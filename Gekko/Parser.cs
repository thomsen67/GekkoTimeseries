/*
    Gekko Timeseries Software (www.t-t.dk/gekko).
    Copyright (C) 2021, Thomas Thomsen, T-T Analyse.

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program (see the file COPYING in the root folder).
    Else, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using System.Text;
using Antlr.Runtime;
using Antlr.Runtime.Tree;
using Antlr.Runtime.Debug;
using Microsoft.CSharp;
using System.CodeDom;
using System.CodeDom.Compiler;
using System.Reflection;
using CT = Antlr.Runtime.Tree.CommonTree;
using System.Windows.Forms;
using System.IO;
using System.Drawing;
using System.Collections;
using System.Security.Cryptography;
using System.Runtime.Serialization.Formatters.Binary;
using System.Runtime.Serialization;
using ProtoBuf;
using ProtoBuf.Meta;

namespace Gekko
{
    
    public enum EEmitType
    {
        bothHumanAndComputerReadable,
        computerReadable,
        humanReadable
    }

    public enum EEquationType
    {
        D,
        G,
        K,
        I,
        S,
        RevertedT,  //table variables that are run after simulation (same as RevertedY, but not technical and shown in doc systems)        
        RevertedY,  //technical, typically manual reverted J-factors               
        RevertedP,  //these equations are ignored -- only for use in PREDICT
        RevertedAutoGenerated        
    }

    public static class ParserOLD
    {       

               
        
        public static void ParserFrmHandleVarlist(ModelCommentsHelper modelCommentsHelper)
        {
            StringBuilder varList = null;

            string fileNameTemp = null;
            bool foundInFrm = false;
            if (modelCommentsHelper.cutout_varlist != null && modelCommentsHelper.cutout_varlist.Length > 0)
            {
                foundInFrm = true;
                varList = new StringBuilder(modelCommentsHelper.cutout_varlist);
            }
            else
            {
                //try to find it externally, look also in model path!
                List<string> folders = new List<string>();
                folders.Add(Program.options.folder_model);
                fileNameTemp = Program.FindFile("varlist.dat", folders);
                if (fileNameTemp != null)
                {
                    string s = Program.GetTextFromFileWithWait(fileNameTemp);  //can read an ANSI file without problems
                    s = "varlist$" + "\n" + s; //a bit hacky, just like the string-StringBuilder-StringReader stuff is convoluted. Anyway, not critical code here.
                    varList = new StringBuilder(s);
                }
            }

            if (varList != null && varList.Length > 0)
            {
                string s = Program.UnfoldVariableList(new StringReader(varList.ToString()));
                if (foundInFrm)
                {
                    if (s != null) s = s + " (found inside .frm file)";
                }
                else
                {
                    if (s != null && fileNameTemp != null) s = s + " (" + fileNameTemp + ")";  //should always be != null, but for safety...
                }
                Program.model.modelGekko.modelInfo.varlistStatus = s;
            }
            else
            {
                Program.model.modelGekko.modelInfo.varlistStatus = "Not found inside .frm file or as 'varlist.dat' file";
            }
        }

        
                

        

        


        public static void PrintModelLexerErrors(List<string> errors, List<string> inputFileLines, ParseHelper ph)
        {
            if (Globals.threadIsInProcessOfAborting) return;
            if (false && ph.fileName == null && ph.commandsText == null)
            {
                //NO: this will show for instance a stray '?' in the model file
                //ignore, probably an error dublet
                return;
            }
            Program.StopPipeAndMute(2);
            int number = 0;
            foreach (string s in errors)
            {
                number++;
                if (errors.Count > 1)  //always just one
                {
                    if (number == 1) G.Writeln();
                    G.Writeln("--------------------- error #" + number + " of " + errors.Count + "-----------------");
                    //G.Writeln();
                }
                else G.Writeln();

                string[] ss = s.Split(Globals.parserErrorSeparator);
                int lineNumber = int.Parse(ss[0]) - 1;  //seems 1-based before subtract 1
                int lineNo = lineNumber + 1;  //1-based
                int positionNo = int.Parse(ss[1]) + 1;  //1-based

                string errorMessage = ss[3];
                                
                errorMessage = errorMessage.Replace(@"'\\r\\n'", "<newline>");  //easier to understand

                if (lineNo > inputFileLines.Count)
                {
                    {
                        G.Writeln("*** ERROR: " + errorMessage);
                    }

                    continue;  //doesn't give meaning
                }
                string line = inputFileLines[lineNo - 1];
                int firstWordPosInLine = line.Length - line.TrimStart().Length + 1;

                bool previousLineProbablyCulprit = false;
                if (positionNo == firstWordPosInLine && errorMessage.Contains("no viable"))
                {
                    //get preceding line (or really: statement) -- most probably the culprit.
                    previousLineProbablyCulprit = true;
                }

                string paranthesesError = "";

                if (ph.isOneLinerFromGui == true && lineNo != 1)
                {
                    G.Writeln("*** ERROR: Parsing this line:");
                    G.Writeln("    " + G.ReplaceGlueNew(inputFileLines[0]), Color.Blue);
                    G.Writeln("*** ERROR: " + errorMessage);
                }
                else
                {
                    if (ph.isOneLinerFromGui == false)
                    {
                        string fn = ph.fileName;
                        if (fn == null || fn == "")
                        {
                            G.Writeln("*** ERROR: Parsing user input block, line " + lineNo + " pos " + positionNo);
                        }
                        else
                        {
                            G.Writeln("*** ERROR: Parsing file: " + fn + " line " + lineNo + " pos " + positionNo);
                        }

                        string e2 = errorMessage.Replace("Der blev udløst en undtagelse af typen ", "");
                        G.Writeln("           " + e2);

                    }
                    else
                    {
                        G.Writeln("*** ERROR: Parsing pos " + positionNo + ":  " + errorMessage);
                    }
                    line = line + "  ";  //hack to avoid ending problems.....
                    string lineTemp = line;
                    string line0 = lineTemp.Substring(0, positionNo - 1);
                    string line1 = lineTemp.Substring(positionNo - 1, 1);
                    string line2 = lineTemp.Substring(positionNo - 1 + 1);

                    if (previousLineProbablyCulprit && lineNo > 1)
                    {
                        G.Writeln("    " + "Line " + (lineNo - 1) + " may be the real cause of the problem");
                        string lineBefore = inputFileLines[lineNo - 1 - 1];
                        G.Writeln("    " + "[" + G.IntFormat(lineNo - 1, 4) + "]:" + "   " + G.ReplaceGlueNew(lineBefore), Color.Blue);
                    }

                    G.Write("    " + "[" + G.IntFormat(lineNo, 4) + "]:" + "   " + G.ReplaceGlueNew(line0), Color.Blue);
                    G.Write(G.ReplaceGlueNew(line1), Color.Red);
                    G.Writeln(G.ReplaceGlueNew(line2), Color.Blue);

                    G.Writeln(G.Blanks(positionNo - 1 + 4 + 5 + 5) + "^", Color.Blue);
                    G.Writeln(G.Blanks(positionNo - 1 + 4 + 5 + 5) + "^", Color.Blue);
                    //G.Writeln();
                }

                if (paranthesesError != "") G.Writeln(paranthesesError);
        
            }
            if (errors.Count > 1) G.Writeln("--------------------- end of " + errors.Count + " errors --------------");
        }        

        
        
        
        

        

        

        

        

        
        


        
        

        
        

        

        

        //
        // TODO TODO when adding extension to a file, cast endswith() to lower before checking
        //

        

        
    }

    public class ConvertHelper
    {
        public string code;        
        public List<string> errors;
        public string commandsText;
        //public string codeUFunctions;        
    }

    public class WalkHelper
    {
        public List<string> frmlItems;
        public int frmlItemsCounter = -1;  //incremented for each ASTFRML, so becomes 0 when first ASTFRML is hit.
        public bool print = false;
        public bool printFile = false;
        //public int eqs = 0;
        public List<string> functions = new List<string>();
        //pointers into the tree of equations
        //public List<EquationsHelper> equations = new List<EquationsHelper>();
        //public EquationNode currentRootEquationNode = null;
        public StreamWriter writer = null;
        public PositionInFile positionInFileStart = new PositionInFile();
        public PositionInFile positionInFileEnd = new PositionInFile();
        public string inputFile = "";
        public StringReader inputFileStringReader = null;
        public List<string> inputFileLines = new List<string>();
        public bool afterEncountered = false;
        public bool after2Encountered = false;
        public string modelBlock = "Unnamed";
    }    

    public class PositionInFile
    {
        public int line; //0-based!
        public int charPosition;  //0-based
        public PositionInFile()
        {
            line = -12345;
            charPosition = -12345;
        }
        public void LookForLargerPosition(CT ast)
        {
            if (ast.Line - 1 > this.line) //subtract 1 to make it 0-based
            {
                this.line = ast.Line - 1; //subtract 1 to make it 0-based
                this.charPosition = ast.CharPositionInLine;
            }
            else if (ast.Line - 1 == this.line)  //subtract 1 to make it 0-based
            {
                if (ast.CharPositionInLine > this.charPosition) this.charPosition = ast.CharPositionInLine;
            }
        }
    }

    public class StringBuilder2
    {
        public StringBuilder shortVersion = new StringBuilder();
        public StringBuilder longVersion = new StringBuilder();
        public StringBuilder humanVersion = new StringBuilder();

        public void Append(string s)
        {
            Append(s, 0);
        }

        public void Append(string s, EEmitType which)
        {  //0: all, 1: nonhuman, 2: human
            if (which == EEmitType.bothHumanAndComputerReadable || which == EEmitType.computerReadable)
            {
                shortVersion.Append(s);
                longVersion.Append(s);
            }
            if (which == EEmitType.bothHumanAndComputerReadable || which == EEmitType.humanReadable)
            {
                humanVersion.Append(s);
            }
        }

        public void AppendLine(string s)
        {
            AppendLine(s, 0);
        }

        public void AppendLine(string s, EEmitType which)
        {
            if (which == EEmitType.bothHumanAndComputerReadable || which == EEmitType.computerReadable)
            {
                shortVersion.AppendLine(s);
                longVersion.AppendLine(s);
            }
            if (which == EEmitType.bothHumanAndComputerReadable || which == EEmitType.humanReadable)
            {
                humanVersion.AppendLine(s);
            }
        }
    }
    
    public class ParseHelper
    {
        public bool isOneLinerFromGui = false;
        public string commandsText = null;
        public string fileName = null;
        public bool isModel = false;
    }

    
}
