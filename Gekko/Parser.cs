/*
    Gekko Timeseries Software (www.t-t.dk/gekko).
    Copyright (C) 2021, Thomas Thomsen, T-T Analyse.

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program (see the file COPYING in the root folder).
    Else, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using System.Text;
using Antlr.Runtime;
using Antlr.Runtime.Tree;
using Antlr.Runtime.Debug;
using Microsoft.CSharp;
using System.CodeDom;
using System.CodeDom.Compiler;
using System.Reflection;
using CT = Antlr.Runtime.Tree.CommonTree;
using System.Windows.Forms;
using System.IO;
using System.Drawing;
using System.Collections;
using System.Security.Cryptography;
using System.Runtime.Serialization.Formatters.Binary;
using System.Runtime.Serialization;
using ProtoBuf;
using ProtoBuf.Meta;

namespace Gekko
{
    
    public enum EEmitType
    {
        bothHumanAndComputerReadable,
        computerReadable,
        humanReadable
    }

    public enum EEquationType
    {
        D,
        G,
        K,
        I,
        S,
        RevertedT,  //table variables that are run after simulation (same as RevertedY, but not technical and shown in doc systems)        
        RevertedY,  //technical, typically manual reverted J-factors               
        RevertedP,  //these equations are ignored -- only for use in PREDICT
        RevertedAutoGenerated        
    }

    public static class ParserOLD
    {       

               
        
        public static void ParserFrmHandleVarlist(ModelCommentsHelper modelCommentsHelper)
        {
            StringBuilder varList = null;

            string fileNameTemp = null;
            bool foundInFrm = false;
            if (modelCommentsHelper.cutout_varlist != null && modelCommentsHelper.cutout_varlist.Length > 0)
            {
                foundInFrm = true;
                varList = new StringBuilder(modelCommentsHelper.cutout_varlist);
            }
            else
            {
                //try to find it externally, look also in model path!
                List<string> folders = new List<string>();
                folders.Add(Program.options.folder_model);
                fileNameTemp = Program.FindFile("varlist.dat", folders);
                if (fileNameTemp != null)
                {
                    string s = Program.GetTextFromFileWithWait(fileNameTemp);  //can read an ANSI file without problems
                    s = "varlist$" + "\n" + s; //a bit hacky, just like the string-StringBuilder-StringReader stuff is convoluted. Anyway, not critical code here.
                    varList = new StringBuilder(s);
                }
            }

            if (varList != null && varList.Length > 0)
            {
                string s = Program.UnfoldVariableList(new StringReader(varList.ToString()));
                if (foundInFrm)
                {
                    if (s != null) s = s + " (found inside .frm file)";
                }
                else
                {
                    if (s != null && fileNameTemp != null) s = s + " (" + fileNameTemp + ")";  //should always be != null, but for safety...
                }
                Program.model.modelGekko.modelInfo.varlistStatus = s;
            }
            else
            {
                Program.model.modelGekko.modelInfo.varlistStatus = "Not found inside .frm file or as 'varlist.dat' file";
            }
        }

        
        public static void PutListsIntoModelListHelper()
        {
            ModelListHelper modelListHelper = new ModelListHelper();

            if (Program.databanks.GetGlobal().ContainsIVariable(Globals.symbolCollection + "all")) modelListHelper.all = Program.GetListOfStringsFromList(Program.databanks.GetGlobal().GetIVariable(Globals.symbolCollection + "all"));
            if (Program.databanks.GetGlobal().ContainsIVariable(Globals.symbolCollection + "endo")) modelListHelper.endo = Program.GetListOfStringsFromList(Program.databanks.GetGlobal().GetIVariable(Globals.symbolCollection + "endo"));
            if (Program.databanks.GetGlobal().ContainsIVariable(Globals.symbolCollection + "exo")) modelListHelper.exo = Program.GetListOfStringsFromList(Program.databanks.GetGlobal().GetIVariable(Globals.symbolCollection + "exo"));
            if (Program.databanks.GetGlobal().ContainsIVariable(Globals.symbolCollection + "exod")) modelListHelper.exod = Program.GetListOfStringsFromList(Program.databanks.GetGlobal().GetIVariable(Globals.symbolCollection + "exod"));
            if (Program.databanks.GetGlobal().ContainsIVariable(Globals.symbolCollection + "exodjz")) modelListHelper.exodjz = Program.GetListOfStringsFromList(Program.databanks.GetGlobal().GetIVariable(Globals.symbolCollection + "exodjz"));
            if (Program.databanks.GetGlobal().ContainsIVariable(Globals.symbolCollection + "exoj")) modelListHelper.exoj = Program.GetListOfStringsFromList(Program.databanks.GetGlobal().GetIVariable(Globals.symbolCollection + "exoj"));
            if (Program.databanks.GetGlobal().ContainsIVariable(Globals.symbolCollection + "exotrue")) modelListHelper.exotrue = Program.GetListOfStringsFromList(Program.databanks.GetGlobal().GetIVariable(Globals.symbolCollection + "exotrue"));
            if (Program.databanks.GetGlobal().ContainsIVariable(Globals.symbolCollection + "exoz")) modelListHelper.exoz = Program.GetListOfStringsFromList(Program.databanks.GetGlobal().GetIVariable(Globals.symbolCollection + "exoz"));

            Program.model.modelGekko.modelInfo.modelListHelper = modelListHelper;
        }

                

        

        


        public static void PrintModelParserErrors(List<string> errors, List<string> inputFileLines, ParseHelper ph)
        {
            if (Globals.threadIsInProcessOfAborting) return;
            Program.StopPipeAndMute(2);
            int number = 0;
            foreach (string s in errors)
            {
                number++;
                if (errors.Count > 1)
                {
                    if (number == 1) G.Writeln();
                    G.Writeln("--------------------- error #" + number + " of " + errors.Count + "-----------------");
                    //G.Writeln();
                }
                else G.Writeln();


                string[] ss = s.Split(Globals.parserErrorSeparator);
                int lineNumber = 0;
                int lineNo = 0;
                int positionNo = 0;
                string errorMessage = "General error";

                try
                {
                    lineNumber = int.Parse(ss[0]) - 1;  //seems 1-based before subtract 1
                    lineNo = lineNumber + 1;  //1-based
                    positionNo = int.Parse(ss[1]) + 1;  //1-based
                    errorMessage = ss[3];
                }
                catch
                {

                }

                if (Globals.addGlue)
                {
                    errorMessage = G.ReplaceGlueNew(errorMessage);
                }                

                if (lineNo > inputFileLines.Count)
                {
                    {
                        G.Writeln2("*** ERROR: " + errorMessage);
                    }

                    continue;  //doesn't give meaning
                }
                string line = "";
                int firstWordPosInLine = -12345;
                bool previousLineProbablyCulprit = false;
                if (lineNo > 0)
                {
                    line = inputFileLines[lineNo - 1];
                    firstWordPosInLine = line.Length - line.TrimStart().Length + 1;
                }

                if (true)
                {
                    if (positionNo == firstWordPosInLine && errorMessage.Contains("no viable"))
                    {
                        //get preceding line (or really: statement) -- most probably the culprit.
                        previousLineProbablyCulprit = true;
                    }

                    if (ph.isOneLinerFromGui == true && lineNo != 1)
                    {
                        G.Writeln("*** ERROR: Parsing this line:");
                        G.Writeln("    " + G.ReplaceGlueNew(inputFileLines[0]), Color.Blue);
                        G.Writeln("*** ERROR: " + errorMessage);
                    }
                    else
                    {
                        if (ph.isOneLinerFromGui == false)
                        {
                            string fn = ph.fileName;
                            string extra = "";
                            if (lineNo >= 1 && positionNo > 0)
                            {
                                extra = " line " + lineNo + " pos " + positionNo;
                            }

                            if (fn == null || fn == "")
                            {
                                G.Writeln("*** ERROR: User input block," + extra);
                            }
                            else
                            {
                                G.Writeln("*** ERROR: Parsing file: " + fn + extra);
                            }
                            G.Writeln("           " + errorMessage);
                        }
                        else
                        {
                            if (positionNo > 0)
                            {
                                G.Writeln("*** ERROR: Parsing pos " + positionNo + ":  " + errorMessage);
                            }
                            else G.Writeln("*** ERROR: " + errorMessage);
                        }
                        line = line + "  ";  //hack to avoid ending problems.....

                        if (positionNo - 1 >= 0)
                        {
                            string lineTemp = line;
                            string line0 = lineTemp.Substring(0, positionNo - 1);
                            string line1 = lineTemp.Substring(positionNo - 1, 1);
                            string line2 = lineTemp.Substring(positionNo - 1 + 1);

                            if (previousLineProbablyCulprit && lineNo > 1)
                            {
                                G.Writeln("    " + "Line " + (lineNo - 1) + " may be the real cause of the problem");
                                string lineBefore = inputFileLines[lineNo - 1 - 1];
                                G.Writeln("    " + "[" + G.IntFormat(lineNo - 1, 4) + "]:" + "   " + G.ReplaceGlueNew(lineBefore), Color.Blue);
                            }

                            G.Write("    " + "[" + G.IntFormat(lineNo, 4) + "]:" + "   " + G.ReplaceGlueNew(line0), Color.Blue);
                            G.Write(G.ReplaceGlueNew(line1), Color.Red);
                            G.Writeln(G.ReplaceGlueNew(line2), Color.Blue);

                            G.Writeln(G.Blanks(positionNo - 1 + 4 + 5 + 5) + "^", Color.Blue);
                            G.Writeln(G.Blanks(positionNo - 1 + 4 + 5 + 5) + "^", Color.Blue);
                            //G.Writeln();
                        }

                    }
                }
                
            }
            if (errors.Count > 1) G.Writeln("--------------------- end of " + errors.Count + " errors --------------");
        }       

        public static void PrintModelLexerErrors(List<string> errors, List<string> inputFileLines, ParseHelper ph)
        {
            if (Globals.threadIsInProcessOfAborting) return;
            if (false && ph.fileName == null && ph.commandsText == null)
            {
                //NO: this will show for instance a stray '?' in the model file
                //ignore, probably an error dublet
                return;
            }
            Program.StopPipeAndMute(2);
            int number = 0;
            foreach (string s in errors)
            {
                number++;
                if (errors.Count > 1)  //always just one
                {
                    if (number == 1) G.Writeln();
                    G.Writeln("--------------------- error #" + number + " of " + errors.Count + "-----------------");
                    //G.Writeln();
                }
                else G.Writeln();

                string[] ss = s.Split(Globals.parserErrorSeparator);
                int lineNumber = int.Parse(ss[0]) - 1;  //seems 1-based before subtract 1
                int lineNo = lineNumber + 1;  //1-based
                int positionNo = int.Parse(ss[1]) + 1;  //1-based

                string errorMessage = ss[3];
                                
                errorMessage = errorMessage.Replace(@"'\\r\\n'", "<newline>");  //easier to understand

                if (lineNo > inputFileLines.Count)
                {
                    {
                        G.Writeln("*** ERROR: " + errorMessage);
                    }

                    continue;  //doesn't give meaning
                }
                string line = inputFileLines[lineNo - 1];
                int firstWordPosInLine = line.Length - line.TrimStart().Length + 1;

                bool previousLineProbablyCulprit = false;
                if (positionNo == firstWordPosInLine && errorMessage.Contains("no viable"))
                {
                    //get preceding line (or really: statement) -- most probably the culprit.
                    previousLineProbablyCulprit = true;
                }

                string paranthesesError = "";

                if (ph.isOneLinerFromGui == true && lineNo != 1)
                {
                    G.Writeln("*** ERROR: Parsing this line:");
                    G.Writeln("    " + G.ReplaceGlueNew(inputFileLines[0]), Color.Blue);
                    G.Writeln("*** ERROR: " + errorMessage);
                }
                else
                {
                    if (ph.isOneLinerFromGui == false)
                    {
                        string fn = ph.fileName;
                        if (fn == null || fn == "")
                        {
                            G.Writeln("*** ERROR: Parsing user input block, line " + lineNo + " pos " + positionNo);
                        }
                        else
                        {
                            G.Writeln("*** ERROR: Parsing file: " + fn + " line " + lineNo + " pos " + positionNo);
                        }

                        string e2 = errorMessage.Replace("Der blev udløst en undtagelse af typen ", "");
                        G.Writeln("           " + e2);

                    }
                    else
                    {
                        G.Writeln("*** ERROR: Parsing pos " + positionNo + ":  " + errorMessage);
                    }
                    line = line + "  ";  //hack to avoid ending problems.....
                    string lineTemp = line;
                    string line0 = lineTemp.Substring(0, positionNo - 1);
                    string line1 = lineTemp.Substring(positionNo - 1, 1);
                    string line2 = lineTemp.Substring(positionNo - 1 + 1);

                    if (previousLineProbablyCulprit && lineNo > 1)
                    {
                        G.Writeln("    " + "Line " + (lineNo - 1) + " may be the real cause of the problem");
                        string lineBefore = inputFileLines[lineNo - 1 - 1];
                        G.Writeln("    " + "[" + G.IntFormat(lineNo - 1, 4) + "]:" + "   " + G.ReplaceGlueNew(lineBefore), Color.Blue);
                    }

                    G.Write("    " + "[" + G.IntFormat(lineNo, 4) + "]:" + "   " + G.ReplaceGlueNew(line0), Color.Blue);
                    G.Write(G.ReplaceGlueNew(line1), Color.Red);
                    G.Writeln(G.ReplaceGlueNew(line2), Color.Blue);

                    G.Writeln(G.Blanks(positionNo - 1 + 4 + 5 + 5) + "^", Color.Blue);
                    G.Writeln(G.Blanks(positionNo - 1 + 4 + 5 + 5) + "^", Color.Blue);
                    //G.Writeln();
                }

                if (paranthesesError != "") G.Writeln(paranthesesError);
        
            }
            if (errors.Count > 1) G.Writeln("--------------------- end of " + errors.Count + " errors --------------");
        }        

        private static void PrintInfoFilesCreateVarsEtc(bool isCalledFromModelStatement)
        {
            //------------------- printing of info files etc. -----------------------------------------------
            if (true)
            {
                ArrayList al = new ArrayList(Program.model.modelGekko.varsAType.Keys);
                al.Sort(StringComparer.InvariantCulture);

                
                List<string> exod = new List<string>();
                List<string> exoj = new List<string>();
                List<string> exoz = new List<string>();
                List<string> exodjz = new List<string>();
                List<string> exo = new List<string>();
                List<string> exotrue = new List<string>();
                List<string> endo = new List<string>();
                List<string> all = new List<string>();

                foreach (string var in al)
                {
                    if (Program.model.modelGekko.m2.endogenous.ContainsKey(var))
                    {
                        Program.model.modelGekko.numberOfEndo++;
                        endo.Add(var);
                    }
                }


                foreach (string var in al)
                {
                    all.Add(var);
                }

                foreach (string var in al)
                {
                    if (!Program.model.modelGekko.m2.endogenous.ContainsKey(var))
                    {
                        exo.Add(var);
                    }
                    if (!Program.model.modelGekko.m2.endogenous.ContainsKey(var) && !Program.model.modelGekko.varsJTypeAutoGenerated.ContainsKey(var) && !Program.model.modelGekko.varsDTypeAutoGenerated.ContainsKey(var) && !Program.model.modelGekko.varsZTypeAutoGenerated.ContainsKey(var))
                    {
                        Program.model.modelGekko.numberOfExo++;
                        exotrue.Add(var);
                    }
                }


                foreach (string var in al)
                {
                    if (Program.model.modelGekko.varsJTypeAutoGenerated.ContainsKey(var) || Program.model.modelGekko.varsDTypeAutoGenerated.ContainsKey(var) || Program.model.modelGekko.varsZTypeAutoGenerated.ContainsKey(var))
                    {
                        Program.model.modelGekko.numberOfDjz++;
                        exodjz.Add(var);
                    }
                    if (Program.model.modelGekko.varsJTypeAutoGenerated.ContainsKey(var))
                    {
                        exoj.Add(var);
                    }
                    if (Program.model.modelGekko.varsDTypeAutoGenerated.ContainsKey(var))
                    {
                        exod.Add(var);
                    }
                    if (Program.model.modelGekko.varsZTypeAutoGenerated.ContainsKey(var))
                    {
                        exoz.Add(var);
                    }
                }

                exod.Sort(StringComparer.InvariantCulture);
                exoj.Sort(StringComparer.InvariantCulture);
                exoz.Sort(StringComparer.InvariantCulture);
                exodjz.Sort(StringComparer.InvariantCulture);
                exo.Sort(StringComparer.InvariantCulture);
                exotrue.Sort(StringComparer.InvariantCulture);
                endo.Sort(StringComparer.InvariantCulture);
                all.Sort(StringComparer.InvariantCulture);
                                
                Program.databanks.GetGlobal().AddIVariableWithOverwrite(Globals.symbolCollection + "exod", new List(Program.GetListOfIVariablesFromListOfStrings(exod.ToArray())));
                Program.databanks.GetGlobal().AddIVariableWithOverwrite(Globals.symbolCollection + "exoj", new List(Program.GetListOfIVariablesFromListOfStrings(exoj.ToArray())));
                Program.databanks.GetGlobal().AddIVariableWithOverwrite(Globals.symbolCollection + "exoz", new List(Program.GetListOfIVariablesFromListOfStrings(exoz.ToArray())));
                Program.databanks.GetGlobal().AddIVariableWithOverwrite(Globals.symbolCollection + "exodjz", new List(Program.GetListOfIVariablesFromListOfStrings(exodjz.ToArray())));
                Program.databanks.GetGlobal().AddIVariableWithOverwrite(Globals.symbolCollection + "exo", new List(Program.GetListOfIVariablesFromListOfStrings(exo.ToArray())));
                Program.databanks.GetGlobal().AddIVariableWithOverwrite(Globals.symbolCollection + "exotrue", new List(Program.GetListOfIVariablesFromListOfStrings(exotrue.ToArray())));
                Program.databanks.GetGlobal().AddIVariableWithOverwrite(Globals.symbolCollection + "endo", new List(Program.GetListOfIVariablesFromListOfStrings(endo.ToArray())));
                Program.databanks.GetGlobal().AddIVariableWithOverwrite(Globals.symbolCollection + "all", new List(Program.GetListOfIVariablesFromListOfStrings(all.ToArray())));
                
                List<string> files = new List<string>();
                files.Add("exod");
                files.Add("exoj");
                files.Add("exoz");
                files.Add("exodjz");
                files.Add("exo");
                files.Add("exotrue");
                files.Add("endo");
                files.Add("all");

                List<List<string>> lists = new List<List<string>>();
                lists.Add(exod);
                lists.Add(exoj);
                lists.Add(exoz);
                lists.Add(exodjz);
                lists.Add(exo);
                lists.Add(exotrue);
                lists.Add(endo);
                lists.Add(all);

                for (int i = 0; i < files.Count; i++)
                {
                    using (FileStream temp = Program.WaitForFileStream(Program.GetModelInfoPath() + "\\" + files[i] + ".lst", Program.GekkoFileReadOrWrite.Write))
                    using (StreamWriter tempFs = G.GekkoStreamWriter(temp))
                    {
                        List<string> oneList = lists[i];
                        foreach (string s in oneList)
                        {
                            tempFs.WriteLine(s);
                        }
                        tempFs.Flush();
                        tempFs.Close();
                    }
                }

                string folder = Program.GetModelInfoPath();  //always a <modelname>__info subfolder to local temp files folder

                if (G.Equal(Program.options.model_infofile, "yes"))
                {
                    string zipFileNameInput = Program.CreateFullPathAndFileName(Globals.modelFileName.Replace(".frm", "") + "__info.zip");
                    Program.WaitForZipWrite(folder, zipFileNameInput);
                }

                //if (isCalledFromModelStatement) G.Writeln("Details regarding model: see " + Path.GetFileName(zipFileNameInput));

            }
        }
        
        
        private static void NewtonStartingValuesFixHelper2(StringBuilder sb)
        {
            sb = sb.Replace("O.Log(", "O.Special_Log(");
            sb = sb.Replace("O.Pow(", "O.Special_Pow(");
        }

        public static void ReferencedAssembliesGekko(CompilerParameters compilerParams)
        {
            if (G.IsUnitTesting())
            {
                //if running test cases, use this absolute path                
                compilerParams.ReferencedAssemblies.Add(Globals.ttPath2 + @"\GekkoCS\Gekko\bin\Debug\gekko.exe");
            }
            else
            {
                compilerParams.ReferencedAssemblies.Add(Application.ExecutablePath);
            }
        }


        

        

        

        
        


        
        

        
        private static bool IsEquationTypeP(string code)
        {
            return G.Equal(code.Substring(0, 1), Globals.equationCodeP);
        }

        private static void PrintEquationCodeWarning(EquationHelper eh)
        {
            if (false)
            {
                //Probably no need to report these
                G.Writeln("+++ WARNING: equation type set to _I for this equation:" + G.NL + eh.equationText);
            }
            return;
        }

        private static void printVariableAsBType(EquationHelper eh, WalkerHelper2 wh2, ModelGekko model, string variable, int lag, bool leftSide, bool humanReadable, bool isModel, bool isBaseBank, string absoluteTime, string namedBank)
        {
            if (EquationIsNotRunAtAll(eh))
            {
                //these equations are not part of the model at all, only used for PREDICT
                //so they are not counted regarding lags, leads, etc.
                if (!leftSide)
                {
                    LongVersionAndHumanVersion(wh2, variable, lag);  //so PREDICT has some code
                }
                return;
            }

            if (isModel)  //for equations in model/frm
            {
                //ATypeData dataA = model.varsAType[variable];
                ATypeData dataA = null; model.varsAType.TryGetValue(variable, out dataA);

                //lag is -1 for fY(-1). It is positive for leads.

                if (dataA == null)
                {
                    dataA = new ATypeData();
                    dataA.aNumber = model.varsAType.Count;
                    dataA.varName = variable;  //only reason to add this is when we want to get the right lower/uppercase of the variable
                    model.varsAType.Add(variable, dataA);
                }
                
                if (true)
                {

                    if (lag < 0)
                    {
                        if (-lag > model.largestLag) model.largestLag = -lag;  //model.largestLag is always 0 or positive
                        if (-lag > eh.largestLag) eh.largestLag = -lag;  //eh.largestLag is always 0 or positive
                    }
                    else if (lag > 0)
                    {
                        if (!EquationIsRunSeparatelyAfterSim(eh))
                        {
                            //not type T, Y, reverted J
                            if (lag > model.largestLeadOutsideRevertedPart) model.largestLeadOutsideRevertedPart = lag;  //model.largestLeadOutsideRevertedPart is always 0 or positive
                            if (!model.leadedVariables.ContainsKey(dataA.aNumber)) model.leadedVariables.Add(dataA.aNumber, 1);  //1 is just artificial
                        }
                        if (lag > model.largestLead) model.largestLead = lag;  //model.largestLead is always 0 or positive                    
                                                                               // --- in the equation ---
                        if (lag > eh.largestLead) eh.largestLead = lag;  //eh.largestLead is always 0 or positive                    
                    }
                }

                string input = variable + Globals.lagIndicator + lag;
                //BTypeData data = (BTypeData)model.varsBType[input];
                BTypeData data = null; model.varsBType.TryGetValue(input, out data);
                if (data == null)
                {
                    data = new BTypeData();
                    data.variable = variable;
                    data.bNumber = model.varsBType.Count;
                    data.lag = lag;
                    //data.equations = new ArrayList();
                    data.leftHandSideEquation = -12345;  //-12345 means none
                    data.aNumber = dataA.aNumber;
                    model.varsBType.Add(input, data);
                    model.varsBTypeInverted.Add(data.bNumber, input);
                }

                //TODO: maybe move test of leftside/rightside out of method to calling method
                if (leftSide == true)
                {
                    string var2 = "";
                    if (lag == 0)
                    {
                        var2 = variable;
                    }
                    else
                    {
                        var2 = variable + "[" + lag + "]";
                    }

                    wh2.leftHandSideHumanReadable.Append(var2);
                    wh2.leftHandSideBNumber = data.bNumber;
                    wh2.leftHandSideCsCodeGauss.Append("b[" + data.bNumber + "]");
                    wh2.leftHandSideCsCodeJacobi.Append("c[" + data.bNumber + "]");

                }
                else
                {
                    //right side
                    //Here we do both the short, long and human version individually

                    if (lag >= 1)
                    {
                        wh2.rightHandSideCsCode.shortVersion.Append("Gekko.Program.Lead(b, " + data.bNumber + ")");
                    }
                    else
                    {
                        //normal way for non-lead variables
                        wh2.rightHandSideCsCode.shortVersion.Append("b[" + data.bNumber + "]");
                    }

                    //This is probably so that equations can be GENR'ed
                    LongVersionAndHumanVersion(wh2, variable, lag);
                }
            }
            else  //for genr and prt statements
            {
                string bank = "databank";
                if (isBaseBank) bank = "baseDatabank";

                if (namedBank != null)
                {
                    //all this stuff is pretty messy, especially for PPLOT and WPLOT (PRT a bit better).
                    //we should merge PRT, PPLOT and WPLOT functionality at some point.
                    //the use of NamedDatabankHelper() is only present when using colons, so it should not
                    //be able to break anything regarding Gekko 1.6 and PRT/PPLOT/WPLOT. Or if it breaks,
                    //it only affects colons.
                    //isBaseBank can not be true here (not legal syntax to mix ':' and @)
                    bank = "Program.NamedDatabankHelper(`" + namedBank + "`, databank)";  //databank is either Work or Base (looping over these)
                }

                string variableSubst = variable;

                if (leftSide)
                {
                    wh2.leftHandSideCsCodeGauss.Append(bank + ".GetVariable(Program.SubstituteAssignVars(" + Globals.QT + variableSubst + Globals.QT + ")).SetData(Program.options.freq, t, data)");
                }
                else
                {
                    if (absoluteTime == null)
                    {
                        if (lag == 0)
                        {
                            //wh2.rightHandSideCsCode.Append(bank + ".GetVariable(Program.SubstituteAssignVars(" + Globals.QT + variableSubst + Globals.QT + ")).GetData(Program.options.freq ,t)");
                            wh2.rightHandSideCsCode.Append("Program.GetData(`" + variableSubst + "`, " + bank + ", t)");
                        }
                        else
                        {
                            //wh2.rightHandSideCsCode.Append(bank + ".GetVariable(Program.SubstituteAssignVars(" + Globals.QT + variableSubst + Globals.QT + ")).GetData(t.CloneAndAdd(" + lag + "))");
                            wh2.rightHandSideCsCode.Append("Program.GetData(`" + variableSubst + "`, " + bank + ", t.Add(" + lag + "))");
                        }
                    }
                    else
                    {
                        GekkoTime t = GekkoTime.FromStringToGekkoTime(absoluteTime);
                        //wh2.rightHandSideCsCode.Append(bank + ".GetVariable(Program.SubstituteAssignVars(" + Globals.QT + variableSubst + Globals.QT + ")).GetData(new GekkoTime(" + t.year + ", " + t.sub + "))");
                        wh2.rightHandSideCsCode.Append("Program.GetData(`" + variableSubst + "`, " + bank + ", new GekkoTime(" + t.super + ", " + t.sub + "))");
                    }
                }

                //dublets are not allowed. TODO: fY and fy can coexist -- find a List<string> doing upper/lowercase
                if (!wh2.allReferencedTimeSeriesOrListsWork.Contains(variable)) wh2.allReferencedTimeSeriesOrListsWork.Add(variable);
                //TODO: prettify all these calls...
                //if (Program.ExtractPrintOptions(helper.prtOption).isMultiplier | useBaseBank == "TRUE")
                if (isBaseBank)
                {
                    if (!wh2.allReferencedTimeSeriesOrListsBase.Contains(variable)) wh2.allReferencedTimeSeriesOrListsBase.Add(variable);
                }
            }
        }

        private static void LongVersionAndHumanVersion(WalkerHelper2 wh2, string variable, int lag)
        {
            wh2.rightHandSideCsCode.longVersion.Append("O.PredictGetValue(`" + variable + "`, gt.Add(" + lag + "))");
            wh2.rightHandSideCsCode.humanVersion.Append(variable + "[" + lag + "]");
        }

        //
        // TODO TODO when adding extension to a file, cast endswith() to lower before checking
        //

        

        
    }

    public class ConvertHelper
    {
        public string code;        
        public List<string> errors;
        public string commandsText;
        //public string codeUFunctions;        
    }

    public class WalkHelper
    {
        public List<string> frmlItems;
        public int frmlItemsCounter = -1;  //incremented for each ASTFRML, so becomes 0 when first ASTFRML is hit.
        public bool print = false;
        public bool printFile = false;
        //public int eqs = 0;
        public List<string> functions = new List<string>();
        //pointers into the tree of equations
        //public List<EquationsHelper> equations = new List<EquationsHelper>();
        //public EquationNode currentRootEquationNode = null;
        public StreamWriter writer = null;
        public PositionInFile positionInFileStart = new PositionInFile();
        public PositionInFile positionInFileEnd = new PositionInFile();
        public string inputFile = "";
        public StringReader inputFileStringReader = null;
        public List<string> inputFileLines = new List<string>();
        public bool afterEncountered = false;
        public bool after2Encountered = false;
        public string modelBlock = "Unnamed";
    }    

    public class PositionInFile
    {
        public int line; //0-based!
        public int charPosition;  //0-based
        public PositionInFile()
        {
            line = -12345;
            charPosition = -12345;
        }
        public void LookForLargerPosition(CT ast)
        {
            if (ast.Line - 1 > this.line) //subtract 1 to make it 0-based
            {
                this.line = ast.Line - 1; //subtract 1 to make it 0-based
                this.charPosition = ast.CharPositionInLine;
            }
            else if (ast.Line - 1 == this.line)  //subtract 1 to make it 0-based
            {
                if (ast.CharPositionInLine > this.charPosition) this.charPosition = ast.CharPositionInLine;
            }
        }
    }

    public class StringBuilder2
    {
        public StringBuilder shortVersion = new StringBuilder();
        public StringBuilder longVersion = new StringBuilder();
        public StringBuilder humanVersion = new StringBuilder();

        public void Append(string s)
        {
            Append(s, 0);
        }

        public void Append(string s, EEmitType which)
        {  //0: all, 1: nonhuman, 2: human
            if (which == EEmitType.bothHumanAndComputerReadable || which == EEmitType.computerReadable)
            {
                shortVersion.Append(s);
                longVersion.Append(s);
            }
            if (which == EEmitType.bothHumanAndComputerReadable || which == EEmitType.humanReadable)
            {
                humanVersion.Append(s);
            }
        }

        public void AppendLine(string s)
        {
            AppendLine(s, 0);
        }

        public void AppendLine(string s, EEmitType which)
        {
            if (which == EEmitType.bothHumanAndComputerReadable || which == EEmitType.computerReadable)
            {
                shortVersion.AppendLine(s);
                longVersion.AppendLine(s);
            }
            if (which == EEmitType.bothHumanAndComputerReadable || which == EEmitType.humanReadable)
            {
                humanVersion.AppendLine(s);
            }
        }
    }
    
    public class ParseHelper
    {
        public bool isOneLinerFromGui = false;
        public string commandsText = null;
        public string fileName = null;
        public bool isModel = false;
    }

    public class WalkerHelper2
    {
        public StringBuilder2 rightHandSideCsCode = new StringBuilder2();
        public StringBuilder leftHandSideCsCodeGauss = new StringBuilder();  // b[117]
        public StringBuilder leftHandSideCsCodeJacobi = new StringBuilder();  // c[117]
        public StringBuilder leftHandSideHumanReadable = new StringBuilder();  //fy
        public int leftHandSideBNumber = -12345;  //only used for model
        public List<string> allReferencedTimeSeriesOrListsWork = new List<string>();  //only used for expressions in cmd
        public List<string> allReferencedTimeSeriesOrListsBase = new List<string>();  //only used for expressions in cmd
        public List<string> problematicFrmlCodes = new List<string>();
        public string frmlCode = "";
        public string leftSideFunction = "";
        public string variableOrFunctionIndicator = "";
        public ASTNodeSimple rhs = null;
        public Dictionary<string, string> vals = null;
    }    
}
