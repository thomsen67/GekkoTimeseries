/*
    Gekko Timeseries Software (www.t-t.dk/gekko).
    Copyright (C) 2021, Thomas Thomsen, T-T Analyse.

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program (see the file COPYING in the root folder).
    Else, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using System.Text;
using Antlr.Runtime;
using Antlr.Runtime.Tree;
using Antlr.Runtime.Debug;
using Microsoft.CSharp;
using System.CodeDom;
using System.CodeDom.Compiler;
using System.Reflection;
using CT = Antlr.Runtime.Tree.CommonTree;
using System.Windows.Forms;
using System.IO;
using System.Drawing;
using System.Collections;
using System.Security.Cryptography;
using System.Runtime.Serialization.Formatters.Binary;
using System.Runtime.Serialization;

namespace Gekko
{
    
    public enum EEmitType
    {
        bothHumanAndComputerReadable,
        computerReadable,
        humanReadable
    }

    public enum EEquationType
    {
        D,
        G,
        K,
        I,
        S,
        RevertedT,  //table variables that are run after simulation (same as RevertedY, but not technical and shown in doc systems)        
        RevertedY,  //technical, typically manual reverted J-factors               
        RevertedP,  //these equations are ignored -- only for use in PREDICT
        RevertedAutoGenerated        
    }

    public static class ParserOLD
    {       

        public static void CreateASTNodesForModel(CT ast, ASTNode equationNode, int depth, WalkHelper wh, ModelGekko model)
        {
            if (ast.Text == "ASTVAL")
            {
                //nothing done here
            }
            if (ast.Text == "ASTMODELBLOCK")
            {
                string s = ast.GetChild(0).Text;
                string[] ss = s.Split(new string[] { "###" }, StringSplitOptions.None);
                wh.modelBlock = ss[1].Trim();  //since it comes from the parser, there are always 2 or 3 elements in ss
                if (wh.modelBlock.Length > 0)
                {
                    //first letter always set to upper-case
                    wh.modelBlock = char.ToUpper(wh.modelBlock[0]) + wh.modelBlock.Substring(1);
                }
            }
            if (ast.Text == "ASTAFTER")
            {
                if (wh.after2Encountered)
                {
                    G.Writeln2("*** ERROR: Expected AFTER$ before AFTER2$ in model");
                    throw new GekkoException();
                }
                if (wh.afterEncountered)
                {
                    G.Writeln2("*** ERROR: It seems there are more than one AFTER$ in model");
                    throw new GekkoException();
                }
                wh.afterEncountered = true;
            }
            if (ast.Text == "ASTAFTER2")
            {
                if (wh.after2Encountered)
                {
                    G.Writeln2("*** ERROR: It seems there are more than one AFTER2$ in model");
                    throw new GekkoException();
                }
                wh.after2Encountered = true;
            }
            equationNode.Text = ast.Text;
            EquationHelper helper = null;
            if (depth == 1 && ast.Text == "ASTFRML")
            {
                wh.frmlItemsCounter++;
                equationNode = new ASTNode(ast.Text);  //the root node for this equation
                equationNode.parent = null;  //has no parent
                helper = new EquationHelper();
                helper.modelBlock = wh.modelBlock;
                helper.equationNumber = model.equations.Count;
                helper.equationsNodeRoot = equationNode;
                //if( helper.isAfterModel
                if (wh.afterEncountered) helper.isAfterModel = true;
                if (wh.after2Encountered) helper.isAfter2Model = true;  //can be both at same time
                model.equations.Add(helper);
                //wh.eqs++;
                wh.positionInFileStart.line = ast.Line - 1; //subtract 1 to make it 0-based
                wh.positionInFileStart.charPosition = ast.CharPositionInLine;
            }

            wh.positionInFileEnd.LookForLargerPosition(ast);

            if (wh.print) for (int i = 0; i < depth; i++) Console.Write("    ");
            if (wh.print) Console.WriteLine(ast.Text);

            if (wh.printFile) for (int i = 0; i < depth; i++) wh.writer.Write("    ");
            if (wh.printFile) wh.writer.WriteLine(ast.Text);

            if (ast.Children == null)
            {
                return;
            }

            int num = ast.Children.Count;
            equationNode.Children = new List<ASTNode>(num);

            //Console.WriteLine();
            for (int i = 0; i < num; ++i)
            {
                CT d = (CT)(ast.Children[i]);
                ASTNode equationNodeChild = new ASTNode(null);  //unknown text
                equationNodeChild.parent = equationNode;
                equationNode.Add(equationNodeChild);
                CreateASTNodesForModel(d, equationNodeChild, depth + 1, wh, model);
                if (i < num - 1)
                {
                    //Console.WriteLine();
                }
            }

            if (depth == 1 && ast.Text == "ASTFRML")
            {
                helper.equationText = wh.frmlItems[wh.frmlItemsCounter];
            }
        }             

        public static void EmitModelFromANTLR(string textInput, string modelName)
        {
            //ParseModel() is reasonably fast. But needs only to be run when new model is called.
            ParseModel(textInput, modelName);  //bool resTypeGaussSeidel = false;
            Program.GuiSetModelName();
        }

        public static void OrderAndCompileModel(ECompiledModelType modelType, bool isCalledFromModelStatement, bool isFix)
        {
            //seems modelType is not used at all
            bool newM2 = false;
            DateTime t0 = DateTime.Now;
            string cacheKey = GetCacheKey(isFix);

            if (Program.model.modelGekko.m2cache.lru.ContainsKey(cacheKey))  //MODEL statement should always issue a real compile, because in that case, Program.model.modelGekko.m2 is newly created
            {
                Program.model.modelGekko.m2 = (Model2)Program.model.modelGekko.m2cache.lru[cacheKey];
                G.WritelnGray("¤¤¤ Got in cache: "+cacheKey);
            }
            else
            {                              
                
                G.WritelnGray("¤¤¤ Has to do .m2 stuff: "+cacheKey);
                newM2 = true;
                Program.model.modelGekko.m2 = new Model2();  //deleting everything here, this is most safe rather than reusing the object
                                
                //this runs very fast
                if (Globals.stackedPrintTimings) G.Writeln2("EndogenizeExogenizeStuff start");
                Program.EndogenizeExogenizeStuff(isFix); //depends upon which endo/exo variables are set
                if (Globals.stackedPrintTimings) G.Writeln2("EndogenizeExogenizeStuff end");
                //takes about 0.6 sec on dec09
                if (Globals.stackedPrintTimings) G.Writeln2("FeedbackOrderingStuff start");
                Program.FeedbackOrderingStuff(modelType, isCalledFromModelStatement); //depends upon which endo/exo variables are set
                if (Globals.stackedPrintTimings) G.Writeln2("FeedbackOrderingStuff end");
            }

            //The .m2 object is in principle recreated each time this method is called (for instance because of ENDO/EXO statement),
            //or with a MODEL statement. But since there is a cache, it will often be found there if it is because of ENDO/EXO.
            //For each modelType (Gauss, GaussFailSafe, Res, Newton, After, Unknown) there is a dedicated .dll in .m2. If
            //this is missing, it will be made in the method below.
            //The way this is done now is more robust, since it will be impossible to obtain a .dll the does not have the
            //corresponding ENDO/EXO vars set. This could be a problem before, for instance doing a ENDO/EXO, and then
            //afterwards Gauss-simulation with failsafe on.
                        
            if (modelType == ECompiledModelType.GaussFailSafe)
            {
                EmitCsCodeAndCompileModel(ECompiledModelType.Gauss, isCalledFromModelStatement);  //This method is only called from here
            }

            //if (Globals.stackedPrintTimings) G.Writeln2("Emit start");
            EmitCsCodeAndCompileModel(modelType, isCalledFromModelStatement);  //This method is only called from here
            //if (Globals.stackedPrintTimings) G.Writeln2("Emit end");

            G.WritelnGray("¤¤¤ Hash: " + cacheKey);

            if (isCalledFromModelStatement) PrintInfoFilesCreateVarsEtc(isCalledFromModelStatement);  //so the "endogenous" are endogenous in original model without ENDO/EXO.

            if (newM2) Program.model.modelGekko.m2cache.lru.Add(cacheKey, Program.model.modelGekko.m2);
        }        

        private static string GetCacheKey(bool isFix)
        {
            //isFix: if active, the endo/exo goals are added as lists
            //       if inactive, the endo/exo goals are always reported as [none] no matter if there ARE goals or not
            //       like this, we can use the same dll for a model with SIM and any endo/exo goals set -- the 
            //       difference only kick in regarding SIM<fix>            
            List<string> temp1 = new List<string>();
            if (isFix) foreach (string s in Program.model.modelGekko.endogenized.Keys) temp1.Add(s.ToLower());
            List<string> temp2 = new List<string>();
            if (isFix) foreach (string s in Program.model.modelGekko.exogenized.Keys) temp2.Add(s.ToLower());
            temp1.Sort();
            temp2.Sort();
            StringBuilder ss = new StringBuilder("ENDO-EXO-info. Endogenized: ");
            foreach (string s in temp1) ss.Append(s + ",");
            if (temp1.Count == 0) ss.Append("[none],");
            ss.Remove(ss.Length - 1, 1);
            ss.Append(". Exogenized: ");
            foreach (string s in temp2) ss.Append(s + ",");
            if (temp2.Count == 0) ss.Append("[none],");
            ss.Remove(ss.Length - 1, 1);
            ss.Append(". ");
            string stacked = "false";
            //if (G.Equal(Program.options.solve_forward_method, "stacked")) stacked = "true";  //stacked is obsolete
            ss.Append("Stacked: " + stacked);            
            return ss.ToString();
        }

        private static void ParseModel(string textInput, string modelName)
        {
            ANTLRStringStream input = new ANTLRStringStream(textInput + "\n");  //a newline for ease of use of ANTLR

            List<string> errors = null;
            CommonTree t = null;

            // Create a lexer attached to that input
            ModelLexer lexer = new ModelLexer(input);
            // Create a stream of tokens pulled from the lexer
            CommonTokenStream tokens = new CommonTokenStream(lexer);
            // Create a parser attached to the token stream
            ModelParser parser = new ModelParser(tokens);
            // Invoke the program rule in get return value
            ModelParser.expr_return r = null;
            DateTime t0 = DateTime.Now;

            //takes 0.5 sec for dec09
            r = parser.expr();

            errors = parser.GetErrors();
            t = (CommonTree)r.Tree;

            if (Globals.printAST)
            {
                AST(t, 0);
            }

            WalkHelper wh = CreateWalkHelper(textInput);
            wh.frmlItems = parser.GetFrmlItems();

            List<string> inputFileLines = wh.inputFileLines;

            ParseHelper ph = new ParseHelper();
            ph.isOneLinerFromGui = false;
            ph.isModel = true;
            ph.fileName = modelName;

            if (errors.Count > 0)
            {
                PrintModelParserErrors(errors, inputFileLines, ph);
                throw new GekkoException();
            }
            else
            {
                //G.Writeln("No errors when parsing");
            }

            GekkoDictionary<string, string> vals = new GekkoDictionary<string, string>(StringComparer.OrdinalIgnoreCase);
            foreach (CT child in t.Children)
            {
                if (child.Text == "ASTVAL")
                {
                    string key = child.GetChild(0).Text;
                    string value = child.GetChild(1).Text;
                    if (child.GetChild(2) != null)
                    {
                        if (G.Equal(child.GetChild(2).Text, "-"))
                        {
                            value = "-" + value;
                        }
                    }

                    if (vals.ContainsKey(key))
                    {
                        G.Writeln2("*** ERROR: Model parsing error: seems VAL '" + key + "' is defined several times.");
                        throw new GekkoException();
                    }
                    else
                    {
                        string key2 = key;
                        if (!key.StartsWith(Globals.symbolScalar.ToString())) key2 = Globals.symbolScalar + key;
                        vals.Add(key2, value);
                    }
                }
            }

            ASTNode equationNode = new ASTNode(null);  //unknown text for now
            wh.print = false;
            //takes 0.1 sec for dec09
            CreateASTNodesForModel(t, equationNode, 0, wh, Program.model.modelGekko); //creates a List<> of equations, with a tree of EquationNodes for each equation

            if (wh.print) wh.writer.Close();

            //TIMING: the rest of this method takes 0.5 sec on dec09, that is nearly as much as parsing and CreateASTNodesForModel()
            //This loop below alone takes 0.5 seconds on dec09, but it also does all the stuff regarding
            //  formula codes DJZ, dlog() on left and right side, broken lags etc. etc. So maybe fair enough it
            //  takes some time. It also writes out actual C# code to be used later on when compiling.

            WalkerHelper2 wh2 = new WalkerHelper2();
            wh2.vals = vals;
            foreach (EquationHelper eh in Program.model.modelGekko.equations)
            {
                //call of recursive method
                wh2.rightHandSideCsCode = new StringBuilder2();  //clearing it for each equation, contains long, short and human versions
                wh2.leftHandSideCsCodeGauss = new StringBuilder();  //clearing it for each equation
                wh2.leftHandSideCsCodeJacobi = new StringBuilder();  //clearing it for each equation
                wh2.leftHandSideHumanReadable = new StringBuilder(); //clearing it for each equation
                EmitCsCodeForModel(eh, eh.equationsNodeRoot, 0, wh2, Program.model.modelGekko, 0, true); //last arg is lag

                if (Globals.printAST) AST2(eh.equationsNodeRoot, 0);

                //TODO: could be nice to also have it human readable, by calling PrintVariable...() with humanReadable=true
                eh.csCodeRhs = wh2.rightHandSideCsCode.shortVersion.ToString();
                eh.csCodeRhsLongVersion = wh2.rightHandSideCsCode.longVersion.ToString();
                eh.csCodeRhsHumanVersion = wh2.rightHandSideCsCode.humanVersion.ToString();

                eh.csCodeLhsGauss = wh2.leftHandSideCsCodeGauss.ToString();
                eh.csCodeLhsJacobi = wh2.leftHandSideCsCodeJacobi.ToString();
                eh.csCodeLhsHuman = wh2.leftHandSideHumanReadable.ToString();
                eh.bNumberLhs = wh2.leftHandSideBNumber;
            }

            //move reverted equations, and compact the others (and renumber them).
            List<EquationHelper> equationsNew = new List<EquationHelper>();
            foreach (EquationHelper eh in Program.model.modelGekko.equations)
            {
                if (EquationIsRunSeparatelyAfterSim(eh))  //will be true for RevertedAutoGenerated too, but these are not created here 
                {
                    eh.equationNumber = Program.model.modelGekko.equationsReverted.Count;
                    Program.model.modelGekko.equationsReverted.Add(eh);
                }
                else if (EquationIsNotRunAtAll(eh))  //will be true for RevertedP, only used n PREDICT
                {
                    eh.equationNumber = Program.model.modelGekko.equationsNotRunAtAll.Count;
                    Program.model.modelGekko.equationsNotRunAtAll.Add(eh);
                }
                else
                {
                    eh.equationNumber = equationsNew.Count;
                    equationsNew.Add(eh);
                }
            }
            Program.model.modelGekko.equations = equationsNew;

            WalkerHelper2 wh3 = new WalkerHelper2();
            wh3.vals = wh2.vals;  //otherwise the will not be available
            foreach (EquationHelper eh in Program.model.modelGekko.equationsReverted)
            {
                //call of recursive method
                wh3.rightHandSideCsCode = new StringBuilder2();  //clearing it for each equation
                wh3.leftHandSideCsCodeGauss = new StringBuilder();  //clearing it for each equation
                wh3.leftHandSideCsCodeJacobi = new StringBuilder();  //clearing it for each equation
                EmitCsCodeForModel(eh, eh.equationsNodeRoot, 0, wh3, Program.model.modelGekko, 0, true);  //last arg is lag
                if (Globals.printAST) AST2(eh.equationsNodeRoot, 0);
                //TODO: could be nice to also have it human readable, by calling PrintVariable...() with humanReadable=true
                eh.csCodeRhs = wh3.rightHandSideCsCode.shortVersion.ToString();
                eh.csCodeRhsLongVersion = wh3.rightHandSideCsCode.longVersion.ToString();
                eh.csCodeLhsGauss = wh3.leftHandSideCsCodeGauss.ToString();
                eh.csCodeLhsJacobi = wh3.leftHandSideCsCodeJacobi.ToString();
                eh.bNumberLhs = wh3.leftHandSideBNumber;
            }
            //-------------------------------------------------------------------------
            
            //---------------------------------------------------------------------------------
            // now model.equations contains real endogenous, and model.equationsReverted contains Y-type and reverted (not real endogenous)

            int nonAfterVars = 0;
            int afterVars = 0;
            int after2Vars = 0;

            foreach (EquationHelper eh in Program.model.modelGekko.equations)
            {
                if (Program.model.modelGekko.endogenousOriginallyInModel.ContainsKey(eh.lhs))
                {
                    G.Writeln2("*** ERROR: when finding endogenous: it seems variable '" + eh.lhs + "' appears multiple times on left-hand side");
                    throw new GekkoException();
                }
                else
                {
                    Program.model.modelGekko.endogenousOriginallyInModel.Add(eh.lhs, "");
                    Program.model.modelGekko.endogenousBNumbersOriginallyInModel.Add(eh.bNumberLhs, "");
                }
                if (EquationIsRunSeparatelyAfterSim(eh)) throw new GekkoException(); //sanity check
                if (EquationIsNotRunAtAll(eh)) throw new GekkoException(); //sanity check
                if (eh.isAfterModel && !eh.isAfter2Model) afterVars++;
                if (eh.isAfter2Model) after2Vars++;
                if (!eh.isAfterModel && !eh.isAfter2Model) nonAfterVars++;
            }

            int sumVars = nonAfterVars + afterVars + after2Vars;

            if (Program.model.modelGekko.fatalEndogenousError)
            {
                //this error should never happen -- should be caught above when checking endogenous
                //just to be 100% sure we are not going on with some inconsistency regarding endogenous vars
                G.Writeln2("*** ERROR: There is a problem with multiple instances of the same endogenous variable");
                throw new GekkoException();
            }

            foreach (EquationHelper eh in Program.model.modelGekko.equations)
            {
                Program.model.modelGekko.fromVariableToEquationNumber.Add(eh.lhsWithLagIndicator, eh.equationNumber);
            }

            foreach (EquationHelper eh in Program.model.modelGekko.equationsReverted)
            {
                if (Program.model.modelGekko.reverted.ContainsKey(eh.lhs))
                {
                    G.Writeln2("*** ERROR: The variable '" + eh.lhs + "' seems to appear as a reverted equation several times.");
                    G.Writeln("           This may be because the variable is both auto-generated by means of formula codes,");
                    G.Writeln("           and added manually.");
                    throw new GekkoException();
                }
                else
                {
                    Program.model.modelGekko.reverted.Add(eh.lhs, "");
                }

                if (!(EquationIsRunSeparatelyAfterSim(eh))) throw new GekkoException(); //sanity check

            }

            //Find dependents for endogenous variables
            //FIXME not working
            //FIXME not working
            //FIXME not working
            //FIXME not working
            //FIXME not working   Edit: HMMM seems to work fine....
            //FIXME not working
            //FIXME not working
            //FIXME not working
            foreach (EquationHelper eh in Program.model.modelGekko.equations)
            {
                foreach (string p in eh.precedentsWithLagIndicator.Keys)
                {
                    string p2 = G.ExtractOnlyVariableIgnoreLag(p);
                    if (Program.model.modelGekko.dependents.ContainsKey(p2))
                    {
                    }
                    else
                    {
                        DependentsHelper d = new DependentsHelper();
                        Program.model.modelGekko.dependents.Add(p2, d);
                    }
                    Dictionary<string, string> yy = Program.model.modelGekko.dependents[p2].storage;
                    if (!yy.ContainsKey(eh.lhs))
                    {
                        yy.Add(eh.lhs, "");
                    }
                }
            }

            int xnumberTotal = Program.model.modelGekko.varsAType.Count;
            int xnumberOfEndo = Program.model.modelGekko.endogenousOriginallyInModel.Count;
            int xnumberOfDjz = Program.model.modelGekko.varsJTypeAutoGenerated.Count + Program.model.modelGekko.varsDTypeAutoGenerated.Count + Program.model.modelGekko.varsZTypeAutoGenerated.Count;
            int xnumberOfExoTrue = xnumberTotal - xnumberOfEndo - xnumberOfDjz;

            Program.model.modelGekko.modelInfo.total = xnumberTotal;
            Program.model.modelGekko.modelInfo.endo = xnumberOfEndo;
            Program.model.modelGekko.modelInfo.exoTrue = xnumberOfExoTrue;
            Program.model.modelGekko.modelInfo.exoDJZ = xnumberOfDjz;
            Program.model.modelGekko.modelInfo.endo2 = sumVars;
            Program.model.modelGekko.modelInfo.endoNoAfter = nonAfterVars;
            Program.model.modelGekko.modelInfo.endoAfter = afterVars;
            Program.model.modelGekko.modelInfo.endoAfter2 = after2Vars;

            return;
        }

        private static bool EquationIsRunSeparatelyAfterSim(EquationHelper eh)
        {
            return eh.equationType == EEquationType.RevertedAutoGenerated || eh.equationType == EEquationType.RevertedY || eh.equationType == EEquationType.RevertedT;
        }

        private static bool EquationIsNotRunAtAll(EquationHelper eh)
        {
            //a bit of a hack here.
            //problem is that equations are run in different batches during parsing, and 
            //EEquationType.RevertedP is not set from the beginning. Therefore we also test the equation code.
            return eh.equationType == EEquationType.RevertedP || IsEquationTypeP(eh.equationCode);
        }

        public static void PrintModelParserErrors(List<string> errors, List<string> inputFileLines, ParseHelper ph)
        {
            if (Globals.threadIsInProcessOfAborting) return;
            Program.StopPipeAndMute(2);
            int number = 0;
            foreach (string s in errors)
            {
                number++;
                if (errors.Count > 1)
                {
                    if (number == 1) G.Writeln();
                    G.Writeln("--------------------- error #" + number + " of " + errors.Count + "-----------------");
                    //G.Writeln();
                }
                else G.Writeln();


                string[] ss = s.Split(Globals.parserErrorSeparator);
                int lineNumber = 0;
                int lineNo = 0;
                int positionNo = 0;
                string errorMessage = "General error";

                try
                {
                    lineNumber = int.Parse(ss[0]) - 1;  //seems 1-based before subtract 1
                    lineNo = lineNumber + 1;  //1-based
                    positionNo = int.Parse(ss[1]) + 1;  //1-based
                    errorMessage = ss[3];
                }
                catch
                {

                }

                if (Globals.addGlue)
                {
                    errorMessage = G.ReplaceGlueNew(errorMessage);
                }                

                if (lineNo > inputFileLines.Count)
                {
                    {
                        G.Writeln2("*** ERROR: " + errorMessage);
                    }

                    continue;  //doesn't give meaning
                }
                string line = "";
                int firstWordPosInLine = -12345;
                bool previousLineProbablyCulprit = false;
                if (lineNo > 0)
                {
                    line = inputFileLines[lineNo - 1];
                    firstWordPosInLine = line.Length - line.TrimStart().Length + 1;
                }

                if (true)
                {
                    if (positionNo == firstWordPosInLine && errorMessage.Contains("no viable"))
                    {
                        //get preceding line (or really: statement) -- most probably the culprit.
                        previousLineProbablyCulprit = true;
                    }

                    if (ph.isOneLinerFromGui == true && lineNo != 1)
                    {
                        G.Writeln("*** ERROR: Parsing this line:");
                        G.Writeln("    " + G.ReplaceGlueNew(inputFileLines[0]), Color.Blue);
                        G.Writeln("*** ERROR: " + errorMessage);
                    }
                    else
                    {
                        if (ph.isOneLinerFromGui == false)
                        {
                            string fn = ph.fileName;
                            string extra = "";
                            if (lineNo >= 1 && positionNo > 0)
                            {
                                extra = " line " + lineNo + " pos " + positionNo;
                            }

                            if (fn == null || fn == "")
                            {
                                G.Writeln("*** ERROR: User input block," + extra);
                            }
                            else
                            {
                                G.Writeln("*** ERROR: Parsing file: " + fn + extra);
                            }
                            G.Writeln("           " + errorMessage);
                        }
                        else
                        {
                            if (positionNo > 0)
                            {
                                G.Writeln("*** ERROR: Parsing pos " + positionNo + ":  " + errorMessage);
                            }
                            else G.Writeln("*** ERROR: " + errorMessage);
                        }
                        line = line + "  ";  //hack to avoid ending problems.....

                        if (positionNo - 1 >= 0)
                        {
                            string lineTemp = line;
                            string line0 = lineTemp.Substring(0, positionNo - 1);
                            string line1 = lineTemp.Substring(positionNo - 1, 1);
                            string line2 = lineTemp.Substring(positionNo - 1 + 1);

                            if (previousLineProbablyCulprit && lineNo > 1)
                            {
                                G.Writeln("    " + "Line " + (lineNo - 1) + " may be the real cause of the problem");
                                string lineBefore = inputFileLines[lineNo - 1 - 1];
                                G.Writeln("    " + "[" + G.IntFormat(lineNo - 1, 4) + "]:" + "   " + G.ReplaceGlueNew(lineBefore), Color.Blue);
                            }

                            G.Write("    " + "[" + G.IntFormat(lineNo, 4) + "]:" + "   " + G.ReplaceGlueNew(line0), Color.Blue);
                            G.Write(G.ReplaceGlueNew(line1), Color.Red);
                            G.Writeln(G.ReplaceGlueNew(line2), Color.Blue);

                            G.Writeln(G.Blanks(positionNo - 1 + 4 + 5 + 5) + "^", Color.Blue);
                            G.Writeln(G.Blanks(positionNo - 1 + 4 + 5 + 5) + "^", Color.Blue);
                            //G.Writeln();
                        }

                    }
                }
                
            }
            if (errors.Count > 1) G.Writeln("--------------------- end of " + errors.Count + " errors --------------");
        }       

        public static void PrintModelLexerErrors(List<string> errors, List<string> inputFileLines, ParseHelper ph)
        {
            if (Globals.threadIsInProcessOfAborting) return;
            if (false && ph.fileName == null && ph.commandsText == null)
            {
                //NO: this will show for instance a stray '?' in the model file
                //ignore, probably an error dublet
                return;
            }
            Program.StopPipeAndMute(2);
            int number = 0;
            foreach (string s in errors)
            {
                number++;
                if (errors.Count > 1)  //always just one
                {
                    if (number == 1) G.Writeln();
                    G.Writeln("--------------------- error #" + number + " of " + errors.Count + "-----------------");
                    //G.Writeln();
                }
                else G.Writeln();

                string[] ss = s.Split(Globals.parserErrorSeparator);
                int lineNumber = int.Parse(ss[0]) - 1;  //seems 1-based before subtract 1
                int lineNo = lineNumber + 1;  //1-based
                int positionNo = int.Parse(ss[1]) + 1;  //1-based

                string errorMessage = ss[3];
                                
                errorMessage = errorMessage.Replace(@"'\\r\\n'", "<newline>");  //easier to understand

                if (lineNo > inputFileLines.Count)
                {
                    {
                        G.Writeln("*** ERROR: " + errorMessage);
                    }

                    continue;  //doesn't give meaning
                }
                string line = inputFileLines[lineNo - 1];
                int firstWordPosInLine = line.Length - line.TrimStart().Length + 1;

                bool previousLineProbablyCulprit = false;
                if (positionNo == firstWordPosInLine && errorMessage.Contains("no viable"))
                {
                    //get preceding line (or really: statement) -- most probably the culprit.
                    previousLineProbablyCulprit = true;
                }

                string paranthesesError = "";

                if (ph.isOneLinerFromGui == true && lineNo != 1)
                {
                    G.Writeln("*** ERROR: Parsing this line:");
                    G.Writeln("    " + G.ReplaceGlueNew(inputFileLines[0]), Color.Blue);
                    G.Writeln("*** ERROR: " + errorMessage);
                }
                else
                {
                    if (ph.isOneLinerFromGui == false)
                    {
                        string fn = ph.fileName;
                        if (fn == null || fn == "")
                        {
                            G.Writeln("*** ERROR: Parsing user input block, line " + lineNo + " pos " + positionNo);
                        }
                        else
                        {
                            G.Writeln("*** ERROR: Parsing file: " + fn + " line " + lineNo + " pos " + positionNo);
                        }

                        string e2 = errorMessage.Replace("Der blev udløst en undtagelse af typen ", "");
                        G.Writeln("           " + e2);

                    }
                    else
                    {
                        G.Writeln("*** ERROR: Parsing pos " + positionNo + ":  " + errorMessage);
                    }
                    line = line + "  ";  //hack to avoid ending problems.....
                    string lineTemp = line;
                    string line0 = lineTemp.Substring(0, positionNo - 1);
                    string line1 = lineTemp.Substring(positionNo - 1, 1);
                    string line2 = lineTemp.Substring(positionNo - 1 + 1);

                    if (previousLineProbablyCulprit && lineNo > 1)
                    {
                        G.Writeln("    " + "Line " + (lineNo - 1) + " may be the real cause of the problem");
                        string lineBefore = inputFileLines[lineNo - 1 - 1];
                        G.Writeln("    " + "[" + G.IntFormat(lineNo - 1, 4) + "]:" + "   " + G.ReplaceGlueNew(lineBefore), Color.Blue);
                    }

                    G.Write("    " + "[" + G.IntFormat(lineNo, 4) + "]:" + "   " + G.ReplaceGlueNew(line0), Color.Blue);
                    G.Write(G.ReplaceGlueNew(line1), Color.Red);
                    G.Writeln(G.ReplaceGlueNew(line2), Color.Blue);

                    G.Writeln(G.Blanks(positionNo - 1 + 4 + 5 + 5) + "^", Color.Blue);
                    G.Writeln(G.Blanks(positionNo - 1 + 4 + 5 + 5) + "^", Color.Blue);
                    //G.Writeln();
                }

                if (paranthesesError != "") G.Writeln(paranthesesError);
        
            }
            if (errors.Count > 1) G.Writeln("--------------------- end of " + errors.Count + " errors --------------");
        }        

        private static void PrintInfoFilesCreateVarsEtc(bool isCalledFromModelStatement)
        {
            //------------------- printing of info files etc. -----------------------------------------------
            if (true)
            {
                ArrayList al = new ArrayList(Program.model.modelGekko.varsAType.Keys);
                al.Sort(StringComparer.InvariantCulture);

                
                List<string> exod = new List<string>();
                List<string> exoj = new List<string>();
                List<string> exoz = new List<string>();
                List<string> exodjz = new List<string>();
                List<string> exo = new List<string>();
                List<string> exotrue = new List<string>();
                List<string> endo = new List<string>();
                List<string> all = new List<string>();

                foreach (string var in al)
                {
                    if (Program.model.modelGekko.m2.endogenous.ContainsKey(var))
                    {
                        Program.model.modelGekko.numberOfEndo++;
                        endo.Add(var);
                    }
                }


                foreach (string var in al)
                {
                    all.Add(var);
                }

                foreach (string var in al)
                {
                    if (!Program.model.modelGekko.m2.endogenous.ContainsKey(var))
                    {
                        exo.Add(var);
                    }
                    if (!Program.model.modelGekko.m2.endogenous.ContainsKey(var) && !Program.model.modelGekko.varsJTypeAutoGenerated.ContainsKey(var) && !Program.model.modelGekko.varsDTypeAutoGenerated.ContainsKey(var) && !Program.model.modelGekko.varsZTypeAutoGenerated.ContainsKey(var))
                    {
                        Program.model.modelGekko.numberOfExo++;
                        exotrue.Add(var);
                    }
                }


                foreach (string var in al)
                {
                    if (Program.model.modelGekko.varsJTypeAutoGenerated.ContainsKey(var) || Program.model.modelGekko.varsDTypeAutoGenerated.ContainsKey(var) || Program.model.modelGekko.varsZTypeAutoGenerated.ContainsKey(var))
                    {
                        Program.model.modelGekko.numberOfDjz++;
                        exodjz.Add(var);
                    }
                    if (Program.model.modelGekko.varsJTypeAutoGenerated.ContainsKey(var))
                    {
                        exoj.Add(var);
                    }
                    if (Program.model.modelGekko.varsDTypeAutoGenerated.ContainsKey(var))
                    {
                        exod.Add(var);
                    }
                    if (Program.model.modelGekko.varsZTypeAutoGenerated.ContainsKey(var))
                    {
                        exoz.Add(var);
                    }
                }

                exod.Sort(StringComparer.InvariantCulture);
                exoj.Sort(StringComparer.InvariantCulture);
                exoz.Sort(StringComparer.InvariantCulture);
                exodjz.Sort(StringComparer.InvariantCulture);
                exo.Sort(StringComparer.InvariantCulture);
                exotrue.Sort(StringComparer.InvariantCulture);
                endo.Sort(StringComparer.InvariantCulture);
                all.Sort(StringComparer.InvariantCulture);
                                
                Program.databanks.GetGlobal().AddIVariableWithOverwrite(Globals.symbolCollection + "exod", new List(Program.GetListOfIVariablesFromListOfStrings(exod.ToArray())));
                Program.databanks.GetGlobal().AddIVariableWithOverwrite(Globals.symbolCollection + "exoj", new List(Program.GetListOfIVariablesFromListOfStrings(exoj.ToArray())));
                Program.databanks.GetGlobal().AddIVariableWithOverwrite(Globals.symbolCollection + "exoz", new List(Program.GetListOfIVariablesFromListOfStrings(exoz.ToArray())));
                Program.databanks.GetGlobal().AddIVariableWithOverwrite(Globals.symbolCollection + "exodjz", new List(Program.GetListOfIVariablesFromListOfStrings(exodjz.ToArray())));
                Program.databanks.GetGlobal().AddIVariableWithOverwrite(Globals.symbolCollection + "exo", new List(Program.GetListOfIVariablesFromListOfStrings(exo.ToArray())));
                Program.databanks.GetGlobal().AddIVariableWithOverwrite(Globals.symbolCollection + "exotrue", new List(Program.GetListOfIVariablesFromListOfStrings(exotrue.ToArray())));
                Program.databanks.GetGlobal().AddIVariableWithOverwrite(Globals.symbolCollection + "endo", new List(Program.GetListOfIVariablesFromListOfStrings(endo.ToArray())));
                Program.databanks.GetGlobal().AddIVariableWithOverwrite(Globals.symbolCollection + "all", new List(Program.GetListOfIVariablesFromListOfStrings(all.ToArray())));
                
                List<string> files = new List<string>();
                files.Add("exod");
                files.Add("exoj");
                files.Add("exoz");
                files.Add("exodjz");
                files.Add("exo");
                files.Add("exotrue");
                files.Add("endo");
                files.Add("all");

                List<List<string>> lists = new List<List<string>>();
                lists.Add(exod);
                lists.Add(exoj);
                lists.Add(exoz);
                lists.Add(exodjz);
                lists.Add(exo);
                lists.Add(exotrue);
                lists.Add(endo);
                lists.Add(all);

                for (int i = 0; i < files.Count; i++)
                {
                    using (FileStream temp = Program.WaitForFileStream(Program.GetModelInfoPath() + "\\" + files[i] + ".lst", Program.GekkoFileReadOrWrite.Write))
                    using (StreamWriter tempFs = G.GekkoStreamWriter(temp))
                    {
                        List<string> oneList = lists[i];
                        foreach (string s in oneList)
                        {
                            tempFs.WriteLine(s);
                        }
                        tempFs.Flush();
                        tempFs.Close();
                    }
                }

                string folder = Program.GetModelInfoPath();  //always a <modelname>__info subfolder to local temp files folder

                if (G.Equal(Program.options.model_infofile, "yes"))
                {
                    string zipFileNameInput = Program.CreateFullPathAndFileName(Globals.modelFileName.Replace(".frm", "") + "__info.zip");
                    Program.WaitForZipWrite(folder, zipFileNameInput);
                }

                //if (isCalledFromModelStatement) G.Writeln("Details regarding model: see " + Path.GetFileName(zipFileNameInput));

            }
        }
        
        private static void EmitCsCodeAndCompileModel(ECompiledModelType modelType, bool isCalledFromModelStatement)
        {
            DateTime t0 = DateTime.Now;

            bool failSafe = false;
            if (modelType == ECompiledModelType.GaussFailSafe) failSafe = true;
            string failSafeString = "";
            if (failSafe) failSafeString = "FailSafe";

            string type = Enum.GetName(typeof(ECompiledModelType), modelType);
            bool didWork = false;

            // =====
            // ===== Gauss-type
            // =====

            if ((modelType == ECompiledModelType.Gauss && Program.model.modelGekko.m2.assemblyGauss == null) ||
                (modelType == ECompiledModelType.GaussFailSafe && Program.model.modelGekko.m2.assemblyGaussFailSafe == null) ||
                (modelType == ECompiledModelType.Res && Program.model.modelGekko.m2.assemblyRes == null))
            {
                didWork = true;
                StringBuilder codeGauss = new StringBuilder();
                {

                    codeGauss.Append(
                        @"using System;
                using System.Collections.Generic;
                using System.Text;
                namespace Gekko
                {
                public class " + type +
                        @"{
                public static void eqs(double[] b)
                {");                    
                    
                    if (modelType == ECompiledModelType.Res)
                    {
                        codeGauss.AppendLine("double [] c = new double[b.Length];");
                        codeGauss.AppendLine("for (int i5 = 0; i5 < c.Length; i5++)");
                        codeGauss.AppendLine("{");
                        codeGauss.AppendLine("   c[i5]=b[i5];");
                        codeGauss.AppendLine("}");                        
                    }

                    List<EquationHelper> prologue = new List<EquationHelper>();
                    List<EquationHelper> eqs = new List<EquationHelper>();
                    List<EquationHelper> epilogue = new List<EquationHelper>();

                    if (Globals.fastGauss)
                    {
                        foreach (int endoNumber in Program.model.modelGekko.m2.prologue)
                        {
                            EquationHelper eh = Program.model.modelGekko.equations[endoNumber];
                            prologue.Add(eh);
                        }

                        if (Program.options.solve_gauss_reorder)
                        {
                            foreach (int endoNumber in Program.model.modelGekko.m2.simulRecursive)
                            {
                                EquationHelper eh = Program.model.modelGekko.equations[endoNumber];
                                eqs.Add(eh);
                            }

                            foreach (int endoNumber in Program.model.modelGekko.m2.simulFeedback)
                            {
                                EquationHelper eh = Program.model.modelGekko.equations[endoNumber];
                                eqs.Add(eh);
                            }
                        }
                        else
                        {

                            //This is old code: it is checked that the
                            //ArrayList al = new ArrayList();
                            //al.AddRange(Program.model.modelGekko.m2.simulRecursive);
                            //al.AddRange(Program.model.modelGekko.m2.simulFeedback);
                            //SortedList<int, EquationHelper> sorted = new SortedList<int, EquationHelper>();
                            //foreach (int eq in al)
                            //{
                            //    EquationHelper eh = Program.model.modelGekko.equations[eq];
                            //    sorted.Add(eh.equationNumber, eh);
                            //}
                            //for (int i = 0; i < sorted.Count; i++)
                            //{
                            //    eqs.Add(sorted.Values[i]);
                            //}

                            List<int> allSimul = Program.GetLeftsideBNumbers();
                            foreach (int i in allSimul)
                            {
                                eqs.Add(Program.model.modelGekko.equations[i]);
                            }

                        }

                        foreach (int endoNumber in Program.model.modelGekko.m2.epilogue)
                        {
                            EquationHelper eh = Program.model.modelGekko.equations[endoNumber];
                            epilogue.Add(eh);
                        }

                        //G.Writeln(Program.model.modelGekko.equations.Count + " == " + (prologue.Count + eqs.Count + epilogue.Count));
                        if (Program.model.modelGekko.equations.Count - (prologue.Count + eqs.Count + epilogue.Count) != 0) throw new GekkoException();
                    }

                    List<EquationHelper> gaussEquations = Program.model.modelGekko.equations;
                    if (Globals.fastGauss) gaussEquations = eqs;

                    foreach (EquationHelper eh in gaussEquations)
                    {
                        if (modelType == ECompiledModelType.Res)
                        {
                            codeGauss.Append(eh.csCodeLhsJacobi);
                        }
                        else  //Gauss of GaussFailSafe
                        {
                            codeGauss.Append(eh.csCodeLhsGauss);
                        }

                        codeGauss.Append(" = ");
                        codeGauss.AppendLine(eh.csCodeRhs);
                        codeGauss.AppendLine(";");

                        if (modelType == ECompiledModelType.GaussFailSafe)  //cannot be jacobi failsafe...
                        {
                            codeGauss.AppendLine("if(Double.IsInfinity(" + eh.csCodeLhsGauss + ") || Double.IsNaN(" + eh.csCodeLhsGauss + ")) {");
                            codeGauss.AppendLine("Program.model.modelGekko.simulateResults[1] = 12345;");
                            codeGauss.AppendLine("Program.model.modelGekko.simulateResults[2] = " + eh.equationNumber + ";");
                            codeGauss.AppendLine("return;");
                            codeGauss.AppendLine("}");
                        }
                    }

                    codeGauss.AppendLine();
                    codeGauss.AppendLine();


                    if (modelType == ECompiledModelType.Res)
                    {
                        codeGauss.AppendLine("for (int i5 = 0; i5 < c.Length; i5++)");
                        codeGauss.AppendLine("{");
                        codeGauss.AppendLine("   b[i5]=c[i5];");
                        codeGauss.AppendLine("}");
                    }
                    codeGauss.AppendLine(@"}");  //end of eqs()
                    codeGauss.AppendLine(@"" + "}}");  //namespace and class

                    CompilerParameters compilerParams = new CompilerParameters();
                    compilerParams.CompilerOptions = Program.GetCompilerOptions();
                    compilerParams.GenerateInMemory = true;
                    compilerParams.IncludeDebugInformation = false;
                    compilerParams.ReferencedAssemblies.Add("system.dll");
                    ReferencedAssembliesGekko(compilerParams);                    
                    compilerParams.GenerateExecutable = false;                    

                    CompilerResults cr = Globals.iCodeCompiler.CompileAssemblyFromSource(compilerParams, codeGauss.ToString());

                    if (cr.Errors.HasErrors)
                    {
                        G.Writeln2("*** ERROR: model not compiled due to errors while compiling for Gauss-Seidel algorithm.");
                        throw new GekkoException();
                    }
                    if (modelType == ECompiledModelType.Gauss)
                    {
                        //Assembly temp = Assembly.LoadFile(@"c:\Users\Thomas\AppData\Local\Temp\gauss.dll");
                        //Program.model.modelGekko.m2.assemblyGauss = temp.GetType("Gekko." + type);
                        Program.model.modelGekko.m2.assemblyGauss = cr.CompiledAssembly.GetType("Gekko." + type);
                    }
                    else if (modelType == ECompiledModelType.GaussFailSafe)
                    {
                        Program.model.modelGekko.m2.assemblyGaussFailSafe = cr.CompiledAssembly.GetType("Gekko." + type);
                    }
                    else if (modelType == ECompiledModelType.Res)
                    {
                        Program.model.modelGekko.m2.assemblyRes = cr.CompiledAssembly.GetType("Gekko." + type);
                    }
                    else throw new GekkoException();  //must be one of these
                }
            }


            // =====
            // ===== Newton-type
            // =====

            if ((modelType == ECompiledModelType.Newton && Program.model.modelGekko.m2.assemblyNewton == null))
            {
                didWork = true;
                StringBuilder codeNewton = new StringBuilder();
                {
                    codeNewton.AppendLine("using System;");
                    codeNewton.AppendLine("using System.Collections.Generic;");
                    codeNewton.AppendLine("using System.Text;");
                    codeNewton.AppendLine("namespace Gekko");
                    codeNewton.AppendLine("{");
                    codeNewton.AppendLine("public class " + type);
                    codeNewton.AppendLine("{");

                    codeNewton.AppendLine("public static void simulPrologue(double[] b)");
                    codeNewton.AppendLine("{");
                    foreach (int endoNumber in Program.model.modelGekko.m2.simulRecursive)
                    {
                        StringBuilder sb = new StringBuilder();
                        EquationHelper eh = Program.model.modelGekko.equations[endoNumber];
                        sb.Append(eh.csCodeLhsGauss);
                        sb.Append(" = ");
                        sb.AppendLine(eh.csCodeRhs);
                        sb.AppendLine(";");
                        sb.AppendLine();
                        if (Program.options.solve_newton_robust) NewtonStartingValuesFixHelper2(sb);
                        codeNewton.Append(sb);

                    }
                    codeNewton.AppendLine("}");

                    codeNewton.AppendLine("public static void simulFeedbackAll(double[] b, double[] r, double[] scale)");
                    codeNewton.AppendLine("{");

                    for (int i = 0; i < Program.model.modelGekko.m2.simulFeedback.Count; i++)
                    {
                        StringBuilder sb = new StringBuilder();
                        int endoNumber = (int)Program.model.modelGekko.m2.simulFeedback[i];
                        EquationHelper eh = Program.model.modelGekko.equations[endoNumber];
                        sb.Append("r[" + i + "] = ");
                        sb.Append(eh.csCodeLhsGauss);
                        sb.Append(" -( ");
                        sb.AppendLine(eh.csCodeRhs);
                        sb.AppendLine(")");
                        sb.AppendLine(";");
                        sb.AppendLine();
                        if (Program.options.solve_newton_robust) NewtonStartingValuesFixHelper2(sb);
                        codeNewton.Append(sb);
                    }
                    codeNewton.AppendLine("}");


                    codeNewton.AppendLine("public static void simulFeedbackSingle(double[] b, double[] r, int n, double[] scale)");
                    codeNewton.AppendLine("{");
                    codeNewton.AppendLine("switch(n)");
                    codeNewton.AppendLine("{");

                    for (int i = 0; i < Program.model.modelGekko.m2.simulFeedback.Count; i++)
                    {
                        StringBuilder sb = new StringBuilder();
                        int endoNumber = (int)Program.model.modelGekko.m2.simulFeedback[i];
                        EquationHelper eh = Program.model.modelGekko.equations[endoNumber];
                        sb.AppendLine("case " + i + ":");
                        sb.Append("r[" + i + "] = ");
                        sb.Append(eh.csCodeLhsGauss);
                        sb.Append(" -( ");
                        sb.AppendLine(eh.csCodeRhs);
                        sb.AppendLine(" ); ");
                        sb.Append("break;");
                        sb.AppendLine();
                        if (Program.options.solve_newton_robust) NewtonStartingValuesFixHelper2(sb);
                        codeNewton.Append(sb);
                    }
                    codeNewton.AppendLine("}");  //case
                    codeNewton.AppendLine("}");  //method

                    codeNewton.AppendLine("}");  //class
                    codeNewton.AppendLine("}");  //namespace
                    //codeNewton.Flush();
                    //codeNewton.Close();

                    CompilerParameters compilerParams = new CompilerParameters();
                    compilerParams = new CompilerParameters();
                    compilerParams.CompilerOptions = Program.GetCompilerOptions();
                    compilerParams.GenerateInMemory = true;
                    compilerParams.IncludeDebugInformation = false;
                    compilerParams.ReferencedAssemblies.Add("system.dll");
                    //compilerParams.ReferencedAssemblies.Add(Application.ExecutablePath);
                    ReferencedAssembliesGekko(compilerParams);
                    compilerParams.GenerateExecutable = false;
                    string s = codeNewton.ToString();
                    //CompilerResults cr = Program.model.modelGekko.iCodeCompiler.CompileAssemblyFromFile(compilerParams, Globals.localTempFilesLocation + "\\" + type + ".cs");
                    CompilerResults cr = Globals.iCodeCompiler.CompileAssemblyFromSource(compilerParams, s);
                    if (modelType == ECompiledModelType.Newton)
                    {
                        Program.model.modelGekko.m2.assemblyNewton = cr.CompiledAssembly.GetType("Gekko." + type);
                    }
                    else throw new GekkoException();  //must be one of these
                }
            }


            // =====
            // ===== Is always used, both for Gauss and Newton
            // ===== Reverted (auto-JZ and Y-equations) -- put in .model, not .model.m2, because it is common for all EXO/ENDO set.
            // =====

            if ((!failSafe && Program.model.modelGekko.assemblyReverted == null) ||
               (failSafe && Program.model.modelGekko.assemblyRevertedFailSafe == null))
            {

                didWork = true;

                StringBuilder code = new StringBuilder();
                {
                    code.Append(
                        @"using System;
                using System.Collections.Generic;
                using System.Text;
                namespace Gekko
                {
                public class " + "Reverted" + failSafeString +
                        @"{");

                    EmitRevertedEquations(code);  //Same code with and without failsafe. Could maybe introduce failsafe here, for the Y-equations. But never mind for now.
                    //Are static given model, in principle they could be shared for Program.model.modelGekko, and not Program.model.modelGekko.m2 (but maybe not worth the trouble and risk of errors)

                    code.AppendLine("}");  //class
                    code.AppendLine("}");  //namespace

                    CompilerParameters compilerParams = new CompilerParameters();
                    compilerParams = new CompilerParameters();
                    compilerParams.CompilerOptions = Program.GetCompilerOptions();
                    compilerParams.GenerateInMemory = true;
                    compilerParams.IncludeDebugInformation = false;
                    compilerParams.ReferencedAssemblies.Add("system.dll");
                    //compilerParams.ReferencedAssemblies.Add(Application.ExecutablePath);
                    ReferencedAssembliesGekko(compilerParams);
                    compilerParams.GenerateExecutable = false;

                    CompilerResults cr = Globals.iCodeCompiler.CompileAssemblyFromSource(compilerParams, code.ToString());

                    if (cr.Errors.HasErrors)
                    {
                        throw new GekkoException();
                    }

                    if (!failSafe)
                    {
                        Program.model.modelGekko.assemblyReverted = cr.CompiledAssembly.GetType("Gekko.Reverted");
                    }
                    else
                    {
                        Program.model.modelGekko.assemblyRevertedFailSafe = cr.CompiledAssembly.GetType("Gekko.RevertedFailSafe");
                    }
                }
            }

            // =====
            // ===== Is always used, both for Gauss and Newton
            // ===== Prologue/Epilogue (depends upon ENDO/EXO set, so put in .m2)
            // =====

            if ((!failSafe && Program.model.modelGekko.m2.assemblyPrologueEpilogue == null) ||
                (failSafe && Program.model.modelGekko.m2.assemblyPrologueEpilogueFailSafe == null))
            {
                didWork = true;
                StringBuilder code = new StringBuilder();
                {
                    code.Append(
                        @"using System;
                using System.Collections.Generic;
                using System.Text;
                namespace Gekko
                {
                public class " + "PrologueEpilogue" + failSafeString +
                        @"{");

                    EmitPrologue(failSafeString, code);  //=====> but these are not static with endo/exo???
                    EmitEpilogue(failSafeString, code);  //=====> but these are not static with endo/exo???

                    code.AppendLine("}");  //class
                    code.AppendLine("}");  //namespace

                    CompilerParameters compilerParams = new CompilerParameters();
                    compilerParams = new CompilerParameters();
                    compilerParams.CompilerOptions = Program.GetCompilerOptions();
                    compilerParams.GenerateInMemory = true;
                    compilerParams.IncludeDebugInformation = false;
                    compilerParams.ReferencedAssemblies.Add("system.dll");
                    //compilerParams.ReferencedAssemblies.Add(Application.ExecutablePath);
                    ReferencedAssembliesGekko(compilerParams);
                    compilerParams.GenerateExecutable = false;

                    CompilerResults cr = Globals.iCodeCompiler.CompileAssemblyFromSource(compilerParams, code.ToString());

                    if (cr.Errors.HasErrors)
                    {
                        throw new GekkoException();
                    }

                    if (failSafeString == "")
                    {
                        Program.model.modelGekko.m2.assemblyPrologueEpilogue = cr.CompiledAssembly.GetType("Gekko.PrologueEpilogue");
                    }
                    else
                    {
                        Program.model.modelGekko.m2.assemblyPrologueEpilogueFailSafe = cr.CompiledAssembly.GetType("Gekko.PrologueEpilogueFailSafe");
                    }
                }
            }

            // =====
            // ===== After (put in .model, not .model.m2, because it is common for all EXO/ENDO set.)
            // =====
            // TODO: after introduction of M2 object, checking for failsafe here is probably not necessay at all
            if (modelType == ECompiledModelType.After && ((!failSafe && Program.model.modelGekko.assemblyAfter == null) ||
                (failSafe && Program.model.modelGekko.assemblyAfterFailSafe == null)))
            {
                //TODO: does not always have to be done, but for now we just keep it.
                didWork = true;
                StringBuilder code = new StringBuilder();
                {
                    code.Append(
                        @"using System;
                using System.Collections.Generic;
                using System.Text;
                namespace Gekko
                {
                public class " + "After" + failSafeString +
                        @"{");

                    EmitAfter(failSafeString, code);    //Are static given model, after() and after2() methods, , in principle they could be shared for Program.model.modelGekko, and not Program.model.modelGekko.m2 (but maybe not worth the trouble and risk of errors)

                    code.AppendLine("}");  //class
                    code.AppendLine("}");  //namespace

                    CompilerParameters compilerParams = new CompilerParameters();
                    compilerParams = new CompilerParameters();
                    compilerParams.CompilerOptions = Program.GetCompilerOptions();
                    compilerParams.GenerateInMemory = true;
                    compilerParams.IncludeDebugInformation = false;
                    compilerParams.ReferencedAssemblies.Add("system.dll");
                    //compilerParams.ReferencedAssemblies.Add(Application.ExecutablePath);
                    ReferencedAssembliesGekko(compilerParams);
                    compilerParams.GenerateExecutable = false;

                    CompilerResults cr = Globals.iCodeCompiler.CompileAssemblyFromSource(compilerParams, code.ToString());

                    if (cr.Errors.HasErrors)
                    {
                        throw new GekkoException();
                    }

                    if (failSafeString == "")
                    {
                        Program.model.modelGekko.assemblyAfter = cr.CompiledAssembly.GetType("Gekko.After");
                    }
                    else
                    {
                        Program.model.modelGekko.assemblyAfterFailSafe = cr.CompiledAssembly.GetType("Gekko.AfterFailSafe");
                    }
                }
            }  //finished After
            if (didWork)
            {
                string duration = G.SecondsFormat((DateTime.Now - t0).TotalMilliseconds);
                if (isCalledFromModelStatement)
                {
                    Program.model.modelGekko.modelInfo.lastCompileDuration = duration;
                }
                else
                {
                    G.Writeln("Compiling lasted " + duration);
                }
            }
        }

        private static void NewtonStartingValuesFixHelper2(StringBuilder sb)
        {
            sb = sb.Replace("O.Log(", "O.Special_Log(");
            sb = sb.Replace("O.Pow(", "O.Special_Pow(");
        }

        public static void ReferencedAssembliesGekko(CompilerParameters compilerParams)
        {
            if (G.IsUnitTesting())
            {
                //if running test cases, use this absolute path                
                compilerParams.ReferencedAssemblies.Add(Globals.ttPath2 + @"\GekkoCS\Gekko\bin\Debug\gekko.exe");
            }
            else
            {
                compilerParams.ReferencedAssemblies.Add(Application.ExecutablePath);
            }
        }


        private static void EmitEpilogue(string failsafe, StringBuilder codeCommon)
        {
            codeCommon.AppendLine("public static void epilogue(double[] b)");
            codeCommon.AppendLine("{");

            foreach (int endoNumber in Program.model.modelGekko.m2.epilogue)
            {
                EquationHelper eh = Program.model.modelGekko.equations[endoNumber];

                codeCommon.Append(eh.csCodeLhsGauss);
                codeCommon.Append(" = ");
                codeCommon.AppendLine(eh.csCodeRhs);
                codeCommon.AppendLine(";");
                codeCommon.AppendLine();
                if (failsafe != "")
                {
                    codeCommon.AppendLine("if(Double.IsInfinity(" + eh.csCodeLhsGauss + ") || Double.IsNaN(" + eh.csCodeLhsGauss + ")) {");
                    codeCommon.AppendLine("Program.model.modelGekko.simulateResults[1] = 12345;");
                    codeCommon.AppendLine("Program.model.modelGekko.simulateResults[2] = " + eh.equationNumber + ";");
                    codeCommon.AppendLine("return;");
                    codeCommon.AppendLine("}");
                }
            }
            codeCommon.AppendLine("}");
        }

        private static void EmitPrologue(string failsafe, StringBuilder codeCommon)
        {
            codeCommon.AppendLine("public static void prologue(double[] b)");
            codeCommon.AppendLine("{");

            foreach (int endoNumber in Program.model.modelGekko.m2.prologue)
            {
                EquationHelper eh = Program.model.modelGekko.equations[endoNumber];
                codeCommon.Append(eh.csCodeLhsGauss);
                codeCommon.AppendLine(" = ");
                codeCommon.AppendLine(eh.csCodeRhs);
                codeCommon.AppendLine(";");
                codeCommon.AppendLine();

                if (failsafe != "")
                {
                    codeCommon.AppendLine("if(Double.IsInfinity(" + eh.csCodeLhsGauss + ") || Double.IsNaN(" + eh.csCodeLhsGauss + ")) {");
                    codeCommon.AppendLine("Program.model.modelGekko.simulateResults[1] = 12345;");
                    codeCommon.AppendLine("Program.model.modelGekko.simulateResults[2] = " + eh.equationNumber + ";");
                    codeCommon.AppendLine("return;");
                    codeCommon.AppendLine("}");
                }
            }
            codeCommon.AppendLine("}");
        }

        private static void EmitAfter(string failsafe, StringBuilder codeCommon)
        {
            //This is for safety: EmitAfter must not depend upon stuff in .m2!
            Model2 temp = Program.model.modelGekko.m2;
            Program.model.modelGekko.m2 = null;

            try
            {
                int count = 0, count2 = 0;
                codeCommon.AppendLine("public static void after(double[] b) {");
                foreach (EquationHelper eh in Program.model.modelGekko.equations)
                {
                    if (eh.isAfterModel && !eh.isAfter2Model)  //if both are set, it is considered after2
                    {
                        codeCommon.Append(eh.csCodeLhsGauss);
                        codeCommon.Append(" = ");
                        codeCommon.AppendLine(eh.csCodeRhs);
                        codeCommon.AppendLine(";");
                        count++;
                    }
                }
                codeCommon.AppendLine("}");  //end of after()
                codeCommon.AppendLine();

                codeCommon.AppendLine("public static void after2(double[] b) {");
                foreach (EquationHelper eh in Program.model.modelGekko.equations)
                {
                    if (eh.isAfter2Model)  //eh.isAfterModel may or not be true here --> in any case it is considered after2
                    {
                        codeCommon.Append(eh.csCodeLhsGauss);
                        codeCommon.Append(" = ");
                        codeCommon.AppendLine(eh.csCodeRhs);
                        codeCommon.AppendLine(";");
                        count2++;
                    }
                }
                codeCommon.AppendLine("}");  //end of after2()
            }
            catch
            {
                throw;
            }
            finally
            {
                Program.model.modelGekko.m2 = temp;
            }
        }

        private static void EmitRevertedEquations(StringBuilder code)
        {
            //This is for safety: EmitAfter must not depend upon stuff in .m2!
            Model2 temp = Program.model.modelGekko.m2;
            Program.model.modelGekko.m2 = null;

            foreach (EquationHelper eh in Program.model.modelGekko.equationsReverted)
            {
                if (!EquationIsRunSeparatelyAfterSim(eh))
                {
                    //Sanity check: each eq must be either auto, Y, T or L
                    //Should not be possible
                    G.Writeln2("*** ERROR: Model equation code error #843784272449");
                    throw new GekkoException();
                }
            }

            try
            {
                code.AppendLine("public static void revertedAuto(double[] b) {");
                foreach (EquationHelper eh in Program.model.modelGekko.equationsReverted)
                {
                    if (eh.equationType == EEquationType.RevertedAutoGenerated)
                    {
                        code.Append(eh.csCodeLhsGauss);
                        code.Append(" = ");
                        code.AppendLine(eh.csCodeRhs);
                        code.AppendLine(";");
                    }
                }
                code.AppendLine("}");  //end of revertedAuto()

                code.AppendLine("public static void reverted" + Globals.equationCodeY.ToUpper() + "(double[] b) {");
                foreach (EquationHelper eh in Program.model.modelGekko.equationsReverted)
                {
                    if (eh.equationType == EEquationType.RevertedY)
                    {
                        code.Append(eh.csCodeLhsGauss);
                        code.Append(" = ");
                        code.AppendLine(eh.csCodeRhs);
                        code.AppendLine(";");
                    }
                }
                code.AppendLine("}");  //end of revertedY()

                code.AppendLine("public static void reverted" + Globals.equationCodeT.ToUpper() + "(double[] b) {");
                foreach (EquationHelper eh in Program.model.modelGekko.equationsReverted)
                {
                    if (eh.equationType == EEquationType.RevertedT)
                    {
                        code.Append(eh.csCodeLhsGauss);
                        code.Append(" = ");
                        code.AppendLine(eh.csCodeRhs);
                        code.AppendLine(";");
                    }
                }
                code.AppendLine("}");  //end of revertedX()                
            }
            catch
            {
                throw;
            }
            finally
            {
                Program.model.modelGekko.m2 = temp;
            }
        }

        private static WalkHelper CreateWalkHelper(string textInput)
        {
            WalkHelper wh = new WalkHelper();
            wh.print = false;
            wh.printFile = false;
            wh.inputFile = textInput;
            wh.inputFileLines = Program.CreateListOfStringsFromString(wh.inputFile);
            return wh;
        }

        public static void EmitCsCodeForModel(EquationHelper eh, ASTNode equationNode, int depth, WalkerHelper2 wh2, ModelGekko model, int subTreeLag, bool isModel)
        {
            bool visitChildren = true;
            int numberOfRightParentheses = 0;

            if(equationNode==null || equationNode.Text == null)
            {

            }

            switch (equationNode.Text)
            {
                case "ASTFRMLCODE":
                    if (equationNode.Children.Count > 0)
                    {
                        wh2.frmlCode = equationNode.GetChild(0).Text;
                    }
                    visitChildren = false;  //is done
                    break;
                case "ASTLEFTSIDE":
                    ASTNode child = equationNode.GetChild(0);
                    wh2.variableOrFunctionIndicator = child.Text;
                    wh2.leftSideFunction = "";
                    if (wh2.variableOrFunctionIndicator == "ASTSIMPLEFUNCTION")
                    {
                        wh2.leftSideFunction = child.GetChild(0).Text;
                        wh2.variableOrFunctionIndicator = child.GetChild(1).Text;
                    }
                    visitChildren = false;
                    break;
                //case "ASTEXPRESSION":
                //    wh2.rhs = equationNode.GetChild(0);
                //    break;
                case "ASTPOW":
                    {
                        HandlePowFunction(eh, equationNode, depth, wh2, model, subTreeLag, isModel, false);
                        visitChildren = false;
                    }
                    break;
                case "ASTFUNCTION":
                    {
                        //-----------------------------------------
                        //   these are right-hand-side functions
                        //-----------------------------------------
                        string function = equationNode.GetChild(0).Text;
                        int arguments = equationNode.Children.Count - 1;

                        //TODO: do log and exp with nodes

                        bool recognized = false;

                        if (G.Equal(function, "log"))
                        {
                            if (arguments != 1)
                            {
                                G.Writeln2("*** ERROR: Expected log() function with 1 argument");
                                throw new GekkoException();
                            }
                            recognized = true;
                            wh2.rightHandSideCsCode.Append("O.Log(", EEmitType.computerReadable);
                            wh2.rightHandSideCsCode.Append("Log(", EEmitType.humanReadable);
                            numberOfRightParentheses++;
                        }
                        else if (G.Equal(function, "exp"))
                        {
                            if (arguments != 1)
                            {
                                G.Writeln2("*** ERROR: Expected exp() function with 1 argument");
                                throw new GekkoException();
                            }
                            recognized = true;
                            wh2.rightHandSideCsCode.Append("O.Exp(", EEmitType.computerReadable);
                            wh2.rightHandSideCsCode.Append("Exp(", EEmitType.humanReadable);
                            numberOfRightParentheses++;
                        }
                        else if (G.Equal(function, "abs"))
                        {
                            if (arguments != 1)
                            {
                                G.Writeln2("*** ERROR: Expected abs() function with 1 argument");
                                throw new GekkoException();
                            }
                            recognized = true;
                            wh2.rightHandSideCsCode.Append("O.Abs(", EEmitType.computerReadable);
                            wh2.rightHandSideCsCode.Append("Abs(", EEmitType.humanReadable);
                            numberOfRightParentheses++;
                        }
                        else if (G.Equal(function, "dlog") || G.Equal(function, "dlogy"))
                        {
                            int lag = 1;
                            if (G.Equal(function, "dlogy"))
                            {
                                lag = O.CurrentSubperiods();
                                Program.model.modelGekko.subPeriods = lag; //this is used as a safety check, so that if the model is loaded/compiled during one freq, and run during another, we will get an error.
                            }

                            if (arguments != 1)
                            {
                                G.Writeln2("*** ERROR: Expected dlog() function with 1 argument");
                                throw new GekkoException();
                            }
                            recognized = true;
                            //wh2.s.Append("(");
                            //numberOfRightParentheses++;
                            /*
                             *
                             *                         x
                             *                         |
                             *                     ASTFUNCTION
                             *                       /    \
                             *                    dlog    subtree
                             *
                             *                         x
                             *                         |
                             *                     "nothing" (equationNode)
                             *                         |
                             *                        "-" (b)
                             *                       /   \                             *
                             *                      /     ASTLAG (c)
                             *                     /      |    \ \
                             *                    /      /    "-" 1
                             *                ASTFUNCTION (d)
                             *                  /       \
                             *               log (e)   subtree
                             *
                             * */
                            ASTNode subTree = equationNode.GetChild(1);
                            equationNode.Text = "nothing";  //function that does nothing
                            equationNode.Children.Clear();
                            ASTNode b = new ASTNode("-");  //subtraction
                            equationNode.Add(b);
                            ASTNode d = new ASTNode("ASTFUNCTION");
                            ASTNode c = new ASTNode("ASTLAG");
                            b.Children = new List<ASTNode>();
                            b.Add(d);
                            b.Add(c);
                            ASTNode c1 = new ASTNode("-");  //it is a lag
                            ASTNode c2 = new ASTNode(lag.ToString()); //n period lag
                            c.Children = new List<ASTNode>();
                            c.Add(d);
                            c.Add(c1);
                            c.Add(c2);
                            ASTNode e = new ASTNode("log");
                            d.Children = new List<ASTNode>();
                            d.Add(e);
                            d.Add(subTree);
                        }
                        else if (G.Equal(function, "pch") || G.Equal(function, "pchy"))
                        {
                            int lag = 1;
                            if (G.Equal(function, "pchy"))
                            {
                                lag = O.CurrentSubperiods();
                                Program.model.modelGekko.subPeriods = lag; //this is used as a safety check, so that if the model is loaded/compiled during one freq, and run during another, we will get an error.
                            }

                            if (arguments != 1)
                            {
                                G.Writeln2("*** ERROR: Expected pch() function with 1 argument");
                                throw new GekkoException();
                            }
                            recognized = true;
                            //wh2.s.Append("(");
                            //numberOfRightParentheses++;
                            /*
                             *
                             *                         x
                             *                         |
                             *                     ASTFUNCTION
                             *                       /    \
                             *                    pch    subtree
                             *
                             *                         x
                             *                         |
                             *                        "nothing" (equationNode)
                             *                         |
                             *                        "*" (f) --------------------------------- 100
                             *                         |
                             *                         |
                             *                        "-" (g) --------------------------------- 1
                             *                         |
                             *                         |
                             *                        "/" (b)
                             *                       /   \
                             *                      /     ASTLAG (c)
                             *                     /      |    \ \
                             *                    /      /    "-" 1
                             *                  subtree (d)
                             *
                             *
                             *
                             * */
                            ASTNode f = new ASTNode("*", true);
                            ASTNode g = new ASTNode("-", true);
                            f.Add(g);
                            f.Add(new ASTNode("ASTDOUBLE", "100"));
                            ASTNode subTree = equationNode.GetChild(1);
                            equationNode.Text = "nothing";  //function that does nothing
                            equationNode.Children.Clear();
                            ASTNode b = new ASTNode("/", true);  //subtraction
                            g.Add(b);
                            g.Add(new ASTNode("ASTDOUBLE", "1"));
                            equationNode.Add(f);
                            ASTNode d = subTree;
                            ASTNode c = new ASTNode("ASTLAG", true);
                            b.Add(d);
                            b.Add(c);
                            ASTNode c1 = new ASTNode("-");  //it is a lag
                            ASTNode c2 = new ASTNode(lag.ToString()); //n period lag
                            c.Add(d);
                            c.Add(c1);
                            c.Add(c2);
                        }
                        else if (G.Equal(function, "lag"))
                        {
                            if (arguments != 2)
                            {
                                G.Writeln2("*** ERROR: Expected lag() function with 2 arguments");
                                throw new GekkoException();
                            }
                            recognized = true;

                            ASTNode lags = equationNode.GetChild(2);
                            int intLags = GetLags(wh2, function, lags);

                            /*
                           *
                           *                         x
                           *                         |
                           *                     ASTFUNCTION
                           *                       /    \
                           *                    dif     subtree
                           *
                           *                         x
                           *                         |
                           *                     "nothing" (equationNode)
                           *                         |
                           *                          \
                           *                           \                             
                           *                            ASTLAG (c)
                           *                            |    \ \
                           *                           /    "-" 1
                           *                     subtree
                           *
                           *
                           *
                           * */

                            ASTNode subTree = equationNode.GetChild(1);
                            equationNode.Text = "nothing";  //function that does nothing
                            equationNode.Children.Clear();
                            ASTNode c = new ASTNode("ASTLAG");
                            ASTNode c1 = new ASTNode("-"); //it is a lag
                            ASTNode c2 = new ASTNode(intLags.ToString()); //n period lag
                            equationNode.Add(c);
                            c.Children = new List<ASTNode>();
                            c.Add(subTree);
                            c.Add(c1);
                            c.Add(c2);
                        }
                        else if (G.Equal(function, "dif") || G.Equal(function, "diff") || G.Equal(function, "dify") || G.Equal(function, "diffy"))
                        {
                            int lag = 1;
                            if (G.Equal(function, "dify") || G.Equal(function, "diffy"))
                            {
                                lag = O.CurrentSubperiods();
                                Program.model.modelGekko.subPeriods = lag; //this is used as a safety check, so that if the model is loaded/compiled during one freq, and run during another, we will get an error.
                            }

                            if (arguments != 1)
                            {
                                G.Writeln2("*** ERROR: Expected dif() function with 1 argument");
                                throw new GekkoException();
                            }
                            recognized = true;
                            /*
                            *
                            *                         x
                            *                         |
                            *                     ASTFUNCTION
                            *                       /    \
                            *                    dif     subtree
                            *
                            *                         x
                            *                         |
                            *                     "nothing" (equationNode)
                            *                         |
                            *                        "-" (b)
                            *                       /   \                             *
                            *                      /     ASTLAG (c)
                            *                     /      |    \ \
                            *                    /      /    "-" 1
                            *                    subtree
                            *
                            *
                            *
                            * */
                            //wh2.s.Append("(");
                            //numberOfRightParentheses++;
                            // see "dlog" for explanation
                            ASTNode subTree = equationNode.GetChild(1);
                            equationNode.Text = "nothing";  //function that does nothing
                            equationNode.Children.Clear();
                            ASTNode b = new ASTNode("-");//subtraction
                            equationNode.Add(b);
                            ASTNode c = new ASTNode("ASTLAG");
                            b.Children = new List<ASTNode>();
                            b.Add(subTree);
                            b.Add(c);
                            ASTNode c1 = new ASTNode("-"); //it is a lag
                            ASTNode c2 = new ASTNode(lag.ToString()); //n period lag
                            c.Children = new List<ASTNode>();
                            c.Add(subTree);
                            c.Add(c1);
                            c.Add(c2);
                        }
                        else if (G.Equal(function, "movavg") || G.Equal(function, "movsum"))
                        {

                            if (arguments != 2)
                            {
                                G.Writeln2("*** ERROR: Expected " + function + "() function with 2 arguments");
                                throw new GekkoException();
                            }
                            recognized = true;

                            ASTNode lags = equationNode.GetChild(2);

                            int intLags = GetLags(wh2, function, lags);

                            /*
                            *
                            *                         x
                            *                         |
                            *                     ASTFUNCTION
                            *                       /    \
                            *                    dif     subtree
                            *
                            *                         x
                            *                         |
                            *                     "nothing" (equationNode)
                            *                         |
                            *                        "+" (b)
                            *                       /   \                             *
                            *                      /     +
                            *                     /     / \
                            *                    /     /   +
                            *                             / \ 
                            *                               ...
                            *                   subtree
                            *                   left brachnes have ASTLAG
                            *
                            *
                            * */
                            //wh2.s.Append("(");
                            //numberOfRightParentheses++;
                            // see "dlog" for explanation
                            ASTNode subTree = equationNode.GetChild(1);
                            equationNode.Text = "nothing";  //function that does nothing
                            equationNode.Children.Clear();

                            ASTNode container = new Gekko.ASTNode("nothing");
                            container.Children = new List<Gekko.ASTNode>();

                            ASTNode cRightOld = new ASTNode("+"); //addition
                            cRightOld.Children = new List<ASTNode>();

                            container.Add(cRightOld);

                            for (int i = 0; i < intLags - 1; i++)
                            {
                                ASTNode cLeft = new ASTNode("ASTLAG");
                                cLeft.Children = new List<ASTNode>();
                                cLeft.Add(subTree);
                                cLeft.Add(new ASTNode("-"));
                                cLeft.Add(new ASTNode(i.ToString()));

                                ASTNode cRightNew = null;

                                if (i < intLags - 2)
                                {
                                    cRightNew = new ASTNode("+"); //addition
                                    cRightNew.Children = new List<ASTNode>();
                                }
                                else
                                {
                                    cRightNew = new ASTNode("ASTLAG");
                                    cRightNew.Children = new List<ASTNode>();
                                    cRightNew.Add(subTree);
                                    cRightNew.Add(new ASTNode("-"));
                                    cRightNew.Add(new ASTNode((i + 1).ToString()));
                                }
                                cRightOld.Add(cLeft);
                                cRightOld.Add(cRightNew);

                                cRightOld = cRightNew;
                            }

                            if (G.Equal(function, "movsum"))
                            {
                                equationNode.Add(container);
                            }
                            else
                            {
                                ASTNode temp = new ASTNode("/");
                                temp.Children = new List<Gekko.ASTNode>();
                                temp.Add(container);
                                temp.Add(new ASTNode("ASTDOUBLE", intLags.ToString()));
                                equationNode.Add(temp);
                            }
                        }
                        else if (G.Equal(function, "pow"))
                        {
                            if (arguments != 2)
                            {
                                G.Writeln2("*** ERROR: Expected pow() function with 2 arguments");
                                throw new GekkoException();
                            }
                            recognized = true;
                            HandlePowFunction(eh, equationNode, depth, wh2, model, subTreeLag, isModel, true);
                            visitChildren = false;
                        }
                        else if (G.Equal(function, "CES_UC") || G.Equal(function, "CES_XL") || G.Equal(function, "CES_XR") || G.Equal(function, "CES_COSTS") || G.Equal(function, "CES_FACTOR1") || G.Equal(function, "CES_FACTOR2") || G.Equal(function, "CES_AC"))
                        {
                            //See #09875209837532
                            recognized = true;
                            wh2.rightHandSideCsCode.Append("Functions." + function + "(", EEmitType.computerReadable);
                            wh2.rightHandSideCsCode.Append(function, EEmitType.humanReadable);
                            numberOfRightParentheses++;
                        }

                        if (recognized == false)
                        {
                            //Se also #09835742345
                            G.Writeln2(G.ReplaceGlueNew(eh.equationText), Color.Red);
                            G.Writeln2("*** ERROR: Function '" + function + "' with " + arguments + " arguments");
                            G.Write("           cannot be recognized (see ", Color.Red);
                            G.WriteLink("functions", "help:" + "i_functions");
                            G.Writeln(")", Color.Red);
                            throw new GekkoException();
                        }
                    }
                    break;
                case "ASTLAG":
                    int lagHere = int.Parse(equationNode.GetChild(2).Text);
                    if (equationNode.GetChild(1).Text == "-")
                    {
                        lagHere = -lagHere;  //keeps sign if it is "+"
                    }
                    else if (equationNode.GetChild(1).Text == "+")
                    {
                        //do nothing
                    }
                    else throw new GekkoException();
                    subTreeLag = subTreeLag + lagHere;  //puts on top of any preexisting lag in this subtree (for instance if y = dif(dif(x))
                    break;
                case "ASTVARIABLE":  //no lag
                    {
                        string variable3 = equationNode.GetChild(0).Text;
                        int lag = 0 + subTreeLag;
                        bool isBaseBank = false;
                        string namedBank = null;
                        if (!isModel)
                        {
                            if (G.Equal(equationNode.GetChild(1).Text, "true"))
                            {
                                isBaseBank = true;
                            }
                            else if (G.Equal(equationNode.GetChild(1).Text, "ASTBANK"))
                            {
                                namedBank = equationNode.GetChild(1).GetChild(0).Text;
                            }
                        }
                        EmitCsDoVariableStuff(eh, wh2, model, isModel, variable3, lag, isBaseBank, null, namedBank);
                        visitChildren = false; //all children are done
                    }
                    break;
                case "ASTVARIABLELAGLEAD":
                    {
                        if (true)
                        {
                            //If it is a broken lag, it looks like this:
                            //
                            //            ASTEXPRESSION
                            //            /
                            //           /
                            //       ASTVARIABLELAGLEAD
                            //       /     /    \      \
                            //      /     /      \      \
                            //     fY    -       0.3    FALSE
                            //
                            // This is converted into:
                            //
                            //                            ASTEXPRESSION
                            //                                /
                            //                               /
                            //                              +
                            //                            /   \
                            //                           /     \
                            //                   --------       ------------
                            //                  /                            \
                            //                 /                              \
                            //                *                                *
                            //               / \                              / \
                            //              /   \                            /   \
                            //             /    ASTDOUBLE                   /    ASTDOUBLE
                            //            /        0.7                     /        0.3
                            //           /                                /
                            //       ASTVARIABLELAGLEAD               ASTVARIABLELAGLEAD
                            //       /     /    \      \              /     /    \      \
                            //      /     /      \      \            /     /      \      \
                            //     fY    -        0     FALSE       fY    -        1     FALSE

                            string namedBank = null;
                            bool isBaseBank2 = false;
                            if (!isModel)
                            {
                                if (G.Equal(equationNode.GetChild(3).Text, "true"))
                                {
                                    isBaseBank2 = true;
                                }
                                else if (G.Equal(equationNode.GetChild(3).Text, "ASTBANK"))
                                {
                                    namedBank = equationNode.GetChild(3).GetChild(0).Text;
                                }
                            }

                            string variable2 = equationNode.GetChild(0).Text;

                            
                            double lagDouble = double.NaN;
                            if (!G.TryParseIntoDouble(equationNode.GetChild(2).Text, out lagDouble)) lagDouble = double.NaN;

                            if (equationNode.GetChild(1).Text == "+")
                            {
                                //do nothing
                            }
                            else if (equationNode.GetChild(1).Text == "-")
                            {
                                lagDouble = -lagDouble;
                            }
                            else if (equationNode.GetChild(1).Text == "ABSOLUTE")
                            {
                                //absolute period, e.g. fY(2001q3)
                                if (isModel)
                                {
                                    G.Writeln2("*** ERROR: absolute dates are not allowed in model");
                                    G.Writeln(eh.equationText);
                                    throw new GekkoException();
                                }
                                else
                                {
                                    //an absolute period
                                    string absoluteTime = equationNode.GetChild(2).Text;
                                    EmitCsDoVariableStuff(eh, wh2, model, isModel, variable2, -12345, isBaseBank2, absoluteTime, namedBank);
                                    visitChildren = false; //all children are done
                                    break;
                                }
                            }
                            else throw new GekkoException();
                            lagDouble += subTreeLag;
                            if (Math.Abs(lagDouble - Math.Round(lagDouble)) < Globals.toleranceRegardingBrokenLagsOrLeads)
                            {
                                //a non-broken lag/lead
                                int nonbrokenlag = Convert.ToInt32(lagDouble);
                                double dif = (double)nonbrokenlag - lagDouble;
                                if (Math.Abs(dif) > 0.01d)
                                {
                                    throw new GekkoException();
                                }
                                EmitCsDoVariableStuff(eh, wh2, model, isModel, variable2, nonbrokenlag, isBaseBank2, null, namedBank);
                                visitChildren = false; //all children are done
                            }
                            else
                            {
                                //a broken lag/lead
                                int lowInt = (int)Math.Floor(lagDouble);
                                int highInt = (int)Math.Ceiling(lagDouble);
                                double lambdaHigh = lagDouble - (double)lowInt;
                                double lambdaLow = (double)highInt - lagDouble;
                                ASTNode low = new ASTNode("*", true);
                                ASTNode high = new ASTNode("*", true);
                                ASTNode low1 = new ASTNode("ASTVARIABLELAGLEAD", true);
                                ASTNode low2 = new ASTNode("ASTDOUBLE", "" + lambdaLow);
                                low.Add(low1);
                                low.Add(low2);
                                ASTNode high1 = new ASTNode("ASTVARIABLELAGLEAD", true);
                                ASTNode high2 = new ASTNode("ASTDOUBLE", "" + lambdaHigh);
                                high.Add(high1);
                                high.Add(high2);
                                low1.Add(new ASTNode(equationNode.GetChild(0).Text));  //varname
                                if (lowInt < 0) low1.Add(new ASTNode("-"));
                                else low1.Add(new ASTNode("+"));
                                low1.Add(new ASTNode(Math.Abs(lowInt) + ""));
                                if (isModel == false) low1.Add(new ASTNode(equationNode.GetChild(3).Text));  //if base bank
                                high1.Add(new ASTNode(equationNode.GetChild(0).Text));  //varname
                                if (highInt < 0) high1.Add(new ASTNode("-"));
                                else high1.Add(new ASTNode("+"));
                                high1.Add(new ASTNode(Math.Abs(highInt) + ""));
                                if (isModel == false) high1.Add(new ASTNode(equationNode.GetChild(3).Text));  //if base bank
                                equationNode.Children.Clear();  //stripping children, in order to add the new subtree
                                equationNode.Text = "nothing";  //nothing is done in this node
                                ASTNode plus = new ASTNode("+", true);
                                plus.Add(low);
                                plus.Add(high);
                                equationNode.Add(plus);
                                visitChildren = true; //should continue in the new tree below!
                            }
                        }
                    }
                    break;
                case "NEGATE":
                    wh2.rightHandSideCsCode.Append("-(");
                    numberOfRightParentheses++;
                    break;
                case "ASTDOUBLE":
                    string number1 = equationNode.GetChild(0).Text;
                    if (number1.EndsWith(".")) number1 = number1 + "0";  //otherwise "1." becomes "1.d" which is not allowed
                    wh2.rightHandSideCsCode.Append(number1 + "d", EEmitType.computerReadable);  //d means double, 1 for non-human readable
                    wh2.rightHandSideCsCode.Append(number1, EEmitType.humanReadable);  //2 for human readable
                    break;
                case "ASTASSIGNVAR":
                    //In Gekko 2.0, the var is %x, not #x.
                    string value = HandleModelVal(equationNode, wh2);
                    wh2.rightHandSideCsCode.Append(value + "d", EEmitType.computerReadable);  //d means double, 1 for non-human readable
                    wh2.rightHandSideCsCode.Append(value, EEmitType.humanReadable);  //2 for human readable
                    break;
                case "ASTINTEGER":
                    string number2 = equationNode.GetChild(0).Text;
                    wh2.rightHandSideCsCode.Append(number2 + "d", EEmitType.computerReadable);  //d means double, 1 for non-human readable
                    wh2.rightHandSideCsCode.Append(number2, EEmitType.humanReadable);  //2 for human readable
                    break;
                case "ASTEXPRESSION":
                    //left side variable is also handled here
                    wh2.rightHandSideCsCode.AppendLine("");  //to force a newline
                    eh.precedentsWithLagIndicator = new GekkoDictionary<string, string>(StringComparer.OrdinalIgnoreCase);
                    eh.equationCode = wh2.frmlCode;
                    //left-hand side (e.g. "b[123] =") below
                    printVariableAsBType(eh, wh2, model, wh2.variableOrFunctionIndicator, 0, true, false, isModel, false, null, null);  //no lag //true=leftside //no named bank
                    //wh2.rightHandSideCsCode.Append(" = ");  //added manually later on
                    wh2.rhs = equationNode.GetChild(0);
                    ASTNode rhs = wh2.rhs;
                    eh.lhsWithLagIndicator = wh2.variableOrFunctionIndicator + Globals.lagIndicator + "0";  //lag is 0 on left hand side
                    eh.lhs = wh2.variableOrFunctionIndicator;

                    ASTNode root0 = rhs;
                    ASTNode root1 = root0;  //default value, if it is not changed
                    if (wh2.leftSideFunction == "")
                    {
                        //do nothing
                    }
                    else
                    {
                        //either:
                        // var = exp(...)                   (log)
                        // var = var(-1) * exp(...)         (dlog)
                        // var = var(-1) * (.../100 + 1)    (pch)
                        // var = var(-n) * (.../100 + 1)    (pchy, n=4 or 12)
                        // var = var(-1) + (...)            (dif)
                        /*
                         *                   ASTFUNCTION
                         *
                         *
                         *
                         * */
                        //These are left-hand side functions
                        if (G.Equal(wh2.leftSideFunction, "log"))
                        {
                            root1 = new ASTNode("ASTFUNCTION", "exp");
                            root1.Add(root0);
                        }
                        else if (G.Equal(wh2.leftSideFunction, "dlog") || G.Equal(wh2.leftSideFunction, "dlogy"))
                        {
                            int lag = 1;
                            if (G.Equal(wh2.leftSideFunction, "dlogy"))
                            {
                                lag = O.CurrentSubperiods();
                                Program.model.modelGekko.subPeriods = lag; //this is used as a safety check, so that if the model is loaded/compiled during one freq, and run during another, we will get an error.
                            }
                            root1 = new ASTNode("*", true);
                            ASTNode child1 = new ASTNode("ASTVARIABLELAGLEAD", true);
                            ASTNode child2 = new ASTNode("ASTFUNCTION", true);
                            root1.Add(child1);
                            root1.Add(child2);
                            child1.Add(new ASTNode(eh.lhs));
                            child1.Add(new ASTNode("-"));  //lag
                            child1.Add(new ASTNode(lag.ToString()));  //lag n
                            //for GENR, cannot be a @-variable on left side, so:
                            child1.Add(new ASTNode("FALSE"));  //not baseline bank
                            child2.Add(new ASTNode("exp"));
                            child2.Add(root0);
                        }
                        else if (G.Equal(wh2.leftSideFunction, "pch") || G.Equal(wh2.leftSideFunction, "pchy"))
                        {
                            int lag = 1;
                            if (G.Equal(wh2.leftSideFunction, "pchy"))
                            {
                                lag = O.CurrentSubperiods();
                                Program.model.modelGekko.subPeriods = lag; //this is used as a safety check, so that if the model is loaded/compiled during one freq, and run during another, we will get an error.
                            }
                            root1 = new ASTNode("*", true);
                            ASTNode child1 = new ASTNode("ASTVARIABLELAGLEAD", true);
                            ASTNode child2 = new ASTNode("+", true);
                            root1.Add(child1);
                            root1.Add(child2);
                            child1.Add(new ASTNode(eh.lhs));
                            child1.Add(new ASTNode("-"));  //lag
                            child1.Add(new ASTNode(lag.ToString()));  //lag n
                            //for GENR, cannot be a @-variable on left side, so:
                            child1.Add(new ASTNode("FALSE"));  //not baseline bank
                            ASTNode child21 = new ASTNode("/", true);
                            ASTNode child22 = new ASTNode("ASTDOUBLE", "1.0");
                            child21.Add(root0);
                            child21.Add(new ASTNode("ASTDOUBLE", "100"));
                            child2.Add(child21);
                            child2.Add(child22);
                        }                        
                        else if (G.Equal(wh2.leftSideFunction, "dif") || G.Equal(wh2.leftSideFunction, "diff") || G.Equal(wh2.leftSideFunction, "dify") || G.Equal(wh2.leftSideFunction, "diffy"))
                        {
                            int lag = 1;
                            if (G.Equal(wh2.leftSideFunction, "dify") || G.Equal(wh2.leftSideFunction, "diffy"))
                            {
                                lag = O.CurrentSubperiods();
                                Program.model.modelGekko.subPeriods = lag; //this is used as a safety check, so that if the model is loaded/compiled during one freq, and run during another, we will get an error.
                            }
                            root1 = new ASTNode("+", true);
                            ASTNode child1 = new ASTNode("ASTVARIABLELAGLEAD", true);
                            ASTNode child2 = root0;
                            root1.Add(child1);
                            root1.Add(child2);
                            child1.Add(new ASTNode(eh.lhs));
                            child1.Add(new ASTNode("-"));  //lag
                            child1.Add(new ASTNode(lag.ToString()));  //lag n
                            //for GENR, cannot be a @-variable on left side, so:
                            child1.Add(new ASTNode("FALSE"));  //not baseline bank
                        }
                        else
                        {
                            G.Writeln2("*** ERROR: Function '" + wh2.leftSideFunction + "' cannot be recognized. On left hand side, these");
                            G.Writeln("    functions are supported: log, dlog, pch, dif");
                            throw new GekkoException();
                        }
                    }
                    /** * -------------------------------------------------------------
                     * JRD
                     *                       +
                     *                    /     \
                     *               --- *       \
                     *             /      \       *
                     *       -----*        -     /  \
                     *      /      \      / \   D    Z
                     *  subtree     +    1   D
                     *            /   \
                     *           1    JR
                     *
                     * ------------------------------------------------------------
                     * * J_D
                     *                       +
                     *                    /     \
                     *               --- *       \
                     *             /      \       *
                     *       ---- +        -     /  \
                     *      /      \      / \   D    Z
                     *  subtree     J    1   D
                     *
                     * -------------------------------------------------------------
                     * JR
                     *
                     *       ---- *
                     *      /      \
                     *  subtree     +
                     *            /   \
                     *           1    JR
                     *
                     * * -------------------------------------------------------------
                     *  J_
                     *
                     *       ---- +
                     *      /      \
                     *  subtree     J
                     *
                     * * * -------------------------------------------------------------
                     * __D
                     *                       +
                     *                    /     \
                     *               --- *       \
                     *             /      \       *
                     *       subtree       -     /  \
                     *                    / \   D    Z
                     *                   1   D
                     *
                     *  ------------------------------------------------------------
                     *  NOTE: 1 is really a tree with ASTDOUBLE and child "1.0"
                     *
                     * */
                    ExtractDJZAndEquationTypeFromEquationCode(eh, model, isModel);  //Note: code may be changed to "_i" here
                    string codeError = "";
                    ASTNode root2 = root1;  //default value, without DJZ-vars
                    if (!(EquationIsRunSeparatelyAfterSim(eh) || EquationIsNotRunAtAll(eh)))
                    {
                        //adding J-variables
                        if (G.Equal(eh.equationCodeJ, "j_") || G.Equal(eh.equationCodeJ, "jd"))
                        {
                            eh.equationCodeJadditive = true;
                        }
                        else if (G.Equal(eh.equationCodeJ, "jr"))
                        {
                            eh.equationCodeJmultiplicative = true;
                        }
                        else if (eh.equationCodeJ != "" && eh.equationCodeJ != "__") codeError += "Expected 'J_' or 'JD' or 'JR' in position 3-4 in equation code\n";

                        string jled2 = eh.equationCodeJ.ToUpper();
                        if (G.Equal(jled2, "j_")) jled2 = "J";  //stripping the "_"
                        eh.Jname = jled2 + eh.lhs;
                        //at this point, jled2 may be = "", so eh.Jname is same as eh.lhs.
                        if (eh.equationCodeJmultiplicative)
                        {
                            //multiplicative
                            root2 = new ASTNode("*", true);
                            ASTNode child2 = new ASTNode("+", true);
                            root2.Add(root1);
                            root2.Add(child2);
                            child2.Add(new ASTNode("ASTDOUBLE", "1.0"));
                            child2.Add(new ASTNode("ASTVARIABLE", eh.Jname, "FALSE"));  //cannot be base bank
                            AddToDictionary(model.varsJTypeAutoGenerated, eh.Jname, model);
                        }
                        else if (eh.equationCodeJadditive)
                        {
                            //additive
                            root2 = new ASTNode("+", true);
                            root2.Add(root1);
                            root2.Add(new ASTNode("ASTVARIABLE", eh.Jname, "FALSE"));  //cannot be base bank
                            AddToDictionary(model.varsJTypeAutoGenerated, eh.Jname, model);
                        }
                    }
                    ASTNode root3 = root2;  //default value
                    if (!(EquationIsRunSeparatelyAfterSim(eh) || EquationIsNotRunAtAll(eh)))
                    {
                        //D- and Z-vars, including reverted equations
                        if (G.Equal(eh.equationCodeD, "d"))
                        {
                            root3 = new ASTNode("+", true);
                            eh.Dname = "D" + eh.lhs;
                            eh.Zname = "Z" + eh.lhs;
                            AddToDictionary(model.varsDTypeAutoGenerated, eh.Dname, model);
                            AddToDictionary(model.varsZTypeAutoGenerated, eh.Zname, model);
                            ASTNode child1 = new ASTNode("*", true);
                            ASTNode child2 = new ASTNode("*", true);
                            root3.Add(child1);
                            root3.Add(child2);
                            ASTNode child12 = new ASTNode("-", true);
                            child1.Add(root2);  //this root may have J-factors included
                            child1.Add(child12);
                            child12.Add(new ASTNode("ASTDOUBLE", "1.0"));
                            child12.Add(new ASTNode("ASTVARIABLE", eh.Dname, "FALSE")); //cannot be base bank
                            child2.Add(new ASTNode("ASTVARIABLE", eh.Dname, "FALSE"));  //cannot be base bank
                            child2.Add(new ASTNode("ASTVARIABLE", eh.Zname, "FALSE"));  //cannot be base bank
                            //create reverted equations for J- and Z-variables
                            if (eh.equationCodeJadditive)
                            {
                                //TODO: clean up, reorder, rename, do diagram
                                ASTNode FrmlJ = new ASTNode("ASTFRML", true);  //super-root
                                ASTNode root4 = new ASTNode("-", true);
                                FrmlJ.Add(new ASTNode("ASTFRMLCODE", "AUTOGENERATED"));
                                FrmlJ.Add(new ASTNode("ASTLEFTSIDE", eh.Jname));
                                ASTNode ex = new ASTNode("ASTEXPRESSION", true);
                                ex.Add(root4);
                                FrmlJ.Add(ex);
                                ASTNode child41 = new ASTNode("ASTVARIABLE", eh.lhs);
                                ASTNode child42 = root1;
                                root4.Add(child41);
                                root4.Add(child42);
                                EquationHelper ehJ = new EquationHelper();
                                ehJ.lhs = eh.Jname;
                                ehJ.lhsWithLagIndicator = eh.Jname + Globals.lagIndicator + "0";
                                ehJ.equationType = EEquationType.RevertedAutoGenerated;
                                ehJ.equationsNodeRoot = FrmlJ;
                                ehJ.equationNumber = model.equationsReverted.Count;
                                model.equationsReverted.Add(ehJ);
                            }
                            if (eh.equationCodeJmultiplicative)
                            {
                                //TODO: clean up, reorder, rename, do diagram
                                ASTNode FrmlJR = new ASTNode("ASTFRML", true);  //super-root
                                ASTNode root4 = new ASTNode("-", true);
                                ASTNode root4child = new ASTNode("/", true);
                                root4.Add(root4child);
                                root4.Add(new ASTNode("ASTDOUBLE", "1"));
                                FrmlJR.Add(new ASTNode("ASTFRMLCODE", "AUTOGENERATED"));
                                FrmlJR.Add(new ASTNode("ASTLEFTSIDE", eh.Jname));
                                ASTNode ex = new ASTNode("ASTEXPRESSION", true);
                                ex.Add(root4);
                                FrmlJR.Add(ex);
                                ASTNode child41 = new ASTNode("ASTVARIABLE", eh.lhs);
                                ASTNode child42 = root1;
                                root4child.Add(child41);
                                root4child.Add(child42);
                                EquationHelper ehJR = new EquationHelper();
                                ehJR.lhs = eh.Jname;
                                ehJR.lhsWithLagIndicator = eh.Jname + Globals.lagIndicator + "0";
                                ehJR.equationType = EEquationType.RevertedAutoGenerated;
                                ehJR.equationsNodeRoot = FrmlJR;
                                ehJR.equationNumber = model.equationsReverted.Count;
                                model.equationsReverted.Add(ehJR);
                            }

                            bool z = false;
                            if (Globals.patch_zvar)
                            {
                                //With this patch, we always do the inverted Z-eqation, even if there are no J, JD, or JR. So this may be an FRML _D__D for instance. Then the Z-variable will always be ready after simulation.
                                z = true;
                            }
                            else
                            {
                                if (eh.equationCodeJadditive || eh.equationCodeJmultiplicative)
                                {
                                    z = true;
                                }
                            }

                            if(z)
                            {
                                //TODO: clean up, reorder, rename, do diagram
                                ASTNode FrmlZ = new ASTNode("ASTFRML", true);  //super-root
                                FrmlZ.Add(new ASTNode("ASTFRMLCODE", "AUTOGENERATED"));
                                FrmlZ.Add(new ASTNode("ASTLEFTSIDE", eh.Zname));
                                ASTNode ex = new ASTNode("ASTEXPRESSION", true);
                                ex.Add(new ASTNode("ASTVARIABLE", eh.lhs));
                                FrmlZ.Add(ex);
                                EquationHelper ehZ = new EquationHelper();
                                ehZ.lhs = eh.Zname;
                                ehZ.lhsWithLagIndicator = eh.Zname + Globals.lagIndicator + "0";
                                ehZ.equationType = EEquationType.RevertedAutoGenerated;
                                ehZ.equationsNodeRoot = FrmlZ;
                                ehZ.equationNumber = model.equationsReverted.Count;
                                model.equationsReverted.Add(ehZ);
                            }
                        }
                        else if (eh.equationCodeD == "" || eh.equationCodeD == "_")
                        {
                            //Not autogenerated D- and Z-vars (but we need the reverted J-equation
                            if (eh.equationCodeJadditive)
                            {
                                if (Globals.revertSimpleJ)
                                {
                                    //TODO: clean up, reorder, rename, do diagram
                                    ASTNode FrmlJ = new ASTNode("ASTFRML", true);  //super-root
                                    ASTNode root4 = new ASTNode("-", true);
                                    FrmlJ.Add(new ASTNode("ASTFRMLCODE", "AUTOGENERATED"));
                                    FrmlJ.Add(new ASTNode("ASTLEFTSIDE", eh.Jname));
                                    ASTNode ex = new ASTNode("ASTEXPRESSION", true);
                                    ex.Add(root4);
                                    FrmlJ.Add(ex);
                                    ASTNode child41 = new ASTNode("ASTVARIABLE", eh.lhs);
                                    ASTNode child42 = root1;
                                    root4.Add(child41);
                                    root4.Add(child42);
                                    EquationHelper ehJ = new EquationHelper();
                                    ehJ.lhs = eh.Jname;
                                    ehJ.lhsWithLagIndicator = eh.Jname + Globals.lagIndicator + "0";
                                    ehJ.equationType = EEquationType.RevertedAutoGenerated;
                                    ehJ.equationsNodeRoot = FrmlJ;
                                    ehJ.equationNumber = model.equationsReverted.Count;
                                    model.equationsReverted.Add(ehJ);
                                }
                            }
                            else if (eh.equationCodeJmultiplicative)
                            {
                                if (Globals.revertSimpleJ)
                                {
                                    if (Globals.revertSimpleJ)
                                    {
                                        //TODO: clean up, reorder, rename, do diagram
                                        ASTNode FrmlJR = new ASTNode("ASTFRML", true);  //super-root
                                        ASTNode root4 = new ASTNode("-", true);
                                        ASTNode root4child = new ASTNode("/", true);
                                        root4.Add(root4child);
                                        root4.Add(new ASTNode("ASTDOUBLE", "1"));
                                        FrmlJR.Add(new ASTNode("ASTFRMLCODE", "AUTOGENERATED"));
                                        FrmlJR.Add(new ASTNode("ASTLEFTSIDE", eh.Jname));
                                        ASTNode ex = new ASTNode("ASTEXPRESSION", true);
                                        ex.Add(root4);
                                        FrmlJR.Add(ex);
                                        ASTNode child41 = new ASTNode("ASTVARIABLE", eh.lhs);
                                        ASTNode child42 = root1;
                                        root4child.Add(child41);
                                        root4child.Add(child42);
                                        EquationHelper ehJR = new EquationHelper();
                                        ehJR.lhs = eh.Jname;
                                        ehJR.lhsWithLagIndicator = eh.Jname + Globals.lagIndicator + "0";
                                        ehJR.equationType = EEquationType.RevertedAutoGenerated;
                                        ehJR.equationsNodeRoot = FrmlJR;
                                        ehJR.equationNumber = model.equationsReverted.Count;
                                        model.equationsReverted.Add(ehJR);
                                    }
                                }
                            }


                        }
                        else if (eh.equationCodeD != "" && eh.equationCodeD != "_")
                        {
                            codeError += "Expected 'D' in position 5 in equation code\n";
                        }
                    }

                    if (G.Equal(eh.equationCodeZ, "z"))
                    {
                        //damping should not be done in generated code, not necessary (and dangerous)
                    }
                    else if (eh.equationCodeZ != "" && eh.equationCodeZ != "_") codeError += "Expected 'Z' in position 7 in equation code\n";
                    //put this into tree instead of rhs (root may actually be = rhs if no J- or D-stuff)

                    equationNode.Children[0] = root3;

                    if (codeError != "")
                    {
                        G.Writeln2("*** ERROR regarding equation code in '" + eh.lhs + "' equation");
                        G.Writeln(eh.equationText);
                        G.Writeln2("*** ERROR: equation code");
                        throw new GekkoException();
                    }
                    break;

            }

            //------------- for testing ------------------
            bool sameParenthesesInMachineCodeAsInHumanReadableCode = false; //should be false for safety, used to test if the human code parantheses are ok (not too many removed)
            //--------------------------------------------

            if (visitChildren == true && equationNode.Children != null)
            {
                int num = equationNode.Children.Count;
                for (int i = 0; i < num; ++i)
                {
                    ASTNode equationNodeChild = equationNode.Children[i];
                    bool last2 = false;
                    if (i == equationNode.Children.Count - 1) last2 = true;
                    bool first2 = false;
                    if (i == 0) first2 = true;

                    {
                        //------------------ before each child ----------------
                        switch (equationNode.Text)
                        {
                            case "*":
                            case "+":
                            case "-":
                            case "/":
                            case "%":
                                if (!sameParenthesesInMachineCodeAsInHumanReadableCode) wh2.rightHandSideCsCode.Append("(", EEmitType.computerReadable);
                                break;
                        }

                        bool setHumanParenthesis = false;
                        switch (equationNode.Text)
                        {

                            case "*":
                            case "/":
                            case "-":
                            case "+":
                            case "%":
                                setHumanParenthesis = true;
                                break;
                        }


                        //------------------ before each child ----------------
                        switch (equationNode.Text)
                        {
                            case "*":
                                if (equationNodeChild.Text == "*" || equationNodeChild.Text == "/") setHumanParenthesis = false;
                                break;
                            case "/":
                                break;
                            case "-":
                                if ((equationNodeChild.Text == "*" || equationNodeChild.Text == "/")) setHumanParenthesis = false;
                                break;
                            case "+":
                                if ((equationNodeChild.Text == "+" || equationNodeChild.Text == "-") || (equationNodeChild.Text == "*" || equationNodeChild.Text == "/")) setHumanParenthesis = false;
                                break;
                            case "%":
                                break;
                        }

                        bool isTimeDifferenceFunction = true;
                        if (equationNodeChild.Text == "ASTFUNCTION" && (G.Equal(equationNodeChild.GetChild(0).Text, "exp") || G.Equal(equationNodeChild.GetChild(0).Text, "log") || G.Equal(equationNodeChild.GetChild(0).Text, "pow")))
                        {
                            isTimeDifferenceFunction = false;
                        }

                        if (equationNodeChild.Text == "ASTVARIABLE" || equationNodeChild.Text == "ASTVARIABLELAGLEAD" || equationNodeChild.Text == "ASTDOUBLE" || equationNodeChild.Text == "ASTINTEGER" || (!isTimeDifferenceFunction && equationNodeChild.Text == "ASTFUNCTION"))
                        {
                            setHumanParenthesis = false;  //overrides everything above
                        }
                        if (sameParenthesesInMachineCodeAsInHumanReadableCode)
                        {
                            if (setHumanParenthesis) wh2.rightHandSideCsCode.Append("(", EEmitType.bothHumanAndComputerReadable);  //0 means all
                        }
                        else
                        {
                            if (setHumanParenthesis) wh2.rightHandSideCsCode.Append("(", EEmitType.humanReadable);  //2 means only human
                        }



                        //------------------ before each child end ----------------

                        EmitCsCodeForModel(eh, equationNodeChild, depth + 1, wh2, model, subTreeLag, isModel);

                        //------------------ after each child ----------------

                        if (sameParenthesesInMachineCodeAsInHumanReadableCode)
                        {
                            if (setHumanParenthesis) wh2.rightHandSideCsCode.Append(")", EEmitType.bothHumanAndComputerReadable);
                        }
                        else
                        {
                            if (setHumanParenthesis) wh2.rightHandSideCsCode.Append(")", EEmitType.humanReadable);
                        }

                        switch (equationNode.Text)
                        {
                            case "*":
                            case "+":
                            case "-":
                            case "/":
                            case "%":
                                if (!sameParenthesesInMachineCodeAsInHumanReadableCode) wh2.rightHandSideCsCode.Append(")", EEmitType.computerReadable);  //nonhuman
                                if (!last2) wh2.rightHandSideCsCode.Append(" " + equationNode.Text + " ", EEmitType.bothHumanAndComputerReadable);  //all
                                break;
                            case "ASTFUNCTION":
                                if (!last2 && !first2) wh2.rightHandSideCsCode.Append(", ");  //functions with more that 1 argument
                                break;
                        }
                        //------------------ after each child ----------------
                    }
                }
            }

            for (int i = 0; i < numberOfRightParentheses; i++)
            {
                wh2.rightHandSideCsCode.Append(")");
            }
        }

        private static int GetLags(WalkerHelper2 wh2, string function, ASTNode lags)
        {
            int intLags = -12345;
            if (lags.Text == "ASTINTEGER")
            {
                intLags = int.Parse(lags.GetChild(0).Text);
            }
            else if (lags.Text == "ASTASSIGNVAR")
            {
                string value2 = HandleModelVal(lags, wh2);
                bool xx = int.TryParse(value2, out intLags);
                if (!xx)
                {
                    G.Writeln2("*** ERROR: The VAL " + value2 + " is not suitable as second argument of " + function + "()");
                    throw new GekkoException();
                }
            }
            else
            {
                G.Writeln2("*** ERROR: Expected the second argument of " + function + "() function to be a fixed value");
                throw new GekkoException();
            }

            if (intLags <= 0 || intLags >= 100)
            {
                G.Writeln2("*** ERROR: Expected lags in " + function + "() function to > 0 and < 100");
                throw new GekkoException();
            }

            return intLags;
        }

        private static string HandleModelVal(ASTNode equationNode, WalkerHelper2 wh2)
        {
            //string key = equationNode.GetChild(0).Text.Substring(1);
            string key = equationNode.GetChild(0).Text;
            string value = null;
            if (wh2.vals == null || !wh2.vals.TryGetValue(key, out value))
            {
                G.Writeln2("*** ERROR: Could not find VAL '" + key + "' definition in .frm file");
                throw new GekkoException();
            }
            if (value.EndsWith(".")) value = value + "0";  //otherwise "1." becomes "1.d" which is not allowed
            return value;
        }


        private static void HandlePowFunction(EquationHelper eh, ASTNode equationNode, int depth, WalkerHelper2 wh2, ModelGekko model, int subTreeLag, bool isModel, bool function)
        {
            wh2.rightHandSideCsCode.Append("O.Pow(", EEmitType.computerReadable);
            wh2.rightHandSideCsCode.Append("Pow(", EEmitType.humanReadable);
            int start = 0;
            int end = 1;
            if (function)
            {
                start = 1;
                end = 2;
            }
            for (int i = start; i <= end; i++)
            {
                wh2.rightHandSideCsCode.Append("(");
                EmitCsCodeForModel(eh, equationNode.Children[i], depth + 1, wh2, model, subTreeLag, isModel);
                wh2.rightHandSideCsCode.Append(")");
                if (i == start) wh2.rightHandSideCsCode.Append(", ");
            }
            wh2.rightHandSideCsCode.Append(")");
        }        

        private static void AddToDictionary(Dictionary<string, string> ht, string name, ModelGekko model)
        {
            if (ht.ContainsKey(name))
            {
                model.fatalEndogenousError = true;
            }
            else
            {
                ht.Add(name, "");
            }
        }

        private static void EmitCsDoVariableStuff(EquationHelper eh, WalkerHelper2 wh2, ModelGekko model, bool isModel, string variable3, int lag, bool isBaseBank, string absoluteTime, string namedBank)
        {
            printVariableAsBType(eh, wh2, model, variable3, lag, false, false, isModel, isBaseBank, absoluteTime, namedBank); //false=rightside
            //doing model frml
            string atSign = "";
            if (isBaseBank) atSign = "@";  //this way, fY lagged from basebank becomes "@fy¤-1". Used only when doing PRT or GENR statements, not for models.

            string varWithLag = "";
            if (absoluteTime == null)
            {
                if (namedBank == null)
                {
                    //@fY¤-2
                    varWithLag = atSign + variable3 + Globals.lagIndicator + lag;
                }
                else
                {
                    //adambk:fY¤-2
                    varWithLag = namedBank + ":" + variable3 + Globals.lagIndicator + lag;
                }
            }
            else
            {
                if (namedBank == null)
                {
                    //@fY¤¤2001q3  (two ¤¤ indicate absolute time)
                    varWithLag = atSign + variable3 + Globals.lagIndicator + Globals.lagIndicator + absoluteTime;
                }
                else
                {
                    varWithLag = namedBank + ":" + variable3 + Globals.lagIndicator + Globals.lagIndicator + absoluteTime;
                }
            }

            string varWithLag2 = varWithLag;

            if (!eh.precedentsWithLagIndicator.ContainsKey(varWithLag2))
            {
                eh.precedentsWithLagIndicator.Add(varWithLag2, "");
            }

        }

        private static void ExtractDJZAndEquationTypeFromEquationCode(EquationHelper eh, ModelGekko model, bool isModel)
        {
            string code = eh.equationCode;

            if (code == "ASTIDENTITYCODE")
            {
                code = "_i";
            }

            if (code == "AUTOGENERATED")
            {
                eh.equationType = EEquationType.RevertedAutoGenerated;
                return;
            }

            if (code.Length == 0)
            {
                eh.equationType = EEquationType.I;
                PrintEquationCodeWarning(eh);
                return;
            }
            string var = eh.lhsWithLagIndicator;

            if (G.Equal(code.Substring(0, 1), Globals.equationCodeT)) //FRML x... for table variables
            {
                eh.equationType = EEquationType.RevertedT;
                return;
            }
            else if (G.Equal(code.Substring(0, 1), Globals.equationCodeY))
            {
                eh.equationType = EEquationType.RevertedY;  //for instance "Y"-type eqs, with J- or Z-vars on left side
                return;
            }
            else if (IsEquationTypeP(code)) //FRML z... for ignored variables (used in PREDICT)
            {
                eh.equationType = EEquationType.RevertedP;
                return;
            }
            else if (G.Equal(code.Substring(0, 1), "i")) //FRML i... is not endorsed or used, but there may be some instances
            {
                eh.equationType = EEquationType.I; //understood as FRML _i...
                return;
            }
            else if (G.Equal(code.Substring(0, 1), "d")) //FRML d... is not endorsed or used, but there may be some instances
            {
                eh.equationType = EEquationType.D; //understood as FRML _d...
                return;
            }
            else if (code.Substring(0, 1) == "_")
            {
                //ok
            }
            else
            {
                eh.equationType = EEquationType.I;
                PrintEquationCodeWarning(eh);
                return;
            }

            eh.equationCodeJ = "";
            eh.equationCodeD = "";
            if (code.Length == 1)
            {
                //it must be "_"
                eh.equationType = EEquationType.I;
                PrintEquationCodeWarning(eh);
                return;
            }

            string type = code.Substring(1, 1);
            if (G.Equal(type, "d")) eh.equationType = EEquationType.D;
            else if (G.Equal(type, "i")) eh.equationType = EEquationType.I;
            else if (G.Equal(type, "g")) eh.equationType = EEquationType.G;
            else if (G.Equal(type, "k")) eh.equationType = EEquationType.K;
            else if (G.Equal(type, "s")) eh.equationType = EEquationType.S;
            else
            {
                eh.equationType = EEquationType.I;
                PrintEquationCodeWarning(eh);
            }

            if (code.Length == 3)
            {
                //1 char
                eh.equationCodeJ = code.Substring(2, 1) + "_";  //no examples of only "_GJ" for instance, but just in case. Should be "_GJ_".
                //TODO: maybe invoke a warning here
            }
            if (code.Length >= 4)
            {
                //2 chars
                eh.equationCodeJ = code.Substring(2, 2);
            }
            if (code.Length >= 5)
            {
                //1 char, if dummy
                eh.equationCodeD = code.Substring(4, 1);
            }
            if (isModel && code.Length >= 7)  //damping not relevant if not isModel (i.e. a GENR statement)
            {
                //1 char, if dummy
                eh.equationCodeZ = code.Substring(6, 1);
                if (G.Equal(eh.equationCodeZ, "Z"))
                {
                    //variable is to be damped in Gauss-Seidel
                    if (model.dampVariables.ContainsKey(var))
                    {
                        G.Writeln2("*** ERROR: it seems the same damp variable appears multiple times");
                    }
                    else
                    {
                        model.dampVariables.Add(var, "");
                    }
                }
            }
            return;
        }

        private static bool IsEquationTypeP(string code)
        {
            return G.Equal(code.Substring(0, 1), Globals.equationCodeP);
        }

        private static void PrintEquationCodeWarning(EquationHelper eh)
        {
            if (false)
            {
                //Probably no need to report these
                G.Writeln("+++ WARNING: equation type set to _I for this equation:" + G.NL + eh.equationText);
            }
            return;
        }

        private static void printVariableAsBType(EquationHelper eh, WalkerHelper2 wh2, ModelGekko model, string variable, int lag, bool leftSide, bool humanReadable, bool isModel, bool isBaseBank, string absoluteTime, string namedBank)
        {
            if (EquationIsNotRunAtAll(eh))
            {
                //these equations are not part of the model at all, only used for PREDICT
                //so they are not counted regarding lags, leads, etc.
                if (!leftSide)
                {
                    LongVersionAndHumanVersion(wh2, variable, lag);  //so PREDICT has some code
                }
                return;
            }

            if (isModel)  //for equations in model/frm
            {
                //ATypeData dataA = model.varsAType[variable];
                ATypeData dataA = null; model.varsAType.TryGetValue(variable, out dataA);

                //lag is -1 for fY(-1). It is positive for leads.

                if (dataA == null)
                {
                    dataA = new ATypeData();
                    dataA.aNumber = model.varsAType.Count;
                    dataA.varName = variable;  //only reason to add this is when we want to get the right lower/uppercase of the variable
                    model.varsAType.Add(variable, dataA);
                }
                
                if (true)
                {

                    if (lag < 0)
                    {
                        if (-lag > model.largestLag) model.largestLag = -lag;  //model.largestLag is always 0 or positive
                        if (-lag > eh.largestLag) eh.largestLag = -lag;  //eh.largestLag is always 0 or positive
                    }
                    else if (lag > 0)
                    {
                        if (!EquationIsRunSeparatelyAfterSim(eh))
                        {
                            //not type T, Y, reverted J
                            if (lag > model.largestLeadOutsideRevertedPart) model.largestLeadOutsideRevertedPart = lag;  //model.largestLeadOutsideRevertedPart is always 0 or positive
                            if (!model.leadedVariables.ContainsKey(dataA.aNumber)) model.leadedVariables.Add(dataA.aNumber, 1);  //1 is just artificial
                        }
                        if (lag > model.largestLead) model.largestLead = lag;  //model.largestLead is always 0 or positive                    
                                                                               // --- in the equation ---
                        if (lag > eh.largestLead) eh.largestLead = lag;  //eh.largestLead is always 0 or positive                    
                    }
                }

                string input = variable + Globals.lagIndicator + lag;
                //BTypeData data = (BTypeData)model.varsBType[input];
                BTypeData data = null; model.varsBType.TryGetValue(input, out data);
                if (data == null)
                {
                    data = new BTypeData();
                    data.variable = variable;
                    data.bNumber = model.varsBType.Count;
                    data.lag = lag;
                    //data.equations = new ArrayList();
                    data.leftHandSideEquation = -12345;  //-12345 means none
                    data.aNumber = dataA.aNumber;
                    model.varsBType.Add(input, data);
                    model.varsBTypeInverted.Add(data.bNumber, input);
                }

                //TODO: maybe move test of leftside/rightside out of method to calling method
                if (leftSide == true)
                {
                    string var2 = "";
                    if (lag == 0)
                    {
                        var2 = variable;
                    }
                    else
                    {
                        var2 = variable + "[" + lag + "]";
                    }

                    wh2.leftHandSideHumanReadable.Append(var2);
                    wh2.leftHandSideBNumber = data.bNumber;
                    wh2.leftHandSideCsCodeGauss.Append("b[" + data.bNumber + "]");
                    wh2.leftHandSideCsCodeJacobi.Append("c[" + data.bNumber + "]");

                }
                else
                {
                    //right side
                    //Here we do both the short, long and human version individually

                    if (lag >= 1)
                    {
                        wh2.rightHandSideCsCode.shortVersion.Append("Gekko.Program.Lead(b, " + data.bNumber + ")");
                    }
                    else
                    {
                        //normal way for non-lead variables
                        wh2.rightHandSideCsCode.shortVersion.Append("b[" + data.bNumber + "]");
                    }

                    //This is probably so that equations can be GENR'ed
                    LongVersionAndHumanVersion(wh2, variable, lag);
                }
            }
            else  //for genr and prt statements
            {
                string bank = "databank";
                if (isBaseBank) bank = "baseDatabank";

                if (namedBank != null)
                {
                    //all this stuff is pretty messy, especially for PPLOT and WPLOT (PRT a bit better).
                    //we should merge PRT, PPLOT and WPLOT functionality at some point.
                    //the use of NamedDatabankHelper() is only present when using colons, so it should not
                    //be able to break anything regarding Gekko 1.6 and PRT/PPLOT/WPLOT. Or if it breaks,
                    //it only affects colons.
                    //isBaseBank can not be true here (not legal syntax to mix ':' and @)
                    bank = "Program.NamedDatabankHelper(`" + namedBank + "`, databank)";  //databank is either Work or Base (looping over these)
                }

                string variableSubst = variable;

                if (leftSide)
                {
                    wh2.leftHandSideCsCodeGauss.Append(bank + ".GetVariable(Program.SubstituteAssignVars(" + Globals.QT + variableSubst + Globals.QT + ")).SetData(Program.options.freq, t, data)");
                }
                else
                {
                    if (absoluteTime == null)
                    {
                        if (lag == 0)
                        {
                            //wh2.rightHandSideCsCode.Append(bank + ".GetVariable(Program.SubstituteAssignVars(" + Globals.QT + variableSubst + Globals.QT + ")).GetData(Program.options.freq ,t)");
                            wh2.rightHandSideCsCode.Append("Program.GetData(`" + variableSubst + "`, " + bank + ", t)");
                        }
                        else
                        {
                            //wh2.rightHandSideCsCode.Append(bank + ".GetVariable(Program.SubstituteAssignVars(" + Globals.QT + variableSubst + Globals.QT + ")).GetData(t.CloneAndAdd(" + lag + "))");
                            wh2.rightHandSideCsCode.Append("Program.GetData(`" + variableSubst + "`, " + bank + ", t.Add(" + lag + "))");
                        }
                    }
                    else
                    {
                        GekkoTime t = GekkoTime.FromStringToGekkoTime(absoluteTime);
                        //wh2.rightHandSideCsCode.Append(bank + ".GetVariable(Program.SubstituteAssignVars(" + Globals.QT + variableSubst + Globals.QT + ")).GetData(new GekkoTime(" + t.year + ", " + t.sub + "))");
                        wh2.rightHandSideCsCode.Append("Program.GetData(`" + variableSubst + "`, " + bank + ", new GekkoTime(" + t.super + ", " + t.sub + "))");
                    }
                }

                //dublets are not allowed. TODO: fY and fy can coexist -- find a List<string> doing upper/lowercase
                if (!wh2.allReferencedTimeSeriesOrListsWork.Contains(variable)) wh2.allReferencedTimeSeriesOrListsWork.Add(variable);
                //TODO: prettify all these calls...
                //if (Program.ExtractPrintOptions(helper.prtOption).isMultiplier | useBaseBank == "TRUE")
                if (isBaseBank)
                {
                    if (!wh2.allReferencedTimeSeriesOrListsBase.Contains(variable)) wh2.allReferencedTimeSeriesOrListsBase.Add(variable);
                }
            }
        }

        private static void LongVersionAndHumanVersion(WalkerHelper2 wh2, string variable, int lag)
        {
            wh2.rightHandSideCsCode.longVersion.Append("O.PredictGetValue(`" + variable + "`, gt.Add(" + lag + "))");
            wh2.rightHandSideCsCode.humanVersion.Append(variable + "[" + lag + "]");
        }

        //
        // TODO TODO when adding extension to a file, cast endswith() to lower before checking
        //

        public static void AST(CT node, int depth)
        {
            G.Writeln(G.Blanks(depth * 2) + node.Text);
            //G.Writeln(G.Blanks(depth * 2) + node.Text + "    line:" + node.Line);
            if (node.Children != null)
            {
                for (int i = 0; i < node.Children.Count; ++i)
                {
                    CT child = (CT)(node.Children[i]);
                    AST(child, depth + 1);
                }
            }
        }

        public static void AST2(ASTNode node, int depth)
        {
            G.Writeln(G.Blanks(depth * 2) + node.Text);
            if (node.Children != null)
            {
                for (int i = 0; i < node.Children.Count; ++i)
                {
                    ASTNode child = (ASTNode)(node.Children[i]);
                    AST2(child, depth + 1);
                }
            }
        }        
    }

    public class ConvertHelper
    {
        public string code;        
        public List<string> errors;
        public string commandsText;
        //public string codeUFunctions;        
    }

    public class WalkHelper
    {
        public List<string> frmlItems;
        public int frmlItemsCounter = -1;  //incremented for each ASTFRML, so becomes 0 when first ASTFRML is hit.
        public bool print = false;
        public bool printFile = false;
        //public int eqs = 0;
        public List<string> functions = new List<string>();
        //pointers into the tree of equations
        //public List<EquationsHelper> equations = new List<EquationsHelper>();
        //public EquationNode currentRootEquationNode = null;
        public StreamWriter writer = null;
        public PositionInFile positionInFileStart = new PositionInFile();
        public PositionInFile positionInFileEnd = new PositionInFile();
        public string inputFile = "";
        public StringReader inputFileStringReader = null;
        public List<string> inputFileLines = new List<string>();
        public bool afterEncountered = false;
        public bool after2Encountered = false;
        public string modelBlock = "Unnamed";
    }

    public class ASTNode
    {
        public IEnumerable ChildrenIterator()
        {
            //One good thing about this iterator is that you can use
            //  foreach (ASTNode child in node.ChildrenIterator())
            //even if node.Children = null. In that case, nothing
            //is iterated, just as if node.Children.Count was 0.
            //This is practical.
            //Another benefit is that we may set .Children private at some
            //point, so that its implementation may change (we use a List<> now).
            if (this.Children != null)
            {
                foreach(ASTNode child in this.Children)
                {
                    yield return child;
                }
            }
        }

        public List<ASTNode> Children = null;  //make this private at some point
        public ASTNode parent = null;
        public string Text = null;
        public int Line = 0;
        public ASTNode(string text)
        {
            this.Text = text;
        }
        public ASTNode(string text, bool withChildren)
        {
            this.Text = text;
            if (withChildren)
            {
                this.Children = new List<ASTNode>();
            }
        }

        public ASTNode(string text, string textChild)
        {
            //adds a node with text and a singla child with textChild
            this.Text = text;
            this.Children = new List<ASTNode>();
            this.Children.Add(new ASTNode(textChild));
        }

        public ASTNode(string text, string textChild1, string textChild2)
        {
            //adds a node with text and a singla child with textChild
            this.Text = text;
            this.Children = new List<ASTNode>();
            this.Children.Add(new ASTNode(textChild1));
            this.Children.Add(new ASTNode(textChild2));
        }

        public ASTNode GetChild(int i)
        {
            if (this.Children == null) return null;
            if (i >= this.Children.Count) return null;  //does not exist
            return this.Children[i];
        }

        public string GetChildString(int i)
        {
            //will be obsolete
            //---> "@`stringcontent`"
            ASTNode node = this.GetChild(i);
            if (node == null) return "null";
            else return "@`" + node.Text + "`";
        }

        public string GetChildText(int i)
        {
            ASTNode node = this.GetChild(i);
            if (node == null) return null;
            else return node.Text;
        }

        public void Add(ASTNode child)
        {
            this.Children.Add(child);
            child.parent = this;
        }

        public string ToString()
        {
            return this.Text;
        }
    }

    public class PositionInFile
    {
        public int line; //0-based!
        public int charPosition;  //0-based
        public PositionInFile()
        {
            line = -12345;
            charPosition = -12345;
        }
        public void LookForLargerPosition(CT ast)
        {
            if (ast.Line - 1 > this.line) //subtract 1 to make it 0-based
            {
                this.line = ast.Line - 1; //subtract 1 to make it 0-based
                this.charPosition = ast.CharPositionInLine;
            }
            else if (ast.Line - 1 == this.line)  //subtract 1 to make it 0-based
            {
                if (ast.CharPositionInLine > this.charPosition) this.charPosition = ast.CharPositionInLine;
            }
        }
    }

    public class StringBuilder2
    {
        public StringBuilder shortVersion = new StringBuilder();
        public StringBuilder longVersion = new StringBuilder();
        public StringBuilder humanVersion = new StringBuilder();

        public void Append(string s)
        {
            Append(s, 0);
        }

        public void Append(string s, EEmitType which)
        {  //0: all, 1: nonhuman, 2: human
            if (which == EEmitType.bothHumanAndComputerReadable || which == EEmitType.computerReadable)
            {
                shortVersion.Append(s);
                longVersion.Append(s);
            }
            if (which == EEmitType.bothHumanAndComputerReadable || which == EEmitType.humanReadable)
            {
                humanVersion.Append(s);
            }
        }

        public void AppendLine(string s)
        {
            AppendLine(s, 0);
        }

        public void AppendLine(string s, EEmitType which)
        {
            if (which == EEmitType.bothHumanAndComputerReadable || which == EEmitType.computerReadable)
            {
                shortVersion.AppendLine(s);
                longVersion.AppendLine(s);
            }
            if (which == EEmitType.bothHumanAndComputerReadable || which == EEmitType.humanReadable)
            {
                humanVersion.AppendLine(s);
            }
        }
    }
    
    public class ParseHelper
    {
        public bool isOneLinerFromGui = false;
        public string commandsText = null;
        public string fileName = null;
        public bool isModel = false;
    }

    public class WalkerHelper2
    {
        public StringBuilder2 rightHandSideCsCode = new StringBuilder2();
        public StringBuilder leftHandSideCsCodeGauss = new StringBuilder();  // b[117]
        public StringBuilder leftHandSideCsCodeJacobi = new StringBuilder();  // c[117]
        public StringBuilder leftHandSideHumanReadable = new StringBuilder();  //fy
        public int leftHandSideBNumber = -12345;  //only used for model
        public List<string> allReferencedTimeSeriesOrListsWork = new List<string>();  //only used for expressions in cmd
        public List<string> allReferencedTimeSeriesOrListsBase = new List<string>();  //only used for expressions in cmd
        public List<string> problematicFrmlCodes = new List<string>();
        public string frmlCode = "";
        public string leftSideFunction = "";
        public string variableOrFunctionIndicator = "";
        public ASTNode rhs = null;
        public Dictionary<string, string> vals = null;
    }    
}
