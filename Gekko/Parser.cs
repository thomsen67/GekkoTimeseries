/*
    Gekko Timeseries Software (www.t-t.dk/gekko).
    Copyright (C) 2016, Thomas Thomsen, T-T Analyse.

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program (see the file COPYING in the root folder).
    Else, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using System.Text;
using Antlr.Runtime;
using Antlr.Runtime.Tree;
using Antlr.Runtime.Debug;
using Microsoft.CSharp;
using System.CodeDom;
using System.CodeDom.Compiler;
using System.Reflection;
using CT = Antlr.Runtime.Tree.CommonTree;
//using Antlr4.StringTemplate;
using System.Windows.Forms;
using System.IO;
using System.Drawing;
using System.Collections;
using SevenZip;
using System.Security.Cryptography;
using System.Runtime.Serialization.Formatters.Binary;
using System.Runtime.Serialization;

namespace Gekko
{

    public enum EPrtType
    {
        Prt,  //includes gmulprt and vprt (and mulprt, mulpct, pctprt)
        Pplot,
        Wplot,
        Cplot
    }

    public enum EEmitType
    {
        bothHumanAndComputerReadable,
        computerReadable,
        humanReadable
    }

    public enum EEquationType
    {
        D,
        G,
        K,
        I,
        S,
        AfterModelI,
        AfterModelD,
        RevertedY,
        RevertedAutoGenerated
    }

    public static class ParserOLD
    {       

        public static void CreateASTNodesForModel(CT ast, ASTNode equationNode, int depth, WalkHelper wh, Model model)
        {
            if (ast.Text == "ASTVAL")
            {
                //nothing done here
            }
            if (ast.Text == "ASTMODELBLOCK")
            {
                string s = ast.GetChild(0).Text;
                string[] ss = s.Split(new string[] { "###" }, StringSplitOptions.None);
                wh.modelBlock = ss[1].Trim();  //since it comes from the parser, there are always 2 or 3 elements in ss
                if (wh.modelBlock.Length > 0)
                {
                    //first letter always set to upper-case
                    wh.modelBlock = char.ToUpper(wh.modelBlock[0]) + wh.modelBlock.Substring(1);
                }
            }
            if (ast.Text == "ASTAFTER")
            {
                if (wh.after2Encountered)
                {
                    G.Writeln2("*** ERROR: Expected AFTER$ before AFTER2$ in model");
                    throw new GekkoException();
                }
                if (wh.afterEncountered)
                {
                    G.Writeln2("*** ERROR: It seems there are more than one AFTER$ in model");
                    throw new GekkoException();
                }
                wh.afterEncountered = true;
            }
            if (ast.Text == "ASTAFTER2")
            {
                if (wh.after2Encountered)
                {
                    G.Writeln2("*** ERROR: It seems there are more than one AFTER2$ in model");
                    throw new GekkoException();
                }
                wh.after2Encountered = true;
            }
            equationNode.Text = ast.Text;
            EquationHelper helper = null;
            if (depth == 1 && ast.Text == "ASTFRML")
            {
                wh.frmlItemsCounter++;
                equationNode = new ASTNode(ast.Text);  //the root node for this equation
                equationNode.parent = null;  //has no parent
                helper = new EquationHelper();
                helper.modelBlock = wh.modelBlock;
                helper.equationNumber = model.equations.Count;
                helper.equationsNodeRoot = equationNode;
                //if( helper.isAfterModel
                if (wh.afterEncountered) helper.isAfterModel = true;
                if (wh.after2Encountered) helper.isAfter2Model = true;  //can be both at same time
                model.equations.Add(helper);
                //wh.eqs++;
                wh.positionInFileStart.line = ast.Line - 1; //subtract 1 to make it 0-based
                wh.positionInFileStart.charPosition = ast.CharPositionInLine;
            }

            wh.positionInFileEnd.LookForLargerPosition(ast);

            if (wh.print) for (int i = 0; i < depth; i++) Console.Write("    ");
            if (wh.print) Console.WriteLine(ast.Text);

            if (wh.printFile) for (int i = 0; i < depth; i++) wh.writer.Write("    ");
            if (wh.printFile) wh.writer.WriteLine(ast.Text);

            if (ast.Children == null)
            {
                return;
            }

            int num = ast.Children.Count;
            equationNode.Children = new List<ASTNode>(num);

            //Console.WriteLine();
            for (int i = 0; i < num; ++i)
            {
                CT d = (CT)(ast.Children[i]);
                ASTNode equationNodeChild = new ASTNode(null);  //unknown text
                equationNodeChild.parent = equationNode;
                equationNode.Add(equationNodeChild);
                CreateASTNodesForModel(d, equationNodeChild, depth + 1, wh, model);
                if (i < num - 1)
                {
                    //Console.WriteLine();
                }
            }

            if (depth == 1 && ast.Text == "ASTFRML")
            {
                helper.equationText = wh.frmlItems[wh.frmlItemsCounter];
            }
        }        

        public static List<string> IntelliParserNew(string s2)
        {
            List<string> result = new List<string>();
            string u_variable = "[string]";
            string u_text_string = "['string']";
            string u_number = "[number]";
            string u_integer = "[integer]";
            for (int iter = 0; iter < 2; iter++)
            {
                result.Clear();
                DateTime t0 = DateTime.Now;

                string text0 = Program.HandleOneLiners(s2);
                text0 = Program.HandleObeyFiles2(text0);
                text0 = text0.Replace("\r\n", "").Trim();
                if (text0.EndsWith(";")) text0 = text0.Substring(0, text0.Length - 1);  //an extra ';' seems to be added in HandleOneLiners, for GENR
                int length = text0.Length;

                //StreamReader sr2 = new StreamReader(Application.StartupPath + "\\" + "tokens.txt");
                //string input3 = sr2.ReadToEnd();

                List<string> ss = G.ExtractLinesFromText(Gekko.Parser.Gek.Tokens.tokens);
                
                //List<string> ss = G.ExtractLinesFromText(input3);
                List<string> ss2 = new List<string>();
                int wordCounter = 0;
                List<string> noIdent = new List<string>();
                foreach (string s007 in ss)
                {
                    string s = s007.Trim();
                    if (s.Trim() == "") continue;
                    int i = s.LastIndexOf('=');
                    if (i == -1) continue;
                    string token = s007.Substring(0, i).Trim();
                    token = G.StripQuotes(token).Trim();
                    ss2.Add(token);
                }

                string t_number = "1" + Globals.dotGlue + "2345";
                ss2.Add(t_number);
                string t_integer = "12345";
                ss2.Add(t_integer);
                string t_text = "'artificial_text'";
                ss2.Add(t_text);
                string t_variable = "artificial_variable";
                ss2.Add(t_variable);

                List<string> ss3 = new List<string>();
                foreach (string s in ss2)
                {
                    if (!ss3.Contains(s.ToLower()))
                    {
                        ss3.Add(s.ToLower());
                    }
                }

                foreach (string s in ss3)
                {
                    //if (s.ToLower() == "clipboard")
                    //{
                    //    G.Writeln("");
                    //}
                    
                    string input7 = text0 + " " + s + " ;";                
                    ANTLRStringStream input = new ANTLRStringStream(input7);  //a newline for ease of use of ANTLR
                    List<string> errors = null;
                    CommonTree t = null;
                    Cmd2Lexer lexer = new Cmd2Lexer(input);
                    CommonTokenStream tokens = new CommonTokenStream(lexer);

                    CommonToken ct;

                    Cmd2Parser parser = new Cmd2Parser(tokens);
                    Cmd2Parser.expr_return r = null;
                    bool ok = true;
                    try
                    {
                        r = parser.expr();
                    }
                    catch (Exception e)
                    {
                        ok = false;
                    }

                    errors = parser.GetErrors();
                    if (errors.Count > 0)
                    {
                        bool ok2 = false;
                        foreach (string error in errors)
                        {
                            string[] sss = error.Split(Globals.parserErrorSeparator);
                            int positionNo = int.Parse(sss[1]); //0-based
                            string msg = sss[3];
                            if (positionNo < input7.Length - 1)  //at input7.Length-1 the character is the ';'
                            {
                                ok = false;
                            }
                            else
                            {
                                //ok2 = true;  //if at least one of these errors is pointing to the last semicolon we are good
                            }
                        }
                        //if (ok2 == false) ok = false;
                    }

                    if (ok)
                    {
                        result.Add(s.ToLower());
                    }
                }

                double fraction = (double)result.Count / (double)wordCounter;
                if (iter == 0 && fraction > 0.8)
                {
                    continue;
                }


                int index = result.IndexOf(t_variable);
                if (index >= 0) result[index] = u_variable;

                index = result.IndexOf(t_text);
                if (index >= 0) result[index] = u_text_string;

                index = result.IndexOf(t_number);
                if (index >= 0) result[index] = u_number;

                index = result.IndexOf(t_integer);
                if (index >= 0) result[index] = u_integer;

                //string s5 = "";
                //foreach (string s in result) s5 += " " + s;
                //MessageBox.Show(s5);

                //G.Writeln("TIme " + G.Seconds(t0));
                break;
            };

            List<string> orig = new List<string>();
            orig.AddRange(result);

            if (result.Contains(u_number))
            {
                result.Remove(u_integer);
            }

            result.Sort();
            result = MoveFirst(result, ">");
            result = MoveFirst(result, "<");
            result = MoveLast(result, ";");        

            return result;
        }

        private static List<string> MoveFirst(List<string> result, string x)
        {
            if (result.Contains(x))
            {
                result.Remove(x);
                List<string> temp = new List<string>();
                temp.Add(x);
                temp.AddRange(result);
                result = temp;
            }
            return result;
        }

        private static List<string> MoveLast(List<string> result, string x)
        {
            if (result.Contains(x))
            {
                result.Remove(x);
                List<string> temp = new List<string>();
                temp.AddRange(result);
                temp.Add(x);
                result = temp;
            }
            return result;
        }        

        public static void EmitModelFromANTLR(string textInput, string modelName)
        {
            //ParseModel() is reasonably fast. But needs only to be run when new model is called.
            ParseModel(textInput, modelName);  //bool resTypeGaussSeidel = false;
            Program.GuiSetModelName();
        }

        public static void OrderAndCompileModel(ECompiledModelType modelType, bool isCalledFromModelStatement, bool isFix)
        {
            //seems modelType is not used at all
            bool newM2 = false;
            DateTime t0 = DateTime.Now;
            string cacheKey = GetCacheKey(isFix);

            if (Program.model.m2cache.lru.ContainsKey(cacheKey))  //MODEL statement should always issue a real compile, because in that case, Program.model.m2 is newly created
            {
                Program.model.m2 = (Model2)Program.model.m2cache.lru[cacheKey];
                G.WritelnGray("¤¤¤ Got in cache: "+cacheKey);
            }
            else
            {                              
                
                G.WritelnGray("¤¤¤ Has to do .m2 stuff: "+cacheKey);
                newM2 = true;
                Program.model.m2 = new Model2();  //deleting everything here, this is most safe rather than reusing the object

                if (Program.IsStacked())
                {
                    //Here, we kind of cheat, transforming Program.model into a model without lags or leads, where
                    //y(-1) is y(99), y is y100, y(+1) is y(101), etc.
                    //In that way, a lot of the current functionality can be just reused.
                    if (Globals.stackedPrintTimings) G.Writeln2("StackedTimeStuff start");
                    StackedTimeStuff();
                    if (Globals.stackedPrintTimings) G.Writeln2("StackedTimeStuff end");
                } 

                //this runs very fast
                if (Globals.stackedPrintTimings) G.Writeln2("EndogenizeExogenizeStuff start");
                Program.EndogenizeExogenizeStuff(isFix); //depends upon which endo/exo variables are set
                if (Globals.stackedPrintTimings) G.Writeln2("EndogenizeExogenizeStuff end");
                //takes about 0.6 sec on dec09
                if (Globals.stackedPrintTimings) G.Writeln2("FeedbackOrderingStuff start");
                Program.FeedbackOrderingStuff(modelType, isCalledFromModelStatement); //depends upon which endo/exo variables are set
                if (Globals.stackedPrintTimings) G.Writeln2("FeedbackOrderingStuff end");
            }

            //The .m2 object is in principle recreated each time this method is called (for instance because of ENDO/EXO statement),
            //or with a MODEL statement. But since there is a cache, it will often be found there if it is because of ENDO/EXO.
            //For each modelType (Gauss, GaussFailSafe, Res, Newton, After, Unknown) there is a dedicated .dll in .m2. If
            //this is missing, it will be made in the method below.
            //The way this is done now is more robust, since it will be impossible to obtain a .dll the does not have the
            //corresponding ENDO/EXO vars set. This could be a problem before, for instance doing a ENDO/EXO, and then
            //afterwards Gauss-simulation with failsafe on.
                        
            if (modelType == ECompiledModelType.GaussFailSafe)
            {
                EmitCsCodeAndCompileModel(ECompiledModelType.Gauss, isCalledFromModelStatement);  //This method is only called from here
            }

            //if (Globals.stackedPrintTimings) G.Writeln2("Emit start");
            EmitCsCodeAndCompileModel(modelType, isCalledFromModelStatement);  //This method is only called from here
            //if (Globals.stackedPrintTimings) G.Writeln2("Emit end");

            G.WritelnGray("¤¤¤ Hash: " + cacheKey);

            if (isCalledFromModelStatement) PrintInfoFilesCreateVarsEtc(isCalledFromModelStatement);  //so the "endogenous" are endogenous in original model without ENDO/EXO.

            if (newM2) Program.model.m2cache.lru.Add(cacheKey, Program.model.m2);
        }

        private static void StackedTimeStuff()
        {
            //Remember Globals.stackedTImePeriods...
            //Remember endoexostuff...

            Model modelTemp = new Model();

            modelTemp.largestLag = 0;
            modelTemp.largestLead = 0;            

            modelTemp.varsBType = new GekkoDictionary<string, BTypeData>(StringComparer.OrdinalIgnoreCase);
            modelTemp.varsBTypeInverted = new GekkoDictionary<int, string>();
            modelTemp.varsAType = new GekkoDictionary<string, ATypeData>(StringComparer.OrdinalIgnoreCase);
            
            //Dictionary<string, int> varsATypeTemp = new Dictionary<string, int>();
            Dictionary<string, int> BNumberConverter = new Dictionary<string, int>(); 

            int equationCounter = -1;

            if (Globals.stackedPrintTimings) G.Writeln2("Folding out eqs start");
            
            for (int i = 0; i < Program.options.solve_forward_stacked_horizon; i++)
            {
                foreach (EquationHelper eh in Program.model.equations)
                {
                    equationCounter++;
                    modelTemp.endogenousOriginallyInModel.Add(eh.lhs + Globals.stackedTimeSeparator + (100 + i), "");
                                        
                    List<string> vars = new List<string>();
                    vars.Add(eh.lhsWithLagIndicator);                    
                    vars.AddRange(eh.precedentsWithLagIndicator.Keys);                    

                    bool first = true;
                    foreach (string s in vars)
                    {
                        int bNumberOriginal = Program.model.varsBType[s].bNumber;

                        string varName = null;
                        int varLag = 0;
                        G.ExtractVariableAndLag(s, out varName, out varLag);
                        int correction = 100 + i + varLag;
                        string lhsTemp = varName + Globals.stackedTimeSeparator + correction + Globals.lagIndicator + "0";                        

                        if (!modelTemp.varsBType.ContainsKey(lhsTemp))
                        {
                            BTypeData btd = new BTypeData();
                            btd.bNumber = modelTemp.varsBType.Count;
                            btd.aNumber = modelTemp.varsAType.Count;
                            btd.lag = 0;
                            btd.variable = varName + Globals.stackedTimeSeparator + correction;
                            btd.leftHandSideEquation = -12345;

                            string xx = bNumberOriginal + "¤" + i;
                            if (!BNumberConverter.ContainsKey(xx)) BNumberConverter.Add(xx, btd.bNumber);

                            if (first)
                            {
                                //is so, it is a left-hand side variable.
                                btd.leftHandSideEquation = equationCounter;
                                modelTemp.fromVariableToEquationNumber.Add(lhsTemp, modelTemp.varsBType.Count);
                            }
                            modelTemp.varsBType.Add(lhsTemp, btd);
                            modelTemp.varsBTypeInverted.Add(btd.bNumber, lhsTemp);
                        }
                        else
                        {                            
                            string xx = bNumberOriginal + "¤" + i;
                            if (!BNumberConverter.ContainsKey(xx)) BNumberConverter.Add(xx, modelTemp.varsBType[lhsTemp].bNumber);
                        }

                        if (!modelTemp.varsAType.ContainsKey(lhsTemp))
                        {
                            ATypeData atd = new ATypeData();
                            atd.aNumber = modelTemp.varsAType.Count;
                            atd.varName = varName + Globals.stackedTimeSeparator + correction; ;
                            modelTemp.varsAType.Add(lhsTemp, atd);
                        }                        
                        
                        first = false;  //must be last statement in loop
                    }
                    

                    //eh.precedentsWithLagIndicator
                }
            }

            if (Globals.stackedPrintTimings) G.Writeln2("Folding out eqs end");

            if (Globals.stackedPrintTimings) G.Writeln2("Folding out eqs again start");

            Dictionary<string, string> endoTemp = new Dictionary<string, string>();
            for (int i = 0; i < Program.options.solve_forward_stacked_horizon; i++)
            {
                foreach (EquationHelper eh in Program.model.equations)
                {
                    List<int> bNumbers = new List<int>();
                    List<int> bNumbersNew = new List<int>();                                                      
                    
                    //modelTemp.equations
                    int number = (100 + i);
                    EquationHelper ehTemp = new EquationHelper();
                    ehTemp.lhs = eh.lhs + Globals.stackedTimeSeparator + (100 + i);
                    ehTemp.lhsWithLagIndicator = ehTemp.lhs + Globals.lagIndicator + "0";
                    bNumbers.Add(modelTemp.varsBType[ehTemp.lhsWithLagIndicator].bNumber);
                    BTypeData btd = modelTemp.varsBType[ehTemp.lhsWithLagIndicator];
                    ehTemp.bNumberLhs = btd.bNumber;
                    modelTemp.endogenousBNumbersOriginallyInModel.Add(ehTemp.bNumberLhs, "");
                    ehTemp.precedentsWithLagIndicator = new GekkoDictionary<string, string>(StringComparer.OrdinalIgnoreCase);

                    bNumbersNew.Add(Program.model.varsBType[eh.lhsWithLagIndicator].bNumber);

                    foreach (string s in eh.precedentsWithLagIndicator.Keys)
                    {
                        string varName = null;
                        int varLag = 0;
                        G.ExtractVariableAndLag(s, out varName, out varLag);
                        ehTemp.precedentsWithLagIndicator.Add(varName + Globals.stackedTimeSeparator + (100 + i + varLag) + Globals.lagIndicator + "0", "");                                                
                        bNumbers.Add(modelTemp.varsBType[varName + Globals.stackedTimeSeparator + (100 + i + varLag) + Globals.lagIndicator + "0"].bNumber);
                        bNumbersNew.Add(Program.model.varsBType[s].bNumber);
                    }                    

                    string codeLhs = eh.csCodeLhsGauss;
                    string codeRhs = eh.csCodeRhs;
                    codeLhs = codeLhs.Replace("b[", "bb[");  //so that equation will fail if not all b[...] are replaced
                    codeRhs = codeRhs.Replace("b[", "bb[");  //so that equation will fail if not all b[...] are replaced

                    foreach (int bNumber in bNumbersNew)
                    {
                        int bNumber2 = BNumberConverter[bNumber + "¤" + i];
                        codeLhs = codeLhs.Replace("bb[" + bNumber + "]", "b[" + bNumber2 + "]");
                        codeRhs = codeRhs.Replace("bb[" + bNumber + "]", "b[" + bNumber2 + "]");                        
                    }

                    ehTemp.csCodeLhsGauss = codeLhs;
                    ehTemp.csCodeRhs = codeRhs;

                    ehTemp.equationNumber = modelTemp.equations.Count;
                    modelTemp.equations.Add(ehTemp);                   

                }
            }

            if (Globals.stackedPrintTimings) G.Writeln2("Folding out eqs again end");
            //Model oldModel = Program.model;
            //Program.model = modelTemp;
            //Program.model.oldModel = oldModel;  //in order to be able to revert to this old model when done
            Program.model.stackedModel = modelTemp;
        }

        

        private static string GetCacheKey(bool isFix)
        {
            //isFix: if active, the endo/exo goals are added as lists
            //       if inactive, the endo/exo goals are always reported as [none] no matter if there ARE goals or not
            //       like this, we can use the same dll for a model with SIM and any endo/exo goals set -- the 
            //       difference only kick in regarding SIM<fix>            
            List<string> temp1 = new List<string>();
            if (isFix) foreach (string s in Program.model.endogenized.Keys) temp1.Add(s.ToLower());
            List<string> temp2 = new List<string>();
            if (isFix) foreach (string s in Program.model.exogenized.Keys) temp2.Add(s.ToLower());
            temp1.Sort();
            temp2.Sort();
            StringBuilder ss = new StringBuilder("ENDO-EXO-info. Endogenized: ");
            foreach (string s in temp1) ss.Append(s + ",");
            if (temp1.Count == 0) ss.Append("[none],");
            ss.Remove(ss.Length - 1, 1);
            ss.Append(". Exogenized: ");
            foreach (string s in temp2) ss.Append(s + ",");
            if (temp2.Count == 0) ss.Append("[none],");
            ss.Remove(ss.Length - 1, 1);
            ss.Append(". ");
            string stacked = "false";
            if (G.Equal(Program.options.solve_forward_method, "stacked")) stacked = "true";
            ss.Append("Stacked: " + stacked);            
            return ss.ToString();
        }

        private static void ParseModel(string textInput, string modelName)
        {
            ANTLRStringStream input = new ANTLRStringStream(textInput + "\n");  //a newline for ease of use of ANTLR

            List<string> errors = null;
            CommonTree t = null;

            // Create a lexer attached to that input
            ModelLexer lexer = new ModelLexer(input);
            // Create a stream of tokens pulled from the lexer
            CommonTokenStream tokens = new CommonTokenStream(lexer);
            // Create a parser attached to the token stream
            ModelParser parser = new ModelParser(tokens);
            // Invoke the program rule in get return value
            ModelParser.expr_return r = null;
            DateTime t0 = DateTime.Now;

            //takes 0.5 sec for dec09
            r = parser.expr();

            errors = parser.GetErrors();
            t = (CommonTree)r.Tree;

            if (Globals.printAST)
            {
                AST(t, 0);
            }

            WalkHelper wh = CreateWalkHelper(textInput);
            wh.frmlItems = parser.GetFrmlItems();

            List<string> inputFileLines = wh.inputFileLines;

            ParseHelper ph = new ParseHelper();
            ph.isOneLinerFromGui = false;
            ph.isModel = true;
            ph.fileName = modelName;

            if (errors.Count > 0)
            {
                PrintModelParserErrors(errors, inputFileLines, ph);
                throw new GekkoException();
            }
            else
            {
                //G.Writeln("No errors when parsing");
            }

            GekkoDictionary<string, string> vals = new GekkoDictionary<string, string>(StringComparer.OrdinalIgnoreCase);
            foreach (CT child in t.Children)
            {
                if (child.Text == "ASTVAL")
                {
                    string key = child.GetChild(0).Text;
                    string value = child.GetChild(1).Text;
                    if (child.GetChild(2) != null)
                    {
                        if (G.Equal(child.GetChild(2).Text, "-"))
                        {
                            value = "-" + value;
                        }
                    }

                    if (vals.ContainsKey(key))
                    {
                        G.Writeln2("*** ERROR: Model parsing error: seems VAL '" + key + "' is defined several times.");
                        throw new GekkoException();
                    }
                    else
                    {
                        string key2 = key;
                        if (!key.StartsWith(Globals.symbolScalar.ToString())) key2 = Globals.symbolScalar + key;
                        vals.Add(key2, value);
                    }
                }
            }

            ASTNode equationNode = new ASTNode(null);  //unknown text for now
            wh.print = false;
            //takes 0.1 sec for dec09
            CreateASTNodesForModel(t, equationNode, 0, wh, Program.model); //creates a List<> of equations, with a tree of EquationNodes for each equation

            if (wh.print) wh.writer.Close();

            //TIMING: the rest of this method takes 0.5 sec on dec09, that is nearly as much as parsing and CreateASTNodesForModel()
            //This loop below alone takes 0.5 seconds on dec09, but it also does all the stuff regarding
            //  formula codes DJZ, dlog() on left and right side, broken lags etc. etc. So maybe fair enough it
            //  takes some time. It also writes out actual C# code to be used later on when compiling.

            WalkerHelper2 wh2 = new WalkerHelper2();
            wh2.vals = vals;
            foreach (EquationHelper eh in Program.model.equations)
            {
                //call of recursive method
                wh2.rightHandSideCsCode = new StringBuilder2();  //clearing it for each equation, contains long, short and human versions
                wh2.leftHandSideCsCodeGauss = new StringBuilder();  //clearing it for each equation
                wh2.leftHandSideCsCodeJacobi = new StringBuilder();  //clearing it for each equation
                wh2.leftHandSideHumanReadable = new StringBuilder(); //clearing it for each equation
                EmitCsCodeForModel(eh, eh.equationsNodeRoot, 0, wh2, Program.model, 0, true); //last arg is lag

                if (Globals.printAST) AST2(eh.equationsNodeRoot, 0);

                //TODO: could be nice to also have it human readable, by calling PrintVariable...() with humanReadable=true
                eh.csCodeRhs = wh2.rightHandSideCsCode.shortVersion.ToString();
                eh.csCodeRhsLongVersion = wh2.rightHandSideCsCode.longVersion.ToString();
                eh.csCodeRhsHumanVersion = wh2.rightHandSideCsCode.humanVersion.ToString();

                eh.csCodeLhsGauss = wh2.leftHandSideCsCodeGauss.ToString();
                eh.csCodeLhsJacobi = wh2.leftHandSideCsCodeJacobi.ToString();
                eh.csCodeLhsHuman = wh2.leftHandSideHumanReadable.ToString();
                eh.bNumberLhs = wh2.leftHandSideBNumber;
            }



            //move reverted equations, and compact the others (and renumber them).
            List<EquationHelper> equationsNew = new List<EquationHelper>();
            foreach (EquationHelper eh in Program.model.equations)
            {
                if (eh.equationType == EEquationType.RevertedY)
                {
                    eh.equationNumber = Program.model.equationsReverted.Count;
                    Program.model.equationsReverted.Add(eh);
                }
                else
                {
                    eh.equationNumber = equationsNew.Count;
                    equationsNew.Add(eh);
                }
            }
            Program.model.equations = equationsNew;

            WalkerHelper2 wh3 = new WalkerHelper2();
            wh3.vals = wh2.vals;  //otherwise the will not be available
            foreach (EquationHelper eh in Program.model.equationsReverted)
            {
                //call of recursive method
                wh3.rightHandSideCsCode = new StringBuilder2();  //clearing it for each equation
                wh3.leftHandSideCsCodeGauss = new StringBuilder();  //clearing it for each equation
                wh3.leftHandSideCsCodeJacobi = new StringBuilder();  //clearing it for each equation
                EmitCsCodeForModel(eh, eh.equationsNodeRoot, 0, wh3, Program.model, 0, true);  //last arg is lag
                if (Globals.printAST) AST2(eh.equationsNodeRoot, 0);
                //TODO: could be nice to also have it human readable, by calling PrintVariable...() with humanReadable=true
                eh.csCodeRhs = wh3.rightHandSideCsCode.shortVersion.ToString();
                eh.csCodeRhsLongVersion = wh3.rightHandSideCsCode.longVersion.ToString();
                eh.csCodeLhsGauss = wh3.leftHandSideCsCodeGauss.ToString();
                eh.csCodeLhsJacobi = wh3.leftHandSideCsCodeJacobi.ToString();
                eh.bNumberLhs = wh3.leftHandSideBNumber;
            }
            //-------------------------------------------------------------------------
            
            //---------------------------------------------------------------------------------
            // now model.equations contains real endogenous, and model.equationsReverted contains Y-type and reverted (not real endogenous)

            int nonAfterVars = 0;
            int afterVars = 0;
            int after2Vars = 0;

            foreach (EquationHelper eh in Program.model.equations)
            {
                if (Program.model.endogenousOriginallyInModel.ContainsKey(eh.lhs))
                {
                    G.Writeln2("*** ERROR: when finding endogenous: it seems variable '" + eh.lhs + "' appears multiple times on left-hand side");
                    throw new GekkoException();
                }
                else
                {
                    Program.model.endogenousOriginallyInModel.Add(eh.lhs, "");
                    Program.model.endogenousBNumbersOriginallyInModel.Add(eh.bNumberLhs, "");
                }
                if ((eh.equationType == EEquationType.RevertedAutoGenerated || eh.equationType == EEquationType.RevertedY)) throw new GekkoException(); //sanity check
                if (eh.isAfterModel && !eh.isAfter2Model) afterVars++;
                if (eh.isAfter2Model) after2Vars++;
                if (!eh.isAfterModel && !eh.isAfter2Model) nonAfterVars++;
            }

            int sumVars = nonAfterVars + afterVars + after2Vars;

            if (Program.model.fatalEndogenousError)
            {
                //this error should never happen -- should be caught above when checking endogenous
                //just to be 100% sure we are not going on with some inconsistency regarding endogenous vars
                G.Writeln2("*** ERROR: There is a problem with multiple instances of the same endogenous variable");
                throw new GekkoException();
            }

            foreach (EquationHelper eh in Program.model.equations)
            {
                Program.model.fromVariableToEquationNumber.Add(eh.lhsWithLagIndicator, eh.equationNumber);
            }

            foreach (EquationHelper eh in Program.model.equationsReverted)
            {
                if (Program.model.reverted.ContainsKey(eh.lhs))
                {
                    G.Writeln2("*** ERROR: The variable '" + eh.lhs + "' seems to appear as a reverted equation several times.");
                    G.Writeln("           This may be because the variable is both auto-generated by means of formula codes,");
                    G.Writeln("           and added manually.");
                    throw new GekkoException();
                }
                else
                {
                    Program.model.reverted.Add(eh.lhs, "");
                }

                if (!(eh.equationType == EEquationType.RevertedAutoGenerated || eh.equationType == EEquationType.RevertedY)) throw new GekkoException(); //sanity check

            }

            //Find dependents for endogenous variables
            //FIXME not working
            //FIXME not working
            //FIXME not working
            //FIXME not working
            //FIXME not working   Edit: HMMM seems to work fine....
            //FIXME not working
            //FIXME not working
            //FIXME not working
            foreach (EquationHelper eh in Program.model.equations)
            {
                foreach (string p in eh.precedentsWithLagIndicator.Keys)
                {
                    string p2 = G.ExtractOnlyVariableIgnoreLag(p);
                    if (Program.model.dependents.ContainsKey(p2))
                    {
                    }
                    else
                    {
                        DependentsHelper d = new DependentsHelper();
                        Program.model.dependents.Add(p2, d);
                    }
                    Dictionary<string, string> yy = Program.model.dependents[p2].storage;
                    if (!yy.ContainsKey(eh.lhs))
                    {
                        yy.Add(eh.lhs, "");
                    }
                }
            }

            int xnumberTotal = Program.model.varsAType.Count;
            int xnumberOfEndo = Program.model.endogenousOriginallyInModel.Count;
            int xnumberOfDjz = Program.model.varsJTypeAutoGenerated.Count + Program.model.varsDTypeAutoGenerated.Count + Program.model.varsZTypeAutoGenerated.Count;
            int xnumberOfExoTrue = xnumberTotal - xnumberOfEndo - xnumberOfDjz;

            Program.model.modelInfo.total = xnumberTotal;
            Program.model.modelInfo.endo = xnumberOfEndo;
            Program.model.modelInfo.exoTrue = xnumberOfExoTrue;
            Program.model.modelInfo.exoDJZ = xnumberOfDjz;
            Program.model.modelInfo.endo2 = sumVars;
            Program.model.modelInfo.endoNoAfter = nonAfterVars;
            Program.model.modelInfo.endoAfter = afterVars;
            Program.model.modelInfo.endoAfter2 = after2Vars;

            return;
        }

        public static void PrintModelParserErrors(List<string> errors, List<string> inputFileLines, ParseHelper ph)
        {
            if (Globals.threadIsInProcessOfAborting) return;
            if (Globals.pipe == true) Program.Pipe("con", null);
            int number = 0;
            foreach (string s in errors)
            {
                number++;
                if (errors.Count > 1)
                {
                    if (number == 1) G.Writeln();
                    G.Writeln("--------------------- error #" + number + " of " + errors.Count + "-----------------");
                    //G.Writeln();
                }
                else G.Writeln();


                string[] ss = s.Split(Globals.parserErrorSeparator);
                int lineNumber = 0;
                int lineNo = 0;
                int positionNo = 0;
                string errorMessage = "General error";

                try
                {
                    lineNumber = int.Parse(ss[0]) - 1;  //seems 1-based before subtract 1
                    lineNo = lineNumber + 1;  //1-based
                    positionNo = int.Parse(ss[1]) + 1;  //1-based
                    errorMessage = ss[3];
                }
                catch
                {

                }

                if (Globals.addGlue)
                {
                    errorMessage = G.ReplaceGlueNew(errorMessage);
                }

                //if (!Globals.useTestParser)
                //{
                //    errorMessage = errorMessage.Replace(" RPARGLUE", " ')'");
                //    errorMessage = errorMessage.Replace(" LPARGLUE", " '('");
                //    errorMessage = errorMessage.Replace(" RPAR", " ')'");
                //    errorMessage = errorMessage.Replace(" LPAR", " '('");
                //    errorMessage = errorMessage.Replace(" RP", " ')'");
                //    errorMessage = errorMessage.Replace(" LP", " '('");
                //    errorMessage = errorMessage.Replace("EOF", "[End of input]");
                //    errorMessage = errorMessage.Replace(@"'\\r\\n'", "[Newline]");  //easier to understand
                //    errorMessage = errorMessage.Replace("expecting set", "");  //not meningful
                //    errorMessage = errorMessage.Replace("required (...)+ loop did not match anything at input", "unexpected input");  //different phrase in order to distinguish these two
                //    errorMessage = errorMessage.Replace("no viable alternative at input", "did not expect input");  //different phrase in order to distinguish these two
                //}


                if (lineNo > inputFileLines.Count)
                {
                    {
                        G.Writeln2("*** ERROR: " + errorMessage);
                    }

                    continue;  //doesn't give meaning
                }
                string line = "";
                int firstWordPosInLine = -12345;
                bool previousLineProbablyCulprit = false;
                if (lineNo > 0)
                {
                    line = inputFileLines[lineNo - 1];
                    firstWordPosInLine = line.Length - line.TrimStart().Length + 1;
                }

                if (true)
                {
                    if (positionNo == firstWordPosInLine && errorMessage.Contains("no viable"))
                    {
                        //get preceding line (or really: statement) -- most probably the culprit.
                        previousLineProbablyCulprit = true;
                    }

                    if (ph.isOneLinerFromGui == true && lineNo != 1)
                    {
                        G.Writeln("*** ERROR: Parsing this line:");
                        G.Writeln("    " + G.ReplaceGlueNew(inputFileLines[0]), Color.Blue);
                        G.Writeln("*** ERROR: " + errorMessage);
                    }
                    else
                    {
                        if (ph.isOneLinerFromGui == false)
                        {
                            string fn = ph.fileName;
                            string extra = "";
                            if (lineNo >= 1 && positionNo > 0)
                            {
                                extra = " line " + lineNo + " pos " + positionNo;
                            }

                            if (fn == null || fn == "")
                            {
                                G.Writeln("*** ERROR: User input block," + extra);
                            }
                            else
                            {
                                G.Writeln("*** ERROR: Parsing file: " + fn + extra);
                            }
                            G.Writeln("           " + errorMessage);
                        }
                        else
                        {
                            if (positionNo > 0)
                            {
                                G.Writeln("*** ERROR: Parsing pos " + positionNo + ":  " + errorMessage);
                            }
                            else G.Writeln("*** ERROR: " + errorMessage);
                        }
                        line = line + "  ";  //hack to avoid ending problems.....

                        if (positionNo - 1 >= 0)
                        {
                            string lineTemp = line;
                            string line0 = lineTemp.Substring(0, positionNo - 1);
                            string line1 = lineTemp.Substring(positionNo - 1, 1);
                            string line2 = lineTemp.Substring(positionNo - 1 + 1);

                            if (previousLineProbablyCulprit && lineNo > 1)
                            {
                                G.Writeln("    " + "Line " + (lineNo - 1) + " may be the real cause of the problem");
                                string lineBefore = inputFileLines[lineNo - 1 - 1];
                                G.Writeln("    " + "[" + G.IntFormat(lineNo - 1, 4) + "]:" + "   " + G.ReplaceGlueNew(lineBefore), Color.Blue);
                            }

                            G.Write("    " + "[" + G.IntFormat(lineNo, 4) + "]:" + "   " + G.ReplaceGlueNew(line0), Color.Blue);
                            G.Write(G.ReplaceGlueNew(line1), Color.Red);
                            G.Writeln(G.ReplaceGlueNew(line2), Color.Blue);

                            G.Writeln(G.Blanks(positionNo - 1 + 4 + 5 + 5) + "^", Color.Blue);
                            G.Writeln(G.Blanks(positionNo - 1 + 4 + 5 + 5) + "^", Color.Blue);
                            //G.Writeln();
                        }

                    }
                }
                
            }
            if (errors.Count > 1) G.Writeln("--------------------- end of " + errors.Count + " errors --------------");
        }       

        public static void PrintModelLexerErrors(List<string> errors, List<string> inputFileLines, ParseHelper ph)
        {
            if (Globals.threadIsInProcessOfAborting) return;
            if (false && ph.fileName == null && ph.commandsText == null)
            {
                //NO: this will show for instance a stray '?' in the model file
                //ignore, probably an error dublet
                return;
            }
            if (Globals.pipe == true) Program.Pipe("con", null);
            int number = 0;
            foreach (string s in errors)
            {
                number++;
                if (errors.Count > 1)  //always just one
                {
                    if (number == 1) G.Writeln();
                    G.Writeln("--------------------- error #" + number + " of " + errors.Count + "-----------------");
                    //G.Writeln();
                }
                else G.Writeln();

                string[] ss = s.Split(Globals.parserErrorSeparator);
                int lineNumber = int.Parse(ss[0]) - 1;  //seems 1-based before subtract 1
                int lineNo = lineNumber + 1;  //1-based
                int positionNo = int.Parse(ss[1]) + 1;  //1-based

                string errorMessage = ss[3];

                //if (!Globals.useTestParser)
                //{
                //    errorMessage = errorMessage.Replace(" RPGLUE", " ')'");
                //    errorMessage = errorMessage.Replace(" LPGLUE", " '('");
                //    errorMessage = errorMessage.Replace(" RP", " ')'");
                //    errorMessage = errorMessage.Replace(" LP", " '('");
                //    //errorMessage = errorMessage.Replace("expecting set", "");  //remove this, is confusing
                //}

                errorMessage = errorMessage.Replace(@"'\\r\\n'", "<newline>");  //easier to understand

                if (lineNo > inputFileLines.Count)
                {
                    {
                        G.Writeln("*** ERROR: " + errorMessage);
                    }

                    continue;  //doesn't give meaning
                }
                string line = inputFileLines[lineNo - 1];
                int firstWordPosInLine = line.Length - line.TrimStart().Length + 1;

                bool previousLineProbablyCulprit = false;
                if (positionNo == firstWordPosInLine && errorMessage.Contains("no viable"))
                {
                    //get preceding line (or really: statement) -- most probably the culprit.
                    previousLineProbablyCulprit = true;
                }

                string paranthesesError = "";

                if (ph.isOneLinerFromGui == true && lineNo != 1)
                {
                    G.Writeln("*** ERROR: Parsing this line:");
                    G.Writeln("    " + G.ReplaceGlueNew(inputFileLines[0]), Color.Blue);
                    G.Writeln("*** ERROR: " + errorMessage);
                }
                else
                {
                    if (ph.isOneLinerFromGui == false)
                    {
                        {
                            string fn = ph.fileName;
                            if (fn == null || fn == "")
                            {
                                G.Writeln("*** ERROR: Parsing user input block, line " + lineNo + " pos " + positionNo);
                            }
                            else
                            {
                                G.Writeln("*** ERROR: Parsing file: " + fn + " line " + lineNo + " pos " + positionNo);
                            }

                            string e2 = errorMessage.Replace("Der blev udløst en undtagelse af typen ", "");
                            G.Writeln("           " + e2);
                        }
                    }
                    else
                    {
                        G.Writeln("*** ERROR: Parsing pos " + positionNo + ":  " + errorMessage);
                    }
                    line = line + "  ";  //hack to avoid ending problems.....
                    string lineTemp = line;
                    string line0 = lineTemp.Substring(0, positionNo - 1);
                    string line1 = lineTemp.Substring(positionNo - 1, 1);
                    string line2 = lineTemp.Substring(positionNo - 1 + 1);

                    if (previousLineProbablyCulprit && lineNo > 1)
                    {
                        G.Writeln("    " + "Line " + (lineNo - 1) + " may be the real cause of the problem");
                        string lineBefore = inputFileLines[lineNo - 1 - 1];
                        G.Writeln("    " + "[" + G.IntFormat(lineNo - 1, 4) + "]:" + "   " + G.ReplaceGlueNew(lineBefore), Color.Blue);
                    }

                    G.Write("    " + "[" + G.IntFormat(lineNo, 4) + "]:" + "   " + G.ReplaceGlueNew(line0), Color.Blue);
                    G.Write(G.ReplaceGlueNew(line1), Color.Red);
                    G.Writeln(G.ReplaceGlueNew(line2), Color.Blue);

                    G.Writeln(G.Blanks(positionNo - 1 + 4 + 5 + 5) + "^", Color.Blue);
                    G.Writeln(G.Blanks(positionNo - 1 + 4 + 5 + 5) + "^", Color.Blue);
                    //G.Writeln();
                }

                if (paranthesesError != "") G.Writeln(paranthesesError);
        
            }
            if (errors.Count > 1) G.Writeln("--------------------- end of " + errors.Count + " errors --------------");
        }        

        private static void PrintInfoFilesCreateVarsEtc(bool isCalledFromModelStatement)
        {
            //------------------- printing of info files etc. -----------------------------------------------
            if (true)
            {
                ArrayList al = new ArrayList(Program.model.varsAType.Keys);
                al.Sort(StringComparer.InvariantCulture);

                
                List<string> exod = new List<string>();
                List<string> exoj = new List<string>();
                List<string> exoz = new List<string>();
                List<string> exodjz = new List<string>();
                List<string> exo = new List<string>();
                List<string> exotrue = new List<string>();
                List<string> endo = new List<string>();
                List<string> all = new List<string>();

                foreach (string var in al)
                {
                    if (Program.model.m2.endogenous.ContainsKey(var))
                    {
                        Program.model.numberOfEndo++;
                        endo.Add(var);
                    }
                }


                foreach (string var in al)
                {
                    all.Add(var);
                }

                foreach (string var in al)
                {
                    if (!Program.model.m2.endogenous.ContainsKey(var))
                    {
                        exo.Add(var);
                    }
                    if (!Program.model.m2.endogenous.ContainsKey(var) && !Program.model.varsJTypeAutoGenerated.ContainsKey(var) && !Program.model.varsDTypeAutoGenerated.ContainsKey(var) && !Program.model.varsZTypeAutoGenerated.ContainsKey(var))
                    {
                        Program.model.numberOfExo++;
                        exotrue.Add(var);
                    }
                }


                foreach (string var in al)
                {
                    if (Program.model.varsJTypeAutoGenerated.ContainsKey(var) || Program.model.varsDTypeAutoGenerated.ContainsKey(var) || Program.model.varsZTypeAutoGenerated.ContainsKey(var))
                    {
                        Program.model.numberOfDjz++;
                        exodjz.Add(var);
                    }
                    if (Program.model.varsJTypeAutoGenerated.ContainsKey(var))
                    {
                        exoj.Add(var);
                    }
                    if (Program.model.varsDTypeAutoGenerated.ContainsKey(var))
                    {
                        exod.Add(var);
                    }
                    if (Program.model.varsZTypeAutoGenerated.ContainsKey(var))
                    {
                        exoz.Add(var);
                    }
                }

                exod.Sort(StringComparer.InvariantCulture);
                exoj.Sort(StringComparer.InvariantCulture);
                exoz.Sort(StringComparer.InvariantCulture);
                exodjz.Sort(StringComparer.InvariantCulture);
                exo.Sort(StringComparer.InvariantCulture);
                exotrue.Sort(StringComparer.InvariantCulture);
                endo.Sort(StringComparer.InvariantCulture);
                all.Sort(StringComparer.InvariantCulture);
                                
                Program.databanks.GetGlobal().AddIVariableWithOverwrite(Globals.symbolCollection + "exod", new List(Program.GetListOfIVariablesFromListOfStrings(exod.ToArray())));
                Program.databanks.GetGlobal().AddIVariableWithOverwrite(Globals.symbolCollection + "exoj", new List(Program.GetListOfIVariablesFromListOfStrings(exoj.ToArray())));
                Program.databanks.GetGlobal().AddIVariableWithOverwrite(Globals.symbolCollection + "exoz", new List(Program.GetListOfIVariablesFromListOfStrings(exoz.ToArray())));
                Program.databanks.GetGlobal().AddIVariableWithOverwrite(Globals.symbolCollection + "exodjz", new List(Program.GetListOfIVariablesFromListOfStrings(exodjz.ToArray())));
                Program.databanks.GetGlobal().AddIVariableWithOverwrite(Globals.symbolCollection + "exo", new List(Program.GetListOfIVariablesFromListOfStrings(exo.ToArray())));
                Program.databanks.GetGlobal().AddIVariableWithOverwrite(Globals.symbolCollection + "exotrue", new List(Program.GetListOfIVariablesFromListOfStrings(exotrue.ToArray())));
                Program.databanks.GetGlobal().AddIVariableWithOverwrite(Globals.symbolCollection + "endo", new List(Program.GetListOfIVariablesFromListOfStrings(endo.ToArray())));
                Program.databanks.GetGlobal().AddIVariableWithOverwrite(Globals.symbolCollection + "all", new List(Program.GetListOfIVariablesFromListOfStrings(all.ToArray())));
                
                List<string> files = new List<string>();
                files.Add("exod");
                files.Add("exoj");
                files.Add("exoz");
                files.Add("exodjz");
                files.Add("exo");
                files.Add("exotrue");
                files.Add("endo");
                files.Add("all");

                List<List<string>> lists = new List<List<string>>();
                lists.Add(exod);
                lists.Add(exoj);
                lists.Add(exoz);
                lists.Add(exodjz);
                lists.Add(exo);
                lists.Add(exotrue);
                lists.Add(endo);
                lists.Add(all);

                for (int i = 0; i < files.Count; i++)
                {
                    using (FileStream temp = Program.WaitForFileStream(Program.GetModelInfoPath() + "\\" + files[i] + ".lst", Program.GekkoFileReadOrWrite.Write))
                    using (StreamWriter tempFs = G.GekkoStreamWriter(temp))
                    {
                        List<string> oneList = lists[i];
                        foreach (string s in oneList)
                        {
                            tempFs.WriteLine(s);
                        }
                        tempFs.Flush();
                        tempFs.Close();
                    }
                }

                string folder = Program.GetModelInfoPath();  //always a <modelname>__info subfolder to local temp files folder

                if (G.Equal(Program.options.model_infofile, "yes"))
                {
                    string zipFileNameInput = Program.CreateFullPathAndFileName(Globals.modelFileName.Replace(".frm", "") + "__info.zip");
                    Program.WaitForZipWrite(folder, zipFileNameInput);
                }

                //if (isCalledFromModelStatement) G.Writeln("Details regarding model: see " + Path.GetFileName(zipFileNameInput));

            }
        }


        //private static List<string> GetList(string listName)
        //{
        //    IVariable storedList = null;
        //    if (Program.scalars.ContainsKey(Globals.symbolCollection + listName))
        //    {
        //        //use tryget...: faster
        //        storedList = Program.scalars[Globals.symbolCollection + listName];
        //        List x = O.GetList(storedList);
        //        x.list.Clear();
        //    }
        //    else
        //    {
        //        storedList = new List(new List<string>());
        //        Program.scalars.Add(Globals.symbolCollection + listName, storedList);
        //    }
        //    return Program.GetListOfStringsFromList((List)storedList);
        //}

        private static void EmitCsCodeAndCompileModel(ECompiledModelType modelType, bool isCalledFromModelStatement)
        {
            DateTime t0 = DateTime.Now;

            bool failSafe = false;
            if (modelType == ECompiledModelType.GaussFailSafe) failSafe = true;
            string failSafeString = "";
            if (failSafe) failSafeString = "FailSafe";

            string type = Enum.GetName(typeof(ECompiledModelType), modelType);
            bool didWork = false;

            // =====
            // ===== Gauss-type
            // =====

            if ((modelType == ECompiledModelType.Gauss && Program.model.m2.assemblyGauss == null) ||
                (modelType == ECompiledModelType.GaussFailSafe && Program.model.m2.assemblyGaussFailSafe == null) ||
                (modelType == ECompiledModelType.Res && Program.model.m2.assemblyRes == null))
            {
                didWork = true;
                StringBuilder codeGauss = new StringBuilder();
                {

                    codeGauss.Append(
                        @"using System;
                using System.Collections.Generic;
                using System.Text;
                namespace Gekko
                {
                public class " + type +
                        @"{
                public static void eqs(double[] b)
                {");                    
                    
                    if (modelType == ECompiledModelType.Res)
                    {
                        codeGauss.AppendLine("double [] c = new double[b.Length];");
                        codeGauss.AppendLine("for (int i5 = 0; i5 < c.Length; i5++)");
                        codeGauss.AppendLine("{");
                        codeGauss.AppendLine("   c[i5]=b[i5];");
                        codeGauss.AppendLine("}");                        
                    }

                    List<EquationHelper> prologue = new List<EquationHelper>();
                    List<EquationHelper> eqs = new List<EquationHelper>();
                    List<EquationHelper> epilogue = new List<EquationHelper>();

                    if (Globals.fastGauss)
                    {
                        foreach (int endoNumber in Program.model.m2.prologue)
                        {
                            EquationHelper eh = Program.model.equations[endoNumber];
                            prologue.Add(eh);
                        }

                        if (Program.options.solve_gauss_reorder)
                        {
                            foreach (int endoNumber in Program.model.m2.simulRecursive)
                            {
                                EquationHelper eh = Program.model.equations[endoNumber];
                                eqs.Add(eh);
                            }

                            foreach (int endoNumber in Program.model.m2.simulFeedback)
                            {
                                EquationHelper eh = Program.model.equations[endoNumber];
                                eqs.Add(eh);
                            }
                        }
                        else
                        {

                            //This is old code: it is checked that the
                            //ArrayList al = new ArrayList();
                            //al.AddRange(Program.model.m2.simulRecursive);
                            //al.AddRange(Program.model.m2.simulFeedback);
                            //SortedList<int, EquationHelper> sorted = new SortedList<int, EquationHelper>();
                            //foreach (int eq in al)
                            //{
                            //    EquationHelper eh = Program.model.equations[eq];
                            //    sorted.Add(eh.equationNumber, eh);
                            //}
                            //for (int i = 0; i < sorted.Count; i++)
                            //{
                            //    eqs.Add(sorted.Values[i]);
                            //}

                            List<int> allSimul = Program.GetLeftsideBNumbers();
                            foreach (int i in allSimul)
                            {
                                eqs.Add(Program.model.equations[i]);
                            }

                        }

                        foreach (int endoNumber in Program.model.m2.epilogue)
                        {
                            EquationHelper eh = Program.model.equations[endoNumber];
                            epilogue.Add(eh);
                        }

                        //G.Writeln(Program.model.equations.Count + " == " + (prologue.Count + eqs.Count + epilogue.Count));
                        if (Program.model.equations.Count - (prologue.Count + eqs.Count + epilogue.Count) != 0) throw new GekkoException();
                    }

                    List<EquationHelper> gaussEquations = Program.model.equations;
                    if (Globals.fastGauss) gaussEquations = eqs;

                    foreach (EquationHelper eh in gaussEquations)
                    {
                        if (modelType == ECompiledModelType.Res)
                        {
                            codeGauss.Append(eh.csCodeLhsJacobi);
                        }
                        else  //Gauss of GaussFailSafe
                        {
                            codeGauss.Append(eh.csCodeLhsGauss);
                        }

                        codeGauss.Append(" = ");
                        codeGauss.AppendLine(eh.csCodeRhs);
                        codeGauss.AppendLine(";");

                        if (modelType == ECompiledModelType.GaussFailSafe)  //cannot be jacobi failsafe...
                        {
                            codeGauss.AppendLine("if(Double.IsInfinity(" + eh.csCodeLhsGauss + ") || Double.IsNaN(" + eh.csCodeLhsGauss + ")) {");
                            codeGauss.AppendLine("Program.model.simulateResults[1] = 12345;");
                            codeGauss.AppendLine("Program.model.simulateResults[2] = " + eh.equationNumber + ";");
                            codeGauss.AppendLine("return;");
                            codeGauss.AppendLine("}");
                        }
                    }

                    codeGauss.AppendLine();
                    codeGauss.AppendLine();


                    if (modelType == ECompiledModelType.Res)
                    {
                        codeGauss.AppendLine("for (int i5 = 0; i5 < c.Length; i5++)");
                        codeGauss.AppendLine("{");
                        codeGauss.AppendLine("   b[i5]=c[i5];");
                        codeGauss.AppendLine("}");
                    }
                    codeGauss.AppendLine(@"}");  //end of eqs()
                    codeGauss.AppendLine(@"" + "}}");  //namespace and class

                    CompilerParameters compilerParams = new CompilerParameters();
                    compilerParams.CompilerOptions = Globals.compilerOptions;
                    compilerParams.GenerateInMemory = true;
                    compilerParams.IncludeDebugInformation = false;
                    compilerParams.ReferencedAssemblies.Add("system.dll");
                    ReferencedAssembliesGekko(compilerParams);                    
                    compilerParams.GenerateExecutable = false;                    

                    CompilerResults cr = Globals.iCodeCompiler.CompileAssemblyFromSource(compilerParams, codeGauss.ToString());

                    if (cr.Errors.HasErrors)
                    {
                        G.Writeln2("*** ERROR: model not compiled due to errors while compiling for Gauss-Seidel algorithm.");
                        throw new GekkoException();
                    }
                    if (modelType == ECompiledModelType.Gauss)
                    {
                        //Assembly temp = Assembly.LoadFile(@"c:\Users\Thomas\AppData\Local\Temp\gauss.dll");
                        //Program.model.m2.assemblyGauss = temp.GetType("Gekko." + type);
                        Program.model.m2.assemblyGauss = cr.CompiledAssembly.GetType("Gekko." + type);
                    }
                    else if (modelType == ECompiledModelType.GaussFailSafe)
                    {
                        Program.model.m2.assemblyGaussFailSafe = cr.CompiledAssembly.GetType("Gekko." + type);
                    }
                    else if (modelType == ECompiledModelType.Res)
                    {
                        Program.model.m2.assemblyRes = cr.CompiledAssembly.GetType("Gekko." + type);
                    }
                    else throw new GekkoException();  //must be one of these
                }
            }


            // =====
            // ===== Newton-type
            // =====

            if ((modelType == ECompiledModelType.Newton && Program.model.m2.assemblyNewton == null))
            {
                didWork = true;
                StringBuilder codeNewton = new StringBuilder();
                {
                    codeNewton.AppendLine("using System;");
                    codeNewton.AppendLine("using System.Collections.Generic;");
                    codeNewton.AppendLine("using System.Text;");
                    codeNewton.AppendLine("namespace Gekko");
                    codeNewton.AppendLine("{");
                    codeNewton.AppendLine("public class " + type);
                    codeNewton.AppendLine("{");

                    codeNewton.AppendLine("public static void simulPrologue(double[] b)");
                    codeNewton.AppendLine("{");
                    foreach (int endoNumber in Program.model.m2.simulRecursive)
                    {
                        StringBuilder sb = new StringBuilder();
                        EquationHelper eh = Program.model.equations[endoNumber];
                        sb.Append(eh.csCodeLhsGauss);
                        sb.Append(" = ");
                        sb.AppendLine(eh.csCodeRhs);
                        sb.AppendLine(";");
                        sb.AppendLine();
                        if (Program.options.solve_newton_robust) NewtonStartingValuesFixHelper2(sb);
                        codeNewton.Append(sb);

                    }
                    codeNewton.AppendLine("}");

                    codeNewton.AppendLine("public static void simulFeedbackAll(double[] b, double[] r, double[] scale)");
                    codeNewton.AppendLine("{");

                    for (int i = 0; i < Program.model.m2.simulFeedback.Count; i++)
                    {
                        StringBuilder sb = new StringBuilder();
                        int endoNumber = (int)Program.model.m2.simulFeedback[i];
                        EquationHelper eh = Program.model.equations[endoNumber];
                        sb.Append("r[" + i + "] = ");
                        sb.Append(eh.csCodeLhsGauss);
                        sb.Append(" -( ");
                        sb.AppendLine(eh.csCodeRhs);
                        sb.AppendLine(")");
                        sb.AppendLine(";");
                        sb.AppendLine();
                        if (Program.options.solve_newton_robust) NewtonStartingValuesFixHelper2(sb);
                        codeNewton.Append(sb);
                    }
                    codeNewton.AppendLine("}");


                    codeNewton.AppendLine("public static void simulFeedbackSingle(double[] b, double[] r, int n, double[] scale)");
                    codeNewton.AppendLine("{");
                    codeNewton.AppendLine("switch(n)");
                    codeNewton.AppendLine("{");

                    for (int i = 0; i < Program.model.m2.simulFeedback.Count; i++)
                    {
                        StringBuilder sb = new StringBuilder();
                        int endoNumber = (int)Program.model.m2.simulFeedback[i];
                        EquationHelper eh = Program.model.equations[endoNumber];
                        sb.AppendLine("case " + i + ":");
                        sb.Append("r[" + i + "] = ");
                        sb.Append(eh.csCodeLhsGauss);
                        sb.Append(" -( ");
                        sb.AppendLine(eh.csCodeRhs);
                        sb.AppendLine(" ); ");
                        sb.Append("break;");
                        sb.AppendLine();
                        if (Program.options.solve_newton_robust) NewtonStartingValuesFixHelper2(sb);
                        codeNewton.Append(sb);
                    }
                    codeNewton.AppendLine("}");  //case
                    codeNewton.AppendLine("}");  //method

                    codeNewton.AppendLine("}");  //class
                    codeNewton.AppendLine("}");  //namespace
                    //codeNewton.Flush();
                    //codeNewton.Close();

                    CompilerParameters compilerParams = new CompilerParameters();
                    compilerParams = new CompilerParameters();
                    compilerParams.CompilerOptions = Globals.compilerOptions;
                    compilerParams.GenerateInMemory = true;
                    compilerParams.IncludeDebugInformation = false;
                    compilerParams.ReferencedAssemblies.Add("system.dll");
                    //compilerParams.ReferencedAssemblies.Add(Application.ExecutablePath);
                    ReferencedAssembliesGekko(compilerParams);
                    compilerParams.GenerateExecutable = false;
                    string s = codeNewton.ToString();
                    //CompilerResults cr = Program.model.iCodeCompiler.CompileAssemblyFromFile(compilerParams, Globals.localTempFilesLocation + "\\" + type + ".cs");
                    CompilerResults cr = Globals.iCodeCompiler.CompileAssemblyFromSource(compilerParams, s);
                    if (modelType == ECompiledModelType.Newton)
                    {
                        Program.model.m2.assemblyNewton = cr.CompiledAssembly.GetType("Gekko." + type);
                    }
                    else throw new GekkoException();  //must be one of these
                }
            }


            // =====
            // ===== Is always used, both for Gauss and Newton
            // ===== Reverted (auto-JZ and Y-equations) -- put in .model, not .model.m2, because it is common for all EXO/ENDO set.
            // =====

            if ((!failSafe && Program.model.assemblyReverted == null) ||
               (failSafe && Program.model.assemblyRevertedFailSafe == null))
            {

                didWork = true;

                StringBuilder code = new StringBuilder();
                {
                    code.Append(
                        @"using System;
                using System.Collections.Generic;
                using System.Text;
                namespace Gekko
                {
                public class " + "Reverted" + failSafeString +
                        @"{");

                    EmitRevertedEquations(code);  //Same code with and without failsafe. Could maybe introduce failsafe here, for the Y-equations. But never mind for now.
                    //Are static given model, in principle they could be shared for Program.model, and not Program.model.m2 (but maybe not worth the trouble and risk of errors)

                    code.AppendLine("}");  //class
                    code.AppendLine("}");  //namespace

                    CompilerParameters compilerParams = new CompilerParameters();
                    compilerParams = new CompilerParameters();
                    compilerParams.CompilerOptions = Globals.compilerOptions;
                    compilerParams.GenerateInMemory = true;
                    compilerParams.IncludeDebugInformation = false;
                    compilerParams.ReferencedAssemblies.Add("system.dll");
                    //compilerParams.ReferencedAssemblies.Add(Application.ExecutablePath);
                    ReferencedAssembliesGekko(compilerParams);
                    compilerParams.GenerateExecutable = false;

                    CompilerResults cr = Globals.iCodeCompiler.CompileAssemblyFromSource(compilerParams, code.ToString());

                    if (cr.Errors.HasErrors)
                    {
                        throw new GekkoException();
                    }

                    if (!failSafe)
                    {
                        Program.model.assemblyReverted = cr.CompiledAssembly.GetType("Gekko.Reverted");
                    }
                    else
                    {
                        Program.model.assemblyRevertedFailSafe = cr.CompiledAssembly.GetType("Gekko.RevertedFailSafe");
                    }
                }
            }

            // =====
            // ===== Is always used, both for Gauss and Newton
            // ===== Prologue/Epilogue (depends upon ENDO/EXO set, so put in .m2)
            // =====

            if ((!failSafe && Program.model.m2.assemblyPrologueEpilogue == null) ||
                (failSafe && Program.model.m2.assemblyPrologueEpilogueFailSafe == null))
            {
                didWork = true;
                StringBuilder code = new StringBuilder();
                {
                    code.Append(
                        @"using System;
                using System.Collections.Generic;
                using System.Text;
                namespace Gekko
                {
                public class " + "PrologueEpilogue" + failSafeString +
                        @"{");

                    EmitPrologue(failSafeString, code);  //=====> but these are not static with endo/exo???
                    EmitEpilogue(failSafeString, code);  //=====> but these are not static with endo/exo???

                    code.AppendLine("}");  //class
                    code.AppendLine("}");  //namespace

                    CompilerParameters compilerParams = new CompilerParameters();
                    compilerParams = new CompilerParameters();
                    compilerParams.CompilerOptions = Globals.compilerOptions;
                    compilerParams.GenerateInMemory = true;
                    compilerParams.IncludeDebugInformation = false;
                    compilerParams.ReferencedAssemblies.Add("system.dll");
                    //compilerParams.ReferencedAssemblies.Add(Application.ExecutablePath);
                    ReferencedAssembliesGekko(compilerParams);
                    compilerParams.GenerateExecutable = false;

                    CompilerResults cr = Globals.iCodeCompiler.CompileAssemblyFromSource(compilerParams, code.ToString());

                    if (cr.Errors.HasErrors)
                    {
                        throw new GekkoException();
                    }

                    if (failSafeString == "")
                    {
                        Program.model.m2.assemblyPrologueEpilogue = cr.CompiledAssembly.GetType("Gekko.PrologueEpilogue");
                    }
                    else
                    {
                        Program.model.m2.assemblyPrologueEpilogueFailSafe = cr.CompiledAssembly.GetType("Gekko.PrologueEpilogueFailSafe");
                    }
                }
            }

            // =====
            // ===== After (put in .model, not .model.m2, because it is common for all EXO/ENDO set.)
            // =====
            // TODO: after introduction of M2 object, checking for failsafe here is probably not necessay at all
            if (modelType == ECompiledModelType.After && ((!failSafe && Program.model.assemblyAfter == null) ||
                (failSafe && Program.model.assemblyAfterFailSafe == null)))
            {
                //TODO: does not always have to be done, but for now we just keep it.
                didWork = true;
                StringBuilder code = new StringBuilder();
                {
                    code.Append(
                        @"using System;
                using System.Collections.Generic;
                using System.Text;
                namespace Gekko
                {
                public class " + "After" + failSafeString +
                        @"{");

                    EmitAfter(failSafeString, code);    //Are static given model, after() and after2() methods, , in principle they could be shared for Program.model, and not Program.model.m2 (but maybe not worth the trouble and risk of errors)

                    code.AppendLine("}");  //class
                    code.AppendLine("}");  //namespace

                    CompilerParameters compilerParams = new CompilerParameters();
                    compilerParams = new CompilerParameters();
                    compilerParams.CompilerOptions = Globals.compilerOptions;
                    compilerParams.GenerateInMemory = true;
                    compilerParams.IncludeDebugInformation = false;
                    compilerParams.ReferencedAssemblies.Add("system.dll");
                    //compilerParams.ReferencedAssemblies.Add(Application.ExecutablePath);
                    ReferencedAssembliesGekko(compilerParams);
                    compilerParams.GenerateExecutable = false;

                    CompilerResults cr = Globals.iCodeCompiler.CompileAssemblyFromSource(compilerParams, code.ToString());

                    if (cr.Errors.HasErrors)
                    {
                        throw new GekkoException();
                    }

                    if (failSafeString == "")
                    {
                        Program.model.assemblyAfter = cr.CompiledAssembly.GetType("Gekko.After");
                    }
                    else
                    {
                        Program.model.assemblyAfterFailSafe = cr.CompiledAssembly.GetType("Gekko.AfterFailSafe");
                    }
                }
            }  //finished After
            if (didWork)
            {
                string duration = G.SecondsFormat((DateTime.Now - t0).TotalMilliseconds);
                if (isCalledFromModelStatement)
                {
                    Program.model.modelInfo.lastCompileDuration = duration;
                }
                else
                {
                    G.Writeln("Compiling lasted " + duration);
                }
            }
        }

        private static void NewtonStartingValuesFixHelper2(StringBuilder sb)
        {
            sb = sb.Replace("O.Log(", "O.Special_Log(");
            sb = sb.Replace("O.Pow(", "O.Special_Pow(");
        }

        public static void ReferencedAssembliesGekko(CompilerParameters compilerParams)
        {
            if (G.IsUnitTesting())
            {
                //if running test cases, use this absolute path                
                compilerParams.ReferencedAssemblies.Add(Globals.ttPath2 + @"\GekkoCS\Gekko\bin\Debug\gekko.exe");
            }
            else
            {
                compilerParams.ReferencedAssemblies.Add(Application.ExecutablePath);
            }
        }


        private static void EmitEpilogue(string failsafe, StringBuilder codeCommon)
        {
            codeCommon.AppendLine("public static void epilogue(double[] b)");
            codeCommon.AppendLine("{");

            foreach (int endoNumber in Program.model.m2.epilogue)
            {
                EquationHelper eh = Program.model.equations[endoNumber];

                codeCommon.Append(eh.csCodeLhsGauss);
                codeCommon.Append(" = ");
                codeCommon.AppendLine(eh.csCodeRhs);
                codeCommon.AppendLine(";");
                codeCommon.AppendLine();
                if (failsafe != "")
                {
                    codeCommon.AppendLine("if(Double.IsInfinity(" + eh.csCodeLhsGauss + ") || Double.IsNaN(" + eh.csCodeLhsGauss + ")) {");
                    codeCommon.AppendLine("Program.model.simulateResults[1] = 12345;");
                    codeCommon.AppendLine("Program.model.simulateResults[2] = " + eh.equationNumber + ";");
                    codeCommon.AppendLine("return;");
                    codeCommon.AppendLine("}");
                }
            }
            codeCommon.AppendLine("}");
        }

        private static void EmitPrologue(string failsafe, StringBuilder codeCommon)
        {
            codeCommon.AppendLine("public static void prologue(double[] b)");
            codeCommon.AppendLine("{");

            foreach (int endoNumber in Program.model.m2.prologue)
            {
                EquationHelper eh = Program.model.equations[endoNumber];
                codeCommon.Append(eh.csCodeLhsGauss);
                codeCommon.AppendLine(" = ");
                codeCommon.AppendLine(eh.csCodeRhs);
                codeCommon.AppendLine(";");
                codeCommon.AppendLine();

                if (failsafe != "")
                {
                    codeCommon.AppendLine("if(Double.IsInfinity(" + eh.csCodeLhsGauss + ") || Double.IsNaN(" + eh.csCodeLhsGauss + ")) {");
                    codeCommon.AppendLine("Program.model.simulateResults[1] = 12345;");
                    codeCommon.AppendLine("Program.model.simulateResults[2] = " + eh.equationNumber + ";");
                    codeCommon.AppendLine("return;");
                    codeCommon.AppendLine("}");
                }
            }
            codeCommon.AppendLine("}");
        }

        private static void EmitAfter(string failsafe, StringBuilder codeCommon)
        {
            //This is for safety: EmitAfter must not depend upon stuff in .m2!
            Model2 temp = Program.model.m2;
            Program.model.m2 = null;

            try
            {
                int count = 0, count2 = 0;
                codeCommon.AppendLine("public static void after(double[] b) {");
                foreach (EquationHelper eh in Program.model.equations)
                {
                    if (eh.isAfterModel && !eh.isAfter2Model)  //if both are set, it is considered after2
                    {
                        codeCommon.Append(eh.csCodeLhsGauss);
                        codeCommon.Append(" = ");
                        codeCommon.AppendLine(eh.csCodeRhs);
                        codeCommon.AppendLine(";");
                        count++;
                    }
                }
                codeCommon.AppendLine("}");  //end of after()
                codeCommon.AppendLine();

                codeCommon.AppendLine("public static void after2(double[] b) {");
                foreach (EquationHelper eh in Program.model.equations)
                {
                    if (eh.isAfter2Model)  //eh.isAfterModel may or not be true here --> in any case it is considered after2
                    {
                        codeCommon.Append(eh.csCodeLhsGauss);
                        codeCommon.Append(" = ");
                        codeCommon.AppendLine(eh.csCodeRhs);
                        codeCommon.AppendLine(";");
                        count2++;
                    }
                }
                codeCommon.AppendLine("}");  //end of after2()
            }
            catch
            {
                throw;
            }
            finally
            {
                Program.model.m2 = temp;
            }
        }

        private static void EmitRevertedEquations(StringBuilder code)
        {
            //This is for safety: EmitAfter must not depend upon stuff in .m2!
            Model2 temp = Program.model.m2;
            Program.model.m2 = null;

            try
            {
                code.AppendLine("public static void revertedAuto(double[] b) {");
                foreach (EquationHelper eh in Program.model.equationsReverted)
                {
                    if (eh.equationCode == "AUTOGENERATED")
                    {
                        code.Append(eh.csCodeLhsGauss);
                        code.Append(" = ");
                        code.AppendLine(eh.csCodeRhs);
                        code.AppendLine(";");
                    }
                }
                code.AppendLine("}");  //end of reverted()

                code.AppendLine("public static void revertedY(double[] b) {");
                foreach (EquationHelper eh in Program.model.equationsReverted)
                {
                    if (!(eh.equationCode == "AUTOGENERATED"))
                    {
                        code.Append(eh.csCodeLhsGauss);
                        code.Append(" = ");
                        code.AppendLine(eh.csCodeRhs);
                        code.AppendLine(";");
                    }
                }
                code.AppendLine("}");  //end of reverted()
            }
            catch
            {
                throw;
            }
            finally
            {
                Program.model.m2 = temp;
            }
        }

        private static WalkHelper CreateWalkHelper(string textInput)
        {
            WalkHelper wh = new WalkHelper();
            wh.print = false;
            wh.printFile = false;
            wh.inputFile = textInput;
            wh.inputFileLines = Program.CreateListOfStringsFromString(wh.inputFile);
            return wh;
        }

        public static void EmitCsCodeForModel(EquationHelper eh, ASTNode equationNode, int depth, WalkerHelper2 wh2, Model model, int subTreeLag, bool isModel)
        {
            bool visitChildren = true;
            int numberOfRightParentheses = 0;

            if(equationNode==null || equationNode.Text == null)
            {

            }

            switch (equationNode.Text)
            {
                case "ASTFRMLCODE":
                    if (equationNode.Children.Count > 0)
                    {
                        wh2.frmlCode = equationNode.GetChild(0).Text;
                    }
                    visitChildren = false;  //is done
                    break;
                case "ASTLEFTSIDE":
                    ASTNode child = equationNode.GetChild(0);
                    wh2.variableOrFunctionIndicator = child.Text;
                    wh2.leftSideFunction = "";
                    if (wh2.variableOrFunctionIndicator == "ASTSIMPLEFUNCTION")
                    {
                        wh2.leftSideFunction = child.GetChild(0).Text;
                        wh2.variableOrFunctionIndicator = child.GetChild(1).Text;
                    }
                    visitChildren = false;
                    break;
                //case "ASTEXPRESSION":
                //    wh2.rhs = equationNode.GetChild(0);
                //    break;
                case "ASTPOW":
                    {
                        HandlePowFunction(eh, equationNode, depth, wh2, model, subTreeLag, isModel, false);
                        visitChildren = false;
                    }
                    break;
                case "ASTFUNCTION":
                    {
                        //-----------------------------------------
                        //   these are right-hand-side functions
                        //-----------------------------------------
                        string function = equationNode.GetChild(0).Text;
                        int arguments = equationNode.Children.Count - 1;

                        //TODO: do log and exp with nodes

                        bool recognized = false;

                        if (G.Equal(function, "log"))
                        {
                            if (arguments != 1)
                            {
                                G.Writeln2("*** ERROR: Expected log() function with 1 argument");
                                throw new GekkoException();
                            }
                            recognized = true;
                            wh2.rightHandSideCsCode.Append("O.Log(", EEmitType.computerReadable);
                            wh2.rightHandSideCsCode.Append("Log(", EEmitType.humanReadable);
                            numberOfRightParentheses++;
                        }
                        else if (G.Equal(function, "exp"))
                        {
                            if (arguments != 1)
                            {
                                G.Writeln2("*** ERROR: Expected exp() function with 1 argument");
                                throw new GekkoException();
                            }
                            recognized = true;
                            wh2.rightHandSideCsCode.Append("O.Exp(", EEmitType.computerReadable);
                            wh2.rightHandSideCsCode.Append("Exp(", EEmitType.humanReadable);
                            numberOfRightParentheses++;
                        }
                        else if (G.Equal(function, "abs"))
                        {
                            if (arguments != 1)
                            {
                                G.Writeln2("*** ERROR: Expected abs() function with 1 argument");
                                throw new GekkoException();
                            }
                            recognized = true;
                            wh2.rightHandSideCsCode.Append("O.Abs(", EEmitType.computerReadable);
                            wh2.rightHandSideCsCode.Append("Abs(", EEmitType.humanReadable);
                            numberOfRightParentheses++;
                        }
                        else if (G.Equal(function, "dlog") || G.Equal(function, "dlogy"))
                        {
                            int lag = 1;
                            if (G.Equal(function, "dlogy"))
                            {
                                lag = O.CurrentSubperiods();
                                Program.model.subPeriods = lag; //this is used as a safety check, so that if the model is loaded/compiled during one freq, and run during another, we will get an error.
                            }

                            if (arguments != 1)
                            {
                                G.Writeln2("*** ERROR: Expected dlog() function with 1 argument");
                                throw new GekkoException();
                            }
                            recognized = true;
                            //wh2.s.Append("(");
                            //numberOfRightParentheses++;
                            /*
                             *
                             *                         x
                             *                         |
                             *                     ASTFUNCTION
                             *                       /    \
                             *                    dlog    subtree
                             *
                             *                         x
                             *                         |
                             *                     "nothing" (equationNode)
                             *                         |
                             *                        "-" (b)
                             *                       /   \                             *
                             *                      /     ASTLAG (c)
                             *                     /      |    \ \
                             *                    /      /    "-" 1
                             *                ASTFUNCTION (d)
                             *                  /       \
                             *               log (e)   subtree
                             *
                             * */
                            ASTNode subTree = equationNode.GetChild(1);
                            equationNode.Text = "nothing";  //function that does nothing
                            equationNode.Children.Clear();
                            ASTNode b = new ASTNode("-");  //subtraction
                            equationNode.Add(b);
                            ASTNode d = new ASTNode("ASTFUNCTION");
                            ASTNode c = new ASTNode("ASTLAG");
                            b.Children = new List<ASTNode>();
                            b.Add(d);
                            b.Add(c);
                            ASTNode c1 = new ASTNode("-");  //it is a lag
                            ASTNode c2 = new ASTNode(lag.ToString()); //n period lag
                            c.Children = new List<ASTNode>();
                            c.Add(d);
                            c.Add(c1);
                            c.Add(c2);
                            ASTNode e = new ASTNode("log");
                            d.Children = new List<ASTNode>();
                            d.Add(e);
                            d.Add(subTree);
                        }
                        else if (G.Equal(function, "pch") || G.Equal(function, "pchy"))
                        {
                            int lag = 1;
                            if (G.Equal(function, "pchy"))
                            {
                                lag = O.CurrentSubperiods();
                                Program.model.subPeriods = lag; //this is used as a safety check, so that if the model is loaded/compiled during one freq, and run during another, we will get an error.
                            }

                            if (arguments != 1)
                            {
                                G.Writeln2("*** ERROR: Expected pch() function with 1 argument");
                                throw new GekkoException();
                            }
                            recognized = true;
                            //wh2.s.Append("(");
                            //numberOfRightParentheses++;
                            /*
                             *
                             *                         x
                             *                         |
                             *                     ASTFUNCTION
                             *                       /    \
                             *                    pch    subtree
                             *
                             *                         x
                             *                         |
                             *                        "nothing" (equationNode)
                             *                         |
                             *                        "*" (f) --------------------------------- 100
                             *                         |
                             *                         |
                             *                        "-" (g) --------------------------------- 1
                             *                         |
                             *                         |
                             *                        "/" (b)
                             *                       /   \
                             *                      /     ASTLAG (c)
                             *                     /      |    \ \
                             *                    /      /    "-" 1
                             *                  subtree (d)
                             *
                             *
                             *
                             * */
                            ASTNode f = new ASTNode("*", true);
                            ASTNode g = new ASTNode("-", true);
                            f.Add(g);
                            f.Add(new ASTNode("ASTDOUBLE", "100"));
                            ASTNode subTree = equationNode.GetChild(1);
                            equationNode.Text = "nothing";  //function that does nothing
                            equationNode.Children.Clear();
                            ASTNode b = new ASTNode("/", true);  //subtraction
                            g.Add(b);
                            g.Add(new ASTNode("ASTDOUBLE", "1"));
                            equationNode.Add(f);
                            ASTNode d = subTree;
                            ASTNode c = new ASTNode("ASTLAG", true);
                            b.Add(d);
                            b.Add(c);
                            ASTNode c1 = new ASTNode("-");  //it is a lag
                            ASTNode c2 = new ASTNode(lag.ToString()); //n period lag
                            c.Add(d);
                            c.Add(c1);
                            c.Add(c2);
                        }
                        else if (G.Equal(function, "lag"))
                        {
                            if (arguments != 2)
                            {
                                G.Writeln2("*** ERROR: Expected lag() function with 2 arguments");
                                throw new GekkoException();
                            }
                            recognized = true;

                            ASTNode lags = equationNode.GetChild(2);
                            int intLags = GetLags(wh2, function, lags);

                            /*
                           *
                           *                         x
                           *                         |
                           *                     ASTFUNCTION
                           *                       /    \
                           *                    dif     subtree
                           *
                           *                         x
                           *                         |
                           *                     "nothing" (equationNode)
                           *                         |
                           *                          \
                           *                           \                             
                           *                            ASTLAG (c)
                           *                            |    \ \
                           *                           /    "-" 1
                           *                     subtree
                           *
                           *
                           *
                           * */

                            ASTNode subTree = equationNode.GetChild(1);
                            equationNode.Text = "nothing";  //function that does nothing
                            equationNode.Children.Clear();
                            ASTNode c = new ASTNode("ASTLAG");
                            ASTNode c1 = new ASTNode("-"); //it is a lag
                            ASTNode c2 = new ASTNode(intLags.ToString()); //n period lag
                            equationNode.Add(c);
                            c.Children = new List<ASTNode>();
                            c.Add(subTree);
                            c.Add(c1);
                            c.Add(c2);
                        }
                        else if (G.Equal(function, "dif") || G.Equal(function, "diff") || G.Equal(function, "dify") || G.Equal(function, "diffy"))
                        {
                            int lag = 1;
                            if (G.Equal(function, "dify") || G.Equal(function, "diffy"))
                            {
                                lag = O.CurrentSubperiods();
                                Program.model.subPeriods = lag; //this is used as a safety check, so that if the model is loaded/compiled during one freq, and run during another, we will get an error.
                            }

                            if (arguments != 1)
                            {
                                G.Writeln2("*** ERROR: Expected dif() function with 1 argument");
                                throw new GekkoException();
                            }
                            recognized = true;
                            /*
                            *
                            *                         x
                            *                         |
                            *                     ASTFUNCTION
                            *                       /    \
                            *                    dif     subtree
                            *
                            *                         x
                            *                         |
                            *                     "nothing" (equationNode)
                            *                         |
                            *                        "-" (b)
                            *                       /   \                             *
                            *                      /     ASTLAG (c)
                            *                     /      |    \ \
                            *                    /      /    "-" 1
                            *                    subtree
                            *
                            *
                            *
                            * */
                            //wh2.s.Append("(");
                            //numberOfRightParentheses++;
                            // see "dlog" for explanation
                            ASTNode subTree = equationNode.GetChild(1);
                            equationNode.Text = "nothing";  //function that does nothing
                            equationNode.Children.Clear();
                            ASTNode b = new ASTNode("-");//subtraction
                            equationNode.Add(b);
                            ASTNode c = new ASTNode("ASTLAG");
                            b.Children = new List<ASTNode>();
                            b.Add(subTree);
                            b.Add(c);
                            ASTNode c1 = new ASTNode("-"); //it is a lag
                            ASTNode c2 = new ASTNode(lag.ToString()); //n period lag
                            c.Children = new List<ASTNode>();
                            c.Add(subTree);
                            c.Add(c1);
                            c.Add(c2);
                        }
                        else if (G.Equal(function, "movavg") || G.Equal(function, "movsum"))
                        {

                            if (arguments != 2)
                            {
                                G.Writeln2("*** ERROR: Expected " + function + "() function with 2 arguments");
                                throw new GekkoException();
                            }
                            recognized = true;

                            ASTNode lags = equationNode.GetChild(2);

                            int intLags = GetLags(wh2, function, lags);

                            /*
                            *
                            *                         x
                            *                         |
                            *                     ASTFUNCTION
                            *                       /    \
                            *                    dif     subtree
                            *
                            *                         x
                            *                         |
                            *                     "nothing" (equationNode)
                            *                         |
                            *                        "+" (b)
                            *                       /   \                             *
                            *                      /     +
                            *                     /     / \
                            *                    /     /   +
                            *                             / \ 
                            *                               ...
                            *                   subtree
                            *                   left brachnes have ASTLAG
                            *
                            *
                            * */
                            //wh2.s.Append("(");
                            //numberOfRightParentheses++;
                            // see "dlog" for explanation
                            ASTNode subTree = equationNode.GetChild(1);
                            equationNode.Text = "nothing";  //function that does nothing
                            equationNode.Children.Clear();

                            ASTNode container = new Gekko.ASTNode("nothing");
                            container.Children = new List<Gekko.ASTNode>();

                            ASTNode cRightOld = new ASTNode("+"); //addition
                            cRightOld.Children = new List<ASTNode>();

                            container.Add(cRightOld);

                            for (int i = 0; i < intLags - 1; i++)
                            {
                                ASTNode cLeft = new ASTNode("ASTLAG");
                                cLeft.Children = new List<ASTNode>();
                                cLeft.Add(subTree);
                                cLeft.Add(new ASTNode("-"));
                                cLeft.Add(new ASTNode(i.ToString()));

                                ASTNode cRightNew = null;

                                if (i < intLags - 2)
                                {
                                    cRightNew = new ASTNode("+"); //addition
                                    cRightNew.Children = new List<ASTNode>();
                                }
                                else
                                {
                                    cRightNew = new ASTNode("ASTLAG");
                                    cRightNew.Children = new List<ASTNode>();
                                    cRightNew.Add(subTree);
                                    cRightNew.Add(new ASTNode("-"));
                                    cRightNew.Add(new ASTNode((i + 1).ToString()));
                                }
                                cRightOld.Add(cLeft);
                                cRightOld.Add(cRightNew);

                                cRightOld = cRightNew;
                            }

                            if (G.Equal(function, "movsum"))
                            {
                                equationNode.Add(container);
                            }
                            else
                            {
                                ASTNode temp = new ASTNode("/");
                                temp.Children = new List<Gekko.ASTNode>();
                                temp.Add(container);
                                temp.Add(new ASTNode("ASTDOUBLE", intLags.ToString()));
                                equationNode.Add(temp);
                            }
                        }
                        else if (G.Equal(function, "pow"))
                        {
                            if (arguments != 2)
                            {
                                G.Writeln2("*** ERROR: Expected pow() function with 2 arguments");
                                throw new GekkoException();
                            }
                            recognized = true;
                            HandlePowFunction(eh, equationNode, depth, wh2, model, subTreeLag, isModel, true);
                            visitChildren = false;
                        }
                        else if (G.Equal(function, "CES_UC") || G.Equal(function, "CES_XL") || G.Equal(function, "CES_XR") || G.Equal(function, "CES_COSTS") || G.Equal(function, "CES_FACTOR1") || G.Equal(function, "CES_FACTOR2") || G.Equal(function, "CES_AC"))
                        {
                            //See #09875209837532
                            recognized = true;
                            wh2.rightHandSideCsCode.Append("Functions." + function + "(", EEmitType.computerReadable);
                            wh2.rightHandSideCsCode.Append(function, EEmitType.humanReadable);
                            numberOfRightParentheses++;
                        }

                        if (recognized == false)
                        {
                            //Se also #09835742345
                            G.Writeln2(G.ReplaceGlueNew(eh.equationText), Color.Red);
                            G.Writeln2("*** ERROR: Function '" + function + "' with " + arguments + " arguments");
                            G.Write("           cannot be recognized (see ", Color.Red);
                            G.WriteLink("functions", "help:" + "i_functions");
                            G.Writeln(")", Color.Red);
                            throw new GekkoException();
                        }
                    }
                    break;
                case "ASTLAG":
                    int lagHere = int.Parse(equationNode.GetChild(2).Text);
                    if (equationNode.GetChild(1).Text == "-")
                    {
                        lagHere = -lagHere;  //keeps sign if it is "+"
                    }
                    else if (equationNode.GetChild(1).Text == "+")
                    {
                        //do nothing
                    }
                    else throw new GekkoException();
                    subTreeLag = subTreeLag + lagHere;  //puts on top of any preexisting lag in this subtree (for instance if y = dif(dif(x))
                    break;
                case "ASTVARIABLE":  //no lag
                    {
                        string variable3 = equationNode.GetChild(0).Text;
                        int lag = 0 + subTreeLag;
                        bool isBaseBank = false;
                        string namedBank = null;
                        if (!isModel)
                        {
                            if (G.Equal(equationNode.GetChild(1).Text, "true"))
                            {
                                isBaseBank = true;
                            }
                            else if (G.Equal(equationNode.GetChild(1).Text, "ASTBANK"))
                            {
                                namedBank = equationNode.GetChild(1).GetChild(0).Text;
                            }
                        }
                        EmitCsDoVariableStuff(eh, wh2, model, isModel, variable3, lag, isBaseBank, null, namedBank);
                        visitChildren = false; //all children are done
                    }
                    break;
                case "ASTVARIABLELAGLEAD":
                    {
                        if (true)
                        {
                            //If it is a broken lag, it looks like this:
                            //
                            //            ASTEXPRESSION
                            //            /
                            //           /
                            //       ASTVARIABLELAGLEAD
                            //       /     /    \      \
                            //      /     /      \      \
                            //     fY    -       0.3    FALSE
                            //
                            // This is converted into:
                            //
                            //                            ASTEXPRESSION
                            //                                /
                            //                               /
                            //                              +
                            //                            /   \
                            //                           /     \
                            //                   --------       ------------
                            //                  /                            \
                            //                 /                              \
                            //                *                                *
                            //               / \                              / \
                            //              /   \                            /   \
                            //             /    ASTDOUBLE                   /    ASTDOUBLE
                            //            /        0.7                     /        0.3
                            //           /                                /
                            //       ASTVARIABLELAGLEAD               ASTVARIABLELAGLEAD
                            //       /     /    \      \              /     /    \      \
                            //      /     /      \      \            /     /      \      \
                            //     fY    -        0     FALSE       fY    -        1     FALSE

                            string namedBank = null;
                            bool isBaseBank2 = false;
                            if (!isModel)
                            {
                                if (G.Equal(equationNode.GetChild(3).Text, "true"))
                                {
                                    isBaseBank2 = true;
                                }
                                else if (G.Equal(equationNode.GetChild(3).Text, "ASTBANK"))
                                {
                                    namedBank = equationNode.GetChild(3).GetChild(0).Text;
                                }
                            }

                            string variable2 = equationNode.GetChild(0).Text;

                            
                            double lagDouble = double.NaN;
                            if (!G.TryParseIntoDouble(equationNode.GetChild(2).Text, out lagDouble)) lagDouble = double.NaN;

                            if (equationNode.GetChild(1).Text == "+")
                            {
                                //do nothing
                            }
                            else if (equationNode.GetChild(1).Text == "-")
                            {
                                lagDouble = -lagDouble;
                            }
                            else if (equationNode.GetChild(1).Text == "ABSOLUTE")
                            {
                                //absolute period, e.g. fY(2001q3)
                                if (isModel)
                                {
                                    G.Writeln2("*** ERROR: absolute dates are not allowed in model");
                                    G.Writeln(eh.equationText);
                                    throw new GekkoException();
                                }
                                else
                                {
                                    //an absolute period
                                    string absoluteTime = equationNode.GetChild(2).Text;
                                    EmitCsDoVariableStuff(eh, wh2, model, isModel, variable2, -12345, isBaseBank2, absoluteTime, namedBank);
                                    visitChildren = false; //all children are done
                                    break;
                                }
                            }
                            else throw new GekkoException();
                            lagDouble += subTreeLag;
                            if (Math.Abs(lagDouble - Math.Round(lagDouble)) < Globals.toleranceRegardingBrokenLagsOrLeads)
                            {
                                //a non-broken lag/lead
                                int nonbrokenlag = Convert.ToInt32(lagDouble);
                                double dif = (double)nonbrokenlag - lagDouble;
                                if (Math.Abs(dif) > 0.01d)
                                {
                                    throw new GekkoException();
                                }
                                EmitCsDoVariableStuff(eh, wh2, model, isModel, variable2, nonbrokenlag, isBaseBank2, null, namedBank);
                                visitChildren = false; //all children are done
                            }
                            else
                            {
                                //a broken lag/lead
                                int lowInt = (int)Math.Floor(lagDouble);
                                int highInt = (int)Math.Ceiling(lagDouble);
                                double lambdaHigh = lagDouble - (double)lowInt;
                                double lambdaLow = (double)highInt - lagDouble;
                                ASTNode low = new ASTNode("*", true);
                                ASTNode high = new ASTNode("*", true);
                                ASTNode low1 = new ASTNode("ASTVARIABLELAGLEAD", true);
                                ASTNode low2 = new ASTNode("ASTDOUBLE", "" + lambdaLow);
                                low.Add(low1);
                                low.Add(low2);
                                ASTNode high1 = new ASTNode("ASTVARIABLELAGLEAD", true);
                                ASTNode high2 = new ASTNode("ASTDOUBLE", "" + lambdaHigh);
                                high.Add(high1);
                                high.Add(high2);
                                low1.Add(new ASTNode(equationNode.GetChild(0).Text));  //varname
                                if (lowInt < 0) low1.Add(new ASTNode("-"));
                                else low1.Add(new ASTNode("+"));
                                low1.Add(new ASTNode(Math.Abs(lowInt) + ""));
                                if (isModel == false) low1.Add(new ASTNode(equationNode.GetChild(3).Text));  //if base bank
                                high1.Add(new ASTNode(equationNode.GetChild(0).Text));  //varname
                                if (highInt < 0) high1.Add(new ASTNode("-"));
                                else high1.Add(new ASTNode("+"));
                                high1.Add(new ASTNode(Math.Abs(highInt) + ""));
                                if (isModel == false) high1.Add(new ASTNode(equationNode.GetChild(3).Text));  //if base bank
                                equationNode.Children.Clear();  //stripping children, in order to add the new subtree
                                equationNode.Text = "nothing";  //nothing is done in this node
                                ASTNode plus = new ASTNode("+", true);
                                plus.Add(low);
                                plus.Add(high);
                                equationNode.Add(plus);
                                visitChildren = true; //should continue in the new tree below!
                            }
                        }
                    }
                    break;
                case "NEGATE":
                    wh2.rightHandSideCsCode.Append("-(");
                    numberOfRightParentheses++;
                    break;
                case "ASTDOUBLE":
                    string number1 = equationNode.GetChild(0).Text;
                    if (number1.EndsWith(".")) number1 = number1 + "0";  //otherwise "1." becomes "1.d" which is not allowed
                    wh2.rightHandSideCsCode.Append(number1 + "d", EEmitType.computerReadable);  //d means double, 1 for non-human readable
                    wh2.rightHandSideCsCode.Append(number1, EEmitType.humanReadable);  //2 for human readable
                    break;
                case "ASTASSIGNVAR":
                    //In Gekko 2.0, the var is %x, not #x.
                    string value = HandleModelVal(equationNode, wh2);
                    wh2.rightHandSideCsCode.Append(value + "d", EEmitType.computerReadable);  //d means double, 1 for non-human readable
                    wh2.rightHandSideCsCode.Append(value, EEmitType.humanReadable);  //2 for human readable
                    break;
                case "ASTINTEGER":
                    string number2 = equationNode.GetChild(0).Text;
                    wh2.rightHandSideCsCode.Append(number2 + "d", EEmitType.computerReadable);  //d means double, 1 for non-human readable
                    wh2.rightHandSideCsCode.Append(number2, EEmitType.humanReadable);  //2 for human readable
                    break;
                case "ASTEXPRESSION":
                    //left side variable is also handled here
                    wh2.rightHandSideCsCode.AppendLine("");  //to force a newline
                    eh.precedentsWithLagIndicator = new GekkoDictionary<string, string>(StringComparer.OrdinalIgnoreCase);
                    eh.equationCode = wh2.frmlCode;
                    //left-hand side (e.g. "b[123] =") below
                    printVariableAsBType(eh, wh2, model, wh2.variableOrFunctionIndicator, 0, true, false, isModel, false, null, null);  //no lag //true=leftside //no named bank
                    //wh2.rightHandSideCsCode.Append(" = ");  //added manually later on
                    wh2.rhs = equationNode.GetChild(0);
                    ASTNode rhs = wh2.rhs;
                    eh.lhsWithLagIndicator = wh2.variableOrFunctionIndicator + Globals.lagIndicator + "0";  //lag is 0 on left hand side
                    eh.lhs = wh2.variableOrFunctionIndicator;

                    ASTNode root0 = rhs;
                    ASTNode root1 = root0;  //default value, if it is not changed
                    if (wh2.leftSideFunction == "")
                    {
                        //do nothing
                    }
                    else
                    {
                        //either:
                        // var = exp(...)                   (log)
                        // var = var(-1) * exp(...)         (dlog)
                        // var = var(-1) * (.../100 + 1)    (pch)
                        // var = var(-n) * (.../100 + 1)    (pchy, n=4 or 12)
                        // var = var(-1) + (...)            (dif)
                        /*
                         *                   ASTFUNCTION
                         *
                         *
                         *
                         * */
                        //These are left-hand side functions
                        if (G.Equal(wh2.leftSideFunction, "log"))
                        {
                            root1 = new ASTNode("ASTFUNCTION", "exp");
                            root1.Add(root0);
                        }
                        else if (G.Equal(wh2.leftSideFunction, "dlog") || G.Equal(wh2.leftSideFunction, "dlogy"))
                        {
                            int lag = 1;
                            if (G.Equal(wh2.leftSideFunction, "dlogy"))
                            {
                                lag = O.CurrentSubperiods();
                                Program.model.subPeriods = lag; //this is used as a safety check, so that if the model is loaded/compiled during one freq, and run during another, we will get an error.
                            }
                            root1 = new ASTNode("*", true);
                            ASTNode child1 = new ASTNode("ASTVARIABLELAGLEAD", true);
                            ASTNode child2 = new ASTNode("ASTFUNCTION", true);
                            root1.Add(child1);
                            root1.Add(child2);
                            child1.Add(new ASTNode(eh.lhs));
                            child1.Add(new ASTNode("-"));  //lag
                            child1.Add(new ASTNode(lag.ToString()));  //lag n
                            //for GENR, cannot be a @-variable on left side, so:
                            child1.Add(new ASTNode("FALSE"));  //not baseline bank
                            child2.Add(new ASTNode("exp"));
                            child2.Add(root0);
                        }
                        else if (G.Equal(wh2.leftSideFunction, "pch") || G.Equal(wh2.leftSideFunction, "pchy"))
                        {
                            int lag = 1;
                            if (G.Equal(wh2.leftSideFunction, "pchy"))
                            {
                                lag = O.CurrentSubperiods();
                                Program.model.subPeriods = lag; //this is used as a safety check, so that if the model is loaded/compiled during one freq, and run during another, we will get an error.
                            }
                            root1 = new ASTNode("*", true);
                            ASTNode child1 = new ASTNode("ASTVARIABLELAGLEAD", true);
                            ASTNode child2 = new ASTNode("+", true);
                            root1.Add(child1);
                            root1.Add(child2);
                            child1.Add(new ASTNode(eh.lhs));
                            child1.Add(new ASTNode("-"));  //lag
                            child1.Add(new ASTNode(lag.ToString()));  //lag n
                            //for GENR, cannot be a @-variable on left side, so:
                            child1.Add(new ASTNode("FALSE"));  //not baseline bank
                            ASTNode child21 = new ASTNode("/", true);
                            ASTNode child22 = new ASTNode("ASTDOUBLE", "1.0");
                            child21.Add(root0);
                            child21.Add(new ASTNode("ASTDOUBLE", "100"));
                            child2.Add(child21);
                            child2.Add(child22);
                        }                        
                        else if (G.Equal(wh2.leftSideFunction, "dif") || G.Equal(wh2.leftSideFunction, "diff") || G.Equal(wh2.leftSideFunction, "dify") || G.Equal(wh2.leftSideFunction, "diffy"))
                        {
                            int lag = 1;
                            if (G.Equal(wh2.leftSideFunction, "dify") || G.Equal(wh2.leftSideFunction, "diffy"))
                            {
                                lag = O.CurrentSubperiods();
                                Program.model.subPeriods = lag; //this is used as a safety check, so that if the model is loaded/compiled during one freq, and run during another, we will get an error.
                            }
                            root1 = new ASTNode("+", true);
                            ASTNode child1 = new ASTNode("ASTVARIABLELAGLEAD", true);
                            ASTNode child2 = root0;
                            root1.Add(child1);
                            root1.Add(child2);
                            child1.Add(new ASTNode(eh.lhs));
                            child1.Add(new ASTNode("-"));  //lag
                            child1.Add(new ASTNode(lag.ToString()));  //lag n
                            //for GENR, cannot be a @-variable on left side, so:
                            child1.Add(new ASTNode("FALSE"));  //not baseline bank
                        }
                        else
                        {
                            G.Writeln2("*** ERROR: Function '" + wh2.leftSideFunction + "' cannot be recognized. On left hand side, these");
                            G.Writeln("    functions are supported: log, dlog, pch, dif");
                            throw new GekkoException();
                        }
                    }
                    /** * -------------------------------------------------------------
                     * JRD
                     *                       +
                     *                    /     \
                     *               --- *       \
                     *             /      \       *
                     *       -----*        -     /  \
                     *      /      \      / \   D    Z
                     *  subtree     +    1   D
                     *            /   \
                     *           1    JR
                     *
                     * ------------------------------------------------------------
                     * * J_D
                     *                       +
                     *                    /     \
                     *               --- *       \
                     *             /      \       *
                     *       ---- +        -     /  \
                     *      /      \      / \   D    Z
                     *  subtree     J    1   D
                     *
                     * -------------------------------------------------------------
                     * JR
                     *
                     *       ---- *
                     *      /      \
                     *  subtree     +
                     *            /   \
                     *           1    JR
                     *
                     * * -------------------------------------------------------------
                     *  J_
                     *
                     *       ---- +
                     *      /      \
                     *  subtree     J
                     *
                     * * * -------------------------------------------------------------
                     * __D
                     *                       +
                     *                    /     \
                     *               --- *       \
                     *             /      \       *
                     *       subtree       -     /  \
                     *                    / \   D    Z
                     *                   1   D
                     *
                     *  ------------------------------------------------------------
                     *  NOTE: 1 is really a tree with ASTDOUBLE and child "1.0"
                     *
                     * */
                    ExtractDJZAndEquationTypeFromEquationCode(eh, model, isModel);  //Note: code may be changed to "_i" here
                    string codeError = "";
                    ASTNode root2 = root1;  //default value, without DJZ-vars
                    if (!(eh.equationType == EEquationType.RevertedAutoGenerated || eh.equationType == EEquationType.RevertedY))
                    {
                        //adding J-variables
                        if (G.Equal(eh.equationCodeJ, "j_") || G.Equal(eh.equationCodeJ, "jd"))
                        {
                            eh.equationCodeJadditive = true;
                        }
                        else if (G.Equal(eh.equationCodeJ, "jr"))
                        {
                            eh.equationCodeJmultiplicative = true;
                        }
                        else if (eh.equationCodeJ != "" && eh.equationCodeJ != "__") codeError += "Expected 'J_' or 'JD' or 'JR' in position 3-4 in equation code\n";

                        string jled2 = eh.equationCodeJ.ToUpper();
                        if (G.Equal(jled2, "j_")) jled2 = "J";  //stripping the "_"
                        eh.Jname = jled2 + eh.lhs;
                        //at this point, jled2 may be = "", so eh.Jname is same as eh.lhs.
                        if (eh.equationCodeJmultiplicative)
                        {
                            //multiplicative
                            root2 = new ASTNode("*", true);
                            ASTNode child2 = new ASTNode("+", true);
                            root2.Add(root1);
                            root2.Add(child2);
                            child2.Add(new ASTNode("ASTDOUBLE", "1.0"));
                            child2.Add(new ASTNode("ASTVARIABLE", eh.Jname, "FALSE"));  //cannot be base bank
                            AddToDictionary(model.varsJTypeAutoGenerated, eh.Jname, model);
                        }
                        else if (eh.equationCodeJadditive)
                        {
                            //additive
                            root2 = new ASTNode("+", true);
                            root2.Add(root1);
                            root2.Add(new ASTNode("ASTVARIABLE", eh.Jname, "FALSE"));  //cannot be base bank
                            AddToDictionary(model.varsJTypeAutoGenerated, eh.Jname, model);
                        }
                    }
                    ASTNode root3 = root2;  //default value
                    if (!(eh.equationType == EEquationType.RevertedAutoGenerated || eh.equationType == EEquationType.RevertedY))
                    {
                        //D- and Z-vars, including reverted equations
                        if (G.Equal(eh.equationCodeD, "d"))
                        {
                            root3 = new ASTNode("+", true);
                            eh.Dname = "D" + eh.lhs;
                            eh.Zname = "Z" + eh.lhs;
                            AddToDictionary(model.varsDTypeAutoGenerated, eh.Dname, model);
                            AddToDictionary(model.varsZTypeAutoGenerated, eh.Zname, model);
                            ASTNode child1 = new ASTNode("*", true);
                            ASTNode child2 = new ASTNode("*", true);
                            root3.Add(child1);
                            root3.Add(child2);
                            ASTNode child12 = new ASTNode("-", true);
                            child1.Add(root2);  //this root may have J-factors included
                            child1.Add(child12);
                            child12.Add(new ASTNode("ASTDOUBLE", "1.0"));
                            child12.Add(new ASTNode("ASTVARIABLE", eh.Dname, "FALSE")); //cannot be base bank
                            child2.Add(new ASTNode("ASTVARIABLE", eh.Dname, "FALSE"));  //cannot be base bank
                            child2.Add(new ASTNode("ASTVARIABLE", eh.Zname, "FALSE"));  //cannot be base bank
                            //create reverted equations for J- and Z-variables
                            if (eh.equationCodeJadditive)
                            {
                                //TODO: clean up, reorder, rename, do diagram
                                ASTNode FrmlJ = new ASTNode("ASTFRML", true);  //super-root
                                ASTNode root4 = new ASTNode("-", true);
                                FrmlJ.Add(new ASTNode("ASTFRMLCODE", "AUTOGENERATED"));
                                FrmlJ.Add(new ASTNode("ASTLEFTSIDE", eh.Jname));
                                ASTNode ex = new ASTNode("ASTEXPRESSION", true);
                                ex.Add(root4);
                                FrmlJ.Add(ex);
                                ASTNode child41 = new ASTNode("ASTVARIABLE", eh.lhs);
                                ASTNode child42 = root1;
                                root4.Add(child41);
                                root4.Add(child42);
                                EquationHelper ehJ = new EquationHelper();
                                ehJ.lhs = eh.Jname;
                                ehJ.lhsWithLagIndicator = eh.Jname + Globals.lagIndicator + "0";
                                ehJ.equationType = EEquationType.RevertedAutoGenerated;
                                ehJ.equationsNodeRoot = FrmlJ;
                                ehJ.equationNumber = model.equationsReverted.Count;
                                model.equationsReverted.Add(ehJ);
                            }
                            if (eh.equationCodeJmultiplicative)
                            {
                                //TODO: clean up, reorder, rename, do diagram
                                ASTNode FrmlJR = new ASTNode("ASTFRML", true);  //super-root
                                ASTNode root4 = new ASTNode("-", true);
                                ASTNode root4child = new ASTNode("/", true);
                                root4.Add(root4child);
                                root4.Add(new ASTNode("ASTDOUBLE", "1"));
                                FrmlJR.Add(new ASTNode("ASTFRMLCODE", "AUTOGENERATED"));
                                FrmlJR.Add(new ASTNode("ASTLEFTSIDE", eh.Jname));
                                ASTNode ex = new ASTNode("ASTEXPRESSION", true);
                                ex.Add(root4);
                                FrmlJR.Add(ex);
                                ASTNode child41 = new ASTNode("ASTVARIABLE", eh.lhs);
                                ASTNode child42 = root1;
                                root4child.Add(child41);
                                root4child.Add(child42);
                                EquationHelper ehJR = new EquationHelper();
                                ehJR.lhs = eh.Jname;
                                ehJR.lhsWithLagIndicator = eh.Jname + Globals.lagIndicator + "0";
                                ehJR.equationType = EEquationType.RevertedAutoGenerated;
                                ehJR.equationsNodeRoot = FrmlJR;
                                ehJR.equationNumber = model.equationsReverted.Count;
                                model.equationsReverted.Add(ehJR);
                            }

                            bool z = false;
                            if (Globals.patch_zvar)
                            {
                                //With this patch, we always do the inverted Z-eqation, even if there are no J, JD, or JR. So this may be an FRML _D__D for instance. Then the Z-variable will always be ready after simulation.
                                z = true;
                            }
                            else
                            {
                                if (eh.equationCodeJadditive || eh.equationCodeJmultiplicative)
                                {
                                    z = true;
                                }
                            }

                            if(z)
                            {
                                //TODO: clean up, reorder, rename, do diagram
                                ASTNode FrmlZ = new ASTNode("ASTFRML", true);  //super-root
                                FrmlZ.Add(new ASTNode("ASTFRMLCODE", "AUTOGENERATED"));
                                FrmlZ.Add(new ASTNode("ASTLEFTSIDE", eh.Zname));
                                ASTNode ex = new ASTNode("ASTEXPRESSION", true);
                                ex.Add(new ASTNode("ASTVARIABLE", eh.lhs));
                                FrmlZ.Add(ex);
                                EquationHelper ehZ = new EquationHelper();
                                ehZ.lhs = eh.Zname;
                                ehZ.lhsWithLagIndicator = eh.Zname + Globals.lagIndicator + "0";
                                ehZ.equationType = EEquationType.RevertedAutoGenerated;
                                ehZ.equationsNodeRoot = FrmlZ;
                                ehZ.equationNumber = model.equationsReverted.Count;
                                model.equationsReverted.Add(ehZ);
                            }
                        }
                        else if (eh.equationCodeD == "" || eh.equationCodeD == "_")
                        {
                            //Not autogenerated D- and Z-vars (but we need the reverted J-equation
                            if (eh.equationCodeJadditive)
                            {
                                if (Globals.revertSimpleJ)
                                {
                                    //TODO: clean up, reorder, rename, do diagram
                                    ASTNode FrmlJ = new ASTNode("ASTFRML", true);  //super-root
                                    ASTNode root4 = new ASTNode("-", true);
                                    FrmlJ.Add(new ASTNode("ASTFRMLCODE", "AUTOGENERATED"));
                                    FrmlJ.Add(new ASTNode("ASTLEFTSIDE", eh.Jname));
                                    ASTNode ex = new ASTNode("ASTEXPRESSION", true);
                                    ex.Add(root4);
                                    FrmlJ.Add(ex);
                                    ASTNode child41 = new ASTNode("ASTVARIABLE", eh.lhs);
                                    ASTNode child42 = root1;
                                    root4.Add(child41);
                                    root4.Add(child42);
                                    EquationHelper ehJ = new EquationHelper();
                                    ehJ.lhs = eh.Jname;
                                    ehJ.lhsWithLagIndicator = eh.Jname + Globals.lagIndicator + "0";
                                    ehJ.equationType = EEquationType.RevertedAutoGenerated;
                                    ehJ.equationsNodeRoot = FrmlJ;
                                    ehJ.equationNumber = model.equationsReverted.Count;
                                    model.equationsReverted.Add(ehJ);
                                }
                            }
                            else if (eh.equationCodeJmultiplicative)
                            {
                                if (Globals.revertSimpleJ)
                                {
                                    if (Globals.revertSimpleJ)
                                    {
                                        //TODO: clean up, reorder, rename, do diagram
                                        ASTNode FrmlJR = new ASTNode("ASTFRML", true);  //super-root
                                        ASTNode root4 = new ASTNode("-", true);
                                        ASTNode root4child = new ASTNode("/", true);
                                        root4.Add(root4child);
                                        root4.Add(new ASTNode("ASTDOUBLE", "1"));
                                        FrmlJR.Add(new ASTNode("ASTFRMLCODE", "AUTOGENERATED"));
                                        FrmlJR.Add(new ASTNode("ASTLEFTSIDE", eh.Jname));
                                        ASTNode ex = new ASTNode("ASTEXPRESSION", true);
                                        ex.Add(root4);
                                        FrmlJR.Add(ex);
                                        ASTNode child41 = new ASTNode("ASTVARIABLE", eh.lhs);
                                        ASTNode child42 = root1;
                                        root4child.Add(child41);
                                        root4child.Add(child42);
                                        EquationHelper ehJR = new EquationHelper();
                                        ehJR.lhs = eh.Jname;
                                        ehJR.lhsWithLagIndicator = eh.Jname + Globals.lagIndicator + "0";
                                        ehJR.equationType = EEquationType.RevertedAutoGenerated;
                                        ehJR.equationsNodeRoot = FrmlJR;
                                        ehJR.equationNumber = model.equationsReverted.Count;
                                        model.equationsReverted.Add(ehJR);
                                    }
                                }
                            }


                        }
                        else if (eh.equationCodeD != "" && eh.equationCodeD != "_")
                        {
                            codeError += "Expected 'D' in position 5 in equation code\n";
                        }
                    }

                    if (G.Equal(eh.equationCodeZ, "z"))
                    {
                        //damping should not be done in generated code, not necessary (and dangerous)
                    }
                    else if (eh.equationCodeZ != "" && eh.equationCodeZ != "_") codeError += "Expected 'Z' in position 7 in equation code\n";
                    //put this into tree instead of rhs (root may actually be = rhs if no J- or D-stuff)

                    equationNode.Children[0] = root3;

                    if (codeError != "")
                    {
                        G.Writeln2("*** ERROR regarding equation code in '" + eh.lhs + "' equation");
                        G.Writeln(eh.equationText);
                        G.Writeln2("*** ERROR: equation code");
                        throw new GekkoException();
                    }
                    break;

            }

            //------------- for testing ------------------
            bool sameParenthesesInMachineCodeAsInHumanReadableCode = false; //should be false for safety, used to test if the human code parantheses are ok (not too many removed)
            //--------------------------------------------

            if (visitChildren == true && equationNode.Children != null)
            {
                int num = equationNode.Children.Count;
                for (int i = 0; i < num; ++i)
                {
                    ASTNode equationNodeChild = equationNode.Children[i];
                    bool last2 = false;
                    if (i == equationNode.Children.Count - 1) last2 = true;
                    bool first2 = false;
                    if (i == 0) first2 = true;

                    {
                        //------------------ before each child ----------------
                        switch (equationNode.Text)
                        {
                            case "*":
                            case "+":
                            case "-":
                            case "/":
                            case "%":
                                if (!sameParenthesesInMachineCodeAsInHumanReadableCode) wh2.rightHandSideCsCode.Append("(", EEmitType.computerReadable);
                                break;
                        }

                        bool setHumanParenthesis = false;
                        switch (equationNode.Text)
                        {

                            case "*":
                            case "/":
                            case "-":
                            case "+":
                            case "%":
                                setHumanParenthesis = true;
                                break;
                        }


                        //------------------ before each child ----------------
                        switch (equationNode.Text)
                        {
                            case "*":
                                if (equationNodeChild.Text == "*" || equationNodeChild.Text == "/") setHumanParenthesis = false;
                                break;
                            case "/":
                                break;
                            case "-":
                                if ((equationNodeChild.Text == "*" || equationNodeChild.Text == "/")) setHumanParenthesis = false;
                                break;
                            case "+":
                                if ((equationNodeChild.Text == "+" || equationNodeChild.Text == "-") || (equationNodeChild.Text == "*" || equationNodeChild.Text == "/")) setHumanParenthesis = false;
                                break;
                            case "%":
                                break;
                        }

                        bool isTimeDifferenceFunction = true;
                        if (equationNodeChild.Text == "ASTFUNCTION" && (G.Equal(equationNodeChild.GetChild(0).Text, "exp") || G.Equal(equationNodeChild.GetChild(0).Text, "log") || G.Equal(equationNodeChild.GetChild(0).Text, "pow")))
                        {
                            isTimeDifferenceFunction = false;
                        }

                        if (equationNodeChild.Text == "ASTVARIABLE" || equationNodeChild.Text == "ASTVARIABLELAGLEAD" || equationNodeChild.Text == "ASTDOUBLE" || equationNodeChild.Text == "ASTINTEGER" || (!isTimeDifferenceFunction && equationNodeChild.Text == "ASTFUNCTION"))
                        {
                            setHumanParenthesis = false;  //overrides everything above
                        }
                        if (sameParenthesesInMachineCodeAsInHumanReadableCode)
                        {
                            if (setHumanParenthesis) wh2.rightHandSideCsCode.Append("(", EEmitType.bothHumanAndComputerReadable);  //0 means all
                        }
                        else
                        {
                            if (setHumanParenthesis) wh2.rightHandSideCsCode.Append("(", EEmitType.humanReadable);  //2 means only human
                        }



                        //------------------ before each child end ----------------

                        EmitCsCodeForModel(eh, equationNodeChild, depth + 1, wh2, model, subTreeLag, isModel);

                        //------------------ after each child ----------------

                        if (sameParenthesesInMachineCodeAsInHumanReadableCode)
                        {
                            if (setHumanParenthesis) wh2.rightHandSideCsCode.Append(")", EEmitType.bothHumanAndComputerReadable);
                        }
                        else
                        {
                            if (setHumanParenthesis) wh2.rightHandSideCsCode.Append(")", EEmitType.humanReadable);
                        }

                        switch (equationNode.Text)
                        {
                            case "*":
                            case "+":
                            case "-":
                            case "/":
                            case "%":
                                if (!sameParenthesesInMachineCodeAsInHumanReadableCode) wh2.rightHandSideCsCode.Append(")", EEmitType.computerReadable);  //nonhuman
                                if (!last2) wh2.rightHandSideCsCode.Append(" " + equationNode.Text + " ", EEmitType.bothHumanAndComputerReadable);  //all
                                break;
                            case "ASTFUNCTION":
                                if (!last2 && !first2) wh2.rightHandSideCsCode.Append(", ");  //functions with more that 1 argument
                                break;
                        }
                        //------------------ after each child ----------------
                    }
                }
            }

            for (int i = 0; i < numberOfRightParentheses; i++)
            {
                wh2.rightHandSideCsCode.Append(")");
            }
        }

        private static int GetLags(WalkerHelper2 wh2, string function, ASTNode lags)
        {
            int intLags = -12345;
            if (lags.Text == "ASTINTEGER")
            {
                intLags = int.Parse(lags.GetChild(0).Text);
            }
            else if (lags.Text == "ASTASSIGNVAR")
            {
                string value2 = HandleModelVal(lags, wh2);
                bool xx = int.TryParse(value2, out intLags);
                if (!xx)
                {
                    G.Writeln2("*** ERROR: The VAL " + value2 + " is not suitable as second argument of " + function + "()");
                    throw new GekkoException();
                }
            }
            else
            {
                G.Writeln2("*** ERROR: Expected the second argument of " + function + "() function to be a fixed value");
                throw new GekkoException();
            }

            if (intLags <= 0 || intLags >= 100)
            {
                G.Writeln2("*** ERROR: Expected lags in " + function + "() function to > 0 and < 100");
                throw new GekkoException();
            }

            return intLags;
        }

        private static string HandleModelVal(ASTNode equationNode, WalkerHelper2 wh2)
        {
            //string key = equationNode.GetChild(0).Text.Substring(1);
            string key = equationNode.GetChild(0).Text;
            string value = null;
            if (wh2.vals == null || !wh2.vals.TryGetValue(key, out value))
            {
                G.Writeln2("*** ERROR: Could not find VAL '" + key + "' definition in .frm file");
                throw new GekkoException();
            }
            if (value.EndsWith(".")) value = value + "0";  //otherwise "1." becomes "1.d" which is not allowed
            return value;
        }


        private static void HandlePowFunction(EquationHelper eh, ASTNode equationNode, int depth, WalkerHelper2 wh2, Model model, int subTreeLag, bool isModel, bool function)
        {
            wh2.rightHandSideCsCode.Append("O.Pow(", EEmitType.computerReadable);
            wh2.rightHandSideCsCode.Append("Pow(", EEmitType.humanReadable);
            int start = 0;
            int end = 1;
            if (function)
            {
                start = 1;
                end = 2;
            }
            for (int i = start; i <= end; i++)
            {
                wh2.rightHandSideCsCode.Append("(");
                EmitCsCodeForModel(eh, equationNode.Children[i], depth + 1, wh2, model, subTreeLag, isModel);
                wh2.rightHandSideCsCode.Append(")");
                if (i == start) wh2.rightHandSideCsCode.Append(", ");
            }
            wh2.rightHandSideCsCode.Append(")");
        }        

        private static void AddToDictionary(Dictionary<string, string> ht, string name, Model model)
        {
            if (ht.ContainsKey(name))
            {
                model.fatalEndogenousError = true;
            }
            else
            {
                ht.Add(name, "");
            }
        }

        private static void EmitCsDoVariableStuff(EquationHelper eh, WalkerHelper2 wh2, Model model, bool isModel, string variable3, int lag, bool isBaseBank, string absoluteTime, string namedBank)
        {
            printVariableAsBType(eh, wh2, model, variable3, lag, false, false, isModel, isBaseBank, absoluteTime, namedBank); //false=rightside
            //doing model frml
            string atSign = "";
            if (isBaseBank) atSign = "@";  //this way, fY lagged from basebank becomes "@fy¤-1". Used only when doing PRT or GENR statements, not for models.

            string varWithLag = "";
            if (absoluteTime == null)
            {
                if (namedBank == null)
                {
                    //@fY¤-2
                    varWithLag = atSign + variable3 + Globals.lagIndicator + lag;
                }
                else
                {
                    //adambk:fY¤-2
                    varWithLag = namedBank + ":" + variable3 + Globals.lagIndicator + lag;
                }
            }
            else
            {
                if (namedBank == null)
                {
                    //@fY¤¤2001q3  (two ¤¤ indicate absolute time)
                    varWithLag = atSign + variable3 + Globals.lagIndicator + Globals.lagIndicator + absoluteTime;
                }
                else
                {
                    varWithLag = namedBank + ":" + variable3 + Globals.lagIndicator + Globals.lagIndicator + absoluteTime;
                }
            }

            string varWithLag2 = varWithLag;

            if (!eh.precedentsWithLagIndicator.ContainsKey(varWithLag2))
            {
                eh.precedentsWithLagIndicator.Add(varWithLag2, "");
            }

        }

        private static void ExtractDJZAndEquationTypeFromEquationCode(EquationHelper eh, Model model, bool isModel)
        {
            string code = eh.equationCode;

            if (code == "ASTIDENTITYCODE")
            {
                code = "_i";
            }

            if (code == "AUTOGENERATED")
            {
                eh.equationType = EEquationType.RevertedAutoGenerated;
                return;
            }

            if (code.Length == 0)
            {
                eh.equationType = EEquationType.I;
                PrintEquationCodeWarning(eh);
                return;
            }
            string var = eh.lhsWithLagIndicator;

            if (G.Equal(code.Substring(0, 1), "y"))
            {
                eh.equationType = EEquationType.RevertedY;  //for instance "Y"-type eqs, with J- or Z-vars on left side
                return;
            }
            else if (G.Equal(code.Substring(0, 1), "i"))
            {
                //Probably, this could just be EEquationType.I instead. After model equations are marked in another way and
                //not identified per this code.
                //TODO: Eliminate AfterModelI and AfterModelD
                eh.equationType = EEquationType.AfterModelI;  //for instance "I"-type eqs in after model
                return;
            }
            else if (G.Equal(code.Substring(0, 1), "d"))
            {
                //Probably, this could just be EEquationType.D instead. After model equations are marked in another way and
                //not identified per this code.
                //TODO: Eliminate AfterModelI and AfterModelD
                eh.equationType = EEquationType.AfterModelD;  //for instance "D"-type eqs in after model
                return;
            }
            else if (code.Substring(0, 1) == "_")
            {
                //ok
            }
            else
            {
                eh.equationType = EEquationType.I;
                PrintEquationCodeWarning(eh);
                return;
            }

            eh.equationCodeJ = "";
            eh.equationCodeD = "";
            if (code.Length == 1)
            {
                //it must be "_"
                eh.equationType = EEquationType.I;
                PrintEquationCodeWarning(eh);
                return;
            }

            string type = code.Substring(1, 1);
            if (G.Equal(type, "d")) eh.equationType = EEquationType.D;
            else if (G.Equal(type, "i")) eh.equationType = EEquationType.I;
            else if (G.Equal(type, "g")) eh.equationType = EEquationType.G;
            else if (G.Equal(type, "k")) eh.equationType = EEquationType.K;
            else if (G.Equal(type, "s")) eh.equationType = EEquationType.S;
            else
            {
                eh.equationType = EEquationType.I;
                PrintEquationCodeWarning(eh);
            }

            if (code.Length == 3)
            {
                //1 char
                eh.equationCodeJ = code.Substring(2, 1) + "_";  //no examples of only "_GJ" for instance, but just in case. Should be "_GJ_".
                //TODO: maybe invoke a warning here
            }
            if (code.Length >= 4)
            {
                //2 chars
                eh.equationCodeJ = code.Substring(2, 2);
            }
            if (code.Length >= 5)
            {
                //1 char, if dummy
                eh.equationCodeD = code.Substring(4, 1);
            }
            if (isModel && code.Length >= 7)  //damping not relevant if not isModel (i.e. a GENR statement)
            {
                //1 char, if dummy
                eh.equationCodeZ = code.Substring(6, 1);
                if (G.Equal(eh.equationCodeZ, "Z"))
                {
                    //variable is to be damped in Gauss-Seidel
                    if (model.dampVariables.ContainsKey(var))
                    {
                        G.Writeln2("*** ERROR: it seems the same damp variable appears multiple times");
                    }
                    else
                    {
                        model.dampVariables.Add(var, "");
                    }
                }
            }
            return;
        }

        private static void PrintEquationCodeWarning(EquationHelper eh)
        {
            if (false)
            {
                //Probably no need to report these
                G.Writeln("+++ WARNING: equation type set to _I for this equation:" + G.NL + eh.equationText);
            }
            return;
        }

        private static void printVariableAsBType(EquationHelper eh, WalkerHelper2 wh2, Model model, string variable, int lag, bool leftSide, bool humanReadable, bool isModel, bool isBaseBank, string absoluteTime, string namedBank)
        {
            if (isModel)  //for equations in model/frm
            {
                //ATypeData dataA = model.varsAType[variable];
                ATypeData dataA = null; model.varsAType.TryGetValue(variable, out dataA);

                //lag is -1 for fY(-1). It is positive for leads.

                if (dataA == null)
                {
                    dataA = new ATypeData();
                    dataA.aNumber = model.varsAType.Count;
                    dataA.varName = variable;  //only reason to add this is when we want to get the right lower/uppercase of the variable
                    model.varsAType.Add(variable, dataA);
                }

                if (lag < 0)
                {
                    if (-lag > model.largestLag) model.largestLag = -lag;  //model.largestLag is always 0 or positive
                }
                else if (lag > 0)
                {
                    if (lag > model.largestLead) model.largestLead = lag;  //model.largestLead is always 0 or positive
                    if (!model.leadedVariables.ContainsKey(dataA.aNumber)) model.leadedVariables.Add(dataA.aNumber, 1);  //1 is just artificial
                }

                string input = variable + Globals.lagIndicator + lag;
                //BTypeData data = (BTypeData)model.varsBType[input];
                BTypeData data = null; model.varsBType.TryGetValue(input, out data);
                if (data == null)
                {
                    data = new BTypeData();
                    data.variable = variable;
                    data.bNumber = model.varsBType.Count;
                    data.lag = lag;
                    //data.equations = new ArrayList();
                    data.leftHandSideEquation = -12345;  //-12345 means none
                    data.aNumber = dataA.aNumber;
                    model.varsBType.Add(input, data);
                    model.varsBTypeInverted.Add(data.bNumber, input);
                }

                //TODO: maybe move test of leftside/rightside out of method to calling method
                if (leftSide == true)
                {
                    string var2 = "";
                    if (lag == 0)
                    {
                        var2 = variable;
                    }
                    else
                    {
                        var2 = variable + "[" + lag + "]";
                    }

                    wh2.leftHandSideHumanReadable.Append(var2);
                    wh2.leftHandSideBNumber = data.bNumber;
                    wh2.leftHandSideCsCodeGauss.Append("b[" + data.bNumber + "]");
                    wh2.leftHandSideCsCodeJacobi.Append("c[" + data.bNumber + "]");

                }
                else
                {
                    //right side
                    //Here we do both the short, long and human version individually

                    if (lag >= 1)
                    {
                        wh2.rightHandSideCsCode.shortVersion.Append("Gekko.Program.Lead(b, " + data.bNumber + ")");                        
                    }
                    else
                    {
                        //normal way for non-lead variables
                        wh2.rightHandSideCsCode.shortVersion.Append("b[" + data.bNumber + "]");
                    }
                    if (lag == 0 && !Globals.showZero)
                    {
                        //This is probably so that equations can be GENR'ed
                        wh2.rightHandSideCsCode.longVersion.Append("databank.GetVariable(" + Globals.QT + variable + Globals.QT + ").GetDataNonLight(t)");
                        wh2.rightHandSideCsCode.humanVersion.Append(variable);
                    }
                    else
                    {
                        //This is probably so that equations can be GENR'ed
                        wh2.rightHandSideCsCode.longVersion.Append("databank.GetVariable(" + Globals.QT + variable + Globals.QT + ").GetData(t.Add(" + lag + "))");
                        wh2.rightHandSideCsCode.humanVersion.Append(variable + "[" + lag + "]");
                    }
                }
            }
            else  //for genr and prt statements
            {
                string bank = "databank";
                if (isBaseBank) bank = "baseDatabank";

                if (namedBank != null)
                {
                    //all this stuff is pretty messy, especially for PPLOT and WPLOT (PRT a bit better).
                    //we should merge PRT, PPLOT and WPLOT functionality at some point.
                    //the use of NamedDatabankHelper() is only present when using colons, so it should not
                    //be able to break anything regarding Gekko 1.6 and PRT/PPLOT/WPLOT. Or if it breaks,
                    //it only affects colons.
                    //isBaseBank can not be true here (not legal syntax to mix ':' and @)
                    bank = "Program.NamedDatabankHelper(`" + namedBank + "`, databank)";  //databank is either Work or Base (looping over these)
                }

                string variableSubst = variable;

                if (leftSide)
                {
                    wh2.leftHandSideCsCodeGauss.Append(bank + ".GetVariable(Program.SubstituteAssignVars(" + Globals.QT + variableSubst + Globals.QT + ")).SetData(Program.options.freq, t, data)");
                }
                else
                {
                    if (absoluteTime == null)
                    {
                        if (lag == 0)
                        {
                            //wh2.rightHandSideCsCode.Append(bank + ".GetVariable(Program.SubstituteAssignVars(" + Globals.QT + variableSubst + Globals.QT + ")).GetData(Program.options.freq ,t)");
                            wh2.rightHandSideCsCode.Append("Program.GetData(`" + variableSubst + "`, " + bank + ", t)");
                        }
                        else
                        {
                            //wh2.rightHandSideCsCode.Append(bank + ".GetVariable(Program.SubstituteAssignVars(" + Globals.QT + variableSubst + Globals.QT + ")).GetData(t.CloneAndAdd(" + lag + "))");
                            wh2.rightHandSideCsCode.Append("Program.GetData(`" + variableSubst + "`, " + bank + ", t.Add(" + lag + "))");
                        }
                    }
                    else
                    {
                        GekkoTime t = G.FromStringToDate(absoluteTime);
                        //wh2.rightHandSideCsCode.Append(bank + ".GetVariable(Program.SubstituteAssignVars(" + Globals.QT + variableSubst + Globals.QT + ")).GetData(new GekkoTime(" + t.year + ", " + t.sub + "))");
                        wh2.rightHandSideCsCode.Append("Program.GetData(`" + variableSubst + "`, " + bank + ", new GekkoTime(" + t.super + ", " + t.sub + "))");
                    }
                }

                //dublets are not allowed. TODO: fY and fy can coexist -- find a List<string> doing upper/lowercase
                if (!wh2.allReferencedTimeSeriesOrListsWork.Contains(variable)) wh2.allReferencedTimeSeriesOrListsWork.Add(variable);
                //TODO: prettify all these calls...
                //if (Program.ExtractPrintOptions(helper.prtOption).isMultiplier | useBaseBank == "TRUE")
                if (isBaseBank)
                {
                    if (!wh2.allReferencedTimeSeriesOrListsBase.Contains(variable)) wh2.allReferencedTimeSeriesOrListsBase.Add(variable);
                }
            }
        }

        //
        // TODO TODO when adding extension to a file, cast endswith() to lower before checking
        //

        public static void AST(CT node, int depth)
        {
            G.Writeln(G.Blanks(depth * 2) + node.Text);
            //G.Writeln(G.Blanks(depth * 2) + node.Text + "    line:" + node.Line);
            if (node.Children != null)
            {
                for (int i = 0; i < node.Children.Count; ++i)
                {
                    CT child = (CT)(node.Children[i]);
                    AST(child, depth + 1);
                }
            }
        }

        public static void AST2(ASTNode node, int depth)
        {
            G.Writeln(G.Blanks(depth * 2) + node.Text);
            if (node.Children != null)
            {
                for (int i = 0; i < node.Children.Count; ++i)
                {
                    ASTNode child = (ASTNode)(node.Children[i]);
                    AST2(child, depth + 1);
                }
            }
        }        

        private static void CheckCurrow(string cr)
        {
            if (!G.Equal(cr, "currow"))
            {
                G.Writeln2("*** ERROR: Expected .CurRow");
            }
        }        
    }

    public class ConvertHelper
    {
        public string code;        
        public List<string> errors;
        public string commandsText;
        public string codeUFunctions;        
    }

    public class WalkHelper
    {
        public List<string> frmlItems;
        public int frmlItemsCounter = -1;  //incremented for each ASTFRML, so becomes 0 when first ASTFRML is hit.
        public bool print = false;
        public bool printFile = false;
        //public int eqs = 0;
        public List<string> functions = new List<string>();
        //pointers into the tree of equations
        //public List<EquationsHelper> equations = new List<EquationsHelper>();
        //public EquationNode currentRootEquationNode = null;
        public StreamWriter writer = null;
        public PositionInFile positionInFileStart = new PositionInFile();
        public PositionInFile positionInFileEnd = new PositionInFile();
        public string inputFile = "";
        public StringReader inputFileStringReader = null;
        public List<string> inputFileLines = new List<string>();
        public bool afterEncountered = false;
        public bool after2Encountered = false;
        public string modelBlock = "Unnamed";
    }
    

    public enum GekkoStringBuilderTypes
    {
        Normal,
        StartNormal,
        EndNormal,
        StartIf,
        EndIf,
        StartFor,
        EndFor
    }

    public class GekkoStringBuilderHelper
    {
        public StringBuilder s = new StringBuilder();
        public GekkoStringBuilderTypes type = GekkoStringBuilderTypes.Normal;
    }

    public class GekkoStringBuilder
    {
        public List<GekkoStringBuilderHelper> data = new List<GekkoStringBuilderHelper>();

        public GekkoStringBuilder()
        {
            data.Add(new GekkoStringBuilderHelper());
        }

        public void NewBlock(GekkoStringBuilderTypes type)
        {
            GekkoStringBuilderHelper temp = new GekkoStringBuilderHelper();
            temp.type = type;
            data.Add(temp);
        }

        public void AppendLine(string s)
        {
            data[data.Count - 1].s.AppendLine(s);
        }
        public void AppendLine()
        {
            data[data.Count - 1].s.AppendLine();
        }

        public void Append(string s)
        {
            data[data.Count - 1].s.Append(s);
        }

        public void Append(StringBuilder s)
        {
            data[data.Count - 1].s.Append(s);
        }

        public void Replace(string s1, string s2)
        {
            foreach (GekkoStringBuilderHelper g in data)
            {
                g.s.Replace(s1, s2);
            }
        }

        public string ToString()
        {
            StringBuilder temp = new StringBuilder();
            foreach (GekkoStringBuilderHelper sb in data)
            {
                temp.Append(sb.s);
            }
            return temp.ToString();
        }

    }

    public class ASTNode
    {
        public IEnumerable ChildrenIterator()
        {
            //One good thing about this iterator is that you can use
            //  foreach (ASTNode child in node.ChildrenIterator())
            //even if node.Children = null. In that case, nothing
            //is iterated, just as if node.Children.Count was 0.
            //This is practical.
            //Another benefit is that we may set .Children private at some
            //point, so that its implementation may change (we use a List<> now).
            if (this.Children != null)
            {
                foreach(ASTNode child in this.Children)
                {
                    yield return child;
                }
            }
        }

        public List<ASTNode> Children = null;  //make this private at some point
        public ASTNode parent = null;
        public string Text = null;
        public int Line = 0;
        public ASTNode(string text)
        {
            this.Text = text;
        }
        public ASTNode(string text, bool withChildren)
        {
            this.Text = text;
            if (withChildren)
            {
                this.Children = new List<ASTNode>();
            }
        }

        public ASTNode(string text, string textChild)
        {
            //adds a node with text and a singla child with textChild
            this.Text = text;
            this.Children = new List<ASTNode>();
            this.Children.Add(new ASTNode(textChild));
        }

        public ASTNode(string text, string textChild1, string textChild2)
        {
            //adds a node with text and a singla child with textChild
            this.Text = text;
            this.Children = new List<ASTNode>();
            this.Children.Add(new ASTNode(textChild1));
            this.Children.Add(new ASTNode(textChild2));
        }

        public ASTNode GetChild(int i)
        {
            if (this.Children == null) return null;
            if (i >= this.Children.Count) return null;  //does not exist
            return this.Children[i];
        }

        public string GetChildString(int i)
        {
            //will be obsolete
            //---> "@`stringcontent`"
            ASTNode node = this.GetChild(i);
            if (node == null) return "null";
            else return "@`" + node.Text + "`";
        }

        public string GetChildText(int i)
        {
            ASTNode node = this.GetChild(i);
            if (node == null) return null;
            else return node.Text;
        }

        public void Add(ASTNode child)
        {
            this.Children.Add(child);
            child.parent = this;
        }

        public string ToString()
        {
            return this.Text;
        }
    }

    public class PositionInFile
    {
        public int line; //0-based!
        public int charPosition;  //0-based
        public PositionInFile()
        {
            line = -12345;
            charPosition = -12345;
        }
        public void LookForLargerPosition(CT ast)
        {
            if (ast.Line - 1 > this.line) //subtract 1 to make it 0-based
            {
                this.line = ast.Line - 1; //subtract 1 to make it 0-based
                this.charPosition = ast.CharPositionInLine;
            }
            else if (ast.Line - 1 == this.line)  //subtract 1 to make it 0-based
            {
                if (ast.CharPositionInLine > this.charPosition) this.charPosition = ast.CharPositionInLine;
            }
        }
    }

    public class StringBuilder2
    {
        public StringBuilder shortVersion = new StringBuilder();
        public StringBuilder longVersion = new StringBuilder();
        public StringBuilder humanVersion = new StringBuilder();

        public void Append(string s)
        {
            Append(s, 0);
        }

        public void Append(string s, EEmitType which)
        {  //0: all, 1: nonhuman, 2: human
            if (which == EEmitType.bothHumanAndComputerReadable || which == EEmitType.computerReadable)
            {
                shortVersion.Append(s);
                longVersion.Append(s);
            }
            if (which == EEmitType.bothHumanAndComputerReadable || which == EEmitType.humanReadable)
            {
                humanVersion.Append(s);
            }
        }

        public void AppendLine(string s)
        {
            AppendLine(s, 0);
        }

        public void AppendLine(string s, EEmitType which)
        {
            if (which == EEmitType.bothHumanAndComputerReadable || which == EEmitType.computerReadable)
            {
                shortVersion.AppendLine(s);
                longVersion.AppendLine(s);
            }
            if (which == EEmitType.bothHumanAndComputerReadable || which == EEmitType.humanReadable)
            {
                humanVersion.AppendLine(s);
            }
        }
    }

    //public class IntelliHelper
    //{
    //    public bool abort = false;
    //}

    public class ParseHelper
    {
        public bool isOneLinerFromGui = false;
        public string commandsText = null;
        public string fileName = null;
        public bool isModel = false;
    }

    public class WalkerHelper2
    {
        public StringBuilder2 rightHandSideCsCode = new StringBuilder2();
        public StringBuilder leftHandSideCsCodeGauss = new StringBuilder();  // b[117]
        public StringBuilder leftHandSideCsCodeJacobi = new StringBuilder();  // c[117]
        public StringBuilder leftHandSideHumanReadable = new StringBuilder();  //fy
        public int leftHandSideBNumber = -12345;  //only used for model
        public List<string> allReferencedTimeSeriesOrListsWork = new List<string>();  //only used for expressions in cmd
        public List<string> allReferencedTimeSeriesOrListsBase = new List<string>();  //only used for expressions in cmd
        public List<string> problematicFrmlCodes = new List<string>();
        public string frmlCode = "";
        public string leftSideFunction = "";
        public string variableOrFunctionIndicator = "";
        public ASTNode rhs = null;
        public Dictionary<string, string> vals = null;
    }    
}
