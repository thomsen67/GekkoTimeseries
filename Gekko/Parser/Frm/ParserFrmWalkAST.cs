using System;
using System.Collections.Generic;
using System.Text;
using Antlr.Runtime;
using Antlr.Runtime.Tree;
using Antlr.Runtime.Debug;
using Microsoft.CSharp;
using System.CodeDom;
using System.CodeDom.Compiler;
using System.Reflection;
using CT = Antlr.Runtime.Tree.CommonTree;
using System.Windows.Forms;
using System.IO;
using System.Drawing;
using System.Collections;
using System.Security.Cryptography;
using System.Runtime.Serialization.Formatters.Binary;
using System.Runtime.Serialization;

namespace Gekko.Parser.Frm
{
    class ParserFrmWalkAST
    {
        public enum EEmitType
        {
            bothHumanAndComputerReadable,
            computerReadable,
            humanReadable
        }

        public static void ParserFrmWalkASTHelper(GekkoDictionary<string, string> vals)
        {
            WalkerHelper2 wh2 = new WalkerHelper2();
            wh2.vals = vals;
            foreach (EquationHelper eh in Program.model.modelGekko.equations)
            {
                //call of recursive method
                wh2.rightHandSideCsCode = new StringBuilder2();  //clearing it for each equation, contains long, short and human versions
                wh2.leftHandSideCsCodeGauss = new StringBuilder();  //clearing it for each equation
                wh2.leftHandSideCsCodeJacobi = new StringBuilder();  //clearing it for each equation
                wh2.leftHandSideHumanReadable = new StringBuilder(); //clearing it for each equation
                wh2.scalar_leftHandSideA = new StringBuilder(); //clearing it for each equation
                ParserFrmWalkASTEquation(eh, eh.equationsNodeRoot, 0, wh2, Program.model.modelGekko, 0, true); //last arg is lag

                if (Globals.printAST) AST2(eh.equationsNodeRoot, 0);

                //TODO: could be nice to also have it human readable, by calling PrintVariable...() with humanReadable=true
                eh.csCodeRhs = wh2.rightHandSideCsCode.shortVersion.ToString();
                eh.csCodeRhsLongVersion = wh2.rightHandSideCsCode.longVersion.ToString();
                eh.codeRhsHumanVersion = wh2.rightHandSideCsCode.humanVersion.ToString();

                eh.csCodeLhsGauss = wh2.leftHandSideCsCodeGauss.ToString();
                eh.csCodeLhsJacobi = wh2.leftHandSideCsCodeJacobi.ToString();
                eh.codeLhsHumanVersion = wh2.leftHandSideHumanReadable.ToString();
                eh.bNumberLhs = wh2.leftHandSideBNumber;

                eh.scalar_csCodeLhs = wh2.scalar_leftHandSideA.ToString();
                eh.scalar_csCodeRhs = wh2.rightHandSideCsCode.scalarVersion.ToString();
            }

            //move reverted equations, and compact the others (and renumber them).
            List<EquationHelper> equationsNew = new List<EquationHelper>();
            foreach (EquationHelper eh in Program.model.modelGekko.equations)
            {
                if (EquationIsRunSeparatelyAfterSim(eh))  //will be true for RevertedAutoGenerated too, but these are not created here 
                {
                    eh.equationNumber = Program.model.modelGekko.equationsReverted.Count;
                    Program.model.modelGekko.equationsReverted.Add(eh);
                }
                else if (EquationIsNotRunAtAll(eh))  //will be true for RevertedP, only used n PREDICT
                {
                    eh.equationNumber = Program.model.modelGekko.equationsNotRunAtAll.Count;
                    Program.model.modelGekko.equationsNotRunAtAll.Add(eh);
                }
                else
                {
                    eh.equationNumber = equationsNew.Count;
                    equationsNew.Add(eh);
                }
            }
            Program.model.modelGekko.equations = equationsNew;

            WalkerHelper2 wh3 = new WalkerHelper2();
            wh3.vals = wh2.vals;  //otherwise the will not be available
            foreach (EquationHelper eh in Program.model.modelGekko.equationsReverted)
            {
                //call of recursive method
                wh3.rightHandSideCsCode = new StringBuilder2();  //clearing it for each equation
                wh3.leftHandSideCsCodeGauss = new StringBuilder();  //clearing it for each equation
                wh3.leftHandSideCsCodeJacobi = new StringBuilder();  //clearing it for each equation
                ParserFrmWalkASTEquation(eh, eh.equationsNodeRoot, 0, wh3, Program.model.modelGekko, 0, true);  //last arg is lag
                if (Globals.printAST) AST2(eh.equationsNodeRoot, 0);
                //TODO: could be nice to also have it human readable, by calling PrintVariable...() with humanReadable=true
                eh.csCodeRhs = wh3.rightHandSideCsCode.shortVersion.ToString();
                eh.csCodeRhsLongVersion = wh3.rightHandSideCsCode.longVersion.ToString();
                eh.csCodeLhsGauss = wh3.leftHandSideCsCodeGauss.ToString();
                eh.csCodeLhsJacobi = wh3.leftHandSideCsCodeJacobi.ToString();
                eh.bNumberLhs = wh3.leftHandSideBNumber;
            }
            //-------------------------------------------------------------------------

            //---------------------------------------------------------------------------------
            // now model.equations contains real endogenous, and model.equationsReverted contains Y-type and reverted (not real endogenous)

            int nonAfterVars = 0;
            int afterVars = 0;
            int after2Vars = 0;

            foreach (EquationHelper eh in Program.model.modelGekko.equations)
            {
                if (Program.model.modelGekko.endogenousOriginallyInModel.ContainsKey(eh.lhs))
                {
                    new Error("When finding endogenous: it seems variable '" + eh.lhs + "' appears multiple times on left-hand side");
                }
                else
                {
                    Program.model.modelGekko.endogenousOriginallyInModel.Add(eh.lhs, "");
                    Program.model.modelGekko.endogenousBNumbersOriginallyInModel.Add(eh.bNumberLhs, "");
                }
                if (EquationIsRunSeparatelyAfterSim(eh)) throw new GekkoException(); //sanity check
                if (EquationIsNotRunAtAll(eh)) throw new GekkoException(); //sanity check
                if (eh.isAfterModel && !eh.isAfter2Model) afterVars++;
                if (eh.isAfter2Model) after2Vars++;
                if (!eh.isAfterModel && !eh.isAfter2Model) nonAfterVars++;
            }

            int sumVars = nonAfterVars + afterVars + after2Vars;

            if (Program.model.modelGekko.fatalEndogenousError)
            {
                //this error should never happen -- should be caught above when checking endogenous
                //just to be 100% sure we are not going on with some inconsistency regarding endogenous vars
                new Error("There is a problem with multiple instances of the same endogenous variable");
            }

            foreach (EquationHelper eh in Program.model.modelGekko.equations)
            {
                Program.model.modelGekko.fromVariableToEquationNumber.Add(eh.lhsWithLagIndicator, eh.equationNumber);
            }

            foreach (EquationHelper eh in Program.model.modelGekko.equationsReverted)
            {
                if (Program.model.modelGekko.reverted.ContainsKey(eh.lhs))
                {
                    new Error("The variable '" + eh.lhs + "' seems to appear as a reverted equation several times. This may be because the variable is both auto-generated by means of formula codes, and added manually.");                    
                }
                else
                {
                    Program.model.modelGekko.reverted.Add(eh.lhs, "");
                }

                if (!(EquationIsRunSeparatelyAfterSim(eh))) throw new GekkoException(); //sanity check

            }

            //Find dependents for endogenous variables
            //FIXME not working
            //FIXME not working
            //FIXME not working
            //FIXME not working
            //FIXME not working   Edit: HMMM seems to work fine....
            //FIXME not working
            //FIXME not working
            //FIXME not working
            foreach (EquationHelper eh in Program.model.modelGekko.equations)
            {
                foreach (string p in eh.precedentsWithLagIndicator.Keys)
                {
                    string p2 = G.ExtractOnlyVariableIgnoreLag(p);
                    if (Program.model.modelGekko.dependents.ContainsKey(p2))
                    {
                    }
                    else
                    {
                        DependentsHelper d = new DependentsHelper();
                        Program.model.modelGekko.dependents.Add(p2, d);
                    }
                    Dictionary<string, string> yy = Program.model.modelGekko.dependents[p2].storage;
                    if (!yy.ContainsKey(eh.lhs))
                    {
                        yy.Add(eh.lhs, "");
                    }
                }
            }

            int xnumberTotal = Program.model.modelGekko.varsAType.Count;
            int xnumberOfEndo = Program.model.modelGekko.endogenousOriginallyInModel.Count;
            int xnumberOfDjz = Program.model.modelGekko.varsJTypeAutoGenerated.Count + Program.model.modelGekko.varsDTypeAutoGenerated.Count + Program.model.modelGekko.varsZTypeAutoGenerated.Count;
            int xnumberOfExoTrue = xnumberTotal - xnumberOfEndo - xnumberOfDjz;

            Program.model.modelGekko.modelInfo.total = xnumberTotal;
            Program.model.modelGekko.modelInfo.endo = xnumberOfEndo;
            Program.model.modelGekko.modelInfo.exoTrue = xnumberOfExoTrue;
            Program.model.modelGekko.modelInfo.exoDJZ = xnumberOfDjz;
            Program.model.modelGekko.modelInfo.endo2 = sumVars;
            Program.model.modelGekko.modelInfo.endoNoAfter = nonAfterVars;
            Program.model.modelGekko.modelInfo.endoAfter = afterVars;
            Program.model.modelGekko.modelInfo.endoAfter2 = after2Vars;
        }

        public static void ParserFrmWalkASTEquation(EquationHelper eh, ASTNodeSimple equationNode, int depth, WalkerHelper2 wh2, ModelGekko model, int subTreeLag, bool isModel)
        {
            bool visitChildren = true;
            int numberOfRightParentheses = 0;

            if (equationNode == null || equationNode.Text == null)
            {

            }

            switch (equationNode.Text)
            {
                case "ASTFRMLCODE":
                    if (equationNode.Children.Count > 0)
                    {
                        wh2.frmlCode = equationNode.GetChild(0).Text;
                    }
                    visitChildren = false;  //is done
                    break;
                case "ASTLEFTSIDE":
                    ASTNodeSimple child = equationNode.GetChild(0);
                    wh2.variableOrFunctionIndicator = child.Text;
                    wh2.leftSideFunction = "";
                    if (wh2.variableOrFunctionIndicator == "ASTSIMPLEFUNCTION")
                    {
                        wh2.leftSideFunction = child.GetChild(0).Text;
                        wh2.variableOrFunctionIndicator = child.GetChild(1).Text;
                    }
                    visitChildren = false;
                    break;
                //case "ASTEXPRESSION":
                //    wh2.rhs = equationNode.GetChild(0);
                //    break;
                case "ASTPOW":
                    {
                        HandlePowFunction(eh, equationNode, depth, wh2, model, subTreeLag, isModel, false);
                        visitChildren = false;
                    }
                    break;
                case "ASTFUNCTION":
                    {
                        //-----------------------------------------
                        //   these are right-hand-side functions
                        //-----------------------------------------
                        string function = equationNode.GetChild(0).Text;
                        int arguments = equationNode.Children.Count - 1;

                        //TODO: do log and exp with nodes

                        bool recognized = false;

                        if (G.Equal(function, "log"))
                        {
                            if (arguments != 1)
                            {
                                new Error("Expected log() function with 1 argument");
                            }
                            recognized = true;
                            wh2.rightHandSideCsCode.Append("O.Log(", EEmitType.computerReadable);
                            wh2.rightHandSideCsCode.Append("log(", EEmitType.humanReadable);
                            numberOfRightParentheses++;
                        }
                        else if (G.Equal(function, "exp"))
                        {
                            if (arguments != 1)
                            {
                                new Error("Expected exp() function with 1 argument");
                            }
                            recognized = true;
                            wh2.rightHandSideCsCode.Append("O.Exp(", EEmitType.computerReadable);
                            wh2.rightHandSideCsCode.Append("exp(", EEmitType.humanReadable);
                            numberOfRightParentheses++;
                        }
                        else if (G.Equal(function, "abs"))
                        {
                            if (arguments != 1)
                            {
                                new Error("Expected abs() function with 1 argument");
                            }
                            recognized = true;
                            wh2.rightHandSideCsCode.Append("O.Abs(", EEmitType.computerReadable);
                            wh2.rightHandSideCsCode.Append("abs(", EEmitType.humanReadable);
                            numberOfRightParentheses++;
                        }
                        else if (G.Equal(function, "min"))
                        {
                            if (arguments != 2)
                            {
                                new Error("ERROR: Expected min() function with 2 arguments");
                            }
                            recognized = true;
                            wh2.rightHandSideCsCode.Append("O.Min(", EEmitType.computerReadable);
                            wh2.rightHandSideCsCode.Append("min(", EEmitType.humanReadable);
                            numberOfRightParentheses++;
                        }
                        else if (G.Equal(function, "max"))
                        {
                            if (arguments != 2)
                            {
                                new Error("Expected max() function with 2 arguments");
                            }
                            recognized = true;
                            wh2.rightHandSideCsCode.Append("O.Max(", EEmitType.computerReadable);
                            wh2.rightHandSideCsCode.Append("max(", EEmitType.humanReadable);
                            numberOfRightParentheses++;
                        }
                        else if (G.Equal(function, "dlog") || G.Equal(function, "dlogy"))
                        {
                            int lag = 1;
                            if (G.Equal(function, "dlogy"))
                            {
                                lag = O.CurrentSubperiods();
                                //Program.model.modelCommon.subPeriods = lag; //this is used as a safety check, so that if the model is loaded/compiled during one freq, and run during another, we will get an error.
                            }

                            if (arguments != 1)
                            {
                                new Error("Expected dlog() function with 1 argument");
                            }
                            recognized = true;
                            //wh2.s.Append("(");
                            //numberOfRightParentheses++;
                            /*
                             *
                             *                         x
                             *                         |
                             *                     ASTFUNCTION
                             *                       /    \
                             *                    dlog    subtree
                             *
                             *                         x
                             *                         |
                             *                     "nothing" (equationNode)
                             *                         |
                             *                        "-" (b)
                             *                       /   \                             *
                             *                      /     ASTLAG (c)
                             *                     /      |    \ \
                             *                    /      /    "-" 1
                             *                ASTFUNCTION (d)
                             *                  /       \
                             *               log (e)   subtree
                             *
                             * */
                            ASTNodeSimple subTree = equationNode.GetChild(1);
                            equationNode.Text = "nothing";  //function that does nothing
                            equationNode.Children.Clear();
                            ASTNodeSimple b = new ASTNodeSimple("-");  //subtraction
                            equationNode.Add(b);
                            ASTNodeSimple d = new ASTNodeSimple("ASTFUNCTION");
                            ASTNodeSimple c = new ASTNodeSimple("ASTLAG");
                            b.Children = new List<ASTNodeSimple>();
                            b.Add(d);
                            b.Add(c);
                            ASTNodeSimple c1 = new ASTNodeSimple("-");  //it is a lag
                            ASTNodeSimple c2 = new ASTNodeSimple(lag.ToString()); //n period lag
                            c.Children = new List<ASTNodeSimple>();
                            c.Add(d);
                            c.Add(c1);
                            c.Add(c2);
                            ASTNodeSimple e = new ASTNodeSimple("log");
                            d.Children = new List<ASTNodeSimple>();
                            d.Add(e);
                            d.Add(subTree);
                        }
                        else if (G.Equal(function, "pch") || G.Equal(function, "pchy"))
                        {
                            int lag = 1;
                            if (G.Equal(function, "pchy"))
                            {
                                lag = O.CurrentSubperiods();
                                //Program.model.modelCommon.subPeriods = lag; //this is used as a safety check, so that if the model is loaded/compiled during one freq, and run during another, we will get an error.
                            }

                            if (arguments != 1)
                            {
                                new Error("Expected pch() function with 1 argument");
                            }
                            recognized = true;
                            //wh2.s.Append("(");
                            //numberOfRightParentheses++;
                            /*
                             *
                             *                         x
                             *                         |
                             *                     ASTFUNCTION
                             *                       /    \
                             *                    pch    subtree
                             *
                             *                         x
                             *                         |
                             *                        "nothing" (equationNode)
                             *                         |
                             *                        "*" (f) --------------------------------- 100
                             *                         |
                             *                         |
                             *                        "-" (g) --------------------------------- 1
                             *                         |
                             *                         |
                             *                        "/" (b)
                             *                       /   \
                             *                      /     ASTLAG (c)
                             *                     /      |    \ \
                             *                    /      /    "-" 1
                             *                  subtree (d)
                             *
                             *
                             *
                             * */
                            ASTNodeSimple f = new ASTNodeSimple("*", true);
                            ASTNodeSimple g = new ASTNodeSimple("-", true);
                            f.Add(g);
                            f.Add(new ASTNodeSimple("ASTDOUBLE", "100"));
                            ASTNodeSimple subTree = equationNode.GetChild(1);
                            equationNode.Text = "nothing";  //function that does nothing
                            equationNode.Children.Clear();
                            ASTNodeSimple b = new ASTNodeSimple("/", true);  //subtraction
                            g.Add(b);
                            g.Add(new ASTNodeSimple("ASTDOUBLE", "1"));
                            equationNode.Add(f);
                            ASTNodeSimple d = subTree;
                            ASTNodeSimple c = new ASTNodeSimple("ASTLAG", true);
                            b.Add(d);
                            b.Add(c);
                            ASTNodeSimple c1 = new ASTNodeSimple("-");  //it is a lag
                            ASTNodeSimple c2 = new ASTNodeSimple(lag.ToString()); //n period lag
                            c.Add(d);
                            c.Add(c1);
                            c.Add(c2);
                        }
                        else if (G.Equal(function, "lag"))
                        {
                            if (arguments != 2)
                            {
                                new Error("Expected lag() function with 2 arguments");
                            }
                            recognized = true;

                            ASTNodeSimple lags = equationNode.GetChild(2);
                            int intLags = GetLags(wh2, function, lags);

                            /*
                           *
                           *                         x
                           *                         |
                           *                     ASTFUNCTION
                           *                       /    \
                           *                    dif     subtree
                           *
                           *                         x
                           *                         |
                           *                     "nothing" (equationNode)
                           *                         |
                           *                          \
                           *                           \                             
                           *                            ASTLAG (c)
                           *                            |    \ \
                           *                           /    "-" 1
                           *                     subtree
                           *
                           *
                           *
                           * */

                            ASTNodeSimple subTree = equationNode.GetChild(1);
                            equationNode.Text = "nothing";  //function that does nothing
                            equationNode.Children.Clear();
                            ASTNodeSimple c = new ASTNodeSimple("ASTLAG");
                            ASTNodeSimple c1 = new ASTNodeSimple("-"); //it is a lag
                            ASTNodeSimple c2 = new ASTNodeSimple(intLags.ToString()); //n period lag
                            equationNode.Add(c);
                            c.Children = new List<ASTNodeSimple>();
                            c.Add(subTree);
                            c.Add(c1);
                            c.Add(c2);
                        }
                        else if (G.Equal(function, "dif") || G.Equal(function, "diff") || G.Equal(function, "dify") || G.Equal(function, "diffy"))
                        {
                            int lag = 1;
                            if (G.Equal(function, "dify") || G.Equal(function, "diffy"))
                            {
                                lag = O.CurrentSubperiods();
                                //Program.model.modelCommon.subPeriods = lag; //this is used as a safety check, so that if the model is loaded/compiled during one freq, and run during another, we will get an error.
                            }

                            if (arguments != 1)
                            {
                                new Error("Expected dif() function with 1 argument");
                            }
                            recognized = true;
                            /*
                            *
                            *                         x
                            *                         |
                            *                     ASTFUNCTION
                            *                       /    \
                            *                    dif     subtree
                            *
                            *                         x
                            *                         |
                            *                     "nothing" (equationNode)
                            *                         |
                            *                        "-" (b)
                            *                       /   \                             *
                            *                      /     ASTLAG (c)
                            *                     /      |    \ \
                            *                    /      /    "-" 1
                            *                    subtree
                            *
                            *
                            *
                            * */
                            //wh2.s.Append("(");
                            //numberOfRightParentheses++;
                            // see "dlog" for explanation
                            ASTNodeSimple subTree = equationNode.GetChild(1);
                            equationNode.Text = "nothing";  //function that does nothing
                            equationNode.Children.Clear();
                            ASTNodeSimple b = new ASTNodeSimple("-");//subtraction
                            equationNode.Add(b);
                            ASTNodeSimple c = new ASTNodeSimple("ASTLAG");
                            b.Children = new List<ASTNodeSimple>();
                            b.Add(subTree);
                            b.Add(c);
                            ASTNodeSimple c1 = new ASTNodeSimple("-"); //it is a lag
                            ASTNodeSimple c2 = new ASTNodeSimple(lag.ToString()); //n period lag
                            c.Children = new List<ASTNodeSimple>();
                            c.Add(subTree);
                            c.Add(c1);
                            c.Add(c2);
                        }
                        else if (G.Equal(function, "movavg") || G.Equal(function, "movsum"))
                        {

                            if (arguments != 2)
                            {
                                new Error("Expected " + function + "() function with 2 arguments");
                            }
                            recognized = true;

                            ASTNodeSimple lags = equationNode.GetChild(2);

                            int intLags = GetLags(wh2, function, lags);

                            /*
                            *
                            *                         x
                            *                         |
                            *                     ASTFUNCTION
                            *                       /    \
                            *                    dif     subtree
                            *
                            *                         x
                            *                         |
                            *                     "nothing" (equationNode)
                            *                         |
                            *                        "+" (b)
                            *                       /   \                             *
                            *                      /     +
                            *                     /     / \
                            *                    /     /   +
                            *                             / \ 
                            *                               ...
                            *                   subtree
                            *                   left brachnes have ASTLAG
                            *
                            *
                            * */
                            //wh2.s.Append("(");
                            //numberOfRightParentheses++;
                            // see "dlog" for explanation
                            ASTNodeSimple subTree = equationNode.GetChild(1);
                            equationNode.Text = "nothing";  //function that does nothing
                            equationNode.Children.Clear();

                            ASTNodeSimple container = new ASTNodeSimple("nothing");
                            container.Children = new List<ASTNodeSimple>();

                            ASTNodeSimple cRightOld = new ASTNodeSimple("+"); //addition
                            cRightOld.Children = new List<ASTNodeSimple>();

                            container.Add(cRightOld);

                            for (int i = 0; i < intLags - 1; i++)
                            {
                                ASTNodeSimple cLeft = new ASTNodeSimple("ASTLAG");
                                cLeft.Children = new List<ASTNodeSimple>();
                                cLeft.Add(subTree);
                                cLeft.Add(new ASTNodeSimple("-"));
                                cLeft.Add(new ASTNodeSimple(i.ToString()));

                                ASTNodeSimple cRightNew = null;

                                if (i < intLags - 2)
                                {
                                    cRightNew = new ASTNodeSimple("+"); //addition
                                    cRightNew.Children = new List<ASTNodeSimple>();
                                }
                                else
                                {
                                    cRightNew = new ASTNodeSimple("ASTLAG");
                                    cRightNew.Children = new List<ASTNodeSimple>();
                                    cRightNew.Add(subTree);
                                    cRightNew.Add(new ASTNodeSimple("-"));
                                    cRightNew.Add(new ASTNodeSimple((i + 1).ToString()));
                                }
                                cRightOld.Add(cLeft);
                                cRightOld.Add(cRightNew);

                                cRightOld = cRightNew;
                            }

                            if (G.Equal(function, "movsum"))
                            {
                                equationNode.Add(container);
                            }
                            else
                            {
                                ASTNodeSimple temp = new ASTNodeSimple("/");
                                temp.Children = new List<ASTNodeSimple>();
                                temp.Add(container);
                                temp.Add(new ASTNodeSimple("ASTDOUBLE", intLags.ToString()));
                                equationNode.Add(temp);
                            }
                        }
                        else if (G.Equal(function, "pow"))
                        {
                            if (arguments != 2)
                            {
                                new Error("Expected pow() function with 2 arguments");
                            }
                            recognized = true;
                            HandlePowFunction(eh, equationNode, depth, wh2, model, subTreeLag, isModel, true);
                            visitChildren = false;
                        }
                        else if (G.Equal(function, "CES_UC") || G.Equal(function, "CES_XL") || G.Equal(function, "CES_XR") || G.Equal(function, "CES_COSTS") || G.Equal(function, "CES_FACTOR1") || G.Equal(function, "CES_FACTOR2") || G.Equal(function, "CES_AC"))
                        {
                            //See #09875209837532
                            recognized = true;
                            wh2.rightHandSideCsCode.Append("Functions." + function + "(", EEmitType.computerReadable);
                            wh2.rightHandSideCsCode.Append(function, EEmitType.humanReadable);
                            numberOfRightParentheses++;
                        }

                        if (recognized == false)
                        {
                            //Se also #09835742345
                            G.Writeln2(G.ReplaceGlueSymbols(eh.equationText), Color.Red);
                            new Error("Function '" + function + "' with " + arguments + " arguments cannot be recognized.");                                
                        }
                    }
                    break;
                case "ASTLAG":
                    int lagHere = int.Parse(equationNode.GetChild(2).Text);
                    if (equationNode.GetChild(1).Text == "-")
                    {
                        lagHere = -lagHere;  //keeps sign if it is "+"
                    }
                    else if (equationNode.GetChild(1).Text == "+")
                    {
                        //do nothing
                    }
                    else throw new GekkoException();
                    subTreeLag = subTreeLag + lagHere;  //puts on top of any preexisting lag in this subtree (for instance if y = dif(dif(x))
                    break;
                case "ASTVARIABLE":  //no lag
                    {
                        string variable3 = equationNode.GetChild(0).Text;
                        int lag = 0 + subTreeLag;
                        bool isBaseBank = false;
                        string namedBank = null;
                        if (!isModel)
                        {
                            if (G.Equal(equationNode.GetChild(1).Text, "true"))
                            {
                                isBaseBank = true;
                            }
                            else if (G.Equal(equationNode.GetChild(1).Text, "ASTBANK"))
                            {
                                namedBank = equationNode.GetChild(1).GetChild(0).Text;
                            }
                        }
                        EmitCsDoVariableStuff(eh, wh2, model, isModel, variable3, lag, isBaseBank, null, namedBank);
                        visitChildren = false; //all children are done
                    }
                    break;
                case "ASTVARIABLELAGLEAD":
                    {
                        if (true)
                        {
                            //If it is a broken lag, it looks like this:
                            //
                            //            ASTEXPRESSION
                            //            /
                            //           /
                            //       ASTVARIABLELAGLEAD
                            //       /     /    \      \
                            //      /     /      \      \
                            //     fY    -       0.3    FALSE
                            //
                            // This is converted into:
                            //
                            //                            ASTEXPRESSION
                            //                                /
                            //                               /
                            //                              +
                            //                            /   \
                            //                           /     \
                            //                   --------       ------------
                            //                  /                            \
                            //                 /                              \
                            //                *                                *
                            //               / \                              / \
                            //              /   \                            /   \
                            //             /    ASTDOUBLE                   /    ASTDOUBLE
                            //            /        0.7                     /        0.3
                            //           /                                /
                            //       ASTVARIABLELAGLEAD               ASTVARIABLELAGLEAD
                            //       /     /    \      \              /     /    \      \
                            //      /     /      \      \            /     /      \      \
                            //     fY    -        0     FALSE       fY    -        1     FALSE

                            string namedBank = null;
                            bool isBaseBank2 = false;
                            if (!isModel)
                            {
                                if (G.Equal(equationNode.GetChild(3).Text, "true"))
                                {
                                    isBaseBank2 = true;
                                }
                                else if (G.Equal(equationNode.GetChild(3).Text, "ASTBANK"))
                                {
                                    namedBank = equationNode.GetChild(3).GetChild(0).Text;
                                }
                            }

                            string variable2 = equationNode.GetChild(0).Text;


                            double lagDouble = double.NaN;
                            if (!G.TryParseIntoDouble(equationNode.GetChild(2).Text, out lagDouble)) lagDouble = double.NaN;

                            if (equationNode.GetChild(1).Text == "+")
                            {
                                //do nothing
                            }
                            else if (equationNode.GetChild(1).Text == "-")
                            {
                                lagDouble = -lagDouble;
                            }
                            else if (equationNode.GetChild(1).Text == "ABSOLUTE")
                            {
                                //absolute period, e.g. fY(2001q3)
                                if (isModel)
                                {
                                    new Error("Absolute dates are not allowed in model. " + eh.equationText);
                                }
                                else
                                {
                                    //an absolute period
                                    string absoluteTime = equationNode.GetChild(2).Text;
                                    EmitCsDoVariableStuff(eh, wh2, model, isModel, variable2, -12345, isBaseBank2, absoluteTime, namedBank);
                                    visitChildren = false; //all children are done
                                    break;
                                }
                            }
                            else throw new GekkoException();
                            lagDouble += subTreeLag;
                            if (Math.Abs(lagDouble - Math.Round(lagDouble)) < Globals.toleranceRegardingBrokenLagsOrLeads)
                            {
                                //a non-broken lag/lead
                                int nonbrokenlag = Convert.ToInt32(lagDouble);
                                double dif = (double)nonbrokenlag - lagDouble;
                                if (Math.Abs(dif) > 0.01d)
                                {
                                    throw new GekkoException();
                                }
                                EmitCsDoVariableStuff(eh, wh2, model, isModel, variable2, nonbrokenlag, isBaseBank2, null, namedBank);
                                visitChildren = false; //all children are done
                            }
                            else
                            {
                                //a broken lag/lead
                                int lowInt = (int)Math.Floor(lagDouble);
                                int highInt = (int)Math.Ceiling(lagDouble);
                                double lambdaHigh = lagDouble - (double)lowInt;
                                double lambdaLow = (double)highInt - lagDouble;
                                ASTNodeSimple low = new ASTNodeSimple("*", true);
                                ASTNodeSimple high = new ASTNodeSimple("*", true);
                                ASTNodeSimple low1 = new ASTNodeSimple("ASTVARIABLELAGLEAD", true);
                                ASTNodeSimple low2 = new ASTNodeSimple("ASTDOUBLE", "" + lambdaLow);
                                low.Add(low1);
                                low.Add(low2);
                                ASTNodeSimple high1 = new ASTNodeSimple("ASTVARIABLELAGLEAD", true);
                                ASTNodeSimple high2 = new ASTNodeSimple("ASTDOUBLE", "" + lambdaHigh);
                                high.Add(high1);
                                high.Add(high2);
                                low1.Add(new ASTNodeSimple(equationNode.GetChild(0).Text));  //varname
                                if (lowInt < 0) low1.Add(new ASTNodeSimple("-"));
                                else low1.Add(new ASTNodeSimple("+"));
                                low1.Add(new ASTNodeSimple(Math.Abs(lowInt) + ""));
                                if (isModel == false) low1.Add(new ASTNodeSimple(equationNode.GetChild(3).Text));  //if base bank
                                high1.Add(new ASTNodeSimple(equationNode.GetChild(0).Text));  //varname
                                if (highInt < 0) high1.Add(new ASTNodeSimple("-"));
                                else high1.Add(new ASTNodeSimple("+"));
                                high1.Add(new ASTNodeSimple(Math.Abs(highInt) + ""));
                                if (isModel == false) high1.Add(new ASTNodeSimple(equationNode.GetChild(3).Text));  //if base bank
                                equationNode.Children.Clear();  //stripping children, in order to add the new subtree
                                equationNode.Text = "nothing";  //nothing is done in this node
                                ASTNodeSimple plus = new ASTNodeSimple("+", true);
                                plus.Add(low);
                                plus.Add(high);
                                equationNode.Add(plus);
                                visitChildren = true; //should continue in the new tree below!
                            }
                        }
                    }
                    break;
                case "NEGATE":
                    wh2.rightHandSideCsCode.Append("-(");
                    numberOfRightParentheses++;
                    break;
                case "ASTDOUBLE":
                    string number1 = equationNode.GetChild(0).Text;
                    if (number1.EndsWith(".")) number1 = number1 + "0";  //otherwise "1." becomes "1.d" which is not allowed
                    wh2.rightHandSideCsCode.Append(number1 + "d", EEmitType.computerReadable);  //d means double, 1 for non-human readable
                    wh2.rightHandSideCsCode.Append(number1, EEmitType.humanReadable);  //2 for human readable
                    break;
                case "ASTASSIGNVAR":
                    //In Gekko 2.0, the var is %x, not #x.
                    string value = HandleModelVal(equationNode, wh2);
                    wh2.rightHandSideCsCode.Append(value + "d", EEmitType.computerReadable);  //d means double, 1 for non-human readable
                    wh2.rightHandSideCsCode.Append(value, EEmitType.humanReadable);  //2 for human readable
                    break;
                case "ASTINTEGER":
                    string number2 = equationNode.GetChild(0).Text;
                    wh2.rightHandSideCsCode.Append(number2 + "d", EEmitType.computerReadable);  //d means double, 1 for non-human readable
                    wh2.rightHandSideCsCode.Append(number2, EEmitType.humanReadable);  //2 for human readable
                    break;
                case "ASTEXPRESSION":
                    //left side variable is also handled here
                    wh2.rightHandSideCsCode.AppendLine("");  //to force a newline
                    eh.precedentsWithLagIndicator = new GekkoDictionary<string, string>(StringComparer.OrdinalIgnoreCase);
                    eh.equationCode = wh2.frmlCode;
                    //left-hand side (e.g. "b[123] =") below
                    PrintVariableAsBType(eh, wh2, model, wh2.variableOrFunctionIndicator, 0, true, false, isModel, false, null, null);  //no lag //true=leftside //no named bank
                    //wh2.rightHandSideCsCode.Append(" = ");  //added manually later on
                    wh2.rhs = equationNode.GetChild(0);
                    ASTNodeSimple rhs = wh2.rhs;
                    eh.lhsWithLagIndicator = wh2.variableOrFunctionIndicator + Globals.lagIndicator + "0";  //lag is 0 on left hand side
                    eh.lhs = wh2.variableOrFunctionIndicator;

                    ASTNodeSimple root0 = rhs;
                    ASTNodeSimple root1 = root0;  //default value, if it is not changed
                    if (wh2.leftSideFunction == "")
                    {
                        //do nothing
                    }
                    else
                    {
                        //either:
                        // var = exp(...)                   (log)
                        // var = var(-1) * exp(...)         (dlog)
                        // var = var(-1) * (.../100 + 1)    (pch)
                        // var = var(-n) * (.../100 + 1)    (pchy, n=4 or 12)
                        // var = var(-1) + (...)            (dif)
                        /*
                         *                   ASTFUNCTION
                         *
                         *
                         *
                         * */
                        //These are left-hand side functions
                        if (G.Equal(wh2.leftSideFunction, "log"))
                        {
                            root1 = new ASTNodeSimple("ASTFUNCTION", "exp");
                            root1.Add(root0);
                        }
                        else if (G.Equal(wh2.leftSideFunction, "dlog") || G.Equal(wh2.leftSideFunction, "dlogy"))
                        {
                            int lag = 1;
                            if (G.Equal(wh2.leftSideFunction, "dlogy"))
                            {
                                lag = O.CurrentSubperiods();
                                //Program.model.modelCommon.subPeriods = lag; //this is used as a safety check, so that if the model is loaded/compiled during one freq, and run during another, we will get an error.
                            }
                            root1 = new ASTNodeSimple("*", true);
                            ASTNodeSimple child1 = new ASTNodeSimple("ASTVARIABLELAGLEAD", true);
                            ASTNodeSimple child2 = new ASTNodeSimple("ASTFUNCTION", true);
                            root1.Add(child1);
                            root1.Add(child2);
                            child1.Add(new ASTNodeSimple(eh.lhs));
                            child1.Add(new ASTNodeSimple("-"));  //lag
                            child1.Add(new ASTNodeSimple(lag.ToString()));  //lag n
                            //for GENR, cannot be a @-variable on left side, so:
                            child1.Add(new ASTNodeSimple("FALSE"));  //not baseline bank
                            child2.Add(new ASTNodeSimple("exp"));
                            child2.Add(root0);
                        }
                        else if (G.Equal(wh2.leftSideFunction, "pch") || G.Equal(wh2.leftSideFunction, "pchy"))
                        {
                            int lag = 1;
                            if (G.Equal(wh2.leftSideFunction, "pchy"))
                            {
                                lag = O.CurrentSubperiods();
                                //Program.model.modelCommon.subPeriods = lag; //this is used as a safety check, so that if the model is loaded/compiled during one freq, and run during another, we will get an error.
                            }
                            root1 = new ASTNodeSimple("*", true);
                            ASTNodeSimple child1 = new ASTNodeSimple("ASTVARIABLELAGLEAD", true);
                            ASTNodeSimple child2 = new ASTNodeSimple("+", true);
                            root1.Add(child1);
                            root1.Add(child2);
                            child1.Add(new ASTNodeSimple(eh.lhs));
                            child1.Add(new ASTNodeSimple("-"));  //lag
                            child1.Add(new ASTNodeSimple(lag.ToString()));  //lag n
                            //for GENR, cannot be a @-variable on left side, so:
                            child1.Add(new ASTNodeSimple("FALSE"));  //not baseline bank
                            ASTNodeSimple child21 = new ASTNodeSimple("/", true);
                            ASTNodeSimple child22 = new ASTNodeSimple("ASTDOUBLE", "1.0");
                            child21.Add(root0);
                            child21.Add(new ASTNodeSimple("ASTDOUBLE", "100"));
                            child2.Add(child21);
                            child2.Add(child22);
                        }
                        else if (G.Equal(wh2.leftSideFunction, "dif") || G.Equal(wh2.leftSideFunction, "diff") || G.Equal(wh2.leftSideFunction, "dify") || G.Equal(wh2.leftSideFunction, "diffy"))
                        {
                            int lag = 1;
                            if (G.Equal(wh2.leftSideFunction, "dify") || G.Equal(wh2.leftSideFunction, "diffy"))
                            {
                                lag = O.CurrentSubperiods();
                                //Program.model.modelCommon.subPeriods = lag; //this is used as a safety check, so that if the model is loaded/compiled during one freq, and run during another, we will get an error.
                            }
                            root1 = new ASTNodeSimple("+", true);
                            ASTNodeSimple child1 = new ASTNodeSimple("ASTVARIABLELAGLEAD", true);
                            ASTNodeSimple child2 = root0;
                            root1.Add(child1);
                            root1.Add(child2);
                            child1.Add(new ASTNodeSimple(eh.lhs));
                            child1.Add(new ASTNodeSimple("-"));  //lag
                            child1.Add(new ASTNodeSimple(lag.ToString()));  //lag n
                            //for GENR, cannot be a @-variable on left side, so:
                            child1.Add(new ASTNodeSimple("FALSE"));  //not baseline bank
                        }
                        else
                        {
                            new Error("Function '" + wh2.leftSideFunction + "' cannot be recognized. On left hand side, these functions are supported: log, dlog, pch, dif");                            
                        }
                    }
                    /** * -------------------------------------------------------------
                     * JRD
                     *                       +
                     *                    /     \
                     *               --- *       \
                     *             /      \       *
                     *       -----*        -     /  \
                     *      /      \      / \   D    Z
                     *  subtree     +    1   D
                     *            /   \
                     *           1    JR
                     *
                     * ------------------------------------------------------------
                     * * J_D
                     *                       +
                     *                    /     \
                     *               --- *       \
                     *             /      \       *
                     *       ---- +        -     /  \
                     *      /      \      / \   D    Z
                     *  subtree     J    1   D
                     *
                     * -------------------------------------------------------------
                     * JR
                     *
                     *       ---- *
                     *      /      \
                     *  subtree     +
                     *            /   \
                     *           1    JR
                     *
                     * * -------------------------------------------------------------
                     *  J_
                     *
                     *       ---- +
                     *      /      \
                     *  subtree     J
                     *
                     * * * -------------------------------------------------------------
                     * __D
                     *                       +
                     *                    /     \
                     *               --- *       \
                     *             /      \       *
                     *       subtree       -     /  \
                     *                    / \   D    Z
                     *                   1   D
                     *
                     *  ------------------------------------------------------------
                     *  NOTE: 1 is really a tree with ASTDOUBLE and child "1.0"
                     *
                     * */
                    ExtractDJZAndEquationTypeFromEquationCode(eh, model, isModel);  //Note: code may be changed to "_i" here
                    string codeError = "";
                    ASTNodeSimple root2 = root1;  //default value, without DJZ-vars
                    if (!(EquationIsRunSeparatelyAfterSim(eh) || EquationIsNotRunAtAll(eh)))
                    {
                        //adding J-variables
                        if (G.Equal(eh.equationCodeJ, "j_") || G.Equal(eh.equationCodeJ, "jd"))
                        {
                            eh.equationCodeJadditive = true;
                        }
                        else if (G.Equal(eh.equationCodeJ, "jr"))
                        {
                            eh.equationCodeJmultiplicative = true;
                        }
                        else if (eh.equationCodeJ != "" && eh.equationCodeJ != "__") codeError += "Expected 'J_' or 'JD' or 'JR' in position 3-4 in equation code\n";

                        string jled2 = eh.equationCodeJ.ToUpper();
                        if (G.Equal(jled2, "j_")) jled2 = "J";  //stripping the "_"
                        eh.Jname = jled2 + eh.lhs;
                        //at this point, jled2 may be = "", so eh.Jname is same as eh.lhs.
                        if (eh.equationCodeJmultiplicative)
                        {
                            //multiplicative
                            root2 = new ASTNodeSimple("*", true);
                            ASTNodeSimple child2 = new ASTNodeSimple("+", true);
                            root2.Add(root1);
                            root2.Add(child2);
                            child2.Add(new ASTNodeSimple("ASTDOUBLE", "1.0"));
                            child2.Add(new ASTNodeSimple("ASTVARIABLE", eh.Jname, "FALSE"));  //cannot be base bank
                            AddToDictionary(model.varsJTypeAutoGenerated, eh.Jname, model);
                        }
                        else if (eh.equationCodeJadditive)
                        {
                            //additive
                            root2 = new ASTNodeSimple("+", true);
                            root2.Add(root1);
                            root2.Add(new ASTNodeSimple("ASTVARIABLE", eh.Jname, "FALSE"));  //cannot be base bank
                            AddToDictionary(model.varsJTypeAutoGenerated, eh.Jname, model);
                        }
                    }
                    ASTNodeSimple root3 = root2;  //default value
                    if (!(EquationIsRunSeparatelyAfterSim(eh) || EquationIsNotRunAtAll(eh)))
                    {
                        //D- and Z-vars, including reverted equations
                        if (G.Equal(eh.equationCodeD, "d"))
                        {
                            root3 = new ASTNodeSimple("+", true);
                            eh.Dname = "D" + eh.lhs;
                            eh.Zname = "Z" + eh.lhs;
                            AddToDictionary(model.varsDTypeAutoGenerated, eh.Dname, model);
                            AddToDictionary(model.varsZTypeAutoGenerated, eh.Zname, model);
                            ASTNodeSimple child1 = new ASTNodeSimple("*", true);
                            ASTNodeSimple child2 = new ASTNodeSimple("*", true);
                            root3.Add(child1);
                            root3.Add(child2);
                            ASTNodeSimple child12 = new ASTNodeSimple("-", true);
                            child1.Add(root2);  //this root may have J-factors included
                            child1.Add(child12);
                            child12.Add(new ASTNodeSimple("ASTDOUBLE", "1.0"));
                            child12.Add(new ASTNodeSimple("ASTVARIABLE", eh.Dname, "FALSE")); //cannot be base bank
                            child2.Add(new ASTNodeSimple("ASTVARIABLE", eh.Dname, "FALSE"));  //cannot be base bank
                            child2.Add(new ASTNodeSimple("ASTVARIABLE", eh.Zname, "FALSE"));  //cannot be base bank
                            //create reverted equations for J- and Z-variables
                            if (eh.equationCodeJadditive)
                            {
                                //TODO: clean up, reorder, rename, do diagram
                                ASTNodeSimple FrmlJ = new ASTNodeSimple("ASTFRML", true);  //super-root
                                ASTNodeSimple root4 = new ASTNodeSimple("-", true);
                                FrmlJ.Add(new ASTNodeSimple("ASTFRMLCODE", "AUTOGENERATED"));
                                FrmlJ.Add(new ASTNodeSimple("ASTLEFTSIDE", eh.Jname));
                                ASTNodeSimple ex = new ASTNodeSimple("ASTEXPRESSION", true);
                                ex.Add(root4);
                                FrmlJ.Add(ex);
                                ASTNodeSimple child41 = new ASTNodeSimple("ASTVARIABLE", eh.lhs);
                                ASTNodeSimple child42 = root1;
                                root4.Add(child41);
                                root4.Add(child42);
                                EquationHelper ehJ = new EquationHelper();
                                ehJ.lhs = eh.Jname;
                                ehJ.lhsWithLagIndicator = eh.Jname + Globals.lagIndicator + "0";
                                ehJ.equationType = EEquationType.RevertedAutoGenerated;
                                ehJ.equationsNodeRoot = FrmlJ;
                                ehJ.equationNumber = model.equationsReverted.Count;
                                model.equationsReverted.Add(ehJ);
                            }
                            if (eh.equationCodeJmultiplicative)
                            {
                                //TODO: clean up, reorder, rename, do diagram
                                ASTNodeSimple FrmlJR = new ASTNodeSimple("ASTFRML", true);  //super-root
                                ASTNodeSimple root4 = new ASTNodeSimple("-", true);
                                ASTNodeSimple root4child = new ASTNodeSimple("/", true);
                                root4.Add(root4child);
                                root4.Add(new ASTNodeSimple("ASTDOUBLE", "1"));
                                FrmlJR.Add(new ASTNodeSimple("ASTFRMLCODE", "AUTOGENERATED"));
                                FrmlJR.Add(new ASTNodeSimple("ASTLEFTSIDE", eh.Jname));
                                ASTNodeSimple ex = new ASTNodeSimple("ASTEXPRESSION", true);
                                ex.Add(root4);
                                FrmlJR.Add(ex);
                                ASTNodeSimple child41 = new ASTNodeSimple("ASTVARIABLE", eh.lhs);
                                ASTNodeSimple child42 = root1;
                                root4child.Add(child41);
                                root4child.Add(child42);
                                EquationHelper ehJR = new EquationHelper();
                                ehJR.lhs = eh.Jname;
                                ehJR.lhsWithLagIndicator = eh.Jname + Globals.lagIndicator + "0";
                                ehJR.equationType = EEquationType.RevertedAutoGenerated;
                                ehJR.equationsNodeRoot = FrmlJR;
                                ehJR.equationNumber = model.equationsReverted.Count;
                                model.equationsReverted.Add(ehJR);
                            }

                            bool z = false;
                            if (true)
                            {
                                //With this patch, we always do the inverted Z-eqation, even if there are no J, JD, or JR. So this may be an FRML _D__D for instance. Then the Z-variable will always be ready after simulation.
                                z = true;
                            }                            

                            if (z)
                            {
                                //TODO: clean up, reorder, rename, do diagram
                                ASTNodeSimple FrmlZ = new ASTNodeSimple("ASTFRML", true);  //super-root
                                FrmlZ.Add(new ASTNodeSimple("ASTFRMLCODE", "AUTOGENERATED"));
                                FrmlZ.Add(new ASTNodeSimple("ASTLEFTSIDE", eh.Zname));
                                ASTNodeSimple ex = new ASTNodeSimple("ASTEXPRESSION", true);
                                ex.Add(new ASTNodeSimple("ASTVARIABLE", eh.lhs));
                                FrmlZ.Add(ex);
                                EquationHelper ehZ = new EquationHelper();
                                ehZ.lhs = eh.Zname;
                                ehZ.lhsWithLagIndicator = eh.Zname + Globals.lagIndicator + "0";
                                ehZ.equationType = EEquationType.RevertedAutoGenerated;
                                ehZ.equationsNodeRoot = FrmlZ;
                                ehZ.equationNumber = model.equationsReverted.Count;
                                model.equationsReverted.Add(ehZ);
                            }
                        }
                        else if (eh.equationCodeD == "" || eh.equationCodeD == "_")
                        {
                            //Not autogenerated D- and Z-vars (but we need the reverted J-equation
                            if (eh.equationCodeJadditive)
                            {
                                if (true)
                                {
                                    //TODO: clean up, reorder, rename, do diagram
                                    ASTNodeSimple FrmlJ = new ASTNodeSimple("ASTFRML", true);  //super-root
                                    ASTNodeSimple root4 = new ASTNodeSimple("-", true);
                                    FrmlJ.Add(new ASTNodeSimple("ASTFRMLCODE", "AUTOGENERATED"));
                                    FrmlJ.Add(new ASTNodeSimple("ASTLEFTSIDE", eh.Jname));
                                    ASTNodeSimple ex = new ASTNodeSimple("ASTEXPRESSION", true);
                                    ex.Add(root4);
                                    FrmlJ.Add(ex);
                                    ASTNodeSimple child41 = new ASTNodeSimple("ASTVARIABLE", eh.lhs);
                                    ASTNodeSimple child42 = root1;
                                    root4.Add(child41);
                                    root4.Add(child42);
                                    EquationHelper ehJ = new EquationHelper();
                                    ehJ.lhs = eh.Jname;
                                    ehJ.lhsWithLagIndicator = eh.Jname + Globals.lagIndicator + "0";
                                    ehJ.equationType = EEquationType.RevertedAutoGenerated;
                                    ehJ.equationsNodeRoot = FrmlJ;
                                    ehJ.equationNumber = model.equationsReverted.Count;
                                    model.equationsReverted.Add(ehJ);
                                }
                            }
                            else if (eh.equationCodeJmultiplicative)
                            {
                                if (true)
                                {
                                    if (true)
                                    {
                                        //TODO: clean up, reorder, rename, do diagram
                                        ASTNodeSimple FrmlJR = new ASTNodeSimple("ASTFRML", true);  //super-root
                                        ASTNodeSimple root4 = new ASTNodeSimple("-", true);
                                        ASTNodeSimple root4child = new ASTNodeSimple("/", true);
                                        root4.Add(root4child);
                                        root4.Add(new ASTNodeSimple("ASTDOUBLE", "1"));
                                        FrmlJR.Add(new ASTNodeSimple("ASTFRMLCODE", "AUTOGENERATED"));
                                        FrmlJR.Add(new ASTNodeSimple("ASTLEFTSIDE", eh.Jname));
                                        ASTNodeSimple ex = new ASTNodeSimple("ASTEXPRESSION", true);
                                        ex.Add(root4);
                                        FrmlJR.Add(ex);
                                        ASTNodeSimple child41 = new ASTNodeSimple("ASTVARIABLE", eh.lhs);
                                        ASTNodeSimple child42 = root1;
                                        root4child.Add(child41);
                                        root4child.Add(child42);
                                        EquationHelper ehJR = new EquationHelper();
                                        ehJR.lhs = eh.Jname;
                                        ehJR.lhsWithLagIndicator = eh.Jname + Globals.lagIndicator + "0";
                                        ehJR.equationType = EEquationType.RevertedAutoGenerated;
                                        ehJR.equationsNodeRoot = FrmlJR;
                                        ehJR.equationNumber = model.equationsReverted.Count;
                                        model.equationsReverted.Add(ehJR);
                                    }
                                }
                            }


                        }
                        else if (eh.equationCodeD != "" && eh.equationCodeD != "_")
                        {
                            codeError += "Expected 'D' in position 5 in equation code\n";
                        }
                    }

                    if (G.Equal(eh.equationCodeZ, "z"))
                    {
                        //damping should not be done in generated code, not necessary (and dangerous)
                    }
                    else if (eh.equationCodeZ != "" && eh.equationCodeZ != "_") codeError += "Expected 'Z' in position 7 in equation code\n";
                    //put this into tree instead of rhs (root may actually be = rhs if no J- or D-stuff)

                    equationNode.Children[0] = root3;

                    if (codeError != "")
                    {
                        new Error("Problem regarding equation code in '" + eh.lhs + "' equation. " + eh.equationText + ".");                        
                    }
                    break;

            }

            //------------- for testing ------------------
            bool sameParenthesesInMachineCodeAsInHumanReadableCode = false; //should be false for safety, used to test if the human code parantheses are ok (not too many removed)
            //--------------------------------------------

            if (visitChildren == true && equationNode.Children != null)
            {
                int num = equationNode.Children.Count;
                for (int i = 0; i < num; ++i)
                {
                    ASTNodeSimple equationNodeChild = equationNode.Children[i];
                    bool last2 = false;
                    if (i == equationNode.Children.Count - 1) last2 = true;
                    bool first2 = false;
                    if (i == 0) first2 = true;

                    {
                        //------------------ before each child ----------------
                        switch (equationNode.Text)
                        {
                            case "*":
                            case "+":
                            case "-":
                            case "/":
                            case "%":
                                if (!sameParenthesesInMachineCodeAsInHumanReadableCode) wh2.rightHandSideCsCode.Append("(", EEmitType.computerReadable);
                                break;
                        }

                        bool setHumanParenthesis = false;
                        switch (equationNode.Text)
                        {

                            case "*":
                            case "/":
                            case "-":
                            case "+":
                            case "%":
                                setHumanParenthesis = true;
                                break;
                        }


                        //------------------ before each child ----------------
                        switch (equationNode.Text)
                        {
                            case "*":
                                if (equationNodeChild.Text == "*" || equationNodeChild.Text == "/") setHumanParenthesis = false;
                                break;
                            case "/":
                                break;
                            case "-":
                                if ((equationNodeChild.Text == "*" || equationNodeChild.Text == "/")) setHumanParenthesis = false;
                                break;
                            case "+":
                                if ((equationNodeChild.Text == "+" || equationNodeChild.Text == "-") || (equationNodeChild.Text == "*" || equationNodeChild.Text == "/")) setHumanParenthesis = false;
                                break;
                            case "%":
                                break;
                        }

                        bool isTimeDifferenceFunction = true;
                        if (equationNodeChild.Text == "ASTFUNCTION" && (G.Equal(equationNodeChild.GetChild(0).Text, "exp") || G.Equal(equationNodeChild.GetChild(0).Text, "log") || G.Equal(equationNodeChild.GetChild(0).Text, "pow")))
                        {
                            isTimeDifferenceFunction = false;
                        }

                        if (equationNodeChild.Text == "ASTVARIABLE" || equationNodeChild.Text == "ASTVARIABLELAGLEAD" || equationNodeChild.Text == "ASTDOUBLE" || equationNodeChild.Text == "ASTINTEGER" || (!isTimeDifferenceFunction && equationNodeChild.Text == "ASTFUNCTION"))
                        {
                            setHumanParenthesis = false;  //overrides everything above
                        }
                        if (sameParenthesesInMachineCodeAsInHumanReadableCode)
                        {
                            if (setHumanParenthesis) wh2.rightHandSideCsCode.Append("(", EEmitType.bothHumanAndComputerReadable);  //0 means all
                        }
                        else
                        {
                            if (setHumanParenthesis) wh2.rightHandSideCsCode.Append("(", EEmitType.humanReadable);  //2 means only human
                        }



                        //------------------ before each child end ----------------

                        ParserFrmWalkASTEquation(eh, equationNodeChild, depth + 1, wh2, model, subTreeLag, isModel);

                        //------------------ after each child ----------------

                        if (sameParenthesesInMachineCodeAsInHumanReadableCode)
                        {
                            if (setHumanParenthesis) wh2.rightHandSideCsCode.Append(")", EEmitType.bothHumanAndComputerReadable);
                        }
                        else
                        {
                            if (setHumanParenthesis) wh2.rightHandSideCsCode.Append(")", EEmitType.humanReadable);
                        }

                        switch (equationNode.Text)
                        {
                            case "*":
                            case "+":
                            case "-":
                            case "/":
                            case "%":
                                if (!sameParenthesesInMachineCodeAsInHumanReadableCode) wh2.rightHandSideCsCode.Append(")", EEmitType.computerReadable);  //nonhuman
                                if (!last2) wh2.rightHandSideCsCode.Append(" " + equationNode.Text + " ", EEmitType.bothHumanAndComputerReadable);  //all
                                break;
                            case "ASTFUNCTION":
                                if (!last2 && !first2) wh2.rightHandSideCsCode.Append(", ");  //functions with more that 1 argument
                                break;
                        }
                        //------------------ after each child ----------------
                    }
                }
            }

            for (int i = 0; i < numberOfRightParentheses; i++)
            {
                wh2.rightHandSideCsCode.Append(")");
            }
        }

        private static void AddToDictionary(Dictionary<string, string> ht, string name, ModelGekko model)
        {
            if (ht.ContainsKey(name))
            {
                model.fatalEndogenousError = true;
            }
            else
            {
                ht.Add(name, "");
            }
        }

        public static void AST2(ASTNodeSimple node, int depth)
        {
            G.Writeln(G.Blanks(depth * 2) + node.Text);
            if (node.Children != null)
            {
                for (int i = 0; i < node.Children.Count; ++i)
                {
                    ASTNodeSimple child = (ASTNodeSimple)(node.Children[i]);
                    AST2(child, depth + 1);
                }
            }
        }

        private static void EmitCsDoVariableStuff(EquationHelper eh, WalkerHelper2 wh2, ModelGekko model, bool isModel, string variable3, int lag, bool isBaseBank, string absoluteTime, string namedBank)
        {
            PrintVariableAsBType(eh, wh2, model, variable3, lag, false, false, isModel, isBaseBank, absoluteTime, namedBank); //false=rightside
            //doing model frml
            string atSign = "";
            if (isBaseBank) atSign = "@";  //this way, fY lagged from basebank becomes "@fy¤-1". Used only when doing PRT or GENR statements, not for models.

            string varWithLag = "";
            if (absoluteTime == null)
            {
                if (namedBank == null)
                {
                    //@fY¤-2
                    varWithLag = atSign + variable3 + Globals.lagIndicator + lag;
                }
                else
                {
                    //adambk:fY¤-2
                    varWithLag = namedBank + ":" + variable3 + Globals.lagIndicator + lag;
                }
            }
            else
            {
                if (namedBank == null)
                {
                    //@fY¤¤2001q3  (two ¤¤ indicate absolute time)
                    varWithLag = atSign + variable3 + Globals.lagIndicator + Globals.lagIndicator + absoluteTime;
                }
                else
                {
                    varWithLag = namedBank + ":" + variable3 + Globals.lagIndicator + Globals.lagIndicator + absoluteTime;
                }
            }

            string varWithLag2 = varWithLag;

            if (!eh.precedentsWithLagIndicator.ContainsKey(varWithLag2))
            {
                eh.precedentsWithLagIndicator.Add(varWithLag2, "");
            }

        }


        private static bool EquationIsNotRunAtAll(EquationHelper eh)
        {
            //a bit of a hack here.
            //problem is that equations are run in different batches during parsing, and 
            //EEquationType.RevertedP is not set from the beginning. Therefore we also test the equation code.
            return eh.equationType == EEquationType.RevertedP || IsEquationTypeP(eh.equationCode);
        }

        public static bool EquationIsRunSeparatelyAfterSim(EquationHelper eh)
        {
            return eh.equationType == EEquationType.RevertedAutoGenerated || eh.equationType == EEquationType.RevertedY || eh.equationType == EEquationType.RevertedT;
        }

        private static void ExtractDJZAndEquationTypeFromEquationCode(EquationHelper eh, ModelGekko model, bool isModel)
        {
            string code = eh.equationCode;

            if (code == "ASTIDENTITYCODE")
            {
                code = "_i";
            }

            if (code == "AUTOGENERATED")
            {
                eh.equationType = EEquationType.RevertedAutoGenerated;
                return;
            }

            if (code.Length == 0)
            {
                eh.equationType = EEquationType.I;
                PrintEquationCodeWarning(eh);
                return;
            }
            string var = eh.lhsWithLagIndicator;

            if (G.Equal(code.Substring(0, 1), Globals.equationCodeT)) //FRML x... for table variables
            {
                eh.equationType = EEquationType.RevertedT;
                return;
            }
            else if (G.Equal(code.Substring(0, 1), Globals.equationCodeY))
            {
                eh.equationType = EEquationType.RevertedY;  //for instance "Y"-type eqs, with J- or Z-vars on left side
                return;
            }
            else if (IsEquationTypeP(code)) //FRML z... for ignored variables (used in PREDICT)
            {
                eh.equationType = EEquationType.RevertedP;
                return;
            }
            else if (G.Equal(code.Substring(0, 1), "i")) //FRML i... is not endorsed or used, but there may be some instances
            {
                eh.equationType = EEquationType.I; //understood as FRML _i...
                return;
            }
            else if (G.Equal(code.Substring(0, 1), "d")) //FRML d... is not endorsed or used, but there may be some instances
            {
                eh.equationType = EEquationType.D; //understood as FRML _d...
                return;
            }
            else if (code.Substring(0, 1) == "_")
            {
                //ok
            }
            else
            {
                eh.equationType = EEquationType.I;
                PrintEquationCodeWarning(eh);
                return;
            }

            eh.equationCodeJ = "";
            eh.equationCodeD = "";
            if (code.Length == 1)
            {
                //it must be "_"
                eh.equationType = EEquationType.I;
                PrintEquationCodeWarning(eh);
                return;
            }

            string type = code.Substring(1, 1);
            if (G.Equal(type, "d")) eh.equationType = EEquationType.D;
            else if (G.Equal(type, "i")) eh.equationType = EEquationType.I;
            else if (G.Equal(type, "g")) eh.equationType = EEquationType.G;
            else if (G.Equal(type, "k")) eh.equationType = EEquationType.K;
            else if (G.Equal(type, "s")) eh.equationType = EEquationType.S;
            else
            {
                eh.equationType = EEquationType.I;
                PrintEquationCodeWarning(eh);
            }

            if (code.Length == 3)
            {
                //1 char
                eh.equationCodeJ = code.Substring(2, 1) + "_";  //no examples of only "_GJ" for instance, but just in case. Should be "_GJ_".
                //TODO: maybe invoke a warning here
            }
            if (code.Length >= 4)
            {
                //2 chars
                eh.equationCodeJ = code.Substring(2, 2);
            }
            if (code.Length >= 5)
            {
                //1 char, if dummy
                eh.equationCodeD = code.Substring(4, 1);
            }
            if (isModel && code.Length >= 7)  //damping not relevant if not isModel (i.e. a GENR statement)
            {
                //1 char, if dummy
                eh.equationCodeZ = code.Substring(6, 1);
                if (G.Equal(eh.equationCodeZ, "Z"))
                {
                    //variable is to be damped in Gauss-Seidel
                    if (model.dampVariables.ContainsKey(var))
                    {
                        new Error("It seems the same damp variable appears multiple times", false);
                    }
                    else
                    {
                        model.dampVariables.Add(var, "");
                    }
                }
            }
            return;
        }

        private static int GetLags(WalkerHelper2 wh2, string function, ASTNodeSimple lags)
        {
            int intLags = -12345;
            if (lags.Text == "ASTINTEGER")
            {
                intLags = int.Parse(lags.GetChild(0).Text);
            }
            else if (lags.Text == "ASTASSIGNVAR")
            {
                string value2 = HandleModelVal(lags, wh2);
                bool xx = int.TryParse(value2, out intLags);
                if (!xx)
                {
                    new Error("The VAL " + value2 + " is not suitable as second argument of " + function + "()");
                }
            }
            else
            {
                new Error("Expected the second argument of " + function + "() function to be a fixed value");
            }

            if (intLags <= 0 || intLags >= 100)
            {
                new Error("Expected lags in " + function + "() function to > 0 and < 100");
            }

            return intLags;
        }

        private static string HandleModelVal(ASTNodeSimple equationNode, WalkerHelper2 wh2)
        {
            //string key = equationNode.GetChild(0).Text.Substring(1);
            string key = equationNode.GetChild(0).Text;
            string value = null;
            if (wh2.vals == null || !wh2.vals.TryGetValue(key, out value))
            {
                new Error("Could not find VAL '" + key + "' definition in .frm file");
            }
            if (value.EndsWith(".")) value = value + "0";  //otherwise "1." becomes "1.d" which is not allowed
            return value;
        }

        private static void HandlePowFunction(EquationHelper eh, ASTNodeSimple equationNode, int depth, WalkerHelper2 wh2, ModelGekko model, int subTreeLag, bool isModel, bool function)
        {
            wh2.rightHandSideCsCode.Append("O.Pow(", EEmitType.computerReadable);
            wh2.rightHandSideCsCode.Append("pow(", EEmitType.humanReadable);
            int start = 0;
            int end = 1;
            if (function)
            {
                start = 1;
                end = 2;
            }
            for (int i = start; i <= end; i++)
            {
                wh2.rightHandSideCsCode.Append("(");
                ParserFrmWalkASTEquation(eh, equationNode.Children[i], depth + 1, wh2, model, subTreeLag, isModel);
                wh2.rightHandSideCsCode.Append(")");
                if (i == start) wh2.rightHandSideCsCode.Append(", ");
            }
            wh2.rightHandSideCsCode.Append(")");
        }

        private static bool IsEquationTypeP(string code)
        {
            return G.Equal(code.Substring(0, 1), Globals.equationCodeP);
        }

        private static void PrintEquationCodeWarning(EquationHelper eh)
        {
            if (false)
            {
                //Probably no need to report these
                new Warning("Equation type set to _I for this equation:" + G.NL + eh.equationText);
            }
            return;
        }

        private static void PrintVariableAsBType(EquationHelper eh, WalkerHelper2 wh2, ModelGekko model, string variable, int lag, bool leftSide, bool humanReadable, bool isModel, bool isBaseBank, string absoluteTime, string namedBank)
        {
            if (EquationIsNotRunAtAll(eh))
            {
                //these equations are not part of the model at all, only used for PREDICT
                //so they are not counted regarding lags, leads, etc.
                if (!leftSide)
                {
                    LongVersionAndHumanVersion(wh2, variable, lag);  //so PREDICT has some code
                }
                return;
            }

            if (isModel)  //for equations in model/frm, probably always true nowadays
            {
                //ATypeData dataA = model.varsAType[variable];
                ATypeData dataA = null; model.varsAType.TryGetValue(variable, out dataA);
                //lag is -1 for fY(-1). It is positive for leads.

                if (dataA == null)
                {
                    dataA = new ATypeData();
                    dataA.aNumber = model.varsAType.Count;
                    dataA.varName = variable;  //only reason to add this is when we want to get the right lower/uppercase of the variable
                    model.varsAType.Add(variable, dataA);
                }

                if (true)
                {

                    if (lag < 0)
                    {
                        if (-lag > model.largestLag) model.largestLag = -lag;  //model.largestLag is always 0 or positive
                        if (-lag > eh.largestLag) eh.largestLag = -lag;  //eh.largestLag is always 0 or positive
                    }
                    else if (lag > 0)
                    {
                        if (!EquationIsRunSeparatelyAfterSim(eh))
                        {
                            //not type T, Y, reverted J
                            if (lag > model.largestLeadOutsideRevertedPart) model.largestLeadOutsideRevertedPart = lag;  //model.largestLeadOutsideRevertedPart is always 0 or positive
                            if (!model.leadedVariables.ContainsKey(dataA.aNumber)) model.leadedVariables.Add(dataA.aNumber, 1);  //1 is just artificial
                        }
                        if (lag > model.largestLead) model.largestLead = lag;  //model.largestLead is always 0 or positive                    
                                                                               // --- in the equation ---
                        if (lag > eh.largestLead) eh.largestLead = lag;  //eh.largestLead is always 0 or positive                    
                    }
                }

                string input = variable + Globals.lagIndicator + lag;
                BTypeData data = null; model.varsBType.TryGetValue(input, out data);
                if (data == null)
                {
                    data = new BTypeData();
                    data.variable = variable;
                    data.bNumber = model.varsBType.Count;
                    data.lag = lag;
                    //data.equations = new ArrayList();
                    data.leftHandSideEquation = -12345;  //-12345 means none
                    data.aNumber = dataA.aNumber;
                    model.varsBType.Add(input, data);
                    model.varsBTypeInverted.Add(data.bNumber, input);
                }

                //TODO: maybe move test of leftside/rightside out of method to calling method
                if (leftSide == true)
                {
                    string var2 = "";
                    if (lag == 0)
                    {
                        var2 = variable;
                    }
                    else
                    {
                        var2 = variable + "[" + lag + "]";
                    }

                    wh2.leftHandSideHumanReadable.Append(var2);
                    wh2.leftHandSideBNumber = data.bNumber;
                    wh2.leftHandSideCsCodeGauss.Append("b[" + data.bNumber + "]");
                    wh2.leftHandSideCsCodeJacobi.Append("c[" + data.bNumber + "]");
                    wh2.scalar_leftHandSideA.Append("x" + (data.bNumber + 1));
                }
                else
                {
                    //right side
                    //Here we do both the short, long and human version individually

                    if (lag >= 1)
                    {
                        wh2.rightHandSideCsCode.shortVersion.Append("O.Lead(b, " + data.bNumber + ")");
                    }
                    else
                    {
                        //normal way for non-lead variables
                        wh2.rightHandSideCsCode.shortVersion.Append("b[" + data.bNumber + "]");
                    }

                    //This is probably so that equations can be GENR'ed
                    LongVersionAndHumanVersion(wh2, variable, lag);
                    wh2.rightHandSideCsCode.scalarVersion.Append("x" + (data.bNumber + 1));
                }
            }      
            else
            {
                new Error("Internal error #980725238579");
            }
        }

        private static void LongVersionAndHumanVersion(WalkerHelper2 wh2, string variable, int lag)
        {
            wh2.rightHandSideCsCode.longVersion.Append("O.PredictGetValue(`" + variable + "`, gt.Add(" + lag + "))");
            wh2.rightHandSideCsCode.humanVersion.Append(variable + "[" + lag + "]");
        }

        public class WalkerHelper2
        {
            public StringBuilder2 rightHandSideCsCode = new StringBuilder2(); //also contains scalar x1, x2 etc.
            public StringBuilder leftHandSideCsCodeGauss = new StringBuilder();  // b[117]
            public StringBuilder leftHandSideCsCodeJacobi = new StringBuilder();  // c[117]
            public StringBuilder leftHandSideHumanReadable = new StringBuilder();  //fy
            public StringBuilder scalar_leftHandSideA = new StringBuilder();  //x1, x2, ...
            public int leftHandSideBNumber = -12345;  //only used for model
            public List<string> allReferencedTimeSeriesOrListsWork = new List<string>();  //only used for expressions in cmd
            public List<string> allReferencedTimeSeriesOrListsBase = new List<string>();  //only used for expressions in cmd
            public List<string> problematicFrmlCodes = new List<string>();
            public string frmlCode = "";
            public string leftSideFunction = "";
            public string variableOrFunctionIndicator = "";
            public ASTNodeSimple rhs = null;
            public Dictionary<string, string> vals = null;
        }

        public class StringBuilder2
        {
            public StringBuilder shortVersion = new StringBuilder();
            public StringBuilder longVersion = new StringBuilder();
            public StringBuilder humanVersion = new StringBuilder();
            public StringBuilder scalarVersion = new StringBuilder();

            public void Append(string s)
            {
                Append(s, 0);
            }

            public void Append(string s, EEmitType which)
            {  //0: all, 1: nonhuman, 2: human
                if (which == EEmitType.bothHumanAndComputerReadable || which == EEmitType.computerReadable)
                {
                    shortVersion.Append(s);
                    longVersion.Append(s);

                    //The following is hacky. 
                    //Should be dealt with properly, but is probably not dangerous at all.
                    string s2 = s;
                    if (s.EndsWith("d"))
                    {
                        //remove "d" if number
                        //a bit hacky, but speed penalty should not be large.
                        string s3 = s2.Substring(0, s2.Length - 1);
                        double v;
                        bool b = double.TryParse(s3, out v);
                        if (b) s2 = s3;
                    }

                    if (s2.StartsWith("O."))
                    {
                        s2 = s2.Substring(2);
                    }

                    scalarVersion.Append(s2);                    
                }
                if (which == EEmitType.bothHumanAndComputerReadable || which == EEmitType.humanReadable)
                {
                    humanVersion.Append(s);
                }
            }

            public void AppendLine(string s)
            {
                AppendLine(s, 0);
            }

            public void AppendLine(string s, EEmitType which)
            {
                if (which == EEmitType.bothHumanAndComputerReadable || which == EEmitType.computerReadable)
                {
                    shortVersion.AppendLine(s);
                    longVersion.AppendLine(s);
                    scalarVersion.AppendLine(s);
                }
                if (which == EEmitType.bothHumanAndComputerReadable || which == EEmitType.humanReadable)
                {
                    humanVersion.AppendLine(s);
                }
            }
        }
    }
}
