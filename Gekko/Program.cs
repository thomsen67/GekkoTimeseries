/*
    Gekko Timeseries Software (www.t-t.dk/gekko).
    Copyright (C) 2016, Thomas Thomsen, T-T Analyse.

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program (see the file COPYING in the root folder).
    Else, see <http://www.gnu.org/licenses/>.
*/

using System.Text.RegularExpressions;
using System;
using System.Drawing;
using System.Windows.Forms;
using System.IO;
using System.Text;
using System.Collections.Generic;
using System.Collections;
using System.Globalization;
using System.Windows.Forms;
using System.Threading;
using MathNet.Numerics.LinearAlgebra.Sparse.Linear;
using MathNet.Numerics.LinearAlgebra.Sparse;
using MathNet.Numerics.LinearAlgebra.Sparse.Tests;
using System.Diagnostics;
using System.ComponentModel;
using System.Drawing;
using System.Data;
using Microsoft.CSharp;
using System.CodeDom;
using System.CodeDom.Compiler;
using System.Runtime.Serialization;
using System.Reflection;
using System.Xml;
using System.Xml.Serialization;
using Office = Microsoft.Office.Core;
using VBIDE = Microsoft.Vbe.Interop;
using Excel = Microsoft.Office.Interop.Excel;
using System.Runtime.InteropServices;
using SevenZip;
using System.Security.Permissions;
using Microsoft.Win32;
using System.Security.Cryptography;
using System.Reflection.Emit;
using System.Runtime.Serialization.Formatters.Binary;
using ProtoBuf;
using ProtoBuf.Meta;
using System.Diagnostics;
using System.Collections.ObjectModel;
using GAMS;
using System.Linq;

namespace Gekko
{

    public class GekkoList<T>
    {
        private List<T> container = new List<T>();

        public static GekkoList<T> Construct()
        {
            return new GekkoList<T>();
        }
        public GekkoList()
        {
            //default constructor
        }

        public GekkoList(T s)
        {
            this.container.Add(s);
        }

        public GekkoList(GekkoList<T> x)
        {
            this.container.AddRange(x.container);
        }

        public GekkoList(List<T>x)
        {
            this.container.AddRange(x);
        }
                
        public GekkoList<T> AddRange(GekkoList<T> x)
        {
            this.container.AddRange(x.container);
            return this;
        }

        public GekkoList<T> AddRange(List<T> x)
        {
            this.container.AddRange(x);
            return this;
        }

        public GekkoList<T> Add(T x)
        {
            this.container.Add(x);
            return this;
        }
    }

    public class DateTimeHelper
    {
        public DateTime dt;
        public string s;
        public long size;
    }

    public class BankNameVersion
    {
        public string bank = null;
        public string name = null;
        public string version = null; //not used 
    }

    public class Zipper
    {
        //this zipper should make sure temp folder always gets deleted, also in case of exceptions etc.
        //alternatively: have Gekko delete all gekkotempfilesxxxxx at program start.

        public string tempFolder = null;
        public string zipFileAndFolder = null;  //may omit path, then it will land in working folder

        public Zipper(string zipFileName)
        {
            this.tempFolder = Globals.localTempFilesLocation + "\\" + "gekkotempfiles_" + Program.RandomInt(11111111, 99999999);
            if (Directory.Exists(this.tempFolder))
            {
                Program.DeleteFolder(this.tempFolder);
            }
            Directory.CreateDirectory(this.tempFolder);
            this.zipFileAndFolder = Program.CreateFullPathAndFileName(zipFileName);
        }

        public void ZipAndCleanup()
        {
            Program.WaitForZipWrite(this.tempFolder, this.zipFileAndFolder);
            Program.DeleteFolder(this.tempFolder);
        }
    }

    public enum EPrtCollapseTypes
    {
        Avg,
        Total,
        None
    }

    public enum EReadInfoTypes
    {
        Normal,
        OpenedNewNonExistingFile,
        OpenedFirstOrRefAlreadyOpenBank
    }

    public enum EdataFormat
    {
        Csv,
        Prn
        //Gnuplot
    }

    public enum ESeriesUpdTypes
    {
        none,
        d,
        p,
        m,
        q,
        mp,
        n
    }

    //See #98745239543
    public enum YesNoNull
    {
        Yes,
        No,
        Null
    }

    public enum ESmoothTypes
    {
        Spline,
        Linear,
        Geometric,
        Repeat
    }

    public enum EPrintCodeTypes
    {
        ShortVersion,
        LongVersionHasYes,
        LongVersionHasAppend,
        LongVersionOnlyNo,
        Verbose,
        None,
        Null
    }

    public enum ESignatureStatus
    {
        Ok,
        SignatureNotFoundInModelFile,
        SignaturesDoNotMatch
    }

    public enum ETerminalCondition
    {
        Exogenous,
        ConstantLevel,
        ConstantGrowthRate
    }

    public enum EMissingType
    {
        Ok,
        //HasMissingData,  //NaN, M in tables
        HasMissingVariables  //MV in tables
    }

    public enum StampTypes
    {
        Normal,
        Base,
        Multiplier
    }

    public enum EEndoOrExo
    {
        Endo,
        Exo,
        Unknown
    }

    public enum ETabs
    {
        Main,
        Output,
        Help,
        Menu
    }

    public enum ECompiledModelType  //corresponds to Model.cs --> public Type assemblyGauss etc.
    {
        Gauss,
        GaussFailSafe,
        Res,  //single equation forecast
        Newton,
        After,
        //Eigen,  //for eigenvalue analysis
        Unknown
    }

    public class UndoSim
    {
        public long id = 0L;
        public double[,] a = null;
        public GekkoTime tStart0;
        public GekkoTime tStart;
        public GekkoTime tEnd;
        public int obsWithLags;
        public int obsSimPeriod;
    }

    public class PackSim
    {
        public long id = 0L;
        public double[,] a = null;
        public GekkoTime tStart0;
        public GekkoTime tStart;
        public GekkoTime tEnd;
        public int obsWithLags;
        public int obsSimPeriod;
    }

    public class DatabankTimeseriesNotFoundException : Exception
    {
        //only used for 1 thing
        public DatabankTimeseriesNotFoundException()
        {
        }
    }

    public class GekkoException : System.Exception
    {
        public GekkoException() { }
        public GekkoException(string s) : base(s) { }
    }


    /// <summary>
    /// A storage implementation where the key "example7" and the key "ExAmpLe7" are treated as equal.
    /// Used to contain variables in a model. Such variable names are not case-sensitive.
    /// </summary>
    ///
    [Serializable]
    public class CaseInsensitiveHashtable : Hashtable
    {

        public CaseInsensitiveHashtable(SerializationInfo info, StreamingContext context)
            : base(info, context)
        {
        }

        /// <summary>
        /// Constructor
        /// </summary>
        public CaseInsensitiveHashtable()
            : base()
        {
            this.hcp = new CaseInsensitiveHashCodeProvider();
            this.comparer = new CaseInsensitiveComparer();
        }
        /// <summary>
        /// Constructor
        /// </summary>
        /// <param name="capacity"></param>
        public CaseInsensitiveHashtable(int capacity)
            : base(capacity)
        {
            this.hcp = new CaseInsensitiveHashCodeProvider();
            this.comparer = new CaseInsensitiveComparer();
        }
    }

    public class OptString
    {
        public string s1;
        public string s2;
        public OptString(string s1, string s2)
        {
            this.s1 = s1;
            this.s2 = s2;
        }
    }

    public class OptVal
    {
        public string s;
        public double val;
        public OptVal(string s, double val)
        {
            this.s = s;
            this.val = val;
        }
    }

    public class OptDate
    {
        public string s;
        public GekkoTime date;
        public OptDate(string s, GekkoTime date)
        {
            this.s = s;
            this.date = date;
        }
    }

    /// <summary>
    /// Simple helper class, obsolete??
    /// </summary>
    public class TwoStrings
    {
        public String s1;
        public String s2;
        public String s2Type;
    }

    public class StackHelper
    {
        public string line;  //has a lot of text added
        public string file;
        public int line2;  //as a simple int
    }

    /// <summary>
    /// Simple helper class
    /// </summary>
    public class CompilerOptions
    {
        public bool gauss;
        public bool jacobi;
        public bool newtonNonFeedBack;
        public bool newton;
        public bool gaussFailSafe;
        public long compilerOptionsHash;
    }

    /// <summary>
    /// Helper class
    /// </summary>
    ///
    [Serializable]
    [ProtoContract]
    public class EquationHelper
    {
        [ProtoMember(1)]
        public string lhsWithLagIndicator;  //left hand side with lag indicator (e.g. "fy¤-1").
        [ProtoMember(2)]
        public string lhs;
        [ProtoMember(3)]
        public GekkoDictionary<string, string> precedentsWithLagIndicator = new GekkoDictionary<string, string>(StringComparer.OrdinalIgnoreCase);
        [ProtoMember(5)]
        public int equationNumber = -12345;
        [ProtoMember(6)]
        public string equationText = "";
        [ProtoMember(7)]
        public double typicalVariance = double.NaN;
        [ProtoMember(8)]
        public string equationCode = "";
        [ProtoMember(9)]
        public string csCodeRhs = "";
        [ProtoMember(10)]
        public string csCodeRhsLongVersion = "";
        [ProtoMember(11)]
        public string csCodeRhsHumanVersion = "";
        [ProtoMember(12)]
        public string csCodeLhsGauss = "";
        [ProtoMember(13)]
        public string csCodeLhsJacobi = "";
        [ProtoMember(14)]
        public string csCodeLhsHuman = "";
        [ProtoMember(15)]
        public int bNumberLhs = -12345;
        [ProtoMember(16)]
        public string equationCodeJ = "";
        [ProtoMember(17)]
        public string equationCodeD = "";
        [ProtoMember(18)]
        public string equationCodeZ = "";
        [ProtoMember(19)]
        public bool equationCodeJadditive = false;
        [ProtoMember(20)]
        public bool equationCodeJmultiplicative = false;
        [ProtoMember(21)]
        public EEquationType equationType;
        [ProtoMember(22)]
        public string Jname = "";
        [ProtoMember(23)]
        public string Dname = "";
        [ProtoMember(24)]
        public string Zname = "";
        //[ProtoMember()] !!!!!!!! ignore this!
        public ASTNode equationsNodeRoot = null;
        [ProtoMember(25)]
        public bool isAfterModel = false;  //if equation is after 
        [ProtoMember(26)]
        public bool isAfter2Model = false; //if equation is after AFTER2$ Here, both isAfterModel and isAfter2Model are true at same time
        [ProtoMember(27)]
        public string modelBlock = "";
    }

    /// <summary>
    /// Helper class
    /// </summary>
    public class UserFunctionsHelper
    {
        public ArrayList arguments;
        public List<string> rhs;
        public List<string> rhsType;
    }

    /// <summary>
    /// Helper class
    /// </summary>
    public class UserFunctionsHelper1
    {
        public List<string> al;
        public List<string> alType;
    }


    /// <summary>
    /// Helper class
    /// </summary>
    public class ReadFrmHelper
    {
        public bool fatalErrorRegardingModelFrmls = false;
    }

    /// <summary>
    /// Simple helper class
    /// </summary>
    public class BnkReader
    {
        public int lastRecordRead;
        public String varName;
        public int startPeriod;
        public int endPeriod;
    }

    /// <summary>
    /// Simple helper class
    /// </summary>
    public class ThreeStrings
    {
        public String s1;
        public String s2;
        public String s3;
    }

    /// <summary>
    /// Simple helper class
    /// </summary>
    ///
    [Serializable]
    [ProtoContract]
    public class BTypeData
    {
        [ProtoMember(1)]
        public string variable;
        [ProtoMember(2)]
        public int bNumber;
        [ProtoMember(3)]
        public int aNumber;
        [ProtoMember(4)]
        public int lag;
        //public ArrayList equations;
        [ProtoMember(5)]
        public int leftHandSideEquation;
    }

    /// <summary>
    /// Simple helper class
    /// </summary>
    ///
    [Serializable]
    [ProtoContract]
    public class ATypeData
    {
        [ProtoMember(1)]
        public string varName;
        [ProtoMember(2)]
        public int aNumber;
    }


    /// <summary>
    /// Simple helper class
    /// </summary>
    public class FourInts
    {
        public int start1;
        public int end1;
        public int start2;
        public int end2;

    }

    /// <summary>
    /// Simple helper class
    /// </summary>
    public class TwoInts
    {
        public int int1;
        public int int2;
    }

    public class NewtonFairTaylorHelper
    {
        public List<NewtonFairTaylorHelper1> shocks = null;
        public double[,] jacobi = null;
    }

    public class NewtonFairTaylorHelper1
    {
        public bool isFirstBaseline = false;
        public GekkoTime gt;
        public int varNumber;
        public int varCounter;
    }

    /// <summary>
    /// Simple helper class
    /// </summary>
    public class TranslateVarData
    {
        public int w;
        public int s;
        public int sForA;

    }


    /// <summary>
    /// Simple helper class
    /// </summary>
    public class MacroHelper
    {
        public string s;
    }


    /// <summary>
    /// Contains methods regarding the "engine" (model solving part) of the software
    /// </summary>
    public static class Program
    {
        /// <summary>
        /// Container for all user options
        /// </summary>
        public static Options options = new Options();

        /// <summary>
        /// Container for all the stuff related to the current model
        /// </summary>
        public static Model model = null;

        //these should be cleared with closeall
        /// <summary>
        /// Contains names of the open databanks. Not case-sensitive. The name of any bank points to a
        /// storage with variable names. Which again points to a double[] array with data for each period.
        /// </summary>
        public static Databanks databanks = new Databanks();

        //going to be obsolete
        //public static Dictionary<string, Assigns> assigns = new Dictionary<string, Assigns>(StringComparer.OrdinalIgnoreCase);  //keys: assign-vars without the '#'

        public static GekkoDictionary<string, IVariable> scalars = new GekkoDictionary<string, IVariable>(StringComparer.OrdinalIgnoreCase);  //keys: assign-vars without the '%'
        //public static GekkoDictionary<string, List<string>> lists = new GekkoDictionary<string, List<string>>(StringComparer.OrdinalIgnoreCase);  //lists generated in .cmd files -- contain strings of variables
        //public static CaseInsensitiveHashtable macros = new CaseInsensitiveHashtable();  //macros -- contain strings of anything
        public static Dictionary<string, Table> tables = new Dictionary<string, Table>(StringComparer.OrdinalIgnoreCase);
        public static CompiledGenrStatements compiledGenrStatements = new CompiledGenrStatements();

        //varlist stuff
        public static List<Item> unfoldedVariableList = null;  //the unfolded variable list
        public static int guiBrowseNumber = 0;
        public static List<string> guiBrowseHistory = new List<string>();

        public static int guiBrowseHelpNumber = 0;
        public static List<string> guiBrowseHelpHistory = new List<string>();

        public static int TempVarIndex()
        {
            Globals.tempVarIndexCounter++;
            return Globals.tempVarIndexCounter;
        }

        public static int RandomInt(int min, int max)
        {
            lock (Globals.randomSyncLock)
            {
                return Globals.random777.Next(min, max);
            }
        }

        public static int RandomInt()
        {
            lock (Globals.randomSyncLock)
            {
                return Globals.random777.Next();
            }
        }

        public static double RandomDouble()
        {
            lock (Globals.randomSyncLock)
            {
                return Globals.random777.NextDouble();
            }
        }

        public static void PrintExceptionAndFinishThread(Exception e2, P p)
        {
            if (!Globals.threadIsInProcessOfAborting)
            {

                string eType = e2.GetType().Name;

                if (true)
                {

                    if (SearchException(e2, "lexer error"))
                    {
                        ParseHelper ph = new ParseHelper();
                        string s2 = p.GetStackCommandFileText(p.GetDepth());
                        string s3 = "";
                        if (s2 != null) s3 = s2;
                        ParserOLD.PrintModelParserErrors(Program.CreateListOfStringsFromString(e2.Message), Program.CreateListOfStringsFromString(s3), ph);
                    }
                    if (SearchException(e2, "***") || SearchException(e2, "+++"))
                    {
                        //for instance "*** ERROR: blablabla" or "+++ NOTE: blablabla"
                        //if *** we know that it is a Gekko-generated error text
                        G.Writeln("    " + e2.Message);
                    }
                    string ramProblem = "";
                    if (SearchException(e2, "System.OutOfMemoryException"))
                    {
                        G.Writeln2("*** ERROR: Out of memory (RAM). Please close some unnessecary programs if possible.");
                        Process[] processlist = Process.GetProcesses();
                        int counter = 0;
                        foreach (Process theprocess in processlist)
                        {
                            counter++;
                            ramProblem += "#" + counter;
                            try
                            {
                                ramProblem += " name:" + theprocess.ProcessName;
                            }
                            catch { };
                            try
                            {
                                ramProblem += " id:" + theprocess.Id;
                            }
                            catch { };
                            try
                            {
                                ramProblem += " ram:" + theprocess.WorkingSet64 / 1024;
                            }
                            catch { };
                            try
                            {
                                ramProblem += " maxram:" + theprocess.PeakWorkingSet64 / 1024;
                            }
                            catch { };
                            try
                            {
                                ramProblem += " created:" + theprocess.StartTime.ToString().Replace(" ", "_");
                            }
                            catch { };
                            ramProblem += G.NL;
                        }
                    }
                    if (SearchException(e2, "GekkoException"))
                    {
                        G.Write("*** ERROR: The command failed");
                    }
                    else
                    {
                        G.Write("*** ERROR: The command failed due to internal Gekko error");
                    }
                    string s = "";

                    if (ramProblem != "")
                    {
                        s += "NOTE: Since this is a RAM problem, the error report contains information on the active processes";
                        s += "running on the computer. If you do not wish this information to be contained in the error report,";
                        s += "please delete the section below 'The following is a list of active processes' before sending";
                        s += "the report to the Gekko editor (active processes are usually not sensitive information, and";
                        s += "no content of these processes is used (only their RAM usage etc.)" + G.NL + G.NL;
                        s += e2.ToString() + G.NL;
                        s += G.NL + "The following is a list of active processes:" + G.NL + ramProblem;
                    }
                    else
                    {
                        s += G.NL + e2.ToString();
                    }

                    if (Globals.errorMemory != null)
                    {
                        s += G.NL + G.NL + "---------------------------------------------------------------------" + G.NL;
                        List<string> xx = G.ExtractLinesFromText(Globals.errorMemory.ToString());
                        for (int i = 0; i < xx.Count; i++)
                        {
                            if (i > 30) continue;  //so that we don't accidentally get 100's of lines from user output pasted in. The intention is to only get a copy of messages since last error message.
                            s += xx[i] + G.NL;
                        }
                    }

                    if (Globals.lastDynamicCsCode != null)
                    {
                        //this is nice to have to trace the error if this sort of problem appears!
                        s += G.NL + G.NL + "----------------------------- Non-compiling cs code: ----------------------------------" + G.NL;
                        s += Globals.lastDynamicCsCode;
                        s += G.NL;
                    }

                    LinkContainer lc = new LinkContainer(s);
                    Globals.linkContainer.Add(lc.counter, lc);
                    G.Write(" ("); G.WriteLink("more", "stacktrace:" + lc.counter); G.Write(")"); G.Writeln();
                }
            }
            Gui.gui.ThreadFinished();  //removes the job from the stack of jobs, otherwise we will wait for this halted job forever. Could use thread stop instead??
        }

        public static void ProtectError(string s)
        {
            G.Writeln2("*** ERROR: " + s);
            throw new GekkoException();
        }

        public static void GekkoExceptionCleanup(P p)
        {
            //This method is also called when exceptions arise in unit testing (FAIL() method)
            Program.ReleasePipe();
            Program.ReleasePipe2();

            if (Globals.threadIsInProcessOfAborting)
            {
                G.Writeln();
                G.Writeln("-------------------------------------------------------------", Color.Red);
                G.Writeln("------------ The job was stopped by the user ----------------", Color.Red);
                if (p.hasSeenStopCommand)
                {
                    G.Writeln("--------------- (STOP command line) -------------------------", Color.Red);
                }
                else
                {
                    G.Writeln("---------------- (Red stop button) --------------------------", Color.Red);
                }
                G.Writeln("-------------------------------------------------------------", Color.Red);
                G.Writeln();
                if (p.hasSeenStopCommand)
                {
                    G.Writeln("+++ NOTE: You may use the EXIT command to (stop and) terminate the Gekko application");
                    G.Writeln();
                }
            }
            if (Globals.applicationIsInProcessOfAborting)
            {
                Application.Exit();  //will go to #3452345523 after
            }
        }

        public static bool SearchException(Exception ex, string s)
        {
            if (ex == null) return false;
            if (ex.Message != null && ex.Message.Contains(s)) return true;
            Exception temp = ex;
            for (int i = 0; i < 1000; i++)  //1000 nested levels should be enough...
            {
                temp = temp.InnerException;
                if (temp == null) return false;
                if (temp.Message != null && temp.Message.Contains(s)) return true;
            }
            return false;
        }


        public static string GetStackTraceWithOffset(Exception e2)
        {
            StackTrace st = new System.Diagnostics.StackTrace(e2);
            string stackTrace = "";
            foreach (StackFrame frame in st.GetFrames())
            {
                stackTrace = "           " + "at " + frame.GetMethod().Module.Name + "." +
                    frame.GetMethod().ReflectedType.Name + "."
                    + frame.GetMethod().Name
                    + "  (IL offset: 0x" + frame.GetILOffset().ToString("x") + ")\n" + stackTrace;
            }
            return stackTrace;
        }

        public static void SetGlobalTimePeriodAbstract(bool direct, GekkoTime t1, GekkoTime t2)
        {
            if (direct)
            {
                Globals.globalPeriodStart = t1;
                Globals.globalPeriodEnd = t2;
                //Globals.setPerEncountered = true;
            }
        }

        public static void SetGlobalTimePeriodDirect(GekkoTime t1, GekkoTime t2)
        {
            SetGlobalTimePeriodAbstract(true, t1, t2);
        }

        public static void SetGlobalTimePeriod(GekkoTime t1, GekkoTime t2)
        {
            SetGlobalTimePeriodAbstract(false, t1, t2);
        }

        public static void SetGlobalTimePeriodAbstractNew(bool direct, GekkoTime t1, GekkoTime t2)
        {
            if (direct)
            {
                Globals.globalPeriodStart = t1;
                Globals.globalPeriodEnd = t2;
                //Globals.setPerEncountered = true;
            }
        }

        public static void SetGlobalTimePeriodDirectNew(GekkoTime t1, GekkoTime t2)
        {
            SetGlobalTimePeriodAbstractNew(true, t1, t2);
        }

        public static void SetGlobalTimePeriodNew(GekkoTime t1, GekkoTime t2)
        {
            SetGlobalTimePeriodAbstractNew(false, t1, t2);
        }

        /// <summary>
        /// Creates a double[,] array to contain periodic (i.e. yearly/monthly) data.
        /// Can be initialized to "NaN"'s, depending upon the global initializeDataArrayWithNaN (typically set to true), else is initialized with zeroes.
        /// Initializing with zeroes may have unintended concequences if some data is missing.
        /// </summary>
        /// <param name="vars">Max number of variables to hold</param>
        /// <param name="periods">Max number of periods to hold</param>
        /// <returns></returns>
        public static double[,] createDataArray(int vars, int periods)
        {
            double[,] a1 = new double[vars, periods];
            if (Globals.initializeDataArrayWithNaN)
            {
                for (int i = 0; i < vars; i++)
                {
                    for (int j = 0; j < periods; j++)
                    {
                        a1[i, j] = double.NaN;
                    }
                }
            }
            return a1;
        }

        /// <summary>
        /// Returns next pos that is not blank.
        /// Also skips tabs. Returns -12345 if not found.
        /// </summary>
        /// <param name="c">Array of characters</param>
        /// <param name="ii">Start position to search from</param>
        /// <returns>Found position.</returns>
        static int skipSpaces(char[] c, int ii)
        {
            int i;
            //skip spaces (tab is included counted)
            for (i = ii; i < int.MaxValue; i++)
            {
                if (c[i] == ' ' || c[i] == '\t')     //'\t' is tab
                {
                    //do nothing
                }
                else return i;
            }
            return -12345;
        }
        static int skipSpaces(string c, int ii)
        {
            int i;
            //skip spaces (tab is included counted)
            for (i = ii; i < c.Length; i++)
            {
                if (c[i] == ' ' || c[i] == '\t')     //'\t' is tab
                {
                    //do nothing
                }
                else return i;
            }
            return -12345;
        }

        /// <summary>
        /// Returns pos after next new line code ('\r\n'). Returns -12345 if not found.
        /// </summary>
        /// <param name="c">Array of characters</param>
        /// <param name="ii">Start position to search from</param>
        /// <returns>Found position.</returns>
        static int skipPastNewLine(char[] c, int ii)
        {  //
            int i;
            for (i = ii; i < c.Length; i++)
            {
                if (!(c[i] == '\r' && c[i + 1] == '\n'))
                {
                    //do nothing
                }
                else return i + 2;
            }
            return -12345;
        }

        /// <summary>
        /// Returns next pos that is the input character. Returns -12345 if not found.
        /// </summary>
        /// <param name="c">Array of characters</param>
        /// <param name="ii">Start position to search from</param>
        /// <param name="toFind">Input character</param>
        /// <returns>Found position.</returns>
        static int findChar(char[] c, int ii, char toFind)
        {
            int i;
            for (i = ii; i < c.Length; i++)
            {
                if (c[i] == toFind) return i;
            }
            return -12345;
        }

        /// <summary>
        /// Returns next pos that is the input character. Returns -12345 if not found.
        /// </summary>
        /// <param name="c">Array of characters</param>
        /// <param name="ii">Start position to search from</param>
        /// <param name="iiMax">Last position legal to search</param>
        /// <param name="toFind">Input character</param>
        /// <returns>Found position.</returns>
        static int findChar(char[] c, int ii, int iiMax, char toFind)
        {
            int i;
            for (i = ii; i < c.Length; i++)
            {
                if (i > iiMax) return -12345;
                if (c[i] == toFind) return i;
            }
            return -12345;
        }

        static String addLag(String s, double lag)
        {
            //for instance "fy¤-1" with lag=-3
            //gives "fy¤-1¤-3"
            if (Globals.removeAllLags == 1)
            {
                lag = 0d;
            }
            s = s + Globals.lagIndicator + lag + "d";  //the "d" denotes double value. Used here since lags can be fractional (for instance fy(-0.5)
            return s;
        }

        public static String RemoveTrailingD(String lag)
        {
            String lag1 = "";
            //problem is: all lags look like this: fy(-2d)
            //the d is added to indicate double precision
            if (lag.EndsWith("d"))
            {
                //remove last "d"
                lag1 = lag.Substring(0, lag.Length - 1);
            }
            else
            {
                lag1 = lag;
            }
            return lag1;
        }

        private static String AddTrailingD(String lag)
        {
            String lag1 = "";
            if (lag.EndsWith("d"))
            {
                //do nothing
            }
            else
            {
                lag1 = lag + "d";
            }
            return lag1;
        }

        /// <summary>
        /// s must be of form "var¤-1", multiple Globals.lagIndicator not allowed.
        /// if "var¤-1¤-1", .s1 is ok but .s2 not.
        /// if no Globals.lagIndicator the raw input is returned.
        /// </summary>
        /// <param name="s"></param>
        /// <returns></returns>
        static TwoStrings getVariableAndLag(String s)
        {
            String var = "";
            String lag = "";
            int find = s.IndexOf(Globals.lagIndicator, 0);
            if (find != -1)
            {
                var = s.Substring(0, find);
                lag = s.Substring(find + 1);
            }
            else
            {
                var = s;
                lag = "0";
            }
            TwoStrings ts = new TwoStrings();
            ts.s1 = var;
            ts.s2 = lag;
            return ts;
        }


        public static TableLight ReadCsvPrn(ReadOpenMulbkHelper oRead, Databank databank, string file)
        {

            char delimiter = ';';

            if (!oRead.Merge)
            {
                databank.Clear();
            }

            string freqHere = G.GetFreq(Program.options.freq);

            string fullFileNameAndPath = CreateFullPathAndFileName(file);

            if (!File.Exists(fullFileNameAndPath))
            {
                if (oRead.Type == EDataFormat.Csv) G.Writeln2("*** ERROR: csv file does not exist");
                else if (oRead.Type == EDataFormat.Prn) G.Writeln2("*** ERROR: prn file does not exist");
                throw new GekkoException();
            }

            string input = GetTextFromFileWithWait(fullFileNameAndPath);
            List<string> lines = G.ExtractLinesFromText(input);

            TableLight matrix = new TableLight();  //1-based coords. Could perhaps design a more lightweight version of cells for this if memory or speed becomes an issue. Perhaps with basic cell stuff, and then a field pointing to object with alignment etc. Or use inheritance.

            if (oRead.Type == EDataFormat.Prn)
            {
                string orientation = null;
                List<string> lines2 = new List<string>();
                bool first = true;
                foreach (string s in lines)
                {
                    if (s.Trim() == "") continue;  //ignore empty lines
                    string[] split = s.Split(new char[] { ' ' }, StringSplitOptions.RemoveEmptyEntries);  //could be variable name with blank such as "ab cd" or something to trim like " abcd", but that is strange/wrong anyway!
                    string line2 = null;
                    foreach (string ss in split)
                    {
                        string ss2 = ss.Trim();  //probably superfluous
                        if (ss2.StartsWith("\""))
                        {
                            if (!ss2.EndsWith("\""))
                            {
                                G.Writeln2("*** ERROR: item '" + ss2 + "' seems malformed");
                                throw new GekkoException();
                            }
                            ss2 = ss2.Substring(1, ss2.Length - 2);
                            if (ss2.Contains("\""))
                            {
                                G.Writeln2("*** ERROR: item '\"" + ss2 + "\"' seems malformed");
                                throw new GekkoException();
                            }
                        }
                        string s3 = ss2;
                        first = false;
                        line2 += s3 + ";";
                    }
                    lines2.Add(line2);
                }
                lines = lines2;
            }

            int row = 0;
            foreach (string line in lines)
            {
                row++;
                string[] chunks = line.Split(delimiter);
                int col = 0;
                foreach (string s in chunks)
                {
                    col++;
                    CellLight cell = new CellLight(s);
                    if (s != "") matrix.Add(row, col, cell);  //no need to keep empty cells in matrix (there can be many such)
                }
            }

            return matrix;
        }

        private static void GetTimeseriesFromWorkbookMatrix(ReadDatesHelper dates, ReadOpenMulbkHelper oRead, Databank databank, TableLight matrix2, ReadInfo readInfo)
        {

            //TODO: gaps, READ<gap>

            //We could 'taste' the file, but how to distinguish A and U for instance?
            //Perhaps augment READ/IMPORT with freq indication for such files?
            EFreq freqHere = Program.options.freq;

            int rowOffset = 0;  //tested, not implemented in ANTLR yet.
            int colOffset = 0;
            string sheetName = null; //not implemented yet: takes first sheet it finds.

            bool transpose = ShouldTranspose(oRead, matrix2, rowOffset, colOffset);
            TableLight matrix = matrix2;
            if (transpose)
            {
                matrix = matrix2.Transpose();
            }

            GekkoTime per1 = Globals.tNull;
            GekkoTime per2 = Globals.tNull;

            int variableCounter = 0;
            string annualIndicator1 = "Y";
            string annualIndicator2 = "A1";

            string[] start = new string[2];
            string[] end = new string[2];

            int matrixMaxRow = matrix.GetRowMaxNumber();
            int matrixMaxCol = matrix.GetColMaxNumber();
            for (int row = 1 + rowOffset; row <= matrixMaxRow; row++)
            {
                TimeSeries ts = null;
                for (int col = 1 + colOffset; col <= matrixMaxCol; col++)
                {
                    if (row - rowOffset == 1 && col - colOffset == 1)
                    {
                        //--> this cell is just ignored now
                        continue;
                    }

                    CellLight cell = matrix.Get(row, col);

                    if (row - rowOffset == 1 && col - colOffset >= 2)
                    {
                        //---------------------
                        //DATES ROW
                        //---------------------
                        string cellText = null;
                        if (cell.type != ECellLightType.None)
                        {
                            if (cell.type == ECellLightType.String) cellText = cell.text;
                            else if (cell.type == ECellLightType.Double) cellText = cell.data.ToString();
                        }

                        if (cellText == null)
                        {
                            G.Writeln2("*** ERROR in cell " + GetExcelCell(row, col, transpose) + ".");
                            G.Writeln2("    This cell should contain a date and not be empty.", Color.Red);
                            throw new GekkoException();
                        }

                        if (col - colOffset == 2)
                        {
                            start[0] = cellText;
                            start[1] = GetExcelCell(row, col, transpose);
                        }

                        if (true)  //made for each date
                        {
                            end[0] = cellText;
                            end[1] = GetExcelCell(row, col, transpose);
                        }

                        string date = cellText;
                        date = date.Trim();  //removes blanks at start and end
                        date = date.ToLower();  //if q or m (or y)

                        if ((freqHere == EFreq.Annual))
                        {
                            if (date.EndsWith(annualIndicator1, true, null))
                            {
                                //remove 'Y' if it is there
                                date = date.Remove(date.Length - 1);
                            }
                            else if (date.EndsWith(annualIndicator2, true, null))
                            {
                                //remove 'A1' if it is there
                                date = date.Remove(date.Length - 2);
                            }
                        }

                        int per = -12345;
                        int subPer = -12345;

                        string perTemp = "";
                        string subPerTemp = "";
                        if ((freqHere == EFreq.Annual) || (freqHere == EFreq.Undated))  //ttfreq
                        {
                            perTemp = date;
                            subPerTemp = "1";
                        }
                        else
                        {
                            bool success = false;
                            string[] temp = date.Split(new string[] { G.GetFreq(freqHere) }, StringSplitOptions.None);
                            if (temp.Length != 2)
                            {
                                if (date.Length == 6 && G.IsInteger(date))
                                {
                                    //It might be a date like 199503, that is, 1995q3 or 1995m3
                                    perTemp = date.Substring(0, 4);
                                    subPerTemp = date.Substring(4, 2);
                                    success = true;
                                }
                            }
                            else
                            {
                                perTemp = temp[0];
                                subPerTemp = temp[1];
                                success = true;
                            }
                            if (!success)
                            {
                                G.Writeln2("*** ERROR: Cell " + GetExcelCell(row, col, transpose) + ". Could not find frequency data in this date: '" + date + "'");
                                G.Writeln("           You may want to change the frequency: OPTION freq = ...", Color.Red);
                                throw new GekkoException();
                            }
                        }

                        try
                        {
                            per = int.Parse(perTemp);
                            subPer = int.Parse(subPerTemp);
                        }
                        catch
                        {
                            G.Writeln2("*** ERROR: Cell " + GetExcelCell(row, col, transpose) + ". Could not understand this date: '" + date + "'");
                            G.Writeln("           You may want to change the frequency: OPTION freq = ...", Color.Red);
                            throw new GekkoException();
                        }

                        if (readInfo.startPerInFile == -12345) readInfo.startPerInFile = per;
                        if (readInfo.endPerInFile == -12345) readInfo.endPerInFile = per;
                        else
                        {
                            if (per > readInfo.endPerInFile) readInfo.endPerInFile = per;
                        }

                        GekkoTime gt = new GekkoTime((Program.options.freq), per, subPer);

                        if (col - colOffset == 2)
                        {
                            per1 = gt;
                        }
                        if (true)  //tested for each observation
                        {
                            per2 = gt;
                            int expectedPeriods = GekkoTime.Observations(per1, gt);
                            if (expectedPeriods != (col - (2 + colOffset) + 1))
                            {
                                G.Writeln2("*** ERROR: Expected to find " + expectedPeriods + " observations between the periods");
                                G.Writeln("           '" + start[0] + "' (cell " + start[1] + ")" + " and '" + end[0] + "' (cell " + end[1] + ").", Color.Red);
                                throw new GekkoException();
                            }
                        }
                    }
                    else if (row - rowOffset >= 2)  //data row
                    {
                        //---------------------
                        //DATA ROW
                        //---------------------
                        //First column
                        if (col - colOffset == 1)
                        {
                            //-----------------------
                            //VARIABLE NAME
                            //-----------------------

                            string cellText = null;
                            if (cell.type != ECellLightType.None)
                            {
                                if (cell.type == ECellLightType.String) cellText = cell.text;
                                else if (cell.type == ECellLightType.Double)
                                {
                                    G.Writeln2("*** ERROR in spreadsheet cell " + GetExcelCell(row, col, transpose) + ".");
                                    G.Writeln("    This cell is a value: expected a variable name.", Color.Red);
                                    throw new GekkoException();
                                }
                            }

                            if (cellText == null)
                            {
                                G.Writeln2("*** ERROR in spreadsheet cell " + GetExcelCell(row, col, transpose) + ".");
                                G.Writeln("    This cell should contain a variable name and not be empty.", Color.Red);
                                throw new GekkoException();
                            }

                            string varName = cellText.Trim();  //the name may contain blanks like 'elveff '
                            variableCounter++;
                            if (!databank.ContainsVariable(varName))
                            {
                                TimeSeries data2 = new TimeSeries(freqHere, varName);
                                databank.AddVariable(data2);
                                ts = data2;
                            }
                            else
                            {
                                ts = databank.GetVariable(varName);
                            }
                        }

                        else
                        {
                            //-----------------------
                            //NUMERIC DATA (rest of row)
                            //-----------------------
                            //Second column and on (data)
                            double ss = double.NaN;
                            bool shouldSkip = false;

                            if (cell.type != ECellLightType.None)
                            {
                                if (cell.type == ECellLightType.Double) ss = cell.data;
                                else if (cell.type == ECellLightType.String)
                                {
                                    if (IsNonAvailableText(cell.text))
                                    {
                                        ss = double.NaN;
                                    }
                                    else if (oRead.Type == EDataFormat.Csv || oRead.Type == EDataFormat.Prn)
                                    {
                                        string s3 = cell.text;
                                        if (G.equal(Program.options.interface_csv_decimalseparator, "comma"))
                                        {
                                            s3 = s3.Replace(",", ".");  //bit of a hack, will not handle 1.500,75   (--> 1500.75)
                                        }
                                        try
                                        {
                                            ss = double.Parse(s3, System.Globalization.CultureInfo.InvariantCulture);
                                        }
                                        catch
                                        {
                                            G.Writeln2("*** ERROR: Cell " + GetExcelCell(row, col, transpose) + ". Could not parse '" + s3 + "' as a number");
                                            G.Writeln("+++ NOTE:  You may change separator: OPTION interface csv decimalseparator");
                                            if(s3.Trim() == ".")
                                            {
                                                G.Writeln("+++ NOTE:  You cannot use dot ('.') to indicate missing value, use M or NA instead");
                                            }
                                            throw new GekkoException();
                                        }
                                    }
                                    else
                                    {
                                        //must be xls or xlsx, and not #n/a or the like
                                        G.Writeln2("*** ERROR in spreadsheet cell " + GetExcelCell(row, col, transpose) + ".");
                                        G.Writeln("    This cell is text: expected numeric value.", Color.Red);
                                        throw new GekkoException();
                                    }
                                }
                            }
                            else
                            {
                                shouldSkip = true;  //empty cell
                            }

                            if (!shouldSkip)
                            {
                                if (ss == 1e+15d)  //we use this as code for missing, as in AREMOS.
                                {
                                    ss = double.NaN;
                                }
                                GekkoTime gt2 = per1.Add((col - colOffset) - 2);  //col 2 is the start col for data   
                                bool good = true;
                                if (dates != null)
                                {
                                    good = false;
                                    if (gt2.freq == EFreq.Annual)
                                    {
                                        if (gt2.LargerThanOrEqual(dates.t1Annual) && gt2.SmallerThanOrEqual(dates.t2Annual)) good = true;
                                    }
                                    else if (gt2.freq == EFreq.Quarterly)
                                    {
                                        if (gt2.LargerThanOrEqual(dates.t1Quarterly) && gt2.SmallerThanOrEqual(dates.t2Quarterly)) good = true;
                                    }
                                    else if (gt2.freq == EFreq.Monthly)
                                    {
                                        if (gt2.LargerThanOrEqual(dates.t1Monthly) && gt2.SmallerThanOrEqual(dates.t2Monthly)) good = true;
                                    }
                                }

                                if (good == true)
                                {
                                    ts.SetData(gt2, ss);
                                }
                            }
                        }
                    }
                }
                if (ts != null) ts.Trim(); //to save ram, for the first row ts is = null
            }
            //See almost identical code in readTsd and readPcim and readTsp...
            readInfo.variables = variableCounter;
            if (oRead.Merge)
            {
                readInfo.startPerResultingBank = G.GekkoMin(readInfo.startPerInFile, databank.yearStart);
                readInfo.endPerResultingBank = G.GekkoMax(readInfo.endPerInFile, databank.yearEnd);
            }
            else
            {
                readInfo.startPerResultingBank = readInfo.startPerInFile;
                readInfo.endPerResultingBank = readInfo.endPerInFile;
            }
            Databank currentBank = Program.databanks.GetDatabank(databank.aliasName);
            currentBank.yearStart = readInfo.startPerResultingBank;
            currentBank.yearEnd = readInfo.endPerResultingBank;
        }

        private static bool IsNonAvailableText(string text)
        {
            //the last ones are the Danish codes
            //the M is Gekko standard for missing value, NA is also allowed, both also with "".
            bool isNonAvailableText = false;
            if (G.equal(text, "M") || G.equal(text, "\"M\"") || G.equal(text, "NA") || G.equal(text, "\"NA\"") || G.equal(text, "#N/A") || G.equal(text, "#NAME?") || G.equal(text, "#I/T") || G.equal(text, "#NAVN?")) isNonAvailableText = true;
            return isNonAvailableText;
        }

        private static bool ShouldTranspose(ReadOpenMulbkHelper oRead, TableLight matrix2, int rowOffset, int colOffset)
        {
            bool transpose = false;
            if (G.equal(oRead.Orientation, "cols")) transpose = true;  //we assume ROWS is default (logical for databanks with more series than observations)
            if (oRead.Type == EDataFormat.Prn)
            {
                CellLight cellA1 = matrix2.Get(1 + rowOffset, 1 + colOffset);
                if (cellA1.type == ECellLightType.None)
                {
                    G.Writeln2("*** ERROR: No data in position A1");
                    throw new GekkoException();
                }
                transpose = HandlePrnFirstElement(cellA1, rowOffset, colOffset, matrix2);
            }
            return transpose;
        }

        private static bool HandlePrnFirstElement(CellLight cell, int rowOffset, int colOffset, TableLight matrix)
        {
            bool transpose = false;
            if (cell.type != ECellLightType.String)
            {
                G.Writeln2("*** ERROR: Expected 'date' or 'name' as first element in prn file");
                throw new GekkoException();
            }
            if (G.equal(cell.text.Trim(), "date")) transpose = true; //corresponds to READ<csv cols>, timeseries are in columns.
            else if (G.equal(cell.text.Trim(), "name")) transpose = false; //corresponds to READ<csv>, timeseries are in rows.
            else
            {
                G.Writeln2("*** ERROR: Expected 'date' or 'name' as first element in prn file");
                throw new GekkoException();
            }

            return transpose;
        }

        private static string GetExcelCell(int row, int col, bool transpose)
        {
            string coord = null;
            if (!transpose)
            {
                coord = GetExcelColumnName(col) + row.ToString();
            }
            else
            {
                coord = GetExcelColumnName(row) + col.ToString();
            }
            return coord;
        }

        public static void readCsvOLDDELETE(Databank databank, string file, bool merge, ReadInfo readInfo)
        {
            if (!merge)
            {
                databank.Clear();
            }

            string freqHere = G.GetFreq(Program.options.freq);

            string fullFileNameAndPath = CreateFullPathAndFileName(file);

            bool trailingY = false;

            if (!File.Exists(fullFileNameAndPath))
            {
                G.Writeln2("*** ERROR: csv file does not exist");
                throw new GekkoException();
            }

            //should not contain æøå, so no need to use GetTextFromFile()
            using (FileStream fs = WaitForFileStream(fullFileNameAndPath, GekkoFileReadOrWrite.Read))
            using (StreamReader sr = new StreamReader(fs))
            {
                char delimiter = ';';
                char periodIndicator = 'Y';
                //This is an arbitrary size for this example.
                int max = 100000000; //100 MB
                char[] c = null;
                int counter = 0;
                int varCounter = -12345;
                while (sr.Peek() >= 0)
                {
                    counter++;
                    if (counter >= 2)
                    {
                        G.Writeln2("*** ERROR: File is > " + max / 1000000 + " MB");
                        throw new GekkoException();
                    }
                    c = new char[max];
                    int size = sr.Read(c, 0, c.Length);
                    int ii = 0;
                    int iiNewLine = 0;
                    for (int i = 0; i < 1; i++)
                    {
                        ii = skipSpaces(c, ii);
                        iiNewLine = skipPastNewLine(c, ii) - 2;  //new line is two characters \r\n
                        //read periods
                        int pcounter = 0;
                        bool endOfLineEncountered = false;
                        bool firstPeriod = true;
                        GekkoTime per1 = Globals.tNull;
                        GekkoTime per2 = Globals.tNull;
                        for (pcounter = 0; pcounter < int.MaxValue; pcounter++)
                        {
                            if (c[ii] != delimiter)
                            {
                                G.Writeln2("*** ERROR regarding CSV read, first character is not a '" + delimiter + "'");
                            }
                            int iiOld = ii;
                            ii = findChar(c, iiOld + 1, ';');
                            if (ii == -12345 || ii > iiNewLine)
                            {
                                ii = iiNewLine;
                                endOfLineEncountered = true;
                            }

                            String date = new String(c, iiOld + 1, ii - iiOld - 1);
                            date = date.Trim();  //removes blanks at start and end
                            date = date.ToLower();  //if q or m

                            if (date.EndsWith(periodIndicator.ToString(), true, null))
                            {
                                //remove 'Y' if it is there
                                date = date.Remove(date.Length - 1);
                                trailingY = true;
                            }

                            int per = -12345;
                            int subPer = -12345;

                            try
                            {

                                string perTemp = "";
                                string subPerTemp = "";
                                if (G.equal(freqHere, "a"))
                                {
                                    perTemp = date;
                                    subPerTemp = "1";
                                }
                                else
                                {
                                    string[] temp = date.Split(new string[] { freqHere }, StringSplitOptions.None);
                                    if (temp.Length != 2)
                                    {
                                        G.Writeln2("*** ERROR: Could not find freq '" + freqHere + "' in this date: '" + date + "'");
                                        G.Writeln("           You may want to change the frequency: OPTION freq = ...", Color.Red);
                                        throw new GekkoException();
                                    }
                                    perTemp = temp[0];
                                    subPerTemp = temp[1];
                                }

                                try
                                {
                                    per = int.Parse(perTemp);
                                    subPer = int.Parse(subPerTemp);
                                }
                                catch
                                {
                                    G.Writeln2("*** ERROR: Could not parse this date: '" + date + "'");
                                    G.Writeln("           You may want to change the frequency: OPTION freq = ...", Color.Red);
                                    throw new GekkoException();
                                }

                                GekkoTime gt = new GekkoTime((Program.options.freq), per, subPer);

                                if (firstPeriod)
                                {
                                    per1 = gt;
                                    firstPeriod = false;
                                }
                                if (endOfLineEncountered)
                                {
                                    per2 = gt;
                                }
                            }
                            catch (Exception e)
                            {
                                G.Writeln2("*** ERROR: unexpected error while reading csv file");
                                throw new GekkoException();
                            }
                            if (endOfLineEncountered == true) break;
                        }

                        G.Writeln("Csv data period = " + G.FromDateToString(per1) + " to " + G.FromDateToString(per2));
                        readInfo.startPerInFile = per1.super;
                        readInfo.endPerInFile = per2.super;

                        int expectedPeriodsPerLine = GekkoTime.Observations(per1, per2);

                        //reading the data part, first the variable name, and then the numbers

                        for (varCounter = 0; varCounter < int.MaxValue; varCounter++)
                        {
                            if (c[ii] == '\r' && c[ii + 1] == '\n')
                            {
                                if (size <= ii + 2) break;
                            }
                            //G.Writeln("---");
                            //double[] ts = null;
                            TimeSeries dataArray = null;
                            String varName = "";
                            endOfLineEncountered = false;
                            bool firstItem = true;
                            ii = skipSpaces(c, ii + 2) - 1;
                            iiNewLine = skipPastNewLine(c, ii) - 2;  //new line is two characters \r\n
                            for (int i5 = 0; i5 < int.MaxValue; i5++)
                            {

                                int iiOld = ii;
                                ii = findChar(c, iiOld + 1, size, ';');
                                if (ii == -12345 || ii > iiNewLine)
                                {
                                    ii = iiNewLine;
                                    endOfLineEncountered = true;
                                }

                                String s = new String(c, iiOld + 1, ii - iiOld - 1);
                                s = s.Trim();
                                if (firstItem)
                                {
                                    //var name
                                    varName = s;
                                    firstItem = false;

                                    //TimeSeries ts=findOrCreateTimeSeriesInDataBank(

                                    if (!databank.ContainsVariable(varName))
                                    {
                                        TimeSeries data2 = new TimeSeries(G.GetFreq(freqHere), varName);  //TODO, FIX
                                        databank.AddVariable(data2);
                                        dataArray = data2;
                                    }
                                    else
                                    {
                                        dataArray = databank.GetVariable(varName);
                                    }
                                }
                                else
                                {
                                    bool shouldSkip = false;
                                    //number
                                    double ss = double.NaN;
                                    if (s == "")
                                    {
                                        shouldSkip = true;
                                    }
                                    else if (s == "#N/A" || s == "#NAME?" || s == "#I/T" || s == "#NAVN?")  //the last ones are the Danish codes
                                    {
                                        ss = double.NaN;
                                    }
                                    else
                                    {
                                        string s3 = s;
                                        if (G.equal(Program.options.interface_csv_decimalseparator, "period"))
                                        {
                                            //do nothing
                                        }
                                        else if (G.equal(Program.options.interface_csv_decimalseparator, "comma"))
                                        {
                                            s3 = s.Replace(",", ".");  //bit of a hack, will not handle 1.500,75   (--> 1500.75)
                                        }
                                        try
                                        {
                                            ss = double.Parse(s3, System.Globalization.CultureInfo.InvariantCulture);
                                        }
                                        catch
                                        {
                                            G.Writeln2("*** ERROR: Could not parse " + s + " as a number");
                                            G.Writeln("+++ NOTE:  You may change separator: OPTION interface csv decimalseparator");
                                            throw new GekkoException();
                                        }
                                    }

                                    if (!shouldSkip)
                                    {
                                        if (ss == 1e+15d)  //we use this as code for missing, as in AREMOS.
                                        {
                                            ss = double.NaN;
                                        }
                                        GekkoTime gt2 = per1.Add(i5 - 1);
                                        dataArray.SetData(gt2, ss);
                                    }
                                }
                                if (endOfLineEncountered)
                                {
                                    //G.Writeln(i5);
                                    if (i5 != expectedPeriodsPerLine)
                                    {
                                        G.Writeln2("*** ERROR: expected " + expectedPeriodsPerLine + " numbers for '" + varName + "'");
                                    }
                                    break;
                                }
                            }
                        }
                    }
                }
                if (trailingY) G.Writeln("+++ NOTE: Trailing 'Y's were removed from dates (for instance '2010Y' becomes '2010')");
                c = null;
                sr.Close();
                readInfo.variables = varCounter;


                //See almost identical code in readTsd() several places
                if (merge)
                {
                    readInfo.startPerResultingBank = G.GekkoMin(readInfo.startPerInFile, databank.yearStart);
                    readInfo.endPerResultingBank = G.GekkoMax(readInfo.endPerInFile, databank.yearEnd);
                }
                else
                {
                    readInfo.startPerResultingBank = readInfo.startPerInFile;
                    readInfo.endPerResultingBank = readInfo.endPerInFile;
                }
                Databank currentBank = Program.databanks.GetDatabank(databank.aliasName);
                currentBank.yearStart = readInfo.startPerResultingBank;
                currentBank.yearEnd = readInfo.endPerResultingBank;

                return;
            }
        }

        public static void Index(string listName, string wildCard)
        {
            string bank = Program.databanks.GetFirst().aliasName;
            if (wildCard.StartsWith(Globals.Work.ToLower() + ":", StringComparison.OrdinalIgnoreCase))
            {
                bank = Globals.Work;
                wildCard = wildCard.Substring(Globals.Work.Length + 1);
                wildCard = wildCard.Trim();
            }
            if (wildCard.StartsWith(Globals.Ref.ToLower() + ":", StringComparison.OrdinalIgnoreCase))
            {
                bank = Globals.Ref;
                wildCard = wildCard.Substring(Globals.Ref.Length + 1);
                wildCard = wildCard.Trim();
            }

            Databank databank = Program.databanks.GetDatabank(bank);

            G.Writeln();

            if (databank.storage.Keys.Count == 0)
            {
                G.Writeln("+++ WARNING: the " + bank + " databank is empty -- did you forget to READ a databank?");
            }

            List<string> found = GetListFromWildcards(wildCard, databank);
            {
                if (found.Count == 0) G.Writeln("No series were found in " + bank + " databank matching '" + wildCard + "'");
                else
                {
                    G.Writeln(found.Count + " variables were found in " + bank + " databank matching '" + wildCard + "'");
                    found.Sort(StringComparer.InvariantCulture);
                    G.PrintListWithCommas(found, false);
                }
                if (listName != "")
                {
                    if (Program.scalars.ContainsKey(Globals.symbolList + listName)) Program.scalars.Remove(Globals.symbolList + listName);
                    Program.scalars.Add(Globals.symbolList + listName, new MetaList(found));
                    if (found.Count == 0) G.Writeln("+++ NOTE: The list #" + listName + " contains zero elements");
                    else G.Writeln("The list #" + listName + " contains the above list of variables");
                }
            }
        }

        private static List<string> GetListFromWildcards(string w, Databank databank)
        {
            Wildcard wildcard = new Wildcard(w, RegexOptions.IgnoreCase);
            List<string> found = new List<string>();
            string end = Globals.freqIndicator + Program.options.freq;  //.freq is always lower key
            foreach (string s in databank.storage.Keys)
            {
                if (s.StartsWith("_tmptmp")) continue;  //Hack: these are deleted after each command, but in for instance PRT command a _tmptmp var is created just before
                //Annoying slower code because the use of freqIndicator is not stringent.
                //Should be fixed so that annual is always %a.
                string s2 = s;
                if (!s.Contains(Globals.freqIndicator)) s2 = s2 + Globals.freqIndicator + "a";
                if (!s2.EndsWith(end)) continue;  //filter out variables with different frequency
                string s3 = s2.Replace(end, "");
                if (wildcard.IsMatch(s3))
                {
                    found.Add(s3);
                }
            }
            found.Sort(StringComparer.InvariantCulture);  //what about a and A?
            return found;
        }

        public static void OpenOrRead(bool wipeDatabankBeforeInsertingData, ReadOpenMulbkHelper oRead, bool open, List<ReadInfo> readInfos)
        {
            //open = true if called with OPEN command                      

            int n = 1;
            List<int> list = new List<int>();
            if (open)
            {
                CheckOpenSyntax(oRead);  //checks for * etc.
                n = oRead.openFileNames.Count;
                if (n > 1)
                {
                    if (oRead.openType == EOpenType.Edit)
                    {
                        G.Writeln2("*** ERROR: OPEN<edit> must be used with 1 databank");
                        throw new GekkoException();
                    }
                    else if (oRead.openType == EOpenType.Ref)
                    {
                        G.Writeln2("*** ERROR: OPEN<ref> must be used with 1 databank");
                        throw new GekkoException();
                    }
                }
                if ((G.equal(options.databank_logic, "aremos") && Program.databanks.ShouldPutBankLastAREMOS(oRead.openType, oRead.openTypePosition)) || (G.equal(options.databank_logic, "default") && Program.databanks.ShouldPutBankLast(oRead.openType, oRead.openTypePosition)))
                {
                    for (int i = 0; i < n; i++)
                    {
                        list.Add(i);
                    }
                }
                else
                {
                    for (int i = n - 1; i >= 0; i--)
                    {
                        list.Add(i);
                    }
                }
            }
            else
            {
                //READ or IMPORT has only 1 bank
                list.Add(1);
            }

            foreach (int i in list)
            {
                ReadInfo readInfo = new ReadInfo();

                string file = null;
                string as2 = null;
                if (open)
                {
                    file = StripQuotes(oRead.openFileNames[i][0]);
                    as2 = oRead.openFileNames[i][1];
                    if (as2 == "") as2 = null;
                }
                else
                {
                    file = StripQuotes(oRead.FileName);
                    as2 = oRead.As;
                }

                string originalFileName = file;
                bool isTsdx = false;
                bool isProtobuf = false;

                string extension = "tsd";
                if (true)
                {
                    isTsdx = true;
                    extension = "" + Globals.extensionDatabank + "";
                }
                if (oRead.Type == EDataFormat.Tsd)  //overrules any global settings
                {
                    isTsdx = false;
                    extension = "tsd";
                }
                if (oRead.Type == EDataFormat.Gbk)  //overrules any global settings
                {
                    isTsdx = true;
                    extension = "" + Globals.extensionDatabank + "";
                }
                if (oRead.Type == EDataFormat.Tsdx)  //overrules any global settings
                {
                    isTsdx = true;
                    extension = "tsdx";
                }
                if (oRead.Type == EDataFormat.Tsp)  //overrules any global settings
                {
                    isTsdx = false;
                    extension = "tsp";
                }
                if (oRead.Type == EDataFormat.Csv)
                {
                    extension = "csv";
                    isTsdx = false;
                }
                if (oRead.Type == EDataFormat.Prn)
                {
                    extension = "prn";
                    isTsdx = false;
                }
                if (oRead.Type == EDataFormat.Xls)
                {
                    extension = "xls";
                    isTsdx = false;
                }
                if (oRead.Type == EDataFormat.Xlsx)
                {
                    extension = "xlsx";
                    isTsdx = false;
                }
                if (oRead.Type == EDataFormat.Pcim)
                {
                    extension = "bnk";
                    isTsdx = false;
                }
                if (oRead.Type == EDataFormat.Gdx)
                {
                    extension = "gdx";
                    isTsdx = false;
                }
                if (oRead.Type == EDataFormat.Px)
                {
                    extension = "px";
                    isTsdx = false;
                }

                bool cancel = false;
                bool createNewOpenFile = false;
                ReadHelper(ref file, ref cancel, ref createNewOpenFile, extension, oRead.openType == EOpenType.Ref, open);
                if (cancel)
                {
                    readInfo.abortedStar = true;
                    return;  //from READ * cancelling
                }

                if (open && createNewOpenFile && oRead.protect)
                {
                    G.Writeln2("*** ERROR: OPEN: The databank '" + file + "' could not be found");
                    throw new GekkoException();
                }

                //At this point, we know that the file to be opened/read actually exists (or createOpenFile is true)

                readInfo.dbName = Path.GetFileNameWithoutExtension(file);  //may be overridden later on (Work for READ, and Base for MULBK)
                if (as2 != null && as2 == "*") as2 = readInfo.dbName;    //With READ * TO *, as2 will be '*'. In that case, we use the filename. This will only happen regarding READ, we do not have an OPEN * AS * (would not be useful, OPEN * would do exactly the same)
                if (as2 != null) readInfo.dbName = as2;

                DateTime dt1 = DateTime.Now;

                bool isReadFromFile = true; //always true for READ/MULBK

                Databank databank = new Databank(readInfo.dbName);  //beware: this is later on pointed to a new object if tsdx-protobuffers are used! (or if the bank already exists in OPEN command)
                if (open)
                {
                    //if new databank (read from disk), the newly created 'databank' is put into the right slot (and other databanks are moved around)
                    //if existing databank, isReadFromFile = false, 'databank' will point to the found databank (that may be moved, for instance with OPEN<first> of existing bank)
                    isReadFromFile = Program.databanks.OpenDatabank(ref databank, oRead.openType, oRead.openTypePosition); //puts it in storage[2], returns bool that says if it is just moved around in databank list, or freshly read from file
                    if (createNewOpenFile) readInfo.type = EReadInfoTypes.OpenedNewNonExistingFile;
                    else if (!isReadFromFile) readInfo.type = EReadInfoTypes.OpenedFirstOrRefAlreadyOpenBank;
                }
                else
                {
                    //READ or READ<first>
                    databank = Program.databanks.GetFirst();
                    if (oRead.openType == EOpenType.Ref) databank = Program.databanks.GetRef();
                    readInfo.type = EReadInfoTypes.Normal;
                }

                readInfo.databank = databank;

                string originalFilePath = file;

                string tsdxFile = null;
                string tempTsdxPath = null;

                int NaNCounter = 0;

                bool copyLocal = Program.options.databank_file_copylocal;

                readInfo.fileName = file;

                if (readInfo.type != EReadInfoTypes.Normal)
                {
                    //When creating a new file with "OPEN xyz" (where xyz does not exist), or
                    //  "OPEN<edit>abc" where abc is already open, nothing should be read from file.
                    readInfo.databank = databank;
                    readInfo.databank.FileNameWithPath = readInfo.fileName;
                    readInfos.Add(readInfo);
                }
                else
                {
                    if (copyLocal)
                    {
                        DateTime t0 = DateTime.Now;
                        string tempPath = GetTempTsdFilePath(extension);
                        WaitForFileCopy(file, tempPath);
                        G.WritelnGray("Local copying: " + G.SecondsFormat((DateTime.Now - t0).TotalMilliseconds));
                        file = tempPath;
                    }

                    ReadDatesHelper dates = GetReadDatesHelper(oRead);

                    if (wipeDatabankBeforeInsertingData) databank.Clear();  //Reading gbk may point to a whole new databank, this is ok. Wipe will only be for READ, no READ<merge> or READ ... TO ... . IMPORT is never wiped.

                    if (oRead.Type == EDataFormat.Pcim)
                    {
                        Program.ReadPCIM(databank, dates, oRead, oRead.FileName, open, as2, oRead.openType == EOpenType.Ref, oRead.Merge, readInfo, file);
                    }
                    else if (oRead.Type == EDataFormat.Csv || oRead.Type == EDataFormat.Prn || oRead.Type == EDataFormat.Xls || oRead.Type == EDataFormat.Xlsx)
                    {
                        ReadSheet(dates, oRead, readInfo, file, databank, originalFilePath);
                    }
                    else if (oRead.Type == EDataFormat.Tsd || oRead.Type == EDataFormat.Tsdx || oRead.Type == EDataFormat.Gbk || oRead.Type == EDataFormat.None)
                    {
                        ReadTsdOrTsdx(dates, oRead, readInfo, ref file, isTsdx, ref isProtobuf, ref databank, originalFilePath, ref tsdxFile, ref tempTsdxPath, ref NaNCounter);
                    }
                    else if (oRead.Type == EDataFormat.Tsp)
                    {
                        if (dates != null)
                        {
                            G.Writeln2("*** ERROR: You cannot use period truncation in TSP data import");
                            throw new GekkoException();
                        }
                        TspUtilities.tspDataUtility(file, databank, oRead, readInfo, open);
                    }
                    else if (oRead.Type == EDataFormat.Gdx)
                    {
                        if (dates != null)
                        {
                            G.Writeln2("*** ERROR: You cannot use period truncation in GDX data import");
                            throw new GekkoException();
                        }
                        Program.ReadGdx(databank, dates, oRead, oRead.FileName, open, as2, oRead.openType == EOpenType.Ref, oRead.Merge, readInfo, file);
                    }
                    else if (oRead.Type == EDataFormat.Px)
                    {
                        Program.ReadPxHelper(databank, dates, oRead, oRead.FileName, open, as2, oRead.openType == EOpenType.Ref, oRead.Merge, readInfo, file);
                    }
                    else
                    {
                        G.Writeln2("*** ERROR #78632432");
                        throw new GekkoException();
                    }

                    HandleCleanAndParentForTimeseries(databank, oRead.Merge);  //otherwise it will look dirty
                    if (open && oRead.protect) databank.protect = true;

                    if (Program.options.solve_data_create_auto == true)
                    {
                        if (!open && (oRead.openType == EOpenType.First || oRead.openType == EOpenType.Normal))
                        {
                            IVariable all2 = null; Program.scalars.TryGetValue(Globals.symbolList + "all", out all2);
                            if (all2 == null) all2 = new MetaList(new List<string>());
                            List<string> all = O.GetMetaList(all2).list;
                            readInfo.createdVars = Program.CreateVariables(all, false);
                        }
                    }

                    //Cleanup of local files
                    if (copyLocal)
                    {
                        if (!isProtobuf)
                        {
                            try
                            {
                                File.SetAttributes(file, FileAttributes.Normal);  //it may be read-only if original file is so
                                File.Delete(file);  //hmm probably best not to use WaitForFileDelete() here, since it seems it is ok if delete fails here
                            }
                            catch (Exception e)
                            {
                                //do nothing
                            }
                        }

                        if (isTsdx)
                        {
                            try
                            {
                                File.SetAttributes(tsdxFile, FileAttributes.Normal);  //it may be read-only if original file is so
                                File.Delete(tsdxFile);  //hmm probably best not to use WaitForFileDelete() here, since it seems it is ok if delete fails here
                            }
                            catch (Exception e)
                            {
                                //do nothing
                            }

                            try
                            {
                                DirectoryInfo folderInfo = new DirectoryInfo(tempTsdxPath);
                                if (System.IO.Directory.Exists(folderInfo.FullName))
                                {
                                    System.IO.Directory.Delete(folderInfo.FullName, true);
                                }
                            }
                            catch (Exception e)
                            {
                                //do nothing
                            }
                        }
                    }

                    readInfo.time = (DateTime.Now - dt1).TotalMilliseconds;

                    if (isTsdx && !isProtobuf)
                    {
                        readInfo.conversionMessage = true;
                    }

                    readInfo.databank.info1 = readInfo.info1;
                    readInfo.databank.date = readInfo.date;
                    readInfo.databank.FileNameWithPath = readInfo.fileName;

                    if (open && !isTsdx && !oRead.protect)
                    {
                        if (readInfo.databank.protect != true)
                        {
                            G.Writeln2("The file is opened as non-editable, since it is not a ." + Globals.extensionDatabank + " file");
                            readInfo.databank.protect = true;
                        }
                    }
                    readInfos.Add(readInfo);
                }
                //databank.Trim();  //This way, the bank is not too bulky in RAM. The operation takes almost no time, and if it is a .tsdx file, the timeseries are already trimmed and trimming is hence skipped.
                databank.readInfo = readInfo;  //Not really used at the moment, but practical to have a pointer to this information!                

                if (Globals.testFileChange)
                {
                    if (open)
                    {
                        if (createNewOpenFile) databank.fileHash = Globals.brandNewFile; //signifies that the bank is brand new
                        else databank.fileHash = Program.GetMD5Hash(GetTextFromFileWithWait(databank.FileNameWithPath));  //MD5 hash of file                
                    }
                }
            }  //for each bank in list

            return;
        }

        private static ReadDatesHelper GetReadDatesHelper(ReadOpenMulbkHelper oRead)
        {
            if (oRead.t1.IsNull()) return null;
            ReadDatesHelper readDatesHelper = new Gekko.ReadDatesHelper();
            if (oRead.t1.freq != oRead.t2.freq)
            {
                G.Writeln2("*** ERROR: The two date frequencies do not match");
                throw new GekkoException();
            }

            if (oRead.t1.freq == EFreq.Undated)
            {
                G.Writeln2("*** ERROR: Undated frequency does not work for READ/IMPORT");
                throw new GekkoException();
            }

            if (GekkoTime.Observations(oRead.t1, oRead.t2) < 1)
            {
                G.Writeln2("*** ERROR: Start period must be <= end period");
                throw new GekkoException();
            }

            if (oRead.t1.freq == EFreq.Annual)
            {
                readDatesHelper.t1Annual = oRead.t1;
                readDatesHelper.t2Annual = oRead.t2;
                readDatesHelper.t1Quarterly = new GekkoTime(EFreq.Quarterly, oRead.t1.super, 1);  //first q
                readDatesHelper.t2Quarterly = new GekkoTime(EFreq.Quarterly, oRead.t2.super, GekkoTimeStuff.numberOfQuarters);  //last q
                readDatesHelper.t1Monthly = new GekkoTime(EFreq.Monthly, oRead.t1.super, 1);  //first m
                readDatesHelper.t2Monthly = new GekkoTime(EFreq.Monthly, oRead.t2.super, GekkoTimeStuff.numberOfMonths);  //last m
            }
            else if (oRead.t1.freq == EFreq.Quarterly)
            {
                readDatesHelper.t1Annual = new GekkoTime(EFreq.Annual, oRead.t1.super, 1);
                readDatesHelper.t2Annual = new GekkoTime(EFreq.Annual, oRead.t2.super, 1);
                readDatesHelper.t1Quarterly = oRead.t1;
                readDatesHelper.t2Quarterly = oRead.t2;
                readDatesHelper.t1Monthly = new GekkoTime(EFreq.Monthly, oRead.t1.super, GekkoTime.FromQuarterToMonthStart(oRead.t1.sub));  //first m
                readDatesHelper.t2Monthly = new GekkoTime(EFreq.Monthly, oRead.t2.super, GekkoTime.FromQuarterToMonthEnd(oRead.t2.sub));  //last m                            
            }
            else if (oRead.t1.freq == EFreq.Monthly)
            {
                readDatesHelper.t1Annual = new GekkoTime(EFreq.Annual, oRead.t1.super, 1);
                readDatesHelper.t2Annual = new GekkoTime(EFreq.Annual, oRead.t2.super, 1);
                readDatesHelper.t1Quarterly = new GekkoTime(EFreq.Quarterly, oRead.t1.super, GekkoTime.FromMonthToQuarter(oRead.t1.sub));
                readDatesHelper.t2Quarterly = new GekkoTime(EFreq.Quarterly, oRead.t2.super, GekkoTime.FromMonthToQuarter(oRead.t2.sub));
                readDatesHelper.t1Monthly = oRead.t1;
                readDatesHelper.t2Monthly = oRead.t2;
            }

            return readDatesHelper;
        }

        private static void CheckOpenSyntax(ReadOpenMulbkHelper oRead)
        {
            int counter = 0;
            foreach (List<string> ss in oRead.openFileNames)
            {
                if (ss[0] == "*") counter++;
            }
            if (counter >= 1)
            {
                //there is at least one *
                if (counter == 1 && oRead.openFileNames.Count == 1)
                {
                    //ok
                }
                else
                {
                    G.Writeln2("*** ERROR: The '*' cannot be used in a list of filenames");
                    throw new GekkoException();
                }
            }

            if (counter >= 1 && oRead.openFileNames.Count > 1)
            {
                if (oRead.openFileNames[0][0] != "*")
                {

                }
            }
            else if (counter > 1)
            {
                G.Writeln2("*** ERROR: The '*' filename should not be stated in a list of files to open");
                throw new GekkoException();
            }
        }

        public static bool IsDatabankDirty(Databank removed)
        {
            bool isDirty = false;
            if (removed.isDirty) isDirty = true;
            else
            {
                foreach (TimeSeries ts in removed.storage.Values)  
                {
                    if (ts.IsDirty())
                    {
                        isDirty = true;
                        break;
                    }
                }
            }
            return isDirty;
        }

        public static void HandleCleanAndParentForTimeseries(Databank db, bool merge)
        {
            db.isDirty = false;
            foreach (TimeSeries ts in db.storage.Values) 
            {
                if (!merge) ts.SetDirty(false);  //if we are not merging, the bank is comletely new, and the timeseries are all considered clean. When merging, dirt is all over.
                ts.parentDatabank = db;                
            }
        }

        private static void ReadSheet(ReadDatesHelper dates, ReadOpenMulbkHelper oRead, ReadInfo readInfo, string file, Databank databank, string originalFilePath)
        {
            //TODO:
            //For speedup:
            //Use simpler Dictionary<long,helper>, where long is row + 2^32*col, and counting maxrow and
            //maxcol. Optionally inputkeys and maxrow/col can be transposed. Helper is a struct with
            //string+double fields. If string==null and double.NaN, the values is simply not put in.
            //if string==null, it is assumed to be a double field.

            //DateTime t000 = DateTime.Now;
            readInfo.fileName = originalFilePath;
            TableLight matrix = null;
            string prnType = null;
            if (oRead.Type == EDataFormat.Csv || oRead.Type == EDataFormat.Prn)
            {
                matrix = ReadCsvPrn(oRead, databank, file);
            }
            else
            {
                matrix = ReadExcelWorkbook(file, databank, null);
            }
            GetTimeseriesFromWorkbookMatrix(dates, oRead, databank, matrix, readInfo);
        }

        public static int ExcelColumnNameToNumber(string columnName)
        {
            if (string.IsNullOrEmpty(columnName)) throw new GekkoException();
            columnName = columnName.ToUpperInvariant();
            int sum = 0;
            for (int i = 0; i < columnName.Length; i++)
            {
                sum *= 26;
                sum += (columnName[i] - 'A' + 1);
            }
            return sum;
        }

        public static string ExcelColumnNumberToName(int columnNumber)
        {
            int dividend = columnNumber;
            string columnName = String.Empty;
            int modulo;
            while (dividend > 0)
            {
                modulo = (dividend - 1) % 26;
                columnName = Convert.ToChar(65 + modulo).ToString() + columnName;
                dividend = (int)((dividend - modulo) / 26);
            }
            return columnName;
        }

        public static void SheetImport(O.SheetImport o)
        {
            string matrixName = null;
            if (G.equal(o.opt_matrix, "yes"))
            {
                if(o.listItems.Count==0 || o.listItems.Count > 1)
                {
                    G.Writeln2("*** ERROR: For SHEET<import matrix>, only 1 matrix name must be provided");
                    throw new GekkoException();
                }
                matrixName = o.listItems[0];
            }

            bool isMissing = false;
            if(G.equal(o.opt_missing,"yes"))
            {
                isMissing = true;
            }                       

            //do copylocal
            string fileName = o.fileName;
            fileName = AddExtension(fileName, ".xlsx");
            fileName = Program.CreateFullPathAndFileNameFromFolder(fileName, null);
            TableLight matrix = ReadExcelWorkbook(fileName, Program.databanks.GetFirst(), o.opt_sheet);

            bool transpose = false;  //corresponding to row-wise reading
            if (G.equal(o.opt_cols, "yes"))
            {
                transpose = true;
                if (matrixName != null) G.Writeln2("+++ NOTE: Because of <rows> option, the matrix #" + matrixName + " is transposed");
            }

            if(transpose)
            {
                //reading downwards by cols
                matrix = matrix.Transpose();
            }

            int obs = GekkoTime.Observations(o.t1, o.t2);
            int n = o.listItems.Count;

            string s = "a1";
            if (o.opt_cell != null) s = o.opt_cell;
            int index = s.IndexOfAny(new char[] { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9' });
            string chars = s.Substring(0, index);
            int num = Int32.Parse(s.Substring(index));
            int rowOffset = num - 1;
            int colOffset = ExcelColumnNameToNumber(chars) - 1;

            if (transpose)
            {
                //switch them
                int temp = rowOffset;
                rowOffset = colOffset;
                colOffset = temp;
            }

            //check between 1... large number

            if (matrixName == null)
            {
                for (int row = 1 + rowOffset; row < 1 + rowOffset + n; row++)
                {
                    TimeSeries ts = Program.GetTimeSeriesFromString(o.listItems[row - 1 - rowOffset], O.ECreatePossibilities.Must); //O
                    for (int col = 1 + colOffset; col < 1 + colOffset + obs; col++)
                    {
                        double v = double.NaN;
                        CellLight cell = matrix.Get(row, col);
                        if (cell.type == ECellLightType.None) continue;
                        v = GetValueFromSpreadsheetCell(transpose, row, col, v, cell);
                        ts.SetData(o.t1.Add(col - 1 - colOffset), v);
                    }
                }
            }
            else
            {

                Matrix mm = null;

                int rr = matrix.GetRowMaxNumber() - rowOffset;
                int cc = matrix.GetColMaxNumber() - colOffset;

                if (rr <= 0 || cc <= 0)
                {
                    G.Writeln2("*** ERROR: Matrix has no data");
                    throw new GekkoException();
                }

                if (isMissing) mm = new Matrix(rr, cc, double.NaN);
                else mm = new Matrix(rr, cc);
                
                for (int row = 1 + rowOffset; row < 1 + rowOffset + matrix.GetRowMaxNumber(); row++)
                {                    
                    for (int col = 1 + colOffset; col < 1 + colOffset + matrix.GetColMaxNumber(); col++)
                    {
                        double v = double.NaN;
                        CellLight cell = matrix.Get(row, col);
                        if (cell.type == ECellLightType.None) continue;
                        v = GetValueFromSpreadsheetCell(transpose, row, col, v, cell);
                        mm.data[row - 1 - rowOffset, col - 1 - colOffset] = v;                        
                    }
                }
                if (Program.scalars.ContainsKey(Globals.symbolList + matrixName))
                {
                    Program.scalars.Remove(Globals.symbolList + matrixName);
                }                                
                Program.scalars.Add(Globals.symbolList + matrixName, mm);
                G.Writeln2("Matrix #" + matrixName + " imported (" + rr + "x" + cc + ")");
            }
        }

        private static double GetValueFromSpreadsheetCell(bool transpose, int row, int col, double v, CellLight cell)
        {
            if (cell.type == ECellLightType.String)
            {
                if (IsNonAvailableText(cell.text))
                {
                    //keep NaN
                }
                else
                {
                    G.Writeln2("*** ERROR in spreadsheet cell " + GetExcelCell(row, col, transpose) + ", content: '" + cell.text + "'");
                    throw new GekkoException();
                }
            }
            else if (cell.type == ECellLightType.Double)
            {
                v = cell.data;
            }
            else throw new GekkoException();
            return v;
        }

        private static void ReadTsdOrTsdx(ReadDatesHelper dates, ReadOpenMulbkHelper oRead, ReadInfo readInfo, ref string file, bool isTsdx, ref bool isProtobuf, ref Databank databank, string originalFilePath, ref string tsdxFile, ref string tempTsdxPath, ref int NaNCounter)
        {
            bool mergeOrTimeLimit = oRead.Merge || dates != null;

            if (isTsdx)
            {
                readInfo.databankVersion = "";
                //try to unzip it here
                tempTsdxPath = GetTempTsdxFolderPath();
                if (!Directory.Exists(tempTsdxPath))  //should almost never exist, since name is random
                {
                    Directory.CreateDirectory(tempTsdxPath);
                }
                else
                {
                    //in the very rare case, any files here will be overwritten
                }
                string unzippedFile = Path.GetFileNameWithoutExtension(originalFilePath) + ".tsd";

                DateTime dt2 = DateTime.Now;
                string foundTsdFile = WaitForZipRead_TSDX(tempTsdxPath, file, unzippedFile, originalFilePath);
                G.WritelnGray("Unzipping took: " + G.Seconds(dt2));

                if (foundTsdFile == "Is_a_protobuffer_file") isProtobuf = true;

                //both protobuffers and tsd files

                tsdxFile = file;
                //file = tempTsdxPath + "\\" + unzippedFile;
                file = tempTsdxPath + "\\" + foundTsdFile;

                XmlDocument doc = new XmlDocument();
                //We can presume that DatabankInfo.xml is in UTF-8, since it is typically written by Gekko
                //So no need to use GetTextFromFile()
                string fileXml = tempTsdxPath + "\\" + "DatabankInfo.xml";
                using (FileStream fs = WaitForFileStream(fileXml, GekkoFileReadOrWrite.Read))
                {
                    try
                    {
                        doc.Load(fs);
                    }
                    catch (Exception e)
                    {
                        G.Writeln2("*** ERROR: XML file 'DatabankInfo.xml' inside " + Globals.extensionDatabank + " file.");
                        WriteXmlError(e, fileXml);
                        throw new GekkoException();
                    }

                    XmlElement root = doc.DocumentElement; //"DatabankInfo"

                    string databankVersion = root.GetAttribute("databankVersion");
                    if (databankVersion == "") databankVersion = "1.0";
                    string gekkoVersion = root.GetAttribute("gekkoVersion");
                    if (databankVersion != "") readInfo.databankVersion = "(vers: " + databankVersion + ")";

                    if (!Globals.tsdxVersions.Contains(databankVersion))
                    {
                        G.Writeln2("*** ERROR: The databank version is unknown to this Gekko version (" + Globals.gekkoVersion + ")");
                        G.Write("           Known databank versions: "); G.PrintListWithCommas(Globals.tsdxVersions, false);
                        G.Writeln("           The databank seems to have been written by Gekko version " + gekkoVersion);
                        throw new GekkoException();
                    }

                    XmlNodeList descriptions = doc.GetElementsByTagName("Info1");
                    foreach (XmlNode description in descriptions)  //should be only 1 in this loop
                    {
                        readInfo.info1 = description.InnerText;
                    }

                    XmlNodeList dates5 = doc.GetElementsByTagName("Date");
                    foreach (XmlNode date in dates5) //should be only 1 in this loop
                    {
                        readInfo.date = date.InnerText;
                    }

                    XmlNodeList modelNames = doc.GetElementsByTagName("ModelName");
                    foreach (XmlNode modelName in modelNames) //should be only 1 in this loop
                    {
                        readInfo.modelName = modelName.InnerText;
                    }

                    XmlNodeList modelInfos = doc.GetElementsByTagName("ModelInfo");
                    foreach (XmlNode modelInfo in modelInfos) //should be only 1 in this loop
                    {
                        readInfo.modelInfo = modelInfo.InnerText;
                    }

                    XmlNodeList modelDates = doc.GetElementsByTagName("ModelDate");
                    foreach (XmlNode modelDate in modelDates) //should be only 1 in this loop
                    {
                        readInfo.modelDate = modelDate.InnerText;
                    }

                    XmlNodeList modelSignatures = doc.GetElementsByTagName("ModelSignature");
                    foreach (XmlNode modelSignature in modelSignatures) //should be only 1 in this loop
                    {
                        readInfo.modelSignature = modelSignature.InnerText;
                    }

                    XmlNodeList modelHashs = doc.GetElementsByTagName("ModelHash");
                    foreach (XmlNode modelHash in modelHashs) //should be only 1 in this loop
                    {
                        readInfo.modelHash = modelHash.InnerText;
                    }

                    XmlNodeList modelLastSimPeriods = doc.GetElementsByTagName("ModelLastSimPeriod");
                    foreach (XmlNode modelLastSimPeriod in modelLastSimPeriods) //should be only 1 in this loop
                    {
                        readInfo.modelLastSimPeriod = modelLastSimPeriod.InnerText;
                    }

                    XmlNodeList modelLastSimStamps = doc.GetElementsByTagName("ModelLastSimStamp");
                    foreach (XmlNode modelLastSimStamp in modelLastSimStamps) //should be only 1 in this loop
                    {
                        readInfo.modelLastSimStamp = modelLastSimStamp.InnerText;
                    }

                    XmlNodeList modelLargestLags = doc.GetElementsByTagName("ModelLargestLag");
                    foreach (XmlNode modelLargestLag in modelLargestLags) //should be only 1 in this loop
                    {
                        readInfo.modelLargestLag = modelLargestLag.InnerText;
                    }

                    XmlNodeList modelLargestLeads = doc.GetElementsByTagName("ModelLargestLead");
                    foreach (XmlNode modelLargestLead in modelLargestLeads) //should be only 1 in this loop
                    {
                        readInfo.modelLargestLead = modelLargestLead.InnerText;
                    }
                }
                if (!isProtobuf) readInfo.databankVersion = "(vers: 1.0)";  //default value if databankVersion attribute is not found inside DatabankInfo.xml
            }

            readInfo.fileName = originalFilePath;

            if (isTsdx && isProtobuf)
            {
                string name = null;
                if (File.Exists(tempTsdxPath + "\\" + Globals.protobufFileName)) name = tempTsdxPath + "\\" + Globals.protobufFileName;  //legacy
                else if (File.Exists(tempTsdxPath + "\\" + Globals.protobufFileName2)) name = tempTsdxPath + "\\" + Globals.protobufFileName2;  //usual name
                else if (File.Exists(tempTsdxPath + "\\" + Program.options.databank_file_gbk_internal)) name = tempTsdxPath + "\\" + Program.options.databank_file_gbk_internal;  //IF the usual name is changed
                else
                {
                    G.Writeln2("*** ERROR: Could not find data storage file inside zipped databank file");
                    G.Writeln("           Troubleshooting, try this page: " + Globals.databankformatUrl, Color.Red);
                    throw new GekkoException();
                }

                using (FileStream fs = WaitForFileStream(name, GekkoFileReadOrWrite.Read))
                {

                    Databank temp = null;
                    ////May take a little time to create: so use static serializer if doing serialize on a lot of small objects
                    //RuntimeTypeModel serializer = TypeModel.Create();
                    //serializer.UseImplicitZeroDefaults = false;  //otherwise an int that has default constructor value -12345 but is set to 0 will reappear as a -12345 (instead of 0). For int, 0 is default, false for bools etc.
                    try
                    {
                        DateTime dt3 = DateTime.Now;
                        temp = Serializer.Deserialize<Databank>(fs);
                        readInfo.variables = temp.storage.Count;  
                        G.WritelnGray("Protobuf deserialize took: " + G.Seconds(dt3));
                    }
                    catch (Exception e)
                    {
                        G.Writeln2("*** ERROR: Unexpected technical error when reading " + Globals.extensionDatabank + " databank in version 1.1 format (protobuffers)");
                        G.Writeln("           Message: " + e.Message, Color.Red);
                        G.Writeln("           Troubleshooting, try this page: " + Globals.databankformatUrl, Color.Red);
                        throw new GekkoException();
                    }

                    int maxYearInProtobufFile = int.MinValue;
                    int minYearInProtobufFile = int.MaxValue;
                    int emptyWarnings = 0;
                    foreach (TimeSeries tsTemp in temp.storage.Values)  //for each timeseries in temp (deserialized) databank 
                    {
                        bool isGhost = tsTemp.IsGhost();
                        //looping through each timeseries to find databank start and end year (and to merge variables if we are merging)

                        if (IsNonsenseVariableName(tsTemp.variableName))
                        {
                            emptyWarnings++;
                            continue;
                        }

                        int counter = 0;
                        GekkoTime first = Globals.tNull;
                        GekkoTime last = Globals.tNull;

                        if (!tsTemp.IsTimeless())
                        {
                            first = tsTemp.GetPeriodFirst();
                            last = tsTemp.GetPeriodLast();
                        }                                                

                        if (mergeOrTimeLimit)  //doing tsdx-protobuf merge (or time limits), get data into Work from deserialized temp databank
                        {
                            if (dates != null)
                            {
                                GetFirstLastDates(dates, ref first, ref last);
                            }

                            int nob = GekkoTime.Observations(first, last);
                            if (nob > 0)
                            {
                                //ignore if nob < 1. This means that the time limit window is outside the data window 
                                TimeSeries ts = FindOrCreateTimeSeriesInDataBank(databank, tsTemp.variableName, tsTemp.freqEnum);
                                int index1;
                                int index2;
                                try
                                {
                                    double[] data = tsTemp.GetDataSequence(out index1, out index2, first, last, true);
                                    ts.SetDataSequence(first, last, data, index1);
                                }
                                catch (Exception e)
                                {
                                    G.Writeln2("*** ERROR: Unexpected technical error while merging databanks");
                                    throw new GekkoException();
                                }

                                GekkoTime firstX = ts.GetPeriodFirst();
                                GekkoTime lastX = ts.GetPeriodLast();

                                if (!isGhost)
                                {
                                    maxYearInProtobufFile = G.GekkoMax(maxYearInProtobufFile, lastX.super);
                                    minYearInProtobufFile = G.GekkoMin(minYearInProtobufFile, firstX.super);
                                }
                            }
                        }
                        else
                        {
                            if (!isGhost)
                            {
                                maxYearInProtobufFile = G.GekkoMax(maxYearInProtobufFile, last.super);
                                minYearInProtobufFile = G.GekkoMin(minYearInProtobufFile, first.super);
                            }
                        }
                    }
                    if (emptyWarnings > 0) G.Writeln("+++ WARNING: " + emptyWarnings + " variables with empty string as name in ." + Globals.extensionDatabank + " file (skipped)");

                    if (!mergeOrTimeLimit)
                    {
                        try
                        {
                            //discarding the old bank completely, and replacing with the new one
                            temp.aliasName = databank.aliasName;
                            Program.databanks.ReplaceDatabank(databank, temp);
                            readInfo.databank = temp;  //since this pointer is altered
                            databank = temp;  //since this pointer is altered
                        }
                        catch (Exception e)
                        {
                            G.Writeln2("*** ERROR: Unexpected technical error while reading " + Globals.extensionDatabank + " databank");
                            throw new GekkoException();
                        }
                    }

                    //See almost identical code below, and in readCsv()
                    if (mergeOrTimeLimit)
                    {
                        readInfo.startPerInFile = minYearInProtobufFile;
                        readInfo.endPerInFile = maxYearInProtobufFile;
                        readInfo.startPerResultingBank = G.GekkoMin(minYearInProtobufFile, databank.yearStart);
                        readInfo.endPerResultingBank = G.GekkoMax(maxYearInProtobufFile, databank.yearEnd);
                    }
                    else
                    {
                        readInfo.startPerInFile = minYearInProtobufFile;
                        readInfo.endPerInFile = maxYearInProtobufFile;
                        readInfo.startPerResultingBank = readInfo.startPerInFile;
                        readInfo.endPerResultingBank = readInfo.endPerInFile;
                    }

                    Databank currentBank = Program.databanks.GetDatabank(databank.aliasName);
                    currentBank.yearStart = readInfo.startPerResultingBank;
                    currentBank.yearEnd = readInfo.endPerResultingBank;

                }  //end of using
            }
            else  // not(isTsdx && isProtobuf), that is, a tsd file (possibly packed inside tsdx):
            {
                //also deals with merging (not clearing the databank first if merging)

                ReadAllTsdRecords(dates, file, oRead.Merge, isTsdx, databank, ref NaNCounter, readInfo);

                readInfo.nanCounter = NaNCounter;

                //See almost identical code above and in readCsv()
                if (mergeOrTimeLimit)
                {
                    readInfo.startPerResultingBank = G.GekkoMin(readInfo.startPerInFile, databank.yearStart);
                    readInfo.endPerResultingBank = G.GekkoMax(readInfo.endPerInFile, databank.yearEnd);
                }
                else
                {
                    readInfo.startPerResultingBank = readInfo.startPerInFile;
                    readInfo.endPerResultingBank = readInfo.endPerInFile;
                }
                Databank currentBank = Program.databanks.GetDatabank(databank.aliasName);
                currentBank.yearStart = readInfo.startPerResultingBank;
                currentBank.yearEnd = readInfo.endPerResultingBank;
            }
        }

        private static int GetFirstLastDates(ReadDatesHelper dates, ref GekkoTime first, ref GekkoTime last)
        {
            int offset = 0;
            if (first.freq == EFreq.Annual)
            {
                if (first.SmallerThanOrEqual(dates.t1Annual))
                {
                    offset = GekkoTime.Observations(first, dates.t1Annual) - 1;
                    first = dates.t1Annual;
                }
                if (last.LargerThanOrEqual(dates.t2Annual))
                {
                    last = dates.t2Annual;
                }
            }
            else if (first.freq == EFreq.Quarterly)
            {
                if (first.SmallerThanOrEqual(dates.t1Quarterly))
                {                    
                    offset = GekkoTime.Observations(first, dates.t1Quarterly) - 1;
                    first = dates.t1Quarterly;
                }
                if (last.LargerThanOrEqual(dates.t2Quarterly))
                {
                    last = dates.t2Quarterly;
                }
            }
            else if (first.freq == EFreq.Monthly)
            {
                if (first.SmallerThanOrEqual(dates.t1Monthly))
                {
                    offset = GekkoTime.Observations(first, dates.t1Monthly) - 1;
                    first = dates.t1Monthly;                    
                }
                if (last.LargerThanOrEqual(dates.t2Monthly))
                {
                    last = dates.t2Monthly;
                }
            }
            return offset;
        }

        private static void ReadAllTsdRecords(ReadDatesHelper dates, string file, bool merge, bool isTsdx, Databank databank, ref int NaNCounter, ReadInfo readInfo)
        {
            int smallWarnings = 0;
            int emptyWarnings = 0;
            if (!merge)
            {
                databank.Clear();
            }

            if (Globals.threadIsInProcessOfAborting) throw new GekkoException();
            double[] tempArray = new double[100000]; //we don't expect series with more than 100000 obs.
            int counter = 0;
            using (FileStream fs = WaitForFileStream(file, GekkoFileReadOrWrite.Read))
            using (StreamReader sr = new StreamReader(fs))
            {
                //file should not contain æøå, so no need to use GetTextFromFileWithWait()

                string line = null;
                int nextState = 1;
                string varName = null;
                string frequency = null;
                EFreq freq = EFreq.Annual;

                DateTime t0 = DateTime.Now;
                DateTime t1 = DateTime.Now;
                DateTime t2 = DateTime.Now;
                int ii = 0;
                int d1min = int.MaxValue;
                int d2max = int.MinValue;
                int d1 = 0, d1sub = 0, d2 = 0, d2sub = 0;
                int countdata = 0;
                int obs = 0;
                int obsLeft = 0;
                //int datalines = 0;
                TimeSeries ts = null;

                while ((line = sr.ReadLine()) != null)
                {
                    line = line.Replace("\0", " ");
                    string lineTrim = line.Trim();
                    if (lineTrim == "") continue;

                    if (nextState == 1)
                    {
                        varName = lineTrim;
                        nextState = 2;
                    }

                    else if (nextState == 2)
                    {
                        //read expression
                        string expr = line.Substring(0, 32).Trim();

                        //read stamp
                        string stamp = line.Substring(32, 8).Trim();
                        if (stamp.Length > 0)
                        {
                            try
                            {
                                // #80927435209843
                                int i1 = int.Parse(stamp.Substring(0, 2)); //month
                                int i2 = int.Parse(stamp.Substring(3, 2)); //day
                                int i3 = int.Parse(stamp.Substring(6, 2)); //year
                                if (i3 > 80) i3 = 1900 + i3;  //will work until 2080!
                                else i3 = 2000 + i3;
                                stamp = stamp.Substring(3, 2) + "-" + stamp.Substring(0, 2) + "-" + i3;
                            }
                            catch { };

                        }

                        //read date
                        int iiStart = 37;
                        string date1 = line.Substring(iiStart + 7, 4);
                        string date1sub = line.Substring(iiStart + 11, 2);
                        string date2 = line.Substring(iiStart + 15, 4);
                        string date2sub = line.Substring(iiStart + 19, 2);
                        try
                        {
                            d1 = int.Parse(date1);
                        }
                        catch
                        {
                            G.Writeln2("*** ERROR: " + varName + ": could not parse '" + date1 + "' as an int (start year)");
                            throw new GekkoException();
                        }
                        try
                        {
                            d1sub = int.Parse(date1sub);
                        }
                        catch
                        {
                            G.Writeln2("*** ERROR: " + varName + ": could not parse '" + date1sub + "' as an int (start sub-period)");
                            throw new GekkoException();
                        }
                        try
                        {
                            d2 = int.Parse(date2);
                        }
                        catch
                        {
                            G.Writeln2("*** ERROR: " + varName + ": could not parse '" + date2 + "' as an int (end year)");
                            throw new GekkoException();
                        }
                        try
                        {
                            d2sub = int.Parse(date2sub);
                        }
                        catch
                        {
                            G.Writeln2("*** ERROR: " + varName + ": could not parse '" + date2sub + "' as an int (end sub-period)");
                            throw new GekkoException();
                        }
                        frequency = line.Substring(iiStart + 23, 1).ToLower(); //a or q or m

                        d1min = G.GekkoMin(d1, d1min);  //finding min and max years
                        d2max = G.GekkoMax(d2, d2max);

                        //preparing nextState = 3
                        {

                            bool ok = G.IsSimpleToken(varName);
                            string label = null;
                            if (!ok)
                            {
                                if (varName.Length >= 17)
                                {
                                    //Of this type, where the first 16 chars is the name, and the rest is the label
                                    //gdp2            GDP in version 2, mia. DKK
                                    string v1 = varName.Substring(0, 16).Trim();
                                    string v2 = varName.Substring(16, varName.Length - 16).Trim();

                                    if (!G.IsSimpleToken(v1))
                                    {
                                        G.Writeln2("*** ERROR: tsd read: the following name is malformed:");
                                        G.Writeln("         : " + v1);
                                        G.Writeln("         : The name should contain letters, digits or underscore only");
                                        G.Writeln("         : (It seems there is a label starting in position 17, this is ok)");
                                        throw new GekkoException();
                                    }

                                    varName = v1;
                                    label = v2;
                                }
                                else
                                {

                                    G.Writeln2("*** ERROR: tsd read: the following name is malformed:");
                                    G.Writeln("         : " + varName);
                                    G.Writeln("         : The name should contain letters, digits or underscore only");
                                    throw new GekkoException();
                                }
                            }

                            countdata = 0;
                            freq = G.GetFreq(frequency);
                            obs = GekkoTime.Observations(new GekkoTime(freq, d1, d1sub), new GekkoTime(freq, d2, d2sub));
                            obsLeft = obs;
                            ts = null;
                            if (IsNonsenseVariableName(varName))
                            {
                                emptyWarnings++;
                                ts = new TimeSeries(freq, varName);  //completely phoney, will not live after exit of this method: just so that we can continue
                            }
                            else
                            {
                                ts = FindOrCreateTimeSeriesInDataBank(databank, varName, freq);
                            }
                            if (label != null && label != "") ts.label = label;
                            if (expr != null && expr != "") ts.source = expr;
                            if (stamp != null && stamp != "") ts.stamp = stamp;
                            //datalines = 0;
                            nextState = 3;
                        }

                    }
                    else if (nextState == 3)
                    {
                        int n = Math.Min(5, obsLeft);
                        for (int i5 = 0; i5 < n; i5++)
                        {
                            double ss = double.NaN;
                            bool success = false;
                            int width = 0;
                            if (isTsdx)
                            {
                                width = 21;
                            }
                            else
                            {
                                width = 15;
                            }
                            success = double.TryParse(line.Substring(ii + i5 * width, width), NumberStyles.Any, System.Globalization.CultureInfo.InvariantCulture, out ss);
                            if (!success)
                            {
                                string toParse = line.Substring(ii + i5 * width, width).Trim();
                                if (G.equal(toParse, "NaN") || G.equal(toParse, "-NaN"))
                                {
                                    ss = 1e+15;  //signals missing value
                                    NaNCounter++;
                                }
                                else
                                {
                                    G.Writeln2("*** ERROR: " + varName + ": could not parse '" + toParse + "' as a number");
                                    //sr.Close();
                                    throw new GekkoException();
                                }
                            }

                            if (ss == 1e+15)
                            {
                                ss = double.NaN;
                            }
                            else
                            {
                                if (Math.Abs(ss) < 1e-37 && ss != 0d)
                                {
                                    smallWarnings++;
                                    ss = 0d;  //numbers smaller than this become imprecise when imported from AREMOS
                                              //AREMOS sets all numbers > 1e+15 to 1e+15 when exporting, so no need to do this for large numbers
                                }
                            }
                            tempArray[countdata] = ss;
                            countdata++;
                            obsLeft--;
                        }

                        if (obsLeft == 0)
                        {
                            GekkoTime gt1 = new GekkoTime(freq, d1, d1sub);
                            GekkoTime gt2 = new GekkoTime(freq, d2, d2sub);

                            int offset = 0;

                            //See similar code in px reader
                            if (dates != null)
                            {
                                offset = GetFirstLastDates(dates, ref gt1, ref gt2);
                            }

                            int nob = GekkoTime.Observations(gt1, gt2);
                            if (nob > 0)
                            {
                                ts.SetDataSequence(gt1, gt2, tempArray, offset);
                                ts.Trim(); //to save ram                                                             
                            }
                            counter++;
                            nextState = 1;
                        }
                    }
                }  //end of readline from file
                readInfo.startPerInFile = d1min;
                readInfo.endPerInFile = d2max;
                readInfo.variables = counter;
                if (emptyWarnings > 0) G.Writeln2("+++ WARNING: " + emptyWarnings + " variables with empty string as name in .tsd file (skipped)");
                if (smallWarnings > 0) G.Writeln2("+++ WARNING: " + smallWarnings + " numbers numerically smaller than 1.0e-37 were set to 0");

            }
        }

        public static void ReadPxHelper(Databank databank, ReadDatesHelper dates, ReadOpenMulbkHelper oRead, string file, bool open, string asName, bool baseline, bool merge, ReadInfo readInfo, string fileLocal)
        {           

            DateTime dt1 = DateTime.Now;

            if (!merge)
            {
                databank.Clear();
            }

            string pxLinesText = Program.GetTextFromFileWithWait(fileLocal);  //also removes some kinds of funny characters

            int vars = -12345;
            GekkoTime startYear;
            GekkoTime endYear;
            ReadPx(oRead.array, false, dates, null, null, null, pxLinesText, out vars, out startYear, out endYear);

            readInfo.startPerInFile = startYear.super;
            readInfo.endPerInFile = endYear.super;        
            readInfo.variables = vars;
            readInfo.time = (DateTime.Now - dt1).TotalMilliseconds;

            //See almost identical code in readTsd and readCsv and readPcim and...
            if (merge)
            {
                readInfo.startPerResultingBank = G.GekkoMin(readInfo.startPerInFile, databank.yearStart);
                readInfo.endPerResultingBank = G.GekkoMax(readInfo.endPerInFile, databank.yearEnd);
            }
            else
            {
                readInfo.startPerResultingBank = readInfo.startPerInFile;
                readInfo.endPerResultingBank = readInfo.endPerInFile;
            }
            Databank currentBank = Program.databanks.GetDatabank(databank.aliasName);
            currentBank.yearStart = readInfo.startPerResultingBank;
            currentBank.yearEnd = readInfo.endPerResultingBank;
            
            readInfo.databank.info1 = readInfo.info1;
            readInfo.databank.date = readInfo.date;
            readInfo.databank.FileNameWithPath = readInfo.fileName;

            return;

        }

        public static void ReadPCIM(Databank databank, ReadDatesHelper dates, ReadOpenMulbkHelper oRead, string file, bool open, string asName, bool baseline, bool merge, ReadInfo readInfo, string fileLocal)
        {

            //try
            {
                //Databank databank = readInfo.databank;

                int emptyWarnings = 0;
                int firstYearWarnings = 0;

                DateTime dt1 = DateTime.Now;
                //G.Writeln();
                //file = StripQuotes(file);
                //string originalFileName = file;
                //string extension = "bnk";
                //bool cancel = false;
                int variableCounter = 0;

                if (!merge)
                {
                    databank.Clear();
                }

                //Is all code without æøå, so no need to use GetTextFromFile() to handle ANSI
                using (FileStream fs = WaitForFileStream(fileLocal, GekkoFileReadOrWrite.Read))
                using (BinaryReader binreader = new BinaryReader(fs))
                {
                    float ver = binreader.ReadSingle();
                    G.WritelnGray("Version: " + ver);
                    Int16 fmaxa = binreader.ReadInt16();  //number of variables+1
                    Int16 ffil = binreader.ReadInt16();
                    char[] fmodel = new char[12];
                    fmodel = binreader.ReadChars(12);
                    string model = new string(fmodel);
                    Int16 fsmpl1 = binreader.ReadInt16();
                    Int16 fsmpl2 = binreader.ReadInt16();
                    Int16 fant = binreader.ReadInt16();
                    Int16 fmsta = binreader.ReadInt16();
                    Int16 fcre = binreader.ReadInt16();
                    Int16 fmaxl = binreader.ReadInt16();
                    char[] fhdg = new char[80];
                    fhdg = binreader.ReadChars(80);
                    string sfhdg = new string(fhdg);
                    char[] fdato = new char[8];
                    fdato = binreader.ReadChars(8);
                    string sfdato = new string(fdato);
                    char[] ftid = new char[5];
                    ftid = binreader.ReadChars(5);
                    string sftid = new string(ftid);
                    readInfo.info1 = sfhdg.Trim();
                    string date = sfdato + " " + sftid;
                    string date2 = sfdato;
                    date2 = date2.Replace(" ", "");
                    string[] date3 = date2.Split('/');
                    if (date3.Length == 3)
                    {
                        string d0 = date3[0].Trim();
                        string d1 = date3[1].Trim();
                        string d2 = date3[2].Trim();
                        string date4 = date3[2];
                        int date5 = 0;
                        if (int.TryParse(date4, out date5))
                        {
                            if (date5 <= 20)
                            {
                                int date6 = date5 + 2000;
                                //date += " (the '" + date5 + "' probably means " + date6 + ")";
                                d2 = date6.ToString();
                            }
                            else if (date5 >= 70 && date5 <= 99)
                            {
                                int date6 = date5 + 1900;
                                //date += " (the '" + date5 + "' probably means " + date6 + ")";
                                d2 = date6.ToString();
                            }
                        }
                        date = d0 + "-" + d1 + "-" + d2 + " " + sftid;
                    }

                    readInfo.date = date.Trim();
                    readInfo.pcim = model.Trim();
                    Int16[] fid = new Int16[ffil];   //year
                    for (int i = 0; i < ffil; i++)
                    {
                        fid[i] = binreader.ReadInt16();
                    }

                    int varnamelength = 16;
                    if (Math.Abs(ver - 3.1d) < 0.00001) varnamelength = 8;

                    binreader.BaseStream.Position = 0;
                    binreader.BaseStream.Position = fmaxa * 4;
                    string[] navne = new string[fmaxa];  //variable names
                    char[] temp = new char[varnamelength];
                    for (int i = 0; i < fmaxa; i++)
                    {
                        temp = binreader.ReadChars(varnamelength);
                        navne[i] = new string(temp);
                        if (navne[i].Trim() == "")
                        {
                            G.Writeln();
                        }
                    }
                    int antalper = fsmpl2 - fsmpl1 + 1;  //antal perioder

                    float[,] gigant = new float[fmaxa, antalper + 1];  //per 0 is empty
                    for (int per = 0; per < antalper + 1; per++)
                    {
                        for (int var = 0; var < fmaxa; var++)
                        {
                            float val = binreader.ReadSingle();  //it seems that for per=0, all val er always 0. Maybe something to do with Fortran arrays starting at index 1??
                            gigant[var, per] = val;
                            if (per == 0 && val != 0)
                            {
                                firstYearWarnings++; //for almost all banks this is never so, but some banks may contain a number in this slot. This number will be ignored, but the issue will be reported.
                            }
                        }
                    }

                    binreader.Close();

                    //turning the loop around, so we can use tempArray speedup
                    double[] tempArray = new double[10000]; //we don't expect series with more than 10000 obs.
                    int year1 = fid[0];
                    int year2 = year1 + antalper - 1;

                    if (fid[antalper - 1] != year1 + antalper - 1)
                    {
                        G.Writeln2("*** ERROR: Strange error while reading PCIM databank file");
                        throw new GekkoException();
                    }

                    for (int var = 0; var < fmaxa - 1; var++)  //There are really only fmaxa-1 variables, the last one in navne[] is fake
                    {
                        string varName = navne[var];
                        varName = varName.Trim();

                        if (IsNonsenseVariableName(varName))  //empty or "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
                        {
                            emptyWarnings++; //probably some artefact creeping in???
                            continue;
                        }

                        TimeSeries ts = FindOrCreateTimeSeriesInDataBank(databank, varName, EFreq.Annual);

                        if (oRead.t1.IsNull())
                        {
                            //faster
                            for (int per = 0; per < antalper; per++)
                            {
                                short year = fid[per];
                                float ss = gigant[var, per + 1];  //<==== because gigant[] is 1-based, not 0-based
                                tempArray[per] = ss;
                            }
                            GekkoTime gt1 = new GekkoTime(EFreq.Annual, year1, 1);
                            GekkoTime gt2 = new GekkoTime(EFreq.Annual, year2, 1);
                            ts.SetDataSequence(gt1, gt2, tempArray);
                            ts.Trim();  //to save RAM
                            variableCounter++;
                            //G.Writeln(varName + " var# " + var);
                        }
                        else
                        {

                            for (int per = 0; per < antalper; per++)
                            {
                                short year = fid[per];
                                GekkoTime t = new GekkoTime(EFreq.Annual, year, 1);
                                if (t.LargerThanOrEqual(dates.t1Annual) && t.SmallerThanOrEqual(dates.t2Annual))
                                {
                                    float ss = gigant[var, per + 1];  //<==== because gigant[] is 1-based, not 0-based
                                    ts.SetData(t, ss);
                                }
                            }
                        }
                    }

                    readInfo.startPerInFile = year1;
                    readInfo.endPerInFile = year2;
                    readInfo.nanCounter = 0;
                    readInfo.databankVersion = "(vers: PCIM " + ver + ")";

                    readInfo.variables = variableCounter;  //does not count emptyWarnings
                    readInfo.time = (DateTime.Now - dt1).TotalMilliseconds;

                    //See almost identical code in readTsd and readCsv
                    if (merge)
                    {
                        readInfo.startPerResultingBank = G.GekkoMin(readInfo.startPerInFile, databank.yearStart);
                        readInfo.endPerResultingBank = G.GekkoMax(readInfo.endPerInFile, databank.yearEnd);
                    }
                    else
                    {
                        readInfo.startPerResultingBank = readInfo.startPerInFile;
                        readInfo.endPerResultingBank = readInfo.endPerInFile;
                    }
                    Databank currentBank = Program.databanks.GetDatabank(databank.aliasName);
                    currentBank.yearStart = readInfo.startPerResultingBank;
                    currentBank.yearEnd = readInfo.endPerResultingBank;

                    if (firstYearWarnings > 0) G.Writeln("+++ WARNING: " + firstYearWarnings + " variables had data before databank time period (data skipped)");

                    readInfo.databank.info1 = readInfo.info1;
                    readInfo.databank.date = readInfo.date;
                    readInfo.databank.FileNameWithPath = readInfo.fileName;

                    return;
                }
            }
        }


        public static void ReadPx(string array, bool isDownload, ReadDatesHelper datesRestrict, string source, string tableName, List<string> codesHeaderJson, string pxLinesText, out int vars, out GekkoTime perStart, out GekkoTime perEnd)
        {
         
            bool isArray = false; if (G.equal(array, "yes")) isArray = true;

            bool hyphenFound = false;

            string freq = "a";

            List<string> dates = new List<string>();

            List<string> lines2 = G.ExtractLinesFromText(pxLinesText);
            pxLinesText = null;  //clearing it

            List<string> codesHeader = new List<string>();
            List<List<string>> codes = new List<List<string>>();
            List<List<string>> values = new List<List<string>>();

            //int counter = 0;
            string codeTimeString = "CODES(\"tid\")=";
            string codeString = "CODES(";
            //string valueTimeString = "VALUES(\"tid\")=";
            string valueString = "VALUES(";
            string matrixString = "MATRIX=";


            List<string> codesCombi = null;
            List<string> valuesCombi = null;
            int state = 0;  //DATA=1, CODES("tid")=2, CODES(...)=3, VALUES(...)=4
            StringBuilder lineHelper = new StringBuilder();
            double[] data = null;
            int ii = 0;
            int jj = 0;

            List<int> fractions = new List<int>();
            List<double> fractions2 = new List<double>();
            for (double dd = 0.1; dd <= 1.0; dd = dd + 0.1)
            {
                fractions.Add((int)(dd * (double)lines2.Count));
                fractions2.Add(dd);
            }

            int lineCounter = 0;

            G.Writeln2("Starting to read " + lines2.Count + " data lines from data file");

            GekkoTime gt0 = Globals.tNull;
            GekkoTime gt1 = Globals.tNull;

            long allCcounter = 0;

            foreach (string line2 in lines2)
            {
                lineCounter++;
                if (lines2.Count >= 10000)
                {
                    for (int i = 0; i < fractions.Count; i++)
                    {
                        if (fractions[i] == lineCounter)
                        {
                            G.Writeln("    Progress: " + (int)(Math.Round(100 * fractions2[i])) + "% of " + lines2.Count + " data lines");
                        }
                    }
                }

                string line = line2.Trim();
                bool semi = false;
                bool firstLine = false;

                if (line.StartsWith("DATA="))
                {
                    lineHelper = null; //not used 
                    state = 1;
                    firstLine = true;
                    line = line.Substring("DATA=".Length);
                }
                else if (line.StartsWith(codeTimeString))
                {
                    lineHelper = new StringBuilder();
                    firstLine = true;
                    state = 2;
                }
                else if (line.StartsWith(codeString))
                {
                    lineHelper = new StringBuilder();
                    firstLine = true;
                    state = 3;
                }
                else if (line.StartsWith(valueString))
                {
                    lineHelper = new StringBuilder();
                    firstLine = true;
                    state = 4;
                }
                else if (line.StartsWith(matrixString))
                {
                    if (tableName == null)
                    {
                        tableName = line.Substring(matrixString.Length).Replace("\"", "").Replace(";", "").Trim();
                    }
                }
                else
                {
                    firstLine = false;
                }

                if (line.EndsWith(";"))
                {
                    line = line.Substring(0, line.Length - 1);
                    semi = true;
                }

                if (state == 1)
                {
                    //special treatment
                }
                else
                {
                    lineHelper.Append(line);
                    if (!semi) continue;
                }

                if (state == 1)
                {
                    //state=1                            

                    if (firstLine)
                    {
                        codesCombi = new List<string>();
                        valuesCombi = new List<string>();

                        List<string> codesHeader2 = codesHeaderJson;
                        if (codesHeader2 == null)
                        {
                            codesHeader2 = codesHeader;
                            codesHeader2.Add("TID");  //will be removed again below!
                        }

                        //we are using codesHeaderJson instead of codesHeader (these are more verbose)
                        Walk(tableName, codesHeader2, codes, codesCombi, values, valuesCombi, 0, "", "", ref hyphenFound);
                        data = G.CreateArrayDouble(codesCombi.Count * dates.Count, double.NaN);  //fill it with NaN for safety. Statistikbanken sometimes return only a subset of the data (and the subset is zeroes)
                    }

                    string s = line;

                    int sstate = 1;
                    int lastStart = 0;
                    int counter = 0;
                    for (int i5 = 0; i5 < s.Length; i5++)
                    {
                        char c = s[i5];
                        if ((c == ' ' || i5 == s.Length - 1) && sstate == 1)
                        {
                            int add = 0;
                            if (i5 == s.Length - 1)
                            {
                                add = 1;
                            }
                            string temp2 = s.Substring(lastStart, i5 - lastStart + add);
                            counter++;
                            //G.Writeln2("oasfas " + counter);
                            double value = double.NaN;
                            try
                            {
                                value = double.Parse(temp2);
                            }
                            catch
                            {
                                if (temp2 == "\".\"" || temp2 == "\"..\"" || temp2 == "\"...\"" || temp2 == "\"....\"" || temp2 == "\":\"")
                                {
                                    //See http://www.inside-r.org/packages/cran/pxr/docs/read.px
                                    //do nothing, "." and ".." and "..." and "...." and ":" will be missing value (these include the quotes in the Axis file)
                                }
                                else
                                {
                                    G.Writeln2("*** ERROR: Could not convert '" + temp2 + "' into a number");
                                    throw new GekkoException();
                                }
                            }
                            data[ii + jj * dates.Count] = value;  //i is date, j is variable
                            ii++;
                            if (ii > dates.Count - 1)
                            {
                                ii = 0;
                                jj++;
                            }
                        }

                        if (c != ' ' && sstate == 2)
                        {
                            lastStart = i5;
                        }

                        if (c == ' ')
                        {
                            sstate = 2;  //blanks
                        }
                        else
                        {
                            sstate = 1;  //nonblanks
                        }

                    }
                }
                else if (state == 2)
                {
                    string s = lineHelper.ToString();
                    s = s.Substring(codeTimeString.Length);
                    string[] ss = s.Split(new char[] { ',' }, StringSplitOptions.RemoveEmptyEntries);
                    foreach (string s2 in ss)
                    {
                        if (s2.Substring(1, s2.Length - 2).IndexOf("m", StringComparison.OrdinalIgnoreCase) != -1)
                        {
                            freq = "m";
                        }
                        if (s2.Substring(1, s2.Length - 2).IndexOf("k", StringComparison.OrdinalIgnoreCase) != -1)
                        {
                            freq = "q";
                        }
                        if (s2.Substring(1, s2.Length - 2).IndexOf("q", StringComparison.OrdinalIgnoreCase) != -1)
                        {
                            freq = "q";
                        }
                        dates.Add(s2.Substring(1, s2.Length - 2));
                    }
                }
                else if (state == 3)
                {
                    //state=3
                    //For instance:
                    //
                    //  CODES("ydelse, k?n og alder")="TOT","NET","LDP","LKT","AKI","ADP","AKT","MEN","KVR","U25","O25","O30","O40","O50","O60";
                    //  CODES("s?sonkorrigering og faktiske tal")="10";
                    //
                    string line777 = lineHelper.ToString();
                    int i = line777.IndexOf("=");
                    if (i < 0)
                    {
                        G.Writeln2("*** ERROR: Expected a '=' in this line: " + line777);
                        throw new GekkoException();
                    }

                    string s3 = line777.Substring(0, i); s3 = s3.Substring(7); s3 = s3.Substring(0, s3.Length - 2);
                    codesHeader.Add(s3);

                    string s = line777.Substring(i + 1);
                    //if (s.EndsWith(";")) s = s.Substring(0, s.Length - 1);
                    string[] ss = s.Split(new char[] { ',' }, StringSplitOptions.RemoveEmptyEntries);
                    List<string> names2 = new List<string>();
                    foreach (string s2 in ss)
                    {
                        names2.Add(s2.Substring(1, s2.Length - 2));
                    }
                    if (names2.Count == 0)
                    {
                        G.Writeln2("*** ERROR: Expected 1 or more items in this line: " + line);
                        throw new GekkoException();
                    }
                    codes.Add(names2);
                }
                else if (state == 4)
                {
                    //state=4
                    string line5 = lineHelper.ToString();
                    int i = line5.IndexOf("=");
                    if (i < 0)
                    {
                        G.Writeln2("*** ERROR: Expected a '=' in this line: " + line5);
                        throw new GekkoException();
                    }
                    string s = line5.Substring(i + 1);
                    //if (s.EndsWith(";")) s = s.Substring(0, s.Length - 1);
                    string[] ss = s.Split(new char[] { ',' }, StringSplitOptions.RemoveEmptyEntries);
                    List<string> values2 = new List<string>();
                    foreach (string s2 in ss)
                    {
                        values2.Add(s2.Substring(1, s2.Length - 2));
                    }
                    if (values2.Count == 0)
                    {
                        G.Writeln2("*** ERROR: Expected 1 or more items in this line: " + line5);
                        throw new GekkoException();
                    }
                    values.Add(values2);
                }

                if (semi) state = 0;  //resetting

            }  //for each line

            G.Writeln("    All data read, now putting into array-timeseries");

            if (isArray)
            {
                TimeSeries ts = new TimeSeries(G.GetFreq(freq), tableName);
                ts.SetDirtyGhost(true, true);
                if (Program.databanks.GetFirst().GetVariable(G.GetFreq(freq), ts.variableName) != null)
                {
                    Program.databanks.GetFirst().RemoveVariable(G.GetFreq(freq), ts.variableName);
                }
                Program.databanks.GetFirst().AddVariable(freq, ts);
            }

            for (int j = 0; j < codesCombi.Count; j++)
            {

                TimeSeries ts = null;

                if (isArray)
                {
                    string name3 = GetArrayName(tableName, codesCombi[j]);
                    ts = new TimeSeries(G.GetFreq(freq), name3);
                    ts.label = valuesCombi[j];
                    ts.source = source;
                    ts.stamp = Globals.dateStamp;
                    ts.SetDirtyGhost(true, false);
                }
                else
                {
                    string name2 = codesCombi[j];
                    ts = new TimeSeries(G.GetFreq(freq), name2);
                    ts.label = valuesCombi[j];
                    ts.source = source;
                    ts.stamp = Globals.dateStamp;
                    ts.SetDirtyGhost(true, false);
                }                

                if (Program.options.bugfix_px)  //can be switched off
                {

                    GekkoTime gt_start = G.FromStringToDate(dates[0], true);
                    GekkoTime gt_end = G.FromStringToDate(dates[dates.Count - 1], true);

                    if (gt_start.freq != gt_end.freq)
                    {
                        G.Writeln2("*** ERROR: Frequency mismatch problem in px file");
                        throw new GekkoException();
                    }

                    if (GekkoTime.Observations(gt_start, gt_end) != dates.Count)
                    {
                        //Guards against holes in the date sequence
                        //Note that gt_start and gt_end may be changed with datesRestrict below
                        G.Writeln2("*** ERROR: Expected " + dates.Count + " obs between " + dates[0] + " and " + dates[dates.Count - 1]);
                        throw new GekkoException();
                    }

                    //See similar code in the tsd reader
                    int offset = 0;
                    if (datesRestrict != null)
                    {
                        offset = GetFirstLastDates(datesRestrict, ref gt_start, ref gt_end);
                    }

                    int obs = GekkoTime.Observations(gt_start, gt_end);

                    ts.SetDataSequence(gt_start, gt_end, data, j * dates.Count + offset);  //the last is the offset
                    ts.Trim();  //to save ram
                    allCcounter += obs;
                    if (gt0.IsNull()) gt0 = gt_start;
                    if (gt1.IsNull()) gt1 = gt_end;
                    if (gt_start.StrictlySmallerThan(gt0)) gt0 = gt_start;
                    if (gt_end.StrictlyLargerThan(gt1)) gt1 = gt_end;
                }
                else
                {
                    //does not handle datesRestrict
                    for (int i = 0; i < dates.Count; i++)  //periods
                    {
                        GekkoTime gt = G.FromStringToDate(dates[i], true);
                        ts.SetData(gt, data[i + j * dates.Count]);
                        allCcounter++;
                        if (gt0.IsNull()) gt0 = gt;
                        if (gt1.IsNull()) gt1 = gt;
                        if (gt.StrictlySmallerThan(gt0)) gt0 = gt;
                        if (gt.StrictlyLargerThan(gt1)) gt1 = gt;
                    }
                }

                if (Program.databanks.GetFirst().GetVariable(G.GetFreq(freq), ts.variableName) != null)
                {
                    Program.databanks.GetFirst().RemoveVariable(G.GetFreq(freq), ts.variableName);
                }
                Program.databanks.GetFirst().AddVariable(freq, ts);

            }




            string downloadOrImport = "Read";
            if (isDownload) downloadOrImport = "Downloaded";

            G.Writeln("--> " + downloadOrImport + " " + codesCombi.Count + " timeseries in total, frequency " + freq + ", " + G.FromDateToString(gt0) + "-" + G.FromDateToString(gt1));

            if (isArray)
            {
                G.Writeln("    Name of first timeseries: " + G.PrettifyTimeseriesHash(GetArrayName(tableName, codesCombi[0]), true, false));
                G.Writeln("    Name of last timeseries: " + G.PrettifyTimeseriesHash(GetArrayName(tableName, codesCombi[codesCombi.Count - 1]), true, false));
            }
            else
            {
                G.Writeln("    Name of first timeseries: " + codesCombi[0]);
                G.Writeln("    Name of last timeseries: " + codesCombi[codesCombi.Count - 1]);
            }

            //return values
            vars = codesCombi.Count;
            perStart = gt0;
            perEnd = gt1;

            if (data.LongLength != allCcounter)
            {
                //See not in constrution of data array
                G.Writeln2("+++ WARNING: " + downloadOrImport + " " + allCcounter + " data points in all, expected " + data.LongLength);
            }

            if (hyphenFound)
            {
                //See not in constrution of data array
                G.Writeln2("+++ WARNING: From Gekko 2.3.2 and onwards, hyphens ('-') in names are removed instead of being replaced with 'h'");
            }


        }

        private static string GetArrayName(string tableName, string codesCombi)
        {
            string name3 = null;
            string name2 = codesCombi;
            string[] ss = name2.Split('_');
            List<string> dims = new List<string>();
            for (int i = 2; i < ss.Length; i += 2)
            {
                //kind of hacky, make it more robust later on
                dims.Add(ss[i]);
            }
            foreach (string s in dims)
            {
                name3 += Globals.symbolTurtle + s;
            }
            name3 = tableName + name3;
            return name3;
        }

        private static void Walk(string table, List<string> codesHeader, List<List<string>> codes, List<string> codesCombi, List<List<string>> values, List<string> valuesCombi, int depth, string sCodes, string sValues, ref bool hyphenFound)
        {
            //Hmmm what if a table name or column has a name with '_' inside? Probably not probable.
            if (depth > codes.Count - 1)
            {
                if (sCodes.EndsWith("_")) sCodes = sCodes.Substring(0, sCodes.Length - 1);
                if (sValues.StartsWith(", ")) sValues = sValues.Substring(2);

                string name2 = null;

                if (Program.options.bugfix_px)
                {
                    string temp = table + sCodes;
                    StringBuilder sb = new StringBuilder();
                    for (int i = 0; i < temp.Length; i++)
                    {
                        char tempi = temp[i];
                        if (tempi == '-')
                        {
                            hyphenFound = true;
                        }

                        if (tempi == 'æ') sb.Append("ae");
                        else if (tempi == 'ø') sb.Append("oe");
                        else if (tempi == 'å') sb.Append("aa");
                        else if (tempi == 'Æ') sb.Append("AE");
                        else if (tempi == 'Ø') sb.Append("OE");
                        else if (tempi == 'Å') sb.Append("AA");
                        else if (!G.IsLetterOrDigitOrUnderscore(tempi))  //only accepts english letters
                        {
                            //ignore it, 
                        }
                        else
                        {
                            sb.Append(tempi);  //here we know that it is englishletter or digit or underscore
                        }
                    }
                    name2 = sb.ToString();
                }
                else
                {
                    if (name2.Contains("-")) hyphenFound = true;
                    name2 = table + sCodes;
                    name2 = name2.Replace("Æ", "AE");
                    name2 = name2.Replace("Ø", "OE");
                    name2 = name2.Replace("Å", "AA");
                    name2 = name2.Replace("æ", "ae");
                    name2 = name2.Replace("ø", "oe");
                    name2 = name2.Replace("å", "aa");
                    //name2 = name2.Replace("-", "h");  //h like hyphen, cannot use "_" since this is used as delimiter when composing names
                    name2 = name2.Replace("-", "");
                    name2 = name2.Replace(" ", "");
                    name2 = name2.Replace("(", "");
                    name2 = name2.Replace(")", "");
                    name2 = name2.Replace("=", "");
                    name2 = name2.Replace(".", "");
                    name2 = name2.Replace(",", "");
                    name2 = name2.Replace(":", "");                    
                }
                codesCombi.Add(name2);
                valuesCombi.Add(sValues);
                return;
            }

            for (int i = 0; i < codes[depth].Count; i++)
            {
                string sCodesTemp = sCodes + "_" + codesHeader[depth] + "_" + codes[depth][i];
                string sValuesTemp = sValues + ", " + values[depth][i];

                Walk(table, codesHeader, codes, codesCombi, values, valuesCombi, depth + 1, sCodesTemp, sValuesTemp, ref hyphenFound);
            }

        }

        public static void ReadGdx(Databank databank, ReadDatesHelper dates, ReadOpenMulbkHelper oRead, string file2, bool open, string asName, bool baseline, bool merge, ReadInfo readInfo, string fileLocal)
        {
            //Hardcoded --------------
            string tName = "t";  //name of the set identified as time
            int timePartLength = 1;  //how many chars to remove from for instance 't30'
            int year0 = 2006; //'t30' --> 30 + 2006 = 2036.

            bool identifyTPlusIntegerAsTime = true;
            char identifierT = 't';

            bool loadIntoTimeseriesWithArrays = true;
            //------------------------

            string file = AddExtension(file2, "." + "gdx");

            DateTime dt1 = DateTime.Now;

            string gamsDir = Program.options.gams_exe_folder.Trim();
            if (gamsDir.EndsWith("\\")) gamsDir = gamsDir.Substring(0, gamsDir.Length - "\\".Length);
            if (gamsDir.Trim() == "") gamsDir = null;  //must be so and not an empty string in the GAMSWorkspace call later on

            GAMSWorkspace ws = null;
            try
            {
                ws = new GAMSWorkspace(workingDirectory: Program.options.folder_working, systemDirectory: gamsDir);
            }
            catch (Exception e)
            {

                G.Writeln2("*** ERROR: Import of gdx file (GAMS) failed. GAMSWorkspace problem.");
                G.Writeln("           Technical error:");
                G.Writeln("           " + e.Message);
                G.Writeln("+++ NOTE:  You may manually indicate the GAMS program folder with 'OPTION gams exe folder = ...;'");                
                throw;
            }

            GAMSDatabase db = null;
            try
            {
                db = ws.AddDatabaseFromGDX(file);
            }
            catch (Exception e)
            {
                G.Writeln2("*** ERROR: Import of gdx file (GAMS) failed. AddDatabaseFromGDX problem.");
                G.Writeln("           Technical error:");
                G.Writeln("           " + e.Message);                
                throw;
            }

            string readType = oRead.gdxopt; //for instance: "scns['base']" 

            string cut1 = null; string cut2 = null;
            if (readType == null) readType = "";
            readType = readType.Replace(" ", "");  //no blanks            
            string[] ss = readType.Split(new char[] { '.' }, StringSplitOptions.RemoveEmptyEntries);
            if (ss.Length == 2 && ss[0] != null && ss[0].Trim() != "" && ss[1] != null && ss[1].Trim() != "")
            {
                cut1 = ss[0];
                cut2 = ss[1];
            }

            DateTime t00 = DateTime.Now;

            G.Writeln();

            int counterVariables = 0;
            int counterParameters = 0;

            if (!merge)
            {
                databank.Clear();
            }

            int yearMin = int.MaxValue;
            int yearMax = int.MinValue;

            foreach (GAMSSymbol gamsSymbol in db)
            {
                if (gamsSymbol.GetType() == typeof(GAMSParameter) || gamsSymbol.GetType() == typeof(GAMSVariable))
                {
                    //The data may or may not be arranged with time (t) as the last set.
                    //If so, we read it in chunks.

                    // ----------------------------
                    // age  status   t       value
                    // ----------------------------
                    // 20   u        t0        ...
                    // 20   u        t1        ...
                    // 20   u        t2        ...
                    // - - - - - - - - - - - - - - 
                    // 20   g        t0        ...
                    // 20   g        t1        ...
                    // 20   g        t2        ...
                    // ----------------------------

                    //For each os the records, we create a hash that does not include time (t). So the first
                    //three will have equal hash. While the hash is equal, we put the data in an array.
                    //When the hash changes (or there are no more records), we put the array into the
                    //corresponding array-timeseries.                

                    string gvar = gamsSymbol.Name;

                    //if (gvar.ToLower().StartsWith("j_"))
                    //{
                    //    //continue;  //make filtering possible!
                    //}


                    if (G.IsUnitTesting() && !(G.equal(gvar, "m") || G.equal(gvar, "myfm") || G.equal(gvar, "f") || G.equal(gvar, "pm") || G.equal(gvar, "pff") || G.equal(gvar, "ef"))) continue;  //to not waste time on this when unit testing

                    //int[] dims = new int[gamsSymbol.Domains.Count];   

                    //if(G.equal(gvar, "j_cqi")) { 

                    //}

                    //if (G.equal(gvar, "gnslon"))
                    //{

                    //}

                    int timeIndex = -12345;
                    int scnsIndex = -12345;
                    for (int i = 0; i < gamsSymbol.Domains.Count; i++)  //only few of these, speed not an issue
                    {
                        Object o = gamsSymbol.Domains.ElementAt(i);
                        if (o.GetType() == typeof(GAMSSet))
                        {
                            GAMSSet gs = (GAMSSet)gamsSymbol.Domains.ElementAt(i);
                            //dims[i] = gs.NumberRecords;
                            if (G.equal(gs.Name, tName))
                            {
                                timeIndex = i;
                            }
                            else if (G.equal(gs.Name, cut1))
                            {
                                scnsIndex = i;
                            }
                        }
                        else
                        {
                            //this may be a string = "*", for instance the parameter y_ps
                        }
                    }


                    TimeSeries ts2 = null;

                    string oldHash = "<{Some random characters}>";

                    bool isDimensionless = false;

                    int ii = 0;

                    foreach (GAMSSymbolRecord gamsSymbolRecord in gamsSymbol)
                    {

                        if (Globals.threadIsInProcessOfAborting)
                        {
                            G.Writeln2("Stopping GAMS file import");
                            return;
                        }

                        string[] keys = gamsSymbolRecord.Keys;

                        if (scnsIndex != -12345)
                        {
                            if (cut1 != null && scnsIndex >= 0 && !G.equal(keys[scnsIndex], cut2)) continue;  //ignore this
                        }

                        double d = double.NaN;

                        if (true)
                        {
                            GAMSParameterRecord xx1 = gamsSymbolRecord as GAMSParameterRecord;
                            if (xx1 != null)
                            {
                                d = xx1.Value;
                            }
                            else
                            {
                                GAMSVariableRecord xx2 = gamsSymbolRecord as GAMSVariableRecord;
                                if (xx2 != null)
                                {
                                    d = xx2.Level;
                                }
                                else
                                {
                                    //Sets could go here...
                                    G.Writeln2("*** ERROR: #09843750983275");
                                    throw new GekkoException();
                                }
                            }
                        }


                        //without continue here, a gdx is around 16s, with continue it is around 12s. So GAMS iterator is slow (pure iterator takes around 5-6 s)
                        //continue; 

                        int tt = -12345;
                        string t = null;
                        if (timeIndex != -12345)  //time has been identified from sets above
                        {
                            t = keys[timeIndex];
                            tt = G.IntParse(t.Substring(timePartLength)) + year0;  //remove the "t" and add 2006
                        }

                        string hash = "";
                        //returns hash and tt
                        GamsGetHashAndTime(year0, identifyTPlusIntegerAsTime, identifierT, cut2, timeIndex, scnsIndex, keys, ref tt, ref hash);

                        string varName = null;
                        if (hash.Length > 0)
                        {
                            varName = gvar + Globals.symbolTurtle + hash.Substring(0, hash.Length - Globals.symbolTurtle.Length);
                        }
                        else
                        {
                            isDimensionless = true;
                            varName = gvar;
                        }

                        if (hash != oldHash)  //oldHash starts out as ""
                        {
                            //if time is the last dimension, the hash is the same for all periods
                            //this avoids getting the same Gekko variable over and over
                            ts2 = databank.GetVariable(EFreq.Annual, varName);
                        }

                        if (ts2 == null)
                        {
                            ts2 = new TimeSeries(EFreq.Annual, varName);
                            databank.AddVariable(ts2, false);
                            if (tt == -12345)
                            {
                                ts2.SetTimeless();
                            }
                            if (gamsSymbol.GetType() == typeof(GAMSParameter)) counterParameters++;
                            else if (gamsSymbol.GetType() == typeof(GAMSVariable)) counterVariables++;
                        }

                        if (tt == -12345)
                        {
                            ts2.SetTimelessData(d);
                        }
                        else
                        {
                            ts2.SetData(new GekkoTime(EFreq.Annual, tt, 1), d);  //seems this is not a time-bottleneck
                            yearMax = Math.Max(tt, yearMax);
                            yearMin = Math.Min(tt, yearMin);
                        }
                        oldHash = hash;
                        ii++;
                    }

                    if (isDimensionless)
                    {
                        //do nothing, do not create a ghost
                    }
                    else
                    {
                        TimeSeries ts = new TimeSeries(EFreq.Annual, gvar);  //we wipe it out if it is alreay existing
                        ts.SetGhost(true);  //only a placeholder, should not be counted etc.
                        databank.AddVariable(ts);
                    }

                    //G.Writeln("Imported GAMS variable: " + gvar + " " + G.SecondsFormat((DateTime.Now - t0).TotalMilliseconds));
                }
                else
                {
                    //ignore it
                }
            }
            G.Writeln2("Finished GAMS import of " + counterVariables + " variables and " + counterParameters + " parameters (" + G.SecondsFormat((DateTime.Now - t00).TotalMilliseconds) + ")");

            readInfo.startPerInFile = yearMin;
            readInfo.endPerInFile = yearMax;
            readInfo.nanCounter = 0;

            readInfo.variables = counterVariables + counterParameters;
            readInfo.time = (DateTime.Now - dt1).TotalMilliseconds;

            //See almost identical code in readTsd and readCsv
            if (merge)
            {
                readInfo.startPerResultingBank = G.GekkoMin(readInfo.startPerInFile, databank.yearStart);
                readInfo.endPerResultingBank = G.GekkoMax(readInfo.endPerInFile, databank.yearEnd);
            }
            else
            {
                readInfo.startPerResultingBank = readInfo.startPerInFile;
                readInfo.endPerResultingBank = readInfo.endPerInFile;
            }
            Databank currentBank = Program.databanks.GetDatabank(databank.aliasName);
            currentBank.yearStart = readInfo.startPerResultingBank;
            currentBank.yearEnd = readInfo.endPerResultingBank;

            readInfo.databank.info1 = readInfo.info1;
            readInfo.databank.date = readInfo.date;
            readInfo.databank.FileNameWithPath = readInfo.fileName;

            //TODO: Maybe only do this on the gdx variables if possible
            //Anyway, the speed penalty is small anyway.
            databank.Trim();
        }

        private static void GamsGetHashAndTime(int year0, bool identifyTPlusIntegerAsTime, char identifierT, string cut2, int timeIndex, int scnsIndex, string[] keys, ref int tt, ref string hash)
        {
            for (int i = 0; i < keys.Length; i++)
            {
                if (i == timeIndex) continue;  //not to be part of name
                string keysi = keys[i];
                if (timeIndex == -12345 && identifyTPlusIntegerAsTime)
                {
                    //Time not found above, so now we take a closer look at the key. This will cost performance
                    bool isTime = true;
                    GamsCheckIfTimeDimension(identifierT, keysi, ref isTime);
                    if (isTime)
                    {
                        tt = G.IntParse(keysi.Substring(1)) + year0;  //used later on
                        continue;  //not to be part of name
                    }
                }

                if (i == scnsIndex && G.equal(keysi, cut2))
                {
                    //skip it entirely, not to be part of name
                }
                else
                {
                    hash += keysi + Globals.symbolTurtle;
                    //if (i < keys.Length - 1) hash += Globals.symbolTurtle; //ok as delimiter;                    
                }
            }
        }

        private static void GamsCheckIfTimeDimension(char identifierT, string keysi, ref bool isTime)
        {
            bool first = true;
            foreach (char c in keysi)
            {
                if (first && c != identifierT)
                {
                    isTime = false;
                    break;
                }
                if (!first && !char.IsDigit(c))
                {
                    isTime = false;
                    break;
                }
                first = false;
            }
        }

        public static string NumberFormat(double d, string format2)
        {
            string format = "{0:" + format2 + "}";  //0: is just that it is the first element in a list of numbers, perhaps even irrelevant here
            string x = null;
            try
            {
                x = String.Format(format, d);
            }
            catch (Exception e)
            {
                G.Writeln2("*** ERROR: format() function failed. The internal error message is this:");
                G.Writeln("           " + e.Message);
                throw new GekkoException();
            }
            return x;
        }

        private static bool IsNonsenseVariableName(string varName)
        {
            bool nonsense = false;
            if (varName == "" || varName == "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")
            {
                nonsense = true;
            }
            return nonsense;
        }


        private static void WriteTsdRecord(GekkoTime per1, GekkoTime per2, StreamWriter res, TimeSeries ts, bool isCaps, bool isTsdx)
        {
            int index1 = -12345;
            int index2 = -12345;
            //TODO: can return null
            //TODO: and it might be called half overlapped like this:
            //            +++++++++++++++++++++++
            //      ---------------
            double[] dataArray = null;
            if (per1.IsNull() && per2.IsNull())
            {
                index1 = ts.firstPeriodPositionInArray;
                index2 = ts.lastPeriodPositionInArray;
                dataArray = ts.dataArray;
                per1 = ts.GetPeriodFirst();
                per2 = ts.GetPeriodLast();
            }
            else
            {
                //also sets index1 and index2.
                dataArray = ts.GetDataSequence(out index1, out index2, per1, per2);
            }

            int count2 = 0;
            string s = "";
            double oldValue = double.NaN;
            bool firstTime = true;
            string varName = ts.variableName;
            if (isCaps) varName = varName.ToUpper();  //for use with AREMOS

            string sub1 = "";
            string sub2 = "";
            string freq = "A";
            if (ts.frequency == "a")
            {
                sub1 = "0101";
                sub2 = "0101";
            }
            else
            {
                freq = ts.frequency.ToUpper();
                sub1 = "" + per1.sub;
                if (sub1.Length == 1) sub1 = "0" + sub1;
                if (sub1.Length == 0 || sub1.Length >= 3)
                {
                    G.Writeln2("*** ERROR: Problem writing subperiod info in tsd file");
                    throw new GekkoException();
                }
                sub1 = sub1 + "01";
                sub2 = "" + per2.sub;
                if (sub2.Length == 1) sub2 = "0" + sub2;
                if (sub2.Length == 0 || sub2.Length >= 3)
                {
                    G.Writeln2("*** ERROR: Problem writing subperiod info in tsd file");
                    throw new GekkoException();
                }
                sub2 = sub2 + "01";
            }

            if (varName.Length <= 16 && ts.label != null && ts.label.Length > 0)
            {
                res.WriteLine(varName + G.Blanks(16 - varName.Length) + ts.label);
            }
            else
            {
                //do not write label if name > 16 chars
                res.WriteLine(varName);
            }

            string stmp = "01/01/00";
            if (ts.stamp != null && ts.stamp.Length == 10)
            {
                try
                {
                    int i = int.Parse(ts.stamp.Substring(6, 4));
                    if (i >= 2000) i = i - 2000;
                    else i = i - 1900;
                    string temp = ts.stamp.Substring(3, 2) + "/" + ts.stamp.Substring(0, 2) + "/" + i;
                    if (temp.Length == 8) stmp = temp;
                }
                catch
                {
                }
            }

            string src = ts.source;
            if (src == null) src = "";
            if (src.Length > 16) src = src.Substring(0, 16);
            else src = src + G.Blanks(16 - src.Length);

            res.WriteLine("                " + src + stmp + "0000" + per1.super + sub1 + per2.super + sub2 + freq + "  0"); //time is set to 0000

            for (int index = index1; index <= index2; index++)
            {
                count2++;
                double value = double.NaN;
                {
                    value = dataArray[index];
                }

                if (double.IsNaN(value))
                {
                    value = 1.0e+15;
                }

                if (Math.Abs(value) <= 1.0e-99d)
                {
                    //otherwise we will get exponents with 3 characters,
                    //and PCIM does not like that
                    value = 0;
                }
                if (Math.Abs(value) >= 1.0e+99d)
                {
                    //otherwise we will get exponents with 3 characters,
                    //and PCIM does not like that
                    //Too large a number
                    //Missing does not have a sign
                    value = 1.0e+15d;
                }

                if (firstTime || (!firstTime && value != oldValue)) //This trick makes it run about 25% faster
                {
                    if (isTsdx)
                    {
                        s = string.Format(System.Globalization.CultureInfo.InvariantCulture, "{0:0.00000000000000E+00}", value);
                    }
                    else
                    {
                        s = string.Format(System.Globalization.CultureInfo.InvariantCulture, "{0:0.00000000E+00}", value);
                    }
                }

                firstTime = false;
                oldValue = value;

                if (value < 0)
                {

                    res.Write(s);

                }
                else
                {
                    res.Write(" " + s);
                }
                if (count2 % 5 == 0 && index != index2) res.WriteLine();  //new line for each 5 numbers written
            }
            res.WriteLine();
        }


        private static void WriteTspRecord(GekkoTime per1, GekkoTime per2, StreamWriter res, TimeSeries ts, bool isCaps)
        {
            int index1 = -12345;
            int index2 = -12345;
            //TODO: can return null
            //TODO: and it might be called half overlapped like this:
            //            +++++++++++++++++++++++
            //      ---------------
            double[] dataArray = null;
            if (per1.IsNull() && per2.IsNull())
            {
                index1 = ts.firstPeriodPositionInArray;
                index2 = ts.lastPeriodPositionInArray;
                dataArray = ts.dataArray;
                per1 = ts.GetPeriodFirst();
                per2 = ts.GetPeriodLast();
            }
            else
            {
                //also sets index1 and index2.
                dataArray = ts.GetDataSequence(out index1, out index2, per1, per2);
            }

            int count2 = 0;
            string s = "";
            string varName = ts.variableName;
            if (isCaps) varName = varName.ToUpper();

            if (!G.equal(ts.frequency, "a"))
            {
                G.Writeln2("*** ERROR: WRITE <tsp> only implemented for annual data");
                throw new GekkoException();
            }

            res.WriteLine("smpl " + per1.super + " " + per2.super + ";");
            res.WriteLine("load " + varName + ";");

            for (int index = index1; index <= index2; index++)
            {
                count2++;
                double value = double.NaN;
                {
                    value = dataArray[index];
                }
                if (double.IsNaN(value))
                {
                    res.WriteLine(".");
                }
                else
                {
                    res.WriteLine(value);
                }
            }
            res.WriteLine(";");
            res.WriteLine();
        }

        public static void WriteTsdRecord2(int yr1, int yr2, StreamWriter res, int varNumber, double[] data, String var2)
        {
            //TODO: quarters
            if (Program.options.freq != EFreq.Annual)
            {
                G.Writeln2("*** ERROR: Tsp to tsd conversion only works on annual data");
                throw new GekkoException();
            }
            res.WriteLine(var2);
            //res.WriteLine("                                 1/ 1/ 10800" + (yr1 + 0) + "0100" + (yr2 + 0) + "0100A  0");
            res.WriteLine("                                11/22/ 72014" + (yr1 + 0) + "0101" + (yr2 + 0) + "0101A2 0         0000000");

            int count2 = 0;
            for (int t = yr1; t <= yr2; t++)
            {
                count2++;
                double value = double.NaN;
                if (varNumber == -12345 && data != null)
                {
                    value = data[t];
                }
                else
                {
                    G.Writeln2("*** ERROR internal error 9329329");
                    //value = a[varNumber, t];
                }

                if (double.IsNaN(value))
                {
                    value = 1.0e+15;
                }

                if (Math.Abs(value) <= 1.0e-99d)
                {
                    //otherwise we will get exponents with 3 characters,
                    //and PCIM does not like that
                    value = 0;
                }
                if (Math.Abs(value) >= 1.0e+99d)
                {
                    //otherwise we will get exponents with 3 characters,
                    //and PCIM does not like that
                    //Too large a number
                    //Missing does not have a sign
                    value = 1.0e+15d;
                }

                String valueExp = string.Format(System.Globalization.CultureInfo.InvariantCulture, "{0:0.000000E+00}", value);

                if (value < 0)
                {
                    res.Write("  " + valueExp);
                }
                else
                {
                    res.Write("   " + valueExp);
                }
                if (count2 % 5 == 0) res.WriteLine();  //new line for each 5 numbers written
            }
            if (count2 % 5 != 0) res.WriteLine();

        }


        public static int key = 129;

        public static string EncryptDecrypt(string textToEncrypt)
        {
            StringBuilder inSb = new StringBuilder(textToEncrypt);
            StringBuilder outSb = new StringBuilder(textToEncrypt.Length);
            char c;
            for (int i = 0; i < textToEncrypt.Length; i++)
            {
                c = inSb[i];
                if (i > 17)
                {
                    c = (char)(c ^ key);
                }
                outSb.Append(c);
            }
            StringBuilder outSb1 = new StringBuilder(outSb.ToString());
            for (int i = 0; i < Math.Abs(outSb.Length / 2d); i++)
            {
                if (i % 3 == 0 && i > 17)
                {
                    outSb1[i] = outSb[outSb.Length - i - 1];
                    outSb1[outSb.Length - i - 1] = outSb[i];
                }
            }
            return outSb1.ToString();
        }

        public static void DeleteTemporaryCsFilesFromLastTime()
        {
            //delete temporary .cs files from last time
            string path = Globals.localTempFilesLocation;
            if (Directory.Exists(path))
            {
                string[] fileList = Directory.GetFiles(path, "*.cs");
                foreach (string file in fileList)
                {
                    FileInfo imgInfo = new FileInfo(file);
                    imgInfo.Delete();
                }
            }
        }

        public static EquationHelper FindEquationByMeansOfVariableName(string lhsName)
        {
            if (model == null) return null;
            int r = -12345;
            if (model.fromVariableToEquationNumber.TryGetValue(lhsName + Globals.lagIndicator + "0", out r))
            {
                //r will get a value
            }
            else
            {
                return null;
            }

            int number = r;
            EquationHelper found = model.equations[number];  //should alway find something
            return found;
        }

        public static void EndogenizeExogenizeStuff(bool isFix)
        {
            Program.model.m2.endogenous.Clear();
            foreach (string var in Program.model.endogenousOriginallyInModel.Keys)
            {
                Program.model.m2.endogenous.Add(var, "");
            }

            Program.model.m2.endoSubstitution.Clear();
            Program.model.m2.endoSubstitutionBNumbers.Clear();

            if (isFix)  //we skip this for normal SIM, just as if the ENDO/EXO lists were empty even if they are not
            {
                //TODO: Maybe model.endogenized and model.exogenized should be List<string> to begin with,
                //      to preserve order. Might be better for simulation.
                //      BUT then we would have to re-thing caching, where order is scrambled anyway. Probably
                //      preserving order is not noticable anyway, especially when using direct inverter (LU).
                List<string> endogeni = new List<string>();
                List<string> exogeni = new List<string>();
                IEnumerator e1 = null;
                IEnumerator e2 = null;
                e1 = Program.model.endogenized.GetEnumerator();
                e2 = Program.model.exogenized.GetEnumerator();
                while (e1.MoveNext())
                {
                    e2.MoveNext();
                    //string s1 = (string)(((DictionaryEntry)e1.Current).Key);
                    string s1 = ((KeyValuePair<string, string>)e1.Current).Key;
                    string s2 = ((KeyValuePair<string, string>)e2.Current).Key;
                    endogeni.Add(s1);
                    exogeni.Add(s2);
                }
                //This sorting is so that we get the same order no matter which order (and case) the means/goals were set
                //This is probably more safe regarding cacheing of the results. Not sorting might give hard to track errors.
                endogeni.Sort(StringComparer.OrdinalIgnoreCase);
                exogeni.Sort(StringComparer.OrdinalIgnoreCase);

                //endogenous/exogenous are altered due to endogenized/exogenized
                for (int i = 0; i < endogeni.Count; i++)
                {
                    string s1 = endogeni[i];
                    string s2 = exogeni[i];
                    //BTypeData ss1 = (BTypeData)Program.model.varsBType[s1 + Globals.lagIndicator + "0"];
                    BTypeData ss1 = null; Program.model.varsBType.TryGetValue(s1 + Globals.lagIndicator + "0", out ss1);
                    if (ss1 == null)
                    {
                        //TODO: general error handling regarding endo/exo
                        //now we get runtime error
                        G.Writeln2("*** ERROR: regarding endogenize: variable " + s1 + " does not exist in model");
                        throw new GekkoException();
                    }
                    int s1BNumber = ss1.bNumber;
                    //int varNumber = ss1.bNumber;
                    if (Program.model.m2.endogenous.ContainsKey(s1))
                    {
                        G.Writeln2("*** ERROR: regarding endogenize: variable " + s1 + " is already endogenous");
                        throw new GekkoException();
                    }
                    else
                    {
                        Program.model.m2.endogenous.Add(s1, "");
                        //Program.model.endogenousBNumbers.Add(s1BNumber, "");  DO NOT ACTIVATE THIS ONE -- endogenousBNumbers are dealt with in the ordering code
                        //BTypeData ss2 = (BTypeData)Program.model.varsBType[s2 + Globals.lagIndicator + "0"];
                        BTypeData ss2 = null; Program.model.varsBType.TryGetValue(s2 + Globals.lagIndicator + "0", out ss2);
                        if (ss2 == null)
                        {
                            //TODO: general error handling regarding endo/exo
                            //now we get runtime error
                            G.Writeln2("*** ERROR: regarding exogenize: variable " + s2 + " does not exist in model");
                            throw new GekkoException();
                        }
                        int s2BNumber = ss2.bNumber;

                        if (Program.model.m2.endogenous.ContainsKey(s2))
                        {
                            Program.model.m2.endogenous.Remove(s2);
                            //Program.model.endogenousBNumbers.Remove(s2BNumber);  //DO NOT ACTIVATE THIS ONE -- endogenousBNumbers are dealt with in the ordering code
                            Program.model.m2.endoSubstitution.Add(s2, s1);
                            Program.model.m2.endoSubstitutionBNumbers.Add(s2BNumber, s1BNumber);
                        }
                        else
                        {
                            G.Writeln2("*** ERROR: regarding exogenize: variable " + s2 + " is not endogenous");
                            throw new GekkoException();
                        }
                    }
                }
            }

            // ---------------------- endogenous with b-number -- end ------------------------

            Program.model.m2.fromEqNumberToBNumber = G.CreateArray(Program.model.m2.endogenous.Count, -12345);  //used in newton
            Program.model.m2.fromBNumberToEqNumber = G.CreateArray(1000000, -12345);  //slack, fix, used in newton
            Program.model.m2.sparseInfo = new List<int>[Program.model.m2.endogenous.Count]; //used in newton
            Program.model.m2.sparseInfoLeftRightSeparated = new List<int>[Program.model.m2.endogenous.Count]; //used for ordering

            foreach (EquationHelper eh in Program.model.equations)
            {
                int varNumber = eh.bNumberLhs;
                List<int> arl = new List<int>();
                List<int> arl2 = new List<int>();
                Program.model.m2.sparseInfo[eh.equationNumber] = arl;
                Program.model.m2.sparseInfoLeftRightSeparated[eh.equationNumber] = arl2;

                int x = -12345;
                if (Program.model.m2.endoSubstitutionBNumbers.TryGetValue(varNumber, out x))
                {
                    varNumber = x;
                }

                Program.model.m2.fromEqNumberToBNumber[eh.equationNumber] = varNumber;
                Program.model.m2.fromBNumberToEqNumber[varNumber] = eh.equationNumber;

                //-------------------------

                List<int> temp = new List<int>();
                //Hmmm, using Contains() on a List<> could waste time instead of Dictionary, but these lists are probably short anyway
                if (!Program.model.m2.sparseInfo[eh.equationNumber].Contains(varNumber))
                {
                    //to avoid duplicates
                    Program.model.m2.sparseInfo[eh.equationNumber].Add(varNumber);
                }
                foreach (string s in eh.precedentsWithLagIndicator.Keys)
                {
                    BTypeData temp3 = (BTypeData)Program.model.varsBType[s];
                    int rhsVarNumber = temp3.bNumber;
                    if (Program.model.endogenousBNumbersOriginallyInModel.ContainsKey(rhsVarNumber))
                    {
                        if (!Program.model.m2.sparseInfo[eh.equationNumber].Contains(rhsVarNumber))
                        {
                            //to avoid duplicates
                            Program.model.m2.sparseInfo[eh.equationNumber].Add(rhsVarNumber);
                        }
                        //if (!first && !((ArrayList)sparseInfoLeftRightSeparated[eqNumber]).Contains(varNumber1))
                        if (!temp.Contains(rhsVarNumber))
                        {
                            //to avoid duplicates
                            temp.Add(rhsVarNumber);
                        }
                    }
                }
                Program.model.m2.sparseInfoLeftRightSeparated[eh.equationNumber].Add(varNumber);
                Program.model.m2.sparseInfoLeftRightSeparated[eh.equationNumber].AddRange(temp);
            }
        }

        public static void FeedbackOrderingStuff(ECompiledModelType modelType, bool isCalledFromModelStatement)
        {

            //int xx;
            //xx = fromEqNumberToBNumber.Length; //(a)
            //xx = fromBNumberToEqNumber.Length; //(a1)

            //xx = fromEqNumberToBNumberRecursiveNEW.Count;  //(b)
            //xx = fromBNumberToEqNumberRecursiveNEW.Length; //(b1)

            //xx = fromEqNumberToBNumberFeedbackNEW.Length;  //(c)
            //xx = fromBNumberToEqNumberFeedbackNEW.Length;  //(c1)


            //frml _i i1=0.5*g;
            //frml _i i=i1;
            //frml _i y=c+i+g+e-m;                          //frml _i g=g+y-(c+i+g+e-m);
            //frml _i c=0.2*y+0.1*c+0.1*e;
            //frml _i e=-0.2*m+0.2*c-0.1*y *y;
            //frml _i m=m2;
            //frml _i m2=m3;
            //frml _i m3=m4;
            //frml _i m4=m5;
            //frml _i m5=m6;
            //frml _i m6=m7;
            //frml _i m7=m8;
            //frml _i m8=0.1*c     ;
            //frml _i x=2*y;
            //frml _i z=2*x;


            //   (a)   (b)    (c)
            //-------------------------
            //0   0    13     3
            //1   2    12     4
            //2   3    11
            //3   4    10
            //4   5    9
            //5   6    8
            //6   7    7
            //7   8    6
            //8   9    5
            //9   10
            //10  11
            //11  12
            //12  13
            //13  14
            //14  15


            //   (a1)  (b2)  (c2)       <m> = -12345
            //------------------------------------------
            //0   0    <m>   <m>        prologue
            //1  <m>   <m>   <m>        exo
            //2   1    <m>   <m>        prologue
            //3   2    <m>    1
            //4   3    <m>    0
            //5   4     8    <m>
            //6   5     7    <m>
            //7   6     6    <m>
            //8   7     5    <m>
            //9   8     4    <m>
            //10  9     3    <m>
            //11  10    2    <m>
            //12  11    1    <m>
            //13  12    0    <m>
            //14  13   <m>   <m>        epilogue
            //15  14   <m>   <m>        epilogue


            // sparseInfoLeftRightSeparated
            //
            //    before                after endo/exo of g and e.
            //------------------------------------------------
            //0     0                 0     0,1                   ++  added 1
            //1     2,0               1     2,0
            //2     3,4,2,5,6         2     3,4,2,1,6             ++  1 instead of 5
            //3     4,3,4,5           3     4,3,4                 ++  removed 5
            //4     5,6,4,3           4     1,1,6,4,3             ++  1's instead of 5
            //5     6,7               5     6,7
            //6     7,8               6     7,8
            //7     8,9               7     8,9
            //8     9,10              8     9,10
            //9     10,11             9     10,11
            //10    11,12             10    11,12
            //11    12,13             11    12,13
            //12    13,4              12    13,4
            //13    14,3              13    14,3
            //14    15,14             14    15,14

            //endogenized exo variable "g" (1):
            //add the number at rhs in equations where it is found at rhs
            //exogenized endo variable "e" (5):
            //remove where it is found at   rhs
            //at eq where it is at lhs: put in endogenized instead at lhs AND at rhs

            DateTime t0 = DateTime.Now;

            foreach (string endo in model.m2.endoSubstitution.Keys)
            {
                //slack: iterate KeyValuePair<> instead
                string exo = model.m2.endoSubstitution[endo];
                int exoBtype = model.varsBType[exo + Globals.lagIndicator + "0"].bNumber;
                int endoBtype = model.varsBType[endo + Globals.lagIndicator + "0"].bNumber;
                ArrayList eqsRhsExo = FindEqsWithVarOnRightHandSide(exo);
                ArrayList eqsRhsEndo = FindEqsWithVarOnRightHandSide(endo);
                int eqLhsEndo = FindEqWithVarOnLeftHandSide(endo);
                //for each equation with exo var on rhs
                foreach (int eq in eqsRhsExo)
                {
                    //EquationHelper eh = (EquationHelper)equations[eq];
                    //eh.rhs.Add(exoBtype, "");
                    List<int> al = model.m2.sparseInfoLeftRightSeparated[eq];
                    for (int i = 1; i < al.Count; i++)
                    {
                        int number = al[i];
                        if (number == exoBtype) G.Writeln2("*** ERROR #32108743");
                    }
                    al.Add(exoBtype);
                }

                foreach (int eq in eqsRhsEndo)
                {
                    List<int> al = model.m2.sparseInfoLeftRightSeparated[eq];
                    int toRemoveI = -12345;
                    for (int i = 1; i < al.Count; i++)
                    {
                        int number = al[i];
                        if (number == endoBtype)
                        {
                            toRemoveI = i;
                        }
                    }
                    al.RemoveAt(toRemoveI);
                }
                List<int> al1 = model.m2.sparseInfoLeftRightSeparated[eqLhsEndo];
                al1[0] = exoBtype;
                al1.Add(exoBtype);
                //G.Writeln(exo + " " + endo + " " + eqsRhsEndo.ToString() + " " + eqsRhsExo.ToString() + eqLhsEndo);
            }

            model.m2.sparseInfoSmart = new List<List<int>>();
            model.m2.sparseInfoSmartCondensed = new List<List<int>>();  //creates an identical copy here
            for (int i = 0; i < model.varsBType.Count; i++)
            {
                model.m2.sparseInfoSmart.Add(null);
                model.m2.sparseInfoSmartCondensed.Add(null);
            }
            for (int i = 0; i < model.m2.sparseInfoLeftRightSeparated.Length; i++)
            {
                bool first = true;
                List<int> vars = model.m2.sparseInfoLeftRightSeparated[i];
                foreach (int var in vars)
                {
                    if (first == true)
                    {
                        //first index is left side
                        model.m2.sparseInfoSmart[vars[0]] = new List<int>();
                        model.m2.sparseInfoSmartCondensed[vars[0]] = new List<int>();
                        first = false;
                        continue;
                    }
                    model.m2.sparseInfoSmart[vars[0]].Add(var);
                    model.m2.sparseInfoSmartCondensed[vars[0]].Add(var);
                }
            }

            if (Globals.stackedPrintTimings) G.Writeln2("Ordering...");
            //=================================
            //=================================
            //======== Ordering start =========
            //=================================
            //=================================


            List<List<int>> rowsIndexes = new List<List<int>>();
            List<List<int>> columnsIndexes = new List<List<int>>();
            for (int i = 0; i < model.m2.endogenous.Count; i++)
            {
                rowsIndexes.Add(new List<int>());
                columnsIndexes.Add(new List<int>());
            }

            List<List<int>> rowsIndexes2 = new List<List<int>>();
            List<List<int>> columnsIndexes2 = new List<List<int>>();
            for (int i = 0; i < model.m2.endogenous.Count; i++)
            {
                rowsIndexes2.Add(new List<int>());
                columnsIndexes2.Add(new List<int>());
            }

            //sparseInfoLeftRightSeparated has lhs at [0], content is b[]-type numbers
            foreach (List<int> al2 in model.m2.sparseInfoLeftRightSeparated)
            {
                bool shouldAddOnRightHandSide = false;
                int lhs2 = al2[0];

                if (model.m2.endoSubstitutionBNumbers.ContainsKey(lhs2))
                {
                    shouldAddOnRightHandSide = true;
                    lhs2 = model.m2.endoSubstitutionBNumbers[lhs2];
                    for (int i = 1; i < al2.Count; i++)
                    {
                        if (al2[i] == lhs2) shouldAddOnRightHandSide = false;
                    }
                }

                int lhs = model.m2.fromBNumberToEqNumber[lhs2];
                for (int i = 1; i < al2.Count; i++)
                {
                    int rhsi2 = al2[i];
                    int rhsi = model.m2.fromBNumberToEqNumber[rhsi2];
                    PutIntoIndidenceMatrix(rowsIndexes, columnsIndexes, rowsIndexes2, columnsIndexes2, lhs, rhsi);
                }
                if (shouldAddOnRightHandSide == true)
                {
                    PutIntoIndidenceMatrix(rowsIndexes, columnsIndexes, rowsIndexes2, columnsIndexes2, lhs, lhs);
                }
            }

            model.m2.prologue = new List<int>();
            model.m2.epilogue = new List<int>();
            model.m2.simulRecursive = new List<int>();
            model.m2.simulFeedback = new List<int>();

            List<int> simulRecursive = new List<int>();
            List<int> simulEpi = new List<int>();

            FindRecursive(rowsIndexes, columnsIndexes, model.m2.prologue);
            FindRecursive(columnsIndexes, rowsIndexes, model.m2.epilogue);  //note: should be reversed, see next statement
            model.m2.epilogue.Reverse();

            int orderingIterations = 0;
            for (int i6 = 0; i6 < int.MaxValue; i6++)
            {
                FindDiagonal(rowsIndexes, columnsIndexes, model.m2.simulFeedback);
                if (!Globals.solveNewtonOnlyFeedback) FindRecursive(rowsIndexes, columnsIndexes, simulRecursive);

                //this one is good:
                //These are simple equations with 1 var on right-hand side
                if (!Globals.solveNewtonOnlyFeedback) FindRowsWithSum1(rowsIndexes, columnsIndexes, simulRecursive);


                //this one is bad:
                //These equations may have many right-hand vars, but impact is only in one other equation
                if (1 == 0)
                {
                    FindColsWithSum1(rowsIndexes, columnsIndexes, simulRecursive);
                }

                Heuristic(rowsIndexes, columnsIndexes, model.m2.simulFeedback);

                bool flag = false;
                for (int i = 0; i < columnsIndexes.Count; i++)
                {
                    if (columnsIndexes[i] != null)
                    {
                        flag = true;
                        orderingIterations = i6;
                        break;
                    }
                }
                if (!flag) break;
            }

            if (Globals.solveNewtonOnlyFeedback)
            {
                Program.model.m2.simulFeedback.Sort();  //easier comparable to gauss-seidel inner loop
            }

            //A little bit cheating, since these numbers will always relate to the last .m2 model
            //But never mind, typically only shown for non-fixed model.
            Program.model.modelInfo.endo3 = model.m2.prologue.Count + model.m2.simulFeedback.Count + simulRecursive.Count + model.m2.epilogue.Count;
            Program.model.modelInfo.prologue = model.m2.prologue.Count;
            Program.model.modelInfo.simultaneous = model.m2.simulFeedback.Count + simulRecursive.Count;
            Program.model.modelInfo.simultaneousFeedback = model.m2.simulFeedback.Count;
            Program.model.modelInfo.simultaneousRecursive = simulRecursive.Count;
            Program.model.modelInfo.epilogue = model.m2.epilogue.Count;

            for (int i = 0; i < rowsIndexes2.Count; i++)
            {
                if (!simulRecursive.Contains(i))
                {
                    DeleteRowAndColumn(rowsIndexes2, columnsIndexes2, i);
                }
            }

            FindRecursive(rowsIndexes2, columnsIndexes2, model.m2.simulRecursive);
            FindRecursive(columnsIndexes2, rowsIndexes2, simulEpi);  //this one is empty and should be!! Good test also.

            if (!(simulEpi.Count == 0))
            {
                G.Writeln2("*** ERROR in feedback/recursive");
            }

            //=================================
            //=================================
            //======== Ordering end ===========
            //=================================
            //=================================

            if (Globals.stackedPrintTimings) G.Writeln2("Ordering end");

            simulRecursive = null;  //the ordering is not correct in simulRecursive: we use simulPrologue instead below.
            //at the moment, this is not strictly necessary, but still give a nicer ordering
            //and a good check

            WriteOrderingInfoToFile(rowsIndexes);

            model.m2.fromEqNumberToBNumberRecursiveNEW = new List<int>();
            foreach (int eq in model.m2.simulRecursive)
            {
                model.m2.fromEqNumberToBNumberRecursiveNEW.Add(model.m2.fromEqNumberToBNumber[eq]);
            }
            model.m2.fromBNumberToEqNumberRecursiveNEW = G.CreateArray(model.varsBType.Count, -12345);
            for (int i = 0; i < model.m2.fromEqNumberToBNumberRecursiveNEW.Count; i++)
            {
                int j = (int)model.m2.fromEqNumberToBNumberRecursiveNEW[i];
                model.m2.fromBNumberToEqNumberRecursiveNEW[j] = i;
            }
            model.m2.fromEqNumberToBNumberFeedbackNEW = new int[model.m2.simulFeedback.Count];
            int i1 = -1;
            foreach (int eq in model.m2.simulFeedback)
            {
                i1++;
                model.m2.fromEqNumberToBNumberFeedbackNEW[i1] = model.m2.fromEqNumberToBNumber[eq];
            }

            try
            {
                //TODO: This is a hack, but probably rare with > 1.000.000 b-elements
                model.m2.fromBNumberToEqNumberFeedbackNEW = G.CreateArray(1000000, -12345);  //slack
            }
            catch (Exception e)
            {
                G.Writeln2("*** ERROR: Array size problem in MODEL command");
                throw new GekkoException();
            }

            for (int i = 0; i < model.m2.fromEqNumberToBNumberFeedbackNEW.Length; i++)
            {
                int j = model.m2.fromEqNumberToBNumberFeedbackNEW[i];
                model.m2.fromBNumberToEqNumberFeedbackNEW[j] = i;
            }

            //at this point in feedb2.frm:
            //===================================
            //simulRecursive = 12,11,10,9,8,7,6,5,4
            //simulFeedback = 3,2
            //fromEqNumberToBNumberRecursiveNEW = 13,12,11,10,9,8,7,6,5
            //fromEqNumberToBNumberFeedbackNEW = 4,3
            //===================================
            //equations 0,1 and 13,14 are prologue and epilogue

            //            sparseInfoSmart
            //fy    0	1,2,3,4
            //fy.1  1	null (!endonolag)
            //tg    2	null
            //fi    3	0,3,4
            //fe    4

            //fy = fy.1 + tg + fi + fe
            //fi = fy + fi + fe

            //sæt fy exo og tg endo: ( 0 og 2 skifter plads)

            //tg = fy  (fy.1 + fi + fe)
            //fi = fy + tg + fi + fe

            //tg    0	1,2,3,4
            //fy.1  1	null (!endonolag)
            //fy    2	null
            //fi    3	2,3,4
            //fe    4

            Dictionary<int, string> fromEqNumberToBNumberRecursiveHelper = new Dictionary<int, string>();
            foreach (int i in model.m2.fromEqNumberToBNumberRecursiveNEW) fromEqNumberToBNumberRecursiveHelper.Add(i, null);

            if (Globals.useRfFr)
            {

                if (Globals.stackedPrintTimings) G.Writeln2("RF start");
                //sparseInfoSmartCondensed knows for a recursive var feedback vars
                //it depends upon.
                //Corresponds to RF part of matrix
                //never relevant for goals search, since means are feedback type.
                CaseInsensitiveHashtable checkRecursiveHashtable = new CaseInsensitiveHashtable();
                foreach (int varRows in model.m2.fromEqNumberToBNumberRecursiveNEW)
                {
                    checkRecursiveHashtable.Add(varRows, "1");
                    List<int> varsRows = model.m2.sparseInfoSmartCondensed[varRows];
                    List<int> toRemove = new List<int>();
                    List<int> toAdd = new List<int>();
                    foreach (int varCols in varsRows)
                    {
                        //slack to use a Contains() on a List here?
                        //if (model.m2.fromEqNumberToBNumberRecursiveNEW.Contains(varCols))
                        if (fromEqNumberToBNumberRecursiveHelper.ContainsKey(varCols))
                        {
                            if (!checkRecursiveHashtable.Contains(varCols))
                            {
                                G.Writeln2("*** ERROR in feedback/recursive");
                            }
                            //recursive type: look into which feedback vars have already been
                            //fed into it, and pass them on.
                            foreach (int var2 in model.m2.sparseInfoSmartCondensed[varCols])
                            {
                                if (Array.IndexOf(model.m2.fromEqNumberToBNumberFeedbackNEW, var2) != -1)
                                {
                                    if (!toAdd.Contains(var2))
                                    {
                                        toAdd.Add(var2);
                                    }
                                }
                            }
                            toRemove.Add(varCols);
                        }
                    }
                    RemoveArrayListFromArrayList(varsRows, toRemove);
                    AddArrayListToArrayList(varsRows, toAdd);
                }
                if (Globals.stackedPrintTimings) G.Writeln2("RF end");
            }

            if (Globals.stackedPrintTimings) G.Writeln2("transpose start");
            //transposing matrix
            //never relevant for goals search, since means are feedback type.
            model.m2.sparseInfoSmartCondensedTransposed = new List<List<int>>();
            for (int i = 0; i < model.m2.sparseInfoSmartCondensed.Count; i++)
            {
                model.m2.sparseInfoSmartCondensedTransposed.Add(null);
                if (model.m2.sparseInfoSmartCondensed[i] != null)
                {
                    model.m2.sparseInfoSmartCondensedTransposed[i] = new List<int>();
                }
            }
            if (Globals.stackedPrintTimings) G.Writeln2("transpose end");

            if (Globals.useRfFr)
            {
                if (Globals.stackedPrintTimings) G.Writeln2("FR start");

                //Corresponds to FR part of matrix
                //never relevant for goals search, since means are feedback type.
                for (int i = 0; i < model.varsBType.Count; i++)
                {
                    if (model.m2.sparseInfoSmartCondensed[i] != null)
                    {
                        List<int> row = model.m2.sparseInfoSmartCondensed[i];
                        foreach (int j in row)
                        {
                            if (!(model.m2.sparseInfoSmartCondensedTransposed[j]).Contains(i))
                            {
                                //((ArrayList)model.m2.sparseInfoSmartCondensedTransposed[j]).Add(i);

                                //slack to use a Contains() on a List here?
                                //if (model.m2.fromEqNumberToBNumberRecursiveNEW.Contains(i))
                                if (fromEqNumberToBNumberRecursiveHelper.ContainsKey(i))
                                {
                                    //this is an extra condition, implying that we only get
                                    //RF-type array for all the first n columns
                                    //the transposed version is not identical to non-transposed
                                    (model.m2.sparseInfoSmartCondensedTransposed[j]).Add(i);
                                }
                            }
                        }
                    }
                }

                if (Globals.stackedPrintTimings) G.Writeln2("FR end");
            }

            //never relevant for goals search, since means are feedback type.
            model.m2.sparseInfoSmartTransposed = new List<List<int>>();
            for (int i = 0; i < model.m2.sparseInfoSmart.Count; i++)
            {
                model.m2.sparseInfoSmartTransposed.Add(null);
                if (model.m2.sparseInfoSmart[i] != null)
                {
                    model.m2.sparseInfoSmartTransposed[i] = new List<int>();
                }
            }

            //never relevant for goals search, since means are feedback type.
            for (int i = 0; i < model.varsBType.Count; i++)
            {
                if (model.m2.sparseInfoSmart[i] != null)
                {
                    List<int> row = model.m2.sparseInfoSmart[i];
                    foreach (int j in row)
                    {
                        if (!(model.m2.sparseInfoSmartTransposed[j]).Contains(i))
                        {
                            //if (fromEqNumberToBNumberFeedbackNEW.Contains(i))
                            if (Array.IndexOf(model.m2.fromEqNumberToBNumberFeedbackNEW, i) != -1)
                            {
                                //this is an extra condition, implying that we only get
                                //FR-type array for all the last n columns
                                //the transposed version is not identical to non-transposed
                                (model.m2.sparseInfoSmartTransposed[j]).Add(i);
                            }
                        }
                    }
                }
            }

            //       feedb    recurs
            // -------------|----------
            // feedb   FF1  |  FR1
            //        ------|------
            // recur   RF1  |  RR1
            //--------------|----------
            //
            //
        }

        private static int FindEqWithVarOnLeftHandSide(string endo)
        {
            int eqEndo = -12345;
            foreach (EquationHelper eh in Program.model.equations)
            {
                if (G.equal(eh.lhs, endo))
                {
                    eqEndo = eh.equationNumber;
                }
            }
            if (eqEndo == -12345) G.Writeln2("*** ERROR: variable " + endo + " is not found as left-hand side var");
            return eqEndo;
        }

        private static void WriteOrderingInfoToFile(List<List<int>> rowsIndexes)
        {
            string path = Program.GetModelInfoPath();

            // Determine whether the directory exists, else create it (used for model related files)
            if (!Directory.Exists(path))
            {
                Directory.CreateDirectory(path);
            }

            using (FileStream fs = WaitForFileStream(path + "\\" + Globals.modelFileName.Replace(".frm", "") + ".ordering", GekkoFileReadOrWrite.Write))
            using (StreamWriter res = G.GekkoStreamWriter(fs))
            {
                res.WriteLine("Number of endogenous  = " + G.IntFormat(rowsIndexes.Count, 7));
                res.WriteLine("----------------------------------");
                res.WriteLine("Prologue              = " + G.IntFormat(model.m2.prologue.Count, 7));
                res.WriteLine("Simultaneous feedback = " + G.IntFormat(model.m2.simulFeedback.Count, 7));
                res.WriteLine("Simultanous recursive = " + G.IntFormat(model.m2.simulRecursive.Count, 7));
                res.WriteLine("Epilogue              = " + G.IntFormat(model.m2.epilogue.Count, 7));
                res.WriteLine();
                res.Write("The prologue variables can be considered a kind of pre-model of recursive equations feeding into ");
                res.Write("the simultanous block. The epilogue variables can be considered a kind of recursive after-model, depending ");
                res.WriteLine("upon the simultanous block, but not being simultanous itself.");
                res.Write("Inside the simulatenous block, there is a (typically) small kernel of intertwined variables being ");
                res.Write("heavily simultanous: the feedback set. The simultaneous recursive set is a set of simultaneous variables ");
                res.Write("being truly simultanous, but can be understood as being recursive relative to the feedback set. That is, ");
                res.Write("given the feedback (and prologue) variables, the simultanous recursive set can be computed as a (typically) ");
                res.Write("long chain of recursive equations depending only upon each other. These properties are used to reduce the ");
                res.WriteLine("dimensionality of the problem when using the Newton method for goals/means etc.");
                res.WriteLine("");
                res.WriteLine("--- Prologue variables (" + model.m2.prologue.Count + ") ---");
                PrintEquationLeftHandSideNames(model.m2.prologue, res);
                res.WriteLine();
                res.WriteLine("--- Simultaneous block #1 of 2: feedback variables (" + model.m2.simulFeedback.Count + ") ---");
                PrintEquationLeftHandSideNames(model.m2.simulFeedback, res);
                res.WriteLine();
                res.WriteLine("--- Simultaneous block #2 of 2: recursive variables (" + model.m2.simulRecursive.Count + ") ---");
                PrintEquationLeftHandSideNames(model.m2.simulRecursive, res);
                res.WriteLine();
                res.WriteLine("--- Epilogue variables (" + model.m2.epilogue.Count + ") ---");
                PrintEquationLeftHandSideNames(model.m2.epilogue, res);
                res.WriteLine();
                res.Flush();
            }
        }

        private static void PutIntoIndidenceMatrix(List<List<int>> rowsIndexes, List<List<int>> columnsIndexes, List<List<int>> rowsIndexes2, List<List<int>> columnsIndexes2, int lhs, int rhsi)
        {
            rowsIndexes[lhs].Add(rhsi);
            columnsIndexes[rhsi].Add(lhs);
            rowsIndexes2[lhs].Add(rhsi);
            columnsIndexes2[rhsi].Add(lhs);
        }

        private static void PrintEquationLeftHandSideNames(List<int> al, StreamWriter res)
        {
            foreach (int i in al)
            {
                int tmp = model.m2.fromEqNumberToBNumber[i];
                string var = model.varsBTypeInverted[tmp];
                TwoStrings ts = getVariableAndLag(var);
                string var2 = G.GetUpperLowerCase(ts.s1);
                res.WriteLine("  " + var2);
            }
        }

        private static void RemoveArrayListFromArrayList(ArrayList varsRows, ArrayList toRemove)
        {
            foreach (int i in toRemove)
            {
                varsRows.Remove(i);
            }
        }

        private static void RemoveArrayListFromArrayList(List<int> varsRows, List<int> toRemove)
        {
            foreach (int i in toRemove)
            {
                varsRows.Remove(i);
            }
        }

        private static void AddArrayListToArrayList(ArrayList varsRows, ArrayList toAdd)
        {
            foreach (int i in toAdd)
            {
                if (!varsRows.Contains(i))
                {
                    varsRows.Add(i);
                }
            }
        }

        private static void AddArrayListToArrayList(List<int> varsRows, List<int> toAdd)
        {
            foreach (int i in toAdd)
            {
                if (!varsRows.Contains(i))
                {
                    varsRows.Add(i);
                }
            }
        }

        private static void Heuristic(List<List<int>> rowsIndexes, List<List<int>> columnsIndexes, List<int> feedback)
        {
            int max2 = -12345;
            int imax = -12345;
            for (int i = 0; i < columnsIndexes.Count; i++)
            {
                List<int> a = columnsIndexes[i];
                if (a != null)
                {
                    List<int> b = rowsIndexes[i];
                    int sza = a.Count;
                    int szb = b.Count;
                    int prod = sza * szb;  //seems to be good rule
                    //int prod = szb; //for jul05 reduces feedb set from 267 to 240, but is slower overall. Also for saffier.
                    if (prod > max2)
                    {
                        max2 = prod;
                        imax = i;
                    }
                }
            }
            if (imax != -12345)
            {
                feedback.Add(imax);
                DeleteRowAndColumn(rowsIndexes, columnsIndexes, imax);
            }
        }

        private static void FindDiagonal(List<List<int>> rowsIndexes, List<List<int>> columnsIndexes, List<int> fb)
        {
            for (int i = 0; i < rowsIndexes.Count; i++)
            {
                List<int> a = rowsIndexes[i];
                if (a != null)
                {
                    if (a.Contains(i))
                    {
                        fb.Add(i);
                        DeleteRowAndColumn(rowsIndexes, columnsIndexes, i);
                    }
                }
            }
        }

        private static void FindColsWithSum1(List<List<int>> rowsIndexes, List<List<int>> columnsIndexes, List<int> rec)
        {
            for (int i = 0; i < columnsIndexes.Count; i++)
            {
                List<int> a = columnsIndexes[i];
                if (a != null)
                {
                    if (a.Count == 1)
                    {
                        int subst = (int)a[0];
                        if (i != subst)
                        {

                            rec.Add(i);


                            if (!(rowsIndexes[subst]).Contains(subst))
                            {
                                (rowsIndexes[subst]).Add(subst);
                            }
                            if (!(columnsIndexes[subst]).Contains(subst))
                            {
                                (columnsIndexes[subst]).Add(subst);
                            }

                            DeleteRowAndColumn(rowsIndexes, columnsIndexes, i);
                        }
                    }
                }
            }
        }

        private static void FindRowsWithSum1(List<List<int>> rowsIndexes, List<List<int>> columnsIndexes, List<int> rec)
        {
            for (int i = 0; i < rowsIndexes.Count; i++)
            {
                List<int> a = rowsIndexes[i];
                if (a != null)
                {
                    if (a.Count == 1)
                    {
                        int subst = (int)a[0];  //the right-hand var (y in c = 0.8 y)
                        if (i != subst)  //should not be equal -- meaning it depends only on itself
                        {
                            //this is an equation like "c = 0.8 y"
                            rec.Add(i);  //add "c" to recursive set
                            List<int> b = columnsIndexes[i];
                            for (int j = 0; j < b.Count; j++)
                            {
                                //for each equation containing "c"
                                int c = (int)b[j];  //the left-hand side of that eq (e.g. the equation i = 0.5 c)
                                if (!(rowsIndexes[c]).Contains(subst))
                                {
                                    //if equation "i" does not contain "y", add it
                                    (rowsIndexes[c]).Add(subst);
                                }
                                if (!(columnsIndexes[subst]).Contains(c))
                                {
                                    //if var "y" does not appear in equaton "i" add it
                                    (columnsIndexes[subst]).Add(c);
                                }


                            }
                            DeleteRowAndColumn(rowsIndexes, columnsIndexes, i);
                        }
                    }
                }
            }
        }

        private static void FindRecursive(List<List<int>> rowsIndexes, List<List<int>> columnsIndexes, List<int> pro)
        {
            while (true)
            {
                bool hit = false;
                for (int i = 0; i < rowsIndexes.Count; i++)
                {

                    List<int> a = rowsIndexes[i];
                    if (a != null && a.Count == 0)
                    {
                        hit = true;
                        //rowsum is 0 for this row
                        pro.Add(i);
                        DeleteRowAndColumn(rowsIndexes, columnsIndexes, i);
                    }
                }
                if (!hit) break;
            }
        }

        private static void DeleteRowAndColumn(List<List<int>> rowsIndexes, List<List<int>> columnsIndexes, int i)
        {
            List<int> b = columnsIndexes[i];
            for (int j = 0; j < b.Count; j++)
            {
                int c = (int)b[j];
                List<int> d = rowsIndexes[c];
                if (!d.Contains(i)) G.Writeln("error");
                d.Remove(i);
            }

            List<int> b2 = rowsIndexes[i];
            for (int j = 0; j < b2.Count; j++)
            {
                int c = (int)b2[j];
                List<int> d = columnsIndexes[c];
                if (!d.Contains(i)) G.Writeln("error");
                d.Remove(i);
            }


            rowsIndexes[i] = null;
            columnsIndexes[i] = null;
        }

        private static void PrintMatrix(IElementalAccessMatrix ic)
        {
            for (int i1 = 0; i1 < ic.RowCount; i1++)
            {
                for (int i2 = 0; i2 < ic.ColumnCount; i2++)
                {
                    double val = ic.GetValue(i1, i2);
                    //int val1 = (int)val;
                    G.Write(val + " ");
                }
                G.Writeln();
            }
        }

        private static void PrintVector(IElementalAccessVector v)
        {
            for (int i1 = 0; i1 < v.Length; i1++)
            {

                double val = v.GetValue(i1);
                int val1 = (int)val;
                G.Write(val1 + " ");
            }
            G.Writeln();
        }

        private static ArrayList FindEqsWithVarOnRightHandSide(string var1)
        {
            ArrayList eqs = new ArrayList();
            foreach (EquationHelper eh in Program.model.equations)
            {
                foreach (string rhsVar in eh.precedentsWithLagIndicator.Keys)
                {
                    if (G.equal(rhsVar, var1 + Globals.lagIndicator + "0"))
                    {
                        eqs.Add(eh.equationNumber);
                    }
                }
            }
            return eqs;
        }

        private static void UpdHelper(TimeSeries ts, String op, GekkoTime per, double inputVal, TimeSeries tsOld, ESeriesUpdTypes updType)
        {
            GekkoTime PerMinusOne = per.Add(-1);
            //todo: also do updprt here.

            if ((op == "=" && updType == ESeriesUpdTypes.none) || updType == ESeriesUpdTypes.n)
            {
                //TODO: sequence
                ts.SetData(per, inputVal);
            }
            else if (op == "%" || updType == ESeriesUpdTypes.p)
            {
                ts.SetData(per, ts.GetData(PerMinusOne) * (1 + inputVal / 100d));
            }
            else if (op == "*")
            {
                ts.SetData(per, ts.GetData(per) * inputVal);
            }
            else if (updType == ESeriesUpdTypes.q)
            {
                ts.SetData(per, ts.GetData(per) * (1 + inputVal / 100d));  //different from * operator
            }
            else if (op == "+" || updType == ESeriesUpdTypes.m)
            {
                ts.SetData(per, ts.GetData(per) + inputVal);
            }
            else if (op == "^" || updType == ESeriesUpdTypes.d)
            {
                ts.SetData(per, ts.GetData(PerMinusOne) + inputVal);
            }
            else if (op == "#" || updType == ESeriesUpdTypes.mp)
            {
                //we have to use stored old growth rate for a[var,t], because of the complexity of the operator
                double ol = tsOld.GetData(per);
                double ol1 = tsOld.GetData(PerMinusOne);
                double tslag = ts.GetData(PerMinusOne);
                ts.SetData(per, tslag * (ol / ol1 + inputVal / 100d));
            }
            else
            {
                G.Writeln2("*** ERROR: Unrecognized operator in SERIES command");
                throw new GekkoException();
            }
        }

        public static void EmitCodeFromANTLR(string text, string fileName, bool isLibrary, P p)
        {
            //#98073245298345
            //Here, we are translating (1) a gui oneliner, (2) a gui command block, or a gcm file (that might be .ini or called with LIBRARY).
            //So we wipe out the uFunctions, to have a clean desk.
            //We do not wipe it if it is a library, since it has already been wiped just before (LIBRARY must be the first command).
            if (!isLibrary) Globals.uFunctionStorageCs = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);

            int max = 1;
            if (G.equal(Program.options.interface_debug, "dialog")) max = int.MaxValue;  //should suffice as tries :-)

            for (int i = 0; i < max; i++)  //number of tries to run a cmd file that has parser/lexer errors
            {
                string islooping = "parser";
                if (i > 0) islooping = "parser_islooping";

                ConvertHelper ch = null;

                ParseHelper ph = new ParseHelper();
                ph.commandsText = text;
                ph.fileName = fileName;
                ph.isModel = false;

                string commandLinesFlat = null;
                //It is either txt or fileName, depending of how method is called

                List<string> commandLines = new List<string>();

                if (Globals.runningOnTTComputer && Globals.showTimings) G.Writeln("Handle start: " + G.SecondsFormat((DateTime.Now - p.startingTime).TotalMilliseconds), Color.LightBlue);

                if (fileName != "")
                {
                    //a file
                    if (!fileName.Contains("tablecode." + Globals.defaultCommandFileExtension))  //don't count an autogenerated table as a cmd file
                    {
                        p.hasBeenCmdFile = true;
                    }
                    string input = GetTextFromFileWithWait(fileName);
                    commandLinesFlat = HandleObeyFiles2(input);
                    ph.isOneLinerFromGui = false;
                }
                else if (text != "")
                {
                    //oneliner from GUI
                    if (text.Contains("\n"))
                    {
                        commandLinesFlat = HandleObeyFiles2(text);  //is handled exactly as if it was a file
                        ph.isOneLinerFromGui = false;  //is a more-liner........
                    }
                    else
                    {
                        string text0 = HandleOneLiners(text);
                        commandLinesFlat = HandleObeyFiles2(text0);
                        ph.isOneLinerFromGui = true;
                        p.isOneLinerFromGui = true;
                    }
                }

                ph.commandsText = commandLinesFlat;
                p.SetCommandFileText(commandLinesFlat);

                try
                {
                    if (Globals.runningOnTTComputer && Globals.showTimings) G.Writeln("Parse start: " + G.SecondsFormat((DateTime.Now - p.startingTime).TotalMilliseconds), Color.LightBlue);
                    p.lastFileSentToANTLR = fileName;
                    p.SetLastFileSentToANTLR(fileName);
                    
                    ch = Gekko.Parser.Gek.ParserGekCreateAST.CreateAST(ph, p);
                    if (Globals.runningOnTTComputer && Globals.showTimings) G.Writeln("Parse end: " + G.SecondsFormat((DateTime.Now - p.startingTime).TotalMilliseconds), Color.LightBlue);
                }
                catch (Exception e)
                {
                    if (G.equal(Program.options.interface_debug, "dialog"))
                    {
                        string eh = Program.ErrorHandling(islooping, p, false);

                        if (eh == "stop")
                        {
                            //throw new GekkoException(); //this will make a double error -- but the other one will be identified later on (both text and filename are null) and skipped -- a little bit hacky, but oh well...
                            throw;
                        }
                        else if (eh == "retry")
                        {
                            continue;  //try again
                        }
                        else
                        {
                            G.Writeln2("*** ERROR: Strange error in cmd convert -- please report this to the developer");
                            //throw new GekkoException();
                            throw;
                        }
                    }
                    else
                    {
                        string eh = Program.ErrorHandling(islooping, p, true);
                        throw new GekkoException(); //this will make a double error -- but the other one will be identified later on (both text and filename are null) and skipped -- a little bit hacky, but oh well...
                    }
                }

                ch.commandsText = commandLinesFlat;
                if (fileName == "") Globals.commandMemory.storage.AppendLine(text); //is syntax-ok, but may run-time fail

                if (isLibrary)
                {
                    //skip it, there will be no code, since code outside functions is not allowed in gcm files storing user functions (called with LIBRARY)
                }
                else
                {
                    Gekko.Parser.Gek.ParserGekCompileAndRunAST.CompileAndRunAST(ch, p);
                }

                break;  //if we get to here, everything is ok so break the file-trying loop
            }
            if (!G.IsUnitTesting()) ShowPeriodInStatusField("");
        }

        public static void PrintOptions(string path)
        {
            Program.options.Write(path);
        }

        public static List<string> CreateNewList(List<string> listItems2, string name2)
        {
            List<string> newList = null;

            IVariable temp2 = null; Program.scalars.TryGetValue(Globals.symbolList + name2, out temp2);

            if (temp2 == null)
            {
                Program.scalars.Add(Globals.symbolList + name2, new MetaList(listItems2));
                newList = listItems2;
            }
            else
            {
                //keeps the same list object.
                List<string> temp = O.GetMetaList(temp2).list;
                temp.Clear();
                temp.AddRange(listItems2);
                newList = temp;
            }
            return newList;  //this is used if the list inside needs to be tampered with afterwards
        }



        public static List<string> MatchRangeInDatabank(string s1, string s2, Databank db)
        {
            List<string> input = new List<string>();
            input.AddRange(db.storage.Keys);
            string endsWith = null;
            if (Program.options.freq != EFreq.Annual) endsWith = Globals.freqIndicator + G.GetFreq(Program.options.freq);
            List<string> temp = Program.MatchRange(s1, s2, input, endsWith);
            return temp;
        }

        public static List<string> MatchRange(string s1, string s2, List<string> input, string endsWith)
        {
            List<string> temp = new List<string>();
            if (endsWith == null)
            {
                foreach (string s in input)
                {
                    if (string.Compare(s, s1, true) >= 0 && string.Compare(s, s2, true) <= 0)
                    {
                        temp.Add(s);
                    }
                }
            }
            else
            {
                foreach (string s in input)
                {
                    if (!s.EndsWith(endsWith)) continue;
                    string ss = s.Substring(0, s.Length - endsWith.Length);
                    if (string.Compare(ss, s1, true) >= 0 && string.Compare(ss, s2, true) <= 0)
                    {
                        temp.Add(ss);
                    }
                }
            }
            temp.Sort(StringComparer.OrdinalIgnoreCase);
            return temp;
        }

        public static List<TimeSeries> GetTimeSeriesFromStringWildcard(string s)
        {
            return GetTimeSeriesFromStringWildcard(s, null);
        }

        public static List<TimeSeries> GetTimeSeriesFromStringWildcard(string s, string defaultBank)
        {
            return GetTimeSeriesFromStringWildcard(s, defaultBank, false);  //no ignore per default
        }

        //Can be "adambk:fX*2"
        //May return 0 items if wildcard does not exist
        //May be used without wildcard: "adambk:fy", then it is similar to GetTimeSeriesFromString() -> will return empty list if variable does not exist.
        public static List<TimeSeries> GetTimeSeriesFromStringWildcard(string s, string defaultBank, bool ignoreNonExistingSeries)
        {
            List<TimeSeries> listTs = new List<TimeSeries>();
            List<BankNameVersion> list = GetInfoFromStringWildcard(s, defaultBank);
            //See #89052349875, maybe merge it
            foreach (BankNameVersion bnv in list)
            {
                Databank db = null;
                if (bnv.bank == null) db = Program.databanks.GetFirst();
                else
                {
                    db = Program.databanks.GetDatabank(bnv.bank);
                    if (db == null)
                    {
                        G.Writeln2("*** ERROR: Could not find databank '" + bnv.bank + "'");
                        throw new GekkoException();
                    }
                }
                TimeSeries ts = db.GetVariable(bnv.name);
                if (ts == null && !ignoreNonExistingSeries)
                {                    
                    G.Writeln2("*** ERROR: Could not find timeseries '" + bnv.name + "' in databank '" + bnv.bank + "'");
                    throw new GekkoException();
                }
                listTs.Add(ts);
            }            
            return listTs;
        }

        public static List<BankNameVersion> GetInfoFromStringWildcard(string s, string defaultBank)
        {
            return GetInfoFromStringWildcard(s, defaultBank, true);
        }

        public static List<BankNameVersion> GetInfoFromStringWildcard(string s, string defaultBank, bool decorateWithFirstDatabankName)
        {

            ExtractBankAndRestHelper h = null;
            if (decorateWithFirstDatabankName) h = Program.ExtractBankAndRest(s, EExtrackBankAndRest.OnlyStrings);
            else h = Program.ExtractBankAndRest(s, EExtrackBankAndRest.OnlyStringNoFirstName);

            string varName = h.name;
            string bank = h.bank;
            bank = PerhapsOverrideWithDefaultBankName(defaultBank, h.hasColon, bank);

            List<BankNameVersion> list = new List<Gekko.BankNameVersion>();
                        
            if (varName.Contains("*") || varName.Contains("?"))
            {
                Databank db = Program.databanks.GetDatabank(bank);
                if (db == null)
                {
                    G.Writeln2("*** ERROR: Databank '" + bank + "' could not be found");
                    throw new GekkoException();
                }
                //This could be sped up if we returned List<TimeSeries> from MatchWildcardInDatabank().
                //We do too many lookups here, but never mind...
                List<string> names = Program.MatchWildcardInDatabank(varName, db);
                foreach (string s2 in names)
                {
                    BankNameVersion bnv = new BankNameVersion();
                    bnv.bank = bank;
                    bnv.name = s2;
                    if (bnv.name != null && bnv.name != "") list.Add(bnv);
                }
            }
            else if (varName.Contains(".."))
            {
                string[] ss2 = varName.Split(new string[] { ".." }, StringSplitOptions.None);
                ScalarString ss = new ScalarString(Globals.indexerAloneCheatString);
                IVariable xx = ss.Indexer(new IVariablesFilterRange(new ScalarString(bank + ":" + ss2[0]), new ScalarString(ss2[1])), Globals.tNull);
                Databank db = Program.databanks.GetDatabank(bank);
                if (db == null)
                {
                    G.Writeln2("*** ERROR: Databank '" + bank + "' could not be found");
                    throw new GekkoException();
                }
                List<string> names = xx.GetList();
                foreach (string s2 in names)
                {
                    BankNameVersion bnv = new BankNameVersion();
                    bnv.bank = bank;
                    bnv.name = s2;
                    if (bnv.name != null && bnv.name != "") list.Add(bnv);
                }
            }
            else
            {
                //Databank db = Program.databanks.GetDatabank(bank);
                //if (db == null)
                //{
                //    G.Writeln2("*** ERROR: Databank '" + bank + "' could not be found");
                //    throw new GekkoException();
                //}
                //TimeSeries temp = db.GetVariable(varName);
                //if (temp != null) list.Add(temp);  //returns 0-item list, not null list.

                BankNameVersion bnv = new BankNameVersion();
                bnv.bank = bank;
                bnv.name = varName;
                if (bnv.name != null && bnv.name != "") list.Add(bnv);
            }

            return list;
        }

        public static string PerhapsOverrideWithDefaultBankName(string defaultBank, bool hasColon, string bank)
        {

            if (!hasColon)
            {
                if (defaultBank != null)
                {
                    bank = defaultBank;
                }
            }
            return bank;
        }

        public static TimeSeries FindOrCreateTimeseries(string bank, string variable, O.ECreatePossibilities isLhsSoCanAutoCreate, bool hasColon, bool isReadingDatabank)
        {
            //Looks for the timeseries, and if not existing it will be created if starting with 'xx'
            //Has an overload used for reading tsd and PCIM files etc.

            if (variable.Contains("."))
            {
                G.Writeln2("*** ERROR: Malformed name: '" + variable + "'");
                G.Writeln("           Dot freqs like .q or .m are not supported yet, please use 'OPTION freq'", Color.Red);
                throw new GekkoException();
            }

            TimeSeries ts = null;

            if (isLhsSoCanAutoCreate == O.ECreatePossibilities.Can || isLhsSoCanAutoCreate == O.ECreatePossibilities.Must)
            {
                //Is on left side of = in SERIES or UPD, for instance SERIES newts = ... or UPD newts = ...
                //No matter if databank search is active or not
                Databank db = Program.databanks.GetDatabank(bank);
                if (db == null)
                {
                    G.Writeln2("*** ERROR: Databank '" + bank + "' could not be found.");
                    throw new GekkoException();
                }
                ts = db.GetVariable(variable);

                if (ts == null)
                {
                    //TODO: isReadingDatabank could be removed and replaced by .Must
                    if (isLhsSoCanAutoCreate == O.ECreatePossibilities.Must || isReadingDatabank || Program.options.databank_create_auto || variable.ToLower().StartsWith("xx"))
                    {
                        //See also similar code regarding CREATE
                        ts = new TimeSeries(Program.options.freq, variable);
                        //ts.dimensions = 0;  //to start with, else it is -12345. May later on be changed to > 0 via an indexer.
                        //if (!Globals.globalPeriodStart.IsNull())
                        //{
                        //    //WHY is this done. For efficiency afterwards??
                        //    //TO get start/end date??
                        //    foreach (GekkoTime gt in new GekkoTimeIterator(Globals.globalPeriodStart, Globals.globalPeriodEnd))
                        //    {
                        //        ts.SetData(gt, double.NaN);
                        //    }
                        //}
                        //We know the timeseries does not already exist
                        db.AddVariable(ts);
                    }
                    else
                    {
                        G.Writeln2("*** ERROR: Timeseries '" + variable + "' could not be auto-created in '" + bank + "' databank");                        
                        G.Writeln("           You should use CREATE to create the timeseries first, or alternatively use");
                        G.Writeln("           'MODE data', or set 'OPTION databank create auto = yes'");
                        throw new GekkoException();
                    }
                }
            }
            else
            {
                //canAutoCreate = false
                //So we are on the right hand side of = in SERIES, or in PRT or other.
                //Here, searching is possible!
                if (Program.options.databank_search && !hasColon)
                {
                    //So we are on the right side of = in GENR (or in PRT, ...), and the varible has no bank indicated
                    //This means we can search the banks for the variable.

                    for (int i = 0; i < Program.databanks.storage.Count; i++)
                    {
                        if (i == 1) continue;  //The Ref databank IS NEVER SEARCHED!!
                        Databank db2 = Program.databanks.storage[i];
                        ts = db2.GetVariable(variable);
                        if (ts != null) break;
                    }
                    if (ts == null)
                    {
                        ReportTimeseriesNotFound(variable, null);
                        throw new GekkoException();
                    }
                }
                else
                {
                    //simple
                    Databank db = Program.databanks.GetDatabank(bank);
                    if (db == null)
                    {
                        string s = "*** ERROR: Databank '" + bank + "' could not be found.";
                        {
                            G.Writeln2(s);
                            throw new GekkoException();
                        }
                    }
                    ts = db.GetVariable(variable);
                    if (ts == null)
                    {
                        if (O.isTableCall && Program.options.table_ignoremissingvars)
                        {
                            //ignore if variable does not exist
                            ts = new TimeSeries(Program.options.freq, "temp_timeseries_not_to_be_used");
                        }
                        else
                        {
                            ReportTimeseriesNotFound(variable, bank);
                            throw new GekkoException();
                        }
                    }
                }
            }

            return ts;

        }

        private static void ReportTimeseriesNotFound(string variable, string bank)
        {
            string b = "any open";
            if (bank != null) b = "'" + bank + "'";
            G.Writeln2("*** ERROR: " + G.GetFreqString() + " timeseries '" + variable + "' could not be found in " + b + " databank");

            bool changeFreq = false;

            foreach (EFreq freq in Enum.GetValues(typeof(EFreq)))
            {
                List<string> found = new List<string>();                
                foreach (Databank db in Program.databanks.storage)
                {
                    TimeSeries ts = db.GetVariable(freq, variable);
                    if (ts != null)
                    {
                        found.Add("'" + db.aliasName + "'");
                        if (freq != Program.options.freq) changeFreq = true;  //mention that freq change could be used
                    }
                }
                if (found.Count > 0)
                {
                    G.Writeln("       --> Note: " + G.GetFreqString(freq) + " timeseries '" + variable + "' exists in: " + G.GetListWithCommas(found), Color.Red);
                }
            }

            if (changeFreq)
            {
                G.Writeln("       --> Note: You may change frequency by means of OPTION freq = ... ;", Color.Red);
            }

            //Program.databanks.storage

        }

        //See also O.GetTimeSeries()
        public static TimeSeries GetTimeSeriesFromString(string s, O.ECreatePossibilities isLhsSoCanAutoCreate)
        {
            ExtractBankAndRestHelper h = ExtractBankAndRest(s, EExtrackBankAndRest.OnlyStrings);
            TimeSeries ts = FindOrCreateTimeseries(h.bank, h.name, isLhsSoCanAutoCreate, h.hasColon, false);
            return ts;
        }

        public static List<string> MatchWildcard(string wildcard, List<string> input, string endsWith)
        {
            //endsWith might be for instance "=q" to indicate quarters. Can also be null.
            Wildcard wc = new Wildcard(wildcard, RegexOptions.IgnoreCase);
            List<string> found = new List<string>();

            if (endsWith == null)
            {
                foreach (string s in input)
                {
                    if (s.Contains(Globals.freqIndicator)) continue;  //#09875230984, filters out fy=q, fy=m, etc. A bit of a hack. Could also check the second-last char to see if it is '='
                    if (wc.IsMatch(s)) found.Add(s);
                }
            }
            else
            {
                foreach (string s in input)
                {
                    if (!s.EndsWith(endsWith)) continue;
                    string s2 = s.Substring(0, s.Length - endsWith.Length);
                    if (wc.IsMatch(s2))
                    {
                        found.Add(s2);
                    }
                }
            }
            found.Sort(StringComparer.OrdinalIgnoreCase);
            return found;
        }

        public static List<string> MatchWildcardInDatabank(string wildcard, Databank db)
        {
            List<string> input = new List<string>();
            
            //input.AddRange(db.storage.Keys);
            foreach (KeyValuePair<string, TimeSeries> kvp in db.storage)
            {
                if (!kvp.Value.IsGhost()) input.Add(kvp.Key);  //do not look at the ghosts here!
            }

            string endsWith = null;
            if (Program.options.freq != EFreq.Annual) endsWith = Globals.freqIndicator + G.GetFreq(Program.options.freq);
            List<string> output = Program.MatchWildcard(wildcard, input, endsWith);
            return output;
        }

        public static void MaybePlaySound(P p)
        {
            if (Program.options.interface_sound == false) return;
            if (p.hasBeenCmdFile == false) return;
            //if (p.hasBeenIsstartCmdFile == true) return;
            int sec = Program.options.interface_sound_wait;
            if ((DateTime.Now - p.timeAtLastUserInteraction).TotalMilliseconds / 1000d > (double)sec)
            {
                PlaySound();
                p.timeAtLastUserInteraction = DateTime.Now;
            }
        }

        public static void PlaySound()
        {
            System.Media.SoundPlayer simpleSound = new System.Media.SoundPlayer(Application.StartupPath + "\\images\\" + Program.options.interface_sound_type + ".wav");
            simpleSound.Play();
        }

        public static void ShowPeriodInStatusField(string s)
        {
            if (G.IsUnitTesting()) return;

            string s1 = "";
            //TODO: make a smart trim procedure
            if (s.Length > 90)
            {
                s1 = s.Remove(88);
                s1 += "...";
            }
            else
            {
                s1 = s;
            }

            string start = "";
            string end = "";

            start = G.FromDateToString(Globals.globalPeriodStart);
            end = G.FromDateToString(Globals.globalPeriodEnd);

            string f = G.GetFreqString();

            string workingFolder = "";
            string banks = "";
            if (s1.Equals(""))
            {
                int wCount = Program.databanks.GetFirst().storage.Count;  
                int rCount = Program.databanks.GetRef().storage.Count;  
                string originalDataFileWork = "[empty]";
                string originalDataFileBaseline = "[empty]";
                string w = GetDatabankFileNameWithPath(Program.databanks.GetFirst().aliasName);
                string b = GetDatabankFileNameWithPath(Program.databanks.GetRef().aliasName);
                if (w != null) originalDataFileWork = w;
                if (b != null) originalDataFileBaseline = b;
                string banks1 = "";
                string banks2 = "";

                if (originalDataFileWork != "") banks1 = originalDataFileWork;
                try
                {
                    banks1 = Path.GetFileName(banks1);
                }
                catch { }
                if (banks1.EndsWith(".tsd", StringComparison.OrdinalIgnoreCase)) banks1 = banks1.Substring(0, banks1.Length - ".tsd".Length);
                if (banks1.EndsWith("." + Globals.extensionDatabank, StringComparison.OrdinalIgnoreCase)) banks1 = banks1.Substring(0, banks1.Length - Globals.extensionDatabank.Length - 1);
                //TODO: make a smart trim procedure

                if (banks1.Length > 30)
                {
                    string ss1 = banks1.Substring(0, 17);
                    string ss2 = banks1.Substring(banks1.Length - 10);
                    banks1 = ss1 + "..." + ss2;
                }
                if (originalDataFileBaseline != "") banks2 = originalDataFileBaseline;
                try
                {
                    banks2 = Path.GetFileName(banks2);
                }
                catch { }
                if (banks2.EndsWith(".tsd", StringComparison.OrdinalIgnoreCase)) banks2 = banks2.Substring(0, banks2.Length - 4);
                if (banks2.EndsWith("." + Globals.extensionDatabank, StringComparison.OrdinalIgnoreCase)) banks2 = banks2.Substring(0, banks2.Length - Globals.extensionDatabank.Length - 1);
                if (banks2.Length > 30)
                {
                    string ss1 = banks2.Substring(0, 17);
                    string ss2 = banks2.Substring(banks2.Length - 10);
                    banks2 = ss1 + "..." + ss2;

                }

                if (wCount == 0) banks1 = "[empty]";
                if (rCount == 0) banks2 = "[empty]";

                if (banks1 == "[empty]" && banks2 == "[empty]")
                {
                    banks = "";
                }
                else if (banks2 == "[empty]")
                {
                    banks = "    |    First: " + banks1;
                }
                else
                {
                    banks = "    |    First: " + banks1 + "    |    " + "Ref" + ": " + banks2;
                }

                workingFolder = Program.options.folder_working;

            }

            Gui.gui.toolStripStatusLabel1.ToolTipText = "Period: " + f + " " + start + "-" + end + G.NL + "First: " + GetDatabankFileNameWithPath(Program.databanks.GetFirst().aliasName) + G.NL + "" + Globals.Ref + ": " + GetDatabankFileNameWithPath(Program.databanks.GetRef().aliasName) + G.NL + "Working folder: " + Program.options.folder_working + G.NL + "Mode: " + Program.options.interface_mode;

            if (Globals.workerThread != null)
            {
                string ss2 = f + " " + start + "-" + end + banks + "    |    " + workingFolder;
                WorkerThreadHelper1 wh = new WorkerThreadHelper1();
                wh.statusField = ss2;
                Globals.workerThread.gekkoGui.Invoke(Globals.workerThread.gekkoGui.threadDelegateSetTitle, wh);
            }


        }

        private static string GetDatabankFileNameWithPath(string bank)
        {
            string fileName = "[no bank filename]";
            if (Program.databanks.GetDatabank(bank) != null)
            {
                fileName = Program.databanks.GetDatabank(bank).FileNameWithPath;
            }
            return fileName;
        }

        //public static void RunCmd(ConvertHelper ch, P p)
        //{
        //    if (Globals.runningOnTTComputer && Globals.showTimings) G.Writeln("RunCmd start: " + G.SecondsFormat((DateTime.Now - p.startingTime).TotalMilliseconds), Color.LightBlue);

        //    CompilerParameters compilerParams = new CompilerParameters();
        //    compilerParams.CompilerOptions = Globals.compilerOptions;  //has no effect

        //    compilerParams.GenerateInMemory = true;
        //    //compilerParams.GenerateExecutable = true;

        //    compilerParams.IncludeDebugInformation = false;
        //    compilerParams.ReferencedAssemblies.Add("system.dll");
        //    compilerParams.ReferencedAssemblies.Add("system.windows.forms.dll");
        //    compilerParams.ReferencedAssemblies.Add("system.drawing.dll");

        //    if (G.IsUnitTesting())
        //    {
        //        //if running test cases, use this absolute path
        //        compilerParams.ReferencedAssemblies.Add(Globals.ttPath2 + @"\GekkoCS\Gekko\bin\Debug\ANTLR.dll");
        //        compilerParams.ReferencedAssemblies.Add(Globals.ttPath2 + @"\GekkoCS\Gekko\bin\Debug\gekko.exe");
        //    }
        //    else
        //    {
        //        compilerParams.ReferencedAssemblies.Add(Path.Combine(Path.GetDirectoryName(Application.ExecutablePath), "ANTLR.dll"));
        //        compilerParams.ReferencedAssemblies.Add(Application.ExecutablePath);
        //    }


        //    compilerParams.GenerateExecutable = false;
        //    CSharpCodeProvider csCompiler = new CSharpCodeProvider();

        //    string code = ch.code;
        //    string code2 = code + " ";

        //    CodeDomProvider provider = CodeDomProvider.CreateProvider("CSharp");
        //    if (Globals.runningOnTTComputer && Globals.showTimings) G.Writeln("Compile start: " + G.SecondsFormat((DateTime.Now - p.startingTime).TotalMilliseconds), Color.LightBlue);
        //    CompilerResults compilerResults = provider.CompileAssemblyFromSource(compilerParams, code2);
        //    if (Globals.runningOnTTComputer && Globals.showTimings) G.Writeln("Compile end: " + G.SecondsFormat((DateTime.Now - p.startingTime).TotalMilliseconds), Color.LightBlue);

        //    if (compilerResults.Errors.HasErrors)
        //    {
        //        p.hasBeenCompilationError = true;
        //        Globals.lastDynamicCsCode = code2;  //would be nicer to have this in the P object.
        //        string text = "*** ERROR: Internal Gekko error regarding file: " + p.lastFileSentToANTLR;
        //        if (p.lastFileSentToANTLR == "") text = "*** ERROR: Internal Gekko error regarding user input";
        //        WriteCompileErrorMessage(text, p.lastFileSentToANTLR);
        //        throw new GekkoException();
        //    }

        //    // Load the generated assembly into the ApplicationDomain

        //    Object[] args = new Object[1];
        //    args[0] = p;

        //    try
        //    {

        //        if (Globals.runningOnTTComputer && Globals.showTimings) G.Writeln("Running dll start: " + G.SecondsFormat((DateTime.Now - p.startingTime).TotalMilliseconds), Color.LightBlue);
        //        p.Deeper();

        //        //This only only takes time to JIT the first time it is invoked
        //        //But cmd files are typically only run 1 time and not called
        //        //again and again (like model SIM for instance). So the JIT overhead
        //        //is always there. But just to say that if the below line was multiplied,
        //        //only the first instance would takte time to JIT.
        //        //Seems NGEN can avoid the JIT if the image is cached, but is it really worth it?
        //        //This issues is worst for large cmd files full of simple lines like UPD or
        //        //GENR, and no loops etc. But hey, why not use a databank and a model for that
        //        //kind of stuff? For more normal kinds of programs, especially when we go the
        //        //AREMOS way with loops etc., the parsing/compiling/JITting would probably be
        //        //less visible.
        //        //On a .cmd file with 1000 GENRs, the JITting is unreasonably slow (50 sec.), and
        //        //it probably has to do with the stack getting full of stuff. Splitting it into
        //        //for instance 200 methods each with 5 GENRs speeds the JIT up to about 4 sec.
        //        //So splitting large cmd files seems to help a lot.

        //        if (Globals.runningOnTTComputer)
        //        {
        //            //G.Writeln("--> Calling InvokeMember()");
        //        }
        //        DateTime t0 = DateTime.Now;

        //        string usedCode = ch.code;
        //        Type assembly = compilerResults.CompiledAssembly.GetType("Gekko.TranslatedCode");
        //        assembly.InvokeMember("CodeLines", BindingFlags.InvokeMethod, null, null, args);

        //        if (Globals.runningOnTTComputer)
        //        {
        //            //G.Writeln("--> Finished InvokeMember() in " + (DateTime.Now - t0).TotalMilliseconds / 1000d);
        //        }

        //        int ii = 2;
        //        if (Globals.runningOnTTComputer && Globals.showTimings) G.Writeln("Running dll end: " + G.SecondsFormat((DateTime.Now - p.startingTime).TotalMilliseconds), Color.LightBlue);
        //    }
        //    catch (Exception e)
        //    {
        //        if (Globals.threadIsInProcessOfAborting)
        //        {
        //            throw e;
        //        }
        //        string exception = "";
        //        if (e.InnerException != null) exception = e.InnerException.Message;
        //        if (exception.Length > 0)
        //        {
        //            {
        //                string originalFileName;
        //                int lineNumber;
        //                string problemLine;
        //                List<string> commandLines;

        //                GetErrorLineAndText(p, p.GetDepth(), out lineNumber, out originalFileName, out commandLines);

        //                if (lineNumber <= 0)
        //                {
        //                    problemLine = "";
        //                }
        //                else
        //                {
        //                    problemLine = commandLines[lineNumber - 1];
        //                }

        //                bool lexer = false;

        //                if (p.hasShownErrorHandling == EHasShownErrorHandling.False)
        //                {
        //                    if (exception.Contains("¤Model lexer error:"))
        //                    {
        //                        lexer = true;
        //                        List<string> temp = new List<string>();
        //                        temp.Add(exception);
        //                        ParserOLD.PrintModelLexerErrors(temp, Globals.modelFileLines, new ParseHelper());
        //                    }
        //                    if (exception.Contains("¤Cmd lexer error:"))
        //                    {
        //                        lexer = true;
        //                        List<string> temp = new List<string>();
        //                        temp.Add(exception);
        //                        ParserOLD.PrintModelLexerErrors(temp, Globals.cmdFileLines, new ParseHelper());
        //                    }

        //                    if (originalFileName == "" && commandLines.Count == 1)  //more-liners get file-type error messages
        //                    {
        //                        if (lexer == true) G.Writeln("*** ERROR: Problem parsing/lexing command line:");
        //                        else G.Writeln("*** ERROR: Running user input line:");
        //                        G.Writeln("              " + G.ReplaceGlueNew(problemLine), Color.Blue);
        //                    }
        //                    else
        //                    {
        //                        //file or text block user input (>1 line)
        //                        string xx = "Running";
        //                        if (lexer == true) xx = "Problem parsing/lexing";
        //                        string text = null;
        //                        string lineNumber3 = "" + lineNumber;
        //                        if (lineNumber == 0) lineNumber3 = "[unknown]";

        //                        if (originalFileName == null || originalFileName == "")
        //                        {
        //                            //text block user input
        //                            text = "*** ERROR: User input block, line " + lineNumber3 + ":";
        //                        }
        //                        else
        //                        {
        //                            //file
        //                            text = "*** ERROR: " + xx + " file: " + originalFileName + " line " + lineNumber3;
        //                        }
        //                        WriteErrorMessage(lineNumber, problemLine, text, originalFileName);
        //                    }
        //                }
        //            }
        //        }
        //        throw e;
        //    }
        //    finally
        //    {
        //        //always remove any _tmptmp-variables in banks if present
        //        p.RemoveLast();
        //    }

        //    return;
        //}

        public static void WriteErrorMessage(int lineNumber, string problemLine, string text, string fileName)
        {
            if (Globals.threadIsInProcessOfAborting) return;
            G.Writeln(text, Color.Black, true);
            G.Writeln("    " + "[" + G.IntFormat(lineNumber, 4) + "]:" + "   " + G.ReplaceGlueNew(problemLine), Color.Blue, true);
        }

        private static string GetOriginalTableFileName(string fileName)
        {
            string s2 = "";
            if (fileName.Contains("tablecode." + Globals.defaultCommandFileExtension))
            {
                string s = GetTextFromFileWithWait(fileName);
                List<string> ss = G.ExtractLinesFromText(s);
                s2 = ss[2];
                s2 = s2.Replace(Globals.tableConverterText3, "");
                //G.Writeln("*** ERROR: The original table filename: " + s2);
            }
            return s2;
        }

        //TODO: Delete this when Parser.cs is deleted
        private static void WriteCompileErrorMessage(string text, string fileName)
        {
            if (Globals.threadIsInProcessOfAborting) return;
            G.Writeln(text, Color.Black, true);
        }

        public static void ClearTmpTmpVariables()
        {
            //Program.databanks.Getfirst().ClearTmpTmpVars();
            //Program.databanks.GetSec().ClearTmpTmpVars();
        }

        public static void Vers()
        {
            G.Writeln2("*** ERROR: Please use: TELL gekkoVersion();");
            throw new GekkoException();


            //G.Writeln("Gekko version: " + G.PrintVersion(Globals.gekkoVersion));
            G.Writeln("Gekko version: " + Globals.gekkoVersion);
        }

        public static void Unfix()  //formerly ClearGoals()
        {
            if (Program.model != null)
            {
                if (Program.model.exogenized.Count == 0 && Program.model.endogenized.Count == 0)
                {
                    G.Writeln2("No goals are set, so nothing to unfix");
                }
                else
                {
                    string s = "Unfixed/cleared ";
                    if (Program.model.exogenized != null)
                    {
                        s += Program.model.exogenized.Count + " EXO and ";
                    }
                    if (Program.model.endogenized != null)
                    {
                        s += Program.model.endogenized.Count + " ENDO variables.";
                    }
                    Endo(null);  //--> better than clearing as above, since hasBeenEndoExoStatementsSinceLastSim flag is set
                    Exo(null);
                    G.Writeln2(s);
                    G.Writeln("Please note that only SIM<fix> (and not SIM) enforces the ENDO/EXO goals");
                }
            }
            else
            {
                G.Writeln2("No model defined -- not possible to clear/unfix goals");
            }
        }

        public static void Sign()
        {
            StringBuilder sb = new StringBuilder();
            if (Program.model == null)
            {
                G.Writeln2("*** ERROR: It seems no model is defined. See MODEL command.");
                throw new GekkoException();
            }
            if (Program.model.signatureStatus == ESignatureStatus.SignatureNotFoundInModelFile)
            {
                sb.AppendLine();
                sb.AppendLine("You may add a signature to the model file by means of");
                sb.AppendLine("the following line somewhere in the beginning of the model file:");
                sb.AppendLine();
                sb.AppendLine("  // Signature: " + Program.model.modelHashTrue);
                sb.AppendLine();
                sb.AppendLine("NOTE: You may use '()' instead of '//'.");
            }
            if (Program.model.signatureStatus == ESignatureStatus.SignaturesDoNotMatch)
            {
                sb.AppendLine();
                sb.AppendLine("You may (a) revert the model equations back to their original state,");
                sb.AppendLine("or (b) insert the true hash code as a new signature in the model file.");
            }
            if (true)
            {
                sb.AppendLine();
                sb.AppendLine("The signature is a so-called MD5 hash code, that is, a string of");
                sb.AppendLine("characters representing the whole model file. The hash code can be");
                sb.AppendLine("thought of as a check-sum or fingerprint.");
                sb.AppendLine();
                sb.AppendLine("When computing the hash code, Gekko ignores any empty lines, or");
                sb.AppendLine("lines starting with the comment symbol ('//' or '()'). So you");
                sb.AppendLine("may add or remove (whole-line) commentaries as you like, without ");
                sb.AppendLine("altering the hash code, but changing or reordering the equations");
                sb.AppendLine("in any way will result in a new hash code.");
                sb.AppendLine();
                sb.AppendLine("Any variable list after the VARLIST$ or VARLIST; tag will also be ignored");
                sb.AppendLine("when computing the hash code.");
            }
            LinkContainer lc = new LinkContainer(sb.ToString());
            Globals.linkContainer.Add(lc.counter, lc);

            G.Writeln();
            string s = Program.model.signatureFoundInFileHeader;
            if (Program.model.signatureStatus == ESignatureStatus.SignatureNotFoundInModelFile)
            {
                s = "[not found]";
                G.Write("No signature was found in model file");
            }
            else if (Program.model.signatureStatus == ESignatureStatus.Ok)
            {
                G.Write("The signature matches the true hash code of the model file");
            }
            else if (Program.model.signatureStatus == ESignatureStatus.SignaturesDoNotMatch)
            {
                G.Write("The signature does not match the true hash code of the model file");
            }
            G.Write(" ("); G.WriteLink("more", "outputtab:" + lc.counter); G.Write(")"); G.Writeln();
            G.Writeln("- Signature in model file      : " + s);
            G.Writeln("- True model file hash code    : " + Program.model.modelHashTrue);
        }

        public static void Unswap(bool print)
        {
            Databanks.Unswap();
        }

        public static void Unswap()
        {
            Unswap(true);
        }

        private class ArrayComparer : IEqualityComparer<string[]>
        {
            public bool Equals(string[] item1, string[] item2)
            {
                if (item1[0] == item2[0] && item1[1] == item2[1] && item1[2] == item2[2] && item1[3] == item2[3])
                {
                    return true;
                }
                else
                {
                    return false;
                }
            }


            public int GetHashCode(string[] item)
            {
                return item[0].GetHashCode();
            }
        }        

        private static void GetGamsVariable(string gvar, GAMSDatabase db, string filterScn)
        {
            GAMSVariable n = db.GetVariable(gvar);

            int[] dims = new int[n.Domains.Count];

            //N has --> a=86, t=116, s=4, scns=5.

            int timeIndex = -12345;
            int scnsIndex = -12345;
            for (int i = 0; i < n.Domains.Count; i++)
            {
                GAMSSet gs = (GAMSSet)n.Domains.ElementAt(i);
                dims[i] = gs.NumberRecords;
                if (gs.Name == "t")
                {
                    timeIndex = i;
                }
                else if (gs.Name == "scns")
                {
                    scnsIndex = i;
                }
            }

            TimeSeries ts2 = null;
            int counter = 0;
            string oldHash = "";

            DateTime t0 = DateTime.Now;

            foreach (GAMSVariableRecord record in n)
            {
                if (scnsIndex != -12345)
                {
                    string scns = record.Keys[scnsIndex];
                    if (filterScn != null && !G.equal(scns, filterScn)) continue;
                }
                counter++;

                int tt = -12345;
                string t = null;
                if (timeIndex != -12345)
                {
                    t = record.Keys[timeIndex];
                    tt = int.Parse(t.Substring(1)) + 2010;  //remove the "t" and add 2010                
                }

                double d = record.Level;

                string hash = null;
                for (int i = 0; i < record.Keys.Length; i++)
                {
                    if (i == timeIndex) continue;
                    hash += record.Keys[i];
                    if (i < record.Keys.Length - 1) hash += Globals.symbolTurtle; //ok as delimiter;                    
                }

                if (hash != oldHash) ts2 = Program.databanks.GetFirst().GetVariable(EFreq.Annual, gvar + Globals.symbolTurtle + hash);

                if (ts2 == null)
                {
                    ts2 = new TimeSeries(EFreq.Annual, gvar + Globals.symbolTurtle + hash);
                    Program.databanks.GetFirst().AddVariable(ts2);
                    if (timeIndex == -12345)
                    {
                        ts2.SetTimeless();
                    }
                }

                if (timeIndex == -12345)
                {
                    ts2.SetTimelessData(d);
                }
                else
                {
                    ts2.SetData(new GekkoTime(EFreq.Annual, tt, 1), d);
                }
                oldHash = hash;
            }

            TimeSeries ts = Program.databanks.GetFirst().GetVariable(EFreq.Annual, gvar);
            if (ts == null)
            {
                ts = new TimeSeries(EFreq.Annual, gvar);
                ts.SetGhost(true);  //only a placeholder, should not be counted etc.
                Program.databanks.GetFirst().AddVariable(ts);
            }

            double time = (DateTime.Now - t0).TotalMilliseconds;
            G.Writeln2("TIME: " + time / 1000d);
        }

        public static Table Dream(string options)
        {
            //Experimantal stuff to decompose DREAM equations

            int t0 = 2013;

            Table table = new Table();
            //Program.databanks.Getfirst().Clear();

            //Variable LMax
            //dim 0 --> DA IX IW
            //dim 1 --> m f
            //dim 2 --> 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34
            //35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68
            //69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85
            //dim 3 --> t0 t1 t2 t3 t4 t5 t6 t7 t8 t9 t10 t11 t12 t13 t14 t15 t16 t17 t18 t19 t20 t21 t22 t23 t24 t25
            //t26 t27 t28 t29 t30 t31 t32 t33 t34 t35 t36 t37 t38 t39 t40 t41 t42 t43 t44 t45 t46 t47 t48 t49 t50 t51
            //t52 t53 t54 t55 t56 t57 t58 t59 t60 t61 t62 t63 t64 t65 t66 t67 t68 t69 t70 t71 t72 t73 t74 t75 t76 t77
            //t78 t79 t80 t81 t82 t83 t84 t85 t86 t87 t88 t89 t90 t91 t92 t93 t94 t95 t96 t97 t98 t99 t100 t101 t102
            //t103 t104 t105 t106 t107 t108 t109 t110 t111 t112 t113 t114 t115

            //Variable J_LMax
            //dim 0 --> DA IX IW DX DW
            //dim 1 --> m f
            //dim 2 --> 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34
            //35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68
            //69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85
            //dim 3 --> t0 t1 t2 t3 t4 t5 t6 t7 t8 t9 t10 t11 t12 t13 t14 t15 t16 t17 t18 t19 t20 t21 t22 t23 t24 t25
            //t26 t27 t28 t29 t30 t31 t32 t33 t34 t35 t36 t37 t38 t39 t40 t41 t42 t43 t44 t45 t46 t47 t48 t49 t50 t51
            //t52 t53 t54 t55 t56 t57 t58 t59 t60 t61 t62 t63 t64 t65 t66 t67 t68 t69 t70 t71 t72 t73 t74 t75 t76 t77
            //t78 t79 t80 t81 t82 t83 t84 t85 t86 t87 t88 t89 t90 t91 t92 t93 t94 t95 t96 t97 t98 t99 t100 t101 t102
            //t103 t104 t105 t106 t107 t108 t109 t110 t111 t112 t113 t114 t115

            //Variable eta
            //dim 0 --> DA IX IW DX DW
            //dim 1 --> m f
            //dim 2 --> 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34
            //35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68
            //69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85
            //dim 3 --> t0 t1 t2 t3 t4 t5 t6 t7 t8 t9 t10 t11 t12 t13 t14 t15 t16 t17 t18 t19 t20 t21 t22 t23 t24 t25
            //t26 t27 t28 t29 t30 t31 t32 t33 t34 t35 t36 t37 t38 t39 t40 t41 t42 t43 t44 t45 t46 t47 t48 t49 t50 t51
            //t52 t53 t54 t55 t56 t57 t58 t59 t60 t61 t62 t63 t64 t65 t66 t67 t68 t69 t70 t71 t72 t73 t74 t75 t76 t77
            //t78 t79 t80 t81 t82 t83 t84 t85 t86 t87 t88 t89 t90 t91 t92 t93 t94 t95 t96 t97 t98 t99 t100 t101 t102
            //t103 t104 t105 t106 t107 t108 t109 t110 t111 t112 t113 t114 t115

            //Variable tmargWork
            //dim 0 --> DA IX IW
            //dim 1 --> m f
            //dim 2 --> 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34
            //35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68
            //69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85
            //dim 3 --> t0 t1 t2 t3 t4 t5 t6 t7 t8 t9 t10 t11 t12 t13 t14 t15 t16 t17 t18 t19 t20 t21 t22 t23 t24 t25
            //t26 t27 t28 t29 t30 t31 t32 t33 t34 t35 t36 t37 t38 t39 t40 t41 t42 t43 t44 t45 t46 t47 t48 t49 t50 t51
            //t52 t53 t54 t55 t56 t57 t58 t59 t60 t61 t62 t63 t64 t65 t66 t67 t68 t69 t70 t71 t72 t73 t74 t75 t76 t77
            //t78 t79 t80 t81 t82 t83 t84 t85 t86 t87 t88 t89 t90 t91 t92 t93 t94 t95 t96 t97 t98 t99 t100 t101 t102
            //t103 t104 t105 t106 t107 t108 t109 t110 t111 t112 t113 t114 t115

            //Variable adjrho
            //dim 0 --> t0 t1 t2 t3 t4 t5 t6 t7 t8 t9 t10 t11 t12 t13 t14 t15 t16 t17 t18 t19 t20 t21 t22 t23 t24 t25
            //t26 t27 t28 t29 t30 t31 t32 t33 t34 t35 t36 t37 t38 t39 t40 t41 t42 t43 t44 t45 t46 t47 t48 t49 t50 t51
            //t52 t53 t54 t55 t56 t57 t58 t59 t60 t61 t62 t63 t64 t65 t66 t67 t68 t69 t70 t71 t72 t73 t74 t75 t76 t77
            //t78 t79 t80 t81 t82 t83 t84 t85 t86 t87 t88 t89 t90 t91 t92 t93 t94 t95 t96 t97 t98 t99 t100 t101 t102
            //t103 t104 t105 t106 t107 t108 t109 t110 t111 t112 t113 t114 t115

            //Variable rho
            //dim 0 --> DA IX IW DX DW
            //dim 1 --> m f
            //dim 2 --> 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34
            //35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68
            //69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85
            //dim 3 --> t0 t1 t2 t3 t4 t5 t6 t7 t8 t9 t10 t11 t12 t13 t14 t15 t16 t17 t18 t19 t20 t21 t22 t23 t24 t25
            //t26 t27 t28 t29 t30 t31 t32 t33 t34 t35 t36 t37 t38 t39 t40 t41 t42 t43 t44 t45 t46 t47 t48 t49 t50 t51
            //t52 t53 t54 t55 t56 t57 t58 t59 t60 t61 t62 t63 t64 t65 t66 t67 t68 t69 t70 t71 t72 t73 t74 t75 t76 t77
            //t78 t79 t80 t81 t82 t83 t84 t85 t86 t87 t88 t89 t90 t91 t92 t93 t94 t95 t96 t97 t98 t99 t100 t101 t102
            //t103 t104 t105 t106 t107 t108 t109 t110 t111 t112 t113 t114 t115

            //Variable W
            //dim 0 --> t0 t1 t2 t3 t4 t5 t6 t7 t8 t9 t10 t11 t12 t13 t14 t15 t16 t17 t18 t19 t20 t21 t22 t23 t24 t25
            //t26 t27 t28 t29 t30 t31 t32 t33 t34 t35 t36 t37 t38 t39 t40 t41 t42 t43 t44 t45 t46 t47 t48 t49 t50 t51
            //t52 t53 t54 t55 t56 t57 t58 t59 t60 t61 t62 t63 t64 t65 t66 t67 t68 t69 t70 t71 t72 t73 t74 t75 t76 t77
            //t78 t79 t80 t81 t82 t83 t84 t85 t86 t87 t88 t89 t90 t91 t92 t93 t94 t95 t96 t97 t98 t99 t100 t101 t102
            //t103 t104 t105 t106 t107 t108 t109 t110 t111 t112 t113 t114 t115

            //Variable PCH
            //dim 0 --> d c g R p eo ep eg H N
            //dim 1 --> t0 t1 t2 t3 t4 t5 t6 t7 t8 t9 t10 t11 t12 t13 t14 t15 t16 t17 t18 t19 t20 t21 t22 t23 t24 t25
            //t26 t27 t28 t29 t30 t31 t32 t33 t34 t35 t36 t37 t38 t39 t40 t41 t42 t43 t44 t45 t46 t47 t48 t49 t50 t51
            //t52 t53 t54 t55 t56 t57 t58 t59 t60 t61 t62 t63 t64 t65 t66 t67 t68 t69 t70 t71 t72 t73 t74 t75 t76 t77
            //t78 t79 t80 t81 t82 t83 t84 t85 t86 t87 t88 t89 t90 t91 t92 t93 t94 t95 t96 t97 t98 t99 t100 t101 t102
            //t103 t104 t105 t106 t107 t108 t109 t110 t111 t112 t113 t114 t115

            //Variable gamma
            //dim 0 --> m f

            //Variable adjLmax
            //dim 0 --> DA IX IW DX DW
            //dim 1 --> m f
            //dim 2 --> 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34
            //35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68
            //69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85
            //dim 3 --> t0 t1 t2 t3 t4 t5 t6 t7 t8 t9 t10 t11 t12 t13 t14 t15 t16 t17 t18 t19 t20 t21 t22 t23 t24 t25
            //t26 t27 t28 t29 t30 t31 t32 t33 t34 t35 t36 t37 t38 t39 t40 t41 t42 t43 t44 t45 t46 t47 t48 t49 t50 t51
            //t52 t53 t54 t55 t56 t57 t58 t59 t60 t61 t62 t63 t64 t65 t66 t67 t68 t69 t70 t71 t72 t73 t74 t75 t76 t77
            //t78 t79 t80 t81 t82 t83 t84 t85 t86 t87 t88 t89 t90 t91 t92 t93 t94 t95 t96 t97 t98 t99 t100 t101 t102
            //t103 t104 t105 t106 t107 t108 t109 t110 t111 t112 t113 t114 t115

            //Variable NInd
            //dim 0 --> DA IX IW
            //dim 1 --> m f
            //dim 2 --> 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33
            //34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67
            //68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85
            //dim 3 --> t0 t1 t2 t3 t4 t5 t6 t7 t8 t9 t10 t11 t12 t13 t14 t15 t16 t17 t18 t19 t20 t21 t22 t23 t24 t25
            //t26 t27 t28 t29 t30 t31 t32 t33 t34 t35 t36 t37 t38 t39 t40 t41 t42 t43 t44 t45 t46 t47 t48 t49 t50 t51
            //t52 t53 t54 t55 t56 t57 t58 t59 t60 t61 t62 t63 t64 t65 t66 t67 t68 t69 t70 t71 t72 t73 t74 t75 t76 t77
            //t78 t79 t80 t81 t82 t83 t84 t85 t86 t87 t88 t89 t90 t91 t92 t93 t94 t95 t96 t97 t98 t99 t100 t101 t102
            //t103 t104 t105 t106 t107 t108 t109 t110 t111 t112 t113 t114 t115

            G.Writeln2("Loading DREAM data start");

            //DateTime t0 = DateTime.Now;

            GAMSWorkspace ws = new GAMSWorkspace(workingDirectory: "c:\\tools\\decomp");
            GAMSDatabase db = ws.AddDatabaseFromGDX("c:\\tools\\decomp\\calib_d.gdx");

            if (false)
            {
                GAMSVariable xx = db.GetVariable("LMax");
                
            }            

            double[,,,] LMax = new double[3, 2, 85, 116];
            db.GetVariable("LMax").CopyToArray(LMax, 0);

            double[,,,] J_LMax = new double[5, 2, 85, 116];
            db.GetVariable("J_LMax").CopyToArray(J_LMax, 0);

            double[,,,] eta = new double[5, 2, 85, 116];
            db.GetVariable("eta").CopyToArray(eta, 0);

            double[,,,] tmargWork = new double[3, 2, 85, 116];
            db.GetVariable("tmargWork").CopyToArray(tmargWork, 0);

            double[] adjrho = new double[116];
            db.GetVariable("adjrho").CopyToArray(adjrho, 0);

            double[,,,] rho = new double[5, 2, 85, 116];
            db.GetVariable("rho").CopyToArray(rho, 0);

            double[] W = new double[116];
            db.GetVariable("W").CopyToArray(W, 0);

            double[,] PCH = new double[10, 116];
            db.GetVariable("PCH").CopyToArray(PCH, 0);

            double[] gamma = new double[2];
            db.GetVariable("gamma").CopyToArray(gamma, 0);

            double[,,,] adjLmax = new double[5, 2, 85, 116];
            db.GetVariable("adjLmax").CopyToArray(adjLmax, 0);

            GAMSParameter p2 = db.GetParameter("NInd");
            p2.AddRecord(new string[] { "IX", "m", "84", "t0" });
            p2.AddRecord(new string[] { "IX", "m", "84", "t1" });
            p2.AddRecord(new string[] { "IX", "m", "84", "t2" });
            p2.AddRecord(new string[] { "IX", "m", "85", "t0" });
            p2.AddRecord(new string[] { "IX", "m", "85", "t1" });
            p2.AddRecord(new string[] { "IX", "m", "85", "t2" });
            p2.AddRecord(new string[] { "IX", "m", "85", "t3" });
            p2.AddRecord(new string[] { "IW", "m", "83", "t3" });
            p2.AddRecord(new string[] { "IW", "m", "83", "t4" });
            p2.AddRecord(new string[] { "IW", "m", "84", "t0" });
            p2.AddRecord(new string[] { "IW", "m", "84", "t1" });
            p2.AddRecord(new string[] { "IW", "m", "84", "t4" });
            p2.AddRecord(new string[] { "IW", "m", "84", "t5" });
            p2.AddRecord(new string[] { "IW", "m", "85", "t0" });
            p2.AddRecord(new string[] { "IW", "m", "85", "t1" });
            p2.AddRecord(new string[] { "IW", "m", "85", "t2" });
            p2.AddRecord(new string[] { "IW", "m", "85", "t5" });
            p2.AddRecord(new string[] { "IW", "m", "85", "t6" });
            double[,,,] NInd = new double[3, 2, 86, 116];  //a is 0-based here, 1-based in the others!
            p2.CopyToArray(NInd, 0);

            G.Writeln("Loading DREAM data end");

            double max = 0d;

            G.Writeln("DREAM decomposition start");

            //DateTime t1 = DateTime.Now;

            string type = "vars__tid";

            int S = 2;
            int A = 86;
            int O = 3;
            int V = 9;
            int T = 116;

            double[,,,,] result = new double[V, S, A, O, T];  //9 variabler
            double[,,,] resultSum = new double[S, A, O, T];
            double[,,,] resultLevelLag = new double[S, A, O, T];

            for (int t = 0; t < T; t++)
            {
                double errorMax = double.MinValue;
                double errorMin = double.MaxValue;

                double d_J_LMax = 0d;
                double d_eta = 0d;
                double d_tmargWork = 0d;
                double d_adjrho = 0d;
                double d_rho = 0d;
                double d_W = 0d;
                double d_PCH = 0d;
                double d_adjLmax = 0d;
                double d_NInd = 0d;
                double d_SUM = 0d;

                //!!!!!!!!!!!!!!!!!!!!!!!!!!!
                //!!!!!!!!!!!!!!!!!!!!!!!!!!!
                //!!!!!!!!!!!!!!!!!!!!!!!!!!!
                if (t == 0) continue;

                double sum1 = 0d;
                double sum2 = 0d;
                double count1 = 0d;
                double count2 = 0d;

                double x1 = 0d;
                double x2 = 0d;

                for (int o = 0; o < O; o++)
                {
                    for (int s = 0; s < S; s++)
                    {
                        for (int a = 1; a < A; a++)
                        {
                            double lhsClean = NInd[o, s, a, t];
                            double lhs = LMax[o, s, a - 1, t] * NInd[o, s, a, t];

                            x1 += lhsClean;
                            x2 += lhs;

                            double lhsLag = LMax[o, s, a - 1, t - 1] * NInd[o, s, a, t - 1];
                            double rhs = (J_LMax[o, s, a - 1, t] + (eta[o, s, a - 1, t] * Math.Pow((1 - tmargWork[o, s, a - 1, t]) * adjrho[t] * rho[o, s, a - 1, t] * W[t] / PCH[1, t], gamma[s])) + adjLmax[o, s, a - 1, t]) * NInd[o, s, a, t];
                            double rhsLag = (J_LMax[o, s, a - 1, t - 1] + (eta[o, s, a - 1, t - 1] * Math.Pow((1 - tmargWork[o, s, a - 1, t - 1]) * adjrho[t - 1] * rho[o, s, a - 1, t - 1] * W[t - 1] / PCH[1, t - 1], gamma[s])) + adjLmax[o, s, a - 1, t - 1]) * NInd[o, s, a, t - 1];

                            double delta = 0.000001;
                            double alpha_J_LMax = (((J_LMax[o, s, a - 1, t - 1] + delta) + (eta[o, s, a - 1, t - 1] * Math.Pow((1 - tmargWork[o, s, a - 1, t - 1]) * adjrho[t - 1] * rho[o, s, a - 1, t - 1] * W[t - 1] / PCH[1, t - 1], gamma[s])) + adjLmax[o, s, a - 1, t - 1]) * NInd[o, s, a, t - 1] - rhsLag) / delta;
                            double alpha_eta = ((J_LMax[o, s, a - 1, t - 1] + ((eta[o, s, a - 1, t - 1] + delta) * Math.Pow((1 - tmargWork[o, s, a - 1, t - 1]) * adjrho[t - 1] * rho[o, s, a - 1, t - 1] * W[t - 1] / PCH[1, t - 1], gamma[s])) + adjLmax[o, s, a - 1, t - 1]) * NInd[o, s, a, t - 1] - rhsLag) / delta;
                            double alpha_tmargWork = ((J_LMax[o, s, a - 1, t - 1] + (eta[o, s, a - 1, t - 1] * Math.Pow((1 - (tmargWork[o, s, a - 1, t - 1] + delta)) * adjrho[t - 1] * rho[o, s, a - 1, t - 1] * W[t - 1] / PCH[1, t - 1], gamma[s])) + adjLmax[o, s, a - 1, t - 1]) * NInd[o, s, a, t - 1] - rhsLag) / delta;
                            double alpha_adjrho = ((J_LMax[o, s, a - 1, t - 1] + (eta[o, s, a - 1, t - 1] * Math.Pow((1 - tmargWork[o, s, a - 1, t - 1]) * (adjrho[t - 1] + delta) * rho[o, s, a - 1, t - 1] * W[t - 1] / PCH[1, t - 1], gamma[s])) + adjLmax[o, s, a - 1, t - 1]) * NInd[o, s, a, t - 1] - rhsLag) / delta;
                            double alpha_rho = ((J_LMax[o, s, a - 1, t - 1] + (eta[o, s, a - 1, t - 1] * Math.Pow((1 - tmargWork[o, s, a - 1, t - 1]) * adjrho[t - 1] * (rho[o, s, a - 1, t - 1] + delta) * W[t - 1] / PCH[1, t - 1], gamma[s])) + adjLmax[o, s, a - 1, t - 1]) * NInd[o, s, a, t - 1] - rhsLag) / delta;
                            double alpha_W = ((J_LMax[o, s, a - 1, t - 1] + (eta[o, s, a - 1, t - 1] * Math.Pow((1 - tmargWork[o, s, a - 1, t - 1]) * adjrho[t - 1] * rho[o, s, a - 1, t - 1] * (W[t - 1] + delta) / PCH[1, t - 1], gamma[s])) + adjLmax[o, s, a - 1, t - 1]) * NInd[o, s, a, t - 1] - rhsLag) / delta;
                            double alpha_PCH = ((J_LMax[o, s, a - 1, t - 1] + (eta[o, s, a - 1, t - 1] * Math.Pow((1 - tmargWork[o, s, a - 1, t - 1]) * adjrho[t - 1] * rho[o, s, a - 1, t - 1] * W[t - 1] / (PCH[1, t - 1] + delta), gamma[s])) + adjLmax[o, s, a - 1, t - 1]) * NInd[o, s, a, t - 1] - rhsLag) / delta;
                            double alpha_adjLmax = ((J_LMax[o, s, a - 1, t - 1] + (eta[o, s, a - 1, t - 1] * Math.Pow((1 - tmargWork[o, s, a - 1, t - 1]) * adjrho[t - 1] * rho[o, s, a - 1, t - 1] * W[t - 1] / PCH[1, t - 1], gamma[s])) + (adjLmax[o, s, a - 1, t - 1] + delta)) * NInd[o, s, a, t - 1] - rhsLag) / delta;
                            double alpha_NInd = ((J_LMax[o, s, a - 1, t - 1] + (eta[o, s, a - 1, t - 1] * Math.Pow((1 - tmargWork[o, s, a - 1, t - 1]) * adjrho[t - 1] * rho[o, s, a - 1, t - 1] * W[t - 1] / PCH[1, t - 1], gamma[s])) + adjLmax[o, s, a - 1, t - 1]) * (NInd[o, s, a, t - 1] + delta) - rhsLag) / delta;

                            double beta_J_LMax = alpha_J_LMax * (J_LMax[o, s, a - 1, t] - J_LMax[o, s, a - 1, t - 1]);
                            double beta_eta = alpha_eta * (eta[o, s, a - 1, t] - eta[o, s, a - 1, t - 1]);
                            double beta_tmargWork = alpha_tmargWork * (tmargWork[o, s, a - 1, t] - tmargWork[o, s, a - 1, t - 1]);
                            double beta_adjrho = alpha_adjrho * (adjrho[t] - adjrho[t - 1]);
                            double beta_rho = alpha_rho * (rho[o, s, a - 1, t] - rho[o, s, a - 1, t - 1]);
                            double beta_W = alpha_W * (W[t] - W[t - 1]);
                            double beta_PCH = alpha_PCH * (PCH[1, t] - PCH[1, t - 1]);
                            double beta_adjLmax = alpha_adjLmax * (adjLmax[o, s, a - 1, t] - adjLmax[o, s, a - 1, t - 1]);
                            double beta_NInd = alpha_NInd * (NInd[o, s, a, t] - NInd[o, s, a, t - 1]);

                            double sum = beta_J_LMax + beta_eta + beta_tmargWork + beta_adjrho + beta_rho + beta_W + beta_PCH + beta_adjLmax + beta_NInd;
                            double target = rhs - rhsLag;
                            double error = sum / target;

                            //error = 1d;

                            //if (t >= 2 && o == 0 && s == 0 && a == 40)
                            //{
                            //    Console.WriteLine();
                            //}

                            double gamma_J_LMax = beta_J_LMax / error;
                            double gamma_eta = beta_eta / error;
                            double gamma_tmargWork = beta_tmargWork / error;
                            double gamma_adjrho = beta_adjrho / error;
                            double gamma_rho = beta_rho / error;
                            double gamma_W = beta_W / error;
                            double gamma_PCH = beta_PCH / error;
                            double gamma_adjLmax = beta_adjLmax / error;
                            double gamma_NInd = beta_NInd / error;

                            if (sum == 0d && target == 0d)
                            {
                                error = 1;
                                if (beta_J_LMax == 0d) gamma_J_LMax = 0d;
                                if (beta_eta == 0d) gamma_eta = 0d;
                                if (beta_tmargWork == 0d) gamma_tmargWork = 0d;
                                if (beta_adjrho == 0d) gamma_adjrho = 0d;
                                if (beta_rho == 0d) gamma_rho = 0d;
                                if (beta_W == 0d) gamma_W = 0d;
                                if (beta_PCH == 0d) gamma_PCH = 0d;
                                if (beta_adjLmax == 0d) gamma_adjLmax = 0d;
                                if (beta_NInd == 0d) gamma_NInd = 0d;
                            }

                            //Hvorfor stiger rho fra DA, m, 49, t15-->t16 fra 1 til 3.04??

                            errorMax = Math.Max(errorMax, error);
                            errorMin = Math.Min(errorMin, error);

                            if (false && error > 0.95 && error < 1.05 && target > .5)
                            {
                                double share = beta_NInd / sum;
                                if (share < 0.7)
                                {
                                    G.Writeln(";");
                                    G.Writeln(target + " ... " + sum);
                                }
                            }

                            //G.Writeln(target + " ... " + sum);

                            if (false)
                            {

                                sum1 += rhs * NInd[o, s, a, t];
                                count1 += NInd[o, s, a, t];
                                sum2 += rhs;
                                count2++;

                                d_J_LMax += gamma_J_LMax;
                                d_eta += gamma_eta;
                                d_tmargWork += gamma_tmargWork;
                                d_adjrho += gamma_adjrho;
                                d_rho += gamma_rho;
                                d_W += gamma_W;
                                d_PCH += gamma_PCH;
                                d_adjLmax += gamma_adjLmax;
                                d_NInd += gamma_NInd;

                                d_SUM += lhs - lhsLag;
                            }

                            result[0, s, a, o, t] = gamma_J_LMax;
                            result[1, s, a, o, t] = gamma_eta;
                            result[2, s, a, o, t] = gamma_tmargWork;
                            result[3, s, a, o, t] = gamma_adjrho;
                            result[4, s, a, o, t] = gamma_rho;
                            result[5, s, a, o, t] = gamma_W;
                            result[6, s, a, o, t] = gamma_PCH;
                            result[7, s, a, o, t] = gamma_adjLmax;
                            result[8, s, a, o, t] = gamma_NInd;
                            resultSum[s, a, o, t] = d_SUM;

                            resultLevelLag[s, a, o, t] = lhsLag;
                        }
                    }
                }

                if (false)
                {
                    G.Writeln2("------------------------------------------");
                    G.Writeln("t = " + t + " = " + sum1 / count1);
                    G.Writeln("t = " + t + " = " + sum2 / count2);
                    G.Writeln("errormin " + errorMin + " errormax " + errorMax);
                    G.Writeln("d_J_LMax " + d_J_LMax);
                    G.Writeln("d_eta " + d_eta);
                    G.Writeln("d_tmargWork " + d_tmargWork);
                    G.Writeln("d_adjrho " + d_adjrho);
                    G.Writeln("d_rho " + d_rho);
                    G.Writeln("d_W " + d_W);
                    G.Writeln("d_PCH " + d_PCH);
                    G.Writeln("d_adjLmax " + d_adjLmax);
                    G.Writeln("d_NInd " + d_NInd);
                    G.Writeln("-------");
                    G.Writeln("d_SUM " + d_SUM);
                    double SUM2 = d_J_LMax + d_eta + d_tmargWork + d_adjrho + d_rho + d_W + d_PCH + d_adjLmax + d_NInd;
                    G.Writeln("d_SUM2 " + SUM2);
                }
            }

            //result = new double[T, S, A, O, T];  //9 variabler

            if (true)
            {

                string row = null;
                string col = null;
                string t1 = null;
                string t2 = null;
                string a1 = null;
                string a2 = null;
                string s1 = null;
                string s2 = null;
                string o1 = null;
                string o2 = null;
                string v1 = null;
                string v2 = null;

                string[] ss = options.Substring(5).Split(',');
                foreach (string ss2 in ss)
                {
                    string s3 = ss2.Replace(" ", "").ToLower();
                    if (s3.StartsWith("row="))
                    {
                        row = s3.Substring(4);
                    }
                    if (s3.StartsWith("col="))
                    {
                        col = s3.Substring(4);
                    }
                    if (s3.StartsWith("t="))
                    {
                        string[] s4 = s3.Substring(2).Split('-');
                        if (s4.Length > 2)
                        {
                            MessageBox.Show("Use for example t=" + t0 + "-2030");
                            throw new GekkoException();
                        }
                        if (s4.Length == 1)
                        {
                            t1 = s4[0];
                            t2 = s4[0];
                        }
                        else
                        {
                            t1 = s4[0];
                            t2 = s4[1];
                        }
                    }
                    if (s3.StartsWith("a="))
                    {
                        string[] s4 = s3.Substring(2).Split('-');
                        if (s4.Length > 2)
                        {
                            MessageBox.Show("Use for example a=18-64");
                            throw new GekkoException();
                        }
                        if (s4.Length == 1)
                        {
                            a1 = s4[0];
                            a2 = s4[0];
                        }
                        else
                        {
                            a1 = s4[0];
                            a2 = s4[1];
                        }
                    }
                    if (s3.StartsWith("s="))
                    {
                        string[] s4 = s3.Substring(2).Split('-');
                        if (s4.Length > 2)
                        {
                            MessageBox.Show("Use for example s=0-0 (s runs from 0 to 1 inclusive)");
                            throw new GekkoException();
                        }
                        if (s4.Length == 1)
                        {
                            s1 = s4[0];
                            s2 = s4[0];
                        }
                        else
                        {
                            s1 = s4[0];
                            s2 = s4[1];
                        }
                    }
                    if (s3.StartsWith("o="))
                    {
                        string[] s4 = s3.Substring(2).Split('-');
                        if (s4.Length > 2)
                        {
                            MessageBox.Show("Use for example o=0-1 (o runs from 0 to 2 inclusive)");
                            throw new GekkoException();
                        }
                        if (s4.Length == 1)
                        {
                            o1 = s4[0];
                            o2 = s4[0];
                        }
                        else
                        {
                            o1 = s4[0];
                            o2 = s4[1];
                        }
                    }
                    if (s3.StartsWith("v="))
                    {
                        string[] s4 = s3.Substring(2).Split('-');
                        if (s4.Length > 2)
                        {
                            MessageBox.Show("Use for example v=0-3 (v runs from 0 to 8 inclusive)");
                            throw new GekkoException();
                        }
                        if (s4.Length == 1)
                        {
                            v1 = s4[0];
                            v2 = s4[0];
                        }
                        else
                        {
                            v1 = s4[0];
                            v2 = s4[1];
                        }
                    }
                }

                /*
                string row = "a";
                string col = "t";
                double[,] tab = new double[A, T];
                int tRest = -12345;

                string row = "v";
                string col = "t";
                double[,] tab = new double[V, T];
                int tRest = -12345;


                string row = "v";
                string col = "a";
                double[,] tab = new double[V, A];
                int tRest = 2;
                */

                int row1 = -12345;
                int col1 = -12345;
                if (row == "t") row1 = T + 1;
                if (row == "s") row1 = S + 1;
                if (row == "a") row1 = A + 1;
                if (row == "o") row1 = O + 1;
                if (row == "v") row1 = V + 1;
                if (col == "t") col1 = T + 1;
                if (col == "s") col1 = S + 1;
                if (col == "a") col1 = A + 1;
                if (col == "o") col1 = O + 1;
                if (col == "v") col1 = V + 1;

                double[,] tab = new double[row1, col1];
                int tRest = -12345;



                for (int t = 0; t < T; t++)
                {
                    if (Skip(t0, "t", t1, t2, a1, a2, s1, s2, o1, o2, v1, v2, -12345, t)) continue;
                    for (int o = 0; o < O; o++)
                    {
                        if (Skip(t0, "o", t1, t2, a1, a2, s1, s2, o1, o2, v1, v2, -12345, o)) continue;
                        for (int s = 0; s < S; s++)
                        {
                            if (Skip(t0, "s", t1, t2, a1, a2, s1, s2, o1, o2, v1, v2, -12345, s)) continue;
                            for (int a = 1; a < A; a++)
                            {
                                if (Skip(t0, "a", t1, t2, a1, a2, s1, s2, o1, o2, v1, v2, -12345, a)) continue;
                                for (int v = 0; v < V; v++)
                                {
                                    if (Skip(t0, "v", t1, t2, a1, a2, s1, s2, o1, o2, v1, v2, -12345, v)) continue;
                                    //if (tRest != -12345 && t != tRest) continue;

                                    int row2 = -12345;
                                    int col2 = -12345;
                                    if (row == "t") row2 = t;
                                    if (row == "s") row2 = s;
                                    if (row == "a") row2 = a;
                                    if (row == "o") row2 = o;
                                    if (row == "v") row2 = v;
                                    if (col == "t") col2 = t;
                                    if (col == "s") col2 = s;
                                    if (col == "a") col2 = a;
                                    if (col == "o") col2 = o;
                                    if (col == "v") col2 = v;

                                    tab[row2, col2] += result[v, s, a, o, t];

                                }
                            }
                        }
                    }
                }

                for (int i = 0; i < tab.GetLength(0) - 1; i++)
                {
                    for (int j = 0; j < tab.GetLength(1) - 1; j++)
                    {
                        tab[tab.GetLength(0) - 1, j] += tab[i, j];
                        tab[i, tab.GetLength(1) - 1] += tab[i, j];
                        tab[tab.GetLength(0) - 1, tab.GetLength(1) - 1] += tab[i, j];
                    }
                }

                string[] vars = new string[] { "J_LMax", "eta", "tmargWork", "adjrho", "rho", "W", "PCH", "adjLmax", "NInd" };
                string[] origins = new string[] { "DA", "IX", "IW" };
                string[] sexs = new string[] { "M", "K" };

                double[] colSum = new double[tab.GetLength(1)];
                double totalSum = 0d;

                string format = "f10.2";
                int ri = 0;
                for (int i = 0; i < tab.GetLength(0); i++)
                {
                    double rowSum = 0d;
                    bool skipRow = Skip(t0, row, t1, t2, a1, a2, s1, s2, o1, o2, v1, v2, tab.GetLength(0), i);

                    if (skipRow) continue;

                    int ci = 0;
                    for (int j = 0; j < tab.GetLength(1); j++)
                    {
                        bool skipCol = Skip(t0, col, t1, t2, a1, a2, s1, s2, o1, o2, v1, v2, tab.GetLength(1), j);
                        if (skipCol) continue;

                        if (ri == 0)
                        {
                            if (j == tab.GetLength(1) - 1)
                            {
                                table.Set(new Coord(1, ci + 2), "Grand Total", double.NaN, CellType.Text, null);
                            }
                            else
                            {
                                if (col == "a") table.Set(new Coord(1, ci + 2), "" + j, double.NaN, CellType.Text, null);
                                else if (col == "t") table.Set(new Coord(1, ci + 2), "" + (j + t0), double.NaN, CellType.Text, null);
                                else if (col == "o") table.Set(new Coord(1, ci + 2), "" + origins[j], double.NaN, CellType.Text, null);
                                else if (col == "s") table.Set(new Coord(1, ci + 2), "" + sexs[j], double.NaN, CellType.Text, null);
                                else if (col == "v") table.Set(new Coord(1, ci + 2), "" + vars[j], double.NaN, CellType.Text, null);
                            }
                        }

                        if (ci == 0)
                        {
                            if (i == tab.GetLength(0) - 1)
                            {
                                table.Set(new Coord(ri + 2, 1), "Grand Total", double.NaN, CellType.Text, null);
                            }
                            else
                            {
                                if (row == "a") table.Set(new Coord(ri + 2, 1), "" + i, double.NaN, CellType.Text, null);
                                else if (row == "t") table.Set(new Coord(ri + 2, 1), "" + (i + t0), double.NaN, CellType.Text, null);
                                else if (row == "o") table.Set(new Coord(ri + 2, 1), origins[i], double.NaN, CellType.Text, null);
                                else if (row == "s") table.Set(new Coord(ri + 2, 1), sexs[i], double.NaN, CellType.Text, null);
                                else if (row == "v") table.Set(new Coord(ri + 2, 1), vars[i], double.NaN, CellType.Text, null);
                            }
                        }

                        if (i == tab.GetLength(0) - 1 && j == tab.GetLength(1) - 1)
                        {
                            table.Set(new Coord(ri + 2, ci + 2), null, totalSum, CellType.Number, format);
                        }
                        else if (i == tab.GetLength(0) - 1)
                        {
                            table.Set(new Coord(ri + 2, ci + 2), null, colSum[j], CellType.Number, format);
                        }
                        else if (j == tab.GetLength(1) - 1)
                        {
                            table.Set(new Coord(ri + 2, ci + 2), null, rowSum, CellType.Number, format);
                        }
                        else
                        {
                            rowSum += tab[i, j];
                            totalSum += tab[i, j];
                            colSum[j] += tab[i, j];
                            table.Set(new Coord(ri + 2, ci + 2), null, tab[i, j], CellType.Number, format);
                        }

                        ci++;
                    }
                    ri++;
                }
            }

            G.Writeln("DREAM decomposition end");

            //G.Writeln2("max = " + max);
            //G.Writeln("t0 " + (DateTime.Now - t0).TotalMilliseconds);
            //G.Writeln("t1 " + (DateTime.Now - t1).TotalMilliseconds);

            //          E_LMax(oLab,s,ax0,t) $ tcx0(t)..
            // LMax(oLab,s,ax0,t) =E= J_LMax(oLab,s,ax0,t) +
            //(  eta(oLab,s,ax0,t)*
            //  ( (1-tmargWork(oLab,s,ax0,t))*adjrho(t)*rho(oLab,s,ax0,t)*W(t)/PCH('C',t) )**gamma(s)  ) + adjLmax(oLab,s,ax0,t);

            return table;
        }

        private static bool Skip(int t0, string col, string t1, string t2, string a1, string a2, string s1, string s2, string o1, string o2, string v1, string v2, int n, int j)
        {
            bool skipCol = false;
            if (col == "t" && t1 != null)
                if (j < int.Parse(t1) - t0 || j > int.Parse(t2) - t0) skipCol = true;
            if (col == "s" && s1 != null)
                if (j < int.Parse(s1) || j > int.Parse(s2)) skipCol = true;
            if (col == "a" && a1 != null)
                if (j < int.Parse(a1) || j > int.Parse(a2)) skipCol = true;
            if (col == "o" && o1 != null)
                if (j < int.Parse(o1) || j > int.Parse(o2)) skipCol = true;
            if (col == "v" && v1 != null)
                if (j < int.Parse(v1) || j > int.Parse(v2)) skipCol = true;
            if (j == n - 1) skipCol = false;
            return skipCol;
        }

        private static string GetRhomeWin32NT(StringBuilder logger)
        {
            RegistryKey rCoreKey = GetRCoreRegistryKeyWin32(logger);
            return GetRInstallPathFromRCoreKegKey(rCoreKey, logger);
        }

        private static string RecurseFirstSubkey(RegistryKey rCoreKey, StringBuilder logger)
        {
            string[] subKeyNames = rCoreKey.GetSubKeyNames();
            if (subKeyNames.Length > 0)
            {
                var versionNum = subKeyNames.First();
                var rVersionCoreKey = rCoreKey.OpenSubKey(versionNum);
                //doLogSetEnvVarInfo("As a last resort, trying to recurse into " + rVersionCoreKey, logger);
                return GetRInstallPathFromRCoreKegKey(rVersionCoreKey, logger);
            }
            else
            {
                //doLogSetEnvVarWarn("No sub-key found under " + rCoreKey, logger);
                return null;
            }
        }

        private static string GetRCurrentVersionStringFromRegistry(RegistryKey rCoreKey)
        {
            return rCoreKey.GetValue("Current Version") as string;
        }

        private static string GetRInstallPathFromRCoreKegKey(RegistryKey rCoreKey, StringBuilder logger)
        {
            string installPath = null;
            string[] subKeyNames = rCoreKey.GetSubKeyNames();
            string[] valueNames = rCoreKey.GetValueNames();
            if (valueNames.Length == 0)
            {
                //doLogSetEnvVarWarn("Did not find any value names under " + rCoreKey, logger);
                return RecurseFirstSubkey(rCoreKey, logger);
            }
            else
            {
                const string installPathKey = "InstallPath";
                if (valueNames.Contains(installPathKey))
                {
                    //doLogSetEnvVarInfo("Found sub-key InstallPath under " + rCoreKey, logger);
                    installPath = (string)rCoreKey.GetValue(installPathKey);
                }
                else
                {
                    //doLogSetEnvVarInfo("Did not find sub-key InstallPath under " + rCoreKey, logger);
                    if (valueNames.Contains("Current Version"))
                    {
                        //doLogSetEnvVarInfo("Found sub-key Current Version under " + rCoreKey, logger);
                        string currentVersion = GetRCurrentVersionStringFromRegistry(rCoreKey);
                        if (subKeyNames.Contains(currentVersion))
                        {
                            var rVersionCoreKey = rCoreKey.OpenSubKey(currentVersion);
                            return GetRInstallPathFromRCoreKegKey(rVersionCoreKey, logger);
                        }
                        else
                        {
                            //doLogSetEnvVarWarn("Sub key " + currentVersion + " not found in " + rCoreKey, logger);
                        }
                    }
                    else
                    {
                        //doLogSetEnvVarInfo("Did not find sub-key Current Version under " + rCoreKey, logger);
                        return RecurseFirstSubkey(rCoreKey, logger);
                    }
                }
            }
            //doLogSetEnvVarInfo(string.Format("InstallPath value of key " + rCoreKey.ToString() + ": {0}",
            // installPath == null ? "null" : installPath), logger);
            return installPath;
        }

        private static void CheckPlatformWin32()
        {
            if (Environment.OSVersion.Platform != PlatformID.Win32NT)
                throw new NotSupportedException("This method is supported only on the Win32NT platform");
        }

        private static RegistryKey GetRCoreRegistryKeyWin32(StringBuilder logger)
        {
            CheckPlatformWin32();
            var rCore = Registry.LocalMachine.OpenSubKey(@"SOFTWARE\R-core");
            if (rCore == null)
            {
                //doLogSetEnvVarInfo(@"Local machine SOFTWARE\R-core not found - trying current user", logger);
                rCore = Registry.CurrentUser.OpenSubKey(@"SOFTWARE\R-core");
                if (rCore == null)
                    throw new ApplicationException("Windows Registry key 'SOFTWARE\\R-core' not found in HKEY_LOCAL_MACHINE nor HKEY_CURRENT_USER");
            }
            //doFoundWinRegKey(rCore, logger);
            bool is64Bit = Environment.Is64BitProcess;
            var subKey = is64Bit ? "R64" : "R";
            var r = rCore.OpenSubKey(subKey);
            if (r == null)
            {
                throw new ApplicationException(string.Format(
                   "Windows Registry sub-key '{0}' of key '{1}' was not found", subKey, rCore.ToString()));
            }
            //doFoundWinRegKey(rCore, logger);
            return r;
        }

        public static string MatrixFromGekkoToR<T>(string Name, T[,] m)
        {

            if (m == null || m.Length == 0) return null;

            string s = Name + " = c(" + m[0, 0];

            for (int i = 1; i < m.GetLength(0); i++)
                s += "," + m[i, 0];

            for (int j = 1; j < m.GetLength(1); j++)
                for (int i = 0; i < m.GetLength(0); i++)
                    s += "," + m[i, j];

            s += ")" + G.NL;
            s += "dim(" + Name + ") = c(" + m.GetLength(0) + ", " + m.GetLength(1) + ")";
            return s;
        }

        public static void RunR(Gekko.O.R_run o)
        {
            //This is just a rename, can be remove at some point in the future
            if (Program.options.r_exe_folder == null || Program.options.r_exe_folder == "")
            {
                if (Program.options.r_exe_path != null && Program.options.r_exe_path != "")
                {
                    Program.options.r_exe_folder = Program.options.r_exe_path;
                }
            }

            string RFileName = Globals.localTempFilesLocation + "\\tempRFile.r";
            string RExportFileName = Globals.localTempFilesLocation + "\\tempR2Gekko.txt";
            List<string> lines2 = new List<string>();

            string def1 = "#gekkoexport function def start";
            string def2 = "#gekkoexport function def end";

            lines2.Add(def1);
            lines2.Add("gekkoexport  <- function(input) {");
            lines2.Add("  name <- deparse(substitute(input))");
            lines2.Add("  filename <- `" + RExportFileName.Replace("\\", "\\\\") + "`");
            lines2.Add("  cols <- NCOL(input)");
            lines2.Add("  write(paste(`name = `, name), filename, append=TRUE)");
            lines2.Add("  write(paste(`rows = `, as.character(NROW(input))), filename, append=TRUE)");
            lines2.Add("  write(paste(`cols = `, as.character(NCOL(input))), filename, append=TRUE)");
            lines2.Add("  write(t(input), file = filename, n=cols, append=TRUE)");
            lines2.Add("  write(`-------------------`, filename, append=TRUE)");
            lines2.Add("}");
            lines2.Add(def2);
            string f = G.ExtractTextFromLines(lines2).ToString().Replace("`", Globals.QT);

            using (FileStream fs = WaitForFileStream(RFileName, GekkoFileReadOrWrite.Write))
            using (StreamWriter sw = G.GekkoStreamWriter(fs))
            {
                sw.Write(f);
                foreach (string s2 in Globals.r_fileContent)
                {
                    if (s2.TrimStart().ToLower().StartsWith("gekkoimport ")) continue;
                    sw.WriteLine(s2);
                }
                sw.Flush();
                sw.Close();
            }

            //Make r2gekko.txt file that R later on fills into
            using (FileStream fs = WaitForFileStream(RExportFileName, GekkoFileReadOrWrite.Write))
            using (StreamWriter sw = G.GekkoStreamWriter(fs))
            {
                sw.WriteLine("R2Gekko version 1.0");
                sw.WriteLine("-------------------");
                sw.Flush();
                sw.Close();
            }

            string RPathUsedHere = null;
            if (Program.options.r_exe_folder.Trim() == "")
            {
                //no path stated manually
                if (Globals.detectedRPath == null || Globals.detectedRPath == "[[RDetectFailed]]")
                {
                    //do not do this every time R is called!
                    string RPath = GetRhomeWin32NT(null);
                    if (RPath == null || RPath.Trim() == "") Globals.detectedRPath = "[[RDetectFailed]]";
                    else Globals.detectedRPath = RPath + "\\bin\\R.exe";
                }
                else
                {
                    //either second etc. time, or previous detect fail                    
                }
                RPathUsedHere = Globals.detectedRPath;
            }
            else
            {
                //overrides
                if (Program.options.r_exe_folder.ToLower().EndsWith("\\r.exe"))
                {
                    RPathUsedHere = Program.options.r_exe_folder;
                }
                else
                {
                    if (Program.options.r_exe_folder.EndsWith("\\")) RPathUsedHere = Program.options.r_exe_folder + "R.exe";
                    else RPathUsedHere = Program.options.r_exe_folder + "\\R.exe";
                }
            }

            //Now RPathUsedHere should be either
            // - A file path ending with "\R.exe"
            // - "[[RDetectFailed]]"

            if (RPathUsedHere == "[[RDetectFailed]]")
            {
                G.Writeln2("*** ERROR: R.exe path could not be auto-detected.");
                G.Writeln("           Please state the R.exe path manually with OPTION r exe folder = ...");
                throw new GekkoException();
            }

            //Now RPathUsedHere is a file path ending with "\R.exe"            

            Process r = new Process();

            //It seems that \bin\R.exe calls \i386\R.exe or \x64\R.exe depending on R settings on the user's computer.
            r.StartInfo.FileName = RPathUsedHere;
            r.StartInfo.Arguments = " CMD BATCH --no-save " + Globals.QT + RFileName + Globals.QT + " " + Globals.QT + RFileName + ".txt" + Globals.QT;
            r.StartInfo.WindowStyle = ProcessWindowStyle.Hidden;

            try
            {
                r.Start();
            }
            catch (Exception e)
            {
                if (!File.Exists(r.StartInfo.FileName))
                {
                    if (Program.options.r_exe_folder.Trim() == "")
                    {
                        //auto-detect
                        G.Writeln2("*** ERROR: Error message: " + e.Message);
                        G.Writeln("*** ERROR: The file " + RPathUsedHere + " does not seem to exist.");
                        G.Writeln("           You may try to manually set \"OPTION r exe folder = ... , if you know the R.exe location.");
                        G.Writeln("           R.exe file locations may be similar to these:");
                        G.Writeln("             c:\\Program Files\\R\\R-3.0.0\\bin\\R.exe");
                        G.Writeln("             c:\\Program Files\\R\\R-3.0.0\\bin\\i386\\R.exe");
                        G.Writeln("             c:\\Program Files\\R\\R-3.0.0\\bin\\x64\\R.exe");
                        G.Writeln("           The first one is generic, the second is 32-bit, and the last is 64-bit");
                    }
                    else
                    {
                        //stated manually
                        G.Writeln2("*** ERROR: Error message: " + e.Message);
                        G.Writeln("*** ERROR: The file " + RPathUsedHere + " does not seem to exist.");
                        G.Writeln("           You may try to set \"OPTION r exe path = '';\" (or remove the option),");
                        G.Writeln("           which will make Gekko try to auto-detect the R.exe path.");
                        G.Writeln("           R.exe file locations may be similar to these:");
                        G.Writeln("             c:\\Program Files\\R\\R-3.0.0\\bin\\R.exe");
                        G.Writeln("             c:\\Program Files\\R\\R-3.0.0\\bin\\i386\\R.exe");
                        G.Writeln("             c:\\Program Files\\R\\R-3.0.0\\bin\\x64\\R.exe");
                        G.Writeln("           The first one is generic, the second is 32-bit, and the last is 64-bit");
                    }
                }
                else
                {
                    G.Writeln2("*** ERROR: Error message: " + e.Message);
                    G.Writeln("*** ERROR: The file " + RPathUsedHere + " exists, but R fails");
                }
                throw new GekkoException();
            }

            r.WaitForExit();

            if (!G.equal(o.opt_mute, "yes") && File.Exists(RFileName + ".txt"))
            {
                string s3 = GetTextFromFileWithWait(RFileName + ".txt");
                List<string> ss = G.ExtractLinesFromText(s3);
                bool skip = true;  //avoid the method and the R header in input
                G.Writeln();
                foreach (string s2 in ss)
                {                    
                    if (!skip) G.Writeln(s2);
                    if (s2.Contains(def2)) skip = false;
                }
                G.Writeln();
            }

            string s = Program.GetTextFromFileWithWait(RExportFileName);
            List<string> lines = G.ExtractLinesFromText(s);
            string data = null;
            string name = null;
            int rows = -12345;
            int cols = -12345;
            bool first = true;
            foreach (string line in lines)
            {
                if (line.StartsWith("R2Gekko")) continue;
                if (line.StartsWith("---"))
                {
                    if (first)
                    {
                        first = false;
                        continue;
                    }
                    else
                    {
                        string[] ss = data.Split(new char[] { ' ' }, StringSplitOptions.RemoveEmptyEntries);
                        if (Program.scalars.ContainsKey(Globals.symbolList + name))
                        {
                            Program.scalars.Remove(Globals.symbolList + name);
                        }
                        Matrix m = new Matrix(rows, cols);

                        int cnt = -1;
                        foreach (string s2 in ss)
                        {
                            cnt++;
                            double d = double.NaN;
                            if (s2 != "NA") d = double.Parse(s2);
                            m.data[cnt / cols, cnt % cols] = d;
                        }
                        Program.scalars.Add(Globals.symbolList + name, m);

                        data = null;
                        name = null;
                        rows = -12345;
                        cols = -12345;
                        continue;
                    }
                }
                if (line.StartsWith("name ="))
                {
                    name = line.Split('=')[1].Trim();
                    continue;
                }
                if (line.StartsWith("rows ="))
                {
                    rows = int.Parse(line.Split('=')[1].Trim());
                    continue;
                }
                if (line.StartsWith("cols ="))
                {
                    cols = int.Parse(line.Split('=')[1].Trim());
                    continue;
                }
                data += line + " ";
            }
            //WaitForFileDelete(
        }

        public static void X12a(Gekko.O.X12a o)
        {
            string tempName = "tempX12aFile";
            string spcFileName = Globals.localTempFilesLocation + "\\" + tempName + ".spc";
            List<string> lines2 = new List<string>();

            //Delete tempX12aFile.*
            string[] files = Directory.GetFiles(Globals.localTempFilesLocation, "" + tempName + "*.*");
            foreach (string file in files) WaitForFileDelete(file);

            string meta = null;
            int counter = 0;
                        
            for (int i = 0; i < o.listItems.Count; i++)
            {
                //GetTimeSeriesFromStringWildcard() implicitly calls GetInfoFromStringWildcard() which we will call again later.
                List<TimeSeries> tss = Program.GetTimeSeriesFromStringWildcard(o.listItems[i], o.opt_bank);
                foreach (TimeSeries ts in tss)
                {
                    counter++;
                    string data = null;
                    foreach (GekkoTime t in new GekkoTimeIterator(o.t1, o.t2))
                    {
                        double v = ts.GetData(t);
                        if (G.isNumericalError(v))
                        {
                            G.Writeln2("*** ERROR: Missing value in '" + ts.variableName + "', period " + G.FromDateToString(t));
                            throw new GekkoException();
                        }
                        //data += t.super + " " + t.sub + " " + v.ToString() + G.NL;
                        data += v.ToString() + G.NL;
                    }
                    //Create data files
                    meta += tempName + counter + ".dat" + G.NL;
                    using (FileStream fs = WaitForFileStream(Globals.localTempFilesLocation + "\\" + tempName + counter + ".dat", GekkoFileReadOrWrite.Write))
                    using (StreamWriter sw = G.GekkoStreamWriter(fs))
                    {
                        sw.Write(data);
                        sw.Flush();
                        sw.Close();
                    }
                }
            }
            
            using (FileStream fs = WaitForFileStream(Globals.localTempFilesLocation + "\\" + tempName + ".dta", GekkoFileReadOrWrite.Write))
            using (StreamWriter sw = G.GekkoStreamWriter(fs))
            {
                sw.Write(meta);
                sw.Flush();
                sw.Close();
            }
            string s2 = null;
            s2 += "series {" + G.NL;  //for instance 2000.2
            s2 += "start = " + o.t1.super + "." + o.t1.sub + G.NL;  //for instance 2000.2
            s2 += "period = " + GetFreqNumbers(o.t1.freq) + G.NL;  //4 or 12
            s2 += "}" + G.NL;

            s2 += "x11{ " + o.opt_param + " }" + G.NL;

            //Create tempX12aFile.spc
            using (FileStream fs = WaitForFileStream(spcFileName, GekkoFileReadOrWrite.Write))
            using (StreamWriter sw = G.GekkoStreamWriter(fs))
            {
                sw.Write(s2);
                sw.Flush();
                sw.Close();
            }

            string currentDir = Directory.GetCurrentDirectory();  //remembered in order to switch back
            Directory.SetCurrentDirectory(Globals.localTempFilesLocation);
            try
            {
                Process process = new Process();
                string startup = null;
                if (G.IsUnitTesting())
                {
                    startup = Globals.ttPath2 + "\\" + Globals.ttPath3 + "\\Gekko\\bin\\Debug";
                }
                else
                {
                    startup = Application.StartupPath;
                }

                process.StartInfo.FileName = startup + "\\X12A.EXE";
                process.StartInfo.WindowStyle = ProcessWindowStyle.Hidden;
                //tempName does not contain blanks, so quotes are not needed
                //TODO: perhaps do this like PLOT with random numbers attached
                process.StartInfo.Arguments = tempName + " -d " + tempName;
                process.Start();
                process.WaitForExit();
                process.Close();
            }
            finally
            {
                Directory.SetCurrentDirectory(currentDir);
            }

            List<string> ext = new List<string>() { "c17", "d10", "d11", "d12", "d13", "saa" };
            //Import data
            files = Directory.GetFiles(Globals.localTempFilesLocation, "" + tempName + "*.*");
            bool first = true;
            foreach (string file in files)
            {
                for (int i = 0; i < o.listItems.Count; i++)
                {
                    List<BankNameVersion> list = GetInfoFromStringWildcard(o.listItems[i], o.opt_bank);
                    foreach (BankNameVersion bnv in list)
                    {
                        foreach (string e in ext)
                        {
                            string sss = Path.GetFileName(file);
                            if (G.equal(sss, tempName + (i + 1) + "." + e))
                            {
                                string varName = bnv.name + "_" + e;
                                TimeSeries ts = new TimeSeries(o.t1.freq, varName);
                                string s = Program.GetTextFromFileWithWait(file);
                                List<string> lines = G.ExtractLinesFromText(s);
                                foreach (string line in lines)
                                {
                                    if (line.TrimStart().ToLower().StartsWith("date")) continue;
                                    if (line.TrimStart().ToLower().StartsWith("---")) continue;
                                    string[] ss = line.Split(new string[] { "\t" }, StringSplitOptions.RemoveEmptyEntries);
                                    if (ss.Length != 2)
                                    {
                                        G.Writeln2("*** ERROR: Error #8907523 in X12A");
                                        throw new GekkoException();
                                    }
                                    try
                                    {
                                        if (ss[0].Length != 6)
                                        {
                                            G.Writeln2("*** ERROR: Error #897525 in X12A");
                                            throw new GekkoException();
                                        }
                                        int i1 = int.Parse(ss[0].Substring(0, 4));
                                        int i2 = int.Parse(ss[0].Substring(4, 2));
                                        GekkoTime gt = new GekkoTime(o.t1.freq, i1, i2);
                                        ts.SetData(gt, double.Parse(ss[1]));
                                    }
                                    catch
                                    {
                                        G.Writeln2("*** ERROR: Error #897524 in X12A");
                                        throw new GekkoException();
                                    }
                                }
                                Databank db = Program.databanks.GetDatabank(bnv.bank);
                                if (db == null)
                                {
                                    //this is probably not possible, since the bank would have failed previously
                                    G.Writeln2("*** ERROR: Databank " + bnv.bank + " not found");
                                    throw new GekkoException();
                                }
                                if (db.ContainsVariable(varName))
                                {
                                    db.RemoveVariable(varName);
                                }
                                db.AddVariable(ts);
                                if (first) G.Writeln();
                                G.Writeln("Adjusted timeseries: " + db.aliasName + ":" + varName);
                                first = false;
                            }
                        }
                    }
                }
            }

            if (first)
            {
                G.Writeln2("Did not produce any adjusted timeseries. See more info in the tempX12aFile...");
                G.Writeln("files here: " + Globals.localTempFilesLocation);
            }
            if (!(o.opt_param.ToLower().Contains("totals") && o.opt_param.ToLower().Contains("force")))
            {
                if (o.opt_param.ToLower().Contains("saa"))
                {
                    G.Writeln("+++ NOTE: For 'saa' type, you need 'force=totals'");
                }
            }
        }

        private static string GetFreqNumbers(EFreq freq)
        {
            string per = "";
            if (freq == EFreq.Annual)
            {
                G.Writeln2("*** ERROR: You cannot use X12A on an annual timeseries");
                throw new GekkoException();
            }
            else if (freq == EFreq.Undated)
            {
                G.Writeln2("*** ERROR: You cannot use X12A on an undated timeseries");
                throw new GekkoException();
            }
            else if (freq == EFreq.Quarterly)
            {
                per = "4";
            }
            else if (freq == EFreq.Monthly)
            {
                per = "12";
            }
            return per;
        }

        public static void ShowMatrix(Matrix a, string label)
        {
            if (a.data.GetLength(0) < 1 || a.data.GetLength(1) < 1)
            {
                G.Writeln2("The matrix has dimensions " + a.data.GetLength(0) + "x" + a.data.GetLength(1) + ", and cannot be printed");
                throw new GekkoException();
            }
            Gekko.Table tab = new Gekko.Table();
            for (int i = 0; i < a.data.GetLength(0); i++)
            {
                for (int j = 0; j < a.data.GetLength(1); j++)
                {
                    Cell c = new Cell();
                    c.cellType = CellType.Number;
                    c.number = a.data[i, j];
                    c.numberFormat = "f" + Program.options.print_fields_nwidth + "." + Program.options.print_fields_ndec + "";
                    tab.Set(new Coord(i + 2, j + 2), c);
                }
            }
            for (int i = 0; i < a.data.GetLength(0); i++)
            {
                //row dimension
                Cell c = null;
                if (a.rownames != null && i < a.rownames.Count && a.rownames[i].Trim() != "")
                {
                    c = new Cell();
                    c.cellType = CellType.Text;
                    c.CellText = new Gekko.Text();
                    c.CellText.TextData = new List<string> { a.rownames[i].Trim() };
                    c.align = -1;                                   
                }
                else
                {
                    c = new Cell();
                    c.cellType = CellType.Number;
                    c.number = i + 1;
                    c.numberFormat = "f4.0";
                }
                tab.Set(new Coord(i + 2, 1), c);
            }
            for (int i = 0; i < a.data.GetLength(1); i++)
            {
                //col dimension                
                Cell c = null;
                if (a.colnames != null && i < a.colnames.Count && a.colnames[i].Trim() != "")
                {
                    c = new Cell();
                    c.cellType = CellType.Text;
                    c.CellText = new Gekko.Text();
                    c.CellText.TextData = new List<string> { a.colnames[i].Trim() };
                    c.align = 1;
                }
                else
                {
                    c = new Cell();
                    c.cellType = CellType.Number;
                    c.number = i + 1;
                    c.numberFormat = "f4.0";
                }
                tab.Set(new Coord(1, i + 2), c);
            }
            List<string> xx = tab.PrintText();

            int widthRemember = Program.options.print_width;
            int fileWidthRemember = Program.options.print_filewidth;
            Program.options.print_width = int.MaxValue;
            Program.options.print_filewidth = int.MaxValue;

            G.Writeln();

            string label2 = G.ReplaceGlueNew(label);
            label2 = ScalarString.SubstituteScalarsInString(label2, false, true);
            G.Writeln(label2);
            foreach (string s in xx)
            {
                G.Writeln(s);
            }

            Program.options.print_width = widthRemember;
            Program.options.print_filewidth = fileWidthRemember;

            Globals.lastPrtOrMulprtTable = tab;  //this puts the matrix on the clipboard.
            CrossThreadStuff.CopyButtonEnabled(true);
        }



        public static bool IsLargeAware(string file)
        {
            using (var fs = File.OpenRead(file))
            {
                return IsLargeAware(fs);
            }
        }

        /// <summary>
        /// Checks if the stream is a MZ header and if it is large address aware
        /// </summary>
        /// <param name="stream">Stream to check, make sure its at the start of the MZ header</param>
        /// <exception cref=""></exception>
        /// <returns></returns>
        public static bool IsLargeAware(Stream stream)
        {
            const int IMAGE_FILE_LARGE_ADDRESS_AWARE = 0x20;

            var br = new BinaryReader(stream);

            if (br.ReadInt16() != 0x5A4D)       //No MZ Header
                return false;

            br.BaseStream.Position = 0x3C;
            var peloc = br.ReadInt32();         //Get the PE header location.

            br.BaseStream.Position = peloc;
            if (br.ReadInt32() != 0x4550)       //No PE header
                return false;

            br.BaseStream.Position += 0x12;
            return (br.ReadInt16() & IMAGE_FILE_LARGE_ADDRESS_AWARE) == IMAGE_FILE_LARGE_ADDRESS_AWARE;
        }

        public static void Stamp()
        {

            if (!Globals.runningOnTTComputer)
            {
                G.Writeln2("*** ERROR: Please use: TELL currentDateTime();");
                throw new GekkoException();
            }
            else
            {
                G.Writeln2("*** ERROR: Please use: TELL currentDateTime();");
            }
        }

        public static void FlowChart(string s, string code, GekkoTime period)
        {
            Dictionary<string, int> counter = new Dictionary<string, int>(StringComparer.OrdinalIgnoreCase);
            List<GekkoFlowChart.FlowNode> sw2 = new List<GekkoFlowChart.FlowNode>();
            List<GekkoFlowChart.FlowArrow> sw = new List<GekkoFlowChart.FlowArrow>();

            int maxDepth = 20;
            double prune = Globals.pruneDecomp;  //is relative, NOT percent
            //int year = int.Parse(s2);  //TODO: quarters etc.

            counter.Add(s, counter.Count);

            GekkoFlowChart.FlowNode fn = new GekkoFlowChart.FlowNode();
            fn.varName = s;
            fn.counter = counter[s];
            fn.labelBig = Program.FlowInsertLabel(s);
            if (Program.VariableTypeEndoExo(s) == EEndoOrExo.Exo) fn.isExogenous = true;
            else fn.isExogenous = false;
            fn.isStartNode = true;
            sw2.Add(fn);

            Dictionary<string, int> d = new Dictionary<string, int>(StringComparer.OrdinalIgnoreCase);
            d.Add(s, 0);
            Program.DecompForFlowChart(s, period, maxDepth, prune, 1d, 0, counter, sw, sw2, d, code);
            G.Writeln();

            GekkoFlowChart.Helper h = new GekkoFlowChart.Helper();
            h.flowArrows = sw;
            h.flowNodes = sw2;
            GekkoFlowChart.FruchtermanReingoldLayout.h = h;
            GekkoFlowChart.DataModel.instance = new GekkoFlowChart.DataModel(-12345, Globals.pruneDecomp, true);
            System.Windows.Window w = new GekkoFlowChart.MainWindow();
            w.Show();
        }

        public static string FlowInsertLabel(string s)
        {
            return GetVariableExplanationAugmented(s, G.ExtractOnlyVariableIgnoreLag(s, Globals.leftParenthesisIndicator));
        }

        public static string GetVariableExplanationAugmented(string variableNameWithLag, string variableNameWithoutLag)
        {
            string ss = G.PrettifyTimeseriesHash(variableNameWithLag, true, false) + "\n";
            List<string> varExpl = Program.GetVariableExplanation(variableNameWithoutLag);
            if (Program.unfoldedVariableList == null) varExpl.Add("[Label not found: no model varlist loaded]");
            foreach (string line in varExpl)
            {
                if (line != "")
                {
                    ss += line + "\n";
                }
            }
            try
            {
                TimeSeries ts = Program.databanks.GetFirst().GetVariable(variableNameWithoutLag);
                if (ts != null)
                {
                    string label = ts.label;
                    string source = ts.source;
                    if (label != null && label.Trim() != "")
                    {
                        ss += "Series label: " + label + "\n";
                    }
                    if (source != null && source.Trim() != "")
                    {
                        ss += "Series source: " + source + "\n";
                    }
                }
            }
            catch
            {
                //no need to fail on this
            }
            return ss;
        }

        public static void DecompForFlowChart(string s, GekkoTime year, int maxDepth, double prune, double factor, int depth, Dictionary<string, int> counter, List<GekkoFlowChart.FlowArrow> sw, List<GekkoFlowChart.FlowNode> sw2, Dictionary<string, int> d, string code)
        {
            if (!Program.model.m2.endogenous.ContainsKey(s))
            {
                //do nothing
            }
            else
            {
                G.Writeln("FLOW = " + s + ", depth = " + depth + ", factor = " + factor);
                DecompOptions decompOptions = new DecompOptions();
                //decompOptions.vars = new List<string>() { s };
                decompOptions.t1 = year;
                decompOptions.t2 = year;
                decompOptions.localBanks = new LocalBanks();
                decompOptions.type = "sq";  //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
                decompOptions.variable = s;
                Table table = Program.DecompHelper2(decompOptions, code, false);
                //table.PrintCellsForDebug();
                //List<string> stable = table.Print();
                //foreach (string s in stable) G.Writeln(s);

                string dependent = table.Get(2, 1).CellText.TextData[0];

                for (int i = 3; i < table.GetRowMaxNumber() + 1; i++)
                {
                    string variable = table.Get(i, 1).CellText.TextData[0];
                    double effect = table.Get(i, 2).number;
                    double ff = factor * effect / 100d;
                    //G.Writeln(i + " " + table.Get(i, 1).CellText.TextData[0] + " " + table.Get(i, 2).number);
                    if (Math.Abs(effect) > prune * 100d)
                    {
                        if (!counter.ContainsKey(variable))
                        {
                            GekkoFlowChart.FlowNode fn = new GekkoFlowChart.FlowNode();
                            counter.Add(variable, counter.Count);
                            fn.varName = variable;
                            fn.counter = counter[variable];
                            fn.labelBig = FlowInsertLabel(variable);
                            if (Program.VariableTypeEndoExo(variable) == EEndoOrExo.Exo) fn.isExogenous = true;
                            else fn.isExogenous = false;
                            fn.isStartNode = false;
                            fn.id = counter[variable];
                            sw2.Add(fn);
                            //if (G.equal(variable, "pm59"))
                            //    G.Writeln();
                        }
                        GekkoFlowChart.FlowArrow fa = new GekkoFlowChart.FlowArrow();
                        fa.varName1 = variable;
                        fa.varName2 = dependent;
                        fa.counter1 = counter[variable];
                        fa.counter2 = counter[dependent];
                        fa.weight = ff;

                        string aname = fa.varName1 + "," + fa.varName2;
                        if (d.ContainsKey(aname))
                        {
                            continue;  //no loops
                        }

                        d.Add(aname, 0);
                        sw.Add(fa);

                        if (depth < maxDepth && Math.Abs(ff) > prune)
                        {
                            if (d.ContainsKey(variable)) continue;  //do not do loops
                            DecompForFlowChart(variable, year, maxDepth, prune, ff, depth + 1, counter, sw, sw2, d, code);
                        }
                    }
                }
            }
        }

        public static bool TestKP2010Model()
        {
            Dictionary<string, CompareHelper> skip = new Dictionary<string, CompareHelper>(StringComparer.OrdinalIgnoreCase);
            skip.Add("RKQYFA", new CompareHelper(new GekkoTime((Program.options.freq), 2011, 1), new GekkoTime((Program.options.freq), 2011, 1)));
            skip.Add("RKQYFB", new CompareHelper(new GekkoTime((Program.options.freq), 2011, 1), new GekkoTime((Program.options.freq), 2011, 1)));
            skip.Add("RKQYFNB", new CompareHelper(new GekkoTime((Program.options.freq), 2011, 1), new GekkoTime((Program.options.freq), 2011, 1)));
            skip.Add("RKQYFNF", new CompareHelper(new GekkoTime((Program.options.freq), 2011, 1), new GekkoTime((Program.options.freq), 2011, 1)));
            skip.Add("RKQYFNK", new CompareHelper(new GekkoTime((Program.options.freq), 2011, 1), new GekkoTime((Program.options.freq), 2011, 1)));
            skip.Add("RKQYFNM", new CompareHelper(new GekkoTime((Program.options.freq), 2011, 1), new GekkoTime((Program.options.freq), 2011, 1)));
            skip.Add("RKQYFNN", new CompareHelper(new GekkoTime((Program.options.freq), 2011, 1), new GekkoTime((Program.options.freq), 2011, 1)));
            skip.Add("RKQYFNQ", new CompareHelper(new GekkoTime((Program.options.freq), 2011, 1), new GekkoTime((Program.options.freq), 2011, 1)));
            skip.Add("RKQYFNT", new CompareHelper(new GekkoTime((Program.options.freq), 2011, 1), new GekkoTime((Program.options.freq), 2011, 1)));
            skip.Add("RKQYFQH", new CompareHelper(new GekkoTime((Program.options.freq), 2011, 1), new GekkoTime((Program.options.freq), 2011, 1)));
            skip.Add("RKQYFQQ", new CompareHelper(new GekkoTime((Program.options.freq), 2011, 1), new GekkoTime((Program.options.freq), 2011, 1)));
            skip.Add("RKQYFQT", new CompareHelper(new GekkoTime((Program.options.freq), 2011, 1), new GekkoTime((Program.options.freq), 2011, 1)));
            //btydd is due to _G__D code, see patchZvar option (probably Gekko error)
            skip.Add("BTYDD", new CompareHelper(new GekkoTime((Program.options.freq), 2020, 1), new GekkoTime((Program.options.freq), 2020, 1)));
            //bven/bveq is strange: seems pcim error not consistent with equation
            skip.Add("bven", new CompareHelper(new GekkoTime((Program.options.freq), 2012, 1), new GekkoTime((Program.options.freq), 2020, 1)));
            skip.Add("bveq", new CompareHelper(new GekkoTime((Program.options.freq), 2012, 1), new GekkoTime((Program.options.freq), 2020, 1)));
            //ecpuxh difference probably because of data inaccuracy (tsd-file)
            skip.Add("ecpuxh", new CompareHelper(new GekkoTime((Program.options.freq), 2013, 1), new GekkoTime((Program.options.freq), 2016, 1)));
            skip.Add("efcpuxh", new CompareHelper(new GekkoTime((Program.options.freq), 2013, 1), new GekkoTime((Program.options.freq), 2013, 1)));
            //pivo is 0 in Gekko and missing in PCIM. Probably due to changed relation in Gekko. Variable not meaningful anyway.
            skip.Add("pivo", new CompareHelper(new GekkoTime((Program.options.freq), 2009, 1), new GekkoTime((Program.options.freq), 2020, 1)));
            //Tiskia is a bit strange: why is there a JR<>0 in PCIM, but not in Gekko.
            skip.Add("tiskia", new CompareHelper(new GekkoTime((Program.options.freq), 2012, 1), new GekkoTime((Program.options.freq), 2020, 1)));
            //uagap and ulgap: differences seem ok
            skip.Add("uagap", new CompareHelper(new GekkoTime((Program.options.freq), 2013, 1), new GekkoTime((Program.options.freq), 2015, 1)));
            skip.Add("ulgap", new CompareHelper(new GekkoTime((Program.options.freq), 2014, 1), new GekkoTime((Program.options.freq), 2015, 1)));

            int t1 = 2005;  //base databank starts in 2000
            //int t2 = 2100;
            int t2 = 2020;  //to avoid too many errors
            //these are set a bit loose to avoid too many errors

            double absCrit = 0.001d;
            double relCritSmart = 0.01d;  //1%
            double relCritNormal = 0.01d;  //1%

            List<string> both = new List<string>();
            Databank work = Program.databanks.GetFirst();
            Databank base2 = Program.databanks.GetRef();
            foreach (string tsString in work.storage.Keys)
            {
                TimeSeries tsGrund = base2.GetVariable(tsString);
                if (tsGrund != null)
                {
                    both.Add(tsString);
                }
            }
            both.Sort(StringComparer.InvariantCulture);
            int counter = 0;
            foreach (string s in both)
            {
                //these eliminate a lot of variables
                if (s.ToLower().StartsWith("j")) continue;
                if (s.ToLower().StartsWith("z")) continue;

                TimeSeries tsWork = work.GetVariable(s);
                TimeSeries tsBase = base2.GetVariable(s);
                bool ok2 = true;

                double maxVariance = 0d;
                foreach (GekkoTime t in new GekkoTimeIterator(new GekkoTime((Program.options.freq), t1, 1), new GekkoTime((Program.options.freq), t2, 1)))
                {
                    double variance = CalculateHistoricalVarianceForVariable(tsBase, t);
                    if (variance > maxVariance) maxVariance = variance;
                }

                foreach (GekkoTime t in new GekkoTimeIterator(new GekkoTime((Program.options.freq), t1, 1), new GekkoTime((Program.options.freq), t2, 1)))
                {

                    double valueWork = tsWork.GetData(t);
                    double valueBase = tsBase.GetData(t);
                    double relative = double.NaN;
                    bool isOk = CheckRelativeDifferenceSmart(1d, false, maxVariance, absCrit, relCritSmart, valueWork, valueBase, out relative);

                    if (!isOk)
                    {
                        if (Math.Abs(valueWork / valueBase - 1) < relCritNormal) isOk = true;  //overrules any problems if "real" % is small enough
                    }

                    if (!isOk)
                    {
                        if (skip.ContainsKey(s))
                        {
                            CompareHelper ch = skip[s];
                            if (t.LargerThanOrEqual(ch.t1) && t.SmallerThanOrEqual(ch.t2))
                            {
                                isOk = true;
                            }
                        }
                    }
                    if (!isOk)
                    {
                        G.Writeln("jul05 full check: variable " + s + " deviated in " + t.ToString() + " (variance is " + maxVariance + ")");
                        ok2 = false;
                        return false;  //can comment this out, in order to get full list of problems
                    }
                }
                if (ok2 == false) counter++;
            }
            return true;
        }

        public static void Randommodelcheck()
        {
            TimeSeries ts = Program.databanks.GetFirst().GetVariable("sum");
            foreach (GekkoTime t in new GekkoTimeIterator(new GekkoTime((Program.options.freq), 2002, 1), new GekkoTime((Program.options.freq), 2100, 1)))
            {
                if (Math.Abs(ts.GetData(t)) > 3 * 1.0e-4)  //hmmm seems error can be a little > 0.0001
                {
                    G.Writeln2("*** ERROR: Problem with this model -- try PRT sum");
                    throw new GekkoException();
                }
            }
            G.Writeln("Check ok");
        }

        public static void Randommodel()
        {

            int endoexo = 0;  //0 means none, 2 means 2 goals
            bool gaussMode = true;
            double factor = 2d; if (gaussMode) factor = factor / 2d;
            int nn = 50;
            Random r = new Random(11111);  //11111 used for regressions, with nn = 1000 and factor = 1d;



            for (int ii = 0; ii < nn; ii++)
            {
                if (true)
                {
                    int n = 20;
                    int p1 = 10;
                    int p2 = 10;
                    double[,] e = new double[n, n];
                    double[,] x = new double[n, 2];

                    for (int j1 = 0; j1 < n; j1++)
                    {
                        for (int j2 = 0; j2 < n; j2++)
                        {
                            if (r.Next(0, 100) < p1) e[j1, j2] = (double)r.Next(1, 999) / 1000d;
                        }
                        if (r.Next(0, 100) < p2) x[j1, 0] = (double)r.Next(1, 999) / 1000d;
                        if (r.Next(0, 100) < p2) x[j1, 1] = (double)r.Next(1, 999) / 1000d;
                    }

                    for (int j1 = 0; j1 < n; j1++)
                    {
                        double sum = 0d;
                        for (int j2 = 0; j2 < n; j2++)
                        {
                            sum += e[j1, j2];
                        }
                        if (sum == 0)
                        {
                            //row sum = 0
                            if (j1 > 0) e[j1, j1 - 1] = 0.55555d;
                            else e[j1, n - 1] = 0.55555d;
                        }
                    }

                    int i = r.Next(0, n - 1);
                    for (int j2 = 0; j2 < n; j2++)
                    {
                        e[i, j2] = 0;
                    }
                    x[i, 1] = 0.66666;  //inducing an equation Ei = 0.66666*X1, to start a prologue chain

                    double sum0 = 0d;
                    double sum1 = 0d;
                    for (int j1 = 0; j1 < n; j1++)
                    {
                        sum0 += x[j1, 0];
                        sum1 += x[j1, 1];
                    }

                    if (sum0 == 0)
                    {
                        x[r.Next(0, n - 1), 0] = 0.44444;
                    }
                    if (sum1 == 0)
                    {
                        x[r.Next(0, n - 1), 1] = 0.44444;
                    }

                    string ss = "";
                    for (int j1 = 0; j1 < n; j1++)
                    {
                        ss += "FRML _GJRD e" + j1 + " = 0." + r.Next(1, 999) + " + ";
                        for (int j2 = 0; j2 < n; j2++)
                        {
                            if (e[j1, j2] != 0) ss += e[j1, j2] * factor + "*e" + j2 + " + ";
                        }
                        if (x[j1, 0] != 0) ss += x[j1, 0] + "*x" + 0 + " + ";
                        if (x[j1, 1] != 0) ss += x[j1, 1] + "*x" + 1 + " + ";

                        if (r.Next(0, 100) < 10) ss += "0.001*e" + r.Next(0, n - 1) + "(-1) + ";

                        if (ss.EndsWith("+ ")) ss = ss.Substring(0, ss.Length - 2);
                        ss = ss + ";\n";
                    }

                    string vv = ss;
                    for (int j1 = 0; j1 < n; j1++)
                    {
                        vv = vv.Replace("FRML _GJRD e" + j1 + " = ", "abs(e" + j1 + " - (");
                    }
                    vv = vv.Replace(";", ")) + ");
                    if (vv.EndsWith("+ \n"))
                    {
                        vv = vv.Substring(0, vv.Length - 3);
                        vv += ";\n";
                    }
                    vv = "GENR sum = " + vv;
                    string vvv = "";
                    if (endoexo == 1) vvv = "EXO e0; ENDO x0;\n";
                    if (endoexo == 2) vvv = "EXO e0 e1; ENDO x0 x1;\n";
                    vv = "RESET; MODEL m" + ii + ";\n READ<tsd> m;\n " + vvv + "SIM 2002 2100;\n " + vv + "\n PRT<2002 2005> sum e0 e1 e2;\n";

                    //ok that this is not G.GekkoStreamWriter()
                    StreamWriter sw = new StreamWriter(Program.options.folder_working + "m" + ii + ".frm");
                    sw.Write(ss);
                    sw.Flush();
                    sw.Close();

                    //ok that this is not G.GekkoStreamWriter()
                    StreamWriter sw2 = new StreamWriter(Program.options.folder_working + "m" + ii + "." + Globals.defaultCommandFileExtension);
                    if (endoexo > 0) sw2 = new StreamWriter(Program.options.folder_working + "n" + ii + "." + Globals.defaultCommandFileExtension);
                    sw2.Write(vv);
                    sw2.Flush();
                    sw2.Close();

                    G.Writeln("Created random model " + ii);

                }
            }
        }

        private static double[,] PutTimeseriesIntoArrayPossiblyNegative(GekkoTime tStart0, GekkoTime tEnd, List<string> varsX)
        {
            int obs = GekkoTime.Observations(tStart0, tEnd);
            double[,] aX = new double[varsX.Count, obs];
            int id = -1;
            foreach (string var in varsX)
            {
                id++;
                int length = -12345;
                int index1 = -12345;
                int index2 = -12345;
                double[] x = null;
                string var2 = var;
                bool negative = false;
                if (var.StartsWith("-"))
                {
                    var2 = var2.Substring(1);
                    negative = true;
                }

                TimeSeries ts = O.GetTimeSeries(var2, 0).ts;

                if (ts == null)
                {
                    G.Writeln2("*** ERROR: Variable '" + var2 + "' does not exist");
                    throw new GekkoException();
                }
                else
                {
                    //Hmmm, Annual?? What about quarters/months??
                    //#280935728439 should handle banknames, and should search if in data mode.
                    //maybe look at COPY and fetch from there.
                    //destination (lhs) should also allow banknames.
                    x = ts.GetDataSequence(out index1, out index2, tStart0, tEnd);  //implicit ", false" ending this method, no setting of start/end period of timeseries
                    length = index2 - index1 + 1;
                    if (negative)
                    {
                        double[] xNew = new double[x.Length];
                        for (int i = 0; i < x.Length; i++)
                        {
                            //NaN and +/- Infinity pass ok through this
                            xNew[i] = -x[i];
                        }
                        x = xNew;  //points to this temp array: otherwise real timeseries data will be overridden
                    }
                }
                Buffer.BlockCopy(x, 8 * index1, aX, 8 * id * obs, 8 * length);  //TODO: what if out of bounds regarding x???
                //I guess after this loop is done, the whole of a[,] will be filled with data or NaN.
                //It should not be possible that there is a 0 left originating from "double[,] a = new double[vars, obs];"
            }
            return aX;
        }

        //dynamic methods

        public static void f1(GekkoTime tStart, GekkoTime tEnd)
        {
            //Seems cannot be done with delegates, because of the tg and fy fields that are used for speed. So a method
            //would have these as arguments, so the arguments would vary.
            //So it seems we have to keep the loop inside f1(), which is also ok.

            List<string> el = null;
            TimeSeries tg = WG("tg", ref el);
            TimeSeries fy = WG("fy", ref el);
            if (el != null && el.Count > 0)
            {
                //report, and remove dublets, in method + throw
            }
            foreach (GekkoTime t in new GekkoTimeIterator(tStart, tEnd))
            {
                //Corresponds to genr100000.cmd and ggenr100000.cmd
                double rhs = W(tg, t) * W(tg, t) / W(tg, t) + W(fy, t) * W(fy, t) / W(fy, t) - W(fy, t) * W(fy, t) / W(fy, t) + Math.Exp(W(fy, t) - W(fy, t));
                //double rhs = W(tg, t) * W(tg, t) / W(tg, t) + (W(fy, t) * W(fy, t) / W(fy, t) - W(fy, t) * W(fy, t) / W(fy, t) + Math.Log(W(fy, t) / W(fy, t)) + Math.Log(W(fy, t) / W(fy, t)) + Math.Log(W(fy, t) / W(fy, t))) + (W(fy, t) * W(fy, t) / W(fy, t) - W(fy, t) * W(fy, t) / W(fy, t) + Math.Log(W(fy, t) / W(fy, t)) + Math.Log(W(fy, t) / W(fy, t)) + Math.Log(W(fy, t) / W(fy, t))) + Math.Exp(W(fy, t) - W(fy, t));
                WW(tg, t, rhs);
            }
        }

        //======= fixed methods

        public static Databank w = null;

        public static TimeSeries WG(string s, ref List<string> errorList)
        {
            TimeSeries ts = w.GetVariable(s);
            if (ts == null)
            {
                if (errorList == null) errorList = new List<string>();
                errorList.Add("*** ERROR: " + s + " not found");
            }
            return ts;
        }

        public static double W(TimeSeries ts, GekkoTime t)
        {
            //return ts.GetData(t);
            return ts.GetData(t);
        }

        public static void WW(TimeSeries ts, GekkoTime t, double d)
        {
            //ts.SetData(Program.options.freq, t, d);
            ts.SetData(t, d);
        }

        private static void LUDecompose(ref double[,] lu, ref int[] indx)
        {
            if (Globals.stackedPrintTimings)
            {
                Density(lu);
            }

            //Running a 1000x1000 dense matrix with code below takes about 2800 ms
            //Compare this with the 1200 ms described here: http://mathnetnumerics.codeplex.com/discussions/360326
            //See also the 1800 ms here: http://www.meta-numerics.net/Pages/Performance.aspx
            //Random r = new Random();
            //int n2 = 1000;
            //lu = new double[n2, n2];
            //indx = new int[n2];
            //for (int ii = 0; ii < n2; ii++)
            //{
            //    for (int jj = 0; jj < n2; jj++)
            //    {
            //        lu[ii, jj] = r.NextDouble();
            //    }
            //}
            //DateTime t0 = DateTime.Now;


            int i, imax = 0, j, k, n = lu.GetLength(0);
            double big, temp1, temp2;
            double[] vv = new double[n];
            //preChecks
            if (lu.GetLength(0) != lu.GetLength(1) || lu.GetLength(0) != indx.Length)
                throw new Exception("matrix dimension problem only use square matrices");
            //for each row find the absolute value of the greatest cell and store in vv
            for (i = 0; i < n; i++)
            {
                big = 0.0;
                for (j = 0; j < n; j++)
                    if ((temp1 = Math.Abs(lu[i, j])) > big) big = temp1;
                if (big == 0.0)
                {
                    int endoNumber = (int)Program.model.m2.simulFeedback[i];
                    EquationHelper eh = Program.model.equations[endoNumber];
                    G.Writeln();
                    G.Writeln2("*** ERROR: Trying to invert a singular matrix. This is because the equations are");
                    G.Writeln("           somehow undetermined, for instance because of an equation 'X = X',", Color.Red);
                    G.Writeln("           or an equation 'Y = Z', where Z is exogenous, and the variable", Color.Red);
                    G.Writeln("           Y has been exogenized (by means of the EXO command).", Color.Red);
                    G.Writeln("           The problem arises in the following equation:", Color.Red);
                    G.Writeln(eh.equationText, Color.Blue);
                    G.Writeln("           Please correct the equation or the goals/means (ENDO/EXO variables).", Color.Red);
                    G.Writeln();
                    throw new GekkoException();
                }

                vv[i] = 1.0 / big;//calculate scaling and save
            }
            //k is for colums start with the left look for the columns under the diagonal for the biggest value want to move the largest over diagonal
            for (k = 0; k < n; k++)//find the largest pivot element
            {
                big = 0.0;
                for (i = k; i < n; i++)
                {
                    temp1 = vv[i] * Math.Abs(lu[i, k]);
                    if (temp1 > big)
                    {
                        big = temp1;
                        imax = i;
                    }
                }

                if (k != imax)//do we need a row change
                {
                    for (j = 0; j < n; j++)// counter for the colums
                    {
                        temp1 = lu[imax, j];// change the rows
                        lu[imax, j] = lu[k, j];
                        lu[k, j] = temp1;
                    }
                    vv[imax] = vv[k];
                    //G.Writeln2("Swapped row " + k + " and row " + imax);
                }
                indx[k] = imax;

                for (i = k + 1; i < n; i++)
                {
                    temp1 = lu[i, k] /= lu[k, k];//divide pilot element
                    if (temp1 != 0d)  //TT changed: changes time from 4 secs on 813x813 to 1.75 secs
                    {
                        for (j = k + 1; j < n; j++)
                        {
                            //lu[i, j] -= temp * lu[k, j];  //<---- original before TT changed, the change improves 1.75 secs to 1.57 secs.
                            temp2 = lu[k, j];
                            if (temp2 != 0d)
                            {
                                lu[i, j] -= temp1 * temp2;
                            }
                        }
                    }
                }
            }

            if (Globals.stackedPrintTimings)
            {
                //G.Writeln("Sparsity AFTER:");
                //Density(lu);
            }

        }

        private static void Density(double[,] lu)
        {
            double sum = 0d;
            double zero = 0d;
            foreach (double d in lu)
            {
                sum++;
                if (d == 0d) zero++;
            }
            double ratio = zero / sum;
            //G.Writeln2("Density = " + (1-ratio) * 100 + "%");
        }

        private static void Solve(ref double[] b, ref double[] x, int[] indx, double[,] lu)
        {
            if (b.Length != lu.GetLength(0) || x.Length != lu.GetLength(0))
                throw new Exception("vector dimension problem");

            int n = lu.GetLength(0);
            int i, ii = 0, ip, j;
            double sum = 0;
            for (i = 0; i < n; i++) x[i] = b[i];
            for (i = 0; i < n; i++)
            {
                ip = indx[i];
                sum = x[ip];
                x[ip] = x[i];
                if (ii != 0)
                    for (j = ii - 1; j < i; j++) sum -= lu[i, j] * x[j];
                else if (sum != 0.0)
                    ii = i + 1;
                x[i] = sum;
            }
            for (i = n - 1; i >= 0; i--)
            {
                sum = x[i];
                for (j = i + 1; j < n; j++) sum -= lu[i, j] * x[j];
                x[i] = sum / lu[i, i];
            }
        }

        private static StringBuilder ConvertPcimTable(string file)
        {
            StringBuilder x = new StringBuilder();
            int start = 4;
            int longest = 0;

            for (int u = 0; u < 2; u++)
            {
                x = new StringBuilder();

                string colformat = "";

                x.AppendLine("<?xml version=`1.0` encoding=`Windows-1252`?>");
                x.AppendLine("<gekkotable>");
                x.AppendLine("  <tableversion>1.0</tableversion>");
                x.AppendLine("  <header>");
                x.AppendLine("    <printinfo type=`full` />");
                x.AppendLine("  </header>");
                x.AppendLine("  <table>");
                x.AppendLine("    <cols>");
                x.AppendLine("      <colborder />");
                x.AppendLine("      <col txtalign=`left`></col>");
                x.AppendLine("      <colglue />");
                x.AppendLine("      <col txtalign=`right` />");
                x.AppendLine("      <colborder />");
                x.AppendLine("      <col type=`expand` txtalign=`center`></col>");
                x.AppendLine("      <colborder />");
                x.AppendLine("    </cols>");
                x.AppendLine("    <rows>");

                string tab = ",";
                //string file = Program.options.folder_working + "\\s56b.TAB";
                List<string> lines = G.ExtractLinesFromText(GetTextFromFileWithWait(file));
                int counter = 0;
                foreach (string line2 in lines)
                {
                    counter++;
                    string line = line2.Trim();
                    //char[] c = line.ToCharArray();
                    if (line.StartsWith("01"))
                    {
                        int ii = ToInt(Substring(line, 3, 5));
                        if (ii == int.MaxValue || ii < 1)
                        {
                            TableConvertError(u, file, counter, line, "Number of variable fields < 1...??");
                        }
                        else if (ii > 1)
                        {
                            TableConvertError(u, file, counter, line, "Converter only works with 1 variable field.");
                        }
                        ii = 1;
                    }
                    else if (line.StartsWith("02"))
                    {
                        int w = ToInt(Substring(line, 3, 4));
                        if (w == int.MaxValue || w < 1)
                        {
                            TableConvertError(u, file, counter, line, "Width problem....");
                        }
                        string code = Substring(line, 5, 5).ToLower();
                        if (code == "i")
                        {
                        }
                        else if (code == "f")
                        {
                        }
                        else
                        {
                            TableConvertError(u, file, counter, line, "Number format is not 'i' or 'f'...");
                        }
                        int decimals = int.MaxValue;
                        if (line.Length > 5) decimals = ToInt(Substring(line, 6, 6));
                        if (decimals == int.MaxValue)
                        {
                            if (code == "i")
                            {
                            }
                            else
                            {
                                TableConvertError(u, file, counter, line, "Number of decimals not found for 'f'-number");
                            }
                            colformat = "f" + w + ".0";
                        }
                        else
                        {
                            colformat = "f" + w + "." + decimals;
                        }
                        x.AppendLine("      <rowformat varformat=`" + colformat + "`/>");
                    }
                    else if (line.StartsWith("03"))
                    {
                        //ignore these borders
                    }
                    else if (line.StartsWith("06"))
                    {
                        string s = line.Substring(start - 1);

                        s = G.ReplaceFirstOccurrence(s, tab, "");

                        if (u == 0 && s != "" && !line.Substring(start - 2).StartsWith(" "))
                        {
                            start = 3;
                            //continue;  //for instance 06Investments
                        }
                        string[] ss = s.Split('');
                        string s1 = ss[0].TrimEnd();
                        string s2 = null;
                        if (ss.Length > 1) s2 = ss[1].Trim();
                        if (ss.Length > 2)
                        {
                            TableConvertError(u, file, counter, line, "Only expected 2 delimiter characters...");
                        }
                        if (s2 == null || s2 == "")
                        {
                            string span = "2";
                            if (u == 1 && s1.Length > longest) span = "3";
                            x.AppendLine("      <row>");
                            x.AppendLine("        <txt colspan=`" + span + "`>" + s1 + "</txt>");
                            x.AppendLine("      </row>");
                            //if (s1.Length > longest) longest = s1.Length;
                        }
                        else
                        {
                            string lbl = "";
                            string text = "";
                            string var = "";
                            if (s1 != "" && s2 != "")
                            {
                                if (s1.ToLower().EndsWith(s2.ToLower()))
                                {
                                    //easy, same name both places
                                    if (s1.Length == s2.Length)
                                    {
                                        text = "";
                                        lbl = "$";
                                        var = s2;
                                    }
                                    else
                                    {
                                        string s3 = s1.Substring(s1.Length - s2.Length - 1, 1);
                                        if (s3 == " " || s3 == "." || s3 == ",")
                                        {
                                            string temp = s1.Substring(0, s1.Length - s2.Length).TrimEnd();
                                            if (temp.Length == 0) text = " ";
                                            else text = temp;
                                            lbl = "$";
                                            var = s1.Substring(s1.Length - s2.Length).Trim();
                                        }
                                    }
                                }
                            }

                            if (text == "")
                            {
                                string lastWord = "";
                                for (int i = s1.Length - 1; i >= 1; i--)
                                {
                                    if (!(G.IsLetterOrDigitOrUnderscore(s1[i]) || s1[i] == '+' || s1[i] == '-' || s1[i] == '*' || s1[i] == '/' || s1[i] == '(' || s1[i] == ')'))
                                    {
                                        if (s1[i] == ' ' && s1[i - 1] == ' ')  //two blanks before word
                                        {
                                            if (i < s1.Length - 1)
                                            {
                                                lastWord = s1.Substring(i + 1);
                                            }
                                        }
                                        break;
                                    }
                                }

                                if (lastWord != "")
                                {

                                    //try looking at last word
                                    text = s1.Substring(0, s1.Length - lastWord.Length).TrimEnd();
                                    lbl = lastWord;
                                    var = s2.Trim();
                                }
                            }

                            if (text == "")
                            {
                                text = s1.TrimEnd();
                                lbl = "";
                                var = s2.Trim();
                            }

                            if (var.ToLower().StartsWith("series")) var = var.Substring(4);
                            var = var.Replace("$", "");
                            var = var.Replace(";", "");
                            var = var.Trim();

                            text = SpecialXmlChars(text);

                            x.AppendLine("      <row>");
                            x.AppendLine("        <txt>" + text + "</txt>");
                            x.AppendLine("        <txt>" + lbl + "</txt>");
                            if (text.Length + lbl.Length + 2 > longest) longest = text.Length + lbl.Length + 2;
                            if (var.ToLower() == "year")
                            {
                                x.AppendLine("        <date/>");
                            }
                            else
                            {
                                x.AppendLine("        <var>" + var + "</var>");
                            }
                            x.AppendLine("      </row>");
                        }
                    }
                    else if (line.StartsWith("07"))
                    {
                        //blank line
                        x.AppendLine("      <row/>");
                    }
                    else if (line.StartsWith("08"))
                    {
                        //sideskift
                    }
                    else if (line.StartsWith("11"))
                    {
                        string s = Substring(line, 3, 3);
                        if (s == null)
                        {
                            TableConvertError(u, file, counter, line, "Problem with delimiter character");
                        }
                        tab = s;
                    }
                    else if (line.StartsWith("12"))
                    {
                        if (line.Length > 2)
                        {
                            string s = line.Substring(2).Trim();
                            x.AppendLine("<!-- " + SpecialXmlChars(s) + " -->");
                        }
                    }
                    else if (line.StartsWith("13"))
                    {
                        //finish of this table
                    }
                    else if (line.StartsWith("18"))
                    {
                        //new screen
                    }
                    else if (line.StartsWith("04") || line.StartsWith("05") || line.StartsWith("41"))
                    {
                        string s = "";
                        if (line.Length == 2)
                        {
                        }
                        else
                        {
                            s = line.Substring(start - 1);
                            if (u == 0 && s != "" && !line.Substring(start - 2).StartsWith(" "))
                            {
                                start = 3;
                                //continue;  //for instance 41Investments
                            }
                        }
                        s = SpecialXmlChars(s);
                        string span = "2";
                        if (u == 1 && s.Length > longest) span = "3";
                        x.AppendLine("      <row>");
                        x.AppendLine("        <txt colspan=`" + span + "`>" + s + "</txt>");
                        x.AppendLine("      </row>");
                        //if (s.Length > longest) longest = s.Length;
                    }
                    else if (line.StartsWith("20") || line.StartsWith("21"))
                    {
                        TableConvertError(u, file, counter, line, "Code 20 and 21 (multiplier) are not converted");
                    }
                    else if (line.StartsWith("22"))
                    {
                        TableConvertError(u, file, counter, line, "Code 22 (scaling) is not converted -- please fix with 'varscale' in XML table");
                    }
                    else if (line.StartsWith("24"))
                    {
                        TableConvertError(u, file, counter, line, "Code 24 (% growth under variables) is not converted");
                    }
                    else if (line.StartsWith("27"))
                    {
                        if (line.Substring(2, 1).ToLower() == "t")
                        {
                            x.AppendLine("      <rowformat vardisplay=`p`/>");
                        }
                        if (line.Substring(2, 1).ToLower() == "f")
                        {
                            x.AppendLine("      <rowformat vardisplay=`n`/>");
                        }
                    }
                    else if (line.StartsWith("28"))
                    {
                        TableConvertError(u, file, counter, line, "Code 28 (differences) is not converted");
                    }
                    else if (line.StartsWith("30"))
                    {
                        TableConvertError(u, file, counter, line, "Code 28 (multiplier difference) is not converted");
                    }
                    else if (line.StartsWith("44") || line.StartsWith("45") || line.StartsWith("46") || line.StartsWith("47"))
                    {
                        //ignore table headers
                    }
                    else if (line.StartsWith("55"))
                    {
                        TableConvertError(u, file, counter, line, "Code 55 (alignment) is not converted");
                    }
                    else if (line.StartsWith("91"))
                    {
                        x.AppendLine("      <rowborder/>");
                    }
                    else if (line.StartsWith("92"))
                    {
                        x.AppendLine("      <rowborder/>");
                    }
                    else if (line.StartsWith("93"))
                    {
                        x.AppendLine("      <rowborder/>");
                    }
                    else if (line.StartsWith("94"))
                    {
                        x.AppendLine("      <rowborder/>");
                    }
                    else if (line.StartsWith("95"))
                    {
                        x.AppendLine("      <rowborder/>");
                    }
                    else if (line.StartsWith("96"))
                    {
                        x.AppendLine("      <rowborder/>");
                    }
                    else if (line.StartsWith("97"))
                    {
                        x.AppendLine("      <rowborder/>");
                    }
                    else if (line.StartsWith("98"))
                    {
                        x.AppendLine("      <rowborder/>");
                    }
                    else if (line.StartsWith("99"))
                    {
                        //finish tabledef
                    }
                    else if (line.StartsWith("menu"))
                    {
                        //ignore menu calls
                    }
                    else if (line == "")
                    {
                    }
                    else
                    {
                        string code = "";
                        if (line.Length >= 2) code = line.Substring(0, 2);
                        TableConvertError(u, file, counter, line, "Did not recognize this table code: " + code);
                    }
                }  //end of foreach

                x.AppendLine("    </rows>");
                x.AppendLine("  </table>");
                x.AppendLine("</gekkotable>");

                x.Replace("`", "\"");
                //break;
            }  // for u

            return x;
        }

        private static string SpecialXmlChars(string text)
        {

            text = text.Replace("&", "&amp;");
            text = text.Replace("<", "&lt;");
            text = text.Replace(">", "&gt;");
            text = text.Replace("<", "");
            text = text.Replace("\"", "&quot;");
            text = text.Replace("'", "&#39;");
            return text;
        }

        private static void TableConvertError(int u, string file, int counter, string line, string s)
        {
            if (u > 0)
            {
                Globals.convertTableErrorCounter++;
                G.Writeln();
                G.Writeln2("*** ERROR: In " + file + " line " + counter);
                G.Writeln("           Could not understand: " + line, Color.Red);
                G.Writeln("           " + s, Color.Red);
                G.Writeln("           " + "(Total error count: " + Globals.convertTableErrorCounter + ")");
                G.Writeln();
            }
        }

        private static void MenuConvertError(string file, int counter, string line, string s)
        {
            if (true)
            {
                Globals.convertMenuErrorCounter++;
                G.Writeln();
                G.Writeln2("*** ERROR: In " + file + " line " + counter);
                G.Writeln("           Could not understand: " + line, Color.Red);
                G.Writeln("           " + s, Color.Red);
                G.Writeln("           " + "(Total error count: " + Globals.convertMenuErrorCounter + ")");
                G.Writeln();
            }
        }

        private static string Substring(string line, int p1, int p2)
        {
            string x = null;
            try
            {
                x = line.Substring(p1 - 1, p2 - p1 + 1);
            }
            catch (Exception e) { };
            return x;
        }

        private static int ToInt(string input)
        {
            int output = int.MaxValue;
            if (input == null) return output;
            try
            {
                output = int.Parse(input);
            }
            catch (Exception e) { };
            return output;
        }

        public static void Mem(string tpe)
        {
            /*
            
            //y = 1 + sum(#i, 2 + b[#i] + sum(#j, 3 + a[#i, #j]))

            //når der mødes en #i i en sum(#i, ...) (*) registreres den
            //  den må ikke allerede findes som loop-variabel eller en anden sum()
            //  følgende #i'er kobles navnemæssigt til denne.
            //  måske ved at adde og remover til en dictionary, når den går ind og ud af sum()

            //test at $-conditions virker
            //test lags
            //test movsum()
            //test bank:
            //test x{i}a[#i]

            //(*) logik mht. sum-funktion: kan kun være array hvis 2 argumenter, og det første skal være #i eller (#i, #j, ...)
            //og det andet skal indeholde mindst én indexer

            //result 2001 509605.4
            //result 2002 518934.1

            List<string> ii = new List<string>(new string[] { "m", "b" });
            List<string> jj = new List<string>(new string[] { "nm", "nk" });

            TimeSeries ts2 = Program.databanks.GetFirst().GetVariable("fk");
            TimeSeries ts1 = Program.databanks.GetFirst().GetVariable("fim");

            for (int t = 2001; t <= 2002; t++)
            {
                GekkoTime gt = new GekkoTime(EFreq.Annual, t, 1);
                double d1 = 0;  //SUM FUNCTION1 +++++++++++++++++++++++++++
                foreach (string i in ii)  //SUM FUNCTION1 ARG 1 ++++++++++++++++++++++++++++
                {
                    double d2 = 0;  //SUM FUNCTION2
                    foreach (string j in jj)  //SUM FUNCTION ARG1
                    {
                        d2 += 3 + ((MetaTimeSeries)O.Indexer(gt, new MetaTimeSeries(ts2), false, new ScalarString(i), new ScalarString(j))).ts.GetData(gt); //SUM FUNCTION ARG2
                    }
                    d1 += 2 + ((MetaTimeSeries)O.Indexer(gt, new MetaTimeSeries(ts1), false, new ScalarString(i))).ts.GetData(gt);  //SUM FUNCTION1 ARG 2 +++++++++++++++++++
                }
                double d = 1 + d1;  //PARENT
                G.Writeln2("result " + t + " " + d);
            }
        
            */

            //call with null, string, name, date, val
            int counter = 0;
            //if (Program.scalars.Count > 0)
            {
                List<string> keys = new List<string>();
                foreach (string s in Program.scalars.Keys)
                {
                    keys.Add(s);
                }
                keys.Sort(StringComparer.OrdinalIgnoreCase);

                Table tab = new Table();
                int row = 1;

                tab.SetBorder(row, 1, row, 3, BorderType.Top);
                tab.Set(row, 1, "type      ");
                tab.Set(row, 2, "name    ");  //blanks to get some spacing
                tab.Set(row, 3, "value    ");
                tab.SetBorder(row, 1, row, 3, BorderType.Bottom);
                row++;
                foreach (string s in keys)
                {
                    IVariable a = Program.scalars[s];  //no need for tryget
                    string value = "";
                    if (a.Type() == EVariableType.Date)
                    {
                        if (tpe != null && tpe != "date") continue;
                        value = G.FromDateToString(O.GetDate(a));
                    }
                    else if (a.Type() == EVariableType.String)
                    {
                        value = "'" + a.GetString() + "'";
                    }
                    else if (a.Type() == EVariableType.Val)
                    {
                        if (tpe != null && tpe != "val") continue;
                        value = a.GetVal(Globals.tNull).ToString();
                        if (value == "NaN") value = "M";
                    }
                    else if (a.Type() == EVariableType.List)
                    {
                        continue;  //skip this
                    }
                    else if (a.Type() == EVariableType.Matrix)
                    {
                        continue;  //skip this
                    }
                    else
                    {
                        G.Writeln2("*** ERROR: unknown mem variable type: " + a.Type().ToString());
                        throw new GekkoException();
                    }

                    string type = a.Type().ToString().ToUpper();
                    if (type == "STRING" && ((ScalarString)a)._isName)
                    {
                        //name
                        type = "NAME";
                        if (tpe != null && tpe != "name") continue;
                    }
                    if (type == "STRING" && !((ScalarString)a)._isName)
                    {
                        //string
                        type = "STRING";
                        if (tpe != null && tpe != "string") continue;
                    }
                    tab.Set(row, 1, type);
                    tab.Set(row, 2, s);
                    tab.Set(row, 3, value);
                    row++;
                    counter++;
                }
                tab.SetBorder(row - 1, 1, row - 1, 3, BorderType.Bottom);
                if (counter == 0)
                {
                    if (tpe == null) G.Writeln2("No scalars found");
                    else G.Writeln2("No " + tpe.ToUpper() + " scalar(s) found");
                }
                else
                {
                    string tpe2 = "";
                    if (tpe != null) tpe2 = " " + tpe.ToUpper();
                    G.Writeln2(counter + tpe2 + " scalar(s) found");
                    foreach (string s in tab.Print()) G.Writeln(s);
                }
            }
        }

        public static void SplitCommandBeingExecuted(out string originalFileName, out int lineNumber, string s)
        {
            string[] split = s.Split('¤');
            originalFileName = split[0];
            string lineNumber2 = split[1];
            lineNumber = int.Parse(lineNumber2);  //1-based it seems
        }

        public static List<string> CreateListOfStringsFromString(string inputFile)
        {
            List<string> inputFileLines = new List<string>();
            StringReader inputFileStringReader = new StringReader(inputFile);
            while (true)
            {
                string aLine = inputFileStringReader.ReadLine();
                if (aLine != null)
                {
                    inputFileLines.Add(aLine);
                }
                else
                {
                    break;
                }
            }
            return inputFileLines;
        }

        public static void Decomp(string type, GekkoTime t1, GekkoTime t2, string prtOption, string var, List<Dictionary<string, string>> precedents, string variable, string expressionCs)
        {
            //This is the starting point of a decomposition call
            //Calls: Decomp(decompOptions);
            //       DecompThreadFunction
            //       w.RecalcCellsWithNewType();
            //       Program.DecompHelper2(this.decompOptions, transformationCodeAugmented, useLocalData);
            //
            //Actual calculation is in DecompHelper2()

            DecompOptions decompOptions = new DecompOptions();

            //type is "udvalg" or "decomp", but not used at the moment
            decompOptions.variable = variable;
            decompOptions.type = type;
            decompOptions.t1 = t1;
            decompOptions.t2 = t2;
            decompOptions.prtOption = prtOption;
            decompOptions.expression = expressionCs;
            if (variable != null)
            {
                if (Program.model == null)
                {
                    G.Writeln();
                    G.Writeln("*** ERROR: No model is defined, needed for decomposition");
                    throw new GekkoException();
                }
                //decompOptions.vars = new List<string> { var.Replace("SIMPLE_DECOMP_VARIABLE:", "").Trim() };
                Decomp(decompOptions);
            }
            else
            {
                //uses expressionCs
                foreach (string s in precedents[0].Keys)
                {
                    if (s.Contains(":"))
                    {
                        G.Writeln2("*** ERROR: You cannot decompose with a named databank (using ':')");
                        throw new GekkoException();
                    }
                    else if (s.Contains("@"))
                    {
                        G.Writeln2("*** ERROR: You cannot decompose with '@' (" + Globals.Ref + " bank indicator)");
                        throw new GekkoException();
                    }
                }

                //decompOptions.vars = new List<string> { var };
                //decompOptions.isExpression = true;
                decompOptions.precedents = precedents;
                Decomp(decompOptions);
            }
        }

        public static void Decomp(DecompOptions decompOptions)
        {
            Thread thread = new Thread(new ParameterizedThreadStart(DecompThreadFunction));
            thread.SetApartmentState(ApartmentState.STA);
            thread.CurrentCulture = new System.Globalization.CultureInfo("en-US");  //gets . instead of , in doubles
            thread.Start(decompOptions);
            if (true)
            {
                //Also see #9237532567
                //This stuff makes sure we wait for the window to open, before we move on with the code.
                for (int i = 0; i < 6000; i++)  //up to 60 s, then we move on anyway
                {
                    System.Threading.Thread.Sleep(10);  //0.01s
                    if (decompOptions.numberOfRecalcs > 0)
                    {
                        break;
                    }
                }
            }
        }

        // Thread for decomp window
        public static void DecompThreadFunction(Object o)
        {
            DecompOptions decompOptions = (DecompOptions)o;
            //decompOptions.isCalledFromDecompWindow = false;
            Window1 w = new Window1(decompOptions);
            Globals.windowsDecomp.Add(w);
            if (decompOptions.expression != null)
            {
                w.Title = "Decompose expression";
            }
            else
            {
                w.Title = "Decompose " + decompOptions.variable;
            }
            w.Tag = decompOptions;

            w.SetRadioButtons();
            w.RecalcCellsWithNewType();
            decompOptions.numberOfRecalcs++;  //signal for Decomp() method to move on

            if (w.isClosing)  //if something goes wrong, .isClosing will be true
            {
                //The line below removes the window from the global list of active windows.
                //Without this line, this half-dead window will mess up automatic closing of windows (Window -> Close -> Close all...)
               if (Globals.windowsDecomp.Count > 0) Globals.windowsDecomp.RemoveAt(Globals.windowsDecomp.Count - 1);                            }
            else
            {
                w.ShowDialog();
                w.Close();  //probably superfluous
                w = null;  //probably superfluous
            }
        }

        public static O.Prt PrtSnippet(string s, string s2)
        {
            CompilerResults cr;
            CreatePrtSnippetDll(out cr, s, s2);
            //O.Prt o = new O.Prt();
            //Object[] args = new Object[1];
            //args[0] = o;
            O.Prt o = null;
            try
            {
                Object ret = null;
                ret = cr.CompiledAssembly.GetType("Gekko.PrtSnippet").InvokeMember("Snippet", BindingFlags.InvokeMethod, null, null, null);
                o = (O.Prt)ret;
                return o;
            }
            catch (Exception e)
            {
                MessageBox.Show("ERROR: Some databanks or timeseries may be unavailable.\nPlease close the PLOT window and consult the error\nmessage in the Gekko output window.");
            }
            return o;
        }

        public static List<string> TestSim(List<string> list, int start, int end)
        {
            List<string> res = new List<string>();
            CompilerResults cr;
            CreateTestSimDll(out cr, list, start, end);
            Object[] args2 = new Object[1];
            args2[0] = res;
            cr.CompiledAssembly.GetType("Gekko.TranslatedCode").InvokeMember("TestSim", BindingFlags.InvokeMethod, null, null, args2);
            return res;
        }

        public static Table DecompHelper2(DecompOptions decompOptions, string transformationCodeAugmented, bool useLocalData)
        {
            GekkoTime tStart = decompOptions.t1;
            GekkoTime tEnd = decompOptions.t2;

            bool isRaw = false;
            if (transformationCodeAugmented.ToLower().StartsWith("x")) isRaw = true;

            string type = decompOptions.type;
            //GekkoParserTimePeriod tp = decompOptions.tp;
            //List<string> vars = decompOptions.vars;
            LocalBanks localBanks = decompOptions.localBanks;
            string modelHash = decompOptions.modelHash;

            Table table = new Table();  //!!BEWARE: this object is also used for flowcharts, so if the layout is changed, change it in flowcharts also

            decompOptions.isPercentageType = false;
            if (transformationCodeAugmented.StartsWith("s") || transformationCodeAugmented.EndsWith("p") || transformationCodeAugmented.EndsWith("dp") || transformationCodeAugmented.EndsWith("q") || transformationCodeAugmented.EndsWith("mp"))
            {
                decompOptions.isPercentageType = true;
                table.Set(1, 1, "% ");
            }
            
            string var2 = decompOptions.variable;

            if (true)
            {

                string leftSideVariable = G.GetUpperLowerCase(var2);

                if (Program.model == null)
                {
                    G.Writeln2("*** ERROR: DECOMP: There does not seem to be any model defined");
                    throw new GekkoException();
                }

                if (decompOptions.expression == null && !Program.model.fromVariableToEquationNumber.ContainsKey(leftSideVariable + Globals.lagIndicator + "0"))
                {
                    G.Writeln2("*** ERROR: DECOMP: variable '" + leftSideVariable + "' does not exist as left-hand side variable in model");
                    throw new GekkoException();
                }

                Dictionary<string, string> precedents = null;
                EquationHelper eh = null;
                if (decompOptions.expression != null)
                {
                    precedents = decompOptions.precedents[0];
                }
                else
                {
                    int eqNumber = (int)Program.model.fromVariableToEquationNumber[leftSideVariable + Globals.lagIndicator + "0"];
                    eh = Program.model.equations[eqNumber];
                    precedents = eh.precedentsWithLagIndicator;
                }

                CompilerResults cr;
                CreateDecompDll(leftSideVariable, decompOptions.expression != null, eh, out cr);
                                
                List<Dictionary<string, string>> precedents2 = new List<Dictionary<string, string>>();
                precedents2.Add(precedents);
                CheckVariableExistence(null, precedents2, false, false, false, false);  //checking in work bank, also ok for time decomp
                List<string> p2 = new List<string>();
                p2.AddRange(precedents.Keys);
                p2.Sort(StringComparer.InvariantCulture);

                //Beware: best to keep this constant for different years to deal with timeless variables
                double delta = Globals.jacobiDeltaProbe;  //can just as well be the same stepsize as used in newton algorithm

                Dictionary<string, List<DecompHelper>> decompHelpers = new Dictionary<string, List<DecompHelper>>();

                List<Databank> banks = new List<Databank>();

                Databank work = Program.databanks.GetFirst();
                Databank base2 = Program.databanks.GetRef();
                banks.Add(work);
                banks.Add(base2);
                List<string> allVariables = GetAllVariablesForDecompose(leftSideVariable, p2);

                int counter = -1;
                foreach (Databank bank in banks)
                {
                    counter++;
                    Databank databank = bank;

                    foreach (GekkoTime t in new GekkoTimeIterator(tStart.Add(-2), tEnd))  //-2 to deal with dp option
                    {
                        List<DecompHelper> decompContributions = new List<DecompHelper>();

                        double y0 = double.NaN;
                        y0 = RunDecompEquation(cr, t, databank);

                        double yDatabank = double.NaN;
                        if (decompOptions.expression != null)
                        {
                            yDatabank = y0;
                        }
                        else
                        {
                            yDatabank = databank.GetVariable(leftSideVariable).GetData(t);
                        }

                        foreach (string variableWithLag in p2)
                        {
                            string variable = null;
                            int lag = -12345;
                            G.ExtractVariableAndLag(variableWithLag, out variable, out lag);

                            double before = databank.GetVariable(variable).GetData(t.Add(lag));
                            double after = before + delta;
                            databank.GetVariable(variable).SetData(t.Add(lag), after);
                            double y1 = double.NaN;
                            try
                            {
                                y1 = RunDecompEquation(cr, t, databank);
                            }
                            finally
                            {
                                //to make 100% sure it is always reset
                                databank.GetVariable(variable).SetData(t.Add(lag), before);
                            }

                            DecompHelper dh = new DecompHelper();
                            dh.variableWithLag = variableWithLag;
                            dh.y0 = y0;
                            dh.y1 = y1;
                            dh.x0 = before;
                            dh.x1 = after;
                            dh.slope = (dh.y1 - dh.y0) / (dh.x1 - dh.x0);
                            dh.z = yDatabank;
                            decompContributions.Add(dh);
                        }

                        //double truth = y1 - y0;
                        //double alpha = truth / sum;

                        //factors.Add(t + ": explanation = " + G.pchFormat(alpha * 100, 10) + "%");
                        //G.Writeln(t + "  " + "sum " + sum + "   truth " + truth + "  alpha " + alpha);
                        string key = "FIRST";
                        if (counter == 1) key = "REF";

                        decompHelpers.Add(key + "," + t.ToString(), decompContributions);  //key for instance "Work,2010"
                    }
                }

                if (decompOptions.showErrors)
                {

                    if (isRaw)
                    {
                        table.Set(3, 1, Globals.decompText2a);
                        table.Set(4, 1, Globals.decompText1a);
                        table.Get(3, 1).backgroundColor = "LightYellow";
                        table.Get(4, 1).backgroundColor = "LightRed";
                    }
                    else
                    {
                        table.Set(3, 1, Globals.decompText2);
                        table.Set(4, 1, Globals.decompText1);
                        table.Get(3, 1).backgroundColor = "LightRed";
                        table.Get(4, 1).backgroundColor = "LightRed";
                    }
                }

                int o = 0;
                if (decompOptions.showErrors) o = 2;

                int j = -1;
                foreach (GekkoTime t in new GekkoTimeIterator(tStart, tEnd))
                {
                    j++;
                    if (j == 0)
                    {
                        List<DecompHelper> dhList2 = decompHelpers["FIRST," + t.ToString()];
                        int i = -1;
                        foreach (DecompHelper dh in dhList2)
                        {
                            i++;
                            table.Set(i + 3 + o, 1, G.FormatVariableAndLag(dh.variableWithLag)); //What should format be?
                        }
                        if (decompOptions.expression != null)
                        {
                            table.Set(2, 1, Globals.decompText0);
                        }
                        else
                        {
                            table.Set(2, 1, G.PrettifyTimeseriesHash(leftSideVariable, true, false));
                        }

                    }
                    table.SetDate(1, j + 2, t.ToString());

                    List<DecompHelper> data = null; decompHelpers.TryGetValue("FIRST," + t.ToString(), out data);
                    List<DecompHelper> data_lag = null; decompHelpers.TryGetValue("FIRST," + t.Add(-1).ToString(), out data_lag);
                    List<DecompHelper> data_lag2 = null; decompHelpers.TryGetValue("FIRST," + t.Add(-2).ToString(), out data_lag2);
                    List<DecompHelper> data_base = null; decompHelpers.TryGetValue("REF," + t.ToString(), out data_base);
                    List<DecompHelper> data_base_lag = null; decompHelpers.TryGetValue("REF," + t.Add(-1).ToString(), out data_base_lag);
                    List<DecompHelper> data_base_lag2 = null; decompHelpers.TryGetValue("REF," + t.Add(-2).ToString(), out data_base_lag2);

                    int offset_i = 2;
                    int offset_j = 2;

                    int decimals = 0;
                    if (decompOptions.isPercentageType) decimals = decompOptions.decimalsPch;
                    else decimals = decompOptions.decimalsLevel;

                    string format = "f16." + decimals.ToString();

                    if (isRaw)
                    {
                        double line0 = double.NaN;
                        double line1 = double.NaN;
                        double line2 = double.NaN;
                        switch (transformationCodeAugmented)
                        {
                            case "xmn":
                                break;
                            case "xm":
                                {
                                    line0 = data[0].z - data_base[0].z;
                                    table.SetNumber(0 + offset_i, j + offset_j, line0, format);  //What should format be?
                                    if (decompOptions.showErrors)
                                    {
                                        line2 = data[0].y0 - data_base[0].y0;
                                    }
                                    for (int i = 0; i < data.Count; i++)
                                    {
                                        table.SetNumber(i + offset_i + 1 + o, j + offset_j, data[i].x0 - data_base[i].x0, format);  //What should format be?
                                    }
                                }
                                break;
                            case "xq":
                                {
                                    line0 = (data[0].z / data_base[0].z - 1d) * 100d;
                                    table.SetNumber(0 + offset_i, j + offset_j, line0, format);  //What should format be?
                                    if (decompOptions.showErrors)
                                    {
                                        line2 = (data[0].y0 / data_base[0].y0 - 1d) * 100d;
                                    }
                                    for (int i = 0; i < data.Count; i++)
                                    {
                                        table.SetNumber(i + offset_i + 1 + o, j + offset_j, (data[i].x0 / data_base[i].x0 - 1d) * 100d, format);  //What should format be?
                                    }
                                }
                                break;
                            case "xsm":
                                G.Writeln2("*** ERROR: DECOMP option <" + transformationCodeAugmented + "> does not make (much) sense: did you mean <ms>?");
                                break;
                            // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                            case "":
                            case "xn":
                                {
                                    line0 = data[0].z;
                                    table.SetNumber(0 + offset_i, j + offset_j, line0, format);  //What should format be?
                                    if (decompOptions.showErrors)
                                    {
                                        line2 = data[0].y0;
                                    }
                                    for (int i = 0; i < data.Count; i++)
                                    {
                                        table.SetNumber(i + offset_i + 1 + o, j + offset_j, data[i].x0, format);  //What should format be?
                                    }
                                }
                                break;
                            case "xb":
                            case "xbn":
                                {
                                    line0 = data_base[0].z;
                                    table.SetNumber(0 + offset_i, j + offset_j, line0, format);  //What should format be?
                                    if (decompOptions.showErrors)
                                    {
                                        line2 = data_base[0].y0;
                                    }
                                    for (int i = 0; i < data.Count; i++)
                                    {
                                        table.SetNumber(i + offset_i + 1 + o, j + offset_j, data_base[i].x0, format);  //What should format be?
                                    }
                                }
                                break;
                            case "xd":
                                {
                                    line0 = data[0].z - data_lag[0].z;
                                    table.SetNumber(0 + offset_i, j + offset_j, line0, format);  //What should format be?
                                    if (decompOptions.showErrors)
                                    {
                                        line2 = data[0].y0 - data_lag[0].y0;
                                    }
                                    for (int i = 0; i < data.Count; i++)
                                    {
                                        table.SetNumber(i + offset_i + 1 + o, j + offset_j, data[i].x0 - data_lag[i].x0, format);  //What should format be?
                                    }
                                }
                                break;
                            case "xbd":
                                {
                                    line0 = data_base[0].z - data_base_lag[0].z;
                                    table.SetNumber(0 + offset_i, j + offset_j, line0, format);  //What should format be?
                                    if (decompOptions.showErrors)
                                    {
                                        line2 = data_base[0].y0 - data_base_lag[0].y0;
                                    }
                                    for (int i = 0; i < data.Count; i++)
                                    {
                                        table.SetNumber(i + offset_i + 1 + o, j + offset_j, data_base[i].x0 - data_base_lag[i].x0, format);  //What should format be?
                                    }
                                }
                                break;
                            case "xp":
                                {
                                    line0 = (data[0].z / data_lag[0].z - 1d) * 100d;
                                    table.SetNumber(0 + offset_i, j + offset_j, line0, format);  //What should format be?
                                    if (decompOptions.showErrors)
                                    {
                                        line2 = (data[0].y0 / data_lag[0].y0 - 1d) * 100d;
                                    }
                                    for (int i = 0; i < data.Count; i++)
                                    {
                                        table.SetNumber(i + offset_i + 1 + o, j + offset_j, (data[i].x0 / data_lag[i].x0 - 1d) * 100d, format);  //What should format be?
                                    }
                                }
                                break;
                            case "xbp":
                                {
                                    line0 = (data_base[0].z / data_base_lag[0].z - 1d) * 100d;
                                    table.SetNumber(0 + offset_i, j + offset_j, line0, format);  //What should format be?
                                    if (decompOptions.showErrors)
                                    {
                                        line2 = (data_base[0].y0 / data_base_lag[0].y0 - 1d) * 100d;
                                    }
                                    for (int i = 0; i < data.Count; i++)
                                    {
                                        table.SetNumber(i + offset_i + 1 + o, j + offset_j, (data_base[i].x0 / data_base_lag[i].x0 - 1d) * 100d, format);  //What should format be?
                                    }
                                }
                                break;
                            case "xdp":
                                {
                                    line0 = (data[0].z / data_lag[0].z - 1d) * 100d - (data_lag[0].z / data_lag2[0].z - 1d) * 100d;
                                    table.SetNumber(0 + offset_i, j + offset_j, line0, format);  //What should format be?
                                    if (decompOptions.showErrors)
                                    {
                                        line2 = (data[0].y0 / data_lag[0].y0 - 1d) * 100d - (data_lag[0].y0 / data_lag2[0].y0 - 1d) * 100d;
                                    }
                                    for (int i = 0; i < data.Count; i++)
                                    {
                                        table.SetNumber(i + offset_i + 1 + o, j + offset_j, (data[i].x0 / data_lag[i].x0 - 1d) * 100d - (data_lag[i].x0 / data_lag2[i].x0 - 1d) * 100d, format);  //What should format be?
                                    }
                                }
                                break;
                            case "xbdp":
                                {
                                    line0 = (data_base[0].z / data_base_lag[0].z - 1d) * 100d - (data_base_lag[0].z / data_base_lag2[0].z - 1d) * 100d;
                                    table.SetNumber(0 + offset_i, j + offset_j, line0, format);  //What should format be?
                                    if (decompOptions.showErrors)
                                    {
                                        line2 = (data_base[0].y0 / data_base_lag[0].y0 - 1d) * 100d - (data_base_lag[0].y0 / data_base_lag2[0].y0 - 1d) * 100d;
                                    }
                                    for (int i = 0; i < data.Count; i++)
                                    {
                                        table.SetNumber(i + offset_i + 1 + o, j + offset_j, (data_base[i].x0 / data_base_lag[i].x0 - 1d) * 100d - (data_base_lag[i].x0 / data_base_lag2[i].x0 - 1d) * 100d, format);  //What should format be?
                                    }
                                }
                                break;
                            case "xmp":
                                {
                                    line0 = (data[0].z / data_lag[0].z - 1d) * 100d - (data_base[0].z / data_base_lag[0].z - 1d) * 100d;
                                    table.SetNumber(0 + offset_i, j + offset_j, line0, format);  //What should format be?
                                    if (decompOptions.showErrors)
                                    {
                                        line2 = (data[0].y0 / data_lag[0].y0 - 1d) * 100d - (data_base[0].y0 / data_base_lag[0].y0 - 1d) * 100d;
                                    }
                                    for (int i = 0; i < data.Count; i++)
                                    {
                                        table.SetNumber(i + offset_i + 1 + o, j + offset_j, (data[i].x0 / data_lag[i].x0 - 1d) * 100d - (data_base[i].x0 / data_base_lag[i].x0 - 1d) * 100d, format);  //What should format be?
                                    }
                                }
                                break;
                            case "xsd":
                                G.Writeln2("*** ERROR: DECOMP option <" + transformationCodeAugmented + "> does not make (much) sense: did you mean <s>?");
                                break;


                                //======================================================================================

                        }  //end of switch

                        if (decompOptions.showErrors)
                        {
                            line1 = line0 - line2;
                            table.SetNumber(2 + offset_i, j + offset_j, line1, format);
                            table.SetNumber(1 + offset_i, j + offset_j, line2, format);
                            table.Get(1 + offset_i, j + offset_j).backgroundColor = "LightYellow";
                            table.Get(2 + offset_i, j + offset_j).backgroundColor = "LightRed";
                        }

                    }  //if raw type (starts with x)
                    else
                    {
                        string code1 = "";
                        string code2 = transformationCodeAugmented;
                        if (transformationCodeAugmented.ToLower().StartsWith("s"))
                        {
                            code1 = "s";
                            code2 = transformationCodeAugmented.Substring(1);
                        }

                        double[] tableTemp = new double[data.Count + 1 + o];
                        double sum = double.NaN;
                        double truth = double.NaN;
                        double dataError = double.NaN;
                        double nonlinError = double.NaN;

                        if (true)
                        {
                            List<DecompHelper> data_CUR = null;
                            List<DecompHelper> data_ALT = null;
                            List<DecompHelper> dataLag_CUR = null;
                            List<DecompHelper> dataLag_ALT = null;
                            if (G.equal(code2, "d") || G.equal(code2, "p"))
                            {
                                data_CUR = data;
                                data_ALT = data_lag;
                            }
                            else if (G.equal(code2, "bd") || G.equal(code2, "bp"))
                            {
                                data_CUR = data_base;
                                data_ALT = data_base_lag;
                            }
                            else if (G.equal(code2, "m") || G.equal(code2, "q"))
                            {
                                data_CUR = data;
                                data_ALT = data_base;
                            }
                            else if (G.equal(code2, "dp"))
                            {
                                data_CUR = data;
                                data_ALT = data_lag;
                                dataLag_CUR = data_lag;
                                dataLag_ALT = data_lag2;
                            }
                            else if (G.equal(code2, "bdp"))
                            {
                                data_CUR = data_base;
                                data_ALT = data_base_lag;
                                dataLag_CUR = data_base_lag;
                                dataLag_ALT = data_base_lag2;
                            }
                            else if (G.equal(code2, "mp"))
                            {
                                data_CUR = data;
                                data_ALT = data_lag;
                                dataLag_CUR = data_base;
                                dataLag_ALT = data_base_lag;
                            }
                            else
                            {
                                G.Writeln2("*** ERROR: Internal error regarding decomposition");
                                throw new GekkoException();
                            }
                            bool isRelative = false; //will be divided with lagged or baseline level
                            if (G.equal(code2, "p") || G.equal(code2, "bp") || G.equal(code2, "dp") || G.equal(code2, "bdp") || G.equal(code2, "q") || G.equal(code2, "mp"))
                            {
                                isRelative = true;
                            }
                            if (G.equal(code2, "dp") || G.equal(code2, "bdp") || G.equal(code2, "mp"))
                            {
                                double sumNolag = double.NaN;
                                double sumLag = double.NaN;
                                double truthNolag = double.NaN;
                                double truthLag = double.NaN;
                                double dataErrorNolag = double.NaN;
                                double dataErrorLag = double.NaN;
                                double nonlinErrorNolag = double.NaN;
                                double nonlinErrorLag = double.NaN;
                                double[] tableTempNolag = new double[data.Count + 1 + o];
                                double[] tableTempLag = new double[data.Count + 1 + o];
                                DecompHelper3(ref sumNolag, ref truthNolag, ref dataErrorNolag, ref nonlinErrorNolag, o, tableTempNolag, data_CUR, data_ALT, isRelative);
                                DecompHelper3(ref sumLag, ref truthLag, ref dataErrorLag, ref nonlinErrorLag, o, tableTempLag, dataLag_CUR, dataLag_ALT, isRelative);
                                sum = sumNolag - sumLag;
                                truth = truthNolag - truthLag;
                                dataError = dataErrorNolag - dataErrorLag;
                                nonlinError = nonlinErrorNolag - nonlinErrorLag;
                                for (int i = 0; i < tableTemp.Length; i++)
                                {
                                    tableTemp[i] = tableTempNolag[i] - tableTempLag[i];
                                }
                            }
                            else
                            {
                                DecompHelper3(ref sum, ref truth, ref dataError, ref nonlinError, o, tableTemp, data_CUR, data_ALT, isRelative);
                            }
                        }

                        tableTemp[0] = truth;

                        if (decompOptions.showErrors)
                        {
                            tableTemp[1] = nonlinError;
                            tableTemp[2] = dataError;
                        }
                        else
                        {
                            for (int i = 1; i < data.Count + 1; i++)
                            {
                                tableTemp[i] *= truth / sum;
                            }
                        }

                        if (G.equal(code1, "s"))
                        {
                            double tableTemp0 = tableTemp[0];
                            for (int i = 0; i < data.Count + 1 + o; i++)
                            {
                                tableTemp[i] = tableTemp[i] / tableTemp0 * 100d;
                            }
                        }

                        for (int i = 0; i < data.Count + 1 + o; i++)
                        {
                            table.SetNumber(i + offset_i, j + offset_j, tableTemp[i], format);  //What should format be?
                        }

                        if (decompOptions.showErrors)
                        {
                            table.Get(1 + offset_i, j + offset_j).backgroundColor = "LightRed";
                            table.Get(2 + offset_i, j + offset_j).backgroundColor = "LightRed";
                        }
                    }
                }
            }
            return table;
        }

        private static void DecompHelper3(ref double sum, ref double truth, ref double dataError, ref double nonlinError, int o, double[] tableTemp, List<DecompHelper> data, List<DecompHelper> data_ALT, bool isRelative)
        {
            sum = 0d;
            for (int i = 0; i < data.Count; i++)
            {
                double val = data_ALT[i].slope * (data[i].x0 - data_ALT[i].x0);
                sum += val;
                tableTemp[i + 1 + o] = val;
            }
            double y = data[0].y0;  //y0 is the same in all of the items, so item 0 is chosen arbitrarily
            double z = data[0].z;
            double y_ALT = data_ALT[0].y0;
            double z_ALT = data_ALT[0].z;
            truth = z - z_ALT;
            dataError = (z - z_ALT) - (y - y_ALT);
            nonlinError = (y - y_ALT) - sum;
            if (isRelative)
            {
                double factor = 100d / data_ALT[0].z;
                for (int i = 0; i < data.Count; i++)
                {
                    tableTemp[i + 1 + o] *= factor;
                }
                truth *= factor;
                dataError *= factor;
                nonlinError *= factor;
                sum *= factor;
            }
        }

        private static List<string> GetAllVariablesForDecompose(string leftSideVariable, List<string> p2)
        {
            List<string> allVariables = new List<string>();

            Dictionary<string, string> rightSideVariables = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
            foreach (string variableWithLag in p2)
            {
                if (variableWithLag.Contains(Globals.lagIndicator + Globals.lagIndicator))
                {
                    string[] split = variableWithLag.Split(new string[] { Globals.lagIndicator + Globals.lagIndicator }, StringSplitOptions.None);
                    if (split.Length != 2)
                    {
                        G.Writeln2("*** ERROR: internal error related to fixed periods");
                        throw new GekkoException();
                    }
                    //rightSideVariables.Add(split[0], "");
                    G.Writeln2("*** ERROR: fixed periods (" + split[0] + Globals.leftParenthesisIndicator + split[1] + Globals.rightParenthesisIndicator + ") cannot be used when decomposing");
                    throw new GekkoException();
                }
                else
                {
                    string variable = null;
                    int lag = -12345;
                    G.ExtractVariableAndLag(variableWithLag, out variable, out lag);
                    if (!rightSideVariables.ContainsKey(variable))
                    {
                        rightSideVariables.Add(variable, "");
                    }
                }
            }
            allVariables.AddRange(rightSideVariables.Keys);
            if (!rightSideVariables.ContainsKey(leftSideVariable))
            {
                allVariables.Add(leftSideVariable);
            }
            return allVariables;
        }

        private static void CreateDecompDll(string varName, bool isExpression, EquationHelper eh, out CompilerResults cr)
        {
            string code = "";
            if (isExpression)
            {
                code = varName;
            }
            else
            {
                code = eh.csCodeRhsLongVersion;
            }

            StringBuilder s2 = new StringBuilder();
            s2.AppendLine("using System;");
            s2.AppendLine("using System.Collections.Generic;");
            s2.AppendLine("using System.Text;");
            s2.AppendLine("namespace Gekko");
            s2.AppendLine("{");
            s2.AppendLine("    public class TranslatedCode");
            s2.AppendLine("    {");
            s2.AppendLine("public static void DecompEquation(double[] result, GekkoTime t, Databank databank)");
            s2.AppendLine("{");
            s2.Append("double data = ");
            s2.AppendLine(code + ";");
            s2.AppendLine("result[0] = data;");
            s2.AppendLine("return;");
            s2.AppendLine("}");  //method DecompEquation()
            s2.AppendLine("}");  //class TranslatedCode
            s2.AppendLine("}");  //namespace Gekko
            s2.Replace("`", Globals.QT);
            CompilerParameters compilerParams = new CompilerParameters();
            compilerParams = new CompilerParameters();
            compilerParams.CompilerOptions = Globals.compilerOptions;
            compilerParams.GenerateInMemory = true;
            compilerParams.IncludeDebugInformation = false;
            compilerParams.ReferencedAssemblies.Add("system.dll");
            compilerParams.ReferencedAssemblies.Add(Application.ExecutablePath);
            compilerParams.GenerateExecutable = false;
            cr = Globals.iCodeCompiler.CompileAssemblyFromSource(compilerParams, s2.ToString());
            if (cr.Errors.HasErrors)
            {
                throw new GekkoException();
            }
        }


        private static void CreatePrtSnippetDll(out CompilerResults cr, string s, string s3)
        {
            StringBuilder s2 = new StringBuilder();
            s2.AppendLine("using System;");
            s2.AppendLine("using System.Collections.Generic;");
            s2.AppendLine("using System.Text;");
            s2.AppendLine("namespace Gekko");
            s2.AppendLine("{");
            s2.AppendLine("    public class PrtSnippet");
            s2.AppendLine("    {");
            s2.AppendLine(s3);
            s2.AppendLine("public static O.Prt Snippet()");
            s2.AppendLine("{");
            s2.AppendLine(Globals.gekkoTimeIniCs);
            s2.AppendLine(s);
            s2.AppendLine("}");  //method
            s2.AppendLine("}");  //class
            s2.AppendLine("}");  //namespace
            s2.Replace("`", Globals.QT);
            CompilerParameters compilerParams = new CompilerParameters();
            compilerParams = new CompilerParameters();
            compilerParams.CompilerOptions = Globals.compilerOptions;
            compilerParams.GenerateInMemory = false;
            compilerParams.IncludeDebugInformation = false;
            compilerParams.ReferencedAssemblies.Add("system.dll");
            compilerParams.ReferencedAssemblies.Add(Application.ExecutablePath);
            compilerParams.GenerateExecutable = false;
            cr = Globals.iCodeCompiler.CompileAssemblyFromSource(compilerParams, s2.ToString());
            if (cr.Errors.HasErrors)
            {
                throw new GekkoException();
            }
        }

        public static List<int> GetLeftsideBNumbers()
        {
            //Gets equation numbers in simultaneous gauss-seidel block
            //Note that this method takes a little time: do not put inside loop!
            List<int> allSimul = new List<int>();
            allSimul.AddRange(Program.model.m2.simulRecursive);
            allSimul.AddRange(Program.model.m2.simulFeedback);
            allSimul.Sort();
            return allSimul;
        }

        private static void CreateTestSimDll(out CompilerResults cr, List<string> list, int start, int end)
        {
            //This is a method only used for debugging purposes
            StringBuilder s2 = new StringBuilder();
            s2.AppendLine("using System;");
            s2.AppendLine("using System.Collections.Generic;");
            s2.AppendLine("using System.Text;");
            s2.AppendLine("namespace Gekko");
            s2.AppendLine("{");
            s2.AppendLine("    public class TranslatedCode");
            s2.AppendLine("    {");
            s2.AppendLine("public static void TestSim(List<string>res)");
            s2.AppendLine("{");
            s2.AppendLine("GekkoTime tStart, tEnd; tStart = Globals.globalPeriodStart; tEnd = Globals.globalPeriodEnd;");
            s2.AppendLine("foreach (GekkoTime t in new GekkoTimeIterator( tStart, tEnd)) {");
            s2.AppendLine("double hs;");
            s2.AppendLine("double vs;");
            s2.AppendLine("double difMax = 0d;");
            s2.AppendLine("double pchMax = 0d;");
            s2.AppendLine("double dif;");
            s2.AppendLine("double pch;");
            s2.AppendLine("string difMaxName = ``;");
            s2.AppendLine("string pchMaxName = ``;");
            s2.AppendLine("double difMaxVs = 0d;");
            s2.AppendLine("double pchMaxVs = 0d;");
            s2.AppendLine("double difMaxHs = 0d;");
            s2.AppendLine("double pchMaxHs = 0d;");
            s2.AppendLine("Databank databank = Program.databanks.GetDatabank(`Work`);");

            int count = -1;

            foreach (string s in list)
            {
                count++;
                if (count < start) continue;
                if (count > end) break;
                int eqNumber = (int)Program.model.fromVariableToEquationNumber[s + Globals.lagIndicator + "0"];
                EquationHelper eh = Program.model.equations[eqNumber];
                string code = eh.csCodeRhsLongVersion;
                s2.Append("hs = ");
                s2.AppendLine(code + ";");
                s2.AppendLine("vs = databank.GetVariable(`" + s + "`).GetData(t);");
                s2.AppendLine("dif = Math.Abs(hs - vs);");
                s2.AppendLine("pch = Math.Abs((hs / vs - 1) * 100);");
                s2.AppendLine("if (dif > difMax) {difMaxVs=vs; difMaxHs=hs; difMax = dif; difMaxName = `" + s + "`; }");
                s2.AppendLine("if (pch > pchMax) {pchMaxVs=vs; pchMaxHs=hs; pchMax = pch; pchMaxName = `" + s + "`; }");
                //s2.AppendLine("G.Writeln(`XXXXXX: ` + t.ToString() + `: ` + dif + ` ` + pch);");
                s2.AppendLine();
            }
            s2.AppendLine("G.Writeln(`Abs: ` + t.ToString() + `: ` + difMaxName + ` = ` + difMax);");

            s2.AppendLine("res.Add(`abs¤` + t.ToString() + `¤` + difMaxName + `¤` + difMax + `¤` + difMaxVs + `¤` + difMaxHs);");

            s2.AppendLine("G.Writeln(`Rel: ` + t.ToString() + `: ` + pchMaxName + ` = ` + pchMax);");

            s2.AppendLine("res.Add(`rel¤` + t.ToString() + `¤` + pchMaxName + `¤` + pchMax + `¤` + pchMaxVs + `¤` + pchMaxHs);");

            s2.AppendLine("}");  //end time loop
            s2.AppendLine("}");  //method DecompEquation()
            s2.AppendLine("}");  //class TranslatedCode
            s2.AppendLine("}");  //namespace Gekko
            s2.Replace("`", Globals.QT);
            CompilerParameters compilerParams = new CompilerParameters();
            compilerParams = new CompilerParameters();
            compilerParams.CompilerOptions = Globals.compilerOptions;
            compilerParams.GenerateInMemory = false;
            compilerParams.IncludeDebugInformation = false;
            compilerParams.ReferencedAssemblies.Add("system.dll");
            compilerParams.ReferencedAssemblies.Add(Application.ExecutablePath);
            compilerParams.GenerateExecutable = false;
            cr = Globals.iCodeCompiler.CompileAssemblyFromSource(compilerParams, s2.ToString());
            if (cr.Errors.HasErrors)
            {
                throw new GekkoException();
            }
        }

        private static double RunDecompEquation(CompilerResults cr, GekkoTime t, Databank db)
        {
            Object[] args2 = new Object[3];
            args2[0] = new double[1];
            args2[1] = t;
            args2[2] = db;
            cr.CompiledAssembly.GetType("Gekko.TranslatedCode").InvokeMember("DecompEquation", BindingFlags.InvokeMethod, null, null, args2);
            double val0 = ((double[])(args2[0]))[0];
            return val0;
        }

        public static List<string> HandleModelFiles(List<string> input, ModelCommentsHelper modelCommentsHelper)
        {
            List<string> output = new List<string>();
            List<string> outputVarlist = new List<string>();
            bool varlistFlag = false;
            foreach (string line in input)
            {
                string line2 = line.Trim();
                if (line2.ToLower().StartsWith("varlist$") || line2.ToLower().StartsWith("varlist;"))
                {
                    varlistFlag = true;
                }
                if (varlistFlag) outputVarlist.Add(line);
                else output.Add(line);
            }
            StringBuilder sVarlist = new StringBuilder();
            foreach (string line in outputVarlist)
            {
                sVarlist.AppendLine(line);
            }
            modelCommentsHelper.varlist = sVarlist.ToString();
            return output;
        }

        public static string HandleModelFiles(string input, ModelCommentsHelper modelCommentsHelper)
        {
            //As a side-effect, Program.model.varlist is filled with stuff after VARLIST$
            List<string> lines = G.ExtractLinesFromText(input);
            List<string> linesNew = HandleModelFiles(lines, modelCommentsHelper);  //after this, there is no varlist stuff in linesNew
            GetModelHashAndXml(linesNew, modelCommentsHelper); //does some rough removing of comments, empty lines etc.
            Globals.modelFileLines = linesNew;
            StringBuilder sb = new StringBuilder();
            foreach (string line in linesNew)
            {
                sb.AppendLine(line);
            }
            string s2 = sb.ToString();
            return s2;
        }

        private static void GetModelHashAndXml(List<string> linesNew, ModelCommentsHelper modelCommentsHelper)
        {
            StringBuilder sb = new StringBuilder();
            StringBuilder comment = new StringBuilder();
            bool problem = false;
            for (int i = 0; i < 2; i++)
            {
                sb = new StringBuilder();
                comment = new StringBuilder();
                int nestedCommentCounter = 0;
                foreach (string s in linesNew)
                {
                    string s2 = s.Trim();
                    if (i == 0)
                    {
                        //TODO: handle ### model blocks together with comment blocks
                        if (s2.StartsWith("/*")) nestedCommentCounter++;
                        if (s2.EndsWith("*/")) nestedCommentCounter--;
                        if (nestedCommentCounter > 1 || nestedCommentCounter < 0)  //should be 0 or 1, nothing else, so nested comments will -> problem
                        {
                            problem = true;
                            break;
                        }
                        if (nestedCommentCounter == 1)
                        {
                            ExtractComment(comment, s2, modelCommentsHelper);
                            continue;  //inside comment
                        }
                    }
                    if (s2.StartsWith("()") || s2.StartsWith("//"))
                    {
                        ExtractComment(comment, s2, modelCommentsHelper);
                        if (!s2.Contains("###"))
                        {
                            continue;  //we ignore a normal comment. But if the comment contains '###'
                                       //it will be hashed. So model block lines count in hash code!
                        }
                    }
                    if (s2 == "") continue;
                    sb.AppendLine(s2);  //used for hash code
                }
                if (problem == false) break;
            }

            if (modelCommentsHelper.infoText == null && modelCommentsHelper.infoCounter > 0)
            {
                G.Writeln("+++ NOTE: The correct syntax for info is 'Info: ' (followed by text)");
                G.Writeln("          Note capital 'I' and the blank after ':'");
            }
            if (modelCommentsHelper.dateText == null && modelCommentsHelper.dateCounter > 0)
            {
                G.Writeln("+++ NOTE: The correct syntax for date is 'Date: ' (followed by date)");
                G.Writeln("          Note capital 'D' and the blank after ':'");
            }
            if (modelCommentsHelper.signatureFoundInFileHeader == null && modelCommentsHelper.signatureCounter > 0)
            {
                G.Writeln("+++ NOTE: The correct syntax for signature is 'Signature: ' (followed by the signature)");
                G.Writeln("          Note capital 'S' and the blank after ':'");
            }

            //The statement below makes sure that -- if a cached model is to be used -- the MODEL statement that created the cached model and the current MODEL statement are done under the same frequency
            sb.AppendLine("SubPeriods: " + O.CurrentSubperiods().ToString());  //for instance: "Frequency: 4". Cf. Program.model.subPeriods

            string trueHash = Program.GetMD5Hash(sb.ToString());  //Pretty unlikely that two different .frm files could produce the same hash.
            trueHash = trueHash.Trim();  //probably not necessary
            G.WritelnGray("HASH: " + trueHash);

            Program.model.modelInfo.info = "[empty]";
            if (modelCommentsHelper.infoText != null) Program.model.modelInfo.info = modelCommentsHelper.infoText;

            Program.model.modelInfo.date = "[empty]";
            if (modelCommentsHelper.dateText != null) Program.model.modelInfo.date = modelCommentsHelper.dateText;

            if (modelCommentsHelper.signatureFoundInFileHeader == null)
            {
                modelCommentsHelper.signatureStatus = ESignatureStatus.SignatureNotFoundInModelFile;
            }
            else
            {
                if (modelCommentsHelper.signatureFoundInFileHeader == trueHash)
                {
                    modelCommentsHelper.signatureStatus = ESignatureStatus.Ok;
                }
                else
                {
                    modelCommentsHelper.signatureStatus = ESignatureStatus.SignaturesDoNotMatch;
                }
            }

            modelCommentsHelper.modelHashTrue = trueHash;

            return;
        }

        private static string IdentifyModelBlock(string s2)
        {
            string s3 = s2;
            if (s2.Contains("###"))
            {
                string[] xx = s2.Split(new string[] { "###" }, StringSplitOptions.None);
                if (xx.Length > 1)
                {
                    s3 = "MODELBLOCK " + xx[1].Trim();
                }
            }
            return s3;
        }

        private static void ExtractComment(StringBuilder sb, string s2, ModelCommentsHelper modelCommentsHelper)
        {
            string s3 = s2.Trim();
            if (s3.StartsWith("/*")) s3 = s3.Substring(2);
            else if (s3.StartsWith("*/")) s3 = s3.Substring(2);
            else if (s3.StartsWith("//")) s3 = s3.Substring(2);
            else if (s3.StartsWith("()")) s3 = s3.Substring(2);
            s3 = s3.Trim();
            //-------------
            if (s3.StartsWith("Info: "))
            {
                if (modelCommentsHelper.infoText != null)
                {
                    G.Writeln2("*** ERROR: Model file contains several comment lines starting with 'Info: '");
                    throw new GekkoException();
                }
                modelCommentsHelper.infoText = s3.Substring(6).Trim();
            }
            if (s3.ToLower().StartsWith("info:") || s3.ToLower().StartsWith("info :")) modelCommentsHelper.infoCounter++;
            //-------------
            if (s3.StartsWith("Date: "))
            {
                if (modelCommentsHelper.dateText != null)
                {
                    G.Writeln2("*** ERROR: Model file contains several comment lines starting with 'Date: '");
                    throw new GekkoException();
                }
                modelCommentsHelper.dateText = s3.Substring(6).Trim();
            }
            if (s3.ToLower().StartsWith("date:") || s3.ToLower().StartsWith("date :")) modelCommentsHelper.dateCounter++;
            //-------------
            if (s3.StartsWith("Signature: "))
            {
                if (modelCommentsHelper.signatureFoundInFileHeader != null)
                {
                    G.Writeln2("*** ERROR: Model file contains several comment lines starting with 'Signature: '");
                    throw new GekkoException();
                }
                modelCommentsHelper.signatureFoundInFileHeader = s3.Substring(11).Trim();
            }
            if (s3.ToLower().StartsWith("signature:") || s3.ToLower().StartsWith("signature :")) modelCommentsHelper.signatureCounter++;
            //-------------
            sb.AppendLine(s3);
        }

        public static string HandleObeyFiles2(string input)
        {
            List<string> lines = G.ExtractLinesFromText(input);

            List<string> linesNew = null;
            linesNew = HandleObeyFilesNew(lines);
                        
            Globals.cmdFileLines = linesNew;  //used if there is a lexer error
            StringBuilder sb = new StringBuilder();
            foreach (string line in linesNew)
            {
                sb.AppendLine(line);
            }
            string s2 = sb.ToString();
            return s2;
        }

        public static double Percentile(double[] sequence, double excelPercentile)
        {
            //handles NaN values, return Excel-style Percentile
            //for sequence 1,2,3,4,5 these correspond to 0%, 25%, 50%, 75%, 100% and interpolates between them.
            //that seems reasonable. Uses N-1 = 4 to multiply the %, seems this corresponds to the gaps between numbers (commas).
            //again this seems reasonable if 1 and 5 are min and max.

            if (excelPercentile < 0 || excelPercentile > 1d)
            {
                G.Writeln2("*** ERROR: The percentile parameter should be between 0 and 1");
                throw new GekkoException();
            }

            Array.Sort(sequence);
            if (double.IsNaN(sequence[0]))
            {
                int x = 0;
                for (int i = 0; i < sequence.Length; i++)
                {
                    if (!double.IsNaN(sequence[i]))
                    {
                        break;
                    }
                    x = i;
                }
                double[] seq2 = new double[sequence.Length - (x + 1)];
                for (int i = x + 1; i < sequence.Length; i++)
                {
                    double y = sequence[i];
                    if (double.IsNaN(y))
                    {
                        G.Writeln2("*** ERROR: #9807435237");  //should not happen in .NET 4.0 or higher
                        throw new GekkoException();
                    }
                    seq2[i - (x + 1)] = y;
                }
                sequence = seq2;
            }
            int N = sequence.Length;
            double n = (N - 1) * excelPercentile + 1;
            // Another method: double n = (N + 1) * excelPercentile;
            if (n == 1d) return sequence[0];
            else if (n == N) return sequence[N - 1];
            else
            {
                int k = (int)n;
                double d = n - k;
                return sequence[k - 1] + d * (sequence[k] - sequence[k - 1]);
            }
        }

        //Overload
        public static ExtractBankAndRestHelper ExtractBankAndRest(string input, EExtrackBankAndRest type)
        {
            return ExtractBankAndRest(input, type, true);
        }

        //Does not allow wildcards in bankname
        //returns whether there is a ':' or not
        public static ExtractBankAndRestHelper ExtractBankAndRest(string input, EExtrackBankAndRest type, bool errorIfTimeseriesIsNotFound)
        {
            //If noErrorIfTimeseriesIsNotFound = false, and the timeseries is not fund, the h.ts will be = null
            ExtractBankAndRestHelper h = new ExtractBankAndRestHelper();
            string[] split = input.Split(':');
            if (split.Length == 1)
            {
                if (type == EExtrackBankAndRest.OnlyStringNoFirstName) h.bank = null;  //so that we can see that the name is not explicitly indicated
                else h.bank = Program.databanks.GetFirst().aliasName;
                h.name = split[0].Trim();
            }
            else if (split.Length == 2)
            {
                h.bank = split[0].Trim();
                if (h.bank == Globals.firstCheatString)
                {
                    h.bank = Program.databanks.GetFirst().aliasName;
                }
                else if (h.bank == "@")
                {
                    h.bank = Program.databanks.GetRef().aliasName;
                    h.hasColon = true;
                }
                else
                {
                    h.hasColon = true;
                }
                h.name = split[1].Trim();
            }
            else
            {
                G.Writeln2("*** ERROR: Did not expect more than 1 colon in '" + input + "'");
                throw new GekkoException();
            }

            if (h.bank != null && (h.bank.Contains("*") || h.bank.Contains("?")))
            {
                G.Writeln2("*** ERROR: Wildcard not allowed for bankname");
                throw new GekkoException();
            }

            if (type == EExtrackBankAndRest.GetDatabank || type == EExtrackBankAndRest.GetDatabankAndTimeSeries)
            {
                //Will return databank object
                h.databank = Program.databanks.GetDatabank(h.bank);
                if (h.databank == null)
                {
                    G.Writeln2("*** ERROR: Could not find databank '" + h.bank + "': is the databank open?");
                    throw new GekkoException();
                }
            }

            if (type == EExtrackBankAndRest.GetDatabankAndTimeSeries)
            {
                //Will return timeseries object
                h.ts = h.databank.GetVariable(h.name);
                if (h.ts == null)
                {
                    if (errorIfTimeseriesIsNotFound)
                    {
                        G.Writeln2("*** ERROR: Could not find timeseries '" + h.name + "' in '" + h.bank + "' databank");
                        throw new GekkoException();
                    }
                    else
                    {
                        //Do nothing, h.ts = null is returned. But we do not allow this ignore regarding a databank name.
                    }
                }
            }

            return h;
        }

        public static void PutListIntoListOrListfile(List<string> listItems, string name, string listFile)
        {
            List<string> newList = new List<string>();

            if (name != null && listFile == null)
            {
                newList = Program.CreateNewList(listItems, name);
            }
            else if (name == null && listFile != null)
            {
                string file = listFile;
                Program.WriteExternalListFile(file, listItems);
            }
            else
            {
                G.Writeln2("*** ERROR: Unexpected error #87230944 related to list name/listfile");
                throw new GekkoException();
            }

            //Remove null element, if only one (used for "LIST xx = null")                
            for (int i = 0; i < newList.Count; i++)
            {
                if (G.equal(newList[i], "null"))
                {
                    if (newList.Count == 1)
                    {
                        newList.Clear();  //remove the null element
                    }
                    else
                    {
                        G.Writeln2("*** ERROR: Null element is only allowed if it is the first and only list element");
                        throw new GekkoException();
                    }
                }
            }
        }

        public static void WriteExternalListFile(string file, List<string> listItems)
        {

            file = Program.AddExtension(file, "." + "lst");
            string pathAndFilename = Program.CreateFullPathAndFileNameFromFolder(file, null);
            using (FileStream fs = Program.WaitForFileStream(pathAndFilename, Program.GekkoFileReadOrWrite.Write))
            using (StreamWriter res = G.GekkoStreamWriter(fs))
            {
                foreach (string s in listItems)
                {
                    res.WriteLine(s);
                }
                res.Flush();
                res.Close();
            }
        }


        public static string HandleOneLiners(string text)
        {
            if (Globals.runningOnTTComputer)
            {
                string s2 = text.Trim();
                if (s2.EndsWith(";")) s2 = s2.Substring(0, s2.Length - 1);
                s2 = s2.Trim();

                if (s2.StartsWith("I(\"") && s2.EndsWith("\")"))
                {
                    text = s2.Substring(3, s2.Length - 5);
                }

                if (s2.StartsWith("bvar"))
                {
                    string[] bv = s2.Split(' ');
                    string xxxx = bv[1];
                    xxxx = xxxx.Replace(";", "");
                    int xx = int.Parse(xxxx);
                    string xxx = Program.model.varsBTypeInverted[xx];
                    G.Writeln("b[" + xx + "] = " + xxx);
                    return "";
                }
                if (s2.Length == 8)
                {
                    string sub = s2;
                    if (G.equal(sub, "rungenr1"))
                    {
                        //typing "rungenr1" will put cs code in Genr.cs
                        G.Writeln2("Put code in Genr.cs. Now you should compile...");
                        Program.Rungenr(1);
                        return "";  //no need for the parser to chew on this afterwards!
                    }
                    else if (G.equal(sub, "rungenr2"))
                    {
                        //typing "rungenr2" will run stuff in Genr.cs for debugging
                        G.Writeln2("Running Genr.cs for debugging:");
                        Program.Rungenr(2);
                        return "";  //no need for the parser to chew on this afterwards!
                    }
                }
                if (s2.Length == 6)
                {
                    string sub = s2;
                    if (G.equal(sub, "ssplit"))
                    {
                        Globals.splitCsCodeIntoChunks = !Globals.splitCsCodeIntoChunks;
                        G.Writeln("SPLIT = " + Globals.splitCsCodeIntoChunks);
                        return "";  //no need for the parser to chew on this afterwards!
                    }
                }
                if (s2.Length == 7)
                {
                    string sub = s2;
                    if (G.equal(sub, "ssimple"))
                    {
                        Globals.simpleCode = !Globals.simpleCode;
                        G.Writeln("SIMPLE (ast_upd()) = " + Globals.simpleCode);
                        return "";  //no need for the parser to chew on this afterwards!
                    }
                }

                //simpleCode

                if (s2.Length == 7)
                {
                    string sub = s2;
                    if (G.equal(sub, "timings"))
                    {
                        Globals.showTimings = !Globals.showTimings;
                        G.Writeln("TIMINGS = " + Globals.showTimings);
                        return "";  //no need for the parser to chew on this afterwards!
                    }
                }

                if (s2.Length == 7)
                {
                    string sub = s2;
                    if (G.equal(sub, "packsim"))
                    {
                        Globals.alwaysEnablcPackForSimulation = true;
                        G.Writeln("alwaysEnablcPackForSimulation = " + Globals.alwaysEnablcPackForSimulation);
                    }
                }

                if (s2.Length == 6)
                {
                    string sub = s2;
                    if (G.equal(sub, "aremos"))
                    {
                        //typing "aremos" on the prompt opens the dialog for creating a wa.bat file.
                        //not intended for "normal" Gekko users.
                        makeBatFileForAremos();
                        return "";  //no need for the parser to chew on this afterwards!
                    }
                }

                if (s2.StartsWith("dream"))
                {
                    if (false)                    {

                        DecompOptions decompOptions = new DecompOptions();
                        decompOptions.dream = s2;
                        Decomp(decompOptions);
                    }
                    else
                    {
                        Program.Dream("t=2010-2010");
                    }
                    return "";
                }

                if (s2.Length == 5)
                {
                    if (G.equal(s2, "eigen"))
                    {
                        Eigen();
                        return "";  //no need for the parser to chew on this afterwards!
                    }
                }


                if (s2.Length == 5)
                {
                    string sub = s2;
                    if (G.equal(sub, "flush"))
                    {
                        Flush();  //removes cached models
                        return "";
                    }
                }


                if (s2.Length == 11)
                {
                    string sub = s2;
                    if (G.equal(sub, "randommodel"))
                    {
                        Randommodel();
                        return "";  //no need for the parser to chew on this afterwards!
                    }
                }

                if (s2.Length == 16)
                {
                    string sub = s2;
                    if (G.equal(sub, "randommodelcheck"))
                    {
                        Randommodelcheck();
                        return "";  //no need for the parser to chew on this afterwards!
                    }
                }

                if (s2.Length == 3)
                {
                    string sub = s2;
                    if (G.equal(sub, "cge"))
                    {
                        CGE.Run();
                        CGE.GamsReader();
                        return "";   //no need for the parser to chew on this afterwards!
                    }
                }

                if (s2.Length == 6)
                {
                    string sub = s2;
                    if (G.equal(sub, "deploy"))
                    {
                        //Deploy
                        if (Globals.runningOnTTComputer)
                        {
                            Deploy.MainWindow w = new Deploy.MainWindow();
                            w.SetStartupPath(Application.StartupPath);                            
                            w.ShowDialog();
                        }
                        return "";   //no need for the parser to chew on this afterwards!
                    }
                }

                if (s2.Length == 7)
                {

                    string sub = s2;

                    if (G.equal(sub, "testsim"))
                    {
                        int n = 1000;
                        double[] abs = new double[3000];  //years
                        double[] rel = new double[3000];  //years
                        string[] absVar = new string[3000];  //years
                        string[] relVar = new string[3000];  //years

                        double[] absVs = new double[3000];  //years
                        double[] relVs = new double[3000];  //years

                        double[] absHs = new double[3000];  //years
                        double[] relHs = new double[3000];  //years

                        int min = int.MaxValue;
                        int max = int.MinValue;
                        List<string> list = O.GetMetaList(Program.scalars[Globals.symbolList + "endo"]).list;
                        int x = list.Count;
                        G.Writeln("Testing " + x + " endogenous vars");
                        for (int i = 0; i < x; i += n)
                        {
                            G.Writeln("Testing " + i + " up to " + (i + n - 1));
                            List<string> res = TestSim(list, i, i + n - 1);
                            foreach (string s in res)
                            {
                                string[] s3 = s.Split('¤');
                                string type = s3[0];
                                int year = int.Parse(s3[1]);
                                string var = s3[2];
                                double val = double.Parse(s3[3]);
                                double vs = double.Parse(s3[4]);
                                double hs = double.Parse(s3[5]);
                                if (year < min) min = year;
                                if (year > max) max = year;
                                if (type == "abs")
                                {
                                    if (val > abs[year])
                                    {
                                        abs[year] = val;
                                        absVar[year] = var;
                                        absVs[year] = vs;
                                        absHs[year] = hs;
                                    }
                                }
                                else
                                {
                                    if (val > rel[year])
                                    {
                                        rel[year] = val;
                                        relVar[year] = var;
                                        relVs[year] = vs;
                                        relHs[year] = hs;
                                    }
                                }
                            }
                        }

                        G.Writeln();
                        for (int y = min; y <= max; y++)
                        {
                            G.Writeln("rel% " + y + " " + relVar[y] + " " + rel[y] + "%     left " + relVs[y] + " right " + relHs[y]);
                        }

                        G.Writeln();
                        for (int y = min; y <= max; y++)
                        {
                            G.Writeln("abs " + y + " " + absVar[y] + " " + abs[y] + "     left " + absVs[y] + " right " + absHs[y]);
                        }

                        return "";  //no need for the parser to chew on this afterwards!
                    }
                }

                if (s2.Length == 3)
                {
                    string sub = s2;
                    if (G.equal(sub, "lex"))
                    {
                        //show raw tokens
                        //only for debugging
                        //not intended for "normal" Gekko users.
                        if (Globals.debugTokens) Globals.debugTokens = false;
                        else Globals.debugTokens = true;
                        if (Globals.debugTokens == true)
                        {
                            G.Writeln("Lexing will be done...");
                        }
                        else
                        {
                            G.Writeln("Lexing undone...");
                        }
                        return "";  //no need for the parser to chew on this afterwards!
                    }
                }


                if (s2.Length == 5)
                {
                    string sub = s2;
                    if (G.equal(sub, "histo"))
                    {
                        Globals.histo = !Globals.histo;
                        return "";  //no need for the parser to chew on this afterwards!
                    }
                }

                if (s2.Length == 3)
                {
                    string sub = s2;
                    if (G.equal(sub, "ast"))
                    {
                        //typing "ast" on the prompt means AST tree is printed out on screen
                        //only for debugging
                        //not intended for "normal" Gekko users.
                        Globals.printAST = true;
                        G.Writeln("AST tree will be printed...");
                        return "";  //no need for the parser to chew on this afterwards!
                    }
                }

                if (s2.Length == 7)
                {
                    string sub = s2;
                    if (G.equal(sub, "timings"))
                    {
                        Globals.showTimings = true;
                        G.Writeln("Timings shown...");
                        return "";  //no need for the parser to chew on this afterwards!
                    }
                }

                if (s2.Length == 5)
                {
                    string sub = s2;
                    if (G.equal(sub, "cache"))
                    {
                        if (Globals.useCache == true)
                        {
                            Globals.useCache = false;
                            G.Writeln2("Set useCache to false");
                        }
                        else if (Globals.useCache == false)
                        {
                            Globals.useCache = true;
                            G.Writeln2("Set useCache to true");
                        }
                        return "";
                    }

                }

                if (s2.Length == 6)
                {
                    string sub = s2;
                    if (G.equal(sub, "speed1"))
                    {
                        double n = 10000000d;
                        string s = "val k   = 0; val m   = 0; val k1  = 1; val k2  = " + n + "; for val k=%k1 to %k2; val m=%m+%k; end;";
                        DateTime t0 = DateTime.Now;
                        obeyCommandCalledFromGUI(s, new P());
                        DateTime t1 = DateTime.Now;
                        double ms = (t1 - t0).TotalMilliseconds;
                        G.Writeln2("Speed1 = " + Math.Round((n / 1000d) / (ms / 1000d), 2) + " kcalc/s, n = " + n / 1000000d + " mio, " + Math.Round(ms / 1000d, 2) + " s");
                        double x = Program.scalars["m"].GetVal(Globals.tNull);
                        G.Writeln("Difference from true: " + (x - (n * (n + 1) / 2)));
                        return "";  //no need for the parser to chew on this afterwards!
                    }
                    else if (G.equal(sub, "speed2"))
                    {
                        DateTime t0 = DateTime.Now;

                        //runs 2-3 x faster as integer loop, but never mind
                        double n = 100000000d;
                        double sum = 0;
                        for (double i = 1; i <= n; i++)
                        {
                            sum += i;
                        }

                        DateTime t1 = DateTime.Now;
                        double ms = (t1 - t0).TotalMilliseconds;
                        G.Writeln2("C# Speed1 = " + Math.Round((n / 1000d) / (ms / 1000d), 2) + " kcalc/s, n = " + n / 1000000d + " mio, " + Math.Round(ms / 1000d, 2) + " s");
                        double x = sum;
                        G.Writeln("Difference from true: " + (x - (n * (n + 1) / 2)));
                        return "";  //no need for the parser to chew on this afterwards!
                    }
                    else if (G.equal(sub, "speed3"))
                    {
                        double n = 100000d;
                        string s = "time 95 2020; create y1, y2, y3, x1; upd <95 2020> y1 = 10 20 30 40 50 60 70 80 90 100 110 120 130 140 150 160 170 180 190 200 210 220 230 240 250 260; upd <95 2020> y2 = 10 20 30 40 50 60 70 80 90 100 110 120 130 140 150 160 170 180 190 200 210 220 230 240 250 260; upd <95 2020> y3 = 10 20 30 40 50 60 70 80 90 100 110 120 130 140 150 160 170 180 190 200 210 220 230 240 250 260; upd <95 2020> x1 = 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26; val k = 0; val x  = 1; val k1 = 0; val k2 = " + n + "; for val k = %k1 to %k2; GENR <2000 2020> x1 = y1 + y1[-1] + y2 + y2[-1] + y3[2000] + %x + 1 + 2; end;";
                        DateTime t0 = DateTime.Now;
                        obeyCommandCalledFromGUI(s, new P());
                        DateTime t1 = DateTime.Now;
                        double ms = (t1 - t0).TotalMilliseconds;
                        G.Writeln2("Speed3 = " + Math.Round((n / 1000d) / (ms / 1000d), 2) + " kcalc/s, n = " + n / 1000000d + " mio, " + Math.Round(ms / 1000d, 2) + " s");
                        return "";  //no need for the parser to chew on this afterwards!
                    }
                }

                if (s2.Length == 5)
                {
                    string sub = s2;
                    if (G.equal(sub, "proto"))
                    {
                        if (Globals.databanksAsProtobuffers == true) Globals.databanksAsProtobuffers = false;
                        else Globals.databanksAsProtobuffers = true;
                        G.Writeln("Protobuf using is set to: " + Globals.databanksAsProtobuffers);
                        return "";  //no need for the parser to chew on this afterwards!
                    }
                }

                if (s2.Length == 4)
                {
                    string sub = s2;
                    if (G.equal(sub, "gray"))
                    {
                        if (Globals.printGrayLinesForDebugging == true) Globals.printGrayLinesForDebugging = false;
                        else Globals.printGrayLinesForDebugging = true;
                        G.Writeln("Gray printing (debug) is set to: " + Globals.printGrayLinesForDebugging);
                        return "";  //no need for the parser to chew on this afterwards!
                    }
                }

                if (s2.StartsWith("prune "))
                {
                    string[] ss2 = s2.Split(' ');
                    double prune = double.Parse(ss2[1].Trim());
                    Globals.pruneDecomp = prune;
                    G.Writeln("Flowchart prune set to: " + Globals.pruneDecomp);
                    G.Writeln();
                    return "";
                }

                //if (s2.Length == 4)
                //{
                //    string sub = s2;
                //    if (G.equal(sub, "ast2"))
                //    {
                //        //typing "ast2" on the prompt means AST tree is printed out on screen
                //        //and test parser is used
                //        //only for debugging
                //        //not intended for "normal" Gekko users.
                //        Globals.printAST = true;
                //        Globals.useTestParser = true;
                //        G.Writeln("AST tree will be printed...");
                //        G.Writeln("Testparser is used...");
                //        return "";  //no need for the parser to chew on this afterwards!
                //    }
                //}

                if (s2.Length == "killexcel".Length)
                {
                    if (G.equal(s2, "killexcel"))
                    {
                        DialogResult result = MessageBox.Show("Delete all processes with 'excel' in their names? CLOSE EXCEL SHEETS BEFOREHAND!!", "Gekko helper", MessageBoxButtons.YesNo, MessageBoxIcon.None, MessageBoxDefaultButton.Button2, MessageBoxOptions.DefaultDesktopOnly);
                        if (result == DialogResult.Yes)
                        {
                            G.Writeln("");
                            int counter = 0;
                            Process[] ps = Process.GetProcesses();
                            foreach (var process in ps)
                            {
                                string name = process.ProcessName;
                                if (name.ToLower().Contains("excel"))
                                {
                                    process.Kill();
                                    G.Writeln("Killed '" + name + "'");
                                    counter++;
                                }
                            }
                            G.Writeln("Killed " + counter + " Excel processes");
                        }
                        else G.Writeln2("Cancelled");
                        return "";  //no need for the parser to chew on this afterwards!
                    }
                }

                if (s2.Length == 6)
                {
                    string sub = s2;
                    if (G.equal(sub, "locked"))
                    {
                        //typing "locked" on the prompt searches for locked files (sharing violation)
                        //in working folder and sub-dirs
                        //intended for bug finding
                        if (true)
                        {
                            string workingFolder = G.GetWorkingFolder();
                            G.Writeln("Searching for locked files in " + workingFolder);
                            G.Writeln("The search includes sub-folders");
                            G.Writeln("----------- search starts --------------");
                            Globals.lockedCounter = 0;
                            FindLockedFiles(G.GetWorkingFolder());
                            G.Writeln("----------- search ends   --------------");
                            G.Writeln("Found " + Globals.lockedCounter + " locked files");
                            G.Writeln();
                        }
                        return "";  //no need for the parser to chew on this afterwards!
                    }
                }
            }
            return text;
        }


        private static void FindLockedFiles(string folder)
        {
            foreach (string file in Directory.GetFiles(folder))
            {
                try
                {
                    using (FileStream fs = File.Open(file, FileMode.Open, FileAccess.Read, FileShare.None))
                    {
                        fs.Close();
                    }
                    // The file is not locked
                }
                catch (Exception)
                {
                    // The file is locked
                    G.Writeln("locked: " + file);
                    Globals.lockedCounter++;
                }

            }
            foreach (string subDir in Directory.GetDirectories(folder))
            {
                FindLockedFiles(subDir);
            }
        }



        public static void ConvertMenu2()
        {
            string folder = "";
            FolderBrowserDialog fbd = new FolderBrowserDialog();
            fbd.SelectedPath = Program.options.folder_working;
            if (fbd.ShowDialog() == DialogResult.OK)
            {
                folder = fbd.SelectedPath;
            }
            if (folder != "")
            {
                string outputPath = Globals.localTempFilesLocation + "\\" + "menufilesconversion";
                DeleteFolder(outputPath);
                Directory.CreateDirectory(outputPath);

                Globals.convertMenuCounter = 0;
                Globals.convertMenuErrorCounter = 0;

                G.Writeln("Starting conversion of menus...");

                ConvertMenu(0, folder, folder, outputPath);

                bool ok = true;
                try
                {
                    string stylesFile = Application.StartupPath + "\\images\\" + "styles.css";
                    string tableIconFile = Application.StartupPath + "\\images\\" + "table.png";
                    WaitForFileCopy(stylesFile, outputPath + "\\styles.css");
                    WaitForFileCopy(tableIconFile, outputPath + "\\table.png");
                }
                catch (Exception e)
                {
                    ok = false;
                    G.Writeln2("*** ERROR: Problem with style-sheets, may impact the menus (files styles.css and table.png)");
                }

                G.Writeln();
                G.Write("Zipping converted files... ");
                string zipFileNameInput = Program.CreateFullPathAndFileName(Program.options.folder_working + "\\converted_menus.zip");
                Program.WaitForZipWrite(outputPath, zipFileNameInput);
                G.Writeln("... ended");
                G.Writeln();
                G.Writeln("Converted " + Globals.convertMenuCounter + " menus from folder: " + folder);
                G.Writeln("There were " + Globals.convertMenuErrorCounter + " error messages.");
                G.Writeln("See the file converted_menus.zip in the working folder.");
                if (ok)
                {
                    G.Writeln("Note the two files styles.css and table.png in the root of the zip file: these");
                    G.Writeln("two files are used to style the menus, without them the menus will look ugly!");
                }
            }
            else
            {
                G.Writeln2("*** ERROR: please choose a folder");
            }
        }

        public static void ConvertMenu(int depth, string start, string folder, string outputPath)
        {
            foreach (string file in Directory.GetFiles(folder))
            {
                if (file.ToLower().EndsWith(".cmd"))
                {
                    //G.Writeln("table file: " + file);
                    string extra = file.Replace(start, "");

                    StringBuilder x = new StringBuilder();

                    try
                    {
                        x = ConvertPcimMenu(depth, file);
                    }
                    catch (Exception e)
                    {
                        G.Writeln();
                        G.Writeln("Conversion failed completely: " + file);
                        G.Writeln();
                        x = null;
                    }

                    if (x != null)
                    {
                        Globals.convertMenuCounter++;
                        string newfile = outputPath + extra;
                        if (newfile.ToLower().EndsWith(".cmd"))
                        {
                            newfile = newfile.Substring(0, newfile.Length - 4);
                            newfile = newfile + ".html";
                        }
                        else
                        {
                            G.Writeln2("*** ERROR: Converting menus: file name: " + newfile);
                        }
                        string path = Path.GetDirectoryName(newfile);
                        if (!Directory.Exists(path))
                        {
                            Directory.CreateDirectory(path);
                        }

                        using (FileStream fs = WaitForFileStream(newfile, GekkoFileReadOrWrite.Write))
                        using (StreamWriter sw = G.GekkoStreamWriter(fs))
                        {
                            sw.Write(x);
                            sw.Flush();
                        }
                    }
                }
            }
            if (true)  //we allow converting subfolders
            {
                foreach (string subDir in Directory.GetDirectories(folder))
                {
                    ConvertMenu(depth + 1, start, subDir, outputPath);
                }
            }
        }


        public static void ConvertTabToText2(string folder)
        {

            string outputPath = Globals.localTempFilesLocation + "\\" + "tabtotextconversion";

            DeleteFolder(outputPath);
            Directory.CreateDirectory(outputPath);

            Globals.convertTabToTextCounter = 0;
            Globals.convertTabToTextErrorCounter = 0;

            G.Writeln("Starting conversion of tables to text...");

            try
            {
                Program.options.interface_debug = "none";
                ConvertTabToText(0, folder, folder, outputPath);
            }
            finally
            {
                WaitForFileDelete(Program.options.folder_working + "\\" + "temptabtotextfile.txt");
                Program.options.interface_debug = "dialog";
            }

            G.Writeln();
            G.Write("Zipping converted files... ");
            string zipFileNameInput = Program.CreateFullPathAndFileName(Program.options.folder_working + "\\converted_table_text.zip");
            Program.WaitForZipWrite(outputPath, zipFileNameInput);
            G.Writeln("... ended");
            G.Writeln();
            G.Writeln("Converted " + Globals.convertTabToTextCounter + " tables from folder: " + folder);
            G.Writeln("with " + Globals.convertTabToTextErrorCounter + " non-converted tables (errors).");
            G.Writeln("Result is in the file converted_table_text.zip in the working folder.");
        }

        public static void ConvertTabToText(int depth, string start, string folder, string outputPath)
        {
            foreach (string file in Directory.GetFiles(folder))
            {
                string extra = file.Replace(start, "");
                if (file.ToLower().EndsWith("." + Globals.extensionTable))
                {
                    StringBuilder x = null;

                    try
                    {
                        string s = ConvertTabToTextHelper(depth, file);
                        x = new StringBuilder(s);
                    }
                    catch (Exception e)
                    {
                        G.Writeln2("*** ERROR: Conversion failed completely: " + file);
                        G.Writeln("----------------------------------------------------------------------");
                        G.Writeln("");
                        Globals.convertTabToTextErrorCounter++;
                        x = null;
                    }

                    if (x != null)
                    {
                        Globals.convertTabToTextCounter++;
                        G.Writeln("Total converted tables: " + Globals.convertTabToTextCounter);
                        string newfile = outputPath + extra;
                        string path = Path.GetDirectoryName(newfile);
                        if (!Directory.Exists(path))
                        {
                            Directory.CreateDirectory(path);
                        }

                        newfile = Path.ChangeExtension(newfile, ".txt");

                        using (FileStream fs = WaitForFileStream(newfile, GekkoFileReadOrWrite.Write))
                        using (StreamWriter sw = G.GekkoStreamWriter(fs))
                        {
                            sw.Write(x);
                            sw.Flush();
                        }
                    }
                }
                else if (file.ToLower().EndsWith(".html"))
                {
                    //for HTML menu files, we change links to .tab files to .txt files (unfortunately necessary in order to get IE to read them).
                    string newfile = outputPath + extra;
                    string path = Path.GetDirectoryName(newfile);
                    if (!Directory.Exists(path))
                    {
                        Directory.CreateDirectory(path);
                    }

                    string s = GetTextFromFileWithWait(file);
                    s = s.Replace("." + Globals.extensionTable + "\"", ".txt\"");
                    using (FileStream fs = WaitForFileStream(newfile, GekkoFileReadOrWrite.Write))
                    using (StreamWriter sw = G.GekkoStreamWriter(fs))
                    {
                        sw.Write(s);
                        sw.Flush();
                    }
                }
            }
            if (true)  //we allow converting subfolders
            {
                foreach (string subDir in Directory.GetDirectories(folder))
                {
                    ConvertTabToText(depth + 1, start, subDir, outputPath);
                }
            }
        }


        public static StringBuilder ConvertPcimMenu(int depth, string file)
        {
            StringBuilder x = new StringBuilder();

            StringBuilder x2 = new StringBuilder();

            string title = null;

            List<string> lines = G.ExtractLinesFromText(GetTextFromFileWithWait(file));
            int counter = 0;

            string path = "";
            for (int i = 0; i < depth; i++)
            {
                path = path + "../";
            }

            foreach (string line2 in lines)
            {
                if (line2.ToLower() == "case") continue;  //kind of empty line
                string line = line2.Trim();
                counter++;
                if (line.Contains("\""))
                {
                    MenuConvertError(file, counter, line, "Menu lines should not contain full quotes (\")");
                }


                if (line.ToLower().StartsWith("nymenu "))
                {
                }
                else if (line.ToLower().StartsWith("select "))
                {
                }
                else if (line.ToLower().StartsWith("case "))
                {
                    string lineTrunc = line.Substring(5);
                    string[] split = lineTrunc.Split('/');
                    if (split.Length == 1)
                    {
                        if (title == null)
                        {
                            title = split[0].Trim();  //only first time
                        }
                        else
                        {
                            //2. time and on
                            x2.AppendLine("      <li>" + split[0].Trim() + "</li>");
                        }
                    }
                    else if (split.Length == 2)
                    {
                        x2.AppendLine("      <li><a href=`" + split[1].Trim() + ".html`>" + split[0].Trim() + "</a></li>");
                    }
                    else if (split.Length >= 3)
                    {
                        if (split.Length > 3) MenuConvertError(file, counter, line, "There are more than 2 '/' in the line: cannot understand");

                        string s1 = split[0].Trim();

                        string lastWord = "";
                        for (int i = s1.Length - 1; i >= 1; i--)
                        {
                            if (!(G.IsLetterOrDigitOrUnderscore(s1[i]) || s1[i] == '-' || s1[i] == '(' || s1[i] == ')'))
                            {
                                if (s1[i] == ' ' && s1[i - 1] == ' ')  //two blanks before word
                                {
                                    if (i < s1.Length - 1)
                                    {
                                        lastWord = s1.Substring(i + 1);
                                    }
                                }
                                break;
                            }
                        }

                        string text = s1;
                        string lbl = "";

                        if (lastWord != "")
                        {
                            //try looking at last word
                            text = s1.Substring(0, s1.Length - lastWord.Length).TrimEnd();
                            lbl = lastWord;
                        }
                        text = text + " ";

                        string img = "<img src=`" + path + "table.png`>";

                        if (lbl != "")
                        {
                            x2.AppendLine("      <li><a href=`" + split[2].Trim() + "." + Globals.extensionTable + "`>" + img + " " + text + " <font color=`silver`>(" + lbl + ")</font>" + "</a>" + "</li>");
                        }
                        else
                        {
                            x2.AppendLine("      <li><a href=`" + split[2].Trim() + "." + Globals.extensionTable + "`>" + img + " " + text + "</a>" + "</li>");
                        }
                    }
                }
                else
                {
                    MenuConvertError(file, counter, line, "Could not recognize this as a menu line, skipping");
                }
            }

            if (title == null) title = "Menu";

            x.AppendLine("<!DOCTYPE HTML PUBLIC `-//W3C//DTD HTML 4.01 Transitional//EN`>");
            x.AppendLine("<html>");
            x.AppendLine("  <head>");
            x.AppendLine("    <link rel=`stylesheet` href=`" + path + "styles.css` type=`text/css`>");
            x.AppendLine("    <meta http-equiv=`Content-Type` content=`text/html; charset=iso-8859-1`>");
            x.AppendLine("    <title>" + title + "</title>");
            x.AppendLine("  </head>");
            x.AppendLine("  <body>");
            x.AppendLine("  <big><b>" + title + "</b></big><br>");
            x.AppendLine("    <ul>");
            x.Append(x2);
            x.AppendLine("    </ul>");
            x.AppendLine("  </body>");
            x.AppendLine("</html>");

            x.Replace("`", "\"");

            return x;
        }


        public static string ConvertTabToTextHelper(int depth, string file)
        {
            string tt1 = "__tabletimestart";
            string tt2 = "__tabletimeend";

            P p = new P();
            Program.XmlTable(file, "txt", null, p);
            Program.Pipe("temptabtotextfile.txt", null);  //no append
            Program.Run(Globals.localTempFilesLocation + "\\" + "tablecode." + Globals.defaultCommandFileExtension, p);
            Program.Pipe("con", null);

            string s = GetTextFromFileWithWait(Program.options.folder_working + "\\" + "temptabtotextfile.txt");

            return s;
        }


        public static void ConvertTab2()
        {
            string folder = "";
            FolderBrowserDialog fbd = new FolderBrowserDialog();
            fbd.SelectedPath = Program.options.folder_working;
            if (fbd.ShowDialog() == DialogResult.OK)
            {
                folder = fbd.SelectedPath;
            }
            if (folder != "")
            {
                string outputPath = Globals.localTempFilesLocation + "\\" + "tabfilesconversion";

                DeleteFolder(outputPath);
                Directory.CreateDirectory(outputPath);

                Globals.convertTableCounter = 0;
                Globals.convertTableErrorCounter = 0;

                G.Writeln("Starting conversion of tables...");

                ConvertTab(folder, folder, outputPath);

                G.Writeln();
                G.Write("Zipping converted files... ");
                string zipFileNameInput = Program.CreateFullPathAndFileName(Program.options.folder_working + "\\converted_tables.zip");
                Program.WaitForZipWrite(outputPath, zipFileNameInput);
                G.Writeln("... ended");
                G.Writeln();
                G.Writeln("Converted " + Globals.convertTableCounter + " tables from folder: " + folder);
                G.Writeln("There were " + Globals.convertTableErrorCounter + " error messages.");
                G.Writeln("See the file converted_tables.zip in the working folder.");
            }
            else
            {
                G.Writeln2("*** ERROR: please choose a folder");
            }
        }

        public static void ConvertTab(string start, string folder, string outputPath)
        {
            foreach (string file in Directory.GetFiles(folder))
            {
                if (file.ToLower().EndsWith("." + "tab"))
                {
                    //G.Writeln("table file: " + file);
                    string extra = file.Replace(start, "");

                    StringBuilder x = new StringBuilder();

                    try
                    {
                        x = ConvertPcimTable(file);
                    }
                    catch (Exception e)
                    {
                        G.Writeln();
                        G.Writeln("Conversion failed completely: " + file);
                        G.Writeln();
                        x = null;
                    }

                    if (x != null)
                    {
                        Globals.convertTableCounter++;
                        string newfile = outputPath + extra;  //path and filename
                        if (newfile.ToLower().EndsWith(".tab"))
                        {
                            newfile = newfile.Substring(0, newfile.Length - 4);
                            newfile = newfile + "." + Globals.extensionTable + "";
                        }
                        else
                        {
                            //This should not be possible....
                        }
                        string path = Path.GetDirectoryName(newfile);
                        if (!Directory.Exists(path))
                        {
                            Directory.CreateDirectory(path);
                        }

                        using (FileStream fs = WaitForFileStream(newfile, GekkoFileReadOrWrite.Write))
                        using (StreamWriter sw = G.GekkoStreamWriter(fs))
                        {
                            sw.Write(x);
                            sw.Flush();
                        }
                    }
                }
            }
            foreach (string subDir in Directory.GetDirectories(folder))
            {
                ConvertTab(start, subDir, outputPath);
            }
        }

        public static void DeleteFolder(string s, string omitType)
        {
            if (!Directory.Exists(s)) return;
            DeleteFolderHelper(new DirectoryInfo(s), omitType);
        }

        public static void DeleteFolder(string s)
        {
            DeleteFolder(s, null);
        }

        //Seems it does not delete the folders, but only their content
        private static void DeleteFolderHelper(DirectoryInfo directoryInfo, string omitType)
        {
            foreach (FileInfo file in directoryInfo.GetFiles())
            {
                if (omitType != null && G.equal("." + omitType, file.Extension)) continue;  //skip it
                file.Delete();  //hmm probably best not to use WaitForFileDelete() here, exceptions are typically caught in a wrapper on this method, and not critical if it fails (used for cleanup)
            }
            foreach (DirectoryInfo subfolder in directoryInfo.GetDirectories())
            {
                DeleteFolderHelper(subfolder, omitType);
            }
        }

        private static bool Has2IdentsFollowing(string lineNewVersion, int start)
        {
            //The method looks for two idents like "a1 b2 " or "a1 b2>". Any spaces before, in middle or after are ok.
            //A '=' right after the second token is ok too.
            int j = skipSpaces(lineNewVersion, start);
            if (j == -12345) return false;
            if (!G.IsLetterOrUnderscore(lineNewVersion[j])) return false;
            int blank = -12345;
            for (int k = j + 1; k < lineNewVersion.Length; k++)
            {
                if (lineNewVersion[k] == ' ')
                {
                    blank = k;
                    break;
                }
                if (!G.IsLetterOrDigitOrUnderscore(lineNewVersion[k]))
                {
                    return false;
                }
            }
            j = skipSpaces(lineNewVersion, blank);
            if (j == -12345) return false;
            if (!G.IsLetterOrUnderscore(lineNewVersion[j])) return false;
            for (int k = j + 1; k < lineNewVersion.Length; k++)
            {
                if (lineNewVersion[k] == ' ' || lineNewVersion[k] == '=' || lineNewVersion[k] == '>')
                {
                    //these are ok: <m p q>, <stamp rows=yes>, <m p>
                    //so the first two tokens will not by tried to be interpreted as two dates
                    break;
                }
                if (!G.IsLetterOrDigitOrUnderscore(lineNewVersion[k]))
                {
                    return false;
                }
            }
            return true;
        }

        private static List<string> HandleObeyFilesNew(List<string> inputFileLines)
        {
            List<string> inputFileLines2 = new List<string>();
            int lineCounter = 0;
            foreach (string line in inputFileLines)
            {
                lineCounter++;
                string lineNewVersion = line;

                if (lineNewVersion == Globals.iniFileSecretName)  //this strange name is made in GuiAutoExecStuff()
                {
                    //lineNewVersion = "run '" + Globals.autoExecCmdFileName + "';";
                    lineNewVersion = "ini;";
                }
                else if (lineNewVersion == "RunGekkoTabToTextStuff")
                {
                    ConvertTabToText2(Globals.RunGekkoTabToTextStuff_folder);
                    lineNewVersion = "";  //deleting it, has been handled above
                }

                string lineComment = lineNewVersion.Trim();

                if (Globals.addGlue)
                {

                    // Special rule to make sure PRT<m d> is not interpreted as time period, so in that case we get
                    // PRT<m d> --> PRT <¨<m d>
                    //
                    // Else: (ldu is letterDigitUnderscore)
                    // For every ldu, '(', '[', '{', '%', '#'
                    //   see if preceding char is ldu, ')', ']', '}', '%' or '#'.
                    //   if so, put a glue in between.
                    //   EXCEPTION: ldu before ldu gets no glue (of course)!
                    // For '|' there is glue before, UNLESS there is a blank before OR after the '|'
                    // For '.' ...
                    //
                    // For "<m d>" kind of options, we use a special kind of marker ('<<<' instead of '<') to indicate that it is
                    // an "<ident ident..." type.
                    //List<char> glued1 = new List<char> { ')', ']', '}', Globals.symbolMemvar, Globals.symbolList };
                    //List<char> glued2 = new List<char> { '(', '[', '{', Globals.symbolMemvar, Globals.symbolList };
                    List<char> glued3 = new List<char> { '|', '\\' };  //note special rules for '.', see glued3a
                    List<char> glued3a = new List<char> { '=', '+', '-', '/', '*', '^', '(', '{', '[', '<', '>', ',', ':', ' ' };  // "=.12", "+.12", "-.12" etc.
                    List<char> glued4 = new List<char> { '@' };  //only checked if no blank right of this
                    List<char> glued5 = new List<char> { '.' };  //only checked if no blank right of this
                    List<char> glued6 = new List<char> { '*', '?' };  //wildcards: a*b and a?b cannot have blanks.

                    //=========== note =========================
                    // [c1] [c2] [c3], where c2 is the char analyzed.
                    //==========================================

                    StringBuilder sb = new StringBuilder();
                    for (int i = 0; i < lineNewVersion.Length; i++)  //ignore if first on line
                    {
                        char c1 = '\n';
                        if (i > 0) c1 = lineNewVersion[i - 1];
                        char c2 = lineNewVersion[i];
                        char c3 = '\n';
                        if (i < lineNewVersion.Length - 1) c3 = lineNewVersion[i + 1];
                        char c4 = '\n';
                        if (i < lineNewVersion.Length - 2) c4 = lineNewVersion[i + 2];

                        // -------------------------------------------------------------
                        // Handle .1, .2, etc. For instance y.1 --> y[-1]
                        // -------------------------------------------------------------
                        if (c2 == '.' && char.IsDigit(c3) && !G.IsLetterOrDigitOrUnderscore(c4) && c4 != '.')
                        {
                            //now we have stuff like .1, and we need to check the chars before the '.'
                            bool good = false;
                            for (int ii = i - 1; ii >= 0; ii--)
                            {
                                //it may be for instance y.1 or y12345.1, so we run it backwards looking for
                                //digits only. When there are no more digits, it MUST be a letter or underscore
                                if (char.IsDigit(lineNewVersion[ii])) continue;
                                if (G.IsLetterOrUnderscore(lineNewVersion[ii])) good = true;
                                break;
                            }
                            //not ok: fy.11  fy.1a  fy.1_  fy.1.    All else is ok for fy[-1] translation, also if fy were fy12345 instead
                            //this will also get translated: %n.1  {s}.1   #m.1
                            if (good)
                            {
                                if (!lineNewVersion.Contains("'"))
                                {
                                    //You can have stuff like TABLE xx.currow.setvalues(1,2000,2010,1,'n',0.001,'f10.3'), where 'f10.3' should not become 'f10[-3]' !!!
                                    //This seems hard to solve properly, so the stuff here is only temporary
                                    //CONCLUSION: should be solved in the PARSER in the long run
                                    sb.Append(Globals.symbolGlueChar6 + "-" + c3 + "]");
                                    i++;
                                    continue;
                                }
                            }
                        }

                        // -------------------------------------------------------------
                        // Handle PRT<m d> etc.
                        // -------------------------------------------------------------
                        if (c2 == '<')
                        {
                            //Special rule to make sure the first two tokens inside <> in PRT<m d> or PRT<stamp row=yes> are not interpreted as time period
                            //If we have for instance "<m d>", the below will return true, and it will be transformed
                            //into "<¨<m d>". This makes it easier to identify such cases in the parser. We would not like
                            //to try to interpret <m d> as a time period, so two raw idents will never be thought of as a
                            //period. That way, missspellings like "<m dd>" will be caught in syntax, and it will not try
                            //to understand <filter row> as dates either. But <%t1 %t2> will be just fine as dates, as will
                            //<2010 2012>. Expressions can also be used for dates.
                            //So all in there is special treatment of the first two items in <>, since this is the only place
                            //a date is allowed.
                            if (Has2IdentsFollowing(lineNewVersion, i + 1))
                            {
                                sb.Append(Globals.symbolGlueChar5);
                                continue;
                            }
                        }

                        // -------------------------------------------------------------
                        // Handle x(, x[, x{, %x, #x
                        // c2 is current char, c1 is previous
                        // -------------------------------------------------------------
                        if (c1 != '\n')
                        {
                            /*
                                   a(      --->   a¨(     and same for the others
                                   a[      --->   special [_[ symbol
                                   a{
                                   a%  //part of name
                                   a#  //part of name

                                   )a  //for instance a%(%b)c, not need for glue here like this: a%(%b)|c as in a%d|c.
                                   ){  //same logic
                                   )%  //same logic
                                   )#  //same logic
                                   )[  //for instance #(list%i)[2] --> special [_[ symbol

                                   }a
                                   }{
                                   }%
                                   }#
                                   }[  //for instance {%a}[2000] or {a}[2000], --> special [_[ symbol

                                   %a
                                   %(
                                   %{

                                   ][  //for instance #m[3][2001q3], --> special [_[ symbol

                                   #(
                                   #{



                                   ...#a --> what is that??



                            */
                            bool glue = false;
                            bool glue2 = false;

                            if (G.IsLetterOrDigitOrUnderscore(c1) && c2 == '(') glue = true;
                            else if (G.IsLetterOrDigitOrUnderscore(c1) && c2 == '[') glue2 = true;
                            else if (G.IsLetterOrDigitOrUnderscore(c1) && c2 == '{') glue = true;
                            else if (G.IsLetterOrDigitOrUnderscore(c1) && c2 == Globals.symbolMemvar) glue = true;
                            else if (G.IsLetterOrDigitOrUnderscore(c1) && c2 == Globals.symbolList) glue = true;

                            else if (c1 == ')' && G.IsLetterOrDigitOrUnderscore(c2)) glue = true;
                            else if (c1 == ')' && c2 == '{') glue = true;
                            else if (c1 == ')' && c2 == Globals.symbolMemvar) glue = true;
                            else if (c1 == ')' && c2 == Globals.symbolList) glue = true;
                            else if (c1 == ')' && c2 == '[') glue2 = true;

                            else if (c1 == '}' && G.IsLetterOrDigitOrUnderscore(c2)) glue = true;
                            else if (c1 == '}' && c2 == '{') glue = true;
                            else if (c1 == '}' && c2 == Globals.symbolMemvar) glue = true;
                            else if (c1 == '}' && c2 == Globals.symbolList) glue = true;
                            else if (c1 == '}' && c2 == '[') glue2 = true;

                            else if (c1 == Globals.symbolMemvar && G.IsLetterOrDigitOrUnderscore(c2)) glue = true;
                            else if (c1 == Globals.symbolMemvar && c2 == '(') glue = true;
                            else if (c1 == Globals.symbolMemvar && c2 == '{') glue = true;

                            //else if (c1 == Globals.symbolDollar[0] && G.IsLetterOrDigitOrUnderscore(c2)) glue = true;
                            //else if (c1 == Globals.symbolDollar[0] && c2 == '(') glue = true;
                            //else if (c1 == Globals.symbolDollar[0] && c2 == '{') glue = true;

                            else if (c1 == Globals.symbolList && G.IsLetterOrDigitOrUnderscore(c2)) glue = true;
                            else if (c1 == Globals.symbolList && c2 == '(') glue = true;
                            else if (c1 == Globals.symbolList && c2 == '{') glue = true;

                            else if (c1 == ']' && c2 == '[') glue2 = true;

                            if (glue)
                            {
                                sb.Append(Globals.symbolGlueChar1);
                                sb.Append(c2);
                                continue;
                            }
                            else if (glue2)
                            {
                                sb.Append(Globals.symbolGlueChar6);
                                continue;
                            }

                            // -------------------------------------------------------------
                            // Handle x|x, x\\x
                            // c2 is current char, c1 is previous
                            // -------------------------------------------------------------
                            //glued3: '|', '\\'
                            else if (glued3.Contains(c2)) //add glue if "xx|yy", but not "xx| yy" or "xx |yy" or "xx | yy", and same regarding "\\"
                            {
                                //Handling '|' and '\\'
                                if (c3 != '\n')
                                {
                                    if (c1 != ' ' && c3 != ' ')
                                    {
                                        sb.Append(Globals.symbolGlueChar1); //12|34 --> 12¨|34, and 12\\34 --> 12¨\\34
                                        sb.Append(c2);
                                        continue;
                                    }
                                }
                            }
                        }

                        // -------------------------------------------------------------
                        // Handle stand-alone [a*b*c*d] that may look like a 1x1 matrix
                        // -------------------------------------------------------------
                        if (c2 == '[')
                        {
                            bool isProbablyStandAloneWildcardWithStars = false;
                            //if this '[' is glued to a name just before, it will have been handled above
                            //and given symbolGlueChar6: '[_[', and we would not end here
                            //So this must be a stand-alone '[', not an indexer on a name
                            for (int ii = i + 1; ii < lineNewVersion.Length; ii++)
                            {
                                if (lineNewVersion[ii] == ']')
                                {
                                    string s = lineNewVersion.Substring(i + 1, ii - (i + 1));
                                    if (s.Contains("*"))
                                    {
                                        string[] ss = s.Split('*');
                                        if (ss.Length > 1)
                                        {
                                            isProbablyStandAloneWildcardWithStars = true;  //looks good, we just need to check the bits
                                            //now we try to falsify it
                                            foreach (string sss in ss)
                                            {
                                                foreach (char c in sss)
                                                {
                                                    if (!G.IsLetterOrDigitOrUnderscore(c))
                                                    {
                                                        isProbablyStandAloneWildcardWithStars = false;
                                                    }
                                                }
                                            }
                                            //now it could be [a*b] or [*a] or [a*] or [a**b] or [1*2] or [a*5]
                                            if (s.StartsWith("*")) isProbablyStandAloneWildcardWithStars = false; //[*a]
                                            if (s.EndsWith("*")) isProbablyStandAloneWildcardWithStars = false;  //[a*]
                                            if (s.Contains("**")) isProbablyStandAloneWildcardWithStars = false;  //[a**b]
                                            if (char.IsDigit(s[0])) isProbablyStandAloneWildcardWithStars = false;  //[1*a]
                                        }
                                    }
                                }
                            }
                            if (isProbablyStandAloneWildcardWithStars)
                            {
                                sb.Append(Globals.symbolGlueChar7);
                                continue;
                            }
                        }


                        // -------------------------------------------------------------
                        // Handle @
                        // -------------------------------------------------------------
                        if (glued4.Contains(c2))
                        {
                            //handling '@'
                            if (c3 != '\n')
                            {
                                if (c3 == ' ')
                                {
                                    //ignore
                                }
                                else
                                {
                                    //PRT @x --> PRT @¨x, but PRT @ x --> PRT @ x.
                                    //Note that the glue is AFTER the @.
                                    sb.Append(c2);
                                    sb.Append(Globals.symbolGlueChar1);
                                    continue;
                                }
                            }
                        }

                        // -------------------------------------------------------------
                        // Handle wildcards a*b, a?b -> a½*½b, a½?½b
                        // A * will get glue (½) to the left if there is ldu to the left. a* -> a½*
                        // A * will get glue (½) to the right if there is ldu the right.  *b -> *½b
                        // -------------------------------------------------------------
                        if (glued6.Contains(c2))
                        {
                            if (G.IsLetterOrDigitOrUnderscore(c1))
                            {
                                sb.Append(Globals.symbolGlueChar4);
                            }
                            sb.Append(c2);
                            if (G.IsLetterOrDigitOrUnderscore(c3))
                            {
                                sb.Append(Globals.symbolGlueChar4);
                            }
                            continue;
                        }

                        // -------------------------------------------------------------
                        // Handle SERIES #m = ...
                        // Problem is that it needs to be interpreted as UPD-type, not GENR-type
                        // -------------------------------------------------------------
                        if (true)
                        {
                            if (!G.IsEnglishLetter(c1) && (c2 == 's' || c2 == 'S') && (c3 == 'e' || c3 == 'E'))
                            {
                                bool success = false;
                                string ident1 = null;
                                int j1 = GetNextIdent(lineNewVersion, i, out ident1);
                                if (j1 != -12345)
                                {
                                    if (ident1.ToLower() == "ser" || ident1.ToLower() == "series")
                                    {


                                        //==========================================
                                        bool hasStarted = false;
                                        for (int ii = j1; ii < lineNewVersion.Length; ii++)
                                        {
                                            if (lineNewVersion[ii] == ' ') continue;
                                            if (lineNewVersion[ii] == '<')
                                            {
                                                hasStarted = true;
                                                continue;
                                            }
                                            if (hasStarted && lineNewVersion[ii] == '>')
                                            {
                                                j1 = ii + 1;
                                                break;
                                            }
                                        }
                                        //==========================================
                                       

                                        int j2 = GetNextHash(lineNewVersion, j1);
                                        if (j2 != -12345)
                                        {
                                            string ident3 = null;
                                            int j3 = GetNextIdent(lineNewVersion, j2, out ident3);
                                            if (j3 != -12345)
                                            {
                                                int j4 = GetNextEquals(lineNewVersion, j3);
                                                if (j4 != -12345)
                                                {
                                                    success = true;
                                                    sb.Append(c2);
                                                    sb.Append("_");
                                                    sb.Append("_");
                                                    sb.Append("_");  //SER -> S___ER, SERIES -> S___ERIES, see also //#098275432874
                                                    continue;
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }

                        // -------------------------------------------------------------
                        // Handle SERIES y = 1 -2 -2 -1 and SERIES y = 1 -2 -2 -1*2
                        // Problem is that the second is genr type, but the parser starts treating it like upd type.
                        // -------------------------------------------------------------
                        if (true)
                        {
                            if (!G.IsEnglishLetter(c1) && (c2 == 's' || c2 == 'S') && (c3 == 'e' || c3 == 'E'))
                            {
                                bool success = false;
                                string ident1 = null;
                                int j1 = GetNextIdent(lineNewVersion, i, out ident1);
                                if (j1 != -12345)
                                {
                                    if (ident1.ToLower() == "ser" || ident1.ToLower() == "series")
                                    {


                                        //==========================================
                                        bool hasStarted = false;
                                        for (int ii = j1; ii < lineNewVersion.Length; ii++)
                                        {
                                            if (lineNewVersion[ii] == ' ') continue;
                                            if (lineNewVersion[ii] == '<')
                                            {
                                                hasStarted = true;
                                                continue;
                                            }
                                            if (hasStarted && lineNewVersion[ii] == '>')
                                            {
                                                j1 = ii + 1;
                                                break;
                                            }
                                        }
                                        //==========================================


                                        int j3 = GetNextEquals2(lineNewVersion, j1);
                                        if (j3 != -12345)
                                        {
                                            int j4 = GetNextComment(lineNewVersion, j3);
                                            string rest = null;
                                            if (j4 == -12345) rest = lineNewVersion.Substring(j3, lineNewVersion.Length - j3);
                                            else rest = lineNewVersion.Substring(j3, j4 - j3);

                                            int semi = rest.IndexOf(";");
                                            if (semi != -1)
                                            {
                                                rest = rest.Substring(0, semi);
                                            }

                                            StringTokenizer2 tok = new StringTokenizer2(rest, false, false);
                                            tok.IgnoreWhiteSpace = false;
                                            tok.SymbolChars = new char[] { '%', '&', '/', '(', ')', '=', '?', '@', '$', '{', '[', ']', '}', '+', '|', '^', '*', '<', '>', ';', ',', ':', '-' };
                                            Token token;
                                            int numberCounter = 0;
                                            bool simpleBlankSeparatedUpd = true;
                                            do
                                            {
                                                token = tok.Next();
                                                string value = token.Value;
                                                string kind = token.Kind.ToString();
                                                if (kind == "EOF" || kind == "WhiteSpace" || kind == "Number" || (kind == "Word" && value.ToLower() == "m") || (kind == "Symbol" && value == "-"))
                                                {
                                                    //continue
                                                }
                                                else
                                                {
                                                    simpleBlankSeparatedUpd = false;
                                                    break;
                                                }
                                                if (kind == "Number") numberCounter++;
                                            } while (token.Kind != TokenKind.EOF);

                                            //Must have at least two numbers to be activated
                                            if (simpleBlankSeparatedUpd && numberCounter == 1)
                                            {
                                                //number = 0: if the numbers are on the next line. That is typically upd type then.
                                                //it must be rather seldom that we have 1 number on the SERIES line, and the rest
                                                //on the next line, and that such a line is upd type.
                                                simpleBlankSeparatedUpd = false;
                                            }

                                            if (simpleBlankSeparatedUpd)
                                            {
                                                //will be of the form "1 -1 -2 3 4 -5 1e6 5" (with at least 2 numbers)
                                                //if (Globals.runningOnTTComputer) G.Writeln("DETECTED simpleBlankSeparatedUpd!");
                                                //really ugly hack
                                                success = true;
                                                sb.Append(c2);
                                                sb.Append("_");
                                                sb.Append("_");
                                                sb.Append("_");
                                                sb.Append("_");  //SER -> S____ER, SERIES -> S____ERIES, see also //#098275432874
                                                continue;
                                            }
                                        }
                                    }
                                }
                            }
                        }

                        // -------------------------------------------------------------
                        // Handle dots (.)
                        // -------------------------------------------------------------
                        if (glued5.Contains(c2))
                        {
                            //c2 is a '.'
                            if (c1 != '\n' && c3 != '\n')
                            {
                                if (c3 != '\n')
                                {
                                    if (c3 == ' ')
                                    {
                                        //do nothing, normal dot, for instance 12. 34
                                    }
                                    else if (char.IsDigit(c3))
                                    {
                                        if (glued3a.Contains(c1))
                                        {
                                            //  +.12, **.12, >.12, (.12, etc.
                                            sb.Append(Globals.symbolGlueChar3);  //GLUEDOTNUMBER
                                            sb.Append(c2);
                                            continue;
                                        }
                                        else if (char.IsDigit(c1))
                                        {
                                            //in stuff like 12.34 the dot becomes a GLUEDOTNUMBER
                                            //but only if stuff before 12 is not ident, for instance
                                            //x12.34. We could have hgn2.1, and that is not a number.
                                            bool number = true;
                                            for (int ii = i - 1 - 1; ii >= 0; ii--)
                                            {
                                                //.... +123.45 loops through pure digits until + is met. Here number would be true.
                                                if (glued3a.Contains(lineNewVersion[ii])) break;  //for instance a "," or "+" to delimit the number ('token')
                                                if (!char.IsDigit(lineNewVersion[ii]))
                                                {
                                                    number = false;
                                                    break;
                                                }
                                            }
                                            if (number)
                                            {
                                                sb.Append(Globals.symbolGlueChar3);  //GLUEDOTNUMBER
                                                sb.Append(c2);
                                                continue;
                                            }
                                            else
                                            {
                                                sb.Append(Globals.symbolGlueChar2);  //GLUEDOT
                                                sb.Append(c2);
                                                continue;
                                            }
                                        }
                                    }
                                    if (c1 != ' ' && c2 != ' ')
                                    {
                                        sb.Append(Globals.symbolGlueChar2);  //GLUEDOT
                                        sb.Append(c2);
                                        continue;
                                    }


                                }
                                else
                                {
                                    //ending with a dot
                                }
                            }
                            else
                            {
                                if (c3 != '\n')
                                {
                                    if (char.IsDigit(c3))
                                    {
                                        //if line starts with .1, the dot is a GLUEDOTNUMBER
                                        sb.Append(Globals.symbolGlueChar3);  //GLUEDOTNUMBER
                                        continue;
                                    }
                                }
                                else
                                {
                                    //ending with a dot
                                }
                            }
                        }

                        sb.Append(c2);
                    }
                    lineNewVersion = sb.ToString();
                }
                inputFileLines2.Add(lineNewVersion);
            }
            if (inputFileLines.Count != inputFileLines2.Count) throw new GekkoException();

            List<string> inputFileLines3 = new List<string>();

            if (Globals.runningOnTTComputer)
            {
                if (Globals.printAST)
                {
                    foreach (string s in inputFileLines2)
                    {
                        G.Writeln("-debug- " + s, Color.Orange);

                    }
                }
            }

            return inputFileLines2;
        }

        private static int GetNextIdent(string lineNewVersion, int i, out string ident)
        {
            //-12345 if no hit, else the first position to read for next thing to read
            ident = null;
            int rv = -12345;
            bool first = true;
            int start = -12345;
            for (int ii = i; ii < lineNewVersion.Length; ii++)
            {
                if (start == -12345 && lineNewVersion[ii] == ' ') continue;
                if (first) start = ii;
                if (first && !G.IsLetterOrUnderscore(lineNewVersion[ii]))
                {
                    return -12345;  //first letter is non-valid
                }
                if (!first && !G.IsLetterOrDigitOrUnderscore(lineNewVersion[ii]))
                {
                    ident = lineNewVersion.Substring(start, ii - start);
                    return ii;  //second+ letter is non-valid
                }
                first = false;
            }

            return rv;
        }

        private static int GetNextHash(string lineNewVersion, int i)
        {
            //-12345 if no hit, else the first position to read for next thing to read
            int rv = -12345;
            for (int ii = i; ii < lineNewVersion.Length; ii++)
            {
                if (lineNewVersion[ii] == ' ') continue;
                if (lineNewVersion[ii] == '#')
                {
                    return ii + 1;
                }
                return -12345;
            }
            return rv;
        }
        
        private static int GetNextEquals(string lineNewVersion, int i)
        {
            //-12345 if no hit, else the first position to read for next thing to read
            int rv = -12345;
            for (int ii = i; ii < lineNewVersion.Length; ii++)
            {
                if (lineNewVersion[ii] == ' ') continue;
                if (lineNewVersion[ii] == '=')
                {
                    return ii + 1;
                }
                return -12345;
            }
            return rv;
        }

        private static int GetNextEquals2(string lineNewVersion, int i)
        {            
            for (int ii = i; ii < lineNewVersion.Length; ii++)
            {
                if (lineNewVersion[ii] != '=') continue;
                return ii + 1;
            }
            return -12345;
        }

        private static int GetNextComment(string lineNewVersion, int i)
        {
            //-12345 if no hit, else the last position without the comment
            //dows not require spaces
            int rv = -12345;
            for (int ii = i; ii < lineNewVersion.Length - 1; ii++)
            {
                if (lineNewVersion[ii] == '/' && (lineNewVersion[ii + 1] == '/' || lineNewVersion[ii + 1] == '*')) return ii - 1;                
            }
            return rv;
        }

        private static bool IsCmdFileFound(string fileName)
        {
            bool found = false;
            List<string> folders = new List<string>();
            folders.Add(Program.options.folder_command);
            folders.Add(Program.options.folder_command1);
            folders.Add(Program.options.folder_command2);
            //The assumption is that this check is ok to do at parse time (not run time), since it is not realistic
            //to imagine .cmd files being created dynamically while the command files are running.
            fileName = SearchForFile(fileName, folders);  //calls CreateFullPathAndFileName()
            if (fileName != null) found = true;
            return found;
        }

        public static double Periods(string per1, string per2)
        {
            return 1;

        }

        public static string GetTextFromFileWithWait(string filename)
        {
            //Encoding encoding = Encoding.Default;
            String original = String.Empty;

            filename = CreateFullPathAndFileName(filename);

            if (!File.Exists(filename))
            {
                G.Writeln2("*** ERROR: file '" + filename + "' does not exist");
                throw new GekkoException();
            }

            Encoding current = null;

            bool utf8checker = false;
            using (FileStream fs = WaitForFileStream(filename, GekkoFileReadOrWrite.Read))
            {
                utf8checker = Utf8Checker.IsUtf8(fs);  //NOTE: tastes the file: this may be slow on very large files. So avoid GetTextFromFileWithWait() on databank reading etc. //previously, sr.CurrentEncoding was used, but it is not precise enough to detect UTF8 without BOM mark at start (TextPad for instance)
                fs.Position = 0;  //to rewind
                Encoding encoding = Encoding.Default;
                if (utf8checker) encoding = Encoding.UTF8;
                using (System.IO.StreamReader sr = new System.IO.StreamReader(fs, encoding))
                {
                    original = sr.ReadToEnd();
                    current = sr.CurrentEncoding;
                    sr.Close();
                }
            }

            string s = null;

            if (utf8checker)
            {
                s = original;                
            }
            else
            {
                //Convert bytes from ANSI to UTF8
                byte[] encBytes = current.GetBytes(original);  //'current' will always be equal to 'encoding' I guess, but just for safety
                byte[] utf8Bytes = Encoding.Convert(current, Encoding.UTF8, encBytes);
                s = Encoding.UTF8.GetString(utf8Bytes);
            }            

            s = s.Replace(Convert.ToChar(160).ToString(), " ");  //non-breaking space
            s = s.Replace(Convert.ToChar(173).ToString(), "");  //soft hyphen

            //the code below is probably too dangerous: what about newlines etc.??
            //s = Regex.Replace(s, @"[^\u0000-\u001F]+", string.Empty);  //see http://stackoverflow.com/questions/123336/how-can-you-strip-non-ascii-characters-from-a-string-in-c, here we use 0-1F, that is: 0-31
            
            return s;
        }


        public static void AdjustFreq()
        {
            //hash #980432
            if (Program.options.freq == EFreq.Annual)
            {
                Globals.globalPeriodStart = new GekkoTime(EFreq.Annual, Globals.globalPeriodStart.super, 1);
                Globals.globalPeriodEnd = new GekkoTime(EFreq.Annual, Globals.globalPeriodEnd.super, 1);
                G.Writeln("Frequency changed to annual (A)");
            }
            else if (Program.options.freq == EFreq.Quarterly)
            {
                Globals.globalPeriodStart = new GekkoTime(EFreq.Quarterly, Globals.globalPeriodStart.super, 1);
                Globals.globalPeriodEnd = new GekkoTime(EFreq.Quarterly, Globals.globalPeriodEnd.super, 4);
                G.Writeln("Frequency changed to quarterly (Q) -- note that 'q1' is set for start year and 'q4' for end year");
            }
            else if (Program.options.freq == EFreq.Monthly)
            {
                Globals.globalPeriodStart = new GekkoTime(EFreq.Monthly, Globals.globalPeriodStart.super, 1);
                Globals.globalPeriodEnd = new GekkoTime(EFreq.Monthly, Globals.globalPeriodEnd.super, 12);
                G.Writeln("Frequency changed to monthly (M) -- note that 'm1' is set for start year and 'm12' for end year");
            }
            else if (Program.options.freq == EFreq.Undated)
            {
                Globals.globalPeriodStart = new GekkoTime(EFreq.Undated, Globals.globalPeriodStart.super, 1);
                Globals.globalPeriodEnd = new GekkoTime(EFreq.Undated, Globals.globalPeriodEnd.super, 1);
                G.Writeln("Frequency changed to undated (U)");
            }
        }

        public static string GetSHA256Hash(string modelText)
        {
            System.Text.UTF8Encoding encoding = new System.Text.UTF8Encoding();
            byte[] modelTextInBytes = encoding.GetBytes(modelText);
            byte[] result;
            using (SHA256 shaM = new SHA256Managed())
            {
                result = shaM.ComputeHash(modelTextInBytes);
            }
            string hashValue = Convert.ToBase64String(result);
            return hashValue;
        }

        public static string GetSHA256HashFromStream(Stream stream)
        {
            byte[] result;
            using (SHA256 shaM = new SHA256Managed())
            {
                result = shaM.ComputeHash(stream);
            }
            string hashValue = Convert.ToBase64String(result);
            return hashValue;
        }

        public static string GetMD5Hash(string input)
        {
            // step 1, calculate MD5 hash from input
            MD5 md5 = System.Security.Cryptography.MD5.Create();
            byte[] inputBytes = System.Text.Encoding.UTF8.GetBytes(input);  //UTF8 seems best choice
            byte[] hash = md5.ComputeHash(inputBytes);
            // step 2, convert byte array to hex string
            StringBuilder sb = new StringBuilder();
            string s = Convert.ToBase64String(hash).Replace("=", "").Replace("+", "a").Replace("/", "b");
            //We remove empty indicator (=), and replace the two non-alphanumeric as well for simplicity.
            //a Bas64-encoding can put 6 bits in each symbol, so that 128 bits become 23 symbols.
            //This is a little better than hex (32 symbols).
            return s;
        }

        public static void Run(string fileName, P p)
        {
            bool cancel = false;
            if (fileName == "*")
            {
                Program.SelectFile(Globals.extensionCommand, ref fileName, ref cancel);
            }
            if (cancel) return;
            AddAbstract(fileName, true, false, p);
        }

        public static void Library(string fileName, P p)
        {
            if (fileName == "*")
            {
                G.Writeln2("*** ERROR: You cannot use LIBRARY *;");
                throw new GekkoException();
            }
            AddAbstract(fileName, true, true, p);
        }

        public static void Ini(P p)
        {
            string s = "gekko.ini";
            List<string> folders = new List<string>();
            folders.Add(Program.options.folder_command);
            folders.Add(Program.options.folder_command1);
            folders.Add(Program.options.folder_command2);
            string fileName2 = SearchForFile(s, folders);  //also calls CreateFullPathAndFileName()
            if (fileName2 == null)
            {
                G.Writeln2("No INI file '" + Globals.autoExecCmdFileName + "' found in working folder");
                return;  //used for gekko.ini file
            }
            Globals.cmdPathAndFileName = fileName2;  //always contains a path, is used if there is a lexer error
            Globals.cmdFileName = Path.GetFileName(Globals.cmdPathAndFileName);
            Program.EmitCodeFromANTLR("", fileName2, false, p);            
            G.Writeln();
            G.Writeln("Finished running INI file ('" + Path.GetFileName(Globals.cmdPathAndFileName) + "') from working folder");            
        }

        public static void AddAbstract(string s, bool run, bool isLibrary, P p)
        {
            s = StripQuotes(s);
            if (run)
            {
                //always called like this
                if (!s.Contains("."))
                {
                    s += "." + Globals.extensionCommand;
                }
            }
            else throw new GekkoException();            

            List<string> folders = new List<string>();
            folders.Add(Program.options.folder_command);
            folders.Add(Program.options.folder_command1);
            folders.Add(Program.options.folder_command2);

            string fileName2 = SearchForFile(s, folders);  //also calls CreateFullPathAndFileName()

            if (fileName2 == null)
            {
                //calling RUN gekko.ini here manually will fail if the file does not exist, which is fine
                G.Writeln2("*** ERROR: Could not find file: " + s);
                if (isLibrary)
                {
                    G.Writeln("*** ERROR: A function with that name is used, looking for definition .gcm");
                }
                throw new GekkoException();
            }

            if (!isLibrary)
            {
                Globals.cmdPathAndFileName = fileName2;  //always contains a path, is used if there is a lexer error
                Globals.cmdFileName = Path.GetFileName(Globals.cmdPathAndFileName);
            }

            Program.EmitCodeFromANTLR("", fileName2, isLibrary, p);

            if (G.equal(s, Globals.autoExecCmdFileName))
            {
                G.Writeln();
                G.Writeln("Finished running INI file ('" + Path.GetFileName(Globals.cmdPathAndFileName) + "') from working folder");
            }
            //G.Writeln("Finished adding file: " + s);
        }

        public static string CreateFullPathAndFileName(string s)
        {
            return CreateFullPathAndFileNameFromFolder(s, null);
        }

        public static string CreateFullPathAndFileNameFromFolder(string file, string path)
        {
            //This method can be called with path = null or path = "", in that case it reduces to
            //only adding the working folder is file is without colon.
            //Path is given from options: "option folder bank = ..." for instance
            //String is user input.
            //RULES:
            //If file includes colon
            //   return = file
            //else
            //   if path includes colon
            //      return = path + file
            //   else
            //      return working_folder + path + file
            //   end
            //end
            //
            //    +++           If path = null or path = "", the above reduces to this:
            //    +++           If file includes colon
            //    +++              return = file
            //    +++           else
            //    +++              return working_folder + "" + file (i.e. working_folder + file)
            //    +++           end
            //
            if (path == null) path = "";
            if (file == null)
            {
                G.Writeln2("*** ERROR: Expected a file name, but it is not defined");
                throw new GekkoException();
            }
            file = file.Trim(); //Most probably not necessary, but better safe than sorry
            path = path.Trim(); //Most probably not necessary, but better safe than sorry
            string fileName2 = "";
            if (file.Contains(":\\"))
            {
                fileName2 = file;
            }
            else
            {
                if (path.Contains(":\\"))
                {
                    fileName2 = path + "\\" + file;
                }
                else
                {
                    fileName2 = Program.options.folder_working + "\\" + path + "\\" + file;  //path may be = "", and workingFolder may end with "\\", and file may start with "\\" --> 4 successive "\\" to be reduced later on
                }
            }

            while (true)
            {
                int count = fileName2.Length;
                fileName2 = fileName2.Replace("\\\\", "\\");
                if (count == fileName2.Length) break;  //keeps on going until nothing more to substitute
            }

            return fileName2;
        }

        public static void Disp(GekkoTime tStart, GekkoTime tEnd, List<string> list, O.Disp o)
        {
            Disp(tStart, tEnd, list, false, false, false, o);
        }

        public static void DispSearch(string s)
        {
            G.Writeln();
            int widthRemember = Program.options.print_width;
            int fileWidthRemember = Program.options.print_filewidth;
            Program.options.print_width = int.MaxValue;
            Program.options.print_filewidth = int.MaxValue;
            try
            {
                s = StripQuotes(s);
                if (Program.unfoldedVariableList == null || Program.unfoldedVariableList.Count == 0)
                {
                    G.Writeln("No variable list read, so label search cannot be performed");
                    return;
                }
                List<string> explanation = new List<string>();
                if (Program.unfoldedVariableList == null) return;
                List<string> vars = new List<string>();
                List<string> expl = new List<string>();
                List<string> both = new List<string>();
                foreach (Program.Item item in Program.unfoldedVariableList)
                {
                    string ss = "";
                    if (item.explanation.Count > 0) ss = item.explanation[0];
                    if (G.Contains(ss, s))
                    {
                        vars.Add(item.variable);
                        expl.Add(ss);
                        both.Add(item.variable + "¤" + ss); //A bit hacky, but an easy way to get the variables sorted without using LINQ or Dictionary
                    }
                }

                both.Sort();

                int max = 0;
                for (int i = 0; i < vars.Count; i++)
                {
                    if (vars[i].Length > max) max = vars[i].Length;
                }
                max = Math.Max(max, "Variable".Length);
                int max2 = 0;
                for (int i = 0; i < expl.Count; i++)
                {
                    if (expl[i].Length > max2) max2 = expl[i].Length;
                }

                if (vars.Count > 0)
                {
                    string w = "Variable" + G.Blanks(max - "Variable".Length + 2) + "Label";
                    string w2 = new string('-', max + max2 + 2);
                    G.Writeln(w);
                    G.Writeln(w2);

                    foreach (string xx in both)
                    {
                        if (Globals.threadIsInProcessOfAborting) throw new GekkoException();
                        string[] xxx = xx.Split('¤');
                        G.WriteLink(xxx[0], "disp:" + xxx[0]);
                        G.Write(G.Blanks(max - xxx[0].Length + 2));
                        G.Writeln(xxx[1]);
                    }
                    G.Writeln(w2);
                    G.Writeln();
                }
                else
                {
                    G.Writeln("The string '" + s + "' did not match any variable labels");
                }
            }
            finally
            {
                //resetting, also if there is an error
                Program.options.print_width = widthRemember;
                Program.options.print_filewidth = fileWidthRemember;
            }

            return;
        }

                
        public static void Disp(GekkoTime tStart, GekkoTime tEnd, List<string> list, bool showFrnEquation, bool showAllPeriods, bool clickedLink, O.Disp o)
        {
            if (o != null && G.equal(o.opt_info, "yes"))
            {
                Info(tStart, tEnd, list);
                return;
            }

            Globals.dispLastDispStart = tStart; //kept if user chooses to click a link -- in that case we want to use same time settings
            Globals.dispLastDispEnd = tEnd; //kept if user chooses to click a link

            int varCounter = 0;

            foreach (string listItem in list)
            {
                //one listitem could be obk:fx*, fy, #m, obk:#m, @fy
                List<BankNameVersion> xx = Program.GetInfoFromStringWildcard(listItem, null, false);  //could use .from or .bank here!!!!
                foreach (BankNameVersion bnv in xx)
                {
                    //any wildcards are folded out, so obk:fx*
                    //could become obk:fxa, obk:fxb, obk:fxnz
                    //If option databank search = yes, a variable like fy could become work:fy, obk:fy, adbk:fy, ...
                    if (Globals.threadIsInProcessOfAborting) throw new GekkoException();
                    string var2 = bnv.name;
                    string var = G.GetUpperLowerCase(var2);

                    List<Databank> dbList = new List<Databank>();
                                        
                    if (bnv.bank == null)
                    {
                        if (Program.options.databank_search)
                        {
                            //search for it, with the current frequency
                            for (int i = 0; i < Program.databanks.storage.Count; i++)
                            {
                                if (i == 1) continue; //skip ref databank, just as when searching for series
                                dbList.Add(Program.databanks.storage[i]);
                            }
                        }
                        else
                        {
                            //In sim-mode do not search all 
                            dbList.Add(Program.databanks.GetFirst());
                        }
                    }
                    else
                    {
                        //get that excact timeseries
                        Databank db = GetBankFromBankNameVersion(bnv.bank);
                        dbList.Add(db);
                    }

                    int existenceCheck = 0;

                    foreach (Databank db in dbList) {                        

                        TimeSeries ts = db.GetVariable(var);
                        if (ts == null) continue;

                        existenceCheck++;
                        varCounter++;

                        if (ts.IsGhost())
                        {
                            //show info on array-timeseries
                            List<string> names = MatchWildcardInDatabank(var + Globals.symbolTurtle + "*", db);  //are sorted
                            if (names == null || names.Count == 0)
                            {
                                G.Writeln2("Could not find any " + var + "[...] array-timeseries");
                                continue;
                            }

                            List<GekkoDictionary<string, string>> dimensions = new List<GekkoDictionary<string, string>>();
                            foreach (string s in names)
                            {
                                string[] ss = s.Split(new string[] { Globals.symbolTurtle }, StringSplitOptions.None);
                                int dims = ss.Length - 1;
                                for (int i = dimensions.Count; i < dims; i++)
                                {
                                    dimensions.Add(new GekkoDictionary<string, string>(StringComparer.OrdinalIgnoreCase));
                                }
                                for (int i = 0; i < dims; i++)
                                {
                                    string name = ss[i + 1];
                                    if (!dimensions[i].ContainsKey(name))
                                    {
                                        dimensions[i].Add(name, "");
                                    }
                                }
                            }

                            G.Writeln2("Array-timeseries '" + var + "' has " + names.Count + " subseries in the following dimensions:");

                            int counter = 0;
                            double product = 1d;
                            string productString = "";
                            foreach (GekkoDictionary<string, string> xxx in dimensions)
                            {
                                counter++;
                                List<string> xxxx = new List<string>(xxx.Keys);
                                //xxxx.Sort();
                                xxxx = new List<string>(xxxx.OrderBy(f => f, new G.CustomComparer<string>(G.CompareNatural)).ToArray());                                
                                G.Writeln2("Dimension #" + counter + " (" + xxxx.Count + " elements): " + G.GetListWithCommas(xxxx));
                                product = product * xxxx.Count;
                                productString += xxxx.Count + " * ";
                            }
                            productString = productString.Substring(0, productString.Length - " x ".Length);

                            string first = names[0];
                            string last = names[names.Count - 1];

                            G.Writeln2("First element: " + G.PrettifyTimeseriesHash(first, true, false));
                            G.Writeln("Last element: " + G.PrettifyTimeseriesHash(last, true, false));

                            G.Writeln2("Dimension span: " + productString + " = " + product+", density: " + names.Count + "/" + product + " = " + Program.NumberFormat(100d * (names.Count / product), "0.00") + "%");

                            return;

                        }

                        //MetaTimeSeries ats = O.GetTimeSeries(var, 0, O.ECreatePossibilities.None);
                        //TimeSeries ts = ats.ts;                    


                        if (ts == null)
                        {
                            G.Writeln2("*** ERROR in DISP, cannot find " + var);
                            throw new GekkoException();
                        }
                        G.Writeln();
                        G.Writeln("==========================================================================================");
                        G.Writeln("SERIES " + db.aliasName + Globals.symbolBankColon + var);
                        if (true)
                        {
                            EEndoOrExo type1 = VariableTypeEndoExo(var);
                            string type = "";
                            if (type1 == EEndoOrExo.Exo) type = "Exogenous, ";
                            else if (type1 == EEndoOrExo.Endo) type = "Endogenous, ";

                            string freq = "[unknown frequency]";
                            if (ts.frequency == "a")
                            {
                                freq = "Annual";
                            }
                            else if (ts.frequency == "q")
                            {
                                freq = "Quarterly";
                            }
                            else if (ts.frequency == "m")
                            {
                                freq = "Monthly";
                            }
                            else if (ts.frequency == "u")
                            {
                                freq = "Undated";
                            }

                            bool noData = ts.IsNullPeriod(); //We are opening up to this possibility of 'empty' data                    

                            //GekkoTime first = ts.GetPeriodFirst();
                            //GekkoTime last = ts.GetPeriodLast();

                            GekkoTime first = ts.GetRealDataPeriodFirst();
                            GekkoTime last = ts.GetRealDataPeriodLast();

                            G.Write(type);
                            string stamp = null;
                            if (ts.stamp != null && ts.stamp != "") stamp = " (updated: " + ts.stamp + ")";
                            if (ts.frequency == "a" || ts.frequency == "u")
                            {
                                if (noData || first.super == -12345 || last.super == -12345)
                                {
                                    G.Writeln(freq + ", no data period");
                                }
                                else
                                {
                                    //we don't want 1995a1 to 2005a1, instead 1995 to 2005
                                    G.Writeln(freq + " data from " + first.super + " to " + last.super + stamp);
                                }
                            }
                            else
                            {
                                if (noData || first.super == -12345 || last.super == -12345)
                                {
                                    G.Writeln(freq + ", no data period");
                                }
                                else
                                {
                                    G.Writeln(freq + " data from " + first.super + ts.frequency + first.sub + " to " + last.super + ts.frequency + last.sub + stamp);
                                }
                            }

                        }

                        List<string> varExpl = Program.GetVariableExplanation(var);
                        foreach (string line in varExpl)
                        {
                            if (line != "")
                            {
                                G.Writeln(line);
                            }
                        }

                        //ts.label = "BNP i faste priser";
                        //ts.expression = "SERIES y = c + i + g;";
                        //ts.stamp = "20-1-2016 10:34";

                        if (ts.label != null) G.Writeln("Series label: " + ts.label);

                        if (ts.source != null)
                        {
                            //We keep the SERIES (or SER), there may be options etc. But we capitalize it.
                            string src2 = ts.source.Trim();
                            if (src2 != "")
                            {
                                G.Writeln("Series source: " + src2);
                            }
                        }

                        if (!G.IsUnitTesting()) Gui.gui.GuiBrowseArrowsStuff(var, clickedLink, 0);

                        if (Program.model != null)
                        {
                            List<string> d4 = new List<string>();
                            if (Program.model.dependents.ContainsKey(var))
                            {
                                Dictionary<string, string> d2 = Program.model.dependents[var].storage;
                                if (d2 != null)
                                {
                                    foreach (string d3 in d2.Keys)
                                    {
                                        d4.Add(d3);
                                    }
                                }
                                d4.Sort(StringComparer.InvariantCulture);
                            }

                            EquationHelper found = Program.FindEquationByMeansOfVariableName(var);

                            if (found != null && found.modelBlock != null && found.modelBlock != "" && found.modelBlock != "Unnamed")
                            {
                                G.Writeln("Modelblock: " + found.modelBlock);
                            }

                            G.Write("Influences: ");
                            if (d4.Count == 0) G.Writeln("<none>");
                            else
                            {
                                G.PrintListWithCommas(d4, true);
                            }

                            G.Writeln("------------------------------------------------------------------------------------------");

                            if (found != null)
                            {
                                int widthRemember = Program.options.print_width;
                                int fileWidthRemember = Program.options.print_filewidth;
                                Program.options.print_width = int.MaxValue;
                                Program.options.print_filewidth = int.MaxValue;
                                try
                                {
                                    //check for endo (but really not necessary, exo just does not exist)
                                    //G.Writeln(found.equationFormula);
                                    string strSplit = found.equationText;
                                    strSplit = strSplit.Replace("\r\n", "£");  //hack: £ unlikely to be used much
                                    char[] arrDelimiters = new char[] { ' ', '(', ')', '=', '+', '-', '*', '/', ',', ';', '$', '£' };  //last one is part of new line (\r\n)
                                    List<string> alWork = Program.SplitStringAndKeepDelimiters(strSplit, arrDelimiters);
                                    foreach (string s in alWork)
                                    {
                                        if (s == "£") G.Writeln();
                                        else
                                        {
                                            if (Program.model.varsAType.ContainsKey(s))
                                            {
                                                //seems the word exists as variable
                                                G.WriteLink(s, "disp:" + s);
                                            }
                                            else
                                            {
                                                G.Write(s);
                                            }
                                        }
                                    }
                                    G.Writeln();
                                }
                                finally
                                {
                                    //resetting, also if there is an error
                                    Program.options.print_width = widthRemember;
                                    Program.options.print_filewidth = fileWidthRemember;
                                }

                                G.Writeln("------------------------------------------------------------------------------------------");
                                string rhs = found.csCodeRhsHumanVersion;
                                rhs = rhs.Replace("\r\n", "");
                                //rhs = rhs.Replace("[", "(");
                                //rhs = rhs.Replace("]", ")");
                                rhs = rhs.Replace("[0]", "");

                                if (showFrnEquation)
                                {
                                    G.Writeln(found.csCodeLhsHuman + " = " + rhs + " " + ";");
                                }
                                else
                                {
                                    G.WriteLink("Show detailed equation", "disp2:" + var);
                                    G.Writeln();
                                }
                            }
                        }

                        bool hasFilter = false; if (Program.options.timefilter && Globals.globalPeriodTimeFilters2.Count > 0) hasFilter = true;

                        int max = Program.options.print_disp_maxlines;
                        if (hasFilter || Program.options.print_disp_maxlines == -1) max = int.MaxValue;

                        if (max > 0)
                        {

                            G.Writeln("------------------------------------------------------------------------------------------");
                            G.Writeln("Period        value        %");

                            int counter = 0;
                            foreach (GekkoTime gt in new GekkoTimeIterator(tStart, tEnd))
                            {
                                counter++;
                                if (hasFilter)  //some periods are set via TIMEFILTER
                                {
                                    //if some filter is set, we never truncate output to 3 or 5 lines (showAllPeriods)
                                    if (ShouldFilterPeriod(gt)) continue;
                                }
                                else
                                {
                                    if (!showAllPeriods && counter > max)
                                    {
                                        continue;
                                    }
                                }

                                if (Program.options.freq == EFreq.Annual) G.Write((gt.super) + " ");
                                else G.Write(gt.super + ts.frequency + gt.sub + " ");

                                double n1 = ts.GetData(gt);
                                double n0 = ts.GetData(gt.Add(-1));

                                double level1 = n1;
                                double pch1 = ((n1 / n0 - 1) * 100d);

                                if (n1 == n0) pch1 = 0d;

                                string levelFormatted;
                                string pchFormatted;
                                Program.ConvertToPrintFormat(level1, pch1, out levelFormatted, out pchFormatted);

                                G.Write(levelFormatted + " " + pchFormatted + " ");
                                G.Writeln();
                            }
                            int surplus = counter - max;
                            if (!showAllPeriods && surplus > 0)
                            {
                                G.Writeln("------------------------------------------------------------------------------------------");
                                string ps = "period";
                                if (surplus > 1) ps = "periods";
                                G.Write(surplus + " " + ps + " hidden (");
                                G.WriteLink("show", "disp3:" + var);
                                G.Writeln(")");
                            }
                        }
                        G.Writeln("==========================================================================================");
                        G.Writeln();
                    }
                    if (existenceCheck == 0)
                    {
                        if (bnv.bank == null)
                        {
                            G.Writeln2("*** ERROR: Variable '" + bnv.name + "' could not be found");
                            throw new GekkoException();
                        }
                        else
                        {
                            G.Writeln2("*** ERROR: Variable '" + bnv.bank + ":" + bnv.name + "' could not be found");
                            throw new GekkoException();
                        }
                    }
                }
            }
            if (varCounter == 1)
            {
                G.Writeln("Displayed " + varCounter + " variable");
            }
            else
            {
                G.Writeln("Displayed " + varCounter + " variables");
            }
        }


        public static List<string> SplitStringAndKeepDelimiters(string strSplit, char[] arrDelimiters)
        {
            // Start of tokenizing
            // Create a work array where the finished result also will be
            List<string> alWork = new List<string>();
            alWork.Add(strSplit);
            // Temporary variables
            Object[] arrSplitted;
            Char[] arrChar = new Char[1];
            List<string> alTemp = new List<string>();
            // Process each delimiter
            foreach (Char c in arrDelimiters)
            {
                // Clear temp vars
                arrChar[0] = c;
                alTemp.Clear();
                // Process each string
                foreach (String strWork in alWork)
                {
                    // Split it by delimiter
                    arrSplitted = strWork.Split(arrChar, StringSplitOptions.None);
                    if (arrSplitted.Length > 1)
                    {
                        // Split took place, add delimiter between every item
                        for (int n = 0; n < arrSplitted.Length; n++)
                        {
                            alTemp.Add((string)arrSplitted[n]);
                            if (n < arrSplitted.Length - 1)
                            {
                                alTemp.Add(c.ToString());
                            }
                        }
                    }
                    else
                    {
                        // No split took place, use original string
                        alTemp.Add(strWork);
                    }
                }
                // Copy temp array to work array
                // In C++ it would be some nice pointer swapping instead!
                alWork.Clear();
                alWork.AddRange(alTemp);
            }
            return alWork;
        }

        public static List<string> GetVariableExplanation(string var)
        {
            List<string> explanation = new List<string>();
            if (Program.unfoldedVariableList == null) return explanation;
            foreach (Program.Item item in Program.unfoldedVariableList)
            {
                if (G.equal(var, item.variable))
                {
                    explanation = item.explanation;
                }
            }
            return explanation;
        }

        public static void ConvertToPrintFormat(double level1, double pch1, out string levelFormatted, out string pchFormatted)
        {
            levelFormatted = G.levelFormatOld(level1);
            pchFormatted = G.pchFormatOld(pch1);
        }


        public static EEndoOrExo VariableTypeEndoExo(string var)
        {
            EEndoOrExo type = EEndoOrExo.Unknown;
            if (Program.model != null)
            {
                //checks if left-hand var in model. So this ignores exo/endo commands.
                //so the E and X only describes the model equations as they are
                if (Program.model.endogenousOriginallyInModel != null && Program.model.endogenousOriginallyInModel.ContainsKey(var))
                {
                    type = EEndoOrExo.Endo;
                }
                else if (Program.model.varsAType != null && Program.model.varsAType.ContainsKey(var))
                {
                    type = EEndoOrExo.Exo;
                }
            }
            return type;
        }

        public static void Tell(string text, bool nocr)
        {
            if (nocr) G.Write(text);
            else G.Writeln(text);
        }

        public static void Display(string text)
        {
            if (text.EndsWith(";")) text = text.Substring(0, text.Length - 1);  //Should be DISPLAY 'text'; fixing it here
            G.Writeln(text);
        }

        public static void Hdg(string text)
        {
            if (text.EndsWith(";")) text = text.Substring(0, text.Length - 1);  //Should be HDG 'text'; fixing it here
            Program.databanks.GetFirst().info1 = text;
            G.Writeln2("Databank heading for '" + Program.databanks.GetFirst().aliasName + "' databank set to: '" + text + "'");
        }

        public static void Checkoff(List<string> vars2, string type)
        {

            if (type == "clear")
            {
                Globals.checkoff.Clear();
                G.Writeln();
                G.Writeln("CHECKOFF variables cleared");
            }
            else if (type == "?")
            {
                G.Writeln();
                if (Globals.checkoff.Count == 0)
                {
                    G.Writeln();
                    G.Writeln("There are 0 variables not checked for convergence in the Gauss algorithm.");
                }
                else
                {
                    G.Writeln();
                    CheckoffHelper();
                }
            }
            else
            {
                List<string> vars3 = vars2;
                Globals.checkoff.Clear();
                Globals.checkoff.AddRange(vars3);
                G.Writeln();
                CheckoffHelper();
            }
            return;
        }

        private static void CheckoffHelper()
        {
            G.Writeln("The following " + Globals.checkoff.Count + " variables are not checked for convergence in the Gauss algorithm:");
            G.PrintListWithCommas(Globals.checkoff, false);
        }

        public static void Endo(List<string> vars2)
        {
            if (Program.model == null)
            {
                G.Writeln2("*** ERROR: No model is defined for endogenization");
                throw new GekkoException();
            }

            Globals.hasBeenEndoExoStatementsSinceLastSim = 1;

            if (vars2 == null)
            {
                Program.model.endogenized.Clear();
                return;
            }

            //TODO: check that manipulated vars exist in model -- no: model may be re-read etc.

            List<string> vars = vars2;
            //if (vars.Count == 0) Program.model.endogenized.Clear();  //not accumulating anymore
            Program.model.endogenized.Clear();
            foreach (string var in vars)
            {
                if (Program.model.endogenized.ContainsKey(var))
                {
                    G.Writeln2("*** ERROR: " + var + " is already endogenized");
                    throw new GekkoException();
                }
                else Program.model.endogenized.Add(var, "");

            }
            return;
        }

        public static void PrintEndoExoLists()
        {
            G.Writeln();
            if (Program.model == null || Program.model.endogenized == null || Program.model.endogenized.Count == 0) G.Writeln("There are 0 endogenized variables");
            else
            {
                if (Program.model.endogenized.Count == 1) G.Write("There is " + Program.model.endogenized.Count + " endogenized var: ");
                else G.Write("There are " + Program.model.endogenized.Count + " endogenized vars: ");
                List<string> temp1 = new List<string>();
                foreach (string s in Program.model.endogenized.Keys) temp1.Add(s);
                temp1.Sort();
                G.PrintListWithCommas(temp1, false);
            }
            //G.Writeln();
            if (Program.model == null || Program.model.exogenized == null || Program.model.exogenized.Count == 0) G.Writeln("There are 0 exogenized variables");
            else
            {
                if (Program.model.exogenized.Count == 1) G.Write("There is " + Program.model.exogenized.Count + " exogenized var: ");
                else G.Write("There are " + Program.model.exogenized.Count + " exogenized vars: ");
                List<string> temp1 = new List<string>();
                foreach (string s in Program.model.exogenized.Keys) temp1.Add(s);
                temp1.Sort();
                G.PrintListWithCommas(temp1, false);
            }
            G.Writeln();
            return;
        }

        public static void Exo(List<string> vars2)
        {
            //TODO: check that manipulated vars exist in model -- no: model may be re-read etc.
            if (Program.model == null)
            {
                G.Writeln2("*** ERROR: No model is defined for exogenization");
                throw new GekkoException();
            }

            Globals.hasBeenEndoExoStatementsSinceLastSim = 1;

            if (vars2 == null)
            {
                Program.model.exogenized.Clear();
                return;
            }

            List<string> vars = vars2;
            //if (vars.Count == 0) Program.model.exogenized.Clear();  //not accumulating anymore
            Program.model.exogenized.Clear();
            foreach (string var in vars)
            {
                if (Program.model.exogenized.ContainsKey(var))
                {
                    G.Writeln2("*** ERROR: " + var + " is already exogenized");
                    throw new GekkoException();
                }
                else Program.model.exogenized.Add(var, "");
            }
            return;
        }

        public static void Efter(GekkoTime tStart, GekkoTime tEnd)
        {
            //ErrorIfDatabanksSwapped();
            bool SimulateUseCurrentPeriodEndogenousRemember = Program.options.solve_data_init;
            Program.options.solve_data_init = false;
            SimOptions so = new SimOptions();
            so.method = "reverted";
            try
            {
                Program.SimFast(tStart, tEnd, so);
            }
            finally
            {
                //to make sure these are always reset
                Program.options.solve_data_init = SimulateUseCurrentPeriodEndogenousRemember;
            }
        }

        public static bool Help(string s)
        {

            if (s == null)
            {
                s = "I_OVERVIEW";
                //G.WriteDirs("large");
            }
            string s2 = s;

            if (!s2.EndsWith(".htm", StringComparison.OrdinalIgnoreCase)) s2 += ".htm";  //called from command line
            List<string> folders = new List<string>();
            if (Program.options.interface_help_copylocal) folders.Add(Globals.localTempFilesLocation + "\\"); //try here first, the file is copied from the path below (helpful if StartupPath is on a network drive)
            folders.Add(Program.options.folder_help);  //looks here first, will actually before anything else look in working folder (which should not contain any help files)
            folders.Add(Application.StartupPath + "\\helpfiles\\"); //most often and probably best, the helpfiles are found here, tied to the gekko version

            string path = SearchForFile("gekko.chm", folders);  //calls CreateFullPathAndFileName()

            if (path == null)
            {
                G.Writeln();
                G.Writeln("Sorry: could not find the help system file ('gekko.chm').");
                return false;
            }

            try
            {

                System.Windows.Forms.Help.ShowHelp(null, path, s2);  //seems to give the same
                //System.Windows.Forms.Help.ShowHelp(Globals.mFrmDummyHost, path, s2);  //problem if F1 and then HELP tell

            }
            catch (Exception e)
            {
                G.Writeln2("*** ERROR: It seems the help system is blocked -- maybe it is opened in another program?");
                G.Writeln("           file: " + path);
                throw new GekkoException();
            }
            return true;
        }

        public static void Info(GekkoTime tStart, GekkoTime tEnd, List<string> list)
        {
            if (Program.model == null)
            {
                G.Writeln2("*** ERROR: DIP<info> command requires a model -- seems no model is defined");
                throw new GekkoException();
            }
            //GekkoTime tStart, tEnd; ConvertToGekkoTime(tp, out tStart, out tEnd);
            //List<string> unfoldedList = UnfoldLists(list);
            if (!(tStart.super == tEnd.super && tStart.sub == tEnd.sub))
            {
                G.Writeln2("*** ERROR: DISP<info> must be called with identical start and end date");
                throw new GekkoException();
            }
            foreach (string var2 in list)
            {
                Program.PrintEquationVariables(tStart, var2);
            }
        }



        public static void List(string type, string leftSide, List<string> rightSide)
        {
            List(type, leftSide, rightSide, true);
        }

        public static void List(string type, string leftSideInput, List<string> rightSide, bool hasHashSign)
        {
            if (type.StartsWith("?"))
            {
                if (type != "?" && type != "?_show_all_lists")
                {
                    //is a click on a system list: show it in output tab
                    try
                    {
                        string m = type.Substring(2);
                        List<string> a1 = O.GetMetaList(Program.scalars[Globals.symbolList + m]).list;
                        bool showList = true;
                        if (a1.Count > 5000)
                        {
                            DialogResult result = MessageBox.Show("Note: showing lists with more than 5000 items tends to freeze the \noutput tab. You may use \"list listfile " + m + " = #" + m + ";\" to put the list into an\nexternal file " + m + ".lst. \nProceed anyway?", "Show list", MessageBoxButtons.YesNo, MessageBoxIcon.None, MessageBoxDefaultButton.Button2, MessageBoxOptions.DefaultDesktopOnly);
                            if (result != DialogResult.Yes)
                            {
                                showList = false;
                            }
                        }
                        if (showList)
                        {
                            Gui.gui.tabControl1.SelectedTab = Gui.gui.tabPage2;
                            Program.Cls("output");
                            //run in thread ideally
                            foreach (string s in a1)
                            {
                                G.Writeln(s, ETabs.Output);
                            }
                        }
                    }
                    catch
                    {
                        G.Writeln2("*** ERROR: Failed to show list");
                        throw new GekkoException();
                    }
                }
                else
                {
                    bool hasLargeModel = IsLargeModel();
                    List<string> a4 = new List<string>();
                    foreach (KeyValuePair<string, IVariable> kvp in Program.scalars)
                    {
                        if (kvp.Value.Type() == EVariableType.List)
                        {
                            string s = kvp.Key.Substring(1);
                            a4.Add(s);
                        }
                    }

                    a4.Sort(StringComparer.InvariantCultureIgnoreCase);  //invariant is better for sorting than ordinal

                    List<string> user = new List<string>();
                    List<string> system = new List<string>();
                    foreach (string m in a4)
                    {
                        if (
                        G.equal(m, "exod") ||
                        G.equal(m, "exoj") ||
                        G.equal(m, "exoz") ||
                        G.equal(m, "exodjz") ||
                        G.equal(m, "exo") ||
                        G.equal(m, "exotrue") ||
                        G.equal(m, "endo") ||
                        G.equal(m, "all"))
                        {
                            system.Add(m);
                        }
                        else
                        {
                            user.Add(m);
                        }
                    }

                    int count = a4.Count;

                    if (type == "?")
                    {
                        G.Writeln();
                        G.Write("There are " + user.Count + " user lists and " + system.Count + " model lists.");                        
                        if (system.Count > 0)
                        {
                            G.Write(" Click ");
                            G.WriteLink("here", "list:?_show_all_lists");
                            G.Write(" to see model lists.");
                        }
                        G.Writeln();
                        if (user.Count > 0)
                        {
                            foreach (string m in user)
                            {
                                WriteListItems(m);
                            }
                        }
                    }
                    else //must be ?_show_all_lists, because ?_mylist returns above.
                    {
                        if (hasLargeModel) G.Writeln();
                        foreach (string m in system)
                        {
                            if (hasLargeModel)
                            {
                                List<string> a1 = O.GetMetaList(Program.scalars[Globals.symbolList + m]).list;                                
                                G.Write("list #" + m + " = ["); G.WriteLink("show", "list:?_" + m); G.Writeln("]  (" + a1.Count + " elements from '" + a1[0] + "' to '" + a1[a1.Count - 1] + "')");
                                G.Writeln();
                            }
                            else
                            {
                                WriteListItems(m);
                            }
                        }
                    }
                }

            }  //end of if startswith("?")
            else
            {
                string leftSide = leftSideInput;
                if (!hasHashSign) leftSide = "#" + leftSide;  //bit of a hack, at some point "LIST + #xx nm nk" will die anyway
                if (leftSide != "null" && !leftSide.StartsWith("#"))
                {
                    G.Writeln2("*** ERROR regarding list (left side)");
                    throw new GekkoException();
                }
                else leftSide = leftSide.Substring(1);  //removing the first '#'

                if (type == "+")
                {
                    List<string> unfoldedRightSide = rightSide;

                    if (unfoldedRightSide.Count == 1 && G.equal(unfoldedRightSide[0], "null"))
                    {
                        //LIST mylist = null; ---> empty list
                        unfoldedRightSide = new List<string>();
                    }

                    if (leftSideInput == null)
                    {
                        G.Writeln2("*** ERROR: List command failed internally");
                        throw new GekkoException();
                    }
                    else
                    {

                        if (Program.scalars.ContainsKey(Globals.symbolList + leftSide))
                        {
                            Program.scalars.Remove(Globals.symbolList + leftSide);
                        }
                        Program.scalars.Add(Globals.symbolList + leftSide, new MetaList(unfoldedRightSide));
                    }
                }
                else if (type == "-")
                {
                    if (Program.scalars.ContainsKey(Globals.symbolList + leftSide))
                    {
                        Program.scalars.Remove(Globals.symbolList + leftSide);
                        G.Writeln("List #" + leftSide + " removed");
                    }
                    else
                    {
                        G.Writeln2("*** ERROR: list #" + leftSide + " does not exist");
                        throw new GekkoException();
                    }
                }
            }
            return;
        }

        private static bool IsLargeModel()
        {
            bool hasLargeModel = false;
            if (Program.scalars.ContainsKey(Globals.symbolList + "all"))
            {
                if ((O.GetMetaList(Program.scalars[Globals.symbolList + "all"])).list.Count > 100) hasLargeModel = true;  //more then 100 vars --> no printing of model lists here
            }
            return hasLargeModel;
        }

        public static void WriteListItems(string m)
        {
            IVariable iv = null; Program.scalars.TryGetValue(Globals.symbolList + m, out iv);
            if (iv == null)
            {
                G.Writeln2("*** ERROR: List " + Globals.symbolList + m + " was not found");
                throw new GekkoException();
            }
            List<string> a1 = O.GetMetaList(iv).list;

            if (a1.Count == 0)
            {
                G.Writeln2("list #" + m + " = [null]");
            }
            else if(a1.Count < 100)
            {
                G.Writeln2("list #" + m + " = " + G.GetListWithCommas(a1) + "  (" + a1.Count + " elements)");
            }
            else
            {
                G.Write2("list #" + m + " = ["); G.WriteLink("show", "list:?_" + m); G.Writeln("]  (" + a1.Count + " elements from '" + a1[0] + "' to '" + a1[a1.Count - 1] + "')");
            }            
        }

        public static void GuiSetModelName()
        {
            if (Globals.workerThread != null)
            {
                //1.4.9 stuff
                string version = G.PrintVersion(Globals.gekkoVersion, false);
                string s1 = "";
                if (Globals.modelFileName == null || Globals.modelFileName == "")
                {
                    s1 = "Gekko " + version;  //this is what Word etc. does too
                }
                else
                {
                    s1 = Globals.modelFileName + " - " + "Gekko " + version;  //this is what Word etc. does too
                }
                Program.WorkerThreadHelper1 wh = new Program.WorkerThreadHelper1();
                wh.titleField = s1;
                Globals.workerThread.gekkoGui.Invoke(Globals.workerThread.gekkoGui.threadDelegateSetTitle, wh);
            }
        }

        public static void Model(O.Model o)
        {
            string fileName = o.fileName;
            P p = o.p;

            fileName = StripQuotes(fileName);

            //Random random = new Random();
            Globals.modelRandomID = Program.RandomInt(11111111, 99999999);  //used in GetModelInfoPath()

            bool cancel = false;
            if (fileName == "*")
            {
                SelectFile("frm", ref fileName, ref cancel);
                CrossThreadStuff.SetTextInput(fileName, "model");
            }
            if (cancel) return;

            DateTime dt0 = DateTime.Now;

            //fileName = SubstituteAssignVarsInExpression(fileName);
            fileName = AddExtension(fileName, ".frm");

            string fileNameSimple = fileName;

            List<string> folders = new List<string>();
            folders.Add(Program.options.folder_model); //looks here first, after looking in working folder
            fileName = SearchForFile(fileName, folders);  //calls CreateFullPathAndFileName()

            Globals.modelPathAndFileName = fileName;  //always contains a path
            Globals.modelFileName = Path.GetFileName(Globals.modelPathAndFileName);

            if (!File.Exists(fileName))
            {
                G.Writeln2("*** ERROR: Could not find file '" + fileNameSimple + "'.");
                throw new GekkoException();
            }

            string textInputRaw = Program.GetTextFromFileWithWait(fileName);  //textInputRaw is without any VARLIST$
            //TODO: keep the old version, so model command can be undone (like undo sim)
            Program.model = new Model();
            Program.model.modelInfo.fileName = fileName;
            //this also creates Program.model.varlist if there is a varlist

            ModelCommentsHelper modelCommentsHelper = new ModelCommentsHelper();
            string textInput = Program.HandleModelFiles(textInputRaw, modelCommentsHelper);

            string mdlFileNameAndPath = Globals.localTempFilesLocation + "\\" + Globals.gekkoVersion + "_" + modelCommentsHelper.modelHashTrue + ".mdl";
            
            if (Program.options.model_cache == true)
            {
                if (File.Exists(mdlFileNameAndPath))
                {
                    try
                    {                        
                        DateTime dt1 = DateTime.Now;
                        //May take a little time to create: so use static serializer if doing serialize on a lot of small objects
                        //RuntimeTypeModel serializer = TypeModel.Create();
                        //serializer.UseImplicitZeroDefaults = false;  //otherwise an int that has default constructor value -12345 but is set to 0 will reappear as a -12345 (instead of 0). For int, 0 is default, false for bools etc.
                        // ----- DESERIALIZE
                        //DeleteFolder(outputPath);
                        //Directory.CreateDirectory(outputPath);
                        //WaitForZipRead(outputPath, mdlFileNameAndPath);
                        using (FileStream fs = WaitForFileStream(mdlFileNameAndPath, GekkoFileReadOrWrite.Read))
                        {
                            Program.model = Serializer.Deserialize<Model>(fs);
                        }

                        GetListsFromModelListHelper();

                        //=============================================
                        //FOR SAFETY: see mail from TKD 5/3 2013
                        Program.model.simulateResults = new double[10];
                        //=============================================

                        G.WritelnGray("Loaded known model from cache in: " + G.SecondsFormat((DateTime.Now - dt1).TotalMilliseconds));
                        Program.model.modelInfo.loadedFromMdlFile = true;
                        Program.model.modelInfo.fileName = fileName;  //otherwise the filename will be the file used when the cache-file was made (these are often equal of course, but not always).
                    }
                    catch
                    {
                        //do nothing, we then have to parse the file
                        Program.model.modelInfo.loadedFromMdlFile = false;
                    }
                }
            }
            else
            {
                Program.model.modelInfo.loadedFromMdlFile = false;
            }

            Program.model.modelInfo.date = modelCommentsHelper.dateText;
            Program.model.modelInfo.info = modelCommentsHelper.infoText;
            Program.model.signatureStatus = modelCommentsHelper.signatureStatus;
            Program.model.signatureFoundInFileHeader = modelCommentsHelper.signatureFoundInFileHeader;
            Program.model.modelHashTrue = modelCommentsHelper.modelHashTrue;

            string parsingSeconds = null;
            if (Program.model.modelInfo.loadedFromMdlFile)
            {
                //Needs to load lists into Program.list, and varlist too
                GuiSetModelName();
            }
            else
            {
                DateTime t1 = DateTime.Now;
                ParserOLD.EmitModelFromANTLR(textInput, fileName);
                parsingSeconds = G.Seconds(t1);

                ParserOLD.OrderAndCompileModel(ECompiledModelType.Gauss, true, false);  //default.

                try //not the end of world if it fails (should never be done if model is read from zipped protobuffer (would be waste of time))
                {
                    DateTime dt1 = DateTime.Now;

                    PutListsIntoModelListHelper();

                    //May take a little time to create: so use static serializer if doing serialize on a lot of small objects
                    RuntimeTypeModel serializer = TypeModel.Create();
                    serializer.UseImplicitZeroDefaults = false;  //otherwise an int that has default constructor value -12345 but is set to 0 will reappear as a -12345 (instead of 0). For int, 0 is default, false for bools etc.


                    // ----- SERIALIZE
                    //string outputPath = Globals.localTempFilesLocation;
                    //DeleteFolder(outputPath);
                    //Directory.CreateDirectory(outputPath);
                    string protobufFileName = Globals.gekkoVersion + "_" + model.modelHashTrue + ".mdl";
                    string pathAndFilename = Globals.localTempFilesLocation + "\\" + protobufFileName;
                    using (FileStream fs = WaitForFileStream(pathAndFilename, GekkoFileReadOrWrite.Write))
                    {
                        //Serializer.Serialize(fs, m);
                        serializer.Serialize(fs, Program.model);
                    }
                    //Program.WaitForZipWrite(outputPath, Globals.localTempFilesLocation + "\\" + protobufFileName);
                    G.WritelnGray("Created model cache file in " + G.SecondsFormat((DateTime.Now - dt1).TotalMilliseconds));
                }
                catch (Exception e)
                {
                    //do nothing, not the end of the world if it fails
                }
            }

            HandleVarlist(modelCommentsHelper);

            Program.model.modelInfo.timeUsedParsing = parsingSeconds;
            Program.model.modelInfo.timeUsedTotal = G.Seconds(dt0);

            Program.model.modelInfo.Print();
        }

        private static void HandleVarlist(ModelCommentsHelper modelCommentsHelper)
        {
            StringBuilder varList = null;

            string fileNameTemp = null;
            bool foundInFrm = false;
            if (modelCommentsHelper.varlist != null && modelCommentsHelper.varlist.Length > 0)
            {
                foundInFrm = true;
                varList = new StringBuilder(modelCommentsHelper.varlist);
            }
            else
            {
                //try to find it externally, look also in model path!
                List<string> folders = new List<string>();
                folders.Add(Program.options.folder_model);
                fileNameTemp = Program.SearchForFile("varlist.dat", folders);
                if (fileNameTemp != null)
                {
                    string s = Program.GetTextFromFileWithWait(fileNameTemp);  //can read an ANSI file without problems
                    s = "varlist$" + "\n" + s; //a bit hacky, just like the string-StringBuilder-StringReader stuff is convoluted. Anyway, not critical code here.
                    varList = new StringBuilder(s);
                }
            }

            if (varList != null && varList.Length > 0)
            {
                string s = Program.UnfoldVariableList(new StringReader(varList.ToString()));
                if (foundInFrm)
                {
                    if (s != null) s = s + " (found inside .frm file)";
                }
                else
                {
                    if (s != null && fileNameTemp != null) s = s + " (" + fileNameTemp + ")";  //should always be != null, but for safety...
                }
                Program.model.modelInfo.varlistStatus = s;
            }
            else
            {
                Program.model.modelInfo.varlistStatus = "Not found inside .frm file or as 'varlist.dat' file";
            }
        }

        private static void PutListsIntoModelListHelper()
        {
            ModelListHelper modelListHelper = new ModelListHelper();
            if (Program.scalars.ContainsKey(Globals.symbolList + "all")) modelListHelper.all = O.GetMetaList(Program.scalars[Globals.symbolList + "all"]).list;
            if (Program.scalars.ContainsKey(Globals.symbolList + "endo")) modelListHelper.endo = O.GetMetaList(Program.scalars[Globals.symbolList + "endo"]).list;
            if (Program.scalars.ContainsKey(Globals.symbolList + "exo")) modelListHelper.exo = O.GetMetaList(Program.scalars[Globals.symbolList + "exo"]).list;
            if (Program.scalars.ContainsKey(Globals.symbolList + "exod")) modelListHelper.exod = O.GetMetaList(Program.scalars[Globals.symbolList + "exod"]).list;
            if (Program.scalars.ContainsKey(Globals.symbolList + "exodjz")) modelListHelper.exodjz = O.GetMetaList(Program.scalars[Globals.symbolList + "exodjz"]).list;
            if (Program.scalars.ContainsKey(Globals.symbolList + "exoj")) modelListHelper.exoj = O.GetMetaList(Program.scalars[Globals.symbolList + "exoj"]).list;
            if (Program.scalars.ContainsKey(Globals.symbolList + "exotrue")) modelListHelper.exotrue = O.GetMetaList(Program.scalars[Globals.symbolList + "exotrue"]).list;
            if (Program.scalars.ContainsKey(Globals.symbolList + "exoz")) modelListHelper.exoz = O.GetMetaList(Program.scalars[Globals.symbolList + "exoz"]).list;
            Program.model.modelInfo.modelListHelper = modelListHelper;
        }

        private static void GetListsFromModelListHelper()
        {
            string[] lists = new string[] { "all", "endo", "exo", "exod", "exodjz", "exoj", "exotrue", "exoz" };
            foreach (string s in lists)
            {
                if (Program.scalars.ContainsKey(Globals.symbolList + s)) Program.scalars.Remove(Globals.symbolList + s);
            }
            foreach (string s in lists)
            {
                Program.scalars.Add(Globals.symbolList + s, new MetaList(new List<string>()));
            }
            if (Program.model.modelInfo.modelListHelper.all != null) O.GetMetaList(Program.scalars[Globals.symbolList + "all"]).list.AddRange(Program.model.modelInfo.modelListHelper.all);
            if (Program.model.modelInfo.modelListHelper.endo != null) O.GetMetaList(Program.scalars[Globals.symbolList + "endo"]).list.AddRange(Program.model.modelInfo.modelListHelper.endo);
            if (Program.model.modelInfo.modelListHelper.exo != null) O.GetMetaList(Program.scalars[Globals.symbolList + "exo"]).list.AddRange(Program.model.modelInfo.modelListHelper.exo);
            if (Program.model.modelInfo.modelListHelper.exod != null) O.GetMetaList(Program.scalars[Globals.symbolList + "exod"]).list.AddRange(Program.model.modelInfo.modelListHelper.exod);
            if (Program.model.modelInfo.modelListHelper.exodjz != null) O.GetMetaList(Program.scalars[Globals.symbolList + "exodjz"]).list.AddRange(Program.model.modelInfo.modelListHelper.exodjz);
            if (Program.model.modelInfo.modelListHelper.exoj != null) O.GetMetaList(Program.scalars[Globals.symbolList + "exoj"]).list.AddRange(Program.model.modelInfo.modelListHelper.exoj);
            if (Program.model.modelInfo.modelListHelper.exotrue != null) O.GetMetaList(Program.scalars[Globals.symbolList + "exotrue"]).list.AddRange(Program.model.modelInfo.modelListHelper.exotrue);
            if (Program.model.modelInfo.modelListHelper.exoz != null) O.GetMetaList(Program.scalars[Globals.symbolList + "exoz"]).list.AddRange(Program.model.modelInfo.modelListHelper.exoz);
            Program.model.modelInfo.modelListHelper = null;  //only used for temporary transfer of these lists
        }

        public static string AddExtension(string fileName, string ending)
        {
            if (Path.GetExtension(fileName) == "") fileName += ending;  //ignore case
            return fileName;
        }

        public static void Pipe(O.Pipe o)
        {
            //This is where we start when issuing a PIPE
            //We call the older version below, the PIPE interface mess should be cleaned up at some point...
            List<string> temp = new List<string>();
            if (G.equal(o.opt_append, "yes")) temp.Add("append");
            if (G.equal(o.opt_html, "yes")) temp.Add("html");
            if (G.equal(o.opt_pause, "yes")) temp.Add("pause");
            if (G.equal(o.opt_continue, "yes")) temp.Add("continue");
            if (G.equal(o.opt_stop, "yes")) temp.Add("stop");
            Pipe(o.fileName, temp);
        }

        public static void Pipe(string fileName, List<string> args)
        {
            Pipe(fileName, args, false);
        }

        public static void Pipe(string fileName, List<string> args, bool mute)  //mute used for closeall
        {
            bool append = false;
            bool html = false;
            bool stop = false;
            bool pause = false;
            bool continue2 = false;

            if (args != null)
            {
                foreach (string s in args)
                {
                    if (G.equal(s, "append")) append = true;
                    else if (G.equal(s, "html")) html = true;
                    else if (G.equal(s, "stop")) stop = true;
                    else if (G.equal(s, "pause")) pause = true;
                    else if (G.equal(s, "continue")) continue2 = true;
                }
            }

            fileName = StripQuotes(fileName);
            //NOTE: If there is an error, Globals.pipeFile will be closed and disposed somewhere else in the
            //      code. So no need to think about using an "using" statement here.    
            
            if(pause && fileName!=null)
            {
                G.Writeln2("*** ERROR: You should use PIPE<pause> without a filename");
                throw new GekkoException();
            }

            if (continue2 && fileName != null)
            {
                G.Writeln2("*** ERROR: You should use PIPE<continue> without a filename");
                throw new GekkoException();
            }

            if (G.equal(fileName, "con") || stop)   //PIPE con, or PIPE<stop>
            {
                if (Globals.pipe == false)
                {
                    if (!mute) G.Writeln("+++ WARNING: you are not currently piping output to a file. Command ignored.");
                }
                else
                {
                    if (Globals.pipeFileHelper.pipeFile != null)
                    {
                        Globals.pipeFileHelper.CloseFile();
                    }
                    Globals.pipe = false;
                    Globals.pipeFileHelper.pipeFile = null;
                    Globals.pipeFileHelper.pipeFileFileWithPath = "";
                    if (!mute) G.Writeln("Directing output to main window");
                }
            }
            else if(pause)
            {
                //try
                //{
                //    Globals.pipeFileHelper.isPiping = false;
                //}
                //catch { };  //not the end of the world if it fails, for instance if the pipeFileHelper is not there
                Globals.pipe = false;
            }
            else if(continue2)
            {
                //try
                //{
                //    Globals.pipeFileHelper.isPiping = true;
                //}
                //catch { };  //not the end of the world if it fails, for instance if the pipeFileHelper is not there
                Globals.pipe = true;
            }
            else
            {
                //piping to a file

                try
                {
                    fileName = CreateFullPathAndFileNameFromFolder(fileName, Program.options.folder_pipe);

                    if (Globals.pipe == true)
                    {
                        if (G.equal(Globals.pipeFileHelper.pipeFileFileWithPath, fileName))
                        {
                            //already pipe to present pipefile
                            //just ignore it with no message: the message will end up in the pipefile                            
                        }
                        else
                        {
                            if (Globals.pipeFileHelper.pipeFile != null)
                            {
                                Globals.pipeFileHelper.CloseFile();
                            }
                            StartPipingToFile(fileName, append, html, mute);
                        }
                    }
                    else
                    {
                        StartPipingToFile(fileName, append, html, mute);
                    }
                }
                catch (Exception e)
                {
                    Globals.pipe = false;
                    MessageBox.Show("*** ERROR: Could not write to file '" + fileName + "'");
                    throw new GekkoException();
                }
                Globals.pipe = true;

            }
        }

        private static void StartPipingToFile(string fileName, bool append, bool html, bool mute)
        {
            if (!mute && !Globals.pipe) G.Writeln("Directing output to file: '" + fileName + "'");
            Globals.pipe = true;
            GekkoFileReadOrWrite option = GekkoFileReadOrWrite.Write;
            if (append) option = GekkoFileReadOrWrite.WriteAppend;  //will be ok if the file does not exist, then it is just created with no warning issued

            bool mustDeleteFileFirst = false;
            string s1 = null;
            string s2 = null;
            if (html)
            {
                string css = "";
                //a fresh html file is made
                css = GetHtmlHeaderCssStyles();
                s1 = Globals.htmlFileStart1 + css + Globals.htmlFileStart2;
                s2 = Globals.htmlFileEnd;
                if (append && File.Exists(fileName))
                {
                    mustDeleteFileFirst = true;
                    string s = GetTextFromFileWithWait(fileName);
                    if (s.Contains(Globals.htmlGekkoCommentary)) css = "";  //no need to duplicate
                    AddHtmlToExistingHtml(ref s1, ref s2, css, s);
                }
                else
                {
                    //then we will just use the simple empty html, since there is no file to append to.
                    //this behavior is equivalent to txt files.
                }
            }
            if (mustDeleteFileFirst)
            {
                WaitForFileDelete(fileName);
            }
            FileStream fs = WaitForFileStream(fileName, option);
            Globals.pipeFileHelper.pipeFile = G.GekkoStreamWriter(fs);
            Globals.pipeFileHelper.pipeFileTypeIsHtml = html;
            Globals.pipeFileHelper.pipeFileFileWithPath = fileName;
            if (html)
            {
                Globals.pipeFileHelper.pipeFile.Write(s1);  //this is the case if it is a html file, then we write the original content up until the </body> tag
                Globals.pipeFileHelper.htmlEndingTagsStuff = s2;
            }
        }

        private static void AddHtmlToExistingHtml(ref string s1, ref string s2, string css, string s)
        {
            int i = s.IndexOf("</body>", StringComparison.OrdinalIgnoreCase);
            if (i == -1)
            {
                G.Writeln2("*** ERROR: Could not find </body> tag in the html file.");
                throw new GekkoException();
            }
            ChopString(out s1, out s2, s, i);
            //new we have:
            //
            //s1 = <html> <body>
            //s2 = </body> </html>
            //
            //or
            //
            //s1 = <html> <head> </head> <body>
            //s2 = </body> </html>
            int j = s1.IndexOf("</head>", StringComparison.OrdinalIgnoreCase);
            if (j == -1)
            {
                //add a <head>...</head> section with css inside
                int k = s1.IndexOf("<body>", StringComparison.OrdinalIgnoreCase);
                if (k == -1)
                {
                    G.Writeln2("*** ERROR: No <body> tag found in html file");
                    throw new GekkoException();
                }
                string s1a, s1b;
                ChopString(out s1a, out s1b, s1, k);
                s1 = s1a + css + s1b;
            }
            else
            {
                //inject css into existing <head>...</head> section
                //multiple <style> sections are allowed in <head>
                string s1a, s1b;
                ChopString(out s1a, out s1b, s1, j);
                s1 = s1a + css + s1b;
            }
        }

        private static void ChopString(out string s1, out string s2, string s, int i)
        {
            s1 = s.Substring(0, i);
            s2 = s.Substring(i, s.Length - i);
        }

        private static string GetHtmlHeaderCssStyles()
        {
            StringBuilder lines = new StringBuilder();
            lines.AppendLine("<style type=\"text/css\">");
            lines.AppendLine("<!-- " + Globals.htmlGekkoCommentary + " -->");
            lines.AppendLine("  td.w {}");  //lines.AppendLine("  td.w {width:4.5em;}");
            lines.AppendLine("  td.c {text-align: center;}");
            lines.AppendLine("  td.ws {white-space:nowrap;}");
            lines.AppendLine("  td.blue {background-color: rgb(174,199,225);}");
            lines.AppendLine("  td.pad {padding:0.1em 0.50em;}");
            lines.AppendLine("  td.top {border-top: 1px solid black;}");
            lines.AppendLine("  td.bottom {border-bottom: 1px solid black;}");
            lines.AppendLine("  td.left {border-left: 1px solid black;}");
            lines.AppendLine("  td.right {border-right: 1px solid black;}");
            lines.AppendLine("  td.rightlg {border-right: 1px solid lightgray;}");
            lines.AppendLine("  .gfsize {font-size: " + Program.options.table_html_fontsize + "%;}");
            lines.AppendLine("  .gfont { font-family: " + Program.options.table_html_font + " }");
            lines.AppendLine("  a { color: #0645AD; text-decoration: none; }");  //Wikipedia link color
            lines.AppendLine("  a:hover { text-decoration: underline; }");
            lines.AppendLine("</style>");
            string s = lines.ToString();
            return s;
        }

        public static void ConvertPrn(string fileName)
        {
            //Maybe merge better with READ/OPEN/MULBK, so READ<prn> is possible.
            //fileName = Program.SubstituteAssignVarsInExpression(fileName);
            fileName = Program.AddExtension(fileName, "." + "prn");
            List<string> folders = new List<string>();
            string fileNameTemp = Program.SearchForFile(fileName, folders);
            string prnFile = GetTextFromFileWithWait(fileNameTemp);
            List<string> listFile2 = G.ExtractLinesFromText(prnFile);

            if (fileNameTemp.ToLower().EndsWith(".prn"))
            {
                string fileNameCsv = fileNameTemp.Substring(0, fileNameTemp.Length - 4) + ".csv";
                List<string> lines2 = new List<string>();
                bool first = true;
                StringBuilder sb = new StringBuilder();
                foreach (string s in listFile2)
                {
                    if (s.Trim() == "") continue;  //ignore empty lines
                    string[] split = s.Split(new char[] { ' ' }, StringSplitOptions.RemoveEmptyEntries);  //could be variable name with blank such as "ab cd" or something to trim like " abcd", but that is strange/wrong anyway!
                    foreach (string ss in split)
                    {
                        string ss2 = ss.Trim();  //probably superfluous
                        if (ss2.StartsWith("\""))
                        {
                            if (!ss2.EndsWith("\""))
                            {
                                G.Writeln2("*** ERROR: item '" + ss2 + "' seems malformed");
                                throw new GekkoException();
                            }
                            ss2 = ss2.Substring(1, ss2.Length - 2);
                            if (ss2.Contains("\""))
                            {
                                G.Writeln2("*** ERROR: item '\"" + ss2 + "\"' seems malformed");
                                throw new GekkoException();
                            }
                        }
                        string s3 = "";
                        if (first)
                        {
                            if (G.equal(ss2, "date")) s3 = "";  //remove it
                            if (G.equal(ss2, "name")) s3 = "";  //remove it
                        }
                        else s3 = ss2;
                        first = false;
                        sb.Append(s3 + ";");
                    }
                    sb.AppendLine();
                }

                using (FileStream fs = Program.WaitForFileStream(fileNameCsv, Program.GekkoFileReadOrWrite.Write))
                using (StreamWriter sw = G.GekkoStreamWriter(fs))
                {
                    sw.Write(sb);
                    sw.Flush();
                    sw.Close();
                }
                G.Writeln2("Converted PRN file '" + fileNameTemp + "' into");
                G.Writeln("CSV file '" + fileNameCsv + "'.");
                G.Writeln("You may use READ<csv cols> or READ<csv cols merge> to read it.");
            }
            else
            {
                G.Writeln2("*** ERROR: Internal error while converting prn file");
                throw new GekkoException();
            }
        }

        public static string StripQuotes(string s)
        {
            if (s == null) return null;
            if (s.StartsWith("'") && s.EndsWith("'"))
            {
                s = s.Substring(1, s.Length - 2);
            }
            return s;
        }

        private static void ReadHelper(ref string fileName, ref bool cancel, ref bool createOpenFile, string extension, bool isBase, bool open)
        {
            if (fileName == "*")
            {
                SelectFile(extension, ref fileName, ref cancel);
                string type = "open";
                if (!open)
                {
                    type = "read";
                    if (isBase) type = "mulbk";
                }
                CrossThreadStuff.SetTextInput(fileName, type);
            }
            else
            {
                //fileName = SubstituteAssignVarsInExpression(fileName);
                fileName = AddExtension(fileName, "." + extension);
                List<string> folders = new List<string>();
                folders.Add(Program.options.folder_bank);
                folders.Add(Program.options.folder_bank1);
                folders.Add(Program.options.folder_bank2);
                string fileNameTemp = SearchForFile(fileName, folders);

                if (fileNameTemp == null)
                {
                    if (open && extension == "" + Globals.extensionDatabank + "")
                    {
                        createOpenFile = true;
                        fileNameTemp = CreateFullPathAndFileName(fileName);
                        G.Writeln2("Creating new databank file: " + fileNameTemp);
                    }
                    else
                    {

                        FileNotFoundErrorMessage(fileName);

                        if (fileName.ToLower().EndsWith("." + Globals.extensionDatabank + ""))
                        {
                            G.Writeln("           NOTE: the default databank format has been changed from .tsdx to ." + Globals.extensionDatabank + ".");
                            G.Writeln("           You can rename a .tsdx file to ." + Globals.extensionDatabank + ", or use <tsdx> option.");
                            G.Writeln();
                        }

                        throw new GekkoException();
                    }
                }
                else
                {
                    //??
                }
                fileName = fileNameTemp;
            }
        }

        private static string FileNotFoundErrorMessage(string fileName)
        {
            string s = "*** ERROR: Could not read file '" + fileName + "' -- the file does not seem to exist";
            G.Writeln2(s);

            if (Program.options.folder == false)
            {
                G.Writeln("           Please note that 'option folder' is set to false -- so Gekko does not");
                G.Writeln("           search for the file in other folders than the working folder.");
            }
            return s;
        }

        public static string SearchForFile(string fileName, List<string> folders)
        {
            return SearchForFile(fileName, folders, true);
        }

        public static string SearchForFile(string fileName, List<string> folders, bool includeWorkingFolder)
        {
            string fileNameTemp = null;
            string fileNameWorkingFolder = CreateFullPathAndFileName(fileName);
            if (includeWorkingFolder && File.Exists(fileNameWorkingFolder))
            {
                fileNameTemp = fileNameWorkingFolder;
            }
            else
            {
                if (Program.options.folder)
                {
                    //allowed to search in folders
                    foreach (string folder in folders)
                    {
                        //when folder is "", shouldn't it just skip to next? For "", the result will be the working folder...?
                        //as long as working folder is always king, this is not an issue.
                        string fileNameFolder = CreateFullPathAndFileNameFromFolder(fileName, folder);
                        if (File.Exists(fileNameFolder))
                        {
                            fileNameTemp = fileNameFolder;
                            break; //no more searching
                        }
                    }
                }
                else fileNameTemp = null;  //not allowed to search in folders
            }
            return fileNameTemp;
        }

        public static void SelectFile(string type, ref string fileName, ref bool cancel)
        {
            string dataFile = "";
            System.Windows.Forms.OpenFileDialog openFileDialog1 = new System.Windows.Forms.OpenFileDialog();
            openFileDialog1.InitialDirectory = Program.options.folder_working;
            openFileDialog1.Filter = type + " files (*." + type + ")|*." + type + "|All files (*.*)|*.*";
            openFileDialog1.FilterIndex = 1;
            //openFileDialog1.RestoreDirectory = true;
            if (openFileDialog1.ShowDialog() == DialogResult.OK)
            {
                try
                {
                    if ((openFileDialog1.OpenFile()) != null)
                    {
                        dataFile = openFileDialog1.FileName;
                    }
                }
                catch (Exception ex)
                {
                    MessageBox.Show("Error: Could not read file from disk. Original error: " + ex.Message);
                    throw new GekkoException();
                }
            }
            else
            {
                cancel = true;
            }

            if (!cancel)
            {
                if (dataFile == "")
                {
                    G.Writeln2("*** ERROR while reading " + type + " file");
                    throw new GekkoException();
                }
                //string dir = Path.GetDirectoryName(dataFile);
                //string tsdOutputFile = dir + Path.DirectorySeparatorChar + "output.tsd";
                fileName = dataFile;
            }
        }

        public static void Res(O.Res o)
        {
            //ErrorIfDatabanksSwapped();
            Res(o.t1, o.t2);
        }

        public static void Res(GekkoTime tStart, GekkoTime tEnd)
        {
            //remember current values
            bool SimulateUseCurrentPeriodEndogenousRemember = Program.options.solve_data_init;
            int SimulateMaximumIterationsRemember = Program.options.solve_gauss_itermax;
            bool simulateStatic = Program.options.solve_static;
            bool fastGaussRemember = Globals.fastGauss;
            Program.options.solve_data_init = false;
            Program.options.solve_gauss_itermax = 1;
            Program.options.solve_static = true;  //could use so.isStatic instead
            Globals.fastGauss = false;  //never for RES, problem is that prologue and epilogue eqs feed into each other
            SimOptions so = new SimOptions();
            so.method = "res";
            try
            {
                Program.SimFast(tStart, tEnd, so);
            }
            catch (Exception e)
            {
                throw;
            }
            finally
            {
                //revert to old values
                Program.options.solve_data_init = SimulateUseCurrentPeriodEndogenousRemember;
                Program.options.solve_gauss_itermax = SimulateMaximumIterationsRemember;
                Program.options.solve_static = simulateStatic;
                Globals.fastGauss = fastGaussRemember;
            }
        }

        public static void Eigen()
        {
            //Globals.fastGauss = false;  //never for RES, problem is that prologue and epilogue eqs feed into each other
            SimOptions so = new SimOptions();
            so.isEigen = true;
            so.method = "gauss";
            GekkoTime tStart = Globals.globalPeriodStart;
            GekkoTime tEnd = Globals.globalPeriodEnd;
            Program.SimFast(tStart, tEnd, so);
        }

        public static void Trimvars()
        {
            //ErrorIfDatabanksSwapped();
            if (Program.model == null)
            {
                G.Writeln2("*** ERROR: No model is defined for trimming, cf. MODEL command.");
                throw new GekkoException();
            }

            List<Databank> banks = new List<Databank> { Program.databanks.GetFirst(), Program.databanks.GetRef() };

            G.Writeln();
            foreach (Databank bank in banks)
            {
                List<string> onlyDatabankNotModel = new List<string>();
                foreach (string s in bank.storage.Keys)
                {
                    if (G.GetFreqFromKey(s) != Program.options.freq) continue;  //filter out other freqs
                    string s2 = G.RemoveFreqFromKey(s);
                    if (!Program.model.varsAType.ContainsKey(s2))
                    {
                        onlyDatabankNotModel.Add(s2);
                    }
                }

                foreach (string s in onlyDatabankNotModel)
                {
                    if (bank.ContainsVariable(s))
                    {
                        bank.RemoveVariable(s);
                    }
                }
                G.Writeln2("Removed " + onlyDatabankNotModel.Count + " variable(s) in '" + bank.aliasName + "' databank");
            }
        }

        public static void FindMissingData(O.Findmissingdata o)
        {
            GekkoTime tStart = o.t1;
            GekkoTime tEnd = o.t2;
            List<string> vars= o.listItems;

            //GekkoTime tStart, tEnd; ConvertToGekkoTime(tp, out tStart, out tEnd);

            //vars = UnfoldLists(vars);

            bool replace = true;
            if (double.IsNaN(o.opt_replace)) replace = false;

            bool hasFilter = false;
            bool hasModel = false;

            Databank work = Program.databanks.GetFirst();

            Dictionary<string, string> exod = null;
            Dictionary<string, string> exoj = null;
            Dictionary<string, string> exoz = null;
            Dictionary<string, string> exodjz = null;
            Dictionary<string, string> exo = null;
            Dictionary<string, string> exotrue = null;
            Dictionary<string, string> endo = null;
            Dictionary<string, string> all = null;

            if (!replace)
            {
                exod = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
                exoj = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
                exoz = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
                exodjz = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
                exo = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
                exotrue = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
                endo = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
                all = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
            }

            if (Program.model == null || replace)
            {
            }
            else
            {
                hasModel = true;
                try
                {
                    foreach (string s in O.GetMetaList(Program.scalars[Globals.symbolList + "exod"]).list)
                        exod.Add(s, "");
                    foreach (string s in O.GetMetaList(Program.scalars[Globals.symbolList + "exoj"]).list)
                        exoj.Add(s, "");
                    foreach (string s in O.GetMetaList(Program.scalars[Globals.symbolList + "exoz"]).list)
                        exoz.Add(s, "");
                    foreach (string s in O.GetMetaList(Program.scalars[Globals.symbolList + "exodjz"]).list)
                        exodjz.Add(s, "");
                    foreach (string s in O.GetMetaList(Program.scalars[Globals.symbolList + "exo"]).list)
                        exo.Add(s, "");
                    foreach (string s in O.GetMetaList(Program.scalars[Globals.symbolList + "exotrue"]).list)
                        exotrue.Add(s, "");
                    foreach (string s in O.GetMetaList(Program.scalars[Globals.symbolList + "endo"]).list)
                        endo.Add(s, "");
                    foreach (string s in O.GetMetaList(Program.scalars[Globals.symbolList + "all"]).list)
                        all.Add(s, "");
                }
                catch { };  //if error, we just ignore it, and the list will be empty.
            }

            Dictionary<string, string> filter = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);

            //exod
            //exoj
            //exoz
            //exodjz
            //exo
            //exotrue
            //endo
            //all
            //work

            List<string> missing_exod = null;
            List<string> missing_exoj = null;
            List<string> missing_exoz = null;
            List<string> missing_exodjz = null;
            List<string> missing_exo = null;
            List<string> missing_exotrue = null;
            List<string> missing_endo = null;
            List<string> missing_all = null;
            List<string> missing_ = null;

            if (!replace)
            {
                missing_exod = new List<string>();
                missing_exoj = new List<string>();
                missing_exoz = new List<string>();
                missing_exodjz = new List<string>();
                missing_exo = new List<string>();
                missing_exotrue = new List<string>();
                missing_endo = new List<string>();
                missing_all = new List<string>();  //every variable in model
                missing_ = new List<string>();   //every model i work databank (this typically includes the "all" set, because the READ statement auto-creates model variables if they are not in the databank)
            }

            if (vars != null)  //if filter is set
            {
                hasFilter = true;
                foreach (string s in vars)
                {
                    filter.Add(s, "");  //we are just using the keys, not values, therefore ""
                }
            }

            //all variables in work databank
            foreach (string ss in work.storage.Keys)
            {                
                if (G.GetFreqFromKey(ss) != Program.options.freq) continue;  //we filter out other freqs
                string s = G.RemoveFreqFromKey(ss);
                if (hasFilter)
                {
                    if (!filter.ContainsKey(s)) continue;  //ignore this
                }
                TimeSeries ts = work.GetVariable(s);  //can this not be moved before loop??
                if (ts.IsGhost()) continue;  //ignore it
                foreach (GekkoTime t in new GekkoTimeIterator(tStart, tEnd))
                {                    
                    double value = ts.GetData(t);
                    if (G.isNumericalError(value))
                    {
                        if (replace)
                        {
                            ts.SetData(t, o.opt_replace);
                        }
                        else
                        {
                            missing_.Add(s);  //always put it in this list
                            if (exod.ContainsKey(s)) missing_exod.Add(s);
                            if (exoj.ContainsKey(s)) missing_exoj.Add(s);
                            if (exoz.ContainsKey(s)) missing_exoz.Add(s);
                            if (exodjz.ContainsKey(s)) missing_exodjz.Add(s);
                            if (exo.ContainsKey(s)) missing_exo.Add(s);
                            if (exotrue.ContainsKey(s)) missing_exotrue.Add(s);
                            if (endo.ContainsKey(s)) missing_endo.Add(s);
                            if (all.ContainsKey(s)) missing_all.Add(s);
                            break;  //one is enough
                        }
                    }
                }
            }

            if (!replace)
            {

                Dictionary<string, List<string>> names = new Dictionary<string, List<string>>(StringComparer.OrdinalIgnoreCase);
                names.Add("missingdata_", missing_);  //this one is a bit special
                names.Add("missingdata_exod", missing_exod);
                names.Add("missingdata_exoj", missing_exoj);
                names.Add("missingdata_exoz", missing_exoz);
                names.Add("missingdata_exodjz", missing_exodjz);
                names.Add("missingdata_exo", missing_exo);
                names.Add("missingdata_exotrue", missing_exotrue);
                names.Add("missingdata_endo", missing_endo);
                names.Add("missingdata_all", missing_all);

                List<string> names2 = new List<string>();
                names2.Add("missingdata_");
                if (hasModel)
                {
                    names2.Add("missingdata_all");
                    names2.Add("missingdata_endo");
                    names2.Add("missingdata_exotrue");
                    names2.Add("missingdata_exo");
                    names2.Add("missingdata_exodjz");
                    names2.Add("missingdata_exod");
                    names2.Add("missingdata_exoj");
                    names2.Add("missingdata_exoz");
                }

                G.Writeln();
                G.Writeln("------------------------ Report: Find missing data -------------------------------");
                G.Writeln();
                if (Program.model == null)
                {
                    G.Writeln();
                    G.Writeln("No model seems to be loaded -- result cannot be split into exogenous, endogenous etc. variables");
                    G.Writeln();
                }

                foreach (string n2 in names2)
                {
                    List<string> list = names[n2];
                    string listname = n2;
                    if (listname == "missingdata_") listname = "missingdata";

                    if (true)
                    {
                        if (Program.scalars.ContainsKey(Globals.symbolList+ listname))
                        {
                            Program.scalars.Remove(Globals.symbolList + listname);
                        }
                        list.Sort();
                        Program.scalars.Add(Globals.symbolList + listname, new MetaList(list));
                        if (list.Count > 0)
                        {
                            string v = "variables";
                            if (list.Count == 1) v = "variable";
                            G.Writeln("List #" + listname + " has " + list.Count + " " + v + ":");
                            G.PrintListWithCommas(list, false);
                            G.Writeln();
                        }
                        else
                        {
                            G.Writeln("List #" + listname + " is empty");
                            G.Writeln();
                        }
                    }
                }
                G.Writeln("------------------------ Report end ----------------------------------------------");
                G.Writeln();
                G.Writeln();
            }
        }

        public static bool IsStacked()
        {
            return G.equal(Program.options.solve_forward_method, "stacked");
        }        

        public static void Sim(O.Sim o)
        {
            if (Program.model != null && Program.model.subPeriods != -12345 && Program.model.subPeriods != O.CurrentSubperiods())
            {
                G.Writeln2("*** ERROR: The model was not compiled/loaded with the current frequency");
                G.Writeln("    This applies to the pchy(), dify(), diffy(), dlogy() functions. Please put");
                G.Writeln("    the MODEL statement after your 'OPTION freq ... ' statement.");
                throw new GekkoException();
            }

            if (G.equal(o.opt_after, "yes"))
            {
                Program.Efter(o.t1, o.t2);
                return;
            }
            else if (G.equal(o.opt_res, "yes"))
            {
                Program.Res(o.t1, o.t2);
                return;
            }


            //New entry to SIM
            //ErrorIfDatabanksSwapped();
            if (Program.model == null)
            {
                G.Writeln2("*** ERROR: No model seems to be defined (see MODEL statement)");
                throw new GekkoException();
            }
            if (!G.IsUnitTesting()) Gekko.Gui.gui.textBox1.SuspendLayout();
            SimOptions so = new SimOptions();
            so.method = Program.options.solve_method;
            if (G.equal(o.opt_fix, "yes")) so.isFix = true;

            so.isStatic = GetYesNoNullLocalOption(o.opt_static);  //works faster as an enumeration

            {
                Program.SimFast(o.t1, o.t2, so);
            }


            if (!G.IsUnitTesting()) Gekko.Gui.gui.textBox1.ResumeLayout();
        }

        //See #98745239543
        private static YesNoNull GetYesNoNullLocalOption(string opt)
        {
            YesNoNull rv = YesNoNull.Null;
            if (opt == null) rv = YesNoNull.Null;
            else if (G.equal(opt, "yes")) rv = YesNoNull.Yes;
            else if (G.equal(opt, "no")) rv = YesNoNull.No;
            else
            {
                G.Writeln2("*** ERROR: Expected 'yes' or 'no', not '" + opt + "'");
                throw new GekkoException();
            }
            return rv;
        }


        public static void Itershow(List<string> vars, GekkoTime t1, GekkoTime t2)
        {
            if (Program.model == null)
            {
                G.Writeln2("*** ERROR: No model seems to be defined, see MODEL command.");
                throw new GekkoException();
            }

            //List<string> vars = UnfoldLists(varsInput);

            bool hasContent = false;

            //GekkoTime t1, t2; ConvertToGekkoTime(time, out t1, out t2);

            Table tab = new Table();
            int row = 1;

            List<string> problems = new List<string>();

            foreach (string var in vars)
            {
                bool hasDifference = false;
                foreach (GekkoTime t in new GekkoTimeIterator( t1, t2))
                {
                    int rowYearStart = row;
                    List<IterMemory> iterMemories = null;
                    if (Program.model.bMemory.ContainsKey(t.ToString()))
                    {
                        iterMemories = Program.model.bMemory[t.ToString()];
                    }
                    else
                    {
                        G.Writeln("There were no recorded iterations in memory regarding period " + t.ToString());
                        continue;
                    }

                    hasContent = true;

                    tab.Set(row, 1, t.ToString());
                    tab.Set(row, 2, G.GetUpperLowerCase(var));
                    row++;
                    tab.Set(row, 1, "Iter");
                    tab.Set(row, 2, "Before");
                    tab.Set(row, 3, "After");
                    tab.Set(row, 4, "Hist. var");
                    tab.Set(row, 5, "Difference");
                    tab.Set(row, 6, "Relative1");
                    tab.Set(row, 7, "Relative2");
                    tab.SetAlign(row, 1, row, 7, Align.Right);
                    tab.SetBorder(row, 1, row, 7, BorderType.Top);
                    tab.SetBorder(row, 1, row, 7, BorderType.Bottom);

                    for (int it = 0; it < iterMemories.Count; it++)
                    {
                        IterMemory iterMemory = iterMemories[it];
                        double[] bBefore = iterMemory.bBefore;
                        double[] bAfter = iterMemory.bAfter;

                        EquationHelper found = Program.FindEquationByMeansOfVariableName(var);
                        if (found == null)
                        {
                            G.Writeln();
                            G.Writeln2("*** ERROR: ITERSHOW: Variable " + var + " is not endogenous");
                            throw new GekkoException();
                        }
                        int i = found.bNumberLhs;
                        //G.Writeln("per " + t.ToString() + " it " + it + " bef " + bBefore[i] + " aft " + bAfter[i]);
                        row++;
                        double bOld = bBefore[i];
                        double b = bAfter[i];
                        double bVariance = model.bVariance[i];

                        tab.Set(new Coord(row, 1), "", it + 1, CellType.Number, "f6.0");
                        tab.Set(new Coord(row, 2), "", bOld, CellType.Number, "f13.4");
                        tab.Set(new Coord(row, 3), "", b, CellType.Number, "f13.4");
                        tab.Set(new Coord(row, 4), "", bVariance, CellType.Number, "f13.4");

                        double abs = (b - bOld);
                        double rel = (abs / bOld);
                        double relHist = (abs / bVariance);

                        if (abs != 0d) hasDifference = true;

                        tab.Set(new Coord(row, 5), "", abs, CellType.Number, "f15.6");
                        tab.Set(new Coord(row, 6), "", relHist, CellType.Number, "f12.6");
                        tab.Set(new Coord(row, 7), "", rel, CellType.Number, "f12.6");
                    }
                    tab.SetBorder(row, 1, row, 7, BorderType.Bottom);
                    tab.SetBorder(rowYearStart + 1, 1, row, 1, BorderType.Left);
                    tab.SetBorder(rowYearStart + 1, 7, row, 7, BorderType.Right);
                    row++;
                    row++;

                }//time loop
                if (!hasDifference) problems.Add(var);
            }
            if (hasContent)
            {
                Program.PrintTable(tab, false, null);
                if (problems.Count > 0)
                {
                    G.Writeln();
                    foreach (string s in problems)
                    {
                        G.Writeln("+++ NOTE: Variable '" + s + "' might be part of the prologue or epilogue, and if so it does not change during Gauss iterations. Regarding ordering, see the [model]__info.zip file, inside [model].ordering.");
                    }
                }
                G.Writeln("+++ NOTE: Damped variables have stricter convergence crits than non-damped.");
            }
            else
            {
                G.Writeln();
                G.Writeln("It seems there was no results stored regarding iterations: did you remember to set 'OPTION solve gauss dump = yes' before simulation?");
            }
        }

        private static void JacobiNull()
        {
            Program.model.jacobiMatrix = null;
            Program.model.jacobiMatrixDense = null;
            //Program.model.jacobiMatrixInverted = null;  //we actually prefer to reuse this -- costly to new[] it for each fast step (it is often > 10.000 doubles)
            Program.model.jacobiMatrixInvertedIndex = null;
        }

        public static double Lead(double[] b, int i)
        {
            //int x = Program.model.m2.fromBNumberToEqNumber[i];
            //BTypeData data = null; model.varsBType.TryGetValue("y" + Globals.lagIndicator + "1", out data);
            //Program.model.m2.from
            //G.Writeln(x);

            double v = double.NaN;

            int type = 1;  //0 "exo" or "forward method none", 1 const, 2 growth

            if (Program.model.simulateResults[8] == 0d)
            {
                v = b[i];
            }
            else if (Program.model.simulateResults[8] == 1d)  //#375204390457
            {
                if (Program.model.terminalHelper == null)
                {
                    //This will switch off the smart terminal stuff, and perforn NFT
                    //just like in the old days.
                    //That typically means a lot of more iterations for terminal CONST,
                    //whereas terminal EXO is not affected.
                    v = b[i];  //use the normal one
                }
                else
                {
                    int distance = (int)Program.model.simulateResults[7];
                    int newI = -12345;

                    if (Program.model.terminalHelper.Count > distance)
                    {
                        Program.model.terminalHelper[distance].TryGetValue(i, out newI);
                    }

                    if (newI != -12345)
                    {
                        //found pointing to a period outside sim period, so we use another b[i]
                        v = b[newI];
                        //G.Writeln("used b[" + newI + "] " + b[newI] + " instead of real lead b[" + i + "] " + b[i] + ", distance " + distance);
                    }
                    else
                    {
                        //just use the normal one
                        v = b[i];
                    }
                }
            }
            else if (Program.model.simulateResults[8] == 2d)
            {
                G.Writeln2("*** ERROR: terminal 'growth' does not work at the moment");
                throw new GekkoException();
            }
            else throw new GekkoException();
            return v;
        }

        public static void SimFast(GekkoTime tStart, GekkoTime tEnd, SimOptions so)
        {
            if (GekkoTime.Observations(tStart, tEnd) < 1)
            {
                G.Writeln2("*** ERROR: start period must be before end period");
                throw new GekkoException();
            }

            Globals.simCounter = 0;
            //ErrorIfDatabanksSwapped();
            if (Program.model == null)
            {
                G.Writeln2("*** ERROR: It seems no model is defined -- simulation cannot be performed");
                throw new GekkoException();
            }

            HandleTerminalHelper();

            bool hasEndoExo = false; if (Program.model.endogenized.Count != 0 || Program.model.exogenized.Count != 0) hasEndoExo = true;

            DateTime startTime = DateTime.Now;
            DateTime dtFt = DateTime.Now;

            bool usingFairTaylor = false;
            bool usingNewtonFairTaylor = false;
            if (model.largestLead > 0)
            {
                if (G.equal(Program.options.solve_forward_method, "fair")) usingFairTaylor = true;
                if (G.equal(Program.options.solve_forward_method, "nfair")) usingNewtonFairTaylor = true;
                if ((usingFairTaylor || usingNewtonFairTaylor) && G.equal(Program.options.solve_forward_terminal, "growth"))
                {
                    //#375204390457
                    G.Writeln2("*** ERROR: Terminal 'GROWTH' is not working at the moment, please use 'CONST'");
                    throw new GekkoException();
                }
            }

            if (G.equal(Program.options.solve_forward_method, "stacked"))
            {
                G.Writeln2("*** ERROR: 'forward method = stacked' is not working -- please use 'forward method = nfair' instead");
                throw new GekkoException();

                if (GekkoTime.Observations(tStart, tEnd) > Program.options.solve_forward_stacked_horizon)
                {
                    usingFairTaylor = true;
                    G.Writeln2("Since there are more observations (" + GekkoTime.Observations(tStart, tEnd) + ") than the horizon (" + Program.options.solve_forward_stacked_horizon + "), Fair-Taylor is used together with stacked time");
                }
                else if (GekkoTime.Observations(tStart, tEnd) < Program.options.solve_forward_stacked_horizon)
                {
                    G.Writeln2("*** ERROR: There are fewer observations (" + GekkoTime.Observations(tStart, tEnd) + ") than the horizon (" + Program.options.solve_forward_stacked_horizon + ")");
                    throw new GekkoException();
                }
            }

            List<string> outputText = new List<string>();

            bool debug = false;
            G.Writeln();

            bool hasIssuedSeedWarning = false;
            double simTime = 0d;
            //bool hasBeenAutoSetToNewton = false;
            double[] bCheck = null;  //for safety check

            Dictionary<int, int> checkoff = new Dictionary<int, int>();
            if (Program.options.solve_gauss_conv_ignorevars == true)
            {
                foreach (string var in Globals.checkoff)
                {
                    //slack: use .TryGetValue()
                    if (model.varsBType.ContainsKey(var + Globals.lagIndicator + "0"))
                    {
                        int bNumber = model.varsBType[var + Globals.lagIndicator + "0"].bNumber;
                        if (!checkoff.ContainsKey(bNumber)) checkoff.Add(bNumber, 0);
                    }
                }
            }

            if (!(G.equal(so.method, "gauss") || G.equal(so.method, "newton") || G.equal(so.method, "res") || G.equal(so.method, "reverted") || G.equal(so.method, "eigen"))) G.Writeln("+++ WARNING: Seems to be a problem with model type");
            //isRes is true if called by Res(), isReverted if called by Efter()

            ErrorContainer ec = new ErrorContainer();

            ECompiledModelType modelType = GetModelTypeFromOptions(so);  //6 types, including Reverted (for EFTER command)

            //only used with ANTLR
            if (Program.model == null || Program.model.equations.Count == 0)
            {
                G.Writeln2("*** ERROR: It seems no model is defined: did you forget a MODEL statement?");
                throw new GekkoException();
            }
            Globals.mayPrintConvergenceCheckVariableMissing = true;  //so that there is only 1 warning regarding this
            if (Program.model.endogenized.Count != Program.model.exogenized.Count)
            {
                G.Writeln2("*** ERROR: different number of endogenized/exogenized variables (endo = " + Program.model.endogenized.Count + ", exo = " + Program.model.exogenized.Count + ")");
                throw new GekkoException();
            }

            Program.model.jacobiMatrix = null;
            Program.model.jacobiMatrixInverted = null;
            Program.model.jacobiMatrixInvertedIndex = null;

            //TODO Cleanup: at some point clean up this, using the RAM cache idea more directly
            //if (Globals.hasBeenEndoExoStatementsSinceLastSim == 1)
            if (so.isFix)
            {
                if (hasEndoExo && !G.equal(so.method, "newton"))
                {
                    //G.Writeln("+++ NOTE: SIM uses Newton method when ENDO/EXO vars are set.");
                    //hasBeenAutoSetToNewton = true;
                    so.method = "newton";
                    modelType = GetModelTypeFromOptions(so);  //5 types
                }
                ParserOLD.OrderAndCompileModel(modelType, false, so.isFix);
            }
            else
            {
                //Compiles model if it is not already compiled
                //If sim is called several times for same sim options (e.g. Gauss), model will only be
                //compiled first time.
                //It is necessary to do compilation here, because there are some by-products from
                //this, specifically Program.model.endogenous (the model's endogenous). These are used below
                //in endoPointers etc.

                if (modelType != ECompiledModelType.After)
                {
                    Type assembly = GetAssemblyFromModelType(modelType);
                    if (assembly == null)
                    {
                        ParserOLD.OrderAndCompileModel(modelType, false, so.isFix);
                        assembly = GetAssemblyFromModelType(modelType);
                        if (assembly == null)
                        {
                            G.Writeln2("*** ERROR: Sorry: something has gone wrong regarding model settings");
                            throw new GekkoException();
                        }
                    }
                }
                else
                {
                    ParserOLD.OrderAndCompileModel(ECompiledModelType.After, false, so.isFix);
                }
            }
            //TODO Cleanup end

            if (CheckYesNoNullLogic(so.isStatic, Program.options.solve_static))
            {
                Globals.undoBank = new Databank("UndoBank");
                G.CloneDatabank(Globals.undoBank, Program.databanks.GetFirst());
            }

            if (Program.options.solve_gauss_dump)
            {
                Program.model.bMemory = null;
                GC.Collect();
                Program.model.bMemory = new GekkoDictionary<string, List<IterMemory>>(StringComparer.OrdinalIgnoreCase);
            }

            Program.model.simulateResults = new double[10];  //fix

            Databank work = Program.databanks.GetFirst();
            TimeSeries[] timeSeriesPointers = new TimeSeries[Program.model.varsBType.Count];
            int[] extraWritebackPointers = new int[Program.model.varsBType.Count]; //will probably become obsolete at some point
            int[] revertedPointers = new int[Program.model.varsBType.Count];
            int[] lagPointers = new int[Program.model.varsBType.Count];
            int[] aNumberPointers = new int[Program.model.varsBType.Count];
            int[] bNumberPointers = new int[Program.model.varsAType.Count];  //get from an a-number to equivalent b-number (with no lag)
            for (int i = 0; i < bNumberPointers.Length; i++)
            {
                bNumberPointers[i] = -12345;  //init for safety
            }
            int[] endoNoLagPointers = new int[Program.model.varsBType.Count];
            int[] endoLeadPointers = new int[Program.model.varsBType.Count];
            int[] endoPointers = new int[Program.model.varsBType.Count];
            string[] varNamePointers = new string[Program.model.varsBType.Count];  //has dublets, a var and a lagged var just has the name here
            int[] isDJZvarPointers = new int[Program.model.varsBType.Count];
            List<int> isDampedPointers = new List<int>();
            int[] isDampedPointersArray = new int[Program.model.varsBType.Count];
            int i1 = 0;

            foreach (BTypeData value in Program.model.varsBType.Values)
            {

                if (IsDjz(value.variable))
                {
                    isDJZvarPointers[value.bNumber] = 1;
                }
                varNamePointers[value.bNumber] = value.variable;
                //TODO: should make a check here that all slots are filled in from b[min] to b[max]
                TimeSeries ts = work.GetVariable(value.variable);  //may be null
                timeSeriesPointers[value.bNumber] = ts;
                lagPointers[value.bNumber] = value.lag;
                aNumberPointers[value.bNumber] = value.aNumber;

                if (value.lag == 0)
                {
                    bNumberPointers[value.aNumber] = value.bNumber;  //used for Fair-Taylor convergence check
                }

                if (Program.model.m2.endogenous.ContainsKey(value.variable))
                {
                    if (value.lag == 0)
                    {
                        endoNoLagPointers[value.bNumber] = 1;
                    }
                    else if (value.lag > 0)
                    {
                        endoLeadPointers[value.bNumber] = 1;
                    }
                    endoPointers[value.bNumber] = 1;
                }

                if (value.lag == 0 && Program.model.reverted.ContainsKey(value.variable))
                {
                    revertedPointers[value.bNumber] = 1;
                }
                //for now, we ignore what the value may be (all damping is with same factor)
                if (model.dampVariables.ContainsKey(value.variable + Globals.lagIndicator + value.lag))  //with lag indicator
                {
                    isDampedPointers.Add(value.bNumber);
                    isDampedPointersArray[value.bNumber] = 1;
                }
                i1++;
            }

            model.b = new double[Program.model.varsBType.Count];
            model.bVariance = new double[Program.model.varsBType.Count];
            model.bOld = new double[Program.model.varsBType.Count];  //used in simulation, to store previous iteration
            for (int i = 0; i < model.varsBType.Count; i++)
            {
                //just for safety, so an error would be found quickly if something gets messed up in referencing these arrays
                model.b[i] = double.NaN;
                model.bVariance[i] = double.NaN;
                model.bOld[i] = double.NaN;
            }

            int number = GekkoTime.Observations(tStart, tEnd);
            double[] temp = new double[number];

            Program.CreateEndoNoLagBNumbers(endoNoLagPointers);

            for (int i = 0; i < Program.model.b.Length; i++)
            {
                Program.model.bVariance[i] = double.NaN;
            }

            Program.CreateBVariance(timeSeriesPointers, tStart.Add(-1));

            int largestLag = -2;  //to get some lagged data into a[] array, for use with initializing endo variables etc.
            if (model.largestLag > 2) largestLag = -model.largestLag;

            GekkoTime tStart0 = tStart.Add(largestLag);

            GekkoTime tEnd_withRE = tEnd.Add(model.largestLead);

            int horizon2 = 0;
            if (IsStacked())
            {
                horizon2 = Program.options.solve_forward_stacked_horizon - 1;
                tEnd_withRE = tEnd_withRE.Add(horizon2);  //horizon2=0 is the same as normal newton
            }

            //DateTime dt1 = DateTime.Now;
            //G.Writeln("Code up to a[] load: used " + (dt1 - startTime).TotalMilliseconds / 1000d);

            //This will throw errors, if a variable is missing, or an exo or lagged endo has missing values
            //Runs pretty fast -- does not hamper simulation speed noticably
            //The nice thing is that full lists of missing stuff are done
            SimCheckFirstPeriodForMissingStuff(usingFairTaylor || usingNewtonFairTaylor, tStart, ec, timeSeriesPointers, lagPointers, endoNoLagPointers, endoLeadPointers, varNamePointers, isDJZvarPointers);

            int obsWithLagsIncludingLeadsAtEnd = GekkoTime.Observations(tStart0, tEnd_withRE);
            int obsSimPeriodIncludingLeadsAtEnd = GekkoTime.Observations(tStart, tEnd_withRE);
            int obsWithLags = GekkoTime.Observations(tStart0, tEnd);
            int obsSimPeriod = GekkoTime.Observations(tStart, tEnd);
            int vars = Program.model.varsAType.Count; //FIX: plus minus 1??
            //GC.Collect();
            double[,] a = new double[vars, obsWithLagsIncludingLeadsAtEnd]; //these zeroes will be overwritten with data or NaN.
            double[] NAN = new double[obsWithLagsIncludingLeadsAtEnd];
            for (int i = 0; i < NAN.Length; i++) NAN[i] = double.NaN;
            FillAWithNaN(vars, a, NAN);  //small speed penalty, but better safe (NaN) than sorry (0d)

            FromDatabankToA(tStart0, tEnd_withRE, work, obsWithLagsIncludingLeadsAtEnd, a, NAN);

            //if (debug && Globals.runningOnTTComputer) G.Writeln("a[] load: " + (DateTime.Now - dt1).TotalMilliseconds / 1000d, Color.LightGray);

            double ms1 = 0d;
            double ms2 = 0d;

            StringBuilder output = new StringBuilder();
            output.AppendLine("This is detailed output regarding the simulation, ie. the output");
            output.AppendLine("that is shown if 'OPTION solve print iter = yes'.");
            output.AppendLine();

            //do a RE loop here, checking only variables with leads.
            //maybe for each outer iteration print iteration # etc.
            //maybe use simulated values as init for endogenous variables
            //for all re-iterations except the first.

            //double[,] ftVarsOld = null;

            List<int> leadedVarsList = new List<int>();
            ETerminalCondition terminal = ETerminalCondition.Exogenous;
            if (G.equal(Program.options.solve_forward_terminal, "exo")) terminal = ETerminalCondition.Exogenous;
            else if (G.equal(Program.options.solve_forward_terminal, "const")) terminal = ETerminalCondition.ConstantLevel;
            else if (G.equal(Program.options.solve_forward_terminal, "growth")) terminal = ETerminalCondition.ConstantGrowthRate;
            int ftMax = 1;
            int ftMin = 1;

            if (usingFairTaylor || usingNewtonFairTaylor)
            {
                if (usingFairTaylor)
                {
                    ftMax = Program.options.solve_forward_fair_itermax;
                    ftMin = Program.options.solve_forward_fair_itermin;
                }
                else if (usingNewtonFairTaylor)
                {
                    //ftMax = Program.options.solve_forward_nfair_itermax;
                    ftMax = Program.options.solve_forward_nfair_itermax;
                    ftMin = Program.options.solve_forward_nfair_itermin;
                }
                else throw new GekkoException();

                foreach (int leadVar in model.leadedVariables.Keys)
                {
                    //if (Program.model.m2.endogenous.ContainsKey(leadVar)) ... go from bnumber to varname #980734323
                    leadedVarsList.Add(leadVar);
                }
                G.Writeln("+++ NOTE: There are " + model.leadedVariables.Count + " variable(s) with leads: Fair-Taylor algorithm is used");
            }

            double[,] oldNftJacobi = null;

            for (int ft = 0; ft < ftMax; ft++)
            {
                if (Program.options.solve_print_details && Globals.runningOnTTComputer)
                {
                    G.Writeln("");
                    G.Writeln("NEW FAIR TAYLOR ITERATION", Color.Red);
                    G.Writeln("");
                }

                if (usingFairTaylor || usingNewtonFairTaylor) startTime = DateTime.Now;
                int iterCounter = 0;
                int iterMax = int.MinValue;
                int iterMin = int.MaxValue;
                int iterNotSolved = 0;
                int iterConsecutiveNotSolved = 0;
                int iterConsecutiveNotSolvedHelper = 0;

                double[,] ftVars = null;
                if (usingFairTaylor || usingNewtonFairTaylor)
                {
                    //Put the leaded vars into a special array ftVars
                    ftVars = GetFtVars(largestLag, obsSimPeriod, a, leadedVarsList, ftVars);
                    HandleTerminals(largestLag, obsSimPeriod, a, leadedVarsList, terminal);
                }

                //a list of actions. The first action is a normal simulation.
                //if we use NFair, the actions are used to create the Jacobi matrix
                NewtonFairTaylorHelper helper = CreateNFairHelper(ref tStart, ref tEnd, usingNewtonFairTaylor, leadedVarsList, ft, oldNftJacobi);
                double[,] aFinalResultFromShockLoop = null;
                int counterJ = -1;
                foreach (NewtonFairTaylorHelper1 shock in helper.shocks)
                {
                    counterJ++;
                    if (!shock.isFirstBaseline) G.Writeln("    Gradient " + counterJ + " of " + (helper.shocks.Count - 1) + " (var " + (shock.varCounter+1) + " per " + shock.gt.ToString() + ")");
                    double[,] aTemp = null;
                    double nftDelta = double.NaN;
                    if (shock.isFirstBaseline && helper.shocks.Count == 1)
                    {
                        //first iteration in shocks, when there is only 1 element
                        //This means that it is not Newton Fair-Taylor but normal Fair-Taylor (or it is the first iteration
                        //of Newton Fair-Taylor). The reason we make a pointer like this in such cases is just to save time
                        //to avoid copying the content of a into aTemp
                        aTemp = a;
                    }
                    else if (shock.isFirstBaseline && helper.shocks.Count > 1)
                    {
                        aTemp = new double[a.GetLength(0), a.GetLength(1)];
                        Array.Copy(a, aTemp, a.Length);
                        helper.jacobi = new double[helper.shocks.Count - 1, helper.shocks.Count - 1];
                    }
                    else
                    {
                        //second iteration and onwards, a is known from first iteration
                        //we only end here when doing NFair
                        aTemp = new double[a.GetLength(0), a.GetLength(1)];
                        Array.Copy(a, aTemp, a.Length);
                        //int bNumber = bNumberPointers[leadedVarsList[shock.varNumber]];
                        int bNumber = bNumberPointers[shock.varNumber];
                        nftDelta = Program.model.bVariance[bNumber] / 100d;
                        if (nftDelta == 0d || G.isNumericalError(nftDelta)) nftDelta = 1d;  //could be refined, perhaps looking at the level of the variable
                        aTemp[shock.varNumber, GekkoTime.Observations(tStart, shock.gt) - 1 - largestLag] += nftDelta;
                    }

                    SetTerminalType(terminal);

                    int tInt = -largestLag - 1;
                    foreach (GekkoTime t in new GekkoTimeIterator(tStart, tEnd.Add(-horizon2)))  //horizon2 is deducted. Is 0 for non-stacked models.
                    {
                        int distanceToEnd = GekkoTime.Observations(t, tEnd) - 1;  //0 if last period, 1 if second-last, and so on
                        Program.model.simulateResults[7] = distanceToEnd;

                        if (Program.options.solve_print_details && Globals.runningOnTTComputer)
                        {
                            G.Writeln("");
                            G.Writeln("NEW TIME PERIOD " + t.super + t.freq.ToString() + t.sub, Color.Green);
                            G.Writeln("");
                        }

                        tInt++;  //first time --> = -largestLag = model.largestLag (= positive number)

                        if (Globals.threadIsInProcessOfAborting) throw new GekkoException();

                        DateTime dt10 = DateTime.Now;

                        try
                        {
                            //BTypeData zz1 = model.varsBType["hw¤0"];
                            //BTypeData zz2 = model.varsBType["hw¤1"];
                            //G.Writeln("lkdsfjasljfd " + zz1.aNumber + zz2.aNumber);
                            //G.Writeln("before1 " + model.b[137] + " lead " + model.b[138] + " " + t.ToString());
                            FromAToB(usingFairTaylor, usingNewtonFairTaylor, shock, ft, ec, work, timeSeriesPointers, extraWritebackPointers, lagPointers, aNumberPointers, endoNoLagPointers, endoLeadPointers, endoPointers, varNamePointers, isDJZvarPointers, aTemp, tInt, t, tStart, tEnd, so);
                            //G.Writeln("after1 " + model.b[137] + " lead " + model.b[138] + " " + t.ToString());
                        }
                        catch (Exception e)
                        {
                            if (!Program.options.solve_print_iter)
                            {
                                G.Write("    You may inspect the individual iterations in more detail");
                                IterLink(output, " ", "here", "");
                                G.Writeln();
                            }
                            double[,] a2 = FromAToDatabankWhileRememberingOldDatabank(tStart0, tStart, tEnd, debug, work, obsWithLagsIncludingLeadsAtEnd, obsSimPeriodIncludingLeadsAtEnd, aTemp, NAN, bNumberPointers, endoNoLagPointers);
                            LinkContainer lc1;
                            LinkContainer lc2;
                            UndoAndPackStuff(out lc1, out lc2, tStart, tEnd, tStart0, obsWithLagsIncludingLeadsAtEnd, obsSimPeriodIncludingLeadsAtEnd, a2);
                            if (SearchException(e, "simFailure"))
                            {
                                SimPrintErrorOptionsUndo(lc1);
                                SimPrintErrorOptionsPack(lc2);
                                WriteAboutFailsafeOption();
                            }
                            else
                            {
                                SimPrintErrorOptionsUndo(lc1);
                                WriteAboutFailsafeOption();
                            }
                            throw;
                        }

                        ms1 += (DateTime.Now - dt10).TotalMilliseconds;

                        string culprit = "";

                        if (Globals.simulationCheckThatAllDataGetsFromBArrayToTimeSeries)
                        {
                            if (IsStacked())
                            {
                                bCheck = new double[Program.model.stackedModel.b.Length];
                                System.Array.Copy(Program.model.stackedModel.b, bCheck, Program.model.stackedModel.b.Length);
                            }
                            else
                            {
                                bCheck = new double[Program.model.b.Length];
                                System.Array.Copy(Program.model.b, bCheck, Program.model.b.Length);
                            }
                        }

                        DateTime t0 = DateTime.Now;

                        try
                        {
                            if (modelType == ECompiledModelType.After)
                            {
                                if (IsStacked())
                                {
                                    G.Writeln2("*** ERROR: You cannot use option 'forward method = stacked' together with the EFTER command");
                                    throw new GekkoException();
                                }
                                SolveAfter();
                                SolveRevertedAuto();
                                SolveRevertedY();
                            }
                            else if (modelType == ECompiledModelType.Res)
                            {
                                if (IsStacked())
                                {
                                    G.Writeln2("*** ERROR: You cannot use option 'forward method = stacked' together with the RES command");
                                    throw new GekkoException();
                                }
                                SolveRes(Program.model.b);
                            }
                            else if (modelType == ECompiledModelType.Gauss || modelType == ECompiledModelType.GaussFailSafe)
                            {
                                if (so.isEigen)
                                {
                                    if (true)
                                    {
                                        Linearize(isDampedPointers);
                                    }
                                    else
                                    {
                                        Globals.solveNewtonOnlyFeedback = true;
                                        LinearizeOLD_DELETE_AT_SOME_POINT();
                                        Globals.solveNewtonOnlyFeedback = false;
                                        Program.model = null;  //safety
                                    }
                                    throw new GekkoException();  //use the return below instead of the exception!
                                    //return;  //do not try to write anything back to databanks etc. We should be able to simulate after an eigenvalue analysis.
                                }
                                else
                                {
                                    if (IsStacked())
                                    {
                                        G.Writeln2("*** ERROR: You cannot use option 'forward method = stacked' together with the Gauss algorithm");
                                        throw new GekkoException();
                                    }
                                    if (so.isFix && hasEndoExo)
                                    {
                                        //This should never happen
                                        G.Writeln2("*** ERROR: Trying to solve SIM<fix> with Gauss Seidel");
                                        throw new GekkoException();
                                    }
                                    SolveGauss(usingFairTaylor || usingNewtonFairTaylor, Program.model.b, isDampedPointers, isDampedPointersArray, out culprit, modelType, t, checkoff);
                                }
                            }
                            else if (modelType == ECompiledModelType.Newton)
                            {
                                NewtonAlgorithmHelper nah = new NewtonAlgorithmHelper();
                                nah.t = t;
                                nah.tStart = tStart;
                                nah.tEnd = tEnd;

                                Model tempModel = Program.model;

                                if (IsStacked())
                                {
                                    Program.model = Program.model.stackedModel;
                                    ParserOLD.OrderAndCompileModel(ECompiledModelType.Newton, false, so.isFix);
                                }

                                SolveNewton(modelType, nah);

                                if (IsStacked())
                                {
                                    //TODO: what if exception, in that case we should also revert
                                    //TODO: what if exception, in that case we should also revert
                                    //TODO: what if exception, in that case we should also revert
                                    Program.model = tempModel;
                                }
                            }
                            else throw new GekkoException();  //should be one of these
                        }
                        catch (Exception e)
                        {
                            if (!Program.options.solve_print_iter)
                            {
                                G.Write("    You may inspect the iterations");
                                IterLink(output, " ", "here", "");
                                G.Writeln();
                            }
                            //write the stuff back to databank
                            double[,] a2 = FromAToDatabankWhileRememberingOldDatabank(tStart0, tStart, tEnd, debug, work, obsWithLagsIncludingLeadsAtEnd, obsSimPeriodIncludingLeadsAtEnd, aTemp, NAN, bNumberPointers, endoNoLagPointers);
                            LinkContainer lc1;
                            LinkContainer lc2;
                            UndoAndPackStuff(out lc1, out lc2, tStart, tEnd, tStart0, obsWithLagsIncludingLeadsAtEnd, obsSimPeriodIncludingLeadsAtEnd, a2);
                            SimPrintErrorOptionsUndo(lc1);
                            SimPrintErrorOptionsPack(lc2);
                            WriteAboutFailsafeOption();
                            throw;
                        }

                        int its = (int)Program.model.simulateResults[0];
                        iterCounter += its;
                        if (its > iterMax) iterMax = its;
                        if (its < iterMin) iterMin = its;
                        if ((G.equal(so.method, "gauss") && its >= Program.options.solve_gauss_itermax) || (G.equal(so.method, "newton") && its >= Program.options.solve_newton_itermax))
                        {
                            iterNotSolved++;
                            iterConsecutiveNotSolvedHelper++;
                            if (iterConsecutiveNotSolvedHelper > iterConsecutiveNotSolved) iterConsecutiveNotSolved = iterConsecutiveNotSolvedHelper;
                        }
                        else
                        {
                            iterConsecutiveNotSolvedHelper = 0;
                        }

                        simTime += (DateTime.Now - t0).TotalMilliseconds / 1000d;

                        bool isGaussConverged = true;
                        if ((int)Program.model.simulateResults[0] >= Program.options.solve_gauss_itermax) isGaussConverged = false;

                        DateTime dt11 = DateTime.Now;

                        //G.Writeln("SIM + before2 " + model.b[137] + " lead " + model.b[138] + " " + t.ToString());
                        FromBToA(ref hasIssuedSeedWarning, bCheck, extraWritebackPointers, revertedPointers, aNumberPointers, endoNoLagPointers, varNamePointers, aTemp, tInt);
                        //G.Writeln("");


                        ms2 += (DateTime.Now - dt11).TotalMilliseconds;

                        IterationPrint(ref culprit, tStart, t, modelType, output, isGaussConverged, so);

                        if (Program.model.simulateResults[1] == 12345)
                        {
                            //abort NaN
                            double[,] a2 = FromAToDatabankWhileRememberingOldDatabank(tStart0, tStart, tEnd, debug, work, obsWithLagsIncludingLeadsAtEnd, obsSimPeriodIncludingLeadsAtEnd, aTemp, NAN, bNumberPointers, endoNoLagPointers);

                            int eqNumber = (int)Program.model.simulateResults[2];
                            EquationHelper eh = Program.model.equations[eqNumber];
                            G.Writeln();
                            G.Writeln("Numerical problem encountered in equation: " + eh.lhs);
                            G.Writeln("Simulation time period: " + tStart + " " + tEnd);
                            G.Writeln("Period being simulated: " + t);
                            G.Writeln("Gauss damping factor:   " + Program.options.solve_gauss_damp);
                            G.Writeln("Current iteration:      " + (int)Program.model.simulateResults[0]);
                            Program.PrintEquationVariables(t, eh);
                            G.Write("*** ERROR: Simulation failed");
                            if (!Program.options.solve_print_iter) IterLink(output, " (", "more", ")");
                            G.Writeln();

                            //G.Writeln("    You may undo the simulation and revert to pre-simulation databank");
                            LinkContainer lc1;
                            LinkContainer lc2;
                            UndoAndPackStuff(out lc1, out lc2, tStart, tEnd, tStart0, obsWithLagsIncludingLeadsAtEnd, obsSimPeriodIncludingLeadsAtEnd, a2);
                            SimPrintErrorOptionsUndo(lc1);
                            SimPrintErrorOptionsPack(lc2);
                            WriteAboutFailsafeOption();
                            throw new GekkoException();
                        }
                    }  //end of foreach t
                    Globals.simCounter++;

                    if (usingFairTaylor || usingNewtonFairTaylor)
                    {
                        if (shock.isFirstBaseline)
                        {
                            aFinalResultFromShockLoop = aTemp;
                            //a = aTemp; //only the first one in shocks will become the 'a' array
                            bool ok = false;
                            CheckFairTaylorIteration(usingFairTaylor, usingNewtonFairTaylor, bNumberPointers, largestLag, obsSimPeriod, aTemp, leadedVarsList, ft, ftVars, out ok);
                            string extra = null; if (usingNewtonFairTaylor) extra = "Newton-";
                            string extra2 = null; if (usingNewtonFairTaylor) extra2 = "N";
                            if (ok && ft >= ftMin)
                            {
                                G.Writeln(extra + "Fair-Taylor (leads) algorithm converged in " + (ft + 1) + " " + extra2 + "FT-iterations (" + G.SecondsFormat((DateTime.Now - dtFt).TotalMilliseconds) + ")");
                                a = aFinalResultFromShockLoop;
                                goto JumpOut;
                            }
                            if (ft == ftMax - 1)
                            {
                                G.Writeln("+++ WARNING: " + extra + "Fair-Taylor algorithm did not converge in " + (ft + 1) + " " + extra2 + "FT-iterations (" + G.SecondsFormat((DateTime.Now - dtFt).TotalMilliseconds) + ")");
                                a = aFinalResultFromShockLoop;
                                goto JumpOut;
                            }
                        }
                        else
                        {
                            //Compute stuff for the NFT Jacobi matrix
                            int counterI = 0;  //1-based
                            foreach (NewtonFairTaylorHelper1 shock2 in helper.shocks)
                            {
                                if (shock2.isFirstBaseline) continue;  //the first one is skipped
                                counterI++;
                                int var = shock2.varNumber;
                                double v1 = aFinalResultFromShockLoop[shock2.varNumber, GekkoTime.Observations(tStart, shock2.gt) - 1 - largestLag];
                                double v2 = aTemp[shock2.varNumber, GekkoTime.Observations(tStart, shock2.gt) - 1 - largestLag];
                                double jac = (v2 - v1) / nftDelta;
                                //Remember that the DUMP matrices #ft_1 etc. are transposed relative to this!
                                helper.jacobi[counterJ - 1, counterI - 1] = jac;
                            }
                        }
                    }
                    else
                    {
                        aFinalResultFromShockLoop = aTemp; //maybe not necessary
                    }
                } //end of shock loop that computes Jacobi matric for Newton-Fair-Taylor
                a = aFinalResultFromShockLoop;  //stores a pointer to the a array that is done in the first shock iteration

                double time = (DateTime.Now - startTime).TotalMilliseconds;
                double avgIter = (double)iterCounter / (double)obsSimPeriodIncludingLeadsAtEnd;
                string avgIterString = avgIter.ToString("0.0");
                if (avgIter > 50) avgIterString = avgIter.ToString("0");
                string type = "";
                if (so.method.Length > 2) type = so.method.Substring(0, 1).ToUpper() + so.method.Substring(1);  //First letter in capitals
                string s5 = ""; if (usingFairTaylor || usingNewtonFairTaylor) s5 = "#" + (ft + 1) + ": ";
                string s3 = s5 + type + " simulation " + G.FromDateToString(tStart) + "-" + G.FromDateToString(tEnd) + " took " + G.SecondsFormat(time) + " -- " + iterMin + "/" + iterMax + "/" + avgIterString + " iterations (min/max/avg)";
                G.Write(s3);
                string s4 = "";
                if (iterNotSolved > 0)
                {
                    s4 = "+++ WARNING: " + iterNotSolved + " periods not converged (most consecutive: " + iterConsecutiveNotSolved + ")";
                }
                if (!Program.options.solve_print_iter)
                {
                    if (s4.Length > 0) output.AppendLine(s4);
                }
                if (!Program.options.solve_print_iter && !(usingFairTaylor || usingNewtonFairTaylor))
                {
                    //we avoid this when using FairTaylor, because it takes up too much memory
                    IterLink(output, " (", "more", ")");
                }
                G.Writeln();
                if (debug)
                {
                    G.WritelnGray(" --> " + (time / 1000d * (100d / (tEnd.super - tStart.super + 1))));
                }
                if (s4.Length > 0) G.Writeln(s4);

                if (so.isFix)
                {
                    //SIM<fix>
                    if (hasEndoExo)
                    {
                        G.Writeln("+++ NOTE: " + Program.model.endogenized.Count + " ENDO/EXO vars (goals) were enforced with SIM<fix>");
                    }
                    else
                    {
                        G.Writeln("+++ NOTE: SIM<fix> did not enforce any goals, since there are no ENDO/EXO vars (goals) set");
                    }
                }
                else
                {
                    //normal SIM
                    if (hasEndoExo)
                    {
                        G.Writeln("+++ NOTE: There are " + Program.model.endogenized.Count + " ENDO/EXO vars (goals) set, you may use SIM<fix> to enforce them");
                    }
                    else
                    {
                        //do nothing
                    }
                }


                if (usingFairTaylor)
                {
                    HandleFairTaylorIteration(bNumberPointers, largestLag, tStart0, obsSimPeriod, a, leadedVarsList, ft, ftVars);
                }
                else if (usingNewtonFairTaylor)
                {
                    if (helper.jacobi != null)
                    {
                        oldNftJacobi = new double[helper.jacobi.GetLength(0), helper.jacobi.GetLength(1)];
                        Array.Copy(helper.jacobi, oldNftJacobi, helper.jacobi.Length);
                    }
                    HandleNewtonFairTaylorIteration(dtFt, bNumberPointers, largestLag, tStart0, obsSimPeriod, a, leadedVarsList, ft, ftVars, helper);
                }

            } //Fair-Taylor (ft) iterations

            JumpOut: ;

            DateTime dt3 = DateTime.Now;

            if (debug) G.WritelnGray("from a[] to b[]: " + ms1 / 1000d);
            if (debug) G.WritelnGray("from b[] to a[]: " + ms2 / 1000d);

            if (Globals.alwaysEnablcPackForSimulation)  //this is mostly for debugging, "packsim" activates the link showing up always.
            {
                double[,] a2 = FromAToDatabankWhileRememberingOldDatabank(tStart0, tStart, tEnd, debug, work, obsWithLagsIncludingLeadsAtEnd, obsSimPeriodIncludingLeadsAtEnd, a, NAN, bNumberPointers, endoNoLagPointers);
                LinkContainer lc1;
                LinkContainer lc2;
                UndoAndPackStuff(out lc1, out lc2, tStart, tEnd, tStart0, obsWithLagsIncludingLeadsAtEnd, obsSimPeriodIncludingLeadsAtEnd, a2);
                SimPrintErrorOptionsPack(lc2);
                WriteAboutFailsafeOption();
            }
            else
            {
                //This is faster, so the "pack" link is not shown as default.
                FromAToDatabank(tStart, tEnd, debug, work, obsWithLagsIncludingLeadsAtEnd, obsSimPeriodIncludingLeadsAtEnd, a, bNumberPointers, endoNoLagPointers);
            }

            if (ec.simInitEndoMissingValueHelper != null)
            {
                ec.simInitEndoMissingValue = new List<string>();
                ec.simInitEndoMissingValue.Add("Normally, initial values for endogenous variables are lagged values from the databank. If such data is missing, Gekko tries ");
                ec.simInitEndoMissingValue.Add("some arbitrary number (0.12345) as starting value. Simulation will often converge anyway, but if it does not, please ");
                ec.simInitEndoMissingValue.Add("put in some meaningful lagged values in the databank. You may alternatively look into 'option solve init' to force Gekko to use ");
                ec.simInitEndoMissingValue.Add("current (unlagged) values as starting values for the endogenous variables.");
                ec.simInitEndoMissingValue.Add("Below is a list of endogenous variables that were initialized to 0.12345 before simulation:");
                ec.simInitEndoMissingValue.Add("");
                StringBuilder sb = new StringBuilder();
                int count = 0;
                foreach (string s in ec.simInitEndoMissingValueHelper)
                {
                    count++;
                    string blank = "";
                    if (count > 0) blank = Globals.blankUsedAsPadding;
                    string count2 = count.ToString();
                    ec.simInitEndoMissingValue.Add(blank + " " + G.Blanks(4 - count2.Length) + "#" + count + ": " + s);
                }
                ec.simInitEndoMissingValue.Add("");
                G.Write("+++ NOTE: "); G.WriteLink(ec.simInitEndoMissingValueHelper.Count.ToString(), "tab:output" + ec.counter + "a"); G.Writeln(" endogenous were given an arbitrary starting value (this is ok)");
                G.Writeln();
                ec.simInitEndoMissingValueHelper.Clear();  //not used anymore
                if (!Globals.outputTabTextContainer.ContainsKey(ec.counter.ToString()))
                {
                    Globals.outputTabTextContainer.Add(ec.counter.ToString(), ec);
                }
            }

            Globals.hasBeenEndoExoStatementsSinceLastSim = 0;
            Program.model.lastSimPer1 = tStart;
            Program.model.lastSimPer2 = tEnd;
            Program.model.lastSimStamp = Program.GetDateStamp();

            return;
        }

        private static void SetTerminalType(ETerminalCondition terminal)
        {
            Program.model.simulateResults[8] = 0;
            if (G.equal(Program.options.solve_forward_method, "stacked"))
            {
                if (!(terminal == ETerminalCondition.Exogenous))
                {
                    G.Writeln2("*** ERROR: method 'stacked' only works with terminal = exo at the moment");
                    throw new GekkoException();
                }
                Program.model.simulateResults[8] = 0;
            }
            if (G.equal(Program.options.solve_forward_method, "none"))
            {
                Program.model.simulateResults[8] = 0;
            }
            else
            {
                if (terminal == ETerminalCondition.Exogenous) Program.model.simulateResults[8] = 0;
                else if (terminal == ETerminalCondition.ConstantLevel) Program.model.simulateResults[8] = 1;
                else if (terminal == ETerminalCondition.ConstantGrowthRate) Program.model.simulateResults[8] = 2;  //not working
            }
        }

        private static void HandleTerminalHelper()
        {
            Program.model.terminalHelper = null;  //will stay like this if terminal feed=external or there are no leads
            if (G.equal(Program.options.solve_forward_terminal_feed, "internal"))
            {
                if (Program.model.largestLead > 0)
                {
                    Program.model.terminalHelper = new List<Dictionary<int, int>>();
                    for (int i = 0; i < Program.model.largestLead; i++)
                    {
                        Program.model.terminalHelper.Add(new Dictionary<int, int>());
                    }
                    foreach (BTypeData data in Program.model.varsBType.Values)
                    {
                        if (data.lag <= 0) continue;
                        for (int i = 0; i < Program.model.largestLead; i++)
                        {
                            if (i >= data.lag) continue;
                            BTypeData data2 = Program.model.varsBType[data.variable + Globals.lagIndicator + i];
                            Program.model.terminalHelper[i].Add(data.bNumber, data2.bNumber);
                        }
                    }
                }
            }
        }

        private static NewtonFairTaylorHelper CreateNFairHelper(ref GekkoTime tStart, ref GekkoTime tEnd, bool usingNewtonFairTaylor, List<int> leadedVarsList, int ft, double[,] oldNftJacobi)
        {
            NewtonFairTaylorHelper helper = new NewtonFairTaylorHelper();
            helper.shocks = new List<NewtonFairTaylorHelper1>();
            NewtonFairTaylorHelper1 h2 = new NewtonFairTaylorHelper1();
            h2.gt = Globals.tNull;
            h2.varNumber = -12345;
            h2.isFirstBaseline = true;
            helper.shocks.Add(h2);
            if (Program.options.solve_forward_nfair_updatefreq > 1 && oldNftJacobi != null)
            {
                helper.jacobi = new double[oldNftJacobi.GetLength(0), oldNftJacobi.GetLength(1)];
                Array.Copy(oldNftJacobi, helper.jacobi, oldNftJacobi.Length);
            }
            else
            {
                if (usingNewtonFairTaylor && ft > 0)
                {
                    //after the first FT-iteration (ft = 0), we do not do shocks.
                    //this has to do with data initialization, because in the first FT-iteration we typically take initial leaded variable values
                    //from lagged variable values (remember the leaded variable may be all missing values).
                    //This interacts badly with shocks, so we do it from FT-iteration 2 and onwards
                    if (IsStacked())
                    {
                        G.Writeln2("*** ERROR: You cannot use stacked and newton-fair-taylor at the same time");
                        throw new GekkoException();
                    }
                    int counter = -1;
                    foreach (int leadVar in leadedVarsList)
                    {
                        counter++;
                        foreach (GekkoTime t in new GekkoTimeIterator(tStart, tEnd))  //horizon2 is deducted. Is 0 for non-stacked models.
                        {
                            NewtonFairTaylorHelper1 h = new NewtonFairTaylorHelper1();
                            h.varNumber = leadVar;
                            h.varCounter = counter;  //starts with 0
                            h.gt = t;
                            helper.shocks.Add(h);
                        }
                    }
                }
            }
            return helper;
        }

        private static void HandleTerminals(int largestLag, int obsSimPeriod, double[,] a, List<int> leadedVarsList, ETerminalCondition terminal)
        {
            for (int lv = 0; lv < leadedVarsList.Count; lv++)
            {
                if (terminal != ETerminalCondition.Exogenous)
                {
                    for (int t2 = -largestLag + obsSimPeriod; t2 < (-largestLag + obsSimPeriod) + model.largestLead; t2++)
                    {
                        //NOTE: do not use damping here: terminal values should not be damped!
                        if (terminal == ETerminalCondition.ConstantLevel)
                        {
                            //seems to be ok
                            a[leadedVarsList[lv], t2] = a[leadedVarsList[lv], t2 - 1];
                        }
                        else if (terminal == ETerminalCondition.ConstantGrowthRate)
                        {
                            //seems to be ok
                            a[leadedVarsList[lv], t2] = a[leadedVarsList[lv], t2 - 1] * a[leadedVarsList[lv], t2 - 1] / a[leadedVarsList[lv], t2 - 2];
                        }
                    }
                }
            }
        }

        private static double[,] GetFtVars(int largestLag, int obsSimPeriod, double[,] a, List<int> leadedVarsList, double[,] ftVars)
        {
            ftVars = new double[model.leadedVariables.Count, obsSimPeriod];
            for (int lv = 0; lv < leadedVarsList.Count; lv++)
            {
                int t3 = -1;
                for (int t2 = -largestLag; t2 < -largestLag + obsSimPeriod; t2++)
                {
                    t3++;
                    ftVars[lv, t3] = a[leadedVarsList[lv], t2];
                }
            }
            return ftVars;
        }

        private static void HandleFairTaylorIteration(int[] bNumberPointers, int largestLag, GekkoTime tStart0, int obsSimPeriod, double[,] a, List<int> leadedVarsList, int ft, double[,] ftVars)
        {

            for (int lv = 0; lv < leadedVarsList.Count; lv++)
            {
                TimeSeries ts = null;
                TimeSeries tsrel = null;
                if (Program.options.solve_forward_dump)
                {
                    ts = new TimeSeries(Program.options.freq, "ftabs" + (lv + 1) + "_" + ft);
                    tsrel = new TimeSeries(Program.options.freq, "ftrel" + (lv + 1) + "_" + ft);
                }
                int t3 = -1;
                for (int t2 = -largestLag; t2 < -largestLag + obsSimPeriod; t2++)
                {
                    t3++;
                    double vNew = a[leadedVarsList[lv], t2];
                    double vOld = ftVars[lv, t3];
                    double vNewDamp = vNew;
                    //only do damping from second ft-iteration and up
                    //there may be NaN's in the lead-variable (if it has not been simulated in the databank),
                    //or the values may be bad. So what we do here, is equivalent to INIT for Gauss-Seidel: we
                    //do not want to just take the databank values as they are.
                    //HMMMMM this means a solved model always has to simulate when rerun on solved databank, with INIT on.
                    if (ft == 0)
                    {
                        //No damping of first iteration. The old values may be full of NaN's.
                        vNewDamp = vNew;
                    }
                    else
                    {
                        //NOTE NOTE NOTE NOTE: Damping is redefined in Gekko 2.0: dampNew = 1-dampOld
                        vNewDamp = (1d - Program.options.solve_forward_fair_damp) * vNew + Program.options.solve_forward_fair_damp * vOld;
                    }
                    a[leadedVarsList[lv], t2] = vNewDamp;
                    if (Program.options.solve_forward_dump)
                    {
                        ts.SetData(tStart0.Add(t2), vNewDamp);
                        tsrel.SetData(tStart0.Add(t2), vNewDamp / vOld - 1);
                    }
                }
                if (Program.options.solve_forward_dump)
                {
                    //G.writeln();
                    if (Program.databanks.GetFirst().ContainsVariable(ts.variableName)) Program.databanks.GetFirst().RemoveVariable(ts.variableName);
                    if (Program.databanks.GetFirst().ContainsVariable(tsrel.variableName)) Program.databanks.GetFirst().RemoveVariable(tsrel.variableName);
                    Program.databanks.GetFirst().AddVariable(ts);
                    Program.databanks.GetFirst().AddVariable(tsrel);
                }

            }
            return;
        }

        private static void CheckFairTaylorIteration(bool usingFairTaylor, bool usingNewtonFairTaylor, int[] bNumberPointers, int largestLag, int obsSimPeriod, double[,] a, List<int> leadedVarsList, int ft, double[,] ftVars, out bool ok)
        {
            ok = true;
            double[,] ftVarsNew = null;
            if (ft > 0)
            {
                ftVarsNew = GetFtVars(largestLag, obsSimPeriod, a, leadedVarsList, ftVars);
                for (int lv = 0; lv < leadedVarsList.Count; lv++)
                {
                    int t3 = -1;
                    for (int t2 = -largestLag; t2 < -largestLag + obsSimPeriod; t2++)
                    {
                        t3++;
                        //double vNew = a[leadedVarsList[lv], t2];
                        double vNew = ftVarsNew[lv, t3];
                        double vOld = ftVars[lv, t3];
                        int fairTaylorConvType = 1;
                        if (usingFairTaylor && G.equal(Program.options.solve_forward_fair_conv, "conv2")) fairTaylorConvType = 2;
                        if (usingNewtonFairTaylor && G.equal(Program.options.solve_forward_nfair_conv, "conv2")) fairTaylorConvType = 2;
                        int bNumber = bNumberPointers[leadedVarsList[lv]];
                        double abs; double rel1; double rel2;
                        bool converged = GaussConvergenceOk(usingFairTaylor, usingNewtonFairTaylor, null, vNew, vOld, bNumber, false, fairTaylorConvType, out abs, out rel1, out rel2);  //first arg is null --> so that there is no Gauss damping correction (Fair-Taylor uses its own damping)
                        if (!converged) ok = false;
                    }
                }
            }
            else
            {
                ok = false;  //so we keep iterating
            }
            return;
        }

        private static void HandleNewtonFairTaylorIteration(DateTime dtFt, int[] bNumberPointers, int largestLag, GekkoTime tStart0, int obsSimPeriod, double[,] a, List<int> leadedVarsList, int ft, double[,] ftVars, NewtonFairTaylorHelper helper)
        {
            //TODO: We could also DUMP these for inspection
            double[,] ftVarsNew = GetFtVars(largestLag, obsSimPeriod, a, leadedVarsList, ftVars);

            if (ft > 0)
            {
                //Do a Newton jump here
                //a[leadedVarsList[lv], t2] = vNew...???

                double[,] inv = new double[helper.jacobi.GetLength(0), helper.jacobi.GetLength(1)];
                Array.Copy(helper.jacobi, inv, helper.jacobi.Length);

                if (Program.options.solve_forward_dump)
                {
                    double[,] dump = new double[helper.jacobi.GetLength(0), helper.jacobi.GetLength(1)];
                    Array.Copy(inv, dump, inv.Length);
                    Matrix m = new Matrix();
                    m.data = dump;
                    //m.data = Transpose(m.data);  //easier for humans to understand this orientation, and also without 1 subtracted on the diagonal
                    if (Program.scalars.ContainsKey("#ft_" + ft)) Program.scalars.Remove("#ft_" + ft);
                    Program.scalars.Add("#ft_" + ft, m);
                }

                for (int i = 0; i < helper.jacobi.GetLength(0); i++)
                {
                    inv[i, i] += -1;
                }

                int success = -12345;
                alglib.matinvreport report = new alglib.matinvreport();
                alglib.rmatrixinverse(ref inv, out success, out report);
                if (success == 3)
                {
                    G.Writeln2("*** ERROR: Inv(): It seems the matrix is singular");
                    throw new GekkoException();
                }
                else if (success != 1)
                {
                    G.Writeln2("*** ERROR: Inv(): Could not invert matrix");
                    throw new GekkoException();
                }

                //#orig-inv(#mm)*(#base - #orig);

                double[] delta = new double[inv.GetLength(0)];
                for (int i = 0; i < inv.GetLength(0); i++)
                {
                    int rowCounter = -1;
                    //The two nested loops below correspond to a full row of the inv array
                    for (int lv = 0; lv < leadedVarsList.Count; lv++)
                    {
                        int t3 = -1;
                        for (int t2 = -largestLag; t2 < -largestLag + obsSimPeriod; t2++)
                        {
                            t3++;
                            rowCounter++;
                            double vNew = ftVarsNew[lv, t3];
                            double vOld = ftVars[lv, t3];
                            delta[i] += -inv[rowCounter, i] * (vNew - vOld);
                        }
                    }
                }

                double[] newBestGuessRegardingLeadVariables = new double[inv.GetLength(0)];

                int ii = -1;
                //The two nested loops below correspond to a full row of the inv array
                for (int lv = 0; lv < leadedVarsList.Count; lv++)
                {
                    int t3 = -1;

                    TimeSeries ts = null;
                    TimeSeries tsrel = null;
                    if (Program.options.solve_forward_dump)
                    {
                        ts = new TimeSeries(Program.options.freq, "ftabs" + (lv + 1) + "_" + ft);
                        tsrel = new TimeSeries(Program.options.freq, "ftrel" + (lv + 1) + "_" + ft);
                    }

                    for (int t2 = -largestLag; t2 < -largestLag + obsSimPeriod; t2++)
                    {
                        t3++;
                        ii++;
                        //double vNew = ftVarsNew[lv, t3];
                        double vOld = ftVars[lv, t3];
                        // NOTE NOTE NOTE NOTE: Damping is redefined in Gekko 2.0: dampNew = 1-dampOld
                        newBestGuessRegardingLeadVariables[ii] = vOld + (1d - Program.options.solve_forward_nfair_damp) * delta[ii];
                        //G.Writeln("--> GUESS var = " + lv + " period " + t3 + " " + newBestGuessRegardingLeadVariables[ii] + " (delta = " + delta[ii] + ")");
                        a[leadedVarsList[lv], t2] = newBestGuessRegardingLeadVariables[ii];

                        if (Program.options.solve_forward_dump)
                        {
                            ts.SetData(tStart0.Add(t2), newBestGuessRegardingLeadVariables[ii]);
                            tsrel.SetData(tStart0.Add(t2), newBestGuessRegardingLeadVariables[ii] / vOld - 1);
                        }
                    }

                    if (Program.options.solve_forward_dump)
                    {
                        //G.writeln();
                        if (Program.databanks.GetFirst().ContainsVariable(ts.variableName)) Program.databanks.GetFirst().RemoveVariable(ts.variableName);
                        if (Program.databanks.GetFirst().ContainsVariable(tsrel.variableName)) Program.databanks.GetFirst().RemoveVariable(tsrel.variableName);
                        Program.databanks.GetFirst().AddVariable(ts);
                        Program.databanks.GetFirst().AddVariable(tsrel);
                    }
                }
            }
            return;
        }

        private static void FillAWithNaN(int vars, double[,] a, double[] NAN)
        {
            for (int i = 0; i < vars; i++)
            {
                Buffer.BlockCopy(NAN, 0, a, 8 * i * NAN.Length, 8 * NAN.Length);  //TODO: what if out of bounds regarding x???
            }
        }

        private static void IterLink(StringBuilder output, string s1, string s2, string s3)
        {
            LinkContainer lc = new LinkContainer(output.ToString());
            Globals.linkContainer.Add(lc.counter, lc);
            G.Write(s1); G.WriteLink(s2, "outputtab:" + lc.counter); G.Write(s3);
        }

        private static void UndoAndPackStuff(out LinkContainer lc1, out LinkContainer lc2, GekkoTime tStart, GekkoTime tEnd, GekkoTime tStart0, int obsWithLags, int obsSimPeriod, double[,] a2)
        {
            lc1 = new LinkContainer("");
            Globals.linkContainer.Add(lc1.counter, lc1);
            Globals.undoSim = new UndoSim();
            Globals.undoSim.id = lc1.counter;
            Globals.undoSim.a = a2;
            Globals.undoSim.tStart0 = tStart0.Add(0); //probably not necessary to clone, but for safety...
            Globals.undoSim.tStart = tStart.Add(0);
            Globals.undoSim.tEnd = tEnd.Add(0);
            Globals.undoSim.obsWithLags = obsWithLags;
            Globals.undoSim.obsSimPeriod = obsSimPeriod;
            lc2 = new LinkContainer("");
            Globals.linkContainer.Add(lc2.counter, lc2);
            Globals.packSim = new PackSim();
            Globals.packSim.id = lc2.counter;
            Globals.packSim.a = a2;
            Globals.packSim.tStart0 = tStart0.Add(0); //probably not necessary to clone, but for safety...
            Globals.packSim.tStart = tStart.Add(0);
            Globals.packSim.tEnd = tEnd.Add(0);
            Globals.packSim.obsWithLags = obsWithLags;
            Globals.packSim.obsSimPeriod = obsSimPeriod;
        }

        private static void SimPrintErrorOptionsPack(LinkContainer lc2)
        {
            G.Write("    Create error report with model + data packed in a zip file ");
            G.WriteLink("here", "packsim:" + lc2.counter);
            G.Writeln("");
        }

        private static void SimPrintErrorOptionsUndo(LinkContainer lc1)
        {
            G.Write("    Undo the simulation, reverting to pre-simulation values ");
            G.WriteLink("here", "undosim:" + lc1.counter);
            G.Writeln("");
        }

        private static double[,] FromAToDatabankWhileRememberingOldDatabank(GekkoTime tStart0, GekkoTime tStart, GekkoTime tEnd, bool debug, Databank work, int obsWithLags, int obsSimPeriod, double[,] a, double[] NAN, int[] bNumberPointers, int[] endoNoLagPointers)
        {
            double[,] a2 = new double[a.GetLength(0), a.GetLength(1)];
            Array.Copy(a, a2, a.Length);
            FromDatabankToA(tStart0, tEnd, work, obsWithLags, a2, NAN);  //NOTE: put into a2 array (will be equal to a array as it were at the beginning)
            FromAToDatabank(tStart, tEnd, debug, work, obsWithLags, obsSimPeriod, a, bNumberPointers, endoNoLagPointers);
            return a2;
        }

        private static void IterationPrint(ref string culprit, GekkoTime tStart, GekkoTime t, ECompiledModelType modelType, StringBuilder output, bool isGaussConverged, SimOptions so)
        {
            string s = "";

            if (t.IsSamePeriod(tStart))
            {
                if (Program.options.solve_print_iter) G.Writeln();
            }
            if (culprit != "") culprit = G.ExtractOnlyVariableIgnoreLag(culprit);
            if (G.equal(so.method, "res"))
            {
                s += "Period " + (t) + " " + " -- single equation static forecast ";
                //G.Write(s);
            }
            else if (G.equal(so.method, "reverted"))
            {
                s += "Period " + (t) + " " + " -- reverted and after variables ";
                //G.Write(s);
            }
            else
            {
                if (isGaussConverged && (Program.options.solve_print_details || Program.options.solve_gauss_dump) && (modelType == ECompiledModelType.Gauss || modelType == ECompiledModelType.GaussFailSafe))
                {
                    s += "Period " + (t) + " " + Program.model.simulateResults[0] + " iterations   --   last conv.: " + culprit;
                    //G.Write(s);
                }
                else
                {
                    s += "Period " + (t) + " " + Program.model.simulateResults[0] + " iterations";
                    //G.Write(s);
                }
                if (G.equal(so.method, "gauss"))
                {
                    if (!isGaussConverged)
                    {
                        s += " *** NOT CONVERGED ";
                        if (culprit != "")
                        {
                            s += "(" + culprit + ")";
                        }
                    }
                }
                if (G.equal(so.method, "newton"))
                {
                    s += ",   crit = " + string.Format("{0:0.00000E+00}", Program.model.simulateResults[1]);
                }
            }
            if (Program.options.solve_print_details && G.equal(so.method, "newton"))
            {
                s += "\n";
                s += "------------------------------------------------------------------\n";
            }
            //s += "\n";

            if (Program.options.solve_print_iter)
            {
                if (s.Length != 0) G.Writeln(s);
            }
            output.AppendLine(s);
        }

        private static bool FromBToA(ref bool hasIssuedSeedWarning, double[] bCheck, int[] extraWritebackPointers, int[] revertedPointers, int[] aNumberPointers, int[] endoNoLagPointers, string[] varNamePointers, double[,] a, int tInt)
        {
            if (IsStacked())
            {
                Model thisModel = Program.model.stackedModel;
                for (int i = 0; i < thisModel.varsBType.Count; i++)
                {
                    //TODO: fix this in #84750237

                    double x1 = bCheck[i];
                    double x2 = thisModel.b[i];

                    long longX1 = BitConverter.DoubleToInt64Bits(x1);
                    long longX2 = BitConverter.DoubleToInt64Bits(x2);

                    if (longX1 != longX2)
                    {
                        string s = thisModel.varsBTypeInverted[i];
                        string[] ss = s.Split(new string[] { Globals.stackedTimeSeparator }, StringSplitOptions.None);
                        string name = ss[0];
                        string[] ss2 = ss[1].Split(new string[] { Globals.lagIndicator }, StringSplitOptions.None);
                        int offset = int.Parse(ss2[0]) - 100;
                        //using the old model .varsAType
                        int aI = Program.model.varsAType[name].aNumber;
                        int tt = tInt + offset;
                        a[aI, tt] = x2;
                        //Slack: see #98327432498

                        if (!hasIssuedSeedWarning && thisModel.b[i] == Globals.missingValueSeedNumber)
                        {
                            //For safety:
                            G.WritelnGray("DEBUGGING: It seems there may be a problem with initializing missing values: 0.123454321: " + varNamePointers[i] + " t: " + tInt + ".");
                            hasIssuedSeedWarning = true;
                        }
                    }
                }
            }
            else
            {
                for (int i = 0; i < Program.model.varsBType.Count; i++)
                {
                    //#84750237
                    //This would probably be better done by comparing Program.model.b and bCheck, and if different
                    //put it into a[]. But there are some issues with Infinity and NaN to be sorted out.
                    //For now, probably best to keep it as it is.
                    //Changing it would require investigating x.Equals(y), to see if it is appropriate for Infinity and NaN.
                    if (endoNoLagPointers[i] == 1 || revertedPointers[i] == 1 || extraWritebackPointers[i] == 1)
                    {
                        a[aNumberPointers[i], tInt] = model.b[i];
                        if (!hasIssuedSeedWarning && model.b[i] == Globals.missingValueSeedNumber)
                        {
                            //For safety:
                            G.WritelnGray("DEBUGGING: It seems there may be a problem with initializing missing values: 0.123454321: " + varNamePointers[i] + " t: " + tInt + ".");
                            hasIssuedSeedWarning = true;
                        }
                    }
                    else
                    {
                        if (Globals.simulationCheckThatAllDataGetsFromBArrayToTimeSeries)
                        {
                            if (Program.model.b[i] != bCheck[i])  //probably is false if left side is 0 and right side is NaN. Not good.
                            {
                                //should change according to b[] arrays, but does not get written back.
                                string var = Program.model.varsBTypeInverted[i];
                                G.Writeln();
                                G.Writeln("*** ERROR: While backwriting from SIM command -- please report this error to the Gekko editor");
                                G.Writeln("*** ERROR: Variable: " + var);
                                G.Writeln();
                                throw new GekkoException();
                            }
                        }
                    }
                }
            }
            return hasIssuedSeedWarning;
        }

        private static void FromAToB(bool usingFairTaylor, bool usingNewtonFairTaylor, NewtonFairTaylorHelper1 shock, int ft, ErrorContainer ec, Databank work, TimeSeries[] timeSeriesPointers, int[] extraWritebackPointers, int[] lagPointers, int[] aNumberPointers, int[] endoNoLagPointers, int[] endoLeadPointers, int[] endoPointers, string[] varNamePointers, int[] isDJZvarPointers, double[,] a, int tInt, GekkoTime t, GekkoTime tStart, GekkoTime tEnd, SimOptions so)
        {
            bool ftOrNft = usingFairTaylor || usingNewtonFairTaylor;
            if (IsStacked())
            {
                Program.model.stackedModel.b = G.CreateArrayDouble(Program.model.stackedModel.varsBType.Count, double.NaN);  //slack: do we need to initialize?
                foreach (string s in Program.model.stackedModel.varsBType.Keys)  //not too good #980753249852
                {
                    string[] ss = s.Split(new string[] {Globals.stackedTimeSeparator}, StringSplitOptions.None);
                    string name = ss[0];
                    string[] ss2 = ss[1].Split(new string[] { Globals.lagIndicator }, StringSplitOptions.None);
                    int offset = int.Parse(ss2[0]) - 100;
                    int aI = Program.model.varsAType[name].aNumber;
                    int tt = tInt + offset;
                    double value = a[aI, tt];
                    int bI = Program.model.stackedModel.varsBType[s].bNumber;
                    //Slack: aI, tInt and bI could be stored in faster containers
                    //See #98327432498
                    Program.model.stackedModel.b[bI] = value;
                }

            }
            else
            {

                for (int i = 0; i < Program.model.varsBType.Count; i++)
                {

                    /*
                     * The logic is more or less like this for the simple case with init=yes and no fair-taylor 
                     * 
                    IF series does not exist
                        IF DJZ-type series
                            create series and set value to 0
                        ELSE
                            abort with error
                    ELSE
                        IF endo with no lag   
                            use lagged value, or the value 0.12345
                        ELSE
                            IF databank value = NaN
                                IF DJZ-type series
                                    set value to 0
                                ELSE
                                    use value from databank
 
                    */


                    double val = double.NaN;
                    TimeSeries ts = timeSeriesPointers[i];
                    string variable = varNamePointers[i];
                    if (ts == null)
                    {
                        if (isDJZvarPointers[i] == 1)
                        {
                            val = 0d;  //DJZ set to 0 --> will end up in b[]
                            //J-factor or D or Z variable
                            TimeSeries tsNew = new TimeSeries(Program.options.freq, variable);
                            work.AddVariable(tsNew);
                            timeSeriesPointers[i] = tsNew;
                            extraWritebackPointers[i] = 1;  //to make sure it gets written back from b[] to a[,] array

                            //Program.model.b[i] = setValue;
                            //if it is a J type, and it has become endogenous, a 0 is fine as starting value (better than lagged J)
                        }
                        else
                        {
                            //missing variable, and not a DJZ-type variable
                            //This will probably never happen, since it gets checked before
                            G.Writeln2("*** ERROR: time series '" + variable + "' does not exist in the Work bank");
                            //FIXME: undo, or at least write if DJZ variables have been created.
                            throw new GekkoException();
                        }
                    }
                    else
                    {
                        //Variable exists in Work bank

                        //---- regarding NaN or 0 ---------
                        //  if options.solve_data_ignoremissing is true, all NaN are replaced by 0,
                        //  except lagged endogeous -- these are treated as usual (given 0.12345).
                        //---------------------------------

                        val = double.NaN;
                        int yy = aNumberPointers[i];

                        //HERE we should have a big IF, if it is NFT doing a "real" shock (not the baseline).
                        //if so, we jump directly to //oiauewrwuer


                        int alternative = -12345;
                        if (endoNoLagPointers[i] == 1 && ft == 0)
                        {
                            //Will only init if init option is = yes, and never in later FT-iterations
                            //Note that all shocks will always be set to alternative = 3 later on.
                            alternative = 1;
                        }
                        else if (Program.options.solve_data_init && ftOrNft && ft == 0 && endoLeadPointers[i] == 1)
                        {
                            alternative = 2;
                        }
                        else
                        {
                            alternative = 3;  //takes plain value
                        }
                        if (!shock.isFirstBaseline)
                        {
                            //for NFT, a lot of the simulations are used to create jacobi matrix
                            //these cases should NEVER have leaded variables initialized, since
                            //these variables are perturbed just before calling this method.
                            //Regarding the first Fair-Taylor iteration (ft = 0), the baseline 'shock'
                            //of these should be initialized (alternative 2), but the following non-baseline
                            //calls should not. Hence, these will be overwritten from alternative = 2 to
                            //alternative = 3 here.
                            alternative = 3;
                        }

                        switch (alternative)
                        {
                            case 1:
                                {
                                    //Will only init if init option is = yes
                                    InitEndoNoLag(ec, a, tInt, ref t, so, ref val, ts, yy);
                                }
                                break;
                            case 2:
                                {
                                    val = InitEndoLeaded(a, tInt, val, yy);
                                }
                                break;
                            case 3:
                                {
                                    InitEndoLaggedOrExo(extraWritebackPointers, lagPointers, endoPointers, isDJZvarPointers, a, tInt, ref t, ref tStart, ref tEnd, i, ref val, ts, variable, yy, so.isStatic);
                                }
                                break;
                        } //end switch
                    }

                    Program.model.b[i] = val;
                } //for each b[i]
            }
            return;
        }

        private static void InitEndoLaggedOrExo(int[] extraWritebackPointers, int[] lagPointers, int[] endoPointers, int[] isDJZvarPointers, double[,] a, int tInt, ref GekkoTime t, ref GekkoTime tStart, ref GekkoTime tEnd, int i, ref double val, TimeSeries ts, string variable, int yy, YesNoNull isStaticLocalOption)
        {
            //not a nolag-endogenous or lead-endogenous, so lagged endo or exogenous (may in principle be leaded exogenous)
            //these are just copied into b[] raw
            //FOR sim and fastsim, try doing it without simgauss, to see what goes into gauss


            val = a[yy, tInt + lagPointers[i]];

            if (options.solve_data_ignoremissing && double.IsNaN(val)) val = 0d;
            //this way, missing DJZ vars also get value = 0

            if (double.IsInfinity(val))
            {
                //this can be possible in successive simulations, see notes in top of method regarding .IsInfinity()
                if (isDJZvarPointers[i] == 1)
                {
                    //probably should issue warning here
                    //J-factor or D or Z variable
                    val = 0;
                    extraWritebackPointers[i] = 1;
                }
            }

            if (double.IsNaN(val))
            {
                //this can be possible for autogenerated DJZ-variables -- not for other types since these are checked above ("real" exogenous and lagged endogenous)
                if (isDJZvarPointers[i] == 1)
                {
                    //J-factor or D or Z variable
                    val = 0;
                    extraWritebackPointers[i] = 1;
                }
                else
                {
                    //real lagged endo or exo (or leaded endo/exo)
                    //it should not be possible to encounter a missing lagged endo here, since lagged endo vars are checked
                    //before simulating first period -- and program breaks if simulation does not converge.
                    //but it could be an exogenous or lagged exogenous with a missing somewhere in the simulation period.
                    //todo: write if exo, lagged endo, and the lag
                    string lag = "";
                    if (lagPointers[i] < 0) lag = Globals.leftParenthesisIndicator + lagPointers[i] + Globals.rightParenthesisIndicator;
                    else if (lagPointers[i] > 0) lag = Globals.leftParenthesisIndicator + "+" + lagPointers[i] + Globals.rightParenthesisIndicator;
                    string type = "exogenous";
                    if (endoPointers[i] == 1) type = "endogenous";

                    G.Writeln("*** ERROR while simulating " + tStart.ToString() + "-" + tEnd.ToString() + ": in " + t.ToString() + " the " + type + " variable '" + variable + lag + "' has a missing value");
                    GekkoTime tLag = t.Add(-1);
                    //G.Writeln("    Simulated " + tStart.ToString() + "-" + tLag + ", but " + t.ToString() + "-" + tEnd + " failed.");
                    bool simFailure = false;
                    if (endoPointers[i] == 1)
                    {
                        if (lagPointers[i] == -1 && t.LargerThanOrEqual(tStart))
                        {
                            G.Writeln("    The problem probably has to do with non-convergence of period " + tLag.ToString());
                            //WriteAboutFailsafeOption();  --> will issue this note 2 times, so deleted here
                        }
                        simFailure = true;
                    }
                    else
                    {
                        G.Writeln("    Please check the databank for missing data regarding exogenous variable '" + variable + "'");
                    }

                    if (simFailure) throw new GekkoException("GekkoException: simFailure");
                    else throw new GekkoException();
                    //FIXME: undo, or at least write if DJZ variables have been created.
                }
            }
            else
            {
                //TODO: check static sim -- seems ok but could need a good check (also with endo/exo stuff)
                if (CheckYesNoNullLogic(isStaticLocalOption, Program.options.solve_static))
                {
                    //This does not run fast, but is seldom used
                    //is also done for exogenous, maybe more safe only for lagged endo.
                    TimeSeries tsUndoBank = Globals.undoBank.GetVariable(ts.variableName);
                    //overrides the value -- takes it from the undoBank -- if exo there should be no change
                    val = tsUndoBank.GetData(t.Add(lagPointers[i]));
                }
            }
        }

        private static void WriteAboutFailsafeOption()
        {
            if (Program.options.solve_failsafe == true) return;
            G.Writeln("+++ NOTE: Use 'OPTION solve failsafe = yes;' to help tracking the root of the problem", Globals.warningColor);
        }

        //See #98745239543
        private static bool CheckYesNoNullLogic(YesNoNull localOption, bool globalOption)
        {
            //                  global yes        global no
            //  ----------------------------------------------
            // local yes        true              true
            // local no         false             false
            // null             true              false
            return (globalOption && localOption != YesNoNull.No) || (!globalOption && localOption == YesNoNull.Yes);
        }

        private static double InitEndoLeaded(double[,] a, int tInt, double val, int yy)
        {
            val = a[yy, tInt - 1];  //lagged value y(-1) set as init for y(+1) or y(+2) etc., but ONLY in the first FT-iteration
            return val;
        }

        private static void InitEndoNoLag(ErrorContainer ec, double[,] a, int tInt, ref GekkoTime t, SimOptions so, ref double val, TimeSeries ts, int yy)
        {
            bool endoInitUsesLag = false;
            //we know that lagPointers are always 0 here!
            if (Program.options.solve_data_init)
            {
                endoInitUsesLag = true;
                //initializing real endogenous variables
                double alag = double.NaN;
                if (tInt - 1 >= 0) alag = a[yy, tInt - 1];

                if (Program.options.solve_data_init_growth)
                {
                    double rel = double.NaN;
                    if (tInt - 2 >= 0) rel = alag / a[yy, tInt - 2];
                    val = alag;
                    if (!G.isNumericalError(rel))
                    {
                        if (rel > 1 + Program.options.solve_data_init_growth_min && rel < 1 + Program.options.solve_data_init_growth_max) val = alag * rel;
                    }
                }
                else
                {
                    val = alag;
                }
            }
            else
            {
                val = a[yy, tInt];  //no lag, just plain value
            }

            if (double.IsNaN(val) && (G.equal(so.method, "gauss") || G.equal(so.method, "newton")))  //if it is Res() or Efter() type, we should NEVER go here (where starting values for non-lagged endogenous are set to some arbitrary value
            {
                if (options.solve_data_ignoremissing == false)
                {
                    if (ec.simInitEndoMissingValueHelper == null) ec.simInitEndoMissingValueHelper = new List<string>();
                    //todo: break? like for exo part? now we get both warning and error regarding aaa in 2005 if it is set to M and we sim in 2006.
                    int lag = 0;
                    if (endoInitUsesLag) lag = 1;
                    ec.simInitEndoMissingValueHelper.Add(ts.variableName + " has a missing value in " + (t.Add(-lag)) + "          " + "sim period: " + t.ToString());
                }

                //====================================
                val = Globals.missingValueSeedNumber; //lagged value of endogenous is missing --> set to this as starting value
                //====================================
            }
        }

        private static void FromDatabankToA(GekkoTime tStart0, GekkoTime tEnd, Databank work, int obsWithLags, double[,] a, double[] NAN)
        {
            foreach (ATypeData atd in Program.model.varsAType.Values)
            {
                int length = -12345;
                string var = atd.varName;
                int id = atd.aNumber;
                int index1 = -12345;
                int index2 = -12345;
                double[] x = null;
                TimeSeries ts = work.GetVariable(var);  //Could have an A-array with TimeSeries...
                if (ts == null)
                {
                    if (IsDjz(var))
                    {
                        length = obsWithLags;
                        x = NAN;
                        index1 = 0;
                    }
                    else
                    {
                        //should not be possible: should have been caught in SimCheckFirstPeriodForMissingStuff()
                        G.Writeln2("*** ERROR: Internal Gekko error #874439849");
                        throw new GekkoException();
                    }
                }
                else
                {
                    x = ts.GetDataSequence(out index1, out index2, tStart0, tEnd, false);  //no setting of start/end period of timeseries
                    length = index2 - index1 + 1;
                }
                Buffer.BlockCopy(x, 8 * index1, a, 8 * id * obsWithLags, 8 * length);  //TODO: what if out of bounds regarding x???
                //I guess after this loop is done, the whole of a[,] will be filled with data or NaN.
                //It should not be possible that there is a 0 left originating from "double[,] a = new double[vars, obs];"
            }
        }

        public static void FromAToDatabank(GekkoTime tStart, GekkoTime tEnd, bool debug, Databank work, int obsWithLags, int obsSimPeriod, double[,] a, int[] bNumberPointers, int[] endoNoLagPointers)
        {
            //TODO: this loop could be speed-optimized. Having the list of TimeSeries pre-done would help,
            //      instead of this looping. Maybe even a list of pointers to x[]-arrays pre-done.
            //      But still, reading in and out of a[] is not that costly.
            //      HMM, is the loop also writing back exogenous vars?
            if (work.protect)
            {
                //NB: This check is here, to avoid having to do it for each timeseries later on.
                //    The data is written in a special (fast) way that does not get checked automatically regarding
                //    dirty and protect, cf. //#98726527
                G.Writeln2("*** ERROR: You are trying to simulate with a first-position databank ('" + work.aliasName + "') that is non-editable");
                throw new GekkoException();
            }
            DateTime dt4 = DateTime.Now;

            string s = O.ShowDatesAsString(tStart, tEnd);
            string src = s + "SIM " + Path.GetFileName(Program.model.modelInfo.fileName) + " (hash " + Program.model.modelHashTrue + ")";            //string stamp = Program.GetDateStampCache();
            foreach (ATypeData atd in Program.model.varsAType.Values)
            {
                string var = atd.varName;
                int id = atd.aNumber;
                TimeSeries ts = work.GetVariable(var);  //Could have an A-array with TimeSeries...
                //??? what if above is null??? << create it if djz?
                int index1 = -12345;
                int index2 = -12345;
                double[] x = ts.GetDataSequence(out index1, out index2, tStart, tEnd, true);
                //#98726527
                //we have to indicate this manually here: normally GetDataSequence() is only for getting, but here stuff is put into it (to keep the method speedy)
                ts.SetDirtyGhost(true, false);
                int length = index2 - index1 + 1;  //only done for sim period, not from tStart0 (i.e. lags)
                Buffer.BlockCopy(a, 8 * id * obsWithLags + 8 * (obsWithLags - obsSimPeriod), x, 8 * (index1), 8 * length); //TODO: what if out of bounds regarding x???
                if(bNumberPointers!=null) {
                    int b = bNumberPointers[id];
                    if(b!=-12345) {
                        if (endoNoLagPointers[b] == 1)
                        {
                            ts.source = src;
                            ts.Stamp();                            
                            ts.SetDirtyGhost(true, false);
                        }
                        else
                        {
                            //do nothing
                        }
                    }
                }
            }
            if (debug) G.WritelnGray("reading back from a[]: " + (DateTime.Now - dt4).TotalMilliseconds / 1000d);
        }

        private static bool IsDjz(string variable)
        {
            return Program.model.varsDTypeAutoGenerated.ContainsKey(variable) || Program.model.varsJTypeAutoGenerated.ContainsKey(variable) || Program.model.varsZTypeAutoGenerated.ContainsKey(variable);
        }

        private static void SimCheckFirstPeriodForMissingStuff(bool usingFairTaylor, GekkoTime tStart, ErrorContainer ec, TimeSeries[] timeSeriesPointers, int[] lagPointers, int[] endoNoLagPointers, int[] endoLeadPointers, string[] varNamePointers, int[] isDJZvarPointers)
        {
            if (true)  //for a period like 2006-2079, this check hardly consumes any time
            {
                GekkoTime t = tStart.Add(0);
                //Fail-fast check of what data is missing in order to simulate
                if (Program.databanks.GetFirst().storage.Count == 0)
                {
                    G.Writeln2("*** ERROR: There were no variables in the databank. Did you forget to load a databank?");
                    G.Writeln("           Simulation is aborted");
                    throw new GekkoException();
                }

                List<string> missingVariables = new List<string>();
                List<string> exoOrLaggedEndoWithNaN = new List<string>();

                for (int i = 0; i < Program.model.varsBType.Count; i++)
                {
                    TimeSeries ts = timeSeriesPointers[i];

                    string variable = varNamePointers[i];

                    if (ts == null)
                    {
                        if (isDJZvarPointers[i] == 1)
                        {
                            //we don't do anything about these now if they are missing:
                            //they are handled below (created and given value = 0)
                        }
                        else
                        {
                            //missing variable, and not a DJZ-type variable
                            //G.Writeln("*** ERROR: time series " + variable + " (and possibly more) does not exist in Work bank");
                            //G.Writeln("    Did you forget to load a databank? Simulation is stopped.");
                            if (!missingVariables.Contains(variable))
                            {
                                missingVariables.Add(variable);
                            }
                            //FIXME: undo, or at least write if DJZ variables have been created.
                            //return -12345;
                        }
                    }
                    else
                    {
                        //Variable exists in Work bank
                        //The variable could be a autogenerated DJZ-variable
                        int endoLag = -endoNoLagPointers[i];  //these are 0 or 1 (endo with no lag)
                        if (!Program.options.solve_data_init) endoLag = 0;  //overrides with this option. Typically for use in residual type simulation.
                        double val = ts.GetData(t.Add(lagPointers[i] + endoLag));

                        if (double.IsNaN(val))
                        {
                            if (options.solve_data_ignoremissing)
                            {
                                val = 0d;
                            }
                        }

                        if (endoNoLagPointers[i] == 1)
                        {
                            //do nothing here
                        }
                        else if (Program.options.solve_data_init && usingFairTaylor && endoLeadPointers[i] == 1)
                        {
                            //do nothing here for leaded variables
                        }
                        else
                        {
                            //not a nolag-endogenous, so lagged endo or exogenous (including DJZ-vars)
                            //endoNoLagPointers[i] = 0.

                            if (double.IsInfinity(val))
                            {
                                //value is NaN -- real problem.... not just starting value question
                                if (isDJZvarPointers[i] == 1)
                                {
                                    //this should be reported maybe: if equation is a JR: log(y) = log(x);
                                    //then y>0 and x=0 gives JR=infinity -- there is no solution. This is
                                    //ok if equation is exogenized with the dummy, but what then if the
                                    //dummy is switched off again? Sim values may jump...
                                    //Setting the J-variable to 0 is a workaround. Happens implicitly
                                    //when writing the bank, since infinity is treated as missing.
                                }
                            }

                            if (double.IsNaN(val))
                            {
                                //value is NaN -- real problem.... not just starting value question
                                if (isDJZvarPointers[i] == 1)
                                {
                                    //see notes regarding .IsInfinity() above
                                }
                                else
                                {
                                    //real lagged endo or exo
                                    //todo: write if exo, lagged endo, and the lag
                                    //G.Writeln("*** ERROR: In period " + (t + lagPointers[i]) + " the variable " + variable + " has a missing");
                                    //G.Writeln("    value. Please check your data bank -- simulation is not performed.");
                                    //FIXME: undo, or at least write if DJZ variables have been created.
                                    //return -12345;

                                    string s = "";
                                    if (lagPointers[i] <= 0) s = variable + "[" + lagPointers[i] + "]";
                                    else s = variable + "[+" + lagPointers[i] + "]";

                                    if (!exoOrLaggedEndoWithNaN.Contains(s))
                                    {
                                        exoOrLaggedEndoWithNaN.Add(s);
                                    }
                                }
                            }
                        }
                    }
                }

                if (missingVariables.Count > 0)
                {
                    if (ec.simNonExistingVariable == null) ec.simNonExistingVariable = new List<string>();
                    missingVariables.Sort(StringComparer.InvariantCulture);
                    ec.simNonExistingVariable.Add("When model variables do not exist in the databank, simulation can not be");
                    ec.simNonExistingVariable.Add("performed. Please make sure the variable(s) exist before simulating.");
                    ec.simNonExistingVariable.Add("There were " + missingVariables.Count + " missing variable(s):");
                    ec.simNonExistingVariable.Add("");
                    StringBuilder sb = new StringBuilder();
                    int count = 0;
                    foreach (string s in missingVariables)
                    {
                        count++;
                        string blank = "";
                        if (count > 0) blank = Globals.blankUsedAsPadding;
                        string count2 = count.ToString();
                        ec.simNonExistingVariable.Add(blank + " " + G.Blanks(4 - count2.Length) + "#" + count + ": The variable " + s + " does not exist in Work databank");
                    }
                    ec.simNonExistingVariable.Add("");
                }

                if (exoOrLaggedEndoWithNaN.Count > 0)
                {
                    if (ec.simMissingValueExoOrLaggedEndo == null) ec.simMissingValueExoOrLaggedEndo = new List<string>();
                    exoOrLaggedEndoWithNaN.Sort(StringComparer.InvariantCulture);
                    ec.simMissingValueExoOrLaggedEndo.Add("When there are missing values regarding exogenous variables or lagged endogenous variables,");
                    ec.simMissingValueExoOrLaggedEndo.Add("simulation can not be performed. Please make sure the relevant data exist before simulating.");
                    ec.simMissingValueExoOrLaggedEndo.Add("There were " + exoOrLaggedEndoWithNaN.Count + " variables with missing values:");
                    ec.simMissingValueExoOrLaggedEndo.Add("");
                    DateTime t0 = DateTime.Now;
                    StringBuilder sb = new StringBuilder();
                    int count = 0;
                    foreach (string s in exoOrLaggedEndoWithNaN)
                    {
                        count++;
                        string s2 = s.Replace("[0]", "");
                        //s2 = s2.Replace("[", "(");
                        //s2 = s2.Replace("]", ")");
                        string count2 = count.ToString();
                        string blank = "";
                        if (count > 0) blank = Globals.blankUsedAsPadding;
                        ec.simMissingValueExoOrLaggedEndo.Add(blank + " " + G.Blanks(4 - count2.Length) + "#" + count + ": Period " + tStart + ": variable " + s2 + " had a missing value in Work databank");
                    }
                    ec.simMissingValueExoOrLaggedEndo.Add("");
                }

                if (missingVariables.Count > 0 || exoOrLaggedEndoWithNaN.Count > 0)
                {
                    //G.writeAbstractScroll("", null, true, Color.Empty, false, ETabs.Output, true);
                    G.Writeln2("*** ERROR: Gekko had problems simulating the first period in the simulation (" + t + "):");
                    if (missingVariables.Count > 0)
                    {
                        G.Write("    There were "); G.WriteLink(missingVariables.Count.ToString() + " missing variables", "tab:output" + ec.counter + "b"); G.Writeln(".");
                    }
                    if (exoOrLaggedEndoWithNaN.Count > 0)
                    {
                        G.Write("    There were missing values in "); G.WriteLink(exoOrLaggedEndoWithNaN.Count.ToString() + " variables", "tab:output" + ec.counter + "c"); G.Writeln(".");
                    }
                    G.Writeln();
                    if (!Globals.outputTabTextContainer.ContainsKey(ec.counter.ToString()))
                    {
                        Globals.outputTabTextContainer.Add(ec.counter.ToString(), ec);
                    }
                    throw new GekkoException();
                }
            }
        }

        private static void SolveRevertedAuto()
        {
            Object[] args2 = new Object[1];
            args2[0] = Program.model.b;
            Program.model.assemblyReverted.InvokeMember("revertedAuto", BindingFlags.InvokeMethod, null, null, args2);
        }

        private static void SolveRevertedY()
        {
            Object[] args2 = new Object[1];
            args2[0] = Program.model.b;
            Program.model.assemblyReverted.InvokeMember("revertedY", BindingFlags.InvokeMethod, null, null, args2);
        }

        private static void SolveAfter()
        {
            //Parser.OrderAndCompileModel(ECompiledModelType.After, false);
            Object[] args2 = new Object[1];
            args2[0] = Program.model.b;
            Program.model.assemblyAfter.InvokeMember("after", BindingFlags.InvokeMethod, null, null, args2);
            Program.model.assemblyAfter.InvokeMember("after2", BindingFlags.InvokeMethod, null, null, args2);
        }

        private static void SolveNewton(ECompiledModelType modelType, NewtonAlgorithmHelper nah)
        {

            //bit of a hack
            Program.model.m2.fromEqNumberToBNumber = Program.model.m2.fromEqNumberToBNumberFeedbackNEW;
            Program.model.m2.fromBNumberToEqNumber = Program.model.m2.fromBNumberToEqNumberFeedbackNEW;

            Object[] args = new Object[1];
            args[0] = Program.model.b;
            Program.model.m2.assemblyPrologueEpilogue.InvokeMember("prologue", BindingFlags.InvokeMethod, null, null, args);

            args = new Object[1];
            args[0] = Program.model.b;
            Program.model.m2.assemblyNewton.InvokeMember("simulPrologue", BindingFlags.InvokeMethod, null, null, args);

            Program.SolveNewtonAlgorithm(Program.model.b, Program.model.m2.assemblyNewton, nah);

            args = new Object[1];
            args[0] = Program.model.b;
            Program.model.m2.assemblyPrologueEpilogue.InvokeMember("epilogue", BindingFlags.InvokeMethod, null, null, args);

            Object[] args2 = new Object[1];
            args2[0] = Program.model.b;
            Program.model.assemblyReverted.InvokeMember("revertedAuto", BindingFlags.InvokeMethod, null, null, args2);
            Program.model.assemblyReverted.InvokeMember("revertedY", BindingFlags.InvokeMethod, null, null, args2);
        }

        private static ECompiledModelType GetModelTypeFromOptions(SimOptions so)
        {
            ECompiledModelType modelType = ECompiledModelType.Unknown;
            if (G.equal(so.method, "gauss"))
            {
                if (Program.options.solve_failsafe)
                {
                    modelType = ECompiledModelType.GaussFailSafe;
                }
                else modelType = ECompiledModelType.Gauss;
            }
            else if (G.equal(so.method, "res"))
            {
                modelType = ECompiledModelType.Res;
            }
            else if (G.equal(so.method, "newton"))
            {
                modelType = ECompiledModelType.Newton;
            }
            else if (G.equal(so.method, "reverted"))
            {
                modelType = ECompiledModelType.After;
            }
            else throw new GekkoException();
            return modelType;
        }



        public static void Time(GekkoTime t1, GekkoTime t2)
        {
            if (t1.freq != Program.options.freq)
            {
                G.Writeln2("*** ERROR: Using DATE with freq " + t1.freq.ToString() + " in a " + Program.options.freq.ToString() + " setting");
                throw new GekkoException();
            }
            if (t2.freq != Program.options.freq)
            {
                G.Writeln2("*** ERROR: Using DATE with freq " + t2.freq.ToString() + " in a " + Program.options.freq.ToString() + " setting");
                throw new GekkoException();
            }
            Globals.globalPeriodStart = t1;
            Globals.globalPeriodEnd = t2;
            G.Writeln2("Global time set: " + G.FromDateToString(t1) + " to " + G.FromDateToString(t2));

            //if (Globals.runningOnTTComputer)
            //{
            //    object[] oo = new object[1];
            //    oo[0] = 2d;
            //    Try1(oo);
            //    Try2(oo);
            //}
        }

        private static void Try1(object[] oo)
        {
            CodeDomProvider provider = new CSharpCodeProvider();
            CompilerParameters parameters = new CompilerParameters();


            CompilerResults results = provider.CompileAssemblyFromSource(parameters, @"
            namespace Dynamic
            {
                public static class A
                {
                    public static double fff(double x) { return x*x; }
                }
            }
            ");

            Assembly assem = results.CompiledAssembly;


            CodeDomProvider provider2 = new CSharpCodeProvider();
            CompilerParameters parameters2 = new CompilerParameters();

            parameters2.ReferencedAssemblies.Add(assem.Location);
            //parameters2.GenerateInMemory = true;

            CompilerResults results2 = provider2.CompileAssemblyFromSource(parameters2, @"
            namespace Dynamic
            {
                public static class B
                {
                    public static double ggg(double x) { return A.fff(2.0) + x+1d; }
                }
            }
            ");


            Assembly assem2 = results2.CompiledAssembly;
            Type assembly = assem2.GetType("Dynamic.B");  //the class
            double d = 2;

            Object ret = assembly.InvokeMember("ggg", BindingFlags.InvokeMethod, null, null, oo);  //the method
            G.Writeln2("return: " + ((double)ret));
        }

        private static void Try2(object[] oo)
        {
            CodeDomProvider provider = new CSharpCodeProvider();
            CompilerParameters parameters = new CompilerParameters();


            CompilerResults results = provider.CompileAssemblyFromSource(parameters, @"
            namespace Dynamic
            {
                public static class A
                {
                    public static double fff(double x) { return x*x*x; }
                }
            }
            ");

            Assembly assem = results.CompiledAssembly;


            CodeDomProvider provider2 = new CSharpCodeProvider();
            CompilerParameters parameters2 = new CompilerParameters();
            parameters2.ReferencedAssemblies.Add(assem.Location);
            //parameters2.GenerateInMemory = true;

            CompilerResults results2 = provider2.CompileAssemblyFromSource(parameters2, @"
            namespace Dynamic
            {
                public static class B
                {
                    public static double ggg(double x) { return A.fff(2.0) + x+1d; }
                }
            }
            ");


            Assembly assem2 = results2.CompiledAssembly;
            Type assembly = assem2.GetType("Dynamic.B");  //the class
            double d = 2;

            Object ret = assembly.InvokeMember("ggg", BindingFlags.InvokeMethod, null, null, oo);  //the method
            G.Writeln2("return: " + ((double)ret));
        }

        //private static void Try2(object[] oo)
        //{
        //    CompilerParameters parameters = new CompilerParameters();
        //    CodeDomProvider provider777 = new CSharpCodeProvider();
        //    CompilerResults results777 = provider777.CompileAssemblyFromSource(parameters, @"
        //    namespace Dynamic
        //    {
        //        public static class A
        //        {
        //            public static double fff(double x) { return x*x*x; }
        //        }
        //    }
        //    ");
        //    Assembly assem777 = results777.CompiledAssembly;
        //    //provider2 = new CSharpCodeProvider();
        //    CompilerParameters parameters777 = new CompilerParameters();
        //    parameters777.ReferencedAssemblies.Add(assem777.Location);

        //    Assembly assem777_2 = results777.CompiledAssembly;
        //    Type assembly777_2 = assem777.GetType("Dynamic.B");  //the class                    
        //    Object ret777 = assembly777_2.InvokeMember("ggg", BindingFlags.InvokeMethod, null, null, oo);  //the method
        //    G.Writeln2("return: " + ((double)ret777));
        //}

        public static void TimeFilter(O.TimeFilter o)
        {
            GekkoTimeSpans gtss = new GekkoTimeSpans();
            foreach (O.TimeFilterHelper tfh in o.timeFilterPeriods)
            {
                //This translation is a bit stupid since the two collections are almost identical
                //But never mind: this is not speed critical code.
                if (tfh.to.IsNull())
                {
                    gtss.data.Add(new GekkoTimeSpan(tfh.from, tfh.from, tfh.step));  //duplicating
                }
                else
                {
                    gtss.data.Add(new GekkoTimeSpan(tfh.from, tfh.to, tfh.step));
                }
            }
            Globals.globalPeriodTimeFilters = gtss;

            List<GekkoTime> positiveFilter = new List<GekkoTime>();
            List<GekkoTime> negativeFilter = new List<GekkoTime>();
            foreach (GekkoTimeSpan gts in Globals.globalPeriodTimeFilters.data)
            {
                int counter = 0;
                foreach (GekkoTime t in new GekkoTimeIterator( gts.tStart, gts.tEnd))
                {
                    if (counter % gts.by == 0)
                    {
                        positiveFilter.Add(t);  //dublets will be ok... should be Dictionary in the longer run...
                    }
                    counter++;
                }
            }
            List<string> chosen = new List<string>();
            List<string> filtered = new List<string>();
            GekkoTime gtLag = Globals.tNull;

            foreach (GekkoTime gt in positiveFilter)
            {
                if (!gtLag.IsNull())
                {
                    if (!gt.StrictlyLargerThan(gtLag))
                    {
                        G.Writeln();
                        G.Writeln2("*** ERROR: TIMEFILTER sequence problem: '" + G.FromDateToString(gtLag) + "' should be larger than '" + G.FromDateToString(gt) + "'");
                        G.Writeln("           Please check your TIMEFILTER command", Color.Red);
                        throw new GekkoException();
                    }
                    else
                    {
                        int dif = GekkoTime.Observations(gtLag, gt) - 1;
                        if (dif > 1)  //period 2000:2001 is 2 obs for example (both start and end counting)
                        {
                            //Actually this dif check should not be necessary, but the problem is that the
                            //iterator is ill-defined if start date is > end date. In that case, the start
                            //date will be iterated once... Too dangerous to fix right now, so we do the
                            //explicit check.
                            //For instance, if gtLag = 2000 and gt=2001, we will iterate between 2001 and 2000 to get
                            //the filtered periods, which should not include 2001. The dif check handles this case.
                            foreach (GekkoTime gt2 in new GekkoTimeIterator( gtLag.Add(1), gt.Add(-1)))
                            {
                                negativeFilter.Add(gt2);
                                filtered.Add(G.FromDateToString(gt2));
                            }
                        }
                    }
                }
                chosen.Add(G.FromDateToString(gt));
                gtLag = gt;
            }
            //f.Sort();  is already in sequence
            G.Writeln();
            G.Write("Chosen periods: ");
            if (chosen.Count > 0)
            {
                G.PrintListWithCommas(chosen, false);
            }
            else G.Writeln("[none]");
            G.Write("Hidden periods: ");
            if (filtered.Count > 0)
            {
                G.PrintListWithCommas(filtered, false);
            }
            else
            {
                G.Writeln("[none]");
                G.Writeln("+++ WARNING: Nothing is filtered out, so filter has no effect!");
            }
            Globals.globalPeriodTimeFilters2 = negativeFilter;
            if (Program.options.timefilter == false)
            {
                Program.options.timefilter = true;
                G.Writeln("Time filtering is switched on (OPTION timefilter = yes)");
            }
        }

        public static bool ShouldFilterPeriod(GekkoTime t)
        {
            if (!Program.options.timefilter) return false;
            bool shouldFilter = false;
            if (Globals.globalPeriodTimeFilters2.Count > 0)
            {
                foreach (GekkoTime tFilter in Globals.globalPeriodTimeFilters2)
                {
                    if (t.IsSamePeriod(tFilter))
                    {
                        shouldFilter = true;
                        break;
                    }
                }
            }
            return shouldFilter;
        }

        
        /// <summary>
        /// Execute a <b style="color:black;background-color:#ff9999">shell</b> command
        /// </summary>
        /// <param name="_CommandLine">Command line parameters to pass</param>        
        public static void ExecuteShellCommand(string _CommandLine, bool mute)
        {
            //To get it dynamically, maybe this?: https://stackoverflow.com/questions/12678407/getting-command-line-output-dynamically

            bool fail = false;
            // Set process variable
            // Provides access to local and remote processes and enables you to start and stop local <b style="color:black;background-color:#99ff99">system</b> processes.
            System.Diagnostics.Process process = null;
            try
            {
                process = new System.Diagnostics.Process();
                // invokes the cmd process specifying the command to be executed.
                string _CMDProcess = string.Format(System.Globalization.CultureInfo.InvariantCulture, @"{0}\cmd.exe", new object[] { Environment.SystemDirectory });
                // pass executing file to cmd (Windows command interpreter) as a arguments
                // /C tells cmd that we want it to execute the command that follows, and then exit.
                //string _Arguments = string.Format(System.Globalization.CultureInfo.InvariantCulture, "/C {0}", new object[] { _FileToExecute });
                string _Arguments = "";
                // pass any command line parameters for execution
                if (_CommandLine != null && _CommandLine.Length > 0)
                {
                    _Arguments = string.Format(System.Globalization.CultureInfo.InvariantCulture, "/C {0}", new object[] { _CommandLine, System.Globalization.CultureInfo.InvariantCulture });
                }                
                // sets a value indicating not to start the process in a new window.
                process.StartInfo.CreateNoWindow = true;
                // sets a value indicating not to use the operating system shell to start the process.
                process.StartInfo.UseShellExecute = false;
                // sets a value that indicates the output/input/error of an application is written to the Process.
                process.StartInfo.RedirectStandardOutput = true;
                process.StartInfo.RedirectStandardInput = false;
                process.StartInfo.RedirectStandardError = true;
                process.StartInfo.WorkingDirectory = Program.options.folder_working;
                process.StartInfo.Arguments = _Arguments;
                process.StartInfo.FileName = _CMDProcess;
                //process.StartInfo = p;
                // Starts a process resource and associates it with a Process component.

                int timeout = 7 * 24 * 60 * 60 * 1000; //7*24 hours

                //See https://stackoverflow.com/questions/139593/processstartinfo-hanging-on-waitforexit-why?lq=1

                StringBuilder output = new StringBuilder();
                StringBuilder error = new StringBuilder();
                using (AutoResetEvent outputWaitHandle = new AutoResetEvent(false))
                using (AutoResetEvent errorWaitHandle = new AutoResetEvent(false))
                {
                    process.OutputDataReceived += (sender, e) => {
                        if (e.Data == null)
                        {
                            outputWaitHandle.Set();
                        }
                        else
                        {
                            output.AppendLine(e.Data);
                        }
                    };
                    process.ErrorDataReceived += (sender, e) =>
                    {
                        if (e.Data == null)
                        {
                            errorWaitHandle.Set();
                        }
                        else
                        {
                            error.AppendLine(e.Data);
                        }
                    };

                    process.Start();

                    process.BeginOutputReadLine();
                    process.BeginErrorReadLine();

                    if (process.WaitForExit(timeout) &&
                        outputWaitHandle.WaitOne(timeout) &&
                        errorWaitHandle.WaitOne(timeout))
                    {
                        // Process completed. Check process.ExitCode here.
                    }
                    else
                    {
                        // Timed out.
                    }
                }                
                
                int exitCode = process.ExitCode;
                if (exitCode != 0)
                {
                    G.Writeln2("*** ERROR: SYS command exited with exit code: " + exitCode);
                    G.Writeln("           SYS command: " + _CommandLine);
                    fail = true;
                }

                if (!mute)
                {
                    int widthRemember = Program.options.print_width;
                    int fileWidthRemember = Program.options.print_filewidth;
                    Program.options.print_width = int.MaxValue;
                    Program.options.print_filewidth = int.MaxValue;
                    try
                    {
                        G.Writeln2(output.ToString());
                        if (error.Length > 0)
                        {
                            G.Writeln2("=================== SYS error message ===================");
                            G.Writeln2(error.ToString());
                        }
                    }
                    catch (Exception e)
                    {
                        G.Writeln2("*** ERROR: Could not write output from SYS command");
                        throw new GekkoException();
                    }
                    finally
                    {
                        //resetting, also if there is an error
                        Program.options.print_width = widthRemember;
                        Program.options.print_filewidth = fileWidthRemember;
                    }
                }    
            }
            catch (Win32Exception _Win32Exception)
            {
                // Error
                Console.WriteLine("Win32 Exception caught in process: {0}", _Win32Exception.ToString());
            }
            catch (Exception _Exception)
            {
                // Error
                Console.WriteLine("Exception caught in process: {0}", _Exception.ToString());
            }
            finally
            {
                // close process and do cleanup
                process.Close();
                process.Dispose();
                process = null;
            }
            if (fail) throw new GekkoException();
        }

        /// <summary>Use this function like string.Split but instead of a character to split on,
        /// use a maximum line width size. This is similar to a Word Wrap where no words will be split.</summary>
        /// Note if the a word is longer than the maxcharactes it will be trimmed from the start.
        /// <param name="initial">The string to parse.</param>
        /// <param name="MaxCharacters">The maximum size.</param>
        /// <remarks>This function will remove some white space at the end of a line, but allow for a blank line.</remarks>
        ///
        /// <returns>An array of strings.</returns>
        public static List<string> SplitOn(string initial, int MaxCharacters)
        {
            List<string> lines = new List<string>();
            if (string.IsNullOrEmpty(initial) == false)
            {
                string targetGroup = "Line";
                string theRegex = string.Format(@"(?<{0}>.{{1,{1}}})(?:\W|$)", targetGroup, MaxCharacters);

                MatchCollection matches = Regex.Matches(initial, theRegex, RegexOptions.IgnoreCase
                                                                          | RegexOptions.Multiline
                                                                          | RegexOptions.ExplicitCapture
                                                                          | RegexOptions.CultureInvariant
                                                                          | RegexOptions.Compiled);
                if (matches != null)
                    if (matches.Count > 0)
                        foreach (Match m in matches)
                            lines.Add(m.Groups[targetGroup].Value);
            }

            return lines;
        }

        public static List<string> SplitOn2(string initial, int MaxCharactersFirstLine, int MaxCharacters)
        {

            List<string> lines = new List<string>();

            if (string.IsNullOrEmpty(initial) == false)
            {
                string targetGroup = "Line";
                string theRegex = string.Format(@"(?<{0}>.{{1,{1}}})(?:\W|$)", targetGroup, MaxCharacters);

                MatchCollection matches = Regex.Matches(initial, theRegex, RegexOptions.IgnoreCase
                                                                          | RegexOptions.Multiline
                                                                          | RegexOptions.ExplicitCapture
                                                                          | RegexOptions.CultureInvariant
                                                                          | RegexOptions.Compiled);
                if (matches != null)
                    if (matches.Count > 0)
                        foreach (Match m in matches)
                            lines.Add(m.Groups[targetGroup].Value);
            }

            return lines;
        }

        public static void UndoSim()
        {
            //ErrorIfDatabanksSwapped();
            if (Globals.undoBank == null)
            {
                G.Writeln2("*** ERROR: Undo databank does not exist");
                throw new GekkoException();
            }
            else
            {
                Databank work = Program.databanks.GetFirst();
                work.Clear();
                G.CloneDatabank(work, Globals.undoBank);
                if (!Globals.setPrintMute) G.Writeln("Old databank re-established");
            }
        }

        public static void Updprt(List<BankNameVersion> vars, GekkoTime tStart, GekkoTime tEnd, string op, string file)
        {
            if (op == "#")
            {
                G.Writeln2("*** ERROR: The '#' operator is not supported in EXPORT<series>");
                throw new GekkoException();
            }
            if (G.equal(op, "mp"))
            {
                G.Writeln2("*** ERROR: The 'mp' operator is not supported in EXPORT<series>");
                throw new GekkoException();
            }

            int type = 0;
            if (op == "=" || op == "^" || op == "%" || op == "+" || op == "*") type = 1;
            if (G.equal(op, "n") || G.equal(op, "d") || G.equal(op, "p") || G.equal(op, "m") || G.equal(op, "q")) type = 2;
            if (type == 0)
            {
                G.Writeln2("*** ERROR: Operator type '" + op + "' not recognized");
                throw new GekkoException();
            }

            //Databank work = Program.databanks.GetFirst();
            Databank base2 = Program.databanks.GetRef();

            file = AddExtension(file, "." + Globals.extensionCommand);
            string pathAndFilename = CreateFullPathAndFileNameFromFolder(file, Program.options.folder_working);
            if (File.Exists(pathAndFilename))
            {
                G.Writeln2("*** ERROR: The ." + Globals.extensionCommand + " file '" + pathAndFilename + "' already exists");
                G.Writeln("           Please remove it, for instance with SYS 'del <filename>';", Color.Red);
                G.Writeln("           This is to avoid overwriting a 'real' ." + Globals.extensionCommand + " file.", Color.Red);
                throw new GekkoException();
            }
            using (FileStream fs = WaitForFileStream(pathAndFilename, GekkoFileReadOrWrite.Write))
            using (StreamWriter sw = G.GekkoStreamWriter(fs))
            {
                string var;
                for (int j = 0; j < vars.Count; j++)
                {                    
                    var = vars[j].name;

                    Databank db = GetBankFromBankNameVersion(vars[j].bank);

                    var = G.GetUpperLowerCase(var);

                    if (!db.ContainsVariable(var))
                    {
                        G.Writeln2("*** ERROR: UPDPRT: Variable '" + var + "' not found in '" + db.aliasName + "' databank");
                        throw new GekkoException();
                    }

                    if (op == "*" || op == "+" || G.equal(op, "q") || G.equal(op, "m"))
                    {
                        if (!base2.ContainsVariable(var))
                        {
                            G.Writeln2("*** ERROR: UPDPRT: Variable '" + var + "' not found in reference databank -- necessary for operator '" + op + "'");
                            throw new GekkoException();
                        }
                    }

                    TimeSeries ts = db.GetVariable(var);

                    TimeSeries tsBase = null;
                    if (op == "*" || op == "+" || G.equal(op, "q") || G.equal(op, "m"))
                    {
                        tsBase = base2.GetVariable(var);
                    }

                    string var2 = var;
                    //for instance fy%q for fy in quarter freq

                    StringBuilder sb = new StringBuilder();
                    if (type == 1) sb.Append("SERIES <" + tStart.ToString() + " " + tEnd.ToString() + "> " + var + " " + op + "  ");
                    else sb.Append("SERIES <" + tStart.ToString() + " " + tEnd.ToString() + " " + op + "> " + var + " =  ");
                    foreach (GekkoTime t in new GekkoTimeIterator(tStart, tEnd))
                    {
                        double val = double.NaN;
                        double w = ts.GetData(t);
                        double wLag = ts.GetData(t.Add(-1));

                        double b = double.NaN;
                        double bLag = double.NaN;  //well, not use at the moment

                        if (op == "*" || op == "+" || G.equal(op, "q") || G.equal(op, "m"))
                        {
                            b = tsBase.GetData(t);
                            bLag = tsBase.GetData(t.Add(-1));
                        }

                        if (op == "=" || op == "n")
                        {
                            val = w;
                        }
                        else if (op == "^" || op == "d")
                        {
                            val = w - wLag;
                        }
                        else if (op == "%" || op == "p")
                        {
                            val = (w / wLag - 1) * 100d;
                        }
                        else if (op == "+" || op == "m")
                        {
                            val = w - b;
                        }
                        else if (op == "*")
                        {
                            val = w / b;
                        }
                        else if (op == "q")
                        {
                            val = (w / b - 1) * 100d;
                        }

                        int decimals = 6;
                        if (op == "*") decimals = 8;
                        string valstring = G.updprtFormat(val, decimals); //6 decimals, must be enough also for interest rates etc.

                        valstring = valstring.Trim();  //necesssary?
                        sb.Append(valstring + "  ");
                    }
                    sb.Append(";");
                    sw.WriteLine(sb);
                }
            }
            G.Writeln2("Exported " + vars.Count + " variables to file " + pathAndFilename);
        }

        public static void Genr()
        {
            //ErrorIfDatabanksSwapped();
        }



        public static GekkoTuple.Tuple2 GenrTuple(string function, IVariable list1, IVariable list2, GekkoTime indexYear, GekkoTime tStart, GekkoTime tEnd)
        {
            //ErrorIfDatabanksSwapped();

            if (!(Program.options.freq == EFreq.Annual))
            {
                G.Writeln();
                G.Writeln2("*** ERROR: Index functions only work for annual frequency at the moment");
                throw new GekkoException();
            }                        
                        
            int indexYearI = -12345;
            int counter = -1;
            bool found = false;
            foreach (GekkoTime t in new GekkoTimeIterator(tStart, tEnd))  //fix for other freqs
            {
                counter++;
                if (t.IsSamePeriod(indexYear))
                {
                    found = true;
                    indexYearI = counter;
                    break;
                }
            }

            if (!found)
            {
                G.Writeln();
                G.Writeln("*** ERROR with index year in Laspeyres function: seems outside time period");
                throw new GekkoException();
            }                      

            List<string> varsP = ((MetaList)list1).list;
            List<string> varsX = ((MetaList)list2).list;

            if (varsP.Count == 0 || varsX.Count == 0)
            {
                G.Writeln();
                G.Writeln("*** ERROR: list with 0 elements not permitted");
                throw new GekkoException();
            }

            if (varsP.Count != varsX.Count)
            {
                G.Writeln();
                G.Writeln("*** ERROR: the lists should have same number of elements");
                throw new GekkoException();
            }

            foreach (string s in varsP)
            {
                if (s.StartsWith("-"))
                {
                    G.Writeln();
                    G.Writeln("*** ERROR: '" + s + "': Please use subtraction in quantity list only");
                    throw new GekkoException();
                }
            }

            double[,] aX = PutTimeseriesIntoArrayPossiblyNegative(tStart, tEnd, varsX);
            double[,] aP = PutTimeseriesIntoArrayPossiblyNegative(tStart, tEnd, varsP);
            int obs = GekkoTime.Observations(tStart, tEnd);
            int obs2 = GekkoTime.Observations(tStart, indexYear);

            double[,] xx = new double[5, obs];
            //Seems [3, ...] is not used

            if (G.equal(function, "laspchain"))
            {
                double index = 1d;
                xx[4, 0] = 1d;
                for (int i = 0; i < obs; i++)
                {
                    double sum = 0d;
                    double sum1 = 0d;
                    for (int j = 0; j < varsX.Count; j++)
                    {
                        sum += aX[j, i] * aP[j, i];
                        if (i > 0) sum1 += aX[j, i] * aP[j, i - 1];
                    }
                    xx[0, i] = sum;  //total cost
                    xx[1, i] = sum1;  //total cost at previous period prices
                    if (i > 0)
                    {
                        xx[2, i] = xx[1, i] / xx[0, i - 1];  //lasp.indexet år for år: C(plag) / C(p).lag
                        index = index * xx[2, i];
                        xx[4, i] = index;                    //lasp.indexet ganget op (1 i startperiode)
                                                             //xx[4,...] is the quantity index
                    }
                }
            }
            else if (G.equal(function, "laspfixed"))
            {
                for (int i = 0; i < obs; i++)
                {
                    double sum = 0d;
                    double sum1 = 0d;
                    for (int j = 0; j < varsX.Count; j++)
                    {
                        sum += aX[j, i] * aP[j, i];
                        sum1 += aX[j, i] * aP[j, indexYearI];
                    }
                    xx[0, i] = sum;  //total cost
                    xx[1, i] = sum1;  //total cost at index period prices
                    xx[4, i] = sum1; //xx[4,...] is the quantity index
                }
            }
            else
            {
                throw new GekkoException();
            }

            TimeSeries p = new TimeSeries(EFreq.Annual, null);
            TimeSeries x = new TimeSeries(EFreq.Annual, null);

            //List<string> vars = new List<string>();
            //vars.Add(var1);
            //vars.Add(var2);

            //foreach (string var in vars)
            //{
            //    CreateXxVariableOrIssueError(work, var);
            //}

            //TimeSeries p = work.GetVariable(var1);
            //TimeSeries x = work.GetVariable(var2);

            double priceInIndexYear = xx[0, indexYearI] / xx[4, indexYearI];
            counter = -1;
            foreach (GekkoTime t in new GekkoTimeIterator(tStart, tEnd))
            {
                counter++;

                if (true)  //price = 1 in index year
                {
                    x.SetData(t, xx[4, counter] * priceInIndexYear);
                    p.SetData(t, xx[0, counter] / xx[4, counter] / priceInIndexYear);
                }
                else
                {
                    //FIXME
                    //4 skal være = 0 in index
                    x.SetData(t, xx[4, counter] / xx[4, indexYearI] * xx[0, indexYearI]);
                    p.SetData(t, xx[0, counter] / xx[4, counter] / priceInIndexYear);
                }
            }

            MetaTimeSeries mp = new MetaTimeSeries(p);
            MetaTimeSeries mx = new MetaTimeSeries(x);
            return new GekkoTuple.Tuple2(mp, mx);
        }


        private static void CreateXxVariableOrIssueError(Databank work, string var)
        {
            if (!work.ContainsVariable(var))
            {
                if (var.ToLower().StartsWith("xx", true, null))
                {
                    //only vars beginning with "xx"
                    TimeSeries tsNew = new TimeSeries(Program.options.freq, var);
                    work.AddVariable(tsNew);
                }
                else
                {
                    IssueCreateWarning(var);
                }
            }
        }

        //==============================================================
        //==============================================================
        //==============================================================



        public static void Upd(O.Upd o)
        {
            //We start with expansion of o.data (regarding REP n, REP *)

            ESeriesUpdTypes updType = ESeriesUpdTypes.none;
            if (G.equal(o.opt_d, "yes")) updType = ESeriesUpdTypes.d;
            else if (G.equal(o.opt_p, "yes")) updType = ESeriesUpdTypes.p;
            else if (G.equal(o.opt_m, "yes")) updType = ESeriesUpdTypes.m;
            else if (G.equal(o.opt_q, "yes")) updType = ESeriesUpdTypes.q;
            else if (G.equal(o.opt_mp, "yes")) updType = ESeriesUpdTypes.mp;
            else if (G.equal(o.opt_n, "yes")) updType = ESeriesUpdTypes.n;

            if (o.op != "=" && updType != ESeriesUpdTypes.none)
            {
                G.Writeln2("*** ERROR: You cannot mix <" + updType.ToString() + "> and '" + o.op + "' operator at the same time");
                throw new GekkoException();
            }

            bool updTypeDollar = false;

            if (G.equal(o.opt_keep, "p"))
            {
                updTypeDollar = true;
            }
            else
            {
                if (o.opt_keep != null)
                {
                    G.Writeln2("*** ERROR: Only <keep=p> is supported at the moment");
                    throw new GekkoException();
                }
            }

            if (o.opDollar && updTypeDollar)
            {
                G.Writeln2("*** ERROR: You cannot use <keep> and the '$' operator at the same time");
                throw new GekkoException();
            }

            GekkoTime tStart = o.t1;
            GekkoTime tEnd = o.t2;
            int expectedNumberOfObservations = GekkoTime.Observations(tStart, tEnd);

            List<double> data2 = new List<double>();
            bool enlarge = false;
            for (int i = 0; i < o.data.Length; i++)
            {
                double data = o.data[i];
                double rep = o.rep[i];

                if (rep == 1d)
                {
                    data2.Add(data);
                }
                else if (rep == -12345d)
                {
                    if (i != o.data.Length - 1)
                    {
                        G.Writeln2("*** ERROR: You can only use 'REP *' on the last UPD item");
                        throw new GekkoException();
                    }
                    data2.Add(data);
                    enlarge = true;
                }
                else
                {
                    int repI = (int)rep;

                    if (repI != rep)
                    {
                        G.Writeln2("*** ERROR: UPD: REP " + rep + " is not an integer value");
                        throw new GekkoException();
                    }

                    if (repI < 1)
                    {
                        G.Writeln2("*** ERROR: UPD: REP " + repI + " should not be zero or negative");
                        throw new GekkoException();
                    }
                    else if (repI > 10000)
                    {
                        G.Writeln2("*** ERROR: UPD: REP " + repI + " seems too large... (> 10.000)");
                        throw new GekkoException();
                    }
                    //Now we know that repI is 1, 2, 3, ... up to a resonable number
                    for (int j = 0; j < repI; j++)
                    {
                        data2.Add(data);
                    }
                }
            }
            o.data = data2.ToArray();
            if (enlarge) o.data = UpdEnlargeDataArray(expectedNumberOfObservations, o.data);

            //ErrorIfDatabanksSwapped();
            Databank first = Program.databanks.GetFirst();

            string op = o.op;

            foreach(string name in o.listItems)
            {
                string var = name;
                TimeSeries ts = GetTimeSeriesFromString(var, O.ECreatePossibilities.Can);
                if (ts == null)
                {
                    if (op != "=")
                    {
                        IssueCreateWarning(var);
                        continue;
                    }
                    else
                    {
                        if (var.ToLower().StartsWith("xx", true, null))
                        {
                            //only vars beginning with "xx", and only "="-operator
                            //G.Writeln("+++ NOTE: upd: variable " + var + " not found in databank -- is created");
                            ts = new TimeSeries(Program.options.freq, var);
                            first.AddVariable(ts);
                        }
                        else
                        {
                            IssueCreateWarning(var);
                            continue;
                        }
                    }
                }

                bool endo = false;
                if (Program.model != null && Program.model.m2.endogenous != null)
                {
                    endo = Program.model.m2.endogenous.ContainsKey(ts.variableName);
                    if (endo) G.Writeln("+++ NOTE: You are updating a left-hand side variable (" + ts.variableName + ")");
                }

                //TimeSeries ts = work.GetVariable(var2);
                TimeSeries tsOld = null;
                if (op == "#" || updTypeDollar || o.opDollar || updType == ESeriesUpdTypes.mp)
                {
                    tsOld = ts.Clone();  //make a copy for use in # or $ or <mp> operator
                }

                if (o.data.Length > expectedNumberOfObservations)
                {
                    //TODO: truncate it
                    G.Writeln2("*** ERROR: UPD " + ts.variableName + ": There were " + o.data.Length + " numbers given for the period " + tStart + " to " + tEnd + " (= " + expectedNumberOfObservations + " periods)");
                    throw new GekkoException();
                }

                if (o.data.Length < expectedNumberOfObservations)
                {
                    if (o.data.Length == 1)
                    {
                        //enlarge
                        o.data = UpdEnlargeDataArray(expectedNumberOfObservations, o.data);
                    }
                    else
                    {
                        G.Writeln2("*** ERROR: UPD " + ts.variableName + ": There were " + o.data.Length + " numbers given for the period " + tStart + " to " + tEnd + " (= " + expectedNumberOfObservations + " periods)");
                        throw new GekkoException();
                    }
                }

                GekkoTime tStartM1 = tStart.Add(-1);
                if (op == "%" || op == "^" || op == "#" || updType == ESeriesUpdTypes.p || updType == ESeriesUpdTypes.d || updType == ESeriesUpdTypes.mp)
                {
                    double dataLag = ts.GetData(tStartM1);
                    if (double.IsNaN(dataLag)) G.Writeln("+++ NOTE: variable '" + ts.variableName + "' is missing in period " + (tStartM1) + ", so the result will be missing values");
                }

                int counter = 0;
                foreach (GekkoTime t in new GekkoTimeIterator(tStart, tEnd))
                {
                    UpdHelper(ts, op, t, o.data[counter], tsOld, updType);
                    counter++;  //IMPORTANT!
                }

                if (o.opDollar || updTypeDollar)
                {
                    GekkoTime last = ts.GetPeriodLast();
                    GekkoTime tEndP1 = tEnd.Add(1);
                    foreach (GekkoTime t in new GekkoTimeIterator(tEndP1, last))
                    {
                        GekkoTime tM1 = t.Add(-1);
                        double old = tsOld.GetData(t);
                        double oldLag = tsOld.GetData(tM1);
                        double newLag = ts.GetData(tM1);
                        double v = old / oldLag;
                        if (old == 0d && oldLag == 0d)
                        {
                            v = 0d;  //same in PCIM
                        }
                        ts.SetData(t, newLag * v);
                    }
                }
                ts.Stamp();

                if (o.meta != null)
                {
                    //For instance, "UPD <p> y = 5, 4, 5;" --> meta = "UPD <p> y = 5, 4, 5"
                    string s = O.ShowDatesAsString(tStart, tEnd);
                    ts.source = s + o.meta;                    
                    ts.SetDirtyGhost(true, false);
                }
            }
        }

        private static double[] UpdEnlargeDataArray(int expectedNumberOfObservations, double[] input)
        {
            if (input.Length > expectedNumberOfObservations)
            {
                //if input.Length == 1, this can never be the case
                //For instance, for TIME 2010 2015, this will fail: "UPD xx = 1,2,3,4,5,6,7 rep *;", whereas "UPD xx = 1,2,3,4,5,6 rep *;" will be ok
                G.Writeln2("*** ERROR: UPD: There were " + input.Length + " numbers given for the period, expected " + expectedNumberOfObservations);
                throw new GekkoException();
            }
            double[] data3 = new double[expectedNumberOfObservations];
            double lastKnown = input[input.Length - 1];
            for (int i = 0; i < expectedNumberOfObservations; i++)
            {
                if (i < input.Length) data3[i] = input[i];  //existing data
                else data3[i] = lastKnown;
            }
            return data3;
        }



        public static int Write(O.Write o)
        {
            if (G.equal(o.opt_tsdx, "yes"))
            {
                G.Writeln2("*** ERROR: You cannot use <tsdx>. The extension name has changed to to ." + Globals.extensionDatabank + ".");
                G.Writeln("           If you really need a .tsdx file, you can WRITE/EXPORT a ." + Globals.extensionDatabank + " file,", Color.Red);
                G.Writeln("           and rename that file to .tsdx afterwards.", Color.Red);
                G.Writeln();
                throw new GekkoException();
            }

            bool isDefault = false;
            if (o.opt_tsd == null && o.opt_gbk == null && o.opt_csv == null && o.opt_prn == null && o.opt_tsp == null && o.opt_xls == null && o.opt_xlsx == null && o.opt_gnuplot == null && o.opt_series == null)
            {
                isDefault = true;  //implicitly GBK
            }

            string fileName = o.fileName;
            fileName = StripQuotes(fileName);
            bool isCaps = true; if (G.equal(o.opt_caps, "no")) isCaps = false;
            GekkoTime tStart = o.t1;
            GekkoTime tEnd = o.t2;
                        
            List<BankNameVersion> list = GetInfoFromListOfWildcards(o.listItems);
                        
            bool writeAllVariables = false;
            if (list == null) writeAllVariables = true;
                        
            if (writeAllVariables)  //writing the whole first databank
            {
                list = GetAllVariablesFromBank(Program.databanks.GetFirst());
            }
            else
            {
                //decorate list items with freq type
                if (Program.options.freq == EFreq.Quarterly)
                {
                    for (int i = 0; i < list.Count; i++) list[i].name = list[i].name + Globals.freqIndicator + "q";
                }
                else if (Program.options.freq == EFreq.Monthly)
                {
                    for (int i = 0; i < list.Count; i++) list[i].name = list[i].name + Globals.freqIndicator + "m";
                }
                else if (Program.options.freq == EFreq.Undated)
                {
                    for (int i = 0; i < list.Count; i++) list[i].name = list[i].name + Globals.freqIndicator + "u";
                }
            }

            bool skipping = RemoveNullTimeseries(list);

            if (skipping) writeAllVariables = false;  //signals to gbk format that it can not just clone existing bank

            bool isRecordsFormat = isDefault || G.equal(o.opt_gbk, "yes") || G.equal(o.opt_tsd, "yes");

            //TODO TODO TODO
            //TODO TODO TODO
            //TODO TODO TODO Not sure is this filter stuff works ok for quarters and months...?
            //TODO TODO TODO
            //TODO TODO TODO

            List<BankNameVersion> listFilteredForCurrentFreq = null;
            if (isRecordsFormat)
            {
                listFilteredForCurrentFreq = list;
            }
            else
            {
                listFilteredForCurrentFreq = FilterListForFrequency(list);
            }

            if (tStart.IsNull() && tEnd.IsNull())
            {
                if (isDefault || G.equal(o.opt_gbk, "yes") || G.equal(o.opt_tsd, "yes"))
                {
                    //Do nothing, skip this, we do not need to know the timespan of the bank
                    //Not done for GBK or TSD, would just waste time. For these formats, a null period
                    //is handled ok    
                }
                else
                {
                    GetDatabankPeriodFilteredForFreq(listFilteredForCurrentFreq, ref tStart, ref tEnd);
                }
            }

            string writeOption = "" + Globals.extensionDatabank + "";  //default
            if (G.equal(o.opt_tsd, "yes")) writeOption = "tsd";

            if (G.equal(o.opt_csv, "yes") || G.equal(o.opt_prn, "yes"))
            {
                //2D format
                EdataFormat format = EdataFormat.Csv;
                if (G.equal(o.opt_csv, "yes")) format = EdataFormat.Csv;
                else if (G.equal(o.opt_prn, "yes")) format = EdataFormat.Prn;
                CheckSomethingToWrite(listFilteredForCurrentFreq);
                return CsvPrnWrite(listFilteredForCurrentFreq, fileName, tStart, tEnd, format);
            }
            else if (G.equal(o.opt_gnuplot, "yes"))
            {
                //2D format
                CheckSomethingToWrite(listFilteredForCurrentFreq);
                return GnuplotWrite(listFilteredForCurrentFreq, fileName, tStart, tEnd);
            }
            else if (G.equal(o.opt_tsp, "yes"))
            {
                //RECORDS
                CheckSomethingToWrite(listFilteredForCurrentFreq);
                return Tspwrite(listFilteredForCurrentFreq, fileName, tStart, tEnd, isCaps);
            }
            else if (G.equal(o.opt_xls, "yes") || G.equal(o.opt_xlsx, "yes"))
            {
                //2D format
                CheckSomethingToWrite(listFilteredForCurrentFreq);
                WriteToExcel(fileName, tStart, tEnd, listFilteredForCurrentFreq);
                return 0;
            }
            else if (o.opt_series != null)
            {
                //RECORDS
                if (fileName == null || fileName.Trim() == "")
                {
                    G.Writeln2("*** ERROR: Please indicate a file name for EXPORT<series>");
                    throw new GekkoException();
                }
                CheckSomethingToWrite(listFilteredForCurrentFreq);
                Program.Updprt(listFilteredForCurrentFreq, tStart, tEnd, o.opt_series, fileName);
                return 0;
            }
            else if (isRecordsFormat)
            {
                //RECORDS
                //tsd or gbk or unspecified format                
                CheckSomethingToWrite(list);
                //first argument (the databank) is only used if list = null
                return Write(Program.databanks.GetFirst(), tStart, tEnd, fileName, isCaps, list, writeOption, writeAllVariables, false);
            }
            else
            {
                G.Writeln2("*** ERROR: Unknown databank format");
                throw new GekkoException();
            }
        }

        private static List<BankNameVersion> GetInfoFromListOfWildcards(List<string> list)
        {
            if (list == null) return null;
            List<BankNameVersion> list2 = new List<BankNameVersion>();
            foreach (string s in list)
            {
                list2.AddRange(Program.GetInfoFromStringWildcard(s, null)); //could use .from or .bank here!!!!
            }
            return list2;
        }

        private static void CheckSomethingToWrite(List<BankNameVersion> listFilteredForCurrentFreq)
        {
            if (listFilteredForCurrentFreq.Count == 0)
            {
                G.Writeln2("*** ERROR: No variables to write");
                throw new GekkoException();
            }
        }

        private static void WriteToExcel(string fileName, GekkoTime tStart, GekkoTime tEnd, List<BankNameVersion> newList)
        {
            G.Writeln2("Writing Excel file for the period " + G.FromDateToString(tStart) + "-" + G.FromDateToString(tEnd));
            //TODO: variables and time                

            int counter = 0;
            int numberOfCols = GekkoTime.Observations(tStart, tEnd);
            int numberOfRows = newList.Count;
            ExcelOptions eo = new ExcelOptions();
            eo.excelData = new double[numberOfRows, numberOfCols];
            eo.excelRowLabels = new string[numberOfRows, 1];
            eo.excelColumnLabels = new string[1, numberOfCols];

            for (int i = 0; i < newList.Count; i++)
            {
                Databank db = GetBankFromBankNameVersion(newList[i].bank);
                string var = (string)newList[i].name;
                string varLabel = (string)newList[i].name;
                eo.excelRowLabels[i, 0] = varLabel;

                TimeSeries ts = db.GetVariable(var);
                //TimeSeries tsGrund = base2.GetVariable(var);
                if (ts == null)
                {
                    //TODO: check this beforehand, and do a msgbox with all missing vars (a la when doing sim)
                    G.Writeln("+++ WARNING: variable '" + var + "' does not exist -- skipped");
                    continue;
                }
                counter++;
                int periodCounter = 0;
                //file.Write(varLabel);
                foreach (GekkoTime gt in new GekkoTimeIterator(tStart, tEnd))
                {
                    eo.excelColumnLabels[0, periodCounter] = gt.ToString();
                    double var1 = ts.GetData(gt);
                    if (G.isNumericalError(var1)) var1 = 9.99999e+99;
                    eo.excelData[i, periodCounter] = var1;
                    periodCounter++;
                }
            }

            eo.fileName = fileName;

            Program.CreateExcelWorkbook2(eo, null, false);
        }

        public static void ArrayTimeseriesTip(string name)
        {
            G.Writeln("           Tip: try 'DISP " + name + ";' to see the dimensions.");
        }

        private static bool RemoveNullTimeseries(List<BankNameVersion> newList)
        {
            Databank first = Program.databanks.GetFirst();
            //The list must be with freq indicator
            bool skipping = false;
            List<BankNameVersion> remove = new List<BankNameVersion>();
            foreach (BankNameVersion s in newList)
            {
                Databank db = first;
                if (s.bank != null) db = Program.databanks.GetDatabank(s.bank);
                if (db == null)
                {
                    G.Writeln2("*** ERROR: Databank '" + s.bank + "' not found");
                    throw new GekkoException();
                }
                TimeSeries ts = db.GetVariable(false, s.name);
                if (ts == null) continue;
                if (ts.IsGhost()) continue;   //don't remove if it is an array-timeseries (which is kind of an empty shell)
                if (ts.IsTimeless()) continue;  //keep timeless variables
                if (ts.IsNullPeriod())
                {
                    remove.Add(s);
                }
            }
            if (remove.Count > 0)
            {
                foreach (BankNameVersion s in remove)
                {
                    newList.Remove(s);
                }
                G.Writeln2("+++ NOTE: Skipped " + remove.Count + " timeseries with no data and no period");
                skipping = true;
            }
            return skipping;
        }

        private static List<BankNameVersion> GetAllVariablesFromBank(Databank work)
        {
            List<BankNameVersion> list = new List<BankNameVersion>();
            foreach (string s in work.storage.Keys)
            {
                if (s == "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0" || s == "")
                {
                    continue;  //probably some artefact creeping in from PCIM?
                }
                BankNameVersion bnv = new Gekko.BankNameVersion();
                bnv.name = s;
                list.Add(bnv);
            }
            //list.Sort(StringComparer.InvariantCulture);
            list = list.OrderBy(o => o.name).ToList();
            return list;
        }

        private static List<BankNameVersion> FilterListForFrequency(List<BankNameVersion> list)
        {
            //Returns a list where %q, %m at the end of each item is removed
            List<BankNameVersion> newList = new List<BankNameVersion>();
            Dictionary<string, double> skipped = new Dictionary<string, double>();
            skipped.Add("a", 0d);
            skipped.Add("q", 0d);
            skipped.Add("m", 0d);
            foreach (BankNameVersion var in list)
            {
                string freq = G.GetFreq(Program.options.freq);
                string s2 = var.name;
                if (!s2.Contains(Globals.freqIndicator)) s2 = s2 + Globals.freqIndicator + "a"; //because annual data does not have this indicator
                string[] temp = s2.Split(new string[] { Globals.freqIndicator }, StringSplitOptions.None);
                if (!G.equal(freq, temp[1]))
                {
                    skipped[temp[1]]++;
                    continue;
                }
                string s3 = temp[0];
                BankNameVersion bnv = new BankNameVersion();
                bnv.name = s3;
                bnv.bank = var.bank;
                newList.Add(bnv);
            }

            bool skipped2 = false;
            foreach (string s in skipped.Keys)
            {
                if (skipped[s] > 0d)
                {
                    skipped2 = true;
                    G.Writeln("+++ WARNING: ignored " + skipped[s] + " variables with frequency '" + s + "'");
                }
            }
            if (skipped2) G.Writeln("You may change frequency (OPTION freq) to write these variables");
            return newList;
        }

        public static int Write(Databank databank, GekkoTime yr1, GekkoTime yr2, string file, bool isCaps, List<BankNameVersion> list, string writeOption, bool writeAllVariables, bool isCloseCommand)
        {
            //ErrorIfDatabanksSwapped();
            if (databank.storage.Count == 0)
            {
                if (isCloseCommand)
                {
                    if (databank.fileHash == Globals.brandNewFile)
                    {
                        G.Writeln2("Databank " + databank.aliasName + " is empty and hence not written");
                        return 0;
                    }
                    else
                    {
                        //write it: it could be an OPEN<edit> on existing file with series. Then CLEAR. Then CLOSE.
                        //in that case, an empty bank should be written.
                    }
                }
                else
                {
                    //nowadays we may have WRITE b2:* file=myfile, not related to Work or first bank at all!
                    //G.Writeln2("*** ERROR: Databank '" + databank.aliasName + "' is empty -- nothing to write");
                    //throw new GekkoException();
                }
            }

            file = StripQuotes(file);
            bool isUsingOptionFolderBank = false;
            if (Program.options.folder && Program.options.folder_bank != "") isUsingOptionFolderBank = true;

            string tempTsdxPath = null;

            bool isTsdx = false;
            string extension = "tsd";
            if (true)
            {
                isTsdx = true;
                extension = "" + Globals.extensionDatabank + "";
            }
            if (G.equal(writeOption, "tsd"))
            {
                isTsdx = false;
                extension = "tsd";
            }
            if (G.equal(writeOption, "" + Globals.extensionDatabank + ""))
            {
                isTsdx = true;
                extension = "" + Globals.extensionDatabank + "";
            }

            DateTime t = DateTime.Now;

            //file = SubstituteAssignVarsInExpression(file);
            file = AddExtension(file, "." + extension);

            string path = null;
            if (isUsingOptionFolderBank)
            {
                path = Program.options.folder_bank;
            }
            string pathAndFilename = CreateFullPathAndFileNameFromFolder(file, path);

            string pathAndFileNameResultingFile = pathAndFilename;

            int count = 0;

            string tsdxVersion = "1.0";

            if (isTsdx)
            {
                //try to zip it to this local folder
                tempTsdxPath = GetTempTsdxFolderPath();
                if (!Directory.Exists(tempTsdxPath))  //should almost never exist, since name is random
                {
                    Directory.CreateDirectory(tempTsdxPath);
                }
                else
                {
                    //in the very rare case, any files here will be overwritten
                }
                pathAndFilename = tempTsdxPath + "\\" + "databank" + ".tsd";

                tsdxVersion = Program.options.databank_file_gbk_version;
                if (!Globals.tsdxVersions.Contains(tsdxVersion))
                {
                    G.Writeln2("*** ERROR: 'OPTION databank file " + Globals.extensionDatabank + " version' have these legal values:");
                    G.Write("            "); G.PrintListWithCommas(Globals.tsdxVersions, false);
                    throw new GekkoException();
                }
                CreateDatabankXmlInfo(tempTsdxPath, tsdxVersion, isCloseCommand);
            }

            if (isTsdx && tsdxVersion == "1.1")
            {
                //May take a little time to create: so use static serializer if doing serialize on a lot of small objects
                RuntimeTypeModel serializer = TypeModel.Create();
                serializer.UseImplicitZeroDefaults = false; //otherwise an int that has default constructor value -12345 but is set to 0 will reappear as a -12345 (instead of 0). For int, 0 is default, false for bools etc.
                string pathAndFilename2 = tempTsdxPath + "\\" + Program.options.databank_file_gbk_internal; //changed from .bin to .data
                databank.Trim();  //to make it smaller, slack removed from each TimeSeries

                //Note that if writeAllVariables=true, we don't make any list of the variables, the databank
                //object is simply serialized directly. So any timeseries will be written in that case.
                GekkoDictionary<string, TimeSeries> databankWithFewerVariables = null;
                GekkoDictionary<string, TimeSeries> storageOriginal = databank.storage;  //for resetting back to this afterwards

                try
                {
                    if (writeAllVariables == false)
                    {
                        //-----------------------
                        // truncate the variables
                        // here, databank variable is not used (this is actually only used for CLOSEing a bank)
                        //-----------------------
                        databankWithFewerVariables = new GekkoDictionary<string, TimeSeries>(StringComparer.OrdinalIgnoreCase);
                        foreach (BankNameVersion var in list)
                        {
                            Databank db = GetBankFromBankNameVersion(var.bank);
                            TimeSeries ts = null; db.storage.TryGetValue(var.name, out ts);
                            if (ts == null)  //if list is given "manually"
                            {
                                G.Writeln();
                                G.Writeln("*** ERROR: Could not find timeseries '" + var + "' in databank '" + db.aliasName + "' for writing (" + Globals.extensionDatabank + ")");
                                throw new GekkoException();
                            }
                            if (databankWithFewerVariables.ContainsKey(var.name))
                            {
                                G.Writeln();
                                G.Writeln("*** ERROR: Gbk format does not allow duplicate variables ('" + var.name + "')");
                                G.Writeln("           This is enforced for " + Globals.extensionDatabank + " version 1.1 and later.");
                                throw new GekkoException();
                            }
                            else
                            {
                                databankWithFewerVariables.Add(var.name, ts);
                            }
                        }
                    }

                    if (databankWithFewerVariables != null) databank.storage = databankWithFewerVariables;  //will be set back later on --> to temp

                    if (!yr1.IsNull() || !yr2.IsNull())
                    {
                        //----------------------
                        // truncate the periods
                        //----------------------
                        GekkoDictionary<string, TimeSeries> databankWithFewerPeriods = new GekkoDictionary<string, TimeSeries>(StringComparer.OrdinalIgnoreCase);
                        foreach (KeyValuePair<string, TimeSeries> kvp in databank.storage)  
                        {
                            TimeSeries ts = kvp.Value;
                            TimeSeries tsClone = ts.Clone();
                            tsClone.Truncate(yr1, yr2);
                            databankWithFewerPeriods.Add(kvp.Key, tsClone);
                        }
                        databank.storage = databankWithFewerPeriods;
                        databank.Trim();  //to make it smaller, slack removed from each TimeSeries
                    }

                    using (FileStream fs = WaitForFileStream(pathAndFilename2, GekkoFileReadOrWrite.Write))
                    {
                        try
                        {
                            DateTime dt0 = DateTime.Now;
                            //ErrorIfDatabanksSwapped(); //for safety, this is also put here so that it is always near the protobuf serialize command.
                            serializer.Serialize(fs, databank);
                            G.WritelnGray("Protobuf serialize: " + G.Seconds(dt0));
                            count = databank.storage.Count;
                        }
                        catch (Exception e)
                        {                            
                            G.Writeln2("*** ERROR: Technical problem while writing databank to " + Globals.extensionDatabank + " (protobuffers)");
                            G.Writeln("           Message: " + e.Message, Color.Red);
                            throw new GekkoException();
                        }
                    }
                }
                finally
                {
                    //so we are sure it always gets pointed back to its real Dictionary<>!
                    databank.storage = storageOriginal;
                }
            }

            if (tsdxVersion != "1.1")
            {
                DateTime dt0 = DateTime.Now;
                //ErrorIfDatabanksSwapped(); //for safety, this is also put here so that it is always near the tsd write command.
                WriteTsdRecords(ref yr1, ref yr2, isCaps, list, databank, isTsdx, pathAndFilename, ref count);
                G.WritelnGray("Writing tsd records took: " + G.Seconds(dt0));
            }

            if (isTsdx)
            {
                DateTime dt0 = DateTime.Now;
                WaitForZipWrite(tempTsdxPath, pathAndFileNameResultingFile);
                G.WritelnGray("Zipping took: " + G.Seconds(dt0));
            }

            if (!Globals.setPrintMute)
            {
                G.Writeln();
                G.Writeln("Wrote " + count + " variables to " + pathAndFileNameResultingFile + " in " + G.Seconds(t));
                if (isUsingOptionFolderBank)
                {
                    if (!file.Contains(":"))  //Don't write this message if it is a absolute path, for instance c:\mybank\myfile. Relative paths will get the message (that must be ok)
                    {
                        G.Writeln("+++ NOTE: Wrote to user-indicated folder (see 'option folder bank = ...')");
                    }
                }
            }
            return count;
        }

        private static void WriteTsdRecords(ref GekkoTime yr1, ref GekkoTime yr2, bool isCaps, List<BankNameVersion> list, Databank databank, bool isTsdx, string pathAndFilename, ref int count)
        {
            using (FileStream fs = WaitForFileStream(pathAndFilename, GekkoFileReadOrWrite.Write))
            using (StreamWriter res = G.GekkoStreamWriter(fs))
            {                
                foreach (BankNameVersion var in list)
                {
                    Databank db = GetBankFromBankNameVersion(var.bank);
                    TimeSeries ts = null; db.storage.TryGetValue(var.name, out ts);
                    {
                        if (ts == null)  //if list is given "manually"
                        {
                            G.Writeln();
                            G.Writeln("*** ERROR: Could not find timeseries '" + var.bank + Globals.symbolBankColon + var.name + "' while writing tsd records");
                            throw new GekkoException();
                        }
                        count++;
                        WriteTsdRecord(yr1, yr2, res, ts, isCaps, isTsdx);
                    }
                }
                res.Flush();
            }
        }

        private static void CreateDatabankXmlInfo(string tempTsdxPath, string tsdxVersion, bool isCloseCommand)
        {
            // Create the xml document containe
            XmlDocument doc = new XmlDocument();// Create the XML Declaration, and append it to XML document
            XmlDeclaration dec = doc.CreateXmlDeclaration("1.0", null, null);
            //doc.Attributes.Append(new XmlAttribute
            doc.AppendChild(dec);// Create the root element
            //Using PascalCase for elements, and camelCase for attributes.
            XmlElement root = doc.CreateElement("DatabankInfo");
            root.SetAttribute("databankVersion", tsdxVersion);  //needs to be changed if Databank/TimeSeries change
            root.SetAttribute("gekkoVersion", Globals.gekkoVersion);
            doc.AppendChild(root);

            XmlElement comment = doc.CreateElement("Info1");  //HDG
            comment.InnerText = Program.databanks.GetFirst().info1;
            root.AppendChild(comment);

            XmlElement date = doc.CreateElement("Date");
            string now = GetDateTimeStamp();
            date.InnerText = now;
            root.AppendChild(date);

            if (Program.model != null && !isCloseCommand)
            {
                //We do not want to put model info into XML if it is a CLOSE command triggering the bank write, for
                //instance after a OPEN<edit>, etc. This is mode=data and something else.
                //(Would probably happen very rarely anyhow, since model endogenous and databank variables must match)
                bool ok = true;
                foreach (string s in Program.model.endogenousOriginallyInModel.Keys)
                {
                    if (!Program.databanks.GetFirst().ContainsVariable(s))
                    {
                        ok = false;
                        break;
                    }
                }

                if (ok == true)  //all model endogenous are found in the databank. If so, we add the extra model info. If not, only HDG and stamp are written into xml.
                {

                    XmlElement modelName = doc.CreateElement("ModelName");
                    modelName.InnerText = Path.GetFileName(Program.model.modelInfo.fileName);
                    root.AppendChild(modelName);

                    XmlElement modelInfo = doc.CreateElement("ModelInfo");
                    modelInfo.InnerText = Program.model.modelInfo.info;
                    root.AppendChild(modelInfo);

                    XmlElement modelDate = doc.CreateElement("ModelDate");
                    modelDate.InnerText = Program.model.modelInfo.date;
                    root.AppendChild(modelDate);

                    XmlElement modelSignature = doc.CreateElement("ModelSignature");
                    modelSignature.InnerText = Program.model.signatureFoundInFileHeader;
                    root.AppendChild(modelSignature);

                    XmlElement modelHash = doc.CreateElement("ModelHash");
                    modelHash.InnerText = Program.model.modelHashTrue;
                    root.AppendChild(modelHash);

                    XmlElement modelLastSimPeriod = doc.CreateElement("ModelLastSimPeriod");
                    if (Program.model.lastSimPer1.IsNull() || Program.model.lastSimPer2.IsNull()) modelLastSimPeriod.InnerText = "";
                    else modelLastSimPeriod.InnerText = G.FromDateToString(Program.model.lastSimPer1) + "-" + G.FromDateToString(Program.model.lastSimPer2);
                    root.AppendChild(modelLastSimPeriod);

                    XmlElement modelLastSimStamp = doc.CreateElement("ModelLastSimStamp");
                    modelLastSimStamp.InnerText = Program.model.lastSimStamp;
                    root.AppendChild(modelLastSimStamp);

                    XmlElement modelLargestLag = doc.CreateElement("ModelLargestLag");
                    modelLargestLag.InnerText = "" + Program.model.largestLag;
                    root.AppendChild(modelLargestLag);

                    XmlElement modelLargestLead = doc.CreateElement("ModelLargestLead");
                    modelLargestLead.InnerText = "" + Program.model.largestLead;
                    root.AppendChild(modelLargestLead);
                }
            }

            string xmlOutput = doc.OuterXml;
            using (FileStream fs = WaitForFileStream(tempTsdxPath + "\\" + "DatabankInfo.xml", GekkoFileReadOrWrite.Write))
            {
                doc.Save(fs);
            }
        }

        public static string GetDateTimeStamp()
        {
            DateTime date1 = DateTime.Now;
            string now = date1.ToString("G", CultureInfo.CreateSpecificCulture("da-DK"));
            return now;
        }

        public static string GetDateStamp()
        {
            //See also #80927435209843
            DateTime date1 = DateTime.Now;
            string now = date1.ToString("d", CultureInfo.CreateSpecificCulture("da-DK"));
            return now;
        }

        public static string GetTimeStamp()
        {
            DateTime date1 = DateTime.Now;
            string now = date1.ToString("T", CultureInfo.CreateSpecificCulture("da-DK"));
            return now;
        }

       

        //This is a general method for zipping the contents of a folder
        public static void WaitForZipWrite(string folder, string zipFileName)
        {
            string path_zipFileName = Path.GetDirectoryName(zipFileName);
            if (!Directory.Exists(path_zipFileName))
            {
                G.Writeln2("*** ERROR: The directory '" + path_zipFileName + "' does not seem to exist");
                throw new GekkoException();
            }

            int gap = Globals.waitFileGap;  //2 seconds
            int totalTime = Globals.waitFileTotalTime;  //600 seconds
            int repeats = totalTime / gap;

            DirectoryInfo folderInfo = new DirectoryInfo(folder);

            for (int i = 0; i < repeats; i++)
            {
                if (Globals.threadIsInProcessOfAborting && !Globals.applicationIsInProcessOfAborting) throw new GekkoException();
                try
                {
                    string sevenzPath = null;
                    if (G.IsUnitTesting())
                    {
                        sevenzPath = Globals.ttPath2 + @"\GekkoCS\Gekko\bin\Debug\zip\7z.dll";
                    }
                    else
                    {
                        sevenzPath = Application.StartupPath + "\\zip\\7z.dll";
                    }
                    SevenZipExtractor.SetLibraryPath(sevenzPath);
                    SevenZipCompressor tmp = new SevenZipCompressor();
                    tmp.ArchiveFormat = OutArchiveFormat.Zip;
                    //tmp.CompressionLevel = CompressionLevel.Low;  //could be better than .Fast??
                    tmp.CompressionLevel = CompressionLevel.Fast;
                    if (zipFileName.ToLower().EndsWith("." + Globals.extensionDatabank + "") && Program.options.databank_file_gbk_compress == false)
                    {
                        tmp.CompressionLevel = CompressionLevel.None;
                    }
                    if (!System.IO.Directory.Exists(folderInfo.FullName))
                    {
                        G.Writeln("+++ WARNING: zip file could not be created");  //should not be possible
                        break;
                    }
                    tmp.CompressDirectory(folderInfo.FullName, zipFileName);
                }
                catch (Exception e)
                {
                    //G.Writeln("+++ WARNING: Problem trying to zip folder '" + folder + "' into zip-file '" + zipFileName + "'. Retrying... (" + (i * gap) + " seconds)");
                    G.Writeln("+++ WARNING: Zip-file '" + zipFileName + "' seems blocked. Retrying... (" + (i * gap) + " seconds)");
                    System.Threading.Thread.Sleep(gap * 1000);  //1 seconds
                    continue;
                }

                //This folder name is in a user specific temp folder (typically on user's hard disk). The folder only lives for a very short time.
                //So it would be very unlikely that any file inside should be blocked.
                try
                {
                    if (System.IO.Directory.Exists(folderInfo.FullName))
                    {
                        System.IO.Directory.Delete(folderInfo.FullName, true);
                    }
                }
                catch (Exception e)
                {
                    //do nothing
                }
                break;
            }
            //return zipFileName;
        }

        //Only used for reading TSDX files, much more specific than WaitForZipRead()
        public static string WaitForZipRead_TSDX(string folder, string zipFileName, string inside, string originalFileName)
        {
            int gap = Globals.waitFileGap;  //1 second
            int totalTime = Globals.waitFileTotalTime;  //600 seconds
            int repeats = totalTime / gap;
            string tsdFile = "";
            bool isProtobuf = false;
            string ext = Path.GetExtension(zipFileName);
            if (G.equal(ext, "." + Globals.extensionDatabank)) isProtobuf = true; //with .gbk files, the inside is always protobuf-files.
            DirectoryInfo folderInfo = new DirectoryInfo(folder);
            for (int j = 0; j < repeats; j++)
            {
                if (Globals.threadIsInProcessOfAborting && !Globals.applicationIsInProcessOfAborting) throw new GekkoException();
                //try-catch is not used here: normally a zip-file can be read even if blocked by others (not so for writing)
                {
                    string sevenzPath = null;
                    if (G.IsUnitTesting())
                    {
                        sevenzPath = Globals.ttPath2 + @"\GekkoCS\Gekko\bin\Debug\zip\7z.dll";
                    }
                    else
                    {
                        sevenzPath = Application.StartupPath + "\\zip\\7z.dll";
                    }

                    SevenZipExtractor.SetLibraryPath(sevenzPath);
                    SevenZipExtractor tmp2 = null;
                    try
                    {
                        tmp2 = new SevenZipExtractor(zipFileName);
                    }
                    catch (Exception e)
                    {
                        //It seems this happens if the file is not a 'real' zip file
                        G.Writeln2("*** ERROR: It seems the databank file is not in the right format (unzipping failed)");
                        throw new GekkoException();
                    }
                    
                    using (tmp2)
                    {
                        string xmlFile = "";
                        int tsdfilecounter = 0;
                        for (int i = 0; i < tmp2.ArchiveFileData.Count; i++)
                        {
                            string fileName2 = tmp2.ArchiveFileNames[i];

                            if (G.equal(fileName2, Globals.protobufFileName) || G.equal(fileName2, Globals.protobufFileName2) || G.equal(fileName2, Program.options.databank_file_gbk_internal))
                            {
                                //this is only relevant for the older .tsdx files, .gbk files always has isProtobuf = true.
                                isProtobuf = true;
                            }

                            //Console.WriteLine(fileName2);
                            if (string.Compare(inside, fileName2, true) == 0)
                            {
                                //This is only for legacy reasons: all new tsdx files have databank.tsd as internal file.
                                //Remove this option a some point.
                                tsdFile = fileName2;
                                tsdfilecounter++;
                            }
                            if (string.Compare("databank.tsd", fileName2, true) == 0)
                            {
                                tsdFile = fileName2;
                                tsdfilecounter++;
                            }
                            if (string.Compare("DatabankInfo.xml", fileName2, true) == 0)
                            {
                                xmlFile = fileName2;
                            }
                        }

                        if (xmlFile == "")
                        {
                            G.Writeln2("*** ERROR: Cannot find xml-file inside zip-file. Expected to find '" + "DatabankInfo.xml" + "' inside '" + originalFileName + "'");
                            throw new GekkoException();
                        }

                        if (isProtobuf)
                        {
                            for (int i = 0; i < tmp2.ArchiveFileData.Count; i++)
                            {
                                tmp2.ExtractFiles(folder, tmp2.ArchiveFileData[i].Index);
                            }
                            tsdFile = "Is_a_protobuffer_file";  //okay, this is a hacky way to signal back, I admit it...
                        }
                        else
                        {
                            if (tsdfilecounter == 2 && G.equal(inside, "databank.tsd"))
                            {
                                //the rare case where the databank file name is "databank"
                                tsdfilecounter = 1;
                            }

                            if (tsdfilecounter > 1)
                            {
                                G.Writeln2("*** ERROR: Found several tsd-files inside zip-file. Cannot decide which one to use");
                                throw new GekkoException();
                            }

                            if (tsdFile == "")
                            {
                                G.Writeln2("*** ERROR: Cannot find tsd-file inside zip-file. Expected to find '" + inside + "' inside '" + originalFileName + "'");
                                throw new GekkoException();
                            }

                            for (int i = 0; i < tmp2.ArchiveFileData.Count; i++)
                            {
                                tmp2.ExtractFiles(folder, tmp2.ArchiveFileData[i].Index);
                            }
                        }
                    }
                    break;
                }
            }
            return tsdFile;
        }


        public static void WaitForZipRead(string folderToUseForOutput, string zipFileNameAndPath)
        {
            int gap = Globals.waitFileGap;  //1 second
            int totalTime = Globals.waitFileTotalTime;  //600 seconds
            int repeats = totalTime / gap;
            string tsdFile = "";

            DirectoryInfo folderInfo = new DirectoryInfo(folderToUseForOutput);

            for (int j = 0; j < repeats; j++)
            {
                if (Globals.threadIsInProcessOfAborting && !Globals.applicationIsInProcessOfAborting) throw new GekkoException();
                //try-catch is not used here: normally a zip-file can be read even if blocked by others (not so for writing)
                {
                    string sevenzPath = null;
                    if (G.IsUnitTesting())
                    {
                        sevenzPath = Globals.ttPath2 + @"\GekkoCS\Gekko\bin\Debug\zip\7z.dll";
                    }
                    else
                    {
                        sevenzPath = Application.StartupPath + "\\zip\\7z.dll";
                    }

                    SevenZipExtractor.SetLibraryPath(sevenzPath);

                    using (SevenZipExtractor tmp2 = new SevenZipExtractor(zipFileNameAndPath))
                    {
                        for (int i = 0; i < tmp2.ArchiveFileData.Count; i++)
                        {
                            tmp2.ExtractFiles(folderToUseForOutput, tmp2.ArchiveFileData[i].Index);
                        }
                    }
                    break;
                }
            }
            return;
        }

        public static FileStream WaitForFileStream(string pathAndFilename, GekkoFileReadOrWrite type)
        {
            return WaitForFileStream(pathAndFilename, type, false);
        }

        public static FileStream WaitForFileStream(string pathAndFilename, GekkoFileReadOrWrite type, bool printAnyExceptionOnScreen)
        {
            FileStream fs = null;

            int gap = Globals.waitFileGap;  //1 second
            int totalTime = Globals.waitFileTotalTime;  //600 seconds
            int repeats = totalTime / gap;

            FileMode fm = FileMode.Create;  //if writing, -- if the file exists overwrite it, otherwise create it
            if (type == GekkoFileReadOrWrite.WriteAppend) fm = FileMode.Append; //if writing, -- if the file exists append to it, otherwise create it

            FileAccess fa = FileAccess.Write; //if writing
            FileShare fsh = FileShare.None; //if writing, -- don't allow others to read while we write

            if (type == GekkoFileReadOrWrite.Read)
            {
                fm = FileMode.Open; //if reading
                fa = FileAccess.Read; //if reading
                fsh = FileShare.Read; ; //if reading
            }

            for (int i = 0; i < repeats; i++)
            {
                if (Globals.threadIsInProcessOfAborting && !Globals.applicationIsInProcessOfAborting) throw new GekkoException();

                string pathName = Path.GetDirectoryName(pathAndFilename);

                if (type == GekkoFileReadOrWrite.Read)
                {
                    //checking if the file is there at all for reading
                    if (!File.Exists(pathAndFilename))
                    {
                        G.Writeln2("*** ERROR: Could not find file '" + pathAndFilename + "' for reading");
                        if (!Directory.Exists(pathName)) G.Writeln2("*** ERROR: The directory '" + pathName + "' does not seem to exist");
                        throw new GekkoException();
                    }
                }

                if (type == GekkoFileReadOrWrite.Write)
                {
                    //checking if the path exists for writing the file
                    //string extension = Path.GetExtension(pathAndFilename);

                    if (Directory.Exists(pathAndFilename))
                    {
                        G.Writeln2("*** ERROR: There exists a folder with the same name: " + pathAndFilename);
                        throw new GekkoException();
                    }

                    if (pathName != "")  //sometimes pathAndFilename may be just the filename??
                    {
                        if (!Directory.Exists(pathName))
                        {
                            G.Writeln2("*** ERROR: Could not find directory '" + pathName + "' for writing");
                            throw new GekkoException();
                        }
                    }
                }

                try
                {
                    fs = File.Open(pathAndFilename, fm, fa, fsh);
                }
                catch (UnauthorizedAccessException e)
                {
                    G.Writeln2("*** ERROR: It seems the file may be read-only: " + pathAndFilename);
                    throw;
                }
                catch (Exception e)
                {
                    //TODO: Can also fail with IOException if folder is not existing, handle that...
                    G.Writeln("+++ WARNING: File '" + pathAndFilename + "' seems blocked. Retrying... (" + (i * gap) + " seconds)");
                    System.Threading.Thread.Sleep(gap * 1000);  //1 seconds
                    continue;
                }
                break;
            }
            if (fs == null)
            {
                G.Writeln2("*** ERROR: Gave up on file '" + pathAndFilename + "'. Is it blocked by another program?");
                throw new GekkoException();
            }
            return fs;
        }

        public static void WaitForFileCopy(string pathAndFilenameSource, string pathAndFilenameDestination)
        {
            WaitForFileCopyDeleteAbstract(pathAndFilenameSource, pathAndFilenameDestination, "copy");
        }

        public static void WaitForFileDelete(string pathAndFilenameSource)
        {
            WaitForFileCopyDeleteAbstract(pathAndFilenameSource, null, "delete");
        }

        private static void WaitForFileCopyDeleteAbstract(string pathAndFilenameSource, string pathAndFilenameDestination, string type)
        {
            if (!(type == "copy" || type == "delete"))
            {
                G.Writeln2("*** ERROR: Sorry, internal Gekko error #837432");
                throw new GekkoException();
            }
            int gap = Globals.waitFileGap;  //2 second
            int totalTime = Globals.waitFileTotalTime;  //600 seconds
            int repeats = totalTime / gap;
            bool success = false;

            for (int i = 0; i < repeats; i++)
            {
                if (Globals.threadIsInProcessOfAborting && !Globals.applicationIsInProcessOfAborting) throw new GekkoException();

                string pathName = Path.GetDirectoryName(pathAndFilenameSource);

                //checking if the file is there at all
                if (!File.Exists(pathAndFilenameSource))
                {
                    G.Writeln2("*** ERROR: Could not find file '" + pathAndFilenameSource + "' (for " + type + ")");
                    if (!Directory.Exists(pathName)) G.Writeln2("*** ERROR: The directory '" + pathName + "' does not seem to exist");
                    throw new GekkoException();
                }

                success = true;
                try
                {
                    if (type == "copy")
                    {
                        File.Copy(pathAndFilenameSource, pathAndFilenameDestination, true);
                    }
                    else if (type == "delete")
                    {
                        File.Delete(pathAndFilenameSource);
                    }
                }
                catch (Exception e)
                {
                    success = false;
                    if (type == "copy")
                    {
                        G.Writeln("+++ WARNING: File '" + pathAndFilenameSource + "' or '" + pathAndFilenameDestination + "'seems blocked for copying. Retrying... (" + (i * gap) + " seconds)");
                    }
                    else if (type == "delete")
                    {
                        G.Writeln("+++ WARNING: File '" + pathAndFilenameSource + "' seems blocked for deleting. Retrying... (" + (i * gap) + " seconds)");
                    }
                    System.Threading.Thread.Sleep(gap * 1000);  //2 seconds
                    continue;
                }
                break;
            }
            if (success == false)
            {
                if (type == "copy")
                {
                    G.Writeln2("*** ERROR: Gave up on copying '" + pathAndFilenameSource + "' to '" + pathAndFilenameDestination + "'. Is one of these files opened/blocked by another program?");
                }
                else if (type == "delete")
                {
                    G.Writeln2("*** ERROR: Gave up on deleting file '" + pathAndFilenameSource + "'. Is it opened/blocked by another program?");
                }
                throw new GekkoException();
            }
            return;
        }

        private static int CsvPrnWrite(List<BankNameVersion> vars, string filename, GekkoTime per1, GekkoTime per2, EdataFormat format)
        {
            int prnWidth = 18;
            //Databank first = Program.databanks.GetFirst();
            
            if (format == EdataFormat.Csv)
            {
                G.Writeln2("Writing csv file for the period " + G.FromDateToString(per1) + "-" + G.FromDateToString(per2));
                filename = AddExtension(filename, ".csv");
            }
            else if (format == EdataFormat.Prn)
            {
                G.Writeln2("Writing prn file for the period " + G.FromDateToString(per1) + "-" + G.FromDateToString(per2));
                filename = AddExtension(filename, ".prn");
            }            

            string pathAndFilename = CreateFullPathAndFileName(filename);
            int counter = 0;
            using (FileStream fs = WaitForFileStream(pathAndFilename, GekkoFileReadOrWrite.Write))
            using (StreamWriter file = G.GekkoStreamWriter(fs))
            {
                //Writing to csv/prn file

                if (format == EdataFormat.Prn) file.Write(G.varFormat("name", prnWidth));
                foreach (GekkoTime t in new GekkoTimeIterator( per1, per2))
                {
                    if (format == EdataFormat.Csv) file.Write(";" + t.ToString());
                    else file.Write(G.varFormat(" " + t.ToString(), prnWidth));  //both prn and gnuplot
                }
                file.WriteLine();

                foreach (BankNameVersion var in vars)
                {
                    string s3 = var.name;
                    Databank db = GetBankFromBankNameVersion(var.bank);
                    TimeSeries ts = db.GetVariable(s3);
                    if (ts == null)
                    {
                        //TODO: check this beforehand, and do a msgbox with all missing vars (a la when doing sim)
                        G.Writeln2("*** ERROR: Writing csv file: variable " + s3 + " in bank '" + db.aliasName + "' with freq '" + Program.options.freq + "' does not exist");
                        throw new GekkoException();
                    }

                    GekkoTime tsStart = ts.GetPeriodFirst();
                    GekkoTime tsEnd = ts.GetPeriodLast();

                    counter++;
                    if (format == EdataFormat.Csv) file.Write(s3);
                    else file.Write(G.varFormat(s3, prnWidth));  //prn and gnuplot
                    foreach (GekkoTime t in new GekkoTimeIterator( per1, per2))
                    {
                        if (format == EdataFormat.Csv) file.Write(";");
                        double data = ts.GetData(t);
                        if (G.isNumericalError(data))
                        {
                            if (t.StrictlySmallerThan(tsStart) || t.StrictlyLargerThan(tsEnd))
                            {
                                if (format == EdataFormat.Csv) file.Write(""); //write nothing, indicates out-of-sample
                                else file.Write(G.varFormat(" \"\"", prnWidth)); //write "", indicates out-of-sample
                            }
                            else
                            {
                                string s = HandleFunnyNumbers(format == EdataFormat.Csv);
                                if (format == EdataFormat.Csv) file.Write(s);
                                else file.Write(G.varFormat(s, prnWidth));
                            }
                        }
                        else
                        {
                            string s = null;
                            if (G.equal(Program.options.interface_csv_decimalseparator, "period"))
                            {
                                s = string.Format(System.Globalization.CultureInfo.InvariantCulture, "{0:0.0000000000E+00}", data);
                            }
                            else if (G.equal(Program.options.interface_csv_decimalseparator, "comma"))
                            {
                                s = string.Format(System.Globalization.CultureInfo.InvariantCulture, "{0:0,0000000000E+00}", data);
                            }
                            else
                            {
                                G.Writeln2("*** ERROR #8423824: Unknown decimalseparator");
                                throw new GekkoException();
                            }
                            if (format == EdataFormat.Csv)
                            {
                                if (data < 0) file.Write(s);
                                else file.Write(" " + s);
                            }
                            else
                            {
                                //prn and gnuplot
                                if (data < 0) file.Write(G.varFormat(s, prnWidth));
                                else file.Write(G.varFormat(" " + s, prnWidth));
                            }
                        }
                    }
                    file.WriteLine();
                }
                file.Flush();
            }

            G.Writeln("Wrote " + counter + " variables to " + pathAndFilename);

            return counter;
        }

        private static void GetDatabankPeriodFilteredForFreq(List<BankNameVersion> vars, ref GekkoTime per1, ref GekkoTime per2)
        {
            //Databank first = Program.databanks.GetFirst();
            //vars: annual is fy, quarterly is fy%q, monthly is fy%m, undated is fy%u
            int start = -12345;
            int end = -12345;
            foreach (BankNameVersion s in vars)
            {                
                Databank db = GetBankFromBankNameVersion(s.bank);
                TimeSeries ts = db.GetVariable(s.name);  //gets it with the global frequency 
                if (ts == null) continue;  //should not be possible
                start = G.GekkoMin(start, ts.GetPeriodFirst().super);
                end = G.GekkoMax(end, ts.GetPeriodLast().super);
            }
            GetQuartersOrMonthsFromYears(ref per1, ref per2, start, end);
        }

        private static Databank GetBankFromBankNameVersion(string bankName)
        {
            Databank db = null;
            if (bankName == null) db = Program.databanks.GetFirst();
            else db = Program.databanks.GetDatabank(bankName);
            if (db == null)
            {
                G.Writeln2("*** ERROR: Databank '" + bankName + "' not found");
                throw new GekkoException();
            }
            return db;
        }

        private static void GetQuartersOrMonthsFromYears(ref GekkoTime per1, ref GekkoTime per2, int yearStart, int yearEnd)
        {
            //see also #980432
            if ((Program.options.freq == EFreq.Annual))
            {
                per1 = new GekkoTime((Program.options.freq), yearStart, 1);
                per2 = new GekkoTime((Program.options.freq), yearEnd, 1);
            }
            else if ((Program.options.freq == EFreq.Quarterly))
            {
                per1 = new GekkoTime((Program.options.freq), yearStart, 1);
                per2 = new GekkoTime((Program.options.freq), yearEnd, 4);
            }
            else if ((Program.options.freq == EFreq.Monthly))
            {
                per1 = new GekkoTime((Program.options.freq), yearStart, 1);
                per2 = new GekkoTime((Program.options.freq), yearEnd, 12);
            }
        }

        private static int GnuplotWrite(List<BankNameVersion> vars, string filename, GekkoTime per1, GekkoTime per2)
        {
            int prnWidth = 18;
            //Databank first = Program.databanks.GetFirst();

            G.Writeln2("Writing gnuplot file for the period " + G.FromDateToString(per1) + "-" + G.FromDateToString(per2));
            filename = AddExtension(filename, ".dat");

            string pathAndFilename = CreateFullPathAndFileName(filename);
            int counter = 0;
            using (FileStream fs = WaitForFileStream(pathAndFilename, GekkoFileReadOrWrite.Write))
            using (StreamWriter file = G.GekkoStreamWriter(fs))
            {
                //Writing to csv/prn file

                file.Write("# " + G.Blanks(prnWidth));  //comment
                foreach (BankNameVersion var in vars)
                {
                    string s3 = var.name;
                    Databank db = GetBankFromBankNameVersion(var.bank);
                    TimeSeries ts = db.GetVariable(s3);
                    if (ts == null)
                    {
                        G.Writeln2("*** ERROR: Writing gnuplot file: variable " + s3 + " in '" + db.aliasName + "' with freq '" + Program.options.freq + "' does not exist");
                        throw new GekkoException();
                    }
                    file.Write(G.varFormat(s3, prnWidth));  //prn and gnuplot
                }
                file.WriteLine();

                foreach (GekkoTime t in new GekkoTimeIterator(per1, per2))
                {
                    file.Write(GetDateStringSuitableForGnuplot(t.ToString()) + " ");
                    foreach (BankNameVersion var in vars)
                    {
                        string s3 = var.name;
                        Databank db = GetBankFromBankNameVersion(var.bank);
                        TimeSeries ts = db.GetVariable(s3);  //existence has been checked
                        double data = ts.GetData(t);
                        if (G.isNumericalError(data))
                        {
                            s3 = "NaN";
                        }
                        else
                        {
                            string s = string.Format(System.Globalization.CultureInfo.InvariantCulture, "{0:0.0000000000E+00}", data);
                            if (data < 0) file.Write(G.varFormat(s, prnWidth));
                            else file.Write(G.varFormat(" " + s, prnWidth));
                        }
                    }
                    file.WriteLine();
                }
                file.Flush();
            }

            G.Writeln("Wrote " + vars.Count + " variables to " + pathAndFilename);

            return vars.Count;
        }

        private static string HandleFunnyNumbers(bool isCsv)
        {
            string s = "";
            if (isCsv)
            {
                if (G.equal(Program.options.interface_excel_language, "danish"))
                {
                    s = "#NAVN?";  //missing value indicator (M) -- SHEET uses na()
                }
                else
                {
                    s = "#NAME?";  //missing value indicator (M) -- SHEET uses na()
                }
            }
            else
            {
                s = " 1.0e+15";
            }
            return s;
        }

        private static int Tspwrite(List<BankNameVersion> vars, string filename, GekkoTime per1, GekkoTime per2, bool isCaps)
        {
            //Databank work = Program.databanks.GetFirst();
            filename = filename;
            filename = AddExtension(filename, ".tsp");
            string pathAndFilename = CreateFullPathAndFileName(filename);
            int counter = 0;
            using (FileStream fs = WaitForFileStream(pathAndFilename, GekkoFileReadOrWrite.Write))
            using (StreamWriter file = G.GekkoStreamWriter(fs))
            {
                string fileName = Path.GetFileName(pathAndFilename);
                file.WriteLine("? This file is produced by Gekko, and contains " + vars.Count + " LOAD-statements with data.");
                file.WriteLine("? You may INPUT this file in your TSP program, but for large datasets it");
                file.WriteLine("? may be better to create a TSP databank (.tlb).");
                file.WriteLine("? To do this, you may try the following statements:");
                file.WriteLine("?");
                file.WriteLine("?   options memory = 1000; ? 1000 MB");
                file.WriteLine("?   out mybankname;");
                file.WriteLine("?   input " + fileName + ";");
                file.WriteLine("?");
                file.WriteLine("? However, there seems to be a limit to the number of lines in a .tsp file,");
                file.WriteLine("? so you may have to split " + fileName + " into several files if it is large.");
                file.WriteLine("? NOTE: if the TSP databank (above: 'mybankname.tlb') already exists, you should delete");
                file.WriteLine("? it first -- otherwise any variables/data in the already existing .tlb file will");
                file.WriteLine("? stay in the file.");
                file.WriteLine();
                file.WriteLine();
                file.WriteLine("freq a;");
                file.WriteLine();
                foreach (BankNameVersion var in vars)
                {
                    Databank db = GetBankFromBankNameVersion(var.bank);                    
                    TimeSeries ts = db.GetVariable(var.name);
                    if (ts == null)
                    {
                        //TODO: check this beforehand, and do a msgbox with all missing vars (a la when doing sim)
                        G.Writeln2("*** ERROR: Writing tsp file: variable " + var + " does not exist");
                        throw new GekkoException();
                    }
                    WriteTspRecord(per1, per2, file, ts, isCaps);
                    counter++;
                }
                file.Flush();
            }

            if (!Globals.setPrintMute) G.Writeln("Wrote " + counter + " variables to " + pathAndFilename);
            return counter;
        }


        //============================================================================================
        //============================================================================================
        //============================================================================================


        /// <summary>
        /// Finds time series in data bank.
        /// </summary>
        /// <param name="databank">The databank</param>
        /// <param name="varName">The variable name</param>
        /// <returns></returns>
        private static TimeSeries FindOrCreateTimeSeriesInDataBank(Databank databank, string varName, EFreq frequency)
        {
            //This auto-creates timeseries for use when reading for example tsd or PCIM files
            //Has an overload used for UPD statements etc.
            TimeSeries ts = null;
            string varName2 = Program.AddFreqAtEndOfVariableName(varName, frequency);

            if (!databank.ContainsVariable(false, varName2))  //a little bit slack, but not much if databank is empty to start with
            {
                ts = new TimeSeries(frequency, varName);
                databank.AddVariable(G.GetFreq(frequency), ts);
            }
            else
            {
                ts = databank.GetVariable(false, varName2);  //false: do not add options.freq at the end!
            }
            if (!G.equal(varName, ts.variableName))
            {
                G.Writeln2("*** ERROR in findOrCreateTimeSeriesInDataBank(), name");  //safety, can be deleted for speed sometime
                throw new GekkoException();  //safety, can be deleted for speed sometime
            }
            if (!(frequency == ts.freqEnum))
            {
                G.Writeln2("*** ERROR in findOrCreateTimeSeriesInDataBank(), freq");  //safety, can be deleted for speed sometime
                throw new GekkoException();  //safety, can be deleted for speed sometime
            }
            return ts;
        }

        public static void Stop(P p)
        {
            Globals.threadIsInProcessOfAborting = true;
            p.hasSeenStopCommand = true;
            throw new GekkoException();
        }

        public static void Exit()
        {
            Globals.applicationIsInProcessOfAborting = true;
            Globals.threadIsInProcessOfAborting = true;
            throw new GekkoException();
        }

        public static void Pause(string arg)
        {
            if (arg.Length > 0)
            {
                G.Writeln();
                G.Writeln(arg);
            }
            if (arg.Length > 0) arg += "\n" + "\n";
            arg += "Press [Enter] to continue";
            MessageBox.Show(arg);
        }

        public static void Clear(O.Clear o, P p)
        {
            //Take care with filename, when clearing: only wipe it out if it is Work or Ref banks, other banks may be OPENed banks that we would like to write back to when CLOSEing

            if (o.name != null && (o.opt_first != null || o.opt_ref != null))
            {
                G.Writeln2("*** ERROR: You should use 'CLEAR<first>;' or  'CLEAR<ref>;'");
                throw new GekkoException();
            }

            if (o.name != null)
            {
                if (Program.databanks.GetDatabank(o.name) == null)
                {
                    G.Writeln2("*** ERROR: Trying to clear non-existing databank '" + o.name + "'");
                    throw new GekkoException();
                }

                Databank db1 = Program.databanks.GetDatabank(o.name);
                db1.Clear();
                if (db1.aliasName == Globals.Work || db1.aliasName == Globals.Ref) db1.FileNameWithPath = null;
                G.Writeln2("Cleared databank: " + o.name);
            }
            if (G.equal(o.opt_first, "yes"))
            {
                Program.databanks.GetFirst().Clear();
                if (Program.databanks.GetFirst().aliasName == Globals.Work || Program.databanks.GetFirst().aliasName == Globals.Ref) Program.databanks.GetFirst().FileNameWithPath = null;
                G.Writeln2("Cleared first databank ('" + Program.databanks.GetFirst().aliasName + "')");
            }
            if (G.equal(o.opt_ref, "yes"))
            {
                Program.databanks.GetRef().Clear();
                if (Program.databanks.GetRef().aliasName == Globals.Work || Program.databanks.GetRef().aliasName == Globals.Ref) Program.databanks.GetRef().FileNameWithPath = null;
                G.Writeln2("Cleared ref databank ('" + Program.databanks.GetRef().aliasName + "')");
            }
            if (o.name == null && !G.equal(o.opt_first, "yes") && !G.equal(o.opt_ref, "yes"))
            {
                //Before: Cleared 'Work' and 'Ref' regardless of position
                Program.databanks.GetFirst().Clear();
                Program.databanks.GetRef().Clear();
                if (Program.databanks.GetFirst().aliasName == Globals.Work || Program.databanks.GetFirst().aliasName == Globals.Ref) Program.databanks.GetFirst().FileNameWithPath = null;
                if (Program.databanks.GetRef().aliasName == Globals.Work || Program.databanks.GetRef().aliasName == Globals.Ref) Program.databanks.GetRef().FileNameWithPath = null;
                G.Writeln2("Cleared first and ref databanks ('" + Program.databanks.GetFirst().aliasName + "' and '" + Program.databanks.GetRef().aliasName + "')");
            }
        }


        public static void MaybeWriteOpenDatabank(Databank removed)
        {
            if (Program.IsDatabankDirty(removed))
            {
                if (removed.save == false)
                {
                    G.Writeln2("Databank '" + removed.aliasName + "' closed, changes not written to file");
                }
                else if (removed.protect)
                {
                    G.Writeln2("*** ERROR: Internal error #872543: a non-editable bank should not be possible to alter.");
                    throw new GekkoException();
                }                
                else
                {
                    Program.WriteRemovedDatabank(removed);
                }
            }
        }

        public static void Re(string s, P p)
        {
            //s may be "reset" or "restart"
            bool ini = false;
            if (s == "restart") ini = true;
            Pipe("con", null, true);  //silently (mute) sets output to screen (Gekko might be piping)            
            int w = -12345;
            int b = -12345;
            MaybeWriteOpenDatabanks(ref w, ref b);
            Databank w2 = Program.databanks.storage[w]; w2.Clear();
            Databank b2 = Program.databanks.storage[b]; b2.Clear();
            Program.databanks.storage.Clear();
            Program.databanks.storage.Add(w2);
            Program.databanks.storage.Add(b2);
            w2.FileNameWithPath = null;
            b2.FileNameWithPath = null;
            Globals.createdVariables.Clear();  //these should maybe live inside work databank
            Program.scalars.Clear();
            //Program.lists.Clear();
            //Program.macros.Clear();
            Globals.commandMemory = new CommandMemory();  //these commands are only remembered up to last clearing of workspace
            //Globals.prtCsSnippets.Clear();  //just to save ram  --> can induce bugs
            //Globals.prtCsSnippetsHeaders.Clear(); //just to save ram --> can induce bugs

            //Globals.uFunctionStorageCs = new GekkoDictionary<string, string>(StringComparer.OrdinalIgnoreCase);  //resetting user functions

            Program.model = null; Program.unfoldedVariableList = null;
            Globals.modelFileName = "";
            GuiSetModelName();

            string workingFolder = Program.options.folder_working;
            Program.options = new Options();  //resetting these, but letting working folder live on.
            CrossThreadStuff.Mode();  //to show default color

            Program.GetStartingPeriod();

            Globals.globalPeriodTimeSpans = new GekkoTimeSpans();  //Probably not used anymore
            Globals.globalPeriodTimeFilters = new GekkoTimeSpans();  //nothing in .data yet.
            Globals.globalPeriodTimeFilters2 = new List<GekkoTime>();

            Globals.detectedRPath = null;  //we reset this, too
            Globals.r_fileContent = null;

            if (workingFolder != null && workingFolder != "")
            {
                Program.options.folder_working = workingFolder;
            }
            Globals.lastPrtOrMulprtTable = null;
            CrossThreadStuff.CopyButtonEnabled(false);
            //Globals.hasBeenTsdTsdxOptionChangeSinceLastClear = false;  //this logic can be removed in a couple of years (maybe in 2015)
            G.Writeln();
            G.Writeln("Clearing options, databanks, models, lists, scalars and matrices");
            if (ini) G.Writeln("INI files ('" + Globals.autoExecCmdFileName + "') will be run");
            else G.Writeln("No INI files ('" + Globals.autoExecCmdFileName + "') will be run");
            G.Writeln("You may use 'CLS' to clear the output window.");
            if (ini)
            {
                G.Writeln();
                Program.Ini(p);
            }
            try
            {
                CrossThreadStuff.RestartMenuBrowser();
            }
            catch
            {
                //no need for this to fail badly...
            }
            Globals.guiHomeMainEnabled = false;
            Program.guiBrowseHistory.Clear();
            Program.guiBrowseNumber = 0;
            Globals.guiHomeMenuEnabled = false;
        }

        public static Dictionary<string, int> FindGekkoInbuiltFunctions()
        {
            Dictionary<string, int> gekkoBuiltInFunctions = new Dictionary<string, int>();
            Type myType = (typeof(Functions));
            MethodInfo[] myArrayMethodInfo = myType.GetMethods(BindingFlags.Public | BindingFlags.Static | BindingFlags.DeclaredOnly);
            for (int i = 0; i < myArrayMethodInfo.Length; i++)
            {
                MethodInfo myMethodInfo = (MethodInfo)myArrayMethodInfo[i];
                string name = myMethodInfo.Name.ToLower();  //should be superfluous
                if (!gekkoBuiltInFunctions.ContainsKey(name)) gekkoBuiltInFunctions.Add(name, 1);  //1 is just arbitrary                
            }
            return gekkoBuiltInFunctions;
        }

        public static void MaybeWriteOpenDatabanks(ref int w, ref int b)
        {
            for (int i = 0; i < Program.databanks.storage.Count; i++)
            {
                //The avoids creating new databanks, better to keep the original ones and switch their places.
                if (G.equal(Program.databanks.storage[i].aliasName, Globals.Work)) w = i;
                else if (G.equal(Program.databanks.storage[i].aliasName, Globals.Ref)) b = i;
                else
                {
                    MaybeWriteOpenDatabank(Program.databanks.storage[i]);
                }
            }
        }

        public static void WriteRemovedDatabank(Databank removed)
        {            
            if (removed == null) return;  //See TKD mail 6/6 2016, this should not be possible, but just in case
            if (removed.FileNameWithPath == null) return; //See TKD mail 6/6 2016, this should not be possible, but just in case
            bool skipWrite = false;
            GekkoTime tStart = Globals.tNull;
            GekkoTime tEnd = Globals.tNull;            
            if (!removed.FileNameWithPath.EndsWith("." + Globals.extensionDatabank + ""))
            {                
                G.Writeln2("*** ERROR: The databank '" + removed.aliasName + "' was opened with the OPEN command.");
                G.Writeln("           It has been altered, but the changes cannot be written back to the", Color.Red);
                G.Writeln("           underlying databank file, since this file is not a ." + Globals.extensionDatabank + " file.", Color.Red);
                G.Writeln("           (If the databank was opened with OPEN<edit>, you may use WRITE to write the ", Color.Red);
                G.Writeln("           databank to file).", Color.Red);
                G.Writeln();
                throw new GekkoException();
            }
            if (Globals.testFileChange)
            {
                if (removed.fileHash == null)
                {
                    //do nothing, fileHashing is probably not active
                }
                else if (removed.fileHash == Globals.brandNewFile)
                {
                    if (File.Exists(removed.FileNameWithPath))
                    {
                        MessageBox.Show("*** ERROR: The databank '" + removed.aliasName + "' did not exist when opening it,\nbut seems to exist as a file now. \nHence, Gekko cannot write the databank to file -- \nplease consider to run your code again.");
                        skipWrite = true;
                    }
                }
                else
                {
                    string trueFileHash = Program.GetMD5Hash(GetTextFromFileWithWait(removed.FileNameWithPath));
                    if (!(trueFileHash == removed.fileHash))
                    {
                        MessageBox.Show("*** ERROR: The databank '" + removed.aliasName + "' seems to have been altered since opening it. \nHence, Gekko cannot write the databank to file -- \nplease consider to run your code again.");
                        skipWrite = true;
                    }
                }
            }
            int n = 0;
            if (!skipWrite) n = Write(removed, tStart, tEnd, removed.FileNameWithPath, false, null, "" + Globals.extensionDatabank + "", true, true);
        }
        
        public static string ErrorHandling(string s, P p, bool noWindowShown)
        {
            if (Globals.threadIsInProcessOfAborting)
            {
                p.hasShownErrorHandling = EHasShownErrorHandling.True;  //to make the command files 'Fail' in status window.
                return "stop";
            }
            if (G.IsUnitTesting()) return "stop";

            if (!p.hasBeenCmdFile) return "stop";

            if (s == null) s = "";

            string type = "stop";

            if (p.canShowErrorDialog == true || s == "parser_islooping")  //show only 1 time, unless parsing-looping
            {
                p.hasShownErrorHandling = EHasShownErrorHandling.True;
                Window2 w = new Window2();
                w.p = p;
                if (s == "runtime")
                {
                    int lineNumber5;
                    string fileCalled5;
                    string commandText5;
                    List<string> commandLines5;
                    GetErrorLineAndText(p, p.GetDepth(), out lineNumber5, out fileCalled5, out commandLines5);

                    if (p.hasBeenCompilationError)
                    {
                        //this is shown somewhere else
                        //string text = "*** ERROR: Internal Gekko error regarding file: " + p.lastFileSentToANTLR;
                        //WriteCompileErrorMessage(text);
                    }
                    else
                    {
                        int ln = lineNumber5;

                        commandText5 = "";
                        string text = "";
                        if (ln <= 0)
                        {
                            //this should not happen any more, after fix regarding token line numbers (2/9 2012)
                            text = "*** ERROR: " + "Running file '" + fileCalled5 + "', line [unknown]";
                            commandText5 = "";
                        }
                        else
                        {
                            text = "*** ERROR: " + "Running file '" + fileCalled5 + "', line " + ln;
                            commandText5 = commandLines5[ln - 1];
                        }
                        WriteErrorMessage(ln, commandText5, text, fileCalled5);
                    }

                    WriteCallStack(false, p);

                    w.textBox1.Text = "*** ERROR: Run-time error.";
                    w.textBox1.Text += "\n";
                    w.textBox1.Text += "\n";
                    w.textBox1.Text += "Gekko encountered a run-time error while trying to execute a command line (cf. the Gekko output window). You may stop the program execution ('Stop'), ";
                    w.textBox1.Text += "or try to skip the problematic line ('Skip line')." + "\n" + "\n" + "Skipping a line is usually ok if the line is non-vital for the rest of the program (for instance a print statement), ";
                    w.textBox1.Text += "else you should rerun your program files ('Stop' and run again).";
                    w.textBox1.Text += "\n";
                    w.textBox1.Text += "\n";
                    w.textBox1.Text += "Be warned that skipping these kinds of errors may leave data structures in an inconsistent state, ";
                    w.textBox1.Text += "so when skipping a line, no firm guarantees regarding the results can be issued. (Retrying the file is not ";
                    w.textBox1.Text += "allowed regarding run-time errors, since some of the lines in the file have already been executed).";

                    w.button2.IsEnabled = false;  //retry
                }
                else if (s == "parser" || s == "parser_islooping")
                {
                    w.textBox1.Text = "*** ERROR: Syntax error.";
                    w.textBox1.Text += "\n";
                    w.textBox1.Text += "\n";
                    w.textBox1.Text += "Gekko encountered a syntax error (cf. the Gekko output window). The problematic command file has not been run (since it could not be parsed), so you may try to fix the error and try again. ";
                    w.textBox1.Text += "\n" + "\n" + "If you fix the syntax error now and click 'Retry file', Gekko will continue executing the system of command files as if no error had happened. (If errors persist, the error dialog will show up again).";
                    w.button3.IsEnabled = false;  //skip

                    WriteCallStack(true, p);
                }
                else MessageBox.Show("Error handling: please report this to the developer");
                try
                {
                    CrossThreadStuff.SetReadOnly(true);
                    MaybePlaySound(p);
                    if (!noWindowShown) w.ShowDialog();  //the window is suppressed when debug = "none" (and not "dialog")
                }
                finally
                {
                    CrossThreadStuff.SetReadOnly(false);
                }
                type = w.type;

                if (noWindowShown) type = "stop";  //for some reason, when window not shown, type becomes "close"

                if (type == "stop") p.canShowErrorDialog = false;
                if (type == "retry") p.canShowErrorDialog = true;
                if (type == "skip")
                {
                    p.canShowErrorDialog = true;
                    p.hasShownErrorHandling = EHasShownErrorHandling.TrueAndAlsoSkippedLines;
                }
            }

            if (type == "skip") Globals.numberOfSkippedLines++;

            return type;
        }

        public static void WriteCallStack(bool syntaxError, P p)
        {
            WriteCallStack(true, syntaxError, p);
        }

        public static List<StackHelper> WriteCallStack(bool print, bool syntaxError, P p)
        {

            List<StackHelper> stackLines = new List<StackHelper>();

            int max = p.GetDepth();
            int limit = 1;
            if (syntaxError || p.hasBeenCompilationError) limit = 0;
            if (max > limit)
            {
                //G.Writeln();
                for (int i = 1; i <= max; i++)  //index 0 is not used
                {
                    int lineNumber2;
                    string fileCalled;
                    List<string> commandLines2;
                    GetErrorLineAndText(p, i, out lineNumber2, out fileCalled, out commandLines2);
                    string lineNumber3 = "" + lineNumber2;
                    if (lineNumber2 == 0) lineNumber3 = "[unknown]";

                    if (fileCalled == "")
                    {
                        if (commandLines2.Count == 1)
                        {
                            StackHelper sh = new StackHelper();
                            sh.line = "    " + "Call stack: Command line calling -->";
                            sh.file = "";
                            sh.line2 = lineNumber2;
                            stackLines.Add(sh);
                        }
                        else
                        {
                            StackHelper sh = new StackHelper();
                            sh.line = "    " + "Call stack: Command block line " + lineNumber3 + " calling -->";
                            sh.file = "";
                            sh.line2 = lineNumber2;
                            stackLines.Add(sh);
                        }
                    }
                    else
                    {

                        if (i < max || syntaxError)
                        {
                            StackHelper sh = new StackHelper();
                            sh.line = "    " + fileCalled + " line " + lineNumber3 + " calling -->";
                            sh.file = fileCalled;
                            sh.line2 = lineNumber2;
                            stackLines.Add(sh);
                        }
                        else
                        {
                            StackHelper sh = new StackHelper();
                            sh.line = "    " + fileCalled + " (run-time error in line " + lineNumber3 + ")";
                            sh.file = fileCalled;
                            sh.line2 = lineNumber2;
                            stackLines.Add(sh);
                        }
                    }
                }
                if (syntaxError || p.hasBeenCompilationError)
                {
                    StackHelper sh = new StackHelper();
                    sh.line = "    " + p.lastFileSentToANTLR + " (syntax error)";
                    sh.file = p.lastFileSentToANTLR;
                    stackLines.Add(sh);
                }

                string tablefile = null;
                foreach (StackHelper sh in stackLines)
                {
                    if (sh.file.Contains("tablecode." + Globals.defaultCommandFileExtension))
                    {
                        tablefile = GetOriginalTableFileName(sh.file);
                    }
                }

                if (print)
                {
                    if (tablefile != null)
                    {
                        G.Writeln2("*** ERROR: Table file failed: " + tablefile);
                    }

                    G.Writeln();
                    foreach (StackHelper sh in stackLines)
                    {
                        if (sh.file.Contains("tablecode." + Globals.defaultCommandFileExtension))
                        {
                            string tablefile2 = GetOriginalTableFileName(sh.file);
                            G.Writeln("    " + tablefile2 + " calling -->", Color.Gray, true);
                        }
                        G.Writeln(sh.line, Color.Gray, true);
                    }
                    G.Writeln();
                }
            }
            return stackLines;
        }

        public static void GetErrorLineAndText(P p, int i, out int lineNumber2, out string lineText, out List<string> commandLines)
        {
            string command = p.GetStack(i);
            string fileText = p.GetStackCommandFileText(i - 1);
            if (command == null)
            {
                lineText = "[?]";
                lineNumber2 = 0;
            }
            else
            {
                SplitCommandBeingExecuted(out lineText, out lineNumber2, command);
            }
            commandLines = CreateListOfStringsFromString(fileText);
            //commandText = commandLines2[lineNumber2 - 1];
        }

        public static void Flush()
        {
            DeleteFolder(Globals.localTempFilesLocation);
            G.Writeln();
            G.Writeln("Temporary folder was flushed:");
            G.Writeln("  " + Globals.localTempFilesLocation);
        }

        public static void Cls(string tab)
        {
            CrossThreadStuff.Cls(tab);
        }

        public static void XmlTable(string filename, string html, string window, P p)
        {

            string tempfile = Globals.localTempFilesLocation + "\\" + "tablecode." + Globals.defaultCommandFileExtension;
            if (File.Exists(tempfile))
            {
                WaitForFileDelete(tempfile);  //for safety
            }

            if (Globals.runningOnTTComputer && Globals.showTimings) G.Writeln("Parse/translate XML table start: " + G.SecondsFormat((DateTime.Now - p.startingTime).TotalMilliseconds), Color.LightBlue);

            XmlDocument doc = new XmlDocument();

            string xmlText = GetTextFromFileWithWait(filename);

            XmlHelper xh = new XmlHelper();
            //using (FileStream fs = WaitForFileStream(filename, GekkoFileReadOrWrite.Read))
            //{

            //To convert to lower case: http://mel-green.com/2009/04/lowercase-xml-regex-csharp/
            //            Regex.Replace(
            //xml,
            //@"<[^<>]+>",
            //m => { return m.Value.ToLower(); },
            //RegexOptions.Multiline | RegexOptions.Singleline);

            //xmlText = xmlText.Replace("'", "´");
            //xmlText = xmlText.Replace("`", "´");

            try
            {
                doc.LoadXml(xmlText);
            }
            catch (Exception e)
            {
                G.Writeln();
                G.Writeln("*** ERROR: Table file: '" + filename + "'");
                WriteXmlError(e, filename);
                throw new GekkoException();
            }

            VisitChildrenAndPutAssignvarsIntoNodes(doc, 0);

            CountRowsCols(doc, 0, xh);
            VisitChildren(doc, 0, xh);

            XmlNode rows = doc.SelectSingleNode("//rows");
            foreach (XmlNode row in rows.ChildNodes)
            {
                HandleXmlRow(xh, row);
            }

            bool isHtml = false;
            if (G.equal(Program.options.table_type, "html")) isHtml = true;
            if (G.equal(html, "yes")) isHtml = true;  //overrides if 'yes'

            StringBuilder s3 = new StringBuilder();
            if (isHtml && !G.equal(window, "main"))
            {
                s3.AppendLine("TABLE tab.Print('html');");
            }
            else if (isHtml && G.equal(window, "main"))
            {
                s3.AppendLine("TABLE tab.Print('html_main');");
            }
            else
            {
                //This will catch other cases, that is, txt
                s3.AppendLine("TABLE tab.Print();");
            }

            StringBuilder s2 = new StringBuilder();


            s2.AppendLine(Globals.tableConverterText1);
            s2.AppendLine(Globals.tableConverterText2);
            s2.AppendLine(Globals.tableConverterText3 + filename);
            s2.AppendLine(Globals.tableConverterText4);
            s2.AppendLine(Globals.tableConverterText5);

            s2.AppendLine("DATE __t1 = %__tabletimestart;");
            s2.AppendLine("DATE __t2 = %__tabletimeend;");
            s2.AppendLine("TABLE tab = new Table();");
            s2.AppendLine("VAL __periods = %__t2 - %__t1 + 1 - filteredperiods(%__t1, %__t2);");
            s2.AppendLine("VAL __c1 = 1;");

            string s = s2.ToString() + xh.s.ToString() + xh.sEnd.ToString() + s3.ToString();

            using (FileStream fs2 = WaitForFileStream(tempfile, GekkoFileReadOrWrite.Write))
            using (StreamWriter tempfile2 = G.GekkoStreamWriter(fs2))
            {
                tempfile2.Write(s);
                tempfile2.Flush();
                tempfile2.Close();
            }

            if (Globals.runningOnTTComputer && Globals.showTimings) G.Writeln("Parse/translate XML table end: " + G.SecondsFormat((DateTime.Now - p.startingTime).TotalMilliseconds), Color.LightBlue);
            //}
        }

        public static void WriteXmlError(Exception e, string file)
        {
            G.Writeln2("*** ERROR: The file seems to be invalid as regards XML syntax:");
            if (e.InnerException != null) G.Writeln("           " + e.InnerException.Message, Color.Red);
            else G.Writeln("           " + e.Message, Color.Red);
        }

        private static void HandleXmlRow(XmlHelper xh, XmlNode row)
        {

            if (row.Name == "row")
            {
                xh.rowCounter++;
                if (xh.rowCounter == xh.totalRows)
                    xh.isLastRow = true;
            }

            if (row.Name == "rowformat")
            {
                Attrib a = new Attrib();
                GetAttributes(row, a);
                MergeAttributes(xh.rowGlobal, a);
            }

            if (row.Name == "colbordershow")
            {
                if (row.ChildNodes.Count > 0)
                {
                    G.Writeln2("*** ERROR: XML table: element '" + row.Name + "' should not have sub-elements");
                    throw new GekkoException();
                }
                if (!xh.isLastRow)
                {
                    xh.s.AppendLine("TABLE tab.CurRow.ShowBorders();");
                }
            }

            if (row.Name == "colborderhide")
            {
                int totalBorders = xh.colLeftBorders.Count + xh.colRightBorderPlusOne.Count;
                string nodeText = row.InnerText;
                List<int> killCols = new List<int>();
                //nodeText="" means all borders
                if (row.ChildNodes.Count > 1)
                {
                    G.Writeln2("*** ERROR: XML table: element '" + row.Name + "' should not have sub-elements");
                    throw new GekkoException();
                }

                if (nodeText != "" && nodeText != "inner" && nodeText != "outer")
                {
                    string[] cols2 = nodeText.Split(',');
                    foreach (string s in cols2)
                    {
                        int col = -12345;
                        if (!int.TryParse(s, out col))
                        {
                            G.Writeln2("*** ERROR: XML table: could not convert '" + s + "' to list of integers");
                        }
                        killCols.Add(col);
                    }
                }

                if (killCols.Count == 0)
                {
                    for (int i = 1; i <= totalBorders; i++)
                    {
                        if (nodeText == "outer" && (i > 1 && i < totalBorders)) continue;
                        if (nodeText == "inner" && (i == 1 || i == totalBorders)) continue;
                        XmlDisableBorder(xh, i);
                    }
                }
                else
                {
                    foreach (int i in killCols)
                    {
                        XmlDisableBorder(xh, i);
                    }
                }



            }

            if (row.Name == "row")
            {
                //G.Writeln("+++ " + row.Name + ":" + row.InnerText);

                Attrib rowA = new Attrib();
                GetAttributes(row, rowA);
                int counter = 0;
                foreach (XmlNode node in row.ChildNodes)
                {
                    string nodeName = node.Name;
                    string nodeText = node.InnerText;

                    if (nodeText.Contains("'"))
                    {
                        //G.Writeln();
                        //G.Writeln("+++ WARNING: XML table should not contain this hyphen: '");
                        //G.Writeln("             The hyphen is changed to this hyphen: ´ (see the key to the left of the backspace key)");
                        //G.Writeln("             Please change the table file, in order for this warning to disappear. The reason the");
                        //G.Writeln("             hyphen is problematic is that it is used to denote strings in Gekko command files.");
                        //G.Writeln("             File: " + filename);
                        //G.Writeln("    " + "[" + G.IntFormat(i + 1, 4) + "]:" + "   " + G.ReplaceGlueNew(line), Color.Blue);
                        nodeText = nodeText.Replace("'", "´");
                    }

                    if (nodeText.Contains("`"))
                    {
                        //G.Writeln();
                        //G.Writeln("+++ WARNING: XML table should not contain this hyphen: `");
                        //G.Writeln("             The hyphen is changed to this hyphen: ´ (see the key to the left of the backspace key)");
                        //G.Writeln("             Please change the table file, in order for this warning to disappear. The reason the");
                        //G.Writeln("             hyphen is problematic is that it is used internally in Gekko for other purposes.");
                        //G.Writeln("             File: " + filename);
                        //G.Writeln("    " + "[" + G.IntFormat(i + 1, 4) + "]:" + "   " + G.ReplaceGlueNew(line), Color.Blue);
                        nodeText = nodeText.Replace("`", "´");
                    }

                    if (nodeText.Contains("\""))
                    {
                        nodeText = nodeText.Replace("\"", "´");
                    }

                    //nodeText = nodeText.Trim();  //also removes blank lines if there are any by accident

                    counter++;
                    if (counter > xh.cols.Count)
                    {
                        G.Writeln2("*** ERROR in XML table: there were more elements put into a <row> than defined columns");
                        G.Writeln("    Please note that since Gekko 1.5.7, the behavoior regarding attribute 'colspan' has ");
                        G.Writeln("    been changed so that for instance after '<txt colspan = \"3\">', the next column");
                        G.Writeln("    will be the 4. column (and not the 2. column as in Gekko versions prior to 1.5.7.");
                        G.Writeln("    So if you use 'colspan', you may have to remove some empty <txt> tags...");
                        throw new GekkoException();
                    }
                    Attrib colInfo = xh.cols[counter - 1].attrib;
                    Attrib childA = new Attrib();
                    GetAttributes(node, childA);

                    Attrib a = new Attrib();
                    MergeAttributes(a, xh.table);       //completely global options
                    MergeAttributes(a, colInfo);        //options related to a specific column
                    MergeAttributes(a, xh.rowGlobal);   //options defined in <rowformat>
                    MergeAttributes(a, rowA);           //options defined in particular <row>
                    MergeAttributes(a, childA);         //options defined in particular item in row (i.e., column)

                    string a_vardisplay = a.Get("vardisplay");
                    if (a_vardisplay == null) a_vardisplay = "n";

                    string a_varscale = a.Get("varscale");
                    if (a_varscale == null) a_varscale = "1.0";

                    string a_varformat = a.Get("varformat");
                    if (a_varformat == null) a_varformat = "f12.2";  //we say that is default is nothing is stated at all

                    string a_datealign = a.Get("datealign");
                    if (a_datealign == null) a_datealign = "right";

                    string a_txtalign = a.Get("txtalign");
                    if (a_txtalign == null) a_txtalign = "left";

                    string a_colspan = a.Get("colspan");
                    if (a_colspan == null) a_colspan = "1";
                    int a_colspanint = GetIntFromAttrib(a_colspan);

                    //G.Writeln(nodeName);

                    if (nodeName == "txt")
                    {
                        if (nodeText == "$")
                        {
                            //text taken from next <var> tag
                            XmlNode next = node.NextSibling;
                            if (next != null)
                            {
                                string nextName = next.Name;
                                string nextText = next.InnerText;
                                if (nextName == "var")
                                {
                                    if (nextText != "")
                                    {
                                        nodeText = nextText;
                                    }
                                }
                            }
                        }

                        if ((nodeText == null || nodeText == "") && a_colspanint <= 1)
                        {
                            //#872483274
                            //do nothing, no need to do any MergeCols etc. for an empty <txt/> without span.
                            //and this would also interfere with subcolborder that would become broken.
                        }
                        else
                        {
                            xh.s.AppendLine("TABLE tab.CurRow.SetText(%__c" + counter + ", '" + nodeText + "');");
                            if (a_txtalign == "center")
                            {
                                xh.s.AppendLine("TABLE tab.CurRow.AlignCenter(%__c" + counter + ");");
                            }
                            else if (a_txtalign == "right")
                            {
                                xh.s.AppendLine("TABLE tab.CurRow.AlignRight(%__c" + counter + ");");
                            }
                            //could this not be omitted if a_colspanint is = 1???
                            //NO: THE COLS MIGHT GET SPANNED DUE TO DATES: SO THIS LOGIC IS NEEDED for stuff spanning through dates!!!!
                            xh.s.AppendLine("TABLE tab.CurRow.MergeCols(%__c" + counter + ", %__c" + (counter + a_colspanint) + " - 1);");
                        }

                        //If colspan is 2, this skips one more column to the right than normal
                        //Corresponds to HTML table behavior.
                        //Gekko versions < 1.5.7 did not have this skip.
                        counter += a_colspanint - 1;
                    }
                    else if (nodeName == "var")
                    {
                        string nodeText2 = nodeText.Trim();
                        if (nodeText2.ToLower().StartsWith("genr "))
                            nodeText2 = nodeText2.Substring("genr ".Length);
                        else if (nodeText2.ToLower().StartsWith("ser "))
                            nodeText2 = nodeText2.Substring("ser ".Length);
                        else if (nodeText2.ToLower().StartsWith("series "))
                            nodeText2 = nodeText2.Substring("series ".Length);

                        if (colInfo.Get("type") == "expand")
                        {
                            xh.s.AppendLine("TABLE tab.CurRow.SetValues(%__c" + counter + ", %__t1, %__t2, " + nodeText2 + ", '" + a_vardisplay + "', " + a_varscale + ", '" + a_varformat + "');");
                        }
                        else if (colInfo.Get("period") != null)
                        {
                            string date = colInfo.Get("period");
                            xh.s.AppendLine("TABLE tab.CurRow.SetValues(%__c" + counter + ", " + date + ", " + date + ", " + nodeText2 + ", '" + a_vardisplay + "', " + a_varscale + ", '" + a_varformat + "');");
                        }
                        else
                        {
                            G.Writeln2("*** ERROR: You are trying to put a variable into a column that is not expandable or of 'period' type");
                            throw new GekkoException();
                        }
                        //G.Writeln(nodeName + ":" + nodeText);
                    }
                    else if (nodeName == "date")
                    {
                        if (colInfo.Get("type") == "expand")
                        {
                            xh.s.AppendLine("TABLE tab.CurRow.SetDates(%__c" + counter + ", %__t1, %__t2);");
                        }
                        else if (colInfo.Get("period") != null)
                        {
                            string date = colInfo.Get("period");
                            xh.s.AppendLine("TABLE tab.CurRow.SetDates(%__c" + counter + ", " + date + ", " + date + ");");
                        }
                        else
                        {
                            G.Writeln2("*** ERROR: You are trying to put a date into a column that is not expandable or of 'period' type");
                            throw new GekkoException();
                        }
                        //G.Writeln(nodeName + ":" + nodeText);
                    }
                }
            }

            if (row.Name == "rowborder")
            {
                if (xh.isLastRow)
                {
                    xh.s.AppendLine("TABLE tab.CurRow.SetBottomBorder(1, %__c" + (xh.cols.Count + 1) + " - 1);");
                }
                else
                {
                    xh.s.AppendLine("TABLE tab.CurRow.SetTopBorder(1, %__c" + (xh.cols.Count + 1) + " - 1);");
                }
            }
            if (row.Name == "row")  //this must be the last part of XML row handling
            {
                if (!xh.isLastRow)
                {
                    xh.s.AppendLine("TABLE tab.CurRow.Next();");
                }
            }
        }

        private static void XmlDisableBorder(XmlHelper xh, int i)
        {
            int totalBorders = xh.colLeftBorders.Count + xh.colRightBorderPlusOne.Count;

            if (i < 1 || i > totalBorders)
            {
                G.Writeln2("*** ERROR: XML table: <colborderhide> should have numbers between 1 and " + totalBorders + " (inclusive)");
                throw new GekkoException();
            }
            if (i < totalBorders)
            {
                //This can maybe fail ([i-1] call)
                if (i - 1 >= 0 && i - 1 < xh.colLeftBorders.Count)
                {
                    xh.s.AppendLine("TABLE tab.CurRow.HideLeftBorder(%__c" + xh.colLeftBorders[i - 1] + ");");
                }

            }
            else
            {
                //This can fail ([0] call)
                if (0 < xh.colRightBorderPlusOne.Count)
                {
                    xh.s.AppendLine("TABLE tab.CurRow.HideRightBorder(%__c" + xh.colRightBorderPlusOne[0] + " - 1);");
                }
            }
        }

        private static int GetIntFromAttrib(string input)
        {
            int parsed = -12345;
            if (!int.TryParse(input, out parsed))
            {
                G.Writeln2("*** ERROR: Could not parse colspan '" + input + "' into an integer");
                throw new GekkoException();
            }
            return parsed;
        }

        static void CountRowsCols(XmlNode node, int level, XmlHelper xh)
        {
            if (node.Name == "col") xh.totalCols++;
            if (node.Name == "row") xh.totalRows++;

            foreach (XmlNode echild in node.ChildNodes)
            {
                CountRowsCols(echild, level + 1, xh);
            }
        }

        static void VisitChildren(XmlNode node, int level, XmlHelper xh)
        {
            //G.Writeln("-".PadLeft(level + 1) + "" + node.Name + ": " + node.Value);

            if (node.Name == "cols")
            {
                Attrib a = new Attrib();
                GetAttributes(node, a);
            }

            if (node.Name == "col")
            {
                xh.cols.Add(new XmlColInfo());
            }

            if (node.Attributes != null)
            {
                Attrib a = null;
                if (node.Name == "table")
                {
                    a = xh.table;
                }
                else if (node.Name == "col")
                {
                    a = xh.cols[xh.cols.Count - 1].attrib;
                }
                if (a != null)
                {
                    GetAttributes(node, a);
                }
            }

            if (node.Name == "col")
            {
                int last = 0;
                if (xh.colB.Count > 0) last = xh.colB[xh.colB.Count - 1];
                xh.colA.Add(last + 1);
                Attrib aa = xh.cols[xh.cols.Count - 1].attrib;
                string add = "1";
                if (aa.Get("type") == "expand")
                {
                    add = "%__periods";
                }
                xh.s.AppendLine("VAL __c" + (xh.cols.Count + 1) + " = %__c" + (xh.cols.Count) + " + " + add + ";");
            }

            if (node.Name == "colborder")
            {
                if (xh.cols.Count < xh.totalCols)
                {
                    int temp = xh.cols.Count + 1;
                    xh.sEnd.AppendLine("TABLE tab.CurRow.SetLeftBorder(%__c" + temp + ");");
                    xh.colLeftBorders.Add(temp);

                }
                else
                {
                    int temp = xh.cols.Count + 1;
                    xh.sEnd.AppendLine("TABLE tab.CurRow.SetRightBorder(%__c" + temp + " - 1);");
                    xh.colRightBorderPlusOne.Add(temp);
                }
            }

            if (node.Name == "subcolborder")  //must be child of <col>, puts data into this <col> (its parent)
            {
                Attrib a = new Attrib();
                if (node.Attributes != null)
                {
                    GetAttributes(node, a);
                }
                XmlColInfo xci = xh.cols[xh.cols.Count - 1];
                string per = a.Get("period");
                xci.subcolborders.Add(per);

                xh.sEnd.AppendLine("TABLE tab.CurRow.SetRightBorder(%__c" + xh.cols.Count + " + (date(" + per + ") - %__t1) - filteredperiods(%__t1, date(" + per + ")), 'gray');");


            }

            foreach (XmlNode echild in node.ChildNodes)
            {
                VisitChildren(echild, level + 1, xh);
            }
        }

        static void VisitChildrenAndPutAssignvarsIntoNodes(XmlNode node, int level)
        {
            //G.Write(G.Blanks(level) + node.Name + " ");
            if (node.Attributes != null)
            {
                foreach (XmlAttribute achild in node.Attributes)
                {
                    //achild.Value = achild.Value + "_12345";
                    //string name = achild.LocalName;
                    //string value = achild.Value;
                    //achild.Value = SubstituteAssignVarsInExpression(achild.Value);
                    //G.Write("[attrib] " + name + "=\"" + value + "\" ");
                }
            }

            //why isnt .Value used in other places (seems innertext or so)
            //here we could substitute, remember the \\# etc.
            //string text = null;
            if (node.NodeType == XmlNodeType.Text || node.NodeType == XmlNodeType.CDATA)
            {
                node.Value = node.Value;
                //text = node.Value;
            }
            //G.Writeln("[value] \"" + text + "\"");

            foreach (XmlNode echild in node.ChildNodes)
            {
                VisitChildrenAndPutAssignvarsIntoNodes(echild, level + 1);
            }
        }

        private static void GetAttributes(XmlNode node, Attrib a)
        {
            if (node.Attributes == null) return;
            foreach (XmlAttribute achild in node.Attributes)
            {
                string name = achild.LocalName;
                string value = achild.Value;
                if (a.Set(name, value) == false)
                {
                    G.Writeln2("*** ERROR: XML table has duplicate attribute name: " + name);
                }
            }
        }

        private static void MergeAttributes(Attrib result, Attrib newItems)
        {
            foreach (var item in newItems.data)
            {
                result.data[item.Key] = item.Value;
            }
        }

        public static void PrintTable(Table tab)
        {
            PrintTable(tab, true, null);
        }

        public static void PrintTable(Table tab, string type)
        {
            PrintTable(tab, true, type);
        }

        public static void PrintTable(Table tab, bool printDateEtc, string printType)
        {
            Globals.lastPrtOrMulprtTable = tab;
            CrossThreadStuff.CopyButtonEnabled(true);
            //This method does NOT alter the table as a side-effect (because of ObjectCopier.Clone).
            bool printRawCode = false;

            //TODO: table types are a bit messy: clean this up at some point
            if (G.equal(printType, "html_main"))
            {
                printType = "html";
                printRawCode = true;
            }
            if (printType == null && G.equal(Program.options.table_type, "html"))
            {
                printType = "html";  //overrides txt, so "TABLE s1" or calling from menu will -> html table
            }

            List<string> ss = tab.Print(printType);

            string fullFileNameAndPath = Globals.localTempFilesLocation + "\\" + "table.html";

            StampTypes type = StampTypes.Normal;
            if (G.equal(Globals.tableOption, "m")) type = StampTypes.Multiplier;
            else if (G.equal(Globals.tableOption, Globals.printCode_s)) type = StampTypes.Base;
            List<string> lines = GetDatabankInfo(type);
            if (Program.options.table_stamp)
            {
                string printed = "Table printed: " + GetDateTimeStamp();
                lines.Add(printed);
            }

            string pTag = "<p CLASS=\"gfsize gfont\" style=\"color: silver; margin: 2px;\">";

            if (printType == "html")
            {
                //---------------------
                //         HTML
                //---------------------
                if (printRawCode)
                {
                    int widthRemember = Program.options.print_width;
                    int fileWidthRemember = Program.options.print_filewidth;
                    Program.options.print_width = int.MaxValue;
                    Program.options.print_filewidth = int.MaxValue;
                    try
                    {
                        G.Write(pTag);
                        for (int i = 0; i < lines.Count; i++)
                        {
                            G.Write(lines[i]);
                            if (i < lines.Count - 1) G.Writeln("<br>");
                        }
                        G.Writeln("</p>");
                        foreach (string line in ss) G.Writeln(line);
                    }
                    catch (Exception e)
                    {
                        G.Writeln2("*** ERROR: Table (in html format) could not be written");
                        throw new GekkoException();
                    }
                    finally
                    {
                        //resetting, also if there is an error
                        Program.options.print_width = widthRemember;
                        Program.options.print_filewidth = fileWidthRemember;
                    }
                }
                else
                {
                    string s1 = Globals.htmlFileStart1 + GetHtmlHeaderCssStyles() + Globals.htmlFileStart2;
                    string s2 = Globals.htmlFileEnd;

                    using (FileStream fs = Program.WaitForFileStream(fullFileNameAndPath, Program.GekkoFileReadOrWrite.Write))
                    using (StreamWriter sw = G.GekkoStreamWriter(fs))
                    {
                        sw.Write(s1);

                        string s5 = null;

                        s5 += pTag + "<a href=\"#\"   onclick=\"document.getElementById('hiddenText').style.display='block'; return false;\">Transform options</a> " + "</p>";

                        s5 += "<div style=\"display: none;\" id=\"hiddenText\">" + G.NL;
                        string s = "style = \"margin:0; padding:0; opacity : 0.5;\"";                        

                        s5 += "<table CLASS=\"gfsize gfont\"  style=\"color:gray\" >";
                        s5 += " <tr>";
                        s5 += "   <td></td>";
                        s5 += "   <td>First &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </td>";
                        s5 += "   <td>Reference &nbsp; &nbsp; &nbsp; &nbsp; </td>";
                        s5 += "   <td>Multiplier</td>";
                        s5 += " </tr>";
                        s5 += " <tr>";
                        s5 += "   <td>Levels &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  </td>";
                        s5 += "   <td><input title=\"Levels as they are in first databank\" CLASS=\"gfsize gfont\" type=\"radio\" name=\"table\" " + s + " onclick=\"window.location='table.html#n" + "';\"/>n</td>";
                        s5 += "   <td><input title=\"Levels as they are in reference databank\"  CLASS=\"gfsize gfont\" type=\"radio\" name=\"table\" " + s + " onclick=\"window.location='table.html#rn" + "';\"/>r&thinsp;n</td>";
                        s5 += "   <td></td>";
                        s5 += " </tr>";
                        s5 += " <tr>";
                        s5 += "   <td>Abs. diff.</td>";
                        s5 += "   <td><input title=\"Absolute time-change (difference) in first databank\" CLASS=\"gfsize gfont\" type=\"radio\" name=\"table\" " + s + " onclick=\"window.location='table.html#d" + "';\"/>d</td>";
                        s5 += "   <td><input title=\"Absolute time-change (difference) in reference databank\" CLASS=\"gfsize gfont\" type=\"radio\" name=\"table\" " + s + " onclick=\"window.location='table.html#rd" + "';\"/>r&thinsp;d</td>";
                        s5 += "   <td><input title=\"Absolute multiplier difference\" CLASS=\"gfsize gfont\" type=\"radio\" name=\"table\" " + s + " onclick=\"window.location='table.html#m" + "';\"/>m</td>";
                        s5 += " </tr>";
                        s5 += " <tr>";
                        s5 += "   <td>Rel. diff.</td>";
                        s5 += "   <td><input title=\"Percentage time growth rate in first databank\" CLASS=\"gfsize gfont\" type=\"radio\" name=\"table\" " + s + " onclick=\"window.location='table.html#p" + "';\"/>p</td>";
                        s5 += "   <td><input title=\"Percentage time growth rate in reference databank\" CLASS=\"gfsize gfont\" type=\"radio\" name=\"table\" " + s + " onclick=\"window.location='table.html#rp" + "';\"/>r&thinsp;p</td>";
                        s5 += "   <td><input title=\"Percentage multiplier difference\" CLASS=\"gfsize gfont\" type=\"radio\" name=\"table\" " + s + " onclick=\"window.location='table.html#q" + "';\"/>q</td>";
                        s5 += " </tr>";
                        s5 += " <tr>";
                        s5 += " </tr>";
                        s5 += " </table>";


                        s5 += "</div>" + G.NL;

                        if (Program.options.interface_table_printcodes) sw.Write(s5);
                        sw.Write(pTag);
                        for (int i = 0; i < lines.Count; i++)
                        {
                            sw.Write(lines[i]);
                            if (i < lines.Count - 1) sw.WriteLine("<br>");
                        }
                        sw.WriteLine("</p>");

                        foreach (string line in ss) sw.WriteLine(line);
                        sw.Write(s2);
                        sw.Close();
                    }

                    if (!G.IsUnitTesting())
                    {
                        CrossThreadStuff.SetTab("menu", true);
                        Gui.gui.webBrowser.Url = new Uri("file:///" + Globals.localTempFilesLocation + "\\table.html");
                        CrossThreadStuff.SetTab("menu", true);
                    }
                }
            }
            else
            {
                //---------------------
                //         TXT
                //---------------------
                int widthRemember = Program.options.print_width;
                int fileWidthRemember = Program.options.print_filewidth;
                Program.options.print_width = int.MaxValue;
                Program.options.print_filewidth = int.MaxValue;
                G.Writeln();
                try
                {
                    if (printDateEtc)
                    {
                        foreach (string s in lines) G.Writeln(s);
                        //G.Writeln(printed);
                    }
                    foreach (string s in ss) G.Writeln(s);
                    G.Writeln();
                }
                catch (Exception e)
                {
                    G.Writeln2("*** ERROR: Table (in txt format) could not be written");
                    throw new GekkoException();
                }
                finally
                {
                    //resetting, also if there is an error
                    Program.options.print_width = widthRemember;
                    Program.options.print_filewidth = fileWidthRemember;
                }
            }
        }

        private static List<string> GetDatabankInfo(StampTypes type)
        {
            Databank work = Program.databanks.GetFirst();
            Databank base2 = Program.databanks.GetRef();
            string workInfo = "";
            if (work != null && work.info1 != null) workInfo = work.info1;
            string base2Info = "";
            if (base2 != null && base2.info1 != null) base2Info = base2.info1;
            string workDate = "";
            if (work != null && work.date != null) workDate = work.date;
            string base2Date = "";
            if (base2 != null && base2.date != null) base2Date = base2.date;

            List<string> lines = new List<string>();
            if (type == StampTypes.Multiplier)
            {
                lines.Add("Multiplier");
                if (workInfo != "") lines.Add(workInfo + " [" + workDate + "]");
                if (base2Info != "") lines.Add("Reference: " + base2Info + " [" + base2Date + "]");
            }
            else if (type == StampTypes.Base)
            {
                if (base2Info != "") lines.Add("Reference: " + base2Info + " [" + base2Date + "]");
            }
            else
            {
                if (workInfo != "") lines.Add(workInfo + " [" + workDate + "]");
            }
            return lines;
        }


        // --------------------------------------------------------------------------------------
        // ----------------- used for tables start ----------------------------------------------
        // --------------------------------------------------------------------------------------

        //Used for tables, don't use for other stuff!
        public static double Level(string db2, string s, GekkoTime t)
        {
            Databank db = Program.databanks.GetDatabank(db2);
            if (!db.ContainsVariable(s))
            {
                if (Program.options.table_ignoremissingvars)
                {
                    return Globals.missingVariableArtificialNumber;
                }
                else
                {
                    G.Writeln2("*** ERROR: could not find variable " + s + " in " + db2 + " databank");
                }
            }
            return db.GetVariable(s).GetData(t);
        }

        //Used for tables, don't use for other stuff!
        public static double MulLevel(string s, GekkoTime t)
        {
            if (!Program.databanks.GetFirst().ContainsVariable(s))
            {
                if (Program.options.table_ignoremissingvars)
                {
                    return Globals.missingVariableArtificialNumber;
                }
                else
                {
                    G.Writeln2("*** ERROR: could not find variable " + s + " in Work databank");
                }
            }
            if (!Program.databanks.GetRef().ContainsVariable(s))
            {
                if (Program.options.table_ignoremissingvars)
                {
                    return Globals.missingVariableArtificialNumber;
                }
                else
                {
                    G.Writeln2("*** ERROR: could not find variable " + s + " in " + Globals.Ref + " databank");
                }
            }
            return Program.databanks.GetFirst().GetVariable(s).GetData(t) - Program.databanks.GetRef().GetVariable(s).GetData(t);
        }

        //Used for tables, don't use for other stuff!
        public static double Pch(string db2, string s, GekkoTime t)
        {
            Databank db = Program.databanks.GetDatabank(db2);
            if (!db.ContainsVariable(s))
            {
                if (Program.options.table_ignoremissingvars)
                {
                    return Globals.missingVariableArtificialNumber;
                }
                else
                {
                    G.Writeln2("*** ERROR: could not find variable " + s + " in " + db2 + " databank");
                }
            }
            return (db.GetVariable(s).GetData(t) / db.GetVariable(s).GetData(t.Add(-1)) - 1) * 100;
        }

        //Used for tables, don't use for other stuff!
        public static double MulPch(string s, GekkoTime t)
        {
            if (!Program.databanks.GetFirst().ContainsVariable(s))
            {
                if (Program.options.table_ignoremissingvars)
                {
                    return Globals.missingVariableArtificialNumber;
                }
                else
                {
                    G.Writeln2("*** ERROR: could not find variable " + s + " in Work databank");
                }
            }
            if (!Program.databanks.GetRef().ContainsVariable(s))
            {
                if (Program.options.table_ignoremissingvars)
                {
                    return Globals.missingVariableArtificialNumber;
                }
                else
                {
                    G.Writeln2("*** ERROR: could not find variable " + s + " in " + Globals.Ref + " databank");
                }
            }
            double pch_base = (Program.databanks.GetRef().GetVariable(s).GetData(t) / Program.databanks.GetRef().GetVariable(s).GetData(t.Add(-1)) - 1) * 100;
            double pch_work = (Program.databanks.GetFirst().GetVariable(s).GetData(t) / Program.databanks.GetFirst().GetVariable(s).GetData(t.Add(-1)) - 1) * 100;
            return pch_work - pch_base;
        }

        public static void GetStartingPeriod()
        {
            int year = DateTime.Now.Year;
            if (year < 2015 || year > 2030) year = 2015;
            Globals.globalPeriodStart = new GekkoTime(Program.options.freq, year - 10, 1);
            Globals.globalPeriodEnd = new GekkoTime(Program.options.freq, year + 0, 1);
        }

        public static void Compare(O.Compare o)
        {
            string type = "COMPARE";
            if (G.equal(o.opt_abs, "yes")) type = "COMPARE<abs>";
            string file = o.fileName;
            file = StripQuotes(file);
            G.Writeln();
            List<string> variables = o.listItems;

            if (file != null && file != "")  //is piped to special pipe-file (pipe2)
            {
                //if exception, these will be reset somewhere else, so no need to have a try-catch-finally regarding the file stream
                Globals.pipe2 = true;
                Globals.pipeFileHelper2.pipeFileFileWithPath = CreateFullPathAndFileName(file);
                Globals.pipeFileHelper2.pipeFile = G.GekkoStreamWriter(WaitForFileStream(Globals.pipeFileHelper2.pipeFileFileWithPath, GekkoFileReadOrWrite.Write));
            }

            GekkoTime tStart = o.t1;
            GekkoTime tEnd = o.t2;

            Databank base2 = Program.databanks.GetRef();
            Databank work = Program.databanks.GetFirst();

            List<string> both = variables;  //may be null
            List<string> listOfDifferentVars = new List<string>();
            int count = 0;

            try
            {
                if (true)
                {
                    if (variables == null || variables.Count == 0)
                    {
                        //i.e. we are doing a databank compare, not a residual compare
                        both = new List<string>();
                        List<string> onlyWork = new List<string>();
                        List<string> onlyGrund = new List<string>();

                        foreach (string tsString in work.storage.Keys) 
                        {
                            if (G.GetFreqFromKey(tsString) != Program.options.freq) continue;  //filter out other freqs
                            TimeSeries tsGrund = base2.GetVariable(false, tsString);
                            if (tsGrund == null)
                            {
                                onlyWork.Add(G.RemoveFreqFromKey(tsString));
                            }
                            else
                            {
                                both.Add(G.RemoveFreqFromKey(tsString));
                            }
                        }
                        foreach (string tsString in base2.storage.Keys)  
                        {
                            if (G.GetFreqFromKey(tsString) != Program.options.freq) continue;  //filter out other freqs
                            TimeSeries tsWork = work.GetVariable(false, tsString);
                            if (tsWork == null)
                            {
                                onlyGrund.Add(G.RemoveFreqFromKey(tsString));
                            }
                        }

                        both.Sort(StringComparer.InvariantCulture);
                        onlyWork.Sort(StringComparer.InvariantCulture);
                        onlyGrund.Sort(StringComparer.InvariantCulture);

                        G.Writeln("Comparing " + both.Count + " common variables in Work (" + GetDatabankFileNameWithPath(Globals.Work) + ") and " + Globals.Ref + " (" + GetDatabankFileNameWithPath(Globals.Ref) + ") databanks");
                        if (onlyWork.Count > 0) G.Writeln("There are " + onlyWork.Count + " variables in Work but not in " + Globals.Ref + " databank");
                        if (onlyGrund.Count > 0) G.Writeln("There are " + onlyGrund.Count + " variables in " + Globals.Ref + " but not in Work databank");
                        G.Writeln();
                    }
                    else
                    {
                        both.Sort(StringComparer.InvariantCulture);
                    }

                    if (true)
                    {
                        //There is a little bit unnecessary overhead here, if compareType is "alphabetical". But never mind.
                        foreach (string tsString in both)
                        {
                            TimeSeries ts = work.GetVariable(tsString);
                            TimeSeries tsGrund = base2.GetVariable(tsString);
                            if (ts == null)
                            {
                                G.Writeln("+++ WARNING: variable '" + tsString + "' not found in " + work.aliasName + " databank");
                                continue;
                            }
                            if (tsGrund == null)
                            {
                                G.Writeln("+++ WARNING: variable '" + tsString + "' not found in " + base2.aliasName + " databank");
                                continue;
                            }

                            count++;

                            //See also similar code in Sam()
                            bool isDifferent = false;
                            foreach (GekkoTime t in new GekkoTimeIterator(tStart, tEnd))
                            {
                                double varDelta = 0;
                                double varPch = 0;

                                double var1 = ts.GetData(t);
                                double var2 = tsGrund.GetData(t);
                                if (var1 == 0 && var2 == 0d)
                                {
                                    varPch = 0d;
                                    varDelta = var1 - var2;
                                }
                                else if (var2 == 0)
                                {
                                    varPch = 100000d;
                                    varDelta = var1 - var2;
                                }
                                else if (double.IsNaN(var1) && double.IsNaN(var2))
                                {
                                    //this is considered okay
                                    varPch = 0d;
                                    varDelta = 0d;
                                }
                                else if ((double.IsNaN(var1) && !double.IsNaN(var2)) || (!double.IsNaN(var1) && double.IsNaN(var2)))
                                {
                                    //this is considered a problem
                                    varPch = double.PositiveInfinity;
                                    varDelta = double.PositiveInfinity;
                                }
                                else
                                {
                                    varPch = ((var1 / var2 - 1d) * 100d);
                                    varDelta = var1 - var2;
                                }

                                if (Math.Abs(varPch / 100d) >= Program.options.databank_compare_trel)  //right-hand side here is relative, not percent, therefore division by 100
                                {
                                    double level = Math.Max(Math.Abs(var1), Math.Abs(var2));  //numerically largest in the two banks
                                    if (double.IsNaN(level) || level >= Program.options.databank_compare_tabs)  //if nan, it is typically because 1 or both levels are missing
                                    {
                                        isDifferent = true;
                                        break;  //stop the loop
                                    }
                                }
                            }

                            if (isDifferent) listOfDifferentVars.Add(tsString);
                        }
                    }

                    //databank compare
                    if (file != null)
                    {
                        G.Writeln(type.ToUpper() + " on " + both.Count + " variables, found " + listOfDifferentVars.Count + " differences.");
                        G.Writeln();
                    }

                    if (listOfDifferentVars.Count > 0)
                    {
                        bool showPchRemember = Program.options.print_mulprt_pch;
                        if (G.equal(o.opt_abs, "yes")) Program.options.print_mulprt_pch = false;

                        GekkoTime t1tmp = Globals.globalPeriodStart;
                        GekkoTime t2tmp = Globals.globalPeriodEnd;
                        if (!tStart.IsNull())
                        {
                            Globals.globalPeriodStart = tStart;
                            Globals.globalPeriodEnd = tEnd;
                        }

                        try
                        {
                            MetaList temp = new MetaList(listOfDifferentVars);
                            Program.scalars.Add("#delete_me_12345", temp);
                            //This is somewhat of a hack, calling a MULPRT command indirectly like that
                            //But it really saves a lot of work, instead of wiring up to the Prt() method!
                            Program.obeyCommandCalledFromGUI("MULPRT " + Globals.symbolList + "delete_me_12345;", new P());
                        }
                        finally
                        {
                            //to make sure everything is reset if there is an exception
                            Program.options.print_mulprt_pch = showPchRemember;
                            if (Program.scalars.ContainsKey(Globals.symbolList + "delete_me_12345")) Program.scalars.Remove(Globals.symbolList + "delete_me_12345");
                            if (!tStart.IsNull())
                            {
                                Globals.globalPeriodStart = t1tmp;
                                Globals.globalPeriodEnd = t2tmp;
                            }
                        }
                    }
                }
                ReleasePipe2();  //will get run 2 times (also in finally block), but that is ok
                G.Writeln();
                G.Write(type.ToUpper() + " on " + both.Count + " variables, found " + listOfDifferentVars.Count + " differences. ");
                if (file != null) G.Writeln("Result put in file '" + file + "'");
                G.Writeln();
            }
            finally  //no catch block here, we use try-finally to close any files
            {
                ReleasePipe2();
            }
        }

        //Used for tables, don't use for other stuff!
        public static double Dif(string db2, string s, GekkoTime t)
        {
            Databank db = Program.databanks.GetDatabank(db2);
            if (!db.ContainsVariable(s))
            {
                if (Program.options.table_ignoremissingvars)
                {
                    return Globals.missingVariableArtificialNumber;
                }
                else
                {
                    G.Writeln2("*** ERROR: could not find variable " + s + " in " + db2 + " databank");
                }
            }
            return db.GetVariable(s).GetData(t) - db.GetVariable(s).GetData(t.Add(-1));
        }

        //Used for tables, don't use for other stuff!
        public static double MulDif(string s, GekkoTime t)
        {
            if (!Program.databanks.GetFirst().ContainsVariable(s))
            {
                if (Program.options.table_ignoremissingvars)
                {
                    return Globals.missingVariableArtificialNumber;
                }
                else
                {
                    G.Writeln2("*** ERROR: could not find variable " + s + " in Work databank");
                }
            }
            if (!Program.databanks.GetRef().ContainsVariable(s))
            {
                if (Program.options.table_ignoremissingvars)
                {
                    return Globals.missingVariableArtificialNumber;
                }
                else
                {
                    G.Writeln2("*** ERROR: could not find variable " + s + " in " + Globals.Ref + " databank");
                }
            }
            double dif_base = Program.databanks.GetRef().GetVariable(s).GetData(t) - Program.databanks.GetRef().GetVariable(s).GetData(t.Add(-1));
            double dif_work = Program.databanks.GetFirst().GetVariable(s).GetData(t) - Program.databanks.GetFirst().GetVariable(s).GetData(t.Add(-1));
            return dif_work - dif_base;
        }

        // --------------------------------------------------------------------------------------
        // ----------------- used for tables end ------------------------------------------------
        // --------------------------------------------------------------------------------------

        public static void obeyCommandCalledFromGUI(string s, P p)
        {
            //Globals.prtCsSnippets.Clear();  //to save RAM for long sessions, should be ok to delete it here (otherwise we will just get an exception)
            Program.EmitCodeFromANTLR(s, "", false, p);
            if (!G.IsUnitTesting()) ShowPeriodInStatusField("");
        }

        public static void Create(List<string> varsInput, bool questionMark, O.Create o)
        {
            //ErrorIfDatabanksSwapped();
            if (varsInput == null && questionMark == true)
            {
                int count = Globals.createdVariables.Count;
                if (count == 1) G.Writeln2("There is 1 created variable:");
                else G.Writeln2("There are " + count + " created variables:");
                List<string> a4 = new List<string>();
                foreach (string s in Globals.createdVariables.Keys) a4.Add(s);
                a4.Sort(StringComparer.InvariantCulture);
                foreach (string m in a4)
                {
                    G.Writeln("  " + m);
                }
                G.Writeln();
            }
            else
            {
                List<string> vars = varsInput;
                bool usedInCreateCommand = true;
                int counter = CreateVariables(vars, usedInCreateCommand);
                if (Program.options.databank_create_message)
                {
                    if (counter == 0) G.Writeln2("Did not create any variables");
                    else
                    {
                        if (o.p.IsSimple())
                        {
                            if (counter == 1)
                            {
                                G.Write2("Created 1 variable with freq '" + Program.options.freq + "'" + " "); G.ServiceMessage();
                            }
                            else
                            {
                                G.Write2("Created " + counter + " variables with freq '" + Program.options.freq + "'" + " "); G.ServiceMessage();
                            }
                        }
                    }
                }
                //G.Writeln();
            }
        }

        public static int CreateVariables(List<string> vars, bool usedInCreateCommand)
        {
            int counter = 0;
            foreach (string s in vars)
            {
                string defaultBank = null;
                List<BankNameVersion> list = GetInfoFromStringWildcard(s, defaultBank);
                
                foreach(BankNameVersion bnv in list)
                {
                    //See //#89052349875, maybe merge it
                    Databank db = null;
                    if (bnv.bank == null) db = Program.databanks.GetFirst();
                    else
                    {
                        db = Program.databanks.GetDatabank(bnv.bank);
                        if (db == null)
                        {
                            G.Writeln2("*** ERROR: Could not find databank '" + bnv.bank + "'");
                            throw new GekkoException();
                        }
                    }
                    TimeSeries ts = db.GetVariable(bnv.name);
                    if (ts == null)
                    {
                        //#642842749283
                        ts = new TimeSeries(Program.options.freq, bnv.name);
                        if (!Globals.globalPeriodStart.IsNull())
                        {
                            //WHY is this done. For efficiency afterwards??
                            //TO get start/end date??
                            foreach (GekkoTime gt in new GekkoTimeIterator(Globals.globalPeriodStart, Globals.globalPeriodEnd))
                            {
                                ts.SetData(gt, double.NaN);
                            }
                        }

                        //We know the timeseries does not already exist
                        //database will throw a protecterror if it is non-editable
                        db.AddVariable(ts);

                        if (usedInCreateCommand == true)
                        {
                            //normally it shouldn't exist, but we check for safety
                            if (!Globals.createdVariables.ContainsKey(AddFreqAtEndOfVariableName(ts.variableName)))
                            {
                                Globals.createdVariables.Add(AddFreqAtEndOfVariableName(ts.variableName), "");
                            }
                        }
                        counter++;
                    }
                    else
                    {
                        if (usedInCreateCommand && Program.options.databank_create_message)
                        {
                            G.Writeln2("+++ WARNING: CREATE: variable " + db.aliasName + ":" + ts.variableName + " already exists");
                        }
                    }
                }
            }
                        
            return counter;
        }

        public static void Collapse(string b1, string ss1, string b0, string ss0, string method)
        {
            //ErrorIfDatabanksSwapped(); 

            Databank databank1 = GetDatabank(b1);
            Databank databank0 = GetDatabank(b0);
                        
            if (method == null) method = "total";
        
            string name1;
            EFreq eFreq1;
            GetFreq(ss1, out name1, out eFreq1);

            string name0;
            EFreq eFreq0;
            GetFreq(ss0, out name0, out eFreq0);
                        
            if (eFreq0 == EFreq.Undated || eFreq1 == EFreq.Undated)
            {
                G.Writeln2("*** ERROR: COLLAPSE cannot involve undated timeseries");
                throw new GekkoException();
            }

            TimeSeries ts0 = databank0.GetVariable(eFreq0, name0);
            if (ts0 == null)
            {
                G.Writeln2("*** ERROR: Could not find variable '" + name0 + "' with frequency '" + eFreq0 + "' in '" + databank0.aliasName + "' databank");
                throw new GekkoException();
            }

            TimeSeries ts1 = databank1.GetVariable(eFreq1, name1);
            if (ts1 == null)
            {
                G.Writeln("+++ NOTE: Created new variable '" + name1 + "' with frequency '" + G.GetFreq(eFreq1) + "'");
            }
            else
            {
                //We wipe it completely out if it already exists!
                databank1.RemoveVariable(eFreq1, name1);
            }
            ts1 = new TimeSeries(eFreq1, name1);
            databank1.AddVariable(G.GetFreq(eFreq1), ts1);  //hmmm a mess with all this freq stuff!

            GekkoTime first = ts0.GetPeriodFirst(); //start of high-freq timeseries
            GekkoTime last = ts0.GetPeriodLast(); //end of high-freq timeseries

            double vsum = double.NaN;
            foreach (GekkoTime t in new GekkoTimeIterator(first, last))
            {
                double value = ts0.GetData(t);
                if (eFreq1 == EFreq.Annual && eFreq0 == EFreq.Quarterly)
                {
                    //Conversion from Q to A
                    if (t.sub == 1) vsum = 0d;
                    GekkoTime ttemp = new GekkoTime(eFreq1, t.super, 1);
                    if (G.equal(method, "total"))
                    {
                        vsum += value;
                        if (t.sub == Globals.freqQSubperiods) ts1.SetData(ttemp, vsum);
                    }
                    else if (G.equal(method, "avg"))
                    {
                        vsum += value;
                        if (t.sub == Globals.freqQSubperiods) ts1.SetData(ttemp, vsum / (double)Globals.freqQSubperiods);
                    }
                    else if (G.equal(method, "first"))
                    {
                        if (t.sub == 1) ts1.SetData(ttemp, value);
                    }
                    else if (G.equal(method, "last"))
                    {
                        if (t.sub == Globals.freqQSubperiods) ts1.SetData(ttemp, value);
                    }
                    else
                    {
                        G.Writeln2("*** ERROR: wrong method in COLLAPSE: " + method + "'");
                        throw new GekkoException();
                    }
                }
                else if (eFreq1 == EFreq.Annual && eFreq0 == EFreq.Monthly)
                {
                    //Conversion from M to A
                    if (t.sub == 1) vsum = 0d;
                    GekkoTime ttemp = new GekkoTime(eFreq1, t.super, 1);
                    if (G.equal(method, "total"))
                    {
                        vsum += value;
                        if (t.sub == Globals.freqMSubperiods) ts1.SetData(ttemp, vsum);
                    }
                    else if (G.equal(method, "avg"))
                    {
                        vsum += value;
                        if (t.sub == Globals.freqMSubperiods) ts1.SetData(ttemp, vsum / (double)Globals.freqMSubperiods);
                    }
                    else if (G.equal(method, "first"))
                    {
                        if (t.sub == 1) ts1.SetData(ttemp, value);
                    }
                    else if (G.equal(method, "last"))
                    {
                        if (t.sub == Globals.freqMSubperiods) ts1.SetData(ttemp, value);
                    }
                    else
                    {
                        G.Writeln2("*** ERROR: wrong method in COLLAPSE: " + method + "'");
                        throw new GekkoException();
                    }
                }
                else if (eFreq1 == EFreq.Quarterly && eFreq0 == EFreq.Monthly)
                {
                    //Conversion from M to Q
                    int mPerQ = Globals.freqMSubperiods / Globals.freqQSubperiods;  //3
                    int quarter = (t.sub - 1) / mPerQ + 1;
                    if (t.sub % mPerQ == 1) vsum = 0d;
                    GekkoTime ttemp = new GekkoTime(eFreq1, t.super, quarter);
                    if (G.equal(method, "total"))
                    {
                        vsum += value;
                        if (t.sub % mPerQ == 0) ts1.SetData(ttemp, vsum);
                    }
                    else if (G.equal(method, "avg"))
                    {
                        vsum += value;
                        if (t.sub % mPerQ == 0) ts1.SetData(ttemp, vsum / (double)mPerQ);
                    }
                    else if (G.equal(method, "first"))
                    {
                        if (t.sub % mPerQ == 1) ts1.SetData(ttemp, value);
                    }
                    else if (G.equal(method, "last"))
                    {
                        if (t.sub % mPerQ == 0) ts1.SetData(ttemp, value);
                    }
                }
                else
                {
                    G.Writeln2("*** ERROR: Cannot COLLAPSE frequency '" + eFreq0 + "' to frequency '" + eFreq1 + "'");
                    throw new GekkoException();
                }
            }
            G.Writeln("Collapsed '" + name1 + "' (" + eFreq1.ToString() + ") from '" + name0 + "' (" + eFreq0.ToString() + ")");
            return;
        }

        public static void Interpolate(string b1, string ss1, string b0, string ss0, string method)
        {
            //ErrorIfDatabanksSwapped();            

            Databank databank1 = GetDatabank(b1);
            Databank databank0 = GetDatabank(b0);

            if (method == null) method = "repeat";
                        
            string name1;
            EFreq eFreq1;
            GetFreq(ss1, out name1, out eFreq1);

            string name0;
            EFreq eFreq0;
            GetFreq(ss0, out name0, out eFreq0);
                        
            if (eFreq0 == EFreq.Undated || eFreq1 == EFreq.Undated)
            {
                G.Writeln2("*** ERROR: INTERPOLATE cannot involve undated timeseries");
                throw new GekkoException();
            }

            TimeSeries ts0 = databank0.GetVariable(eFreq0, name0);
            if (ts0 == null)
            {
                G.Writeln2("*** ERROR: Could not find variable '" + name0 + "' with frequency '" + eFreq0 + "' in '" + databank0.aliasName + "' databank");
                throw new GekkoException();
            }

            TimeSeries ts1 = databank1.GetVariable(eFreq1, name1);
            if (ts1 == null)
            {
                G.Writeln("+++ NOTE: Created new variable '" + name1 + "' with frequency '" + G.GetFreq(eFreq1) + "'");
            }
            else
            {
                //We wipe it completely out if it already exists!
                databank1.RemoveVariable(eFreq1, name1);
            }
            ts1 = new TimeSeries(eFreq1, name1);
            databank1.AddVariable(G.GetFreq(eFreq1), ts1);  //hmmm a mess with all this freq stuff!

            GekkoTime first = ts0.GetPeriodFirst(); //start of low-freq timeseries
            GekkoTime last = ts0.GetPeriodLast(); //end of low-freq timeseries

            double vsum = double.NaN;
            foreach (GekkoTime t in new GekkoTimeIterator(first, last))
            {
                double value = ts0.GetData(t);
                if (value == double.NaN) continue;
                if (eFreq1 == EFreq.Quarterly && eFreq0 == EFreq.Annual)
                {
                    //Conversion from A to Q                                        
                    if (G.equal(method, "repeat"))
                    {
                        for (int i = 1; i < Globals.freqQSubperiods + 1; i++)
                        {
                            GekkoTime gt = new GekkoTime(EFreq.Quarterly, t.super, i);
                            ts1.SetData(gt, value);
                        }
                    }
                    else if (G.equal(method, "prorate"))
                    {
                        for (int i = 1; i < Globals.freqQSubperiods + 1; i++)
                        {
                            GekkoTime gt = new GekkoTime(EFreq.Quarterly, t.super, i);
                            ts1.SetData(gt, value / (double)Globals.freqQSubperiods);
                        }
                    }                    
                    else
                    {
                        G.Writeln2("*** ERROR: wrong method in INTERPOLATE: " + method + "'");
                        throw new GekkoException();
                    }
                }
                else if (eFreq1 == EFreq.Monthly && eFreq0 == EFreq.Annual)
                {
                    //Conversion from A to M
                    if (G.equal(method, "repeat"))
                    {
                        for (int i = 1; i < Globals.freqMSubperiods + 1; i++)
                        {
                            GekkoTime gt = new GekkoTime(EFreq.Monthly, t.super, i);
                            ts1.SetData(gt, value);
                        }
                    }
                    else if (G.equal(method, "prorate"))
                    {
                        for (int i = 1; i < Globals.freqMSubperiods + 1; i++)
                        {
                            GekkoTime gt = new GekkoTime(EFreq.Monthly, t.super, i);
                            ts1.SetData(gt, value / (double)Globals.freqMSubperiods);
                        }
                    }
                    else
                    {
                        G.Writeln2("*** ERROR: wrong method in INTERPOLATE: " + method + "'");
                        throw new GekkoException();
                    }
                }
                else if (eFreq1 == EFreq.Monthly && eFreq0 == EFreq.Quarterly)
                {
                    //Conversion from Q to M
                    int mInQ = Globals.freqMSubperiods / Globals.freqQSubperiods; //3
                    int startSub = (t.sub - 1) * mInQ + 1;  //1->1, 2->4, 3->7, 4->10
                    if (G.equal(method, "repeat"))
                    {
                        for (int i = startSub; i < startSub + mInQ; i++)
                        {
                            GekkoTime gt = new GekkoTime(EFreq.Monthly, t.super, i);
                            ts1.SetData(gt, value);
                        }
                    }
                    else if (G.equal(method, "prorate"))
                    {
                        for (int i = startSub; i < startSub + mInQ; i++)
                        {
                            GekkoTime gt = new GekkoTime(EFreq.Monthly, t.super, i);
                            ts1.SetData(gt, value / (double)mInQ);
                        }
                    }
                    else
                    {
                        G.Writeln2("*** ERROR: wrong method in INTERPOLATE: " + method + "'");
                        throw new GekkoException();
                    }

                }
                else
                {
                    G.Writeln2("*** ERROR: Cannot INTERPOLATE frequency '" + eFreq0 + "' to frequency '" + eFreq1 + "'");
                    throw new GekkoException();
                }
            }
            G.Writeln("Interpolated '" + name1 + "' (" + eFreq1.ToString() + ") from '" + name0 + "' (" + eFreq0.ToString() + ")");
            return;
        }

        private static void GetFreq(string ss1, out string name1, out EFreq eFreq1)
        {
            List<string> s1 = new List<string>(ss1.Split('.'));            
            name1 = s1[0];
            string extension1 = "";
            if (s1.Count == 2) extension1 = s1[1];
            if (extension1 == "")
            {
                extension1 = G.GetFreq(Program.options.freq);
            }
            eFreq1 = G.GetFreq(extension1);
        }

        private static Databank GetDatabank(string b1)
        {
            Databank databank1 = Program.databanks.GetFirst();
            if (b1 == "@") databank1 = Program.databanks.GetRef();
            else if (b1 != "") databank1 = Program.databanks.GetDatabank(b1);
            if (databank1 == null)
            {
                G.Writeln2("*** ERROR: Databank '" + b1 + "' not found");
                throw new GekkoException();
            }

            return databank1;
        }

        public static void Delete(List<string> vars)
        {
            int counter = 0;
            G.Writeln();

            for (int i = 0; i < vars.Count; i++)
            {
                //may contain nulls if ts not found in bank
                List<TimeSeries> tss = Program.GetTimeSeriesFromStringWildcard(vars[i], null, true);
                foreach (TimeSeries ts in tss)
                {
                    if (ts == null)
                    {
                        G.Writeln("+++ WARNING: DELETE: variable '" + vars[i] + "' does not exist");
                    }
                    else
                    {
                        if (ts.parentDatabank.protect) Program.ProtectError("You cannot delete a timeseries in a non-editable databank (" + ts.parentDatabank + ")");
                        ts.parentDatabank.RemoveVariable(ts.variableName);
                        counter++;
                    }
                }
            }
            
            if (counter == 0) G.Writeln("Did not delete any variables");
            else if (counter == 1) G.Writeln("Deleted 1 variable");
            else G.Writeln("Deleted " + counter + " variables");
        }

        public static double[,] InvertMatrix(double[,] matrix)
        {
            int success = 0;
            alglib.matinvreport report = new alglib.matinvreport();
            alglib.rmatrixinverse(ref matrix, out success, out report);
            if (success == 3)
            {
                G.Writeln2("*** ERROR: Inv(): It seems the matrix is singular");
                throw new GekkoException();
            }
            else if (success != 1)
            {
                G.Writeln2("*** ERROR: Inv(): Could not invert matrix");
                throw new GekkoException();
            }
            return matrix;
        }
               
        public static double[,] XTransposeX(double[,] x)
        {
            //  1 2
            //  3 4     5 6 7 8       -->   3x2 * 2x4 = 3x4
            //  5 6     8 9 8 5
            //
            int xRows = x.GetLength(1);
            int xCols = x.GetLength(0);
            //int yRows = x.GetLength(0);
            //int yCols = x.GetLength(1);
                        
            double[,] z = new double[xRows, xRows];
            for (int i = 0; i < xRows; i++)
            {
                for (int j = 0; j < xRows; j++)
                {
                    double sum = 0d;
                    for (int k = 0; k < xCols; k++)
                    {
                        sum += x[k, i] * x[k, j];
                    }
                    z[i, j] = sum;
                }
            }
            return z;
            
        }

        public static void Ols(O.Ols o)
        {

            //AREMOS:
            //close*;clear;
            //import<tsd mute>maj11_pcim;
            //set per 50 2079
            //set per 80 2010;
            //equ lna1 = pcp, pcp.1, ul, ul.1;

            // LNA1
            // Ordinary Least Squares
            // ANNUAL data for   31 periods from 1980 to 2010
            // Date: 14 NOV 2013

            // lna1

            //   =    418.171 * pcp - 154.400 * pcp[-1] + 0.00154 * ul
            //       (2.96194)       (1.15821)           (0.03103)

            //      - 0.12668 * ul[-1] - 59.8149
            //       (2.58716)          (3.64875)

            // Sum Sq    1148.51   Std Err    6.6463   LHS Mean  154.294
            // R Sq       0.9876   R Bar Sq   0.9856   F  4, 26  515.654
            // D.W.( 1)   0.4673   D.W.( 2)   0.9352

            //Denne stemmer med Gekko.

            //What about restrictions (IMPOSE)?
            //Could do it using PRT syntax: OLS fy = fx, pcp/lna;
            //What about: http://christoph.ruegg.name/blog/linear-regression-mathnet-numerics.html ?
            //Also see: http://christoph.ruegg.name/blog/towards-mathnet-numerics-v3.html


            bool useScale = false; //usually true

            GekkoTime t1 = o.t1;
            GekkoTime t2 = o.t2;
            string name = o.name;
            if (name == null) name = "ols";

            List<string> labels = new List<string>();
            double[,] tsData2 = null;
            int m2 = 0;
            int n = GekkoTime.Observations(t1, t2);
            List<O.Prt.Element> elements = o.prtElements;
            int constant = 1;
            if (G.equal(o.opt_constant, "no")) constant = 0;
            UnfoldVarsAndLabels(ref m2, ref tsData2, t1, t2, labels, n, elements, constant);

            int m = m2 - 1;  //explanatory vars including constant

            if (n <= m)
            {
                G.Writeln2("*** ERROR: There are " + m + " variables with only " + n + " observations");
                throw new GekkoException();
            }

            Matrix name_coeff = new Matrix(m, 1, double.NaN);
            Matrix name_t = new Matrix(m, 1, double.NaN);
            Matrix name_se = new Matrix(m, 1, double.NaN);
            Matrix name_stats = new Matrix(9, 1, double.NaN);
            Matrix name_covar = new Matrix(m, m, double.NaN);
            Matrix name_corr = new Matrix(m, m, double.NaN);
            TimeSeries name_predict = new TimeSeries(t1.freq, name + "_predict");
            TimeSeries name_residual = new TimeSeries(t1.freq, name + "_residual");

            double[] y = new double[n];
            double[,] x = new double[n, m];
            for (int i = 0; i < n; i++)
            {
                y[i] = tsData2[i, 0];
                for (int j = 0; j < m; j++)
                {
                    x[i, j] = tsData2[i, j + 1];
                }
            }

            double[] beta = null;
            int info = 0;

            double[] scaling = new double[x.GetLength(1)];
            for (int kk = 0; kk < x.GetLength(1); kk++)
            {
                double sum = 0d;
                for (int tt = 0; tt < x.GetLength(0); tt++)
                {
                    sum += Math.Abs(x[tt, kk]);  //with abs we avoid stupid averages = 0 like -2, -1, 0, 1, 2 etc.
                }
                scaling[kk] = sum / x.GetLength(0);
                if (scaling[kk] == 0d) scaling[kk] = 1d;

                //scaling[kk] = 1d;
                //if (kk == 0) scaling[kk] = 1d / 1000d;
                //if (kk == 1) scaling[kk] = 1d / .01d;

                for (int tt = 0; tt < x.GetLength(0); tt++)
                {
                    x[tt, kk] = x[tt, kk] / scaling[kk];
                }
            }

            alglib.lsfit.lsfitreport rep = new alglib.lsfit.lsfitreport();

            int info2 = -12345;
            double[,] restrict = new double[0, m + 1];  //array[k, m+1]  c[i,0]*beta[0] + ... + c[i,m-1]*beta[m-1] = c[i,m]            

            int k = 0;
            double[,] r = null;

            if (o.impose != null)
            {
                Matrix rr = O.GetMatrix(o.impose);
                k = rr.data.GetLength(0);
                restrict = new double[rr.data.GetLength(0), rr.data.GetLength(1)];  //needs to be cloned, otherwise the IMPOSE matrix will be changed with scaling
                for (int i = 0; i < rr.data.GetLength(0); i++)
                {
                    for (int j = 0; j < rr.data.GetLength(1) - 1; j++)
                    {
                        restrict[i, j] = rr.data[i, j] / scaling[j];
                    }
                    restrict[i, rr.data.GetLength(1) - 1] = rr.data[i, rr.data.GetLength(1) - 1];
                }                
            }

            r = new double[restrict.GetLength(0), restrict.GetLength(1) - 1];
            for (int i = 0; i < restrict.GetLength(0); i++)
            {
                for (int j = 0; j < restrict.GetLength(1) - 1; j++)
                {
                    r[i, j] = restrict[i, j];
                }
            }

            //http://www.alglib.net/translator/man/manual.csharp.html#sub_lsfitlinearc
            //if it detects k = 0, it just calls same procedure as alglib.lsfit.lsfitlinear()
            try
            {
                alglib.lsfit.lsfitlinearc(y, x, restrict, n, m, k, ref info2, ref beta, rep);
            }
            catch (Exception e)
            {
                if (e.Message != null && e.Message != "")
                    G.Writeln2("*** ERROR: " + e.Message);
                if (e.InnerException != null && e.InnerException.Message != null && e.InnerException.Message != "")
                    G.Writeln2("*** ERROR: " + e.InnerException.Message);
                throw;
            }

            //for (int kk = 0; kk < x.GetLength(1); kk++)
            //{
            //    for (int tt = 0; tt < x.GetLength(0); tt++)
            //    {
            //        x[tt, kk] = x[tt, kk] * scaling[kk];
            //    }
            //}

            double[] ypredict = new double[n];
            double[] residual = new double[n];

            double dw1 = 0d;
            double rss = 0d;
            
            double resMean = 0d;
            
            double lhsMean = 0d;

            double ySum = 0d;
            for (int i = 0; i < n; i++)
            {                
                ySum += y[i];                
            }
            double yAvg = ySum / (double)n;

            double ssTot = 0d;

            for (int i = 0; i < n; i++)
            {
                ypredict[i] = 0d;
                for (int ik = 0; ik < m; ik++)
                {
                    ypredict[i] += beta[ik] * x[i, ik];
                }
                residual[i] = y[i] - ypredict[i];
                resMean += residual[i];
                
                lhsMean += y[i];
                rss += residual[i] * residual[i];
                ssTot += (y[i] - yAvg) * (y[i] - yAvg);
                if (i > 0) dw1 += (residual[i] - residual[i - 1]) * (residual[i] - residual[i - 1]);

                name_predict.SetData(t1.Add(i), ypredict[i]);
                name_residual.SetData(t1.Add(i), residual[i]);
            }
            resMean = resMean / (double)n;
            lhsMean = lhsMean / (double)n;
            
            double dw = dw1 / rss;
            double rmse = Math.Sqrt(rss / (double)(n));
            double see = Math.Sqrt(rss / (double)(n - m + k));

            double[,] usedCovar = null;

            double[,] ixtx = InvertMatrix(XTransposeX(x));
            if (r.GetLength(0) == 0)
            {
                //covar = sigma^2 * inv(X'X)
                usedCovar = O.MultiplyMatrixScalar(ixtx, see * see, ixtx.GetLength(0), ixtx.GetLength(1));
            }
            else
            {
                //covar = sigma^2 *( inv(X'X)  -   inv(X'X) * R' inv( R  inv(X'X) R' ) R  inv(X'X) )
                double[,] mat1 = ixtx;
                double[,] inside = InvertMatrix(MultiplyMatrices(MultiplyMatrices(r, ixtx), Transpose(r)));
                double[,] zz = MultiplyMatrices(MultiplyMatrices(MultiplyMatrices(MultiplyMatrices(ixtx, Transpose(r)), inside), r), ixtx);
                double[,] zzz = O.SubtractMatrixMatrix(ixtx, zz, ixtx.GetLength(0), ixtx.GetLength(1));
                usedCovar = O.MultiplyMatrixScalar(zzz, see * see, zzz.GetLength(0), zzz.GetLength(1));
            }

            //usedCovar = rep.covpar; --> this yields the same (without restrictions), also in the case without constant

            
            for (int i = 0; i < usedCovar.GetLength(0); i++)
            {
                for (int j = 0; j < usedCovar.GetLength(1); j++)
                {
                    usedCovar[i, j] = usedCovar[i, j] / scaling[i] / scaling[j];                    
                }
            }

            double[,] usedCorr = new double[usedCovar.GetLength(0), usedCovar.GetLength(1)];
            for (int i = 0; i < usedCovar.GetLength(0); i++)
            {
                for (int j = 0; j < usedCovar.GetLength(1); j++)
                {
                    usedCorr[i, j] = usedCovar[i, j] / Math.Sqrt(usedCovar[i, i]) / Math.Sqrt(usedCovar[j, j]);
                }
            }
            
            Table tab = new Table();

            tab.Set(1, 1, "Variable");
            tab.Set(1, 2, "Estimate");
            tab.Set(1, 3, "Std error");
            tab.Set(1, 4, "T-stat");
            tab.SetAlign(1, 1, 1, 1, Align.Left);
            tab.SetAlign(1, 2, 1, 4, Align.Right);
            for (int i = 0; i < m; i++)
            {
                double coeff = 1d / scaling[i] * beta[i];

                string s = TruncateTextWithDots(25, labels[i + 1]);
                tab.Set(i + 2, 1, s);                
                tab.SetAlign(i + 2, 1, Align.Left);
                
                int digits = -(int)RoundDecimals1(coeff) + 6;  //can be negative
                if (digits < 0) digits = 0;
                
                double se = double.NaN;
                double t = double.NaN;
                
                se = Math.Sqrt(usedCovar[i, i]);
                t = Math.Abs(coeff / Math.Sqrt(usedCovar[i, i]));
                
                tab.SetNumber(i + 2, 2, coeff, "f16." + digits);
                tab.SetNumber(i + 2, 3, se, "f16." + digits);
                tab.SetNumber(i + 2, 4, t, "f12.2");

                name_coeff.data[i, 0] = coeff;
                name_se.data[i, 0] = se;
                name_t.data[i, 0] = t;
            }

            tab.SetBorder(1, 1, 1, 4, BorderType.Top);
            tab.SetBorder(1, 1, 1, 4, BorderType.Bottom);
            tab.SetBorder(m + 1, 1, m + 1, 4, BorderType.Bottom);
            List<string> temp = tab.Print();
            Globals.lastPrtOrMulprtTable = tab;
            CrossThreadStuff.CopyButtonEnabled(true);

            double r2 = 1 - rss / ssTot;
            double r2cor = 1 - (1 - r2) * (n - 1) / (n - (m - 1) - 1 + k);  //google r2 adjusted formula. Our m includes the constant, usually regressors do not count the constant -> therefore (m-1). TT added k, must be so.
        
            int widthRemember = Program.options.print_width;
            int fileWidthRemember = Program.options.print_filewidth;
            Program.options.print_width = int.MaxValue;
            Program.options.print_filewidth = int.MaxValue;
            G.Writeln2("OLS estimation " + t1 + "-" + t2 + " (n = " + n + ")");
            G.Writeln(labels[0]);  //labels contain the LHS and all the RHS!            
            foreach (string s in temp) G.Writeln(s);
            G.Writeln("R2: " + Math.Round(r2, 6) + "    " + "SEE: " + RoundToSignificantDigits(see, 6) + "    " + "DW: " + Math.Round(dw, 4));
            
            if (Math.Abs(resMean) > 0.000001d*see)
            {
                G.Writeln2("+++ NOTE: The residuals do not seem to sum to zero. Did you omit a constant term?");
                G.Writeln("          Note that R2 and other statistics may be misleading in this case.");
            }
                        
            name_stats.data[1 - 1, 0] = rss;
            name_stats.data[2 - 1, 0] = see;
            name_stats.data[3 - 1, 0] = resMean;
            name_stats.data[4 - 1, 0] = rmse; // rep.rmserror;
            name_stats.data[5 - 1, 0] = r2;
            name_stats.data[6 - 1, 0] = r2cor;
            name_stats.data[8 - 1, 0] = lhsMean;
            name_stats.data[9 - 1, 0] = dw;
            name_covar.data = usedCovar;
            name_corr.data = usedCorr;

            if (true)
            {
                if (Program.databanks.GetFirst().ContainsVariable(name + "_predict")) Program.databanks.GetFirst().RemoveVariable(name + "_predict");
                Program.databanks.GetFirst().AddVariable(name_predict);
                if (Program.databanks.GetFirst().ContainsVariable(name + "_residual")) Program.databanks.GetFirst().RemoveVariable(name + "_residual");
                Program.databanks.GetFirst().AddVariable(name_residual);
                if (Program.scalars.ContainsKey(Globals.symbolList + name + "_stats")) Program.scalars.Remove(Globals.symbolList + name + "_stats");
                Program.scalars.Add(Globals.symbolList + name + "_stats", name_stats);
                if (Program.scalars.ContainsKey(Globals.symbolList + name + "_param")) Program.scalars.Remove(Globals.symbolList + name + "_param");
                Program.scalars.Add(Globals.symbolList + name + "_param", name_coeff);
                if (Program.scalars.ContainsKey(Globals.symbolList + name + "_t")) Program.scalars.Remove(Globals.symbolList + name + "_t");
                Program.scalars.Add(Globals.symbolList + name + "_t", name_t);
                if (Program.scalars.ContainsKey(Globals.symbolList + name + "_se")) Program.scalars.Remove(Globals.symbolList + name + "_se");
                Program.scalars.Add(Globals.symbolList + name + "_se", name_se);
                if (Program.scalars.ContainsKey(Globals.symbolList + name + "_covar")) Program.scalars.Remove(Globals.symbolList + name + "_covar");
                Program.scalars.Add(Globals.symbolList + name + "_covar", name_covar);
                if (Program.scalars.ContainsKey(Globals.symbolList + name + "_corr")) Program.scalars.Remove(Globals.symbolList + name + "_corr");
                Program.scalars.Add(Globals.symbolList + name + "_corr", name_corr);
            }


            Program.options.print_width = widthRemember;
            Program.options.print_filewidth = fileWidthRemember;
        }

        public static double StandardDeviation(List<double> valueList)
        {
            double M = 0.0;
            double S = 0.0;
            int k = 1;
            foreach (double value in valueList)
            {
                double tmpM = M;
                M += (value - tmpM) / k;
                S += (value - tmpM) * (value - M);
                k++;
            }
            return Math.Sqrt(S / (k - 2));
        }

        public static double Mean(List<double> valueList)
        {
            double m = 0d;
            foreach (double value in valueList)
            {
                m += value;
            }
            return m/valueList.Count;
        }

        public static void Max(out int maxI, out double max, List<double> list)
        {
            maxI = int.MinValue;
            max = double.MinValue;
            for(int i = 0;i< list.Count ;i++)
            {
                double d = list[i];
                if (d > max)
                {
                    max = d;
                    maxI = i;
                }
            }
        }

        public static void Min(out int minI, out double min, List<double> list)
        {
            minI = int.MaxValue;
            min = double.MaxValue;
            for (int i = 0; i < list.Count; i++)
            {
                double d = list[i];
                if (d < min)
                {
                    min = d;
                    minI = i;
                }
            }
        }

        public static void Analyze(O.Analyze o)
        {

            //set per 2001 2010;
            //ser x1 = 1,2,4,5,6,5,6,7,8,6;
            //ser x2 = 5,4,4,5,6,3,6,1,8,6;
            //ser x3 = 7,5,4,1,6,5,9,7,8,9;
            //analyze <matrix>x1,x2,x3 xx;
            //disp<decimals 8> xx;

            //time 2001 2010;
            //create x1, x2, x3;
            //ser x1 = 1,2,4,5,6,5,6,7,8,6;
            //ser x2 = 5,4,4,5,6,3,6,1,8,6;
            //ser x3 = 7,5,4,1,6,5,9,7,8,9;
            //analyze x1,x2,x3;

            //  1 x1
            //    ANNUAL Data for   10 periods from 2001  to 2010
            //     Mean            5.00            Standard deviation         2.16
            //     Maximum         8.00 in  2009
            //     Minimum         1.00 in  2001
            //  2 x2
            //    ANNUAL Data for   10 periods from 2001  to 2010
            //     Mean            4.80            Standard deviation         1.93
            //     Maximum         8.00 in  2009
            //     Minimum         1.00 in  2008
            //  3 x3
            //    ANNUAL Data for   10 periods from 2001  to 2010
            //     Mean            6.10            Standard deviation         2.47
            //     Maximum         9.00 in  2010
            //     Minimum         1.00 in  2004

            //     Cross correlation based on    10 observations
            //      1      2      3
            //  1   1.00
            //  2   0.21   1.00
            //  3   0.31   0.31   1.00

            // => disp<decimals 8> xx

            //MATRIX   XX

            //              1          2          3
            //   1 1.00000000 0.21295885 0.31237800
            //   2 0.21295885 1.00000000 0.30733932
            //   3 0.31237800 0.30733932 1.00000000

            GekkoTime t1 = o.t1;
            GekkoTime t2 = o.t2;

            List<string> labels = new List<string>();
            double[,] tsData = null;
            int k = 0;
            int n = GekkoTime.Observations(t1, t2);
            List<O.Prt.Element> elements = o.prtElements;
            UnfoldVarsAndLabels(ref k, ref tsData, t1, t2, labels, n, elements, 0);

            G.Writeln();
            int counter = -1;
            foreach (string s in labels)
            {
                counter++;
                List<double> x = new List<double>(n);
                for (int i = 0; i < n; i++)
                {
                    x.Add(tsData[i, counter]);
                }
                double std = StandardDeviation(x);
                double mean = Mean(x);
                int minI; double min;
                Min(out minI, out min, x);
                int maxI; double max;
                Max(out maxI, out max, x);
                int width = 16;
                G.Writeln("SERIES " + s);
                G.Writeln("  " + n + " observations from " + t1.ToString() + " to " + t2.ToString());
                G.Writeln("  Mean    = " + G.levelFormat(mean, width));
                G.Writeln("  St.dev. = " + G.levelFormat(std, width));
                G.Writeln("  Min     = " + G.levelFormat(min, width) + " in " + t1.Add(minI).ToString());
                G.Writeln("  Max     = " + G.levelFormat(max, width) + " in " + t1.Add(maxI).ToString());
            }

            if (k > 1)
            {

                double[,] y = null;
                alglib.pearsoncorrm(tsData, out y);
                Matrix m = new Matrix();
                m.data = y;
                if (Program.scalars.ContainsKey(Globals.symbolList + "corr")) Program.scalars.Remove(Globals.symbolList + "corr");
                Program.scalars.Add(Globals.symbolList + "corr", m);

                G.Writeln2("Cross correlation based on " + k + " variables and " + n + " observations");
                counter = 0;
                foreach (string s in labels)
                {
                    counter++;
                    G.Writeln("Variable " + counter + ": " + s);
                }
                Program.ShowMatrix(m, Globals.symbolList + "corr");
            }
        }

        private static void UnfoldVarsAndLabels(ref int k, ref double[,] tsData, GekkoTime t1, GekkoTime t2, List<string> labels, int n, List<O.Prt.Element> elements, int constant)
        {           
            foreach (O.Prt.Element e in elements)
            {
                foreach (O.Prt.SubElement se in e.subElements)
                {
                    k += 1;
                    if (se.label != null) labels.Add(G.ReplaceGlueNew(se.label));
                    else labels.Add(G.ReplaceGlueNew(e.label));
                }
            }
            if(constant == 1)
            {
                labels.Add("CONSTANT");
            }
            if (k == 0)
            {
                G.Writeln2("*** ERROR: Number of explanatory variables = 0");  //probably not possible unless empty list
                throw new GekkoException();
            }
            k += constant;

            tsData = new double[n, k];
            Databank work = Program.databanks.GetFirst();
            int countT = -1;
            foreach (GekkoTime t in new GekkoTimeIterator(t1, t2))
            {
                countT++;
                int countK = -1;
                foreach (O.Prt.Element e in elements)
                {
                    foreach (O.Prt.SubElement se in e.subElements)
                    {
                        countK++;
                        double v = se.tsWork.GetData(t);
                        if (G.isNumericalError(v))
                        {
                            G.Writeln2("*** ERROR: Missing value: " + labels[countK] + " in " + t.ToString());
                            G.Writeln("           Workaround: see command FINDMISSINGDATA<replace>");
                            throw new GekkoException();
                        }
                        tsData[countT, countK] = v;
                    }
                }
                if (constant == 1)
                {
                    countK++;
                    tsData[countT, countK] = 1d;
                }
            }
        }

        public static DialogResult InputBox(string title, string promptText, ref string value)
        {
            Form form = new Form();
            System.Windows.Forms.Label label = new System.Windows.Forms.Label();
            TextBox textBox = new TextBox();
            Button buttonOk = new Button();
            Button buttonCancel = new Button();

            form.Text = title;
            label.Text = promptText;
            textBox.Text = value;

            buttonOk.Text = "OK";
            buttonCancel.Text = "Cancel";
            buttonOk.DialogResult = DialogResult.OK;
            buttonCancel.DialogResult = DialogResult.Cancel;

            label.SetBounds(9, 20 - 5, 372, 13);
            textBox.SetBounds(12, 36, 372, 20);
            buttonOk.SetBounds(228, 72, 75, 23);
            buttonCancel.SetBounds(309, 72, 75, 23);

            label.AutoSize = true;
            textBox.Anchor = textBox.Anchor | AnchorStyles.Right;
            buttonOk.Anchor = AnchorStyles.Bottom | AnchorStyles.Right;
            buttonCancel.Anchor = AnchorStyles.Bottom | AnchorStyles.Right;

            form.ClientSize = new Size(396, 107);
            form.Controls.AddRange(new Control[] { label, textBox, buttonOk, buttonCancel });
            form.ClientSize = new Size(Math.Max(300, label.Right + 10), form.ClientSize.Height);
            form.FormBorderStyle = FormBorderStyle.FixedDialog;
            form.StartPosition = FormStartPosition.CenterScreen;
            form.MinimizeBox = false;
            form.MaximizeBox = false;
            form.AcceptButton = buttonOk;
            form.CancelButton = buttonCancel;

            DialogResult dialogResult = form.ShowDialog();
            value = textBox.Text;
            return dialogResult;
        }

        public static double RoundToSignificantDigits(this double d, int digits)
        {
            if (d == 0)
                return 0;            
            return RoundDecimals2(d, digits);
        }

        private static double RoundDecimals2(double d, int digits)
        {
            double scale = Math.Pow(10, RoundDecimals1(d));
            double scale2 = scale * Math.Round(d / scale, digits);
            return scale2;
        }

        private static double RoundDecimals1(double d)
        {
            return Math.Floor(Math.Log10(Math.Abs(d))) + 1;
        }

        public static void PrtNew(O.Prt o)
        {

            //precedentsInput may contain #var, @var, var¤-1, @var¤-1, and also also fy#i or fy{i} (or var¤¤2010m7)

            LocalBanks localBanks = new LocalBanks();
            o.opt_filename = StripQuotes(o.opt_filename);  //necessary???

            if (o.prtElements.Count == 0)
            {
                //should not be possible
                G.Writeln2("*** ERROR: No variables given");
                throw new GekkoException();
            }

            //==================================================================================

            if (G.equal(o.prtType, "sheet") || G.equal(o.prtType, "plot") || G.equal(o.prtType, "clip"))
            {
                //do nothing, do not start pipe2
            }
            else
            {
                MaybeStartPipe2(o.opt_filename);
            }
            try
            {
                Program.PrtNew2(o);
            }
            catch (Exception e)
            {
                throw;
            }
            finally
            {
                bool message = false;
                if (Globals.pipe2) message = true;
                ReleasePipe2();  //no harm if it is not active
                if (message) G.Writeln2("Data written to file '" + o.opt_filename + "'");
            }
        }


        public static int PrtNew2(O.Prt o)
        {
            //beware case of printcodes!
            //check use of base bank etc.
            //do timeseries with lags if <p> is present etc (two lags for mp etc.)
            //List<string> endoExoIndicators = null;

            //foreach(O.Prt.Element e in o.prtElements)
            //{
            //    e.originalLabel = e.label;
            //    if(e.label.StartsWith(Globals.labelCheatString))
            //    {
            //        e.label = e.label.Substring(Globals.labelCheatString.Length);
            //    }
            //}

            bool hasV = false;
            foreach (OptString ts in o.printCodes)
            {
                if (G.equal(ts.s1, "v") && G.equal(ts.s2, "yes"))
                {
                    hasV = true;  //could be more than one "v", so we keep looping to get the last one.
                }
            }
            if (!IsMulprt(o) && hasV)
            {
                G.Writeln2("*** ERROR: Please use MULPRT<v> instead of PRT<v>");
                throw new GekkoException();
            }

            bool isVerbose = false;
            if (G.equal(o.prtType, "gmulprt")) isVerbose = true;
            if (IsMulprt(o) && hasV) isVerbose = true;
            if (IsMulprt(o) && Program.options.print_mulprt_v) isVerbose = true;

            if (IsMulprt(o))
            {
                foreach (OptString xx in o.printCodes)
                {
                    if (IsPrintCodeShort(xx.s1))
                    {
                        G.Writeln2("*** ERROR: You cannot use 'short' printcodes with MULPRT, for instance MULPRT<p> etc.");
                        throw new GekkoException();
                    }
                }
            }

            if (isVerbose)
            {
                if (IsMulprt(o))
                {
                    isVerbose = true;  //GMULPRT or MULPRT<v> or MULPRT with option print_mulprt_v
                    o.printCodes.Clear();
                    o.printCodes.Add(new OptString("n", "yes"));
                    o.printCodes.Add(new OptString("p", "yes"));
                    o.printCodes.Add(new OptString(Globals.printCode_s, "yes"));
                    o.printCodes.Add(new OptString(Globals.printCode_sp, "yes"));
                    o.printCodes.Add(new OptString("m", "yes"));
                    o.printCodes.Add(new OptString("q", "yes"));
                }
                else
                {
                    G.Writeln2("*** ERROR: Display code <v> (verbose) is only legal for MULPRT");
                    throw new GekkoException();
                }
            }

            //bool hasDataDifferentFromNaN_Infinity = false;
            Databank work = null;
            Databank base2 = null;
            {
                work = databanks.GetFirst();
                base2 = databanks.GetRef();
            }

            List<string> masterSpaceErrors = new List<string>();
            List<string> nonExistenceErrors = new List<string>();

            int max = Program.options.print_width;
            if (Globals.pipe || Globals.pipe2) max = Program.options.print_filewidth;  //is printing to file

            string timefilterType = Program.options.timefilter_type;  //avg or skip
            bool timefilter = Program.options.timefilter;
            if (o.timefilter != null)
            {
                if (G.equal(o.timefilter, "yes"))
                {
                    timefilter = true;
                }
                else if (G.equal(o.timefilter, "no"))
                {
                    timefilter = false;
                }
                else if (G.equal(o.timefilter, "avg"))
                {
                    timefilter = true;
                    timefilterType = o.timefilter;
                }
                else if (G.equal(o.timefilter, "hide"))
                {
                    timefilter = true;
                    timefilterType = o.timefilter;
                }
            }

            int virtualCols = 0;

            Table tab = new Table();            

            Globals.lastPrtOrMulprtTable = tab;  //this remembers the last PRT or MULPRT table, for possible putting on clipboard.
            CrossThreadStuff.CopyButtonEnabled(true);

            tab.writeOnce = true;  //so we don't accidentally override cells without even knowing it.
            int numberOfLabelsLinesMax = -12345;

            bool isRows;
            bool isCols;
            HandleRowsCols(o, out isRows, out isCols);
            bool transpose = isRows; //transpose=false -> timeseries running down in cols, transpose=true -> timeseries running out in rows
            if (G.equal(o.prtType, "sheet"))
            {
                //TODO: the Excel emitter transposes itself, so we never transpose here. #89073253245
                transpose = false;
            }

            int maxLabelsLinesFound = 1;
            if (transpose)
            {
                numberOfLabelsLinesMax = 1;
            }
            else
            {
                numberOfLabelsLinesMax = 5;
            }

            bool identicalCodes = HasIdenticalCodes(o);  //also checks that MULPRT and short codes are not mixed

            int blocks = 0;  //0-based
            int blocksWidthRest = max;
            string onePrintCodeLabel = "";
            int virtualRowsStart = 0;
            int virtualRowsMaxSeen = 0;
            virtualCols = 0;  //1-based

            int elementCounter = -1;
            int subElementCounterTotal = -1;  //total number of variables/expressions (with unfolded lists) in a print.

            List<string> labelsNonBroken = new List<string>();
            List<string> originalLabelsNonBroken = new List<string>();


            foreach (O.Prt.Element pe in o.prtElements)  //varI 0-based
            {
                elementCounter++;
                int subElementCounter = -1;
                foreach (O.Prt.SubElement subPe in pe.subElements)
                {
                    subElementCounter++;
                    subElementCounterTotal++;

                    List<string> printCodes = GetElementPrintCodes(o, pe);

                    List<int> widths = new List<int>();
                    List<int> decs = new List<int>();
                    PrintGetWithAndDecimals(o, elementCounter, printCodes, widths, decs);

                    int widthSum = 0; foreach (int w in widths) widthSum += w + 2;  //2 chars padding
                    if (!(G.equal(o.prtType, "plot") || G.equal(o.prtType, "sheet") || G.equal(o.prtType, "clip")) && !transpose && blocksWidthRest - (widthSum + 6) < 0)  //these 6 chars represent the date column. The wrapping is only approximate, but that is probably ok (that was also the case in the old PRT command)
                    {
                        //new block
                        virtualRowsMaxSeen = PrintPrettify(o, tab, numberOfLabelsLinesMax, transpose, maxLabelsLinesFound, identicalCodes, onePrintCodeLabel, virtualRowsStart, virtualRowsMaxSeen);
                        blocks++;  //0-based
                        virtualCols = 0;  //1-based
                        virtualRowsStart = virtualRowsMaxSeen + 1;
                        virtualRowsMaxSeen = 0;
                        blocksWidthRest = max;
                        blocksWidthRest += -widthSum;
                    }
                    else
                    {
                        blocksWidthRest += -widthSum;
                    }

                    int printCodesCounter = -1;

                    bool isSimplePrtOrMulprt = false;
                    if (printCodes.Count == 2 && G.equal(printCodes[0], "n") && G.equal(printCodes[1], "p")) isSimplePrtOrMulprt = true;
                    if (printCodes.Count == 2 && G.equal(printCodes[0], "m") && G.equal(printCodes[1], "q")) isSimplePrtOrMulprt = true;

                    foreach (string printCode in printCodes)
                    {
                        virtualCols++;
                        printCodesCounter++;  //0-based
                        int width = widths[printCodesCounter];
                        int dec = decs[printCodesCounter];
                        int labelsWidth = -12345;
                        int maxLength = -12345;
                        if (transpose)
                        {
                            labelsWidth = 20;
                        }
                        else
                        {
                            labelsWidth = width;
                        }

                        maxLength = labelsWidth * numberOfLabelsLinesMax;

                        //--------------------------- putting in labels, and handling the width of those (for normal print they may be split into several rows)

                        string printCodeLabelLong = GetPrintCodeLabel(printCode, isVerbose, isSimplePrtOrMulprt, identicalCodes);

                        onePrintCodeLabel = printCodeLabelLong;  //for possible use later on

                        string[] labelsArray = new string[numberOfLabelsLinesMax];
                        for (int i = 0; i < labelsArray.Length; i++) labelsArray[i] = "[[]]";

                        if (printCodesCounter == 0)  //first item
                        {
                            string label = GetLabelInPrt(pe, subElementCounter);
                            label = G.PrettifyTimeseriesHash(label, true, false);
                            string originalLabel = label;
                            if (label.StartsWith(Globals.labelCheatString)) label = label.Substring(Globals.labelCheatString.Length);                            

                            if (identicalCodes || printCode == "n" || printCode == Globals.printCode_sn || printCode == Globals.printCode_s || (IsMulprt(o) && printCode == "m"))
                            {
                                //do nothing
                                //if identical codes, the number of print codes will always be 1 for each item, so printCodesCounter will be = 0 always
                            }
                            else
                            {
                                label += " " + printCodeLabelLong;
                            }
                            int width2 = width;
                            if (G.equal(o.prtType, "sheet") || G.equal(o.prtType, "clip")) width2 = int.MaxValue;
                            int numberOfLabelsLines = PrintCreateLabelsArrayNew(label, width2, numberOfLabelsLinesMax, maxLength, labelsArray);
                            maxLabelsLinesFound = Math.Max(maxLabelsLinesFound, numberOfLabelsLines);
                            labelsNonBroken.Add(originalLabel);
                        }
                        else
                        {
                            //second item and on
                            if (isSimplePrtOrMulprt)
                            {
                                //we override "[%]" or "[m%]" with "%", this is understandable enough
                                string s = null;

                                string label = GetLabelInPrt(pe, subElementCounter);

                                if (G.IsIdent(label.Trim()))
                                {
                                    EEndoOrExo ee = Program.VariableTypeEndoExo(label.Trim());
                                    if (ee == EEndoOrExo.Endo) s = "E";
                                    else if (ee == EEndoOrExo.Exo) s = "X";
                                }

                                if (!transpose && s != null)
                                {
                                    //for transposed (<rows>) we do not show indicators
                                    labelsArray[0] = "(" + s + ")" + "%";  //PCIM-style is E% or X%, but we do (E)% or (X)% to distinguish from real variables (pcp [%] etc.)
                                }
                                else
                                {
                                    labelsArray[0] = "%";
                                }

                            }
                            else
                            {
                                labelsArray[0] = printCodeLabelLong;
                            }
                            maxLabelsLinesFound = Math.Max(maxLabelsLinesFound, 1);  //this line just for symmetry
                            labelsNonBroken.Add("");  //should never happen for GRAPH
                        }

                        for (int i = 0; i < labelsArray.Length; i++)
                        {
                            if (labelsArray[i] == "[[]]") labelsArray[i] = "";
                        }

                        for (int i = 0; i < numberOfLabelsLinesMax; i++)
                        {
                            string s = labelsArray[numberOfLabelsLinesMax - i - 1];
                            int ii = i;
                            int jj = virtualCols;
                            if (transpose)
                            {
                                ii = virtualCols;
                                jj = i;
                            }

                            int ii2 = ii + 1 + virtualRowsStart;
                            tab.Set(ii2, jj + 1, s);  //virtualRowsStart=0 if transpose=true
                            if (!transpose)
                            {
                                tab.SetAlign(ii2, jj + 1, Align.Right);
                            }
                        }

                        List<double> filterMemoryValues = new List<double>();
                        List<string> filterMemoryDates = new List<string>();

                        List<double> collapseFreqsValues = new List<double>();

                        int virtualRows = virtualRowsStart;
                        foreach (GekkoTime gt in new GekkoTimeIterator(o.t1, o.t2))
                        {
                            bool filter = timefilter && ShouldFilterPeriod(gt);

                            TimeSeries ts = subPe.tsWork;
                            TimeSeries tsGrund = subPe.tsBase;

                            double var1;
                            double varPch;
                            ComputeValueForPrintPlotNew(out var1, out varPch, printCode, gt, ts, tsGrund, o.guiGraphIsLogTransform, false);

                            collapseFreqsValues.Add(var1);

                            string date = G.FromDateToString(gt);

                            if (timefilter && G.equal(timefilterType, "avg"))
                            {
                                if (filter)
                                {
                                    //filterCounter++;
                                    filterMemoryValues.Add(var1);
                                    filterMemoryDates.Add(date);
                                }
                                else
                                {
                                    //filterCounter = 0;
                                    if (filterMemoryValues.Count > 0)
                                    {
                                        filterMemoryValues.Add(var1);
                                        filterMemoryDates.Add(date);
                                        var1 = CalculateAveragesForPrint(printCode, filterMemoryValues, EPrtCollapseTypes.None, -12345);  //freq will not be used here
                                        date = filterMemoryDates[0] + "-" + filterMemoryDates[filterMemoryDates.Count - 1];
                                    }
                                    filterMemoryValues.Clear();
                                    filterMemoryDates.Clear();
                                }
                            }

                            if (filter) continue;

                            virtualRows++;

                            //don't do pretty printing of Q and M if there is timefilter or if it is transposed
                            bool doAremosStuff = false; if (Program.options.print_freq == "pretty" && !timefilter && !transpose && (gt.freq == EFreq.Quarterly || gt.freq == EFreq.Monthly)) doAremosStuff = true;
                            if (G.equal(o.prtType, "plot") || G.equal(o.prtType, "clip") || G.equal(o.prtType, "sheet")) doAremosStuff = false;
                            //Note: the method below only puts stuff into table for virtualCols == 1. Else it is only used
                            //      to correct virtualRows when pretty-printing frequencies Q and M.
                            PrintInsertDate(doAremosStuff, virtualCols, date, gt, o.t1, tab, numberOfLabelsLinesMax, transpose, ref virtualRows, o);
                            PrintInsertTimeseriesData(doAremosStuff, gt, virtualCols, tab, numberOfLabelsLinesMax, transpose, width, dec, ref virtualRows, var1, collapseFreqsValues, printCode, o);
                            virtualRowsMaxSeen = Math.Max(virtualRowsMaxSeen, virtualRows + numberOfLabelsLinesMax);
                        } //foreach period
                    } //foreach printcode
                }  //foreach item in variable (if it is a list)
            } //foreach variable

            if (subElementCounterTotal == -1)
            {
                G.Writeln2("Empty list -- nothing to print");
            }

            virtualRowsMaxSeen = PrintPrettify(o, tab, numberOfLabelsLinesMax, transpose, maxLabelsLinesFound, identicalCodes, onePrintCodeLabel, virtualRowsStart, virtualRowsMaxSeen);

            if (masterSpaceErrors.Count > 0)
            {
                //only results in a warning ("MULPRT @fy" will always be 0)
                G.Writeln();
                foreach (string s in masterSpaceErrors) G.Writeln(s);
            }

            if (nonExistenceErrors.Count > 0)
            {
                G.Writeln();
                foreach (string s in nonExistenceErrors) G.Writeln(s);
                throw new GekkoException();
            }
            else
            {
                //----------------- actually printing the stuff start -------------------------------
                //tab.PrintCellsForDebug();

                if (G.equal(o.prtType, "plot"))
                {
                    //tab.PrintCellsForDebug();
                    if (Program.options.plot_new)
                    {
                        CallGnuplotNew2(tab, o, subElementCounterTotal + 1, maxLabelsLinesFound, labelsNonBroken);  //make sure there are no percent shown for levels (use <n> option, not <n p>)                            
                    }
                    else
                    {
                        CallGnuplotNew(tab, o, subElementCounterTotal + 1, maxLabelsLinesFound, labelsNonBroken);  //make sure there are no percent shown for levels (use <n> option, not <n p>)
                    }

                    //Alternatively: store all transformations, maybe also for UDVALG
                    //TODO.......
                    //if (po.isCalledFromGraphWindow == false)  //PPLOT called from command prompt or command file
                    //{
                    //    CloneToLocalBank(graphVars, localBanks, work, base2);
                    //}

                    return 0;
                }

                if (G.IsUnitTesting())
                {
                    Globals.unitTestTablePointer = tab;  //to be able to inspect it in unit tests
                }

                if (G.equal(o.prtType, "sheet"))
                {
                    //tab2 = tab.Transpose();
                    //TODO: we need a counter regarding the first rows/cols of the table, how many??

                    //TODO: fill with NaN!!!
                    //TODO: fill with NaN!!!
                    //TODO: fill with NaN!!!

                    //remember append
                    //always start in A1, no blank line
                    //labels.. what if they break -- should be infinitely long

                    Table tab2 = tab.Transpose();
                    int startRows = 1;
                    int startCols = 1;
                    ExcelOptions eo = new ExcelOptions();
                    eo.excelRowLabels = new string[tab2.GetRowMaxNumber() - startRows, 1];
                    eo.excelColumnLabels = new string[1, tab2.GetColMaxNumber() - startCols];
                    eo.excelData = G.CreateArrayDouble(tab2.GetRowMaxNumber() - startRows, tab2.GetColMaxNumber() - startCols, double.NaN);

                    for (int i = 1; i <= tab2.GetRowMaxNumber(); i++)
                    {
                        for (int j = 1; j <= tab2.GetColMaxNumber(); j++)
                        {
                            Cell cell2 = tab2.Get(i, j);
                            string s2 = "";
                            if (cell2 == null)
                            {
                            }
                            else
                            {
                                if (i == 1 && j == 1)
                                {
                                    //do nothing
                                }
                                else if (j == 1)
                                {
                                    //first row
                                    string s = cell2.CellText.TextData[0];
                                    if (s == null) s = "";
                                    eo.excelRowLabels[i - 1 - startRows, j - 1] = s;
                                }
                                else if (i == 1)
                                {
                                    string s = cell2.CellText.TextData[0];
                                    if (s == null) s = "";
                                    eo.excelColumnLabels[i - 1, j - 1 - startCols] = s;
                                }
                                else
                                {
                                    eo.excelData[i - startRows - 1, j - startCols - 1] = cell2.number;
                                    s2 = cell2.date;
                                }
                            }
                        }
                    }

                    CreateExcelWorkbook2(eo, o, IsMulprt(o));
                    return 0;
                }
                else if (G.equal(o.prtType, "clip"))
                {
                    //maybe better to "record" into tablelight from CreateExcelWorkbook2?
                    PrtClipboard(tab, false);
                    return 0;
                }
                else  //normal PRT
                {
                    List<string> table = tab.Print();
                    int widthRemember = Program.options.print_width;
                    int fileWidthRemember = Program.options.print_filewidth;
                    Program.options.print_width = int.MaxValue;
                    Program.options.print_filewidth = int.MaxValue;
                    G.Writeln();
                    if (o.opt_title != null && o.opt_title != "")
                    {
                        G.Writeln(o.opt_title);
                    }
                    try
                    {

                        foreach (string s in table)
                        {
                            G.Writeln(s);
                        }


                    }
                    finally
                    {
                        //resetting, also if there is an error
                        Program.options.print_width = widthRemember;
                        Program.options.print_filewidth = fileWidthRemember;
                    }
                    //----------------- actually printing the stuff end -------------------------------
                }
            }

            return virtualCols;
        }

        private static bool HasIdenticalCodes(O.Prt o)
        {
            //a bit costly method, and the loop here is looped again later on, but this is not speed critical.
            bool identicalCodes = false;
            GekkoDictionary<string, string> temp = new GekkoDictionary<string, string>(StringComparer.OrdinalIgnoreCase);
            foreach (O.Prt.Element pe in o.prtElements)  //varI 0-based
            {
                List<string> printCodes = GetElementPrintCodes(o, pe);
                foreach (string s in printCodes)
                {
                    if (!temp.ContainsKey(s)) temp.Add(s, "");
                }
            }
            if (temp.Count == 1) identicalCodes = true;
            return identicalCodes;
        }

        private static string GetLabelInPrt(O.Prt.Element pe, int subElementCounter)
        {
            string label = null;
            if (pe.subElements[subElementCounter].label == null)
            {
                label = pe.label;
            }
            else
            {
                label = pe.subElements[subElementCounter].label;
            }
            label = G.ReplaceGlueNew(label);
            label = ScalarString.SubstituteScalarsInString(label, false, true);
            return label;
        }

        private static double CalculateAveragesForPrint(string printCode, List<double> filterMemoryValues, EPrtCollapseTypes collapse, int n)
        {
            double rv = double.NaN;
            if (IsLevelPrintCode(printCode))
            {
                if (n == -12345)
                {
                    double start1 = 0d;
                    for (int i = 0; i < filterMemoryValues.Count; i++) start1 += filterMemoryValues[i];
                    rv = start1 / (double)filterMemoryValues.Count;
                }
                else
                {
                    if (filterMemoryValues.Count - n >= 0)
                    {
                        double start1 = 0d;
                        for (int i = filterMemoryValues.Count - n; i < filterMemoryValues.Count; i++) start1 += filterMemoryValues[i];
                        double den = (double)n;
                        if (collapse == EPrtCollapseTypes.Total) den = 1d;
                        rv = start1 / den;
                    }
                }
            }
            else
            {
                //percent print codes
                if (G.equal(printCode, "p") || G.equal(printCode, Globals.printCode_sp))
                {
                    if (n == -12345)
                    {
                        double start1 = 1d;
                        for (int i = 0; i < filterMemoryValues.Count; i++) start1 *= 1 + filterMemoryValues[i] / 100d;
                        rv = (Math.Pow(start1, 1d / (double)filterMemoryValues.Count) - 1d) * 100d;
                    }
                    else
                    {
                        if (filterMemoryValues.Count - 2 * n >= 0)
                        {
                            int counter = 0;
                            double xa = 0;
                            double xb = 0;
                            double start1 = 1d;
                            for (int i = filterMemoryValues.Count - 2 * n; i < filterMemoryValues.Count; i++)
                            {
                                counter++;
                                start1 *= 1 + filterMemoryValues[i] / 100d;
                                if (counter <= n) xa += start1;
                                else if (counter >= n + 1) xb += start1;
                            }
                            rv = (xb / xa - 1d) * 100d;
                        }
                    }
                }
                else
                {
                    //#89074323455
                    //for instance q printcode, could be in MULPRT
                    rv = double.NaN;
                }

                //double start2 = 1d;
                //for (int i = 0; i < filterMemoryValues.Count; i++)
                //{
                //    start2 *= 1 + filterMemoryValues[i] / 100d;
                //}
                //rv = (Math.Pow(start2, 1d / (double)filterMemoryValues.Count) - 1d) * 100d;
            }
            return rv;
        }

        private static bool IsMulprt(O.Prt o)
        {
            bool isMulprt = false;
            if (G.equal(o.prtType, "mulprt")) isMulprt = true;
            if (G.equal(o.prtType, "gmulprt")) isMulprt = true;
            return isMulprt;
        }

        public static List<string> GetElementPrintCodes(O.Prt o, O.Prt.Element ope)
        {
            bool isGraph = false;
            bool isSheet = false;
            if (G.equal(o.prtType, "plot")) isGraph = true;
            else if (G.equal(o.prtType, "sheet")) isSheet = true;
            else if (G.equal(o.prtType, "clip")) isSheet = true;

            bool isMulprt = IsMulprt(o);
            List<string> printCodes = new List<string>();
            printCodes.AddRange(GetSuperPrintCodes(o)); //start with a fresh copy of super-printcodes

            if (!isMulprt && printCodes.Count == 1 && G.equal(printCodes[0], "lev"))
            {
                G.Writeln2("*** ERROR: PRT<lev> is not legal: use PRT<abs> to print absolute levels");
                throw new GekkoException();
            }

            if (isMulprt && printCodes.Count == 1 && (G.equal(printCodes[0], "dif") || G.equal(printCodes[0], "diff")))
            {
                G.Writeln2("*** ERROR: MULPRT<dif> is not legal: use MULPRT<abs> to print multiplier differences");
                throw new GekkoException();
            }

            if (ope != null && ope.printCodes != null && ope.printCodes.Count > 0)
            {
                //element-specific printcode overrides!
                printCodes = new List<string>();
                foreach (OptString ts in ope.printCodes)
                {
                    //hmmm, what if there is a no after a yes for the same code????
                    if (G.equal(ts.s2, "yes")) printCodes.Add(ts.s1);
                    else if (G.equal(ts.s2, "no"))
                    {
                        //do not add
                    }
                    else
                    {
                        G.Writeln2("*** ERROR: Printcode = '" + ts.s2 + "' should be 'yes' or 'no'");
                        throw new GekkoException();
                    }
                }
            }
            printCodes = PrintGetPrintcodesOLD(isMulprt, printCodes, isGraph, isSheet);
            return printCodes;
        }

        private static List<string> GetSuperPrintCodes(O.Prt o)
        {
            List<string> printCodesGlobal = new List<string>();
            foreach (OptString ts in o.printCodes)
            {
                //hmmm, what if there is a no after a yes for the same code????
                if (G.equal(ts.s2, "yes"))
                {
                    printCodesGlobal.Add(ts.s1);
                }
                else if (G.equal(ts.s2, "no"))
                {
                    printCodesGlobal.Add("no" + ts.s1);  //for instance 'nopch'
                }
                else if (G.equal(ts.s2, "append"))
                {
                    printCodesGlobal.Add("_" + ts.s1);  //for instance '_lev'
                }
                else
                {
                    G.Writeln2("*** ERROR: Printcode = '" + ts.s2 + "' should be 'yes' or 'no' or 'append'");
                    throw new GekkoException();
                }
            }
            return printCodesGlobal;
        }

        private static void SetGmulprtPrintCodes(PrtHelper ph)
        {
            ph.printCodes.Clear();
            ph.printCodes.Add("n");
            ph.printCodes.Add("p");
            ph.printCodes.Add(Globals.printCode_s);
            ph.printCodes.Add(Globals.printCode_sp);
            ph.printCodes.Add("m");
            ph.printCodes.Add("q");
        }

        private static void ChangePrintCodesToLower(PrtHelper ph)
        {
            if (ph.printCodes != null) ph.printCodes = ph.printCodes.ConvertAll(d => d.ToLower());
            foreach (PrtHelperElement phe in ph.elementOptions)
            {
                if (phe == null) continue;
                if (phe.printCodes == null) continue;
                phe.printCodes = phe.printCodes.ConvertAll(d => d.ToLower());
            }
        }

        private static void PrintInsertTimeseriesData(bool doAremosStuff, GekkoTime gt, int virtualCols, Table tab, int numberOfLabelsLinesMax, bool transpose, int width, int dec, ref int virtualRows, double var1, List<double> collapseFreqsValues, string printCode, O.Prt o)
        {
            int ii = virtualRows + numberOfLabelsLinesMax;
            int jj = virtualCols + 1;
            if (transpose)
            {
                ii = virtualCols + 1;
                jj = virtualRows + numberOfLabelsLinesMax;
            }
            tab.Set(new Coord(ii, jj), "", var1, CellType.Number, "f" + width + "." + dec);
            EPrtCollapseTypes collapse = GetCollapseType(o);
            if (doAremosStuff && collapse != EPrtCollapseTypes.None)
            {
                if ((gt.freq == EFreq.Quarterly && gt.sub == 4) || (gt.freq == EFreq.Monthly && gt.sub == 12))
                {
                    int n = 4;
                    if (gt.freq == EFreq.Monthly) n = 12;
                    double x = CalculateAveragesForPrint(printCode, collapseFreqsValues, collapse, n);
                    if (!G.isNumericalError(x))
                    {
                        tab.Set(new Coord(ii + 1, jj), "", x, CellType.Number, "f" + width + "." + dec);
                    }
                    virtualRows++;  //The row containing the collapsed value
                }
            }
        }

        private static EPrtCollapseTypes GetCollapseType(O.Prt o)
        {
            EPrtCollapseTypes collapse = EPrtCollapseTypes.None;
            if (G.equal(Program.options.print_collapse, "avg")) collapse = EPrtCollapseTypes.Avg;
            else if (G.equal(Program.options.print_collapse, "total")) collapse = EPrtCollapseTypes.Total;
            if (G.equal(o.opt_collapse, "avg")) collapse = EPrtCollapseTypes.Avg;  //overrides global options
            else if (G.equal(o.opt_collapse, "total")) collapse = EPrtCollapseTypes.Total;  //overrides global options
            else if (G.equal(o.opt_collapse, "yes"))
            {
                if (G.equal(Program.options.print_collapse, "none")) collapse = EPrtCollapseTypes.Total;  //default for PRT<collapse>, if no global option
            }
            return collapse;
        }

        private static int PrintPrettify(O.Prt o, Table tab, int numberOfLabelsLinesMax, bool transpose, int maxLabelsLinesFound, bool identicalCodes, string onePrintCodeLabel, int virtualRowsStart, int virtualRowsMaxSeen)
        {
            if (identicalCodes)  //put in general marker for whole table just over the period column (or left of it if transposed)
            {
                string s = "";
                if (o.printCodes.Count == 1) s = onePrintCodeLabel;
                if (s != "")
                {
                    int ii = numberOfLabelsLinesMax + virtualRowsStart;
                    int jj = 1;
                    if (transpose)
                    {
                        ii = 1;
                        jj = numberOfLabelsLinesMax;
                    }
                    tab.Set(ii, jj, s);
                    if (!transpose)
                    {
                        tab.SetAlign(ii, jj, Align.Right);
                    }
                }
            }

            int difference = numberOfLabelsLinesMax - maxLabelsLinesFound;

            if (!transpose && difference > 0)
            {
                for (int i = 0; i < difference; i++)
                {
                    tab.DeleteRow(1 + virtualRowsStart);
                }
            }

            return virtualRowsMaxSeen - difference;
        }

        private static void NonExistenceError(List<string> nonExistenceErrors, string variableLabel, string variableName, string ss)
        {
            if (variableLabel != null && !G.equal(variableName, variableLabel)) ss += ":   " + variableLabel;
            if (!nonExistenceErrors.Contains(ss)) nonExistenceErrors.Add(ss);
        }

        private static void PrintInsertDate(bool doAremosStuff, int virtualCol, string date, GekkoTime gt, GekkoTime gtStart, Table tab, int numberOfLabelsLinesMax, bool transpose, ref int virtualRows, O.Prt o)
        {
            //date and gt correspond here
            bool doPrint = false; if (virtualCol == 1) doPrint = true;

            if (doAremosStuff)
            {
                if (gt.sub == 1 || (gt.sub > 1 && (gt.IsSamePeriod(gtStart))))
                {
                    //first quarter or month, or if not do it anyway if it is the first date printed
                    if (doPrint) tab.Set(virtualRows + numberOfLabelsLinesMax, 1, gt.super.ToString());
                    virtualRows++;
                }
            }

            //insert dates
            string line = "";
            if (doAremosStuff)
            {
                if (gt.freq == EFreq.Quarterly) line += "  " + "q" + gt.sub;
                else if (gt.freq == EFreq.Monthly) line += "  " + "m" + gt.sub;
                else
                {
                    G.Writeln2("*** ERROR: Internal error #7523943");
                    throw new GekkoException();
                }
            }
            else
            {
                line += date;
            }
            int iii = virtualRows + numberOfLabelsLinesMax;
            int jjj = 1;
            if (transpose)
            {
                iii = 1;
                jjj = virtualRows + numberOfLabelsLinesMax;
            }
            if (doPrint) tab.Set(iii, jjj, line);
            if (transpose)
            {
                tab.SetAlign(iii, jjj, Align.Right);
            }

            if (doAremosStuff && GetCollapseType(o) != EPrtCollapseTypes.None)
            {
                if ((gt.freq == EFreq.Quarterly && gt.sub == 4) || (gt.freq == EFreq.Monthly && gt.sub == 12))
                {
                    //virtualRows++;  //The row containing the collapsed value
                }
            }
            return;
        }

        private static List<string> PrintGetPrintcodesOLD(bool isMulprt, List<string> printCodes, bool isGraph, bool isSheet)
        {
            bool mul_lev = false;
            bool mul_abs = false;
            bool mul_pch = false;
            bool mul_gdif = false;
            bool abs = false;
            bool dif = false;
            bool pch = false;
            bool gdif = false;

            List<string> printCodesNew = null;
            //Range: ShortVersion, LongVersionHasYes, LongVersionHasAppend, LongVersionOnlyNo, None
            EPrintCodeTypes printCodeType = GetPrintCodeType(printCodes);  //also performs validation that they are not mixed wrongly

            if (printCodeType == EPrintCodeTypes.None || printCodeType == EPrintCodeTypes.LongVersionHasYes || printCodeType == EPrintCodeTypes.LongVersionHasAppend || printCodeType == EPrintCodeTypes.LongVersionOnlyNo)
            {
                printCodesNew = new List<string>();
                PrintGetPrintCodesHelper2(isSheet, ref mul_lev, ref mul_abs, ref mul_pch, ref mul_gdif, ref abs, ref dif, ref pch, ref gdif);
                if (isGraph)
                {
                    mul_pch = false;  //probably never relavant, but for symmetry
                    pch = false;
                }

                if (printCodeType == EPrintCodeTypes.LongVersionHasYes)  //then it may contain yes and no elements (but no append). The yes element clears all defaults, so no elements are not really interesting here since they will have no effect
                {
                    //clear them all
                    mul_lev = false;
                    mul_abs = false;
                    mul_pch = false;
                    mul_gdif = false;
                    abs = false;
                    dif = false;
                    pch = false;
                    gdif = false;
                }
                else
                {
                    //keep global option values for None, LongVersionHasAppend or LongVersionOnlyNo
                }
                bool levTest = false;
                bool absTest = false;
                bool difTest = false;
                bool pchTest = false;
                bool gdifTest = false;

                foreach (string printCode in printCodes)
                {
                    if (isMulprt)  //MULPRT
                    {
                        if (printCode == "lev" || printCode == "_lev")
                        {
                            levTest = TestNoDuplicateDisplayCode(levTest, "lev");
                            mul_lev = true;
                        }
                        else if (printCode == "nolev")
                        {
                            levTest = TestNoDuplicateDisplayCode(levTest, "lev");
                            mul_lev = false;
                        }
                        else if (printCode == "abs" || printCode == "_abs")
                        {
                            absTest = TestNoDuplicateDisplayCode(absTest, "abs");
                            mul_abs = true;
                        }
                        else if (printCode == "noabs")
                        {
                            absTest = TestNoDuplicateDisplayCode(absTest, "abs");
                            mul_abs = false;
                        }
                        else if (printCode == "pch" || printCode == "_pch")
                        {
                            pchTest = TestNoDuplicateDisplayCode(pchTest, "pch");
                            mul_pch = true;
                        }
                        else if (printCode == "nopch")
                        {
                            pchTest = TestNoDuplicateDisplayCode(pchTest, "pch");
                            mul_pch = false;
                        }
                        else if (printCode == "gdif" || printCode == "_gdif")
                        {
                            gdifTest = TestNoDuplicateDisplayCode(gdifTest, "gdif");
                            mul_gdif = true;
                        }
                        else if (printCode == "nogdif")
                        {
                            gdifTest = TestNoDuplicateDisplayCode(gdifTest, "gdif");
                            mul_gdif = false;
                        }
                    }
                    else  //normal PRT
                    {
                        if (printCode == "abs" || printCode == "_abs")
                        {
                            absTest = TestNoDuplicateDisplayCode(absTest, "abs");
                            abs = true;
                        }
                        else if (printCode == "noabs")
                        {
                            absTest = TestNoDuplicateDisplayCode(absTest, "abs");
                            abs = false;
                        }
                        else if (printCode == "dif" || printCode == "_dif")
                        {
                            difTest = TestNoDuplicateDisplayCode(difTest, "dif");
                            dif = true;
                        }
                        else if (printCode == "nodif")
                        {
                            difTest = TestNoDuplicateDisplayCode(difTest, "dif");
                            dif = false;
                        }
                        else if (printCode == "pch" || printCode == "_pch")
                        {
                            pchTest = TestNoDuplicateDisplayCode(pchTest, "pch");
                            pch = true;
                        }
                        else if (printCode == "nopch")
                        {
                            pchTest = TestNoDuplicateDisplayCode(pchTest, "pch");
                            pch = false;
                        }
                        else if (printCode == "gdif" || printCode == "_gdif")
                        {
                            gdifTest = TestNoDuplicateDisplayCode(gdifTest, "gdif");
                            gdif = true;
                        }
                        else if (printCode == "nogdif")
                        {
                            gdifTest = TestNoDuplicateDisplayCode(gdifTest, "gdif");
                            gdif = false;
                        }
                    }
                }
                if (isMulprt)
                {
                    //will always be in {n,m,q,mp} order
                    if (mul_lev) printCodesNew.Add("n");
                    if (mul_abs) printCodesNew.Add("m");
                    if (mul_pch) printCodesNew.Add("q");
                    if (mul_gdif) printCodesNew.Add("mp");
                }
                else
                {
                    //will always be in {n,d,p,dp} order
                    if (abs) printCodesNew.Add("n");
                    if (dif) printCodesNew.Add("d");
                    if (pch) printCodesNew.Add("p");
                    if (gdif) printCodesNew.Add("dp");
                }
            }
            else
            {
                if (!isMulprt && !isGraph && printCodes.Count == 1 && G.equal(printCodes[0], "r"))
                {
                    //PRT<r> or SHEET/CLIP<r>
                    PrintGetPrintCodesHelper2(isSheet, ref mul_lev, ref mul_abs, ref mul_pch, ref mul_gdif, ref abs, ref dif, ref pch, ref gdif);
                    printCodesNew = new List<string>();
                    if (abs) printCodesNew.Add("rn");
                    if (dif) printCodesNew.Add("rd");
                    if (pch) printCodesNew.Add("rp");
                    if (gdif) printCodesNew.Add("rdp");
                }
                else
                {
                    printCodesNew = printCodes;  //point to same object
                }
            }
            return printCodesNew;
        }

        private static void PrintGetPrintCodesHelper2(bool isSheet, ref bool mul_lev, ref bool mul_abs, ref bool mul_pch, ref bool mul_gdif, ref bool abs, ref bool dif, ref bool pch, ref bool gdif)
        {
            if (isSheet)
            {
                //In this case, the printcodes are transformed to the short format
                mul_lev = Program.options.sheet_mulprt_lev;
                mul_abs = Program.options.sheet_mulprt_abs;
                mul_pch = Program.options.sheet_mulprt_pch;
                mul_gdif = Program.options.sheet_mulprt_gdif;
                abs = Program.options.sheet_prt_abs;
                dif = Program.options.sheet_prt_dif;
                pch = Program.options.sheet_prt_pch;
                gdif = Program.options.sheet_prt_gdif;
            }
            else
            {
                mul_lev = Program.options.print_mulprt_lev;
                mul_abs = Program.options.print_mulprt_abs;
                mul_pch = Program.options.print_mulprt_pch;
                mul_gdif = Program.options.print_mulprt_gdif;
                abs = Program.options.print_prt_abs;
                dif = Program.options.print_prt_dif;
                pch = Program.options.print_prt_pch;
                gdif = Program.options.print_prt_gdif;
            }
        }

        private static void PrintGetWithAndDecimals(O.Prt o, int varI, List<string> printCodesNew, List<int> widths, List<int> decs)
        {
            foreach (string printCode in printCodesNew)
            {
                int width = -12345;
                int dec = -12345;
                bool isPchType = false;
                if (IsLevelPrintCode(printCode))
                {
                    isPchType = false;
                    width = options.print_fields_nwidth;
                    dec = options.print_fields_ndec;
                }
                else
                {
                    isPchType = true;
                    width = options.print_fields_pwidth;
                    dec = options.print_fields_pdec;
                }

                // ---------------------------------------------
                // --- Width -----------------------------------
                // ---------------------------------------------
                if (o.opt_width != -12345) width = (int)o.opt_width;
                if (isPchType)
                {
                    //overrides ph.width if given
                    if (o.opt_pwidth != -12345) width = (int)o.opt_pwidth;
                }
                else
                {
                    //overrides ph.width if given
                    if (o.opt_nwidth != -12345) width = (int)o.opt_nwidth;
                }

                //element-specific stuff
                if (o.prtElements[varI] != null && o.prtElements[varI].width != -12345) width = o.prtElements[varI].width;   //element-specific width overrides!
                if (isPchType)
                {
                    //overrides ph.width if given
                    if (o.prtElements[varI] != null && o.prtElements[varI].pwidth != -12345) width = o.prtElements[varI].pwidth;
                }
                else
                {
                    //overrides ph.width if given
                    if (o.prtElements[varI] != null && o.prtElements[varI].nwidth != -12345) width = o.prtElements[varI].nwidth;
                }


                // ---------------------------------------------
                // --- Decimals --------------------------------
                // ---------------------------------------------
                if (o.opt_dec != -12345) dec = (int)o.opt_dec;
                if (isPchType)
                {
                    //overrides ph.dec if given
                    if (o.opt_pdec != -12345) dec = (int)o.opt_pdec;
                }
                else
                {
                    //overrides ph.dec if given
                    if (o.opt_ndec != -12345) dec = (int)o.opt_ndec;
                }

                //element-specific stuff
                if (o.prtElements[varI] != null && o.prtElements[varI].dec != -12345) dec = o.prtElements[varI].dec;   //element-specific dec overrides!
                if (isPchType)
                {
                    //overrides ph.dec if given
                    if (o.prtElements[varI] != null && o.prtElements[varI].pdec != -12345) dec = o.prtElements[varI].pdec;
                }
                else
                {
                    //overrides ph.dec if given
                    if (o.prtElements[varI] != null && o.prtElements[varI].ndec != -12345) dec = o.prtElements[varI].ndec;
                }


                widths.Add(width);
                decs.Add(dec);
            }
        }

        private static bool IsLevelPrintCode(string printCode)
        {
            return printCode == "" || printCode == "n" || printCode == "d" || printCode == Globals.printCode_s || printCode == Globals.printCode_sn || printCode == Globals.printCode_sd || printCode == "m";
        }

        private static string GetPrintCodeLabel(string printCode, bool isVerbose, bool useExoEndoIndicator, bool identicalCodes)
        {
            string printCodeLabel = "";
            if (printCode == "n")
            {
                printCodeLabel = "lev";  //MULPRT<lev>
            }
            else if (printCode == Globals.printCode_s || printCode == Globals.printCode_sn)
            {
                printCodeLabel = "@lev";
                if (isVerbose) printCodeLabel = Globals.Ref + " bank";
            }
            else if (printCode == "d") printCodeLabel = "dif";  //PRT<dif>
            else if (printCode == Globals.printCode_sd) printCodeLabel = "@dif";
            else if (printCode == "p") printCodeLabel = "%";  //PRT<pch>
            else if (printCode == Globals.printCode_sp)
            {
                printCodeLabel = "@%";
                if (isVerbose) printCodeLabel = "%";
            }
            else if (printCode == "dp") printCodeLabel = "dif%";  //PRT<gdif>
            else if (printCode == Globals.printCode_sdp) printCodeLabel = "@dif%";
            else if (printCode == "m")
            {
                printCodeLabel = "mdif";  //MULPRT<abs>
                if (isVerbose) printCodeLabel = "Difference";
            }
            else if (printCode == "q")
            {
                printCodeLabel = "m%";  //MULPRT<pch>
                if (isVerbose) printCodeLabel = "%";
            }
            else if (printCode == "mp") printCodeLabel = "mdif%";  //MULPRT<gdif>
            if (!isVerbose) printCodeLabel = "[" + printCodeLabel + "]";
            if (identicalCodes && printCodeLabel == "[lev]") printCodeLabel = "";  //no need for a [lev] on a PRT<nopch>.
            return printCodeLabel;
        }

        private static bool HasIdenticalCodes(List<string> graphVars, PrtHelper ph)
        {
            bool identicalCodes = true;
            for (int varI = 0; varI < graphVars.Count; varI++)  //varI 0-based
            {
                if (ph.elementOptions[varI] != null)
                {
                    identicalCodes = false;
                    break;
                }
            }
            if (ph.printCodes.Count > 1) identicalCodes = false;
            if (ph.printCodes.Count == 1)
            {
                string s = ph.printCodes[0];
                if (IsPrintCodeLongAppend(s)) identicalCodes = false;
                if (IsPrintCodeLongNo(s)) identicalCodes = false;
            }
            return identicalCodes;
        }

        private static bool HasIdenticalCodesNew(List<TimeSeries> graphVars, PrtHelper ph)
        {
            bool identicalCodes = true;
            for (int varI = 0; varI < graphVars.Count; varI++)  //varI 0-based
            {
                if (ph.elementOptions[varI] != null)
                {
                    identicalCodes = false;
                    break;
                }
            }
            if (ph.printCodes.Count > 1) identicalCodes = false;
            if (ph.printCodes.Count == 1)
            {
                string s = ph.printCodes[0];
                if (IsPrintCodeLongAppend(s)) identicalCodes = false;
                if (IsPrintCodeLongNo(s)) identicalCodes = false;
            }
            return identicalCodes;
        }

        private static bool TestNoDuplicateDisplayCode(bool variable, string name)
        {
            if (variable)
            {
                G.Writeln();
                G.Writeln("*** ERROR: There are more than one '" + name + "' display codes");
                throw new GekkoException();
            }
            variable = true;
            return variable;
        }

        private static EPrintCodeTypes GetPrintCodeType(List<string> printCodes)
        {
            EPrintCodeTypes printCodeType = EPrintCodeTypes.Null;
            bool isVerbose = false;
            foreach (string printCode in printCodes)
            {
                if (IsPrintCodeLong(printCode))
                {
                    if (printCodeType == EPrintCodeTypes.LongVersionHasAppend)
                    {
                        WritePrintCodeMismatchError();
                    }
                    printCodeType = EPrintCodeTypes.LongVersionHasYes;
                }
                else if (IsPrintCodeLongAppend(printCode))
                {
                    if (printCodeType == EPrintCodeTypes.LongVersionHasYes)
                    {
                        WritePrintCodeMismatchError();
                    }
                    printCodeType = EPrintCodeTypes.LongVersionHasAppend;
                }
                else if (IsPrintCodeLongNo(printCode))
                {
                    if (printCodeType == EPrintCodeTypes.Null)
                    {
                        //do not override if others are found
                        printCodeType = EPrintCodeTypes.LongVersionOnlyNo;
                    }
                }
                else if (IsPrintCodeShort(printCode))
                {
                    if (printCodeType == EPrintCodeTypes.LongVersionHasAppend || printCodeType == EPrintCodeTypes.LongVersionHasYes || printCodeType == EPrintCodeTypes.LongVersionOnlyNo)
                    {
                        G.Writeln();
                        G.Writeln("*** ERROR: You cannot mix display codes of short and long type, for example");
                        G.Writeln("           PRT<p abs> or PRT<d pch=no> etc. Please consult the help file regarding", Color.Red);
                        G.Writeln("           the PRT and MULPRT commands. Short types are n, d, p, m, q, mp and", Color.Red);
                        G.Writeln("           similar, whereas long types are lev, abs, dif, pch, gdif.", Color.Red);
                        throw new GekkoException();
                    }
                    printCodeType = EPrintCodeTypes.ShortVersion;
                }
                else if (G.equal(printCode, "v"))
                {
                    //in that case, all other print options are suppressed, so you can write MULPRT<v gdif> and only a MULPRT<v> will be issued (this makes it easier to quickly put a 'v' in the optionfield to get a GMULPRT)
                    isVerbose = true;
                }
                else
                {
                    G.Writeln();
                    G.Writeln("*** ERROR: Sorry, internal Gekko error related to display codes");
                    throw new GekkoException();
                }
            }
            if (printCodes.Count == 0)
            {
                printCodeType = EPrintCodeTypes.None;
            }
            if (isVerbose) printCodeType = EPrintCodeTypes.Verbose;  //overrides everything else
            if (printCodeType == EPrintCodeTypes.Null)
            {
                G.Writeln();
                G.Writeln("*** ERROR: Sorry, internal Gekko error related to display codes");
                throw new GekkoException();
            }
            return printCodeType;
        }

        public static bool IsPrintCodeShort(string printCode)
        {
            return G.equal(printCode, "n") || G.equal(printCode, "d") || G.equal(printCode, "p") || G.equal(printCode, "dp") || G.equal(printCode, Globals.printCode_s) || G.equal(printCode, Globals.printCode_sn) || G.equal(printCode, Globals.printCode_sd) || G.equal(printCode, Globals.printCode_sp) || G.equal(printCode, Globals.printCode_sdp) || G.equal(printCode, "m") || G.equal(printCode, "q") || G.equal(printCode, "mp");
        }

        public static bool IsPrintCodeShortMultiplier(string printCode)
        {
            return G.equal(printCode, "m") || G.equal(printCode, "q") || G.equal(printCode, "mp") || G.equal(printCode, "v");
        }

        public static bool IsPrintCodeShortBase(string printCode)
        {
            return G.equal(printCode, Globals.printCode_s) || G.equal(printCode, Globals.printCode_sn) || G.equal(printCode, Globals.printCode_sd) || G.equal(printCode, Globals.printCode_sp) || G.equal(printCode, Globals.printCode_sdp);
        }

        public static bool IsPrintCodeShortWork(string printCode)
        {
            return printCode == null || G.equal(printCode, "") || G.equal(printCode, "n") || G.equal(printCode, "d") || G.equal(printCode, "p") || G.equal(printCode, "dp");
        }

        private static bool IsPrintCodeLongNo(string printCode)
        {
            return G.equal(printCode, "nolev") || G.equal(printCode, "noabs") || G.equal(printCode, "nodif") || G.equal(printCode, "nopch") || G.equal(printCode, "nogdif");
        }

        private static bool IsPrintCodeLongAppend(string printCode)
        {
            return G.equal(printCode, "_lev") || G.equal(printCode, "_abs") || G.equal(printCode, "_dif") || G.equal(printCode, "_pch") || G.equal(printCode, "_gdif");
        }

        private static bool IsPrintCodeLong(string printCode)
        {
            return G.equal(printCode, "lev") || G.equal(printCode, "abs") || G.equal(printCode, "dif") || G.equal(printCode, "pch") || G.equal(printCode, "gdif");
        }

        private static void WritePrintCodeMismatchError()
        {
            G.Writeln();
            G.Writeln("*** ERROR: You cannot mix display codes of type 'yes' and 'append', for instance");
            G.Writeln("           PRT<pch=yes gdif=append> or the equivalent PRT<pch _gdif>", Color.Red);
            throw new GekkoException();
        }

        public static void PrtClipboard(Table table, bool calledFromCopyButton)
        {
            if (table == null)
            {
                G.Writeln2("*** ERROR: No print or table recorded to put on clipboard");
                throw new GekkoException();
            }
            StringBuilder s = new StringBuilder();

            for (int i = 1; i <= table.GetRowMaxNumber(); i++)
            {
                if (i > 1) s.Append("\n");
                for (int j = 1; j <= table.GetColMaxNumber(); j++)
                {
                    Cell cell2 = table.Get(i, j);
                    string s2 = "";
                    if (cell2 == null)
                    {
                    }
                    else
                    {
                        if (cell2.cellType == CellType.Number)
                        {
                            s2 = PrepareDataForClipboard(cell2.number);
                        }
                        else if (cell2.cellType == CellType.Date)
                        {
                            s2 = cell2.date;
                        }
                        else if (cell2.cellType == CellType.Text)
                        {
                            s2 = cell2.CellText.TextData[0];
                        }
                    }
                    if (j > 1) s.Append("\t");
                    s.Append(s2);
                }
            }
            string ss = s.ToString();
            System.Windows.Forms.Clipboard.SetText(ss, System.Windows.Forms.TextDataFormat.Text);
            G.Writeln2("You may now paste (Ctrl-V) cells into your spreadsheet (e.g. Excel)");
            if (calledFromCopyButton)
            {
                G.Writeln("These are the cells from your last PRT/MULPRT/SHOW or table.");
            }
        }

        public static string PrepareDataForClipboard(double d2)
        {
            string s2 = d2.ToString(CultureInfo.InvariantCulture);  //should always be "." with this locale corresponding to US style (is used also for PRT etc)

            if (s2.Contains(",") && s2.Contains("."))
            {
                if (s2.IndexOf(",") < s2.IndexOf("."))
                {
                    //we have at least one "____,____.____", so at least one "," to the left of "."
                    //then we remove the ",", for instance in 12,345,678.22 --> 12345678.22
                    //(If it should happen to be 12.345.678,22 then we would not be here)
                    s2 = s2.Replace(",", "");
                }
            }

            //now s2 should be with "." if there is a decimal (and no thousand grouping)

            if (G.equal(Program.options.interface_clipboard_decimalseparator, "comma"))
            {
                s2 = s2.Replace(".", ",");
            }
            if (s2 == "9.99999E+99" || s2 == "9,99999E+99"  //I think this is funny number made in Excel printing routine, to signal missing value
                || G.isNumericalError(d2) || d2 == 3e300d )  //NumericalError is 'M', and the number 3e300 is a signal from a table that variable is non-existing ('N')
            {
                s2 = "=na()";
                if (G.equal(Program.options.interface_excel_language, "danish"))
                {
                    s2 = "=ikke.tilgængelig()";
                }
            }
            return s2;
        }

        private static void Cplot(string transpose, string dates, string labels, ExcelDataForCplot ed)
        {
            int rows = ed.data.GetLength(0);
            int cols = ed.data.GetLength(1);
            string[,] x = new string[rows + 1, cols + 1]; //hmmm what if not there...

            bool hasDates = true;
            if (G.equal(dates, "no"))
            {
                hasDates = false;
            }

            bool hasLabels = true;
            if (G.equal(labels, "no"))
            {
                hasLabels = false;
            }

            bool isTranspose = false;
            if (G.equal(transpose, "yes"))
            {
                isTranspose = true;
            }

            x[0, 0] = "";

            if (isTranspose)
            {
                for (int col = 0; col < cols; col++)
                {
                    if (hasLabels) x[0, col + 1] = ed.varnames[0, col];
                }
                for (int row = 0; row < rows; row++)
                {
                    if (hasDates) x[row + 1, 0] = ed.dates[row, 0];
                }
            }
            else
            {
                for (int col = 0; col < cols; col++)
                {
                    if (hasDates) x[0, col + 1] = ed.dates[0, col];
                }
                for (int row = 0; row < rows; row++)
                {
                    if (hasLabels) x[row + 1, 0] = ed.varnames[row, 0];
                }
            }

            for (int row = 0; row < rows; row++)
            {
                for (int col = 0; col < cols; col++)
                {
                    x[row + 1, col + 1] = PrepareDataForClipboard(ed.data[row, col]);
                }
            }

            int rowStart = 0;
            int colStart = 0;

            if (isTranspose)
            {
                if (!hasLabels) rowStart = 1;
                if (!hasDates) colStart = 1;
            }
            else
            {
                if (!hasLabels) colStart = 1;
                if (!hasDates) rowStart = 1;
            }

            StringBuilder s = new StringBuilder();
            if (ed.stamp != null)
            {
                s.Append(ed.stamp);
                s.Append("\n");
            }

            if (ed.heading != null)
            {
                s.Append(ed.heading);
                s.Append("\n");
            }

            for (int i = rowStart; i < rows + 1; i++)
            {
                for (int j = colStart; j < cols + 1; j++)
                {
                    if (j - colStart > 0) s.Append("\t");
                    string s2 = x[i, j];
                    s.Append(s2);
                }
                if (i < rows) s.Append("\n");
            }
            System.Windows.Forms.Clipboard.SetText(s.ToString(), System.Windows.Forms.TextDataFormat.Text);
            G.Writeln2("CSHEET: You may now paste (Ctrl-V) cells into your spreadsheet (e.g. Excel)");
        }

        private static void GraphThreadFunction(Object o)
        {
            GraphOptions graphOptions = (GraphOptions)o;
            Graph g = new Graph(graphOptions);
            Globals.windowsGraph.Add(g);
            if(true)
            {
                //otherwise, setting them checked = true fires a redraw event
                Globals.disableRationButtons = 1;
                g.radioButton1.Checked = graphOptions.po.isLevel;
                g.radioButton2.Checked = graphOptions.po.isLog;
                g.radioButton5.Checked = graphOptions.po.isDiff;
                g.radioButton3.Checked = graphOptions.po.isPch;
                g.radioButton8.Checked = graphOptions.po.isDlog;
                g.checkBox1.Checked = graphOptions.po.isMultiplier;
                Globals.disableRationButtons = 0;
            }

            g.ShowDialog();
            graphOptions.windowIsShown = true;

            //end of graph window
            g.Close();
            g.Dispose();
            g = null;
        }

        private static void MaybeStartPipe2(string fileName)
        {
            if (fileName != null && fileName != "" && !Globals.pipe2)  //is piped to special pipe-file (pipe2), and not already piping to pipe2 (could be case if called via DIFPRT for example)
            {
                //if exception, these will be reset somewhere else, so no need to have a try-catch-finally regarding the file stream
                Globals.pipe2 = true;
                Globals.pipeFileHelper2.pipeFileFileWithPath = CreateFullPathAndFileName(fileName);
                Globals.pipeFileHelper2.pipeFile = G.GekkoStreamWriter(WaitForFileStream(Globals.pipeFileHelper2.pipeFileFileWithPath, GekkoFileReadOrWrite.Write));
            }
        }


        private static string SubstituteEscapeCharacters(string s, bool fromEscapeToArtificialChars)
        {
            if (false)
            {
                //Problem is for instance: "READ c:\folders\#bankname\scenarion"
                //This will be seen a lot.
                //what about &lbrace;  &rbrace;  &hash;
                //or &lbrace$  &rbrace$  &hash$
                //or &lbrace&  &rbrace&  &hash&
                //or {{  }}  ##

                if (fromEscapeToArtificialChars)
                {
                    s = s.Replace("\\{", "<[LEFTCURLY]>");
                    s = s.Replace("\\}", "<[RIGHTCURLY]>");
                    s = s.Replace("\\#", "<[HASHCHARACTER]>");
                    //s = s.Replace("\\'", "<[QUOTE]>");
                }
                else
                {
                    s = s.Replace("<[LEFTCURLY]>", "{");
                    s = s.Replace("<[RIGHTCURLY]>", "}");
                    s = s.Replace("<[HASHCHARACTER]>", "#");
                    //s = s.Replace("<[QUOTE]>", "'");
                }
            }
            return s;
        }

        private static List<string> ExtractEndoExoIndicators(List<string> variables, List<Dictionary<string, string>> precedents)
        {
            List<string> endoExoIndicators = new List<string>();
            for (int i = 0; i < precedents.Count; i++)
            {
                string var = "";
                string endoExo = "";
                Dictionary<string, string> d = precedents[i];

                bool endo = true;
                bool exo = true;
                foreach (string s in d.Keys)
                {
                    string varWithoutLag = G.ExtractOnlyVariableIgnoreLag(s);
                    if (varWithoutLag.StartsWith("@")) varWithoutLag = varWithoutLag.Substring(1);
                    EEndoOrExo type = VariableTypeEndoExo(varWithoutLag);
                    if (type != EEndoOrExo.Endo) endo = false;
                    if (type != EEndoOrExo.Exo) exo = false;
                }
                if (endo)
                {
                    endoExo = "e";
                }
                else if (exo)
                {
                    endoExo = "x";
                }
                else endoExo = " ";
                endoExoIndicators.Add(endoExo);
            }
            if (endoExoIndicators.Count != variables.Count) throw new GekkoException();  //sanity check
            return endoExoIndicators;
        }



        private static void AddListToPrecedentsEtc(List<string> variables, List<string> variablesLabels, List<Dictionary<string, string>> precedents, List<string> unfolded)
        {
            foreach (string listItem in unfolded)
            {
                variables.Add(listItem);
                variablesLabels.Add(listItem);
                Dictionary<string, string> precedentsTemp = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
                precedentsTemp.Add(listItem + Globals.lagIndicator + "0", "");
                precedents.Add(precedentsTemp);
            }
        }

        public static void CreateLeftSideVariableIfNeeded(List<Dictionary<string, string>> precedentsWithLagIndicator, string variable)
        {
            //variable = SubstituteAssignVars(variable);
            if (Program.databanks.GetFirst().GetVariable(variable) == null)
            {
                if (!variable.ToLower().StartsWith("xx"))
                {
                    IssueCreateWarning(variable);
                }
                G.Writeln("+++ NOTE: Variable " + variable + " not found in databank -- is created");
                TimeSeries tempTs = new TimeSeries(Program.options.freq, variable);
                Program.databanks.GetFirst().AddVariable(tempTs);

                for (int i = 0; i < precedentsWithLagIndicator.Count; i++)
                {
                    Dictionary<string, string> d = precedentsWithLagIndicator[i];
                    foreach (string prec in d.Keys)
                    {
                        string variable2 = "";
                        int lag = 0;

                        if (prec.Contains(Globals.lagIndicator + Globals.lagIndicator))
                        {
                            //drop to issue this warning if this is the case: genr nyvar = nyvar(2001m1) $
                            //that will give NaN with no warning/explanation given.
                        }
                        else
                        {
                            G.ExtractVariableAndLag(prec, out variable2, out lag);
                            if (G.equal(variable, variable2) && lag != 0)
                            {
                                G.Writeln("+++ WARNING: The non-existing variable " + variable + " appears with lag or leads on right hand side -- so this will produce missing values");
                                break;
                            }
                        }
                    }
                }
            }
        }

        private static void IssueCreateWarning(string variable)
        {
            G.Writeln();
            G.Writeln("*** ERROR: You are trying to put data into a variable or list ('" + variable + "') that does not exist.");
            G.Writeln("           Please create the variable or list first (CREATE or LIST command), or use a");
            G.Writeln("           name that starts with the characters 'xx'.");
            //if (Program.options.calc_ignoremissingvars)
            //{
            //    G.Writeln("           The error is ignored: set 'OPTION calc ignoremissingvars = no' to enforce such errors");
            //}
            //else
            //{
            //    G.Writeln("           Since Gekko 1.5.1 and onwards, Gekko will abort execution in such cases.");
            //    G.Writeln("           You may set 'OPTION calc ignoremissingvars = yes' to ignore such problems.");
            //    throw new GekkoException();
            //}
        }


        public static EMissingType CheckVariableExistence(List<string> variablesLabelsForPrtCommand, List<Dictionary<string, string>> precedents, bool isMultiplier, bool isCalledFromGenr, bool isBaseline, bool isCalledFromTable)
        {
            if (!(G.equal(Program.databanks.GetFirst().aliasName, Globals.Work) && G.equal(Program.databanks.GetRef().aliasName, Globals.Ref)))
            {
                G.Writeln2("*** ERROR: Please use Work and " + Globals.Ref + " as first and reference databanks");
                throw new GekkoException();
            }
            //In the method below, any memory vars of VAL type will be removed
            //if (isCalledFromGenr) SubstituteAssignVarsInPrecedents(precedents);  //a bit slow for GENR maybe... for PRT etc. it has already been called when this method is called
            bool hasIssuedWarning = false;
            Dictionary<string, string> problem = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
            for (int i = 0; i < precedents.Count; i++)
            {
                Dictionary<string, string> d = precedents[i];
                foreach (string s in d.Keys)
                {
                    List<string> banks = new List<string>();

                    string varWithBaseBankIndicator = G.ExtractOnlyVariableIgnoreLag(s);  //TODO: will produce dublets if "p fy/fy(-1)" or "p fy fm/fy" , but never mind now

                    string[] split = null;
                    if (varWithBaseBankIndicator.Contains(":"))
                    {
                        //p<m>adam:fy
                        split = varWithBaseBankIndicator.Split(':');
                        banks.Add(split[0]);
                    }
                    else
                    {

                        if (isMultiplier)
                        {
                            if (varWithBaseBankIndicator.StartsWith("@"))
                            {
                                //p<m>@fy                --------- this is not really meaningful
                                banks.Add(Globals.Ref);
                                if (!hasIssuedWarning) G.Writeln("+++ WARNING: Note that you are using @-variables in combination with the <m> (multiplier) option");
                                hasIssuedWarning = true;
                            }
                            else
                            {
                                //p<m>fy
                                banks.Add(Globals.Work);
                                banks.Add(Globals.Ref);
                            }
                        }
                        else
                        {
                            if (isBaseline)
                            {
                                if (varWithBaseBankIndicator.StartsWith("@"))
                                {
                                    //p<b>@fy                --------- this is not really meaningful
                                    banks.Add(Globals.Ref);
                                    if (!hasIssuedWarning) G.Writeln("+++ WARNING: Note that you are using @-variables in combination with the <r> (reference) option");
                                    hasIssuedWarning = true;
                                }
                                else
                                {
                                    //p<b>fy
                                    banks.Add(Globals.Ref);
                                }
                            }
                            else
                            {
                                if (varWithBaseBankIndicator.StartsWith("@"))
                                {
                                    //p @fy
                                    banks.Add(Globals.Ref);
                                }
                                else
                                {
                                    //p fy
                                    banks.Add(Globals.Work);
                                }
                            }
                        }
                    }

                    string variableName = varWithBaseBankIndicator;
                    if (variableName.StartsWith("@"))
                    {
                        variableName = variableName.Substring(1);
                    }
                    else if (varWithBaseBankIndicator.Contains(":"))
                    {
                        variableName = split[1];
                    }

                    foreach (string bank in banks)
                    {
                        bool noBank = false;
                        if (Program.databanks.GetDatabank(bank) == null) noBank = true;
                        if (noBank || Program.databanks.GetDatabank(bank).GetVariable(variableName) == null)
                        {
                            if (!problem.ContainsKey(varWithBaseBankIndicator))
                            {
                                problem.Add(varWithBaseBankIndicator, "");
                                string ss = "";
                                if (variablesLabelsForPrtCommand != null && !G.equal(variableName, variablesLabelsForPrtCommand[i])) ss = " -- " + variablesLabelsForPrtCommand[i];
                                if (isCalledFromTable && Program.options.table_ignoremissingvars)
                                {
                                }
                                else
                                {
                                    G.Writeln("*** ERROR: Could not find variable '" + variableName + "' (freq = " + Program.options.freq + ") in '" + bank + "' databank" + ss);
                                    if (noBank)
                                    {
                                        G.Writeln("           The databank '" + bank + "' does not seem to exist", Color.Red);
                                    }
                                }
                            }
                        }
                    }
                }
            }
            if (isCalledFromTable && Program.options.table_ignoremissingvars)
            {
                if (problem.Count > 0)
                {
                    return EMissingType.HasMissingVariables;
                }
                else
                {
                    return EMissingType.Ok;
                }
            }
            else
            {
                if (problem.Count > 0)
                {
                    throw new GekkoException();
                }
            }
            return EMissingType.Ok;
        }

        public static PrtOptionsHelper ExtractPrintOptions(string printOptions)
        {
            PrtOptionsHelper po = new PrtOptionsHelper();
            if (true)
            {
                string firstChar = "";
                switch (printOptions.ToLower())
                {
                    case "":
                    case "n":
                        po.isMultiplier = false;
                        po.isBaseline = false;
                        po.isLog = false;
                        po.isPch = false;
                        po.isDlog = false;
                        po.isDiff = false;
                        po.isLevel = true;
                        break;
                    case "m":
                        po.isMultiplier = true;
                        po.isBaseline = false;
                        po.isLog = false;
                        po.isPch = false;
                        po.isDlog = false;
                        po.isDiff = true;
                        po.isLevel = false;
                        break;
                    case "q":
                        po.isMultiplier = true;
                        po.isBaseline = false;
                        po.isLog = false;
                        po.isPch = true;
                        po.isDlog = false;
                        po.isDiff = false;
                        po.isLevel = false;
                        break;
                    case "d":
                        po.isMultiplier = false;
                        po.isBaseline = false;
                        po.isLog = false;
                        po.isPch = false;
                        po.isDlog = false;
                        po.isDiff = true;
                        po.isLevel = false;
                        break;
                    case "p":
                        po.isMultiplier = false;
                        po.isBaseline = false;
                        po.isLog = false;
                        po.isPch = true;
                        po.isDlog = false;
                        po.isDiff = false;
                        po.isLevel = false;
                        break;
                    case Globals.printCode_s:
                    case Globals.printCode_sn:
                        po.isMultiplier = false;
                        po.isBaseline = true;
                        po.isLog = false;
                        po.isPch = false;
                        po.isDlog = false;
                        po.isDiff = false;
                        po.isLevel = true;
                        break;
                    case Globals.printCode_sd:
                        po.isMultiplier = false;
                        po.isBaseline = true;
                        po.isLog = false;
                        po.isPch = false;
                        po.isDlog = false;
                        po.isDiff = true;
                        po.isLevel = false;
                        break;
                    case Globals.printCode_sp:
                        po.isMultiplier = false;
                        po.isBaseline = true;
                        po.isLog = false;
                        po.isPch = true;
                        po.isDlog = false;
                        po.isDiff = false;
                        po.isLevel = false;
                        break;
                    case "dp":
                        po.isDp = true;
                        break;
                    case "mp":  //"bmp" is not meaningful
                        po.isMp = true;
                        break;
                    case Globals.printCode_sdp:
                        po.isDp = true;
                        po.isBaseline = true;
                        break;
                    default:
                        G.Writeln2("*** ERROR: print-code " + printOptions + " is not legal");
                        throw new GekkoException();
                        break;
                }
                if (!(po.isLog || po.isPch || po.isDlog || po.isDiff))
                {
                    po.isLevel = true;
                }
            }
            return po;
        }




        private static void PrintFirstLineLabels(List<string> rememberWriteStatements, List<string> graphVarsLabels, PrintHelper ph, int numberOfLabelsRows, string[,] labelsArray, List<string> endoExoIndicators)
        {
            for (int i2 = 0; i2 < numberOfLabelsRows; i2++)
            {
                string line = "";
                int i = numberOfLabelsRows - i2 - 1;  //the labels in labelsArray are in reverted order.
                line += G.Blanks(ph.widthDate);
                for (int j = 0; j < graphVarsLabels.Count; j++)
                {
                    line += "  " + G.Blanks(ph.widthLabel - labelsArray[i, j].Length) + labelsArray[i, j];
                    if (ph.width2 > 0)
                    {
                        if (i == 0)
                        {
                            if (endoExoIndicators[j] == " ")
                            {
                                line += "  %";
                            }
                            else
                            {
                                line += " " + "%" + endoExoIndicators[j].ToUpper();
                            }
                        }
                        else
                        {
                            line += "   ";
                        }
                    }
                }
                rememberWriteStatements.Add(line);
            }
        }

        private static int PrintCreateLabelsArrayNew(string label, int width, int numberOfLabelsRowsMax, int maxLength, string[] labelsArray)
        {
            int numberOfLabelsRows = -12345;

            //string label = graphVarsLabels[j];
            string ss = label;
            ss = TruncateTextWithDots(maxLength, ss);

            if (numberOfLabelsRowsMax == 1)  //for some reason, this case must be treated specially... (not sure why)
            {
                numberOfLabelsRows = 1;
                labelsArray[0] = ss;
            }
            else
            {
                for (int i = 0; i < numberOfLabelsRowsMax; i++)
                {
                    //chopping off text backwards
                    int start = ss.Length - width;
                    string s = "";
                    if (start >= 0)
                    {
                        s = ss.Substring(start);
                        ss = ss.Substring(0, ss.Length - s.Length);  //cropping s off
                    }
                    else
                    {
                        if (ss.Length > 0) s = ss;
                        ss = "[[]]";
                    }
                    labelsArray[i] = s;
                    if (labelsArray[i] != "" && labelsArray[i] != "[[]]")
                    {
                        if (i + 1 > numberOfLabelsRows) numberOfLabelsRows = i + 1;
                    }
                }
            }

            return numberOfLabelsRows;
        }

        private static string TruncateTextWithDots(int maxLength, string ss)
        {
            if (ss.Length > maxLength)
            {
                if (maxLength >= 3)
                {
                    ss = ss.Substring(0, maxLength - 3);
                    ss += "...";
                }
                else ss = ss.Substring(0, maxLength);   //almost absurd... maxlength should always be >= 3 (typically 100)
            }

            return ss;
        }

        private static int PrintCreateLabelsArray(List<string> graphVarsLabels, PrintHelper ph, int numberOfLabelsRowsMax, int numberOfLabelsRows, int maxLength, string[,] labelsArray)
        {
            for (int j = 0; j < graphVarsLabels.Count; j++)
            {
                string label = graphVarsLabels[j];
                string ss = label;
                if (ss.Length > maxLength)
                {
                    if (maxLength >= 3)
                    {
                        ss = ss.Substring(0, maxLength - 3);
                        ss += "...";
                    }
                    else ss = ss.Substring(0, maxLength);   //almost absurd... maxlength should always be >= 3 (typically 100)
                }
                for (int i = 0; i < numberOfLabelsRowsMax; i++)
                {
                    //chopping off text backwards
                    int start = ss.Length - ph.widthLabel;
                    string s = "";
                    if (start >= 0)
                    {
                        s = ss.Substring(start);
                        ss = ss.Substring(0, ss.Length - s.Length);  //cropping s off
                    }
                    else
                    {
                        if (ss.Length > 0) s = ss;
                        ss = "";
                    }
                    labelsArray[i, j] = s;
                    if (labelsArray[i, j] != "")
                    {
                        if (i + 1 > numberOfLabelsRows) numberOfLabelsRows = i + 1;
                    }
                }
            }
            return numberOfLabelsRows;
        }

        private static void CallGnuplotNew(Table data, O.Prt o, int count, int maxLabelsLinesFound, List<string> labelsNonBroken)
        {
            if (count == 0)
            {
                G.Writeln2("*** ERROR: PLOT called with 0 variables");
                throw new GekkoException();
            }
            int numberOfObs = GekkoTime.Observations(o.t1, o.t2);
            int rr = Program.RandomInt();
            string file1 = "temp" + rr + ".dat";
            string file2 = "temp" + rr + ".emf";
            string file3 = "temp" + rr + ".gp";
            string heading = "";
            string pplotType = "emf";

            if (o.opt_filename != null)
            {
                pplotType = Path.GetExtension(o.opt_filename);
                if (pplotType.StartsWith(".")) pplotType = pplotType.Substring(1);
                if (pplotType == "")
                {
                    o.opt_filename = AddExtension(o.opt_filename, ".emf");
                    pplotType = "emf";
                }
                if (pplotType != "emf" && pplotType != "png" && pplotType != "svg")
                {
                    G.Writeln2("*** ERROR: In PLOT, expected file type is emf, png or svg");
                    throw new GekkoException();
                }
            }
            bool histo = false;
            string currentDir = Directory.GetCurrentDirectory();  //remembered in order to switch back
            string path = System.Windows.Forms.Application.LocalUserAppDataPath + "\\gnuplot\\tempfiles";

            //tw.WriteLine("set terminal emf size 300 ,200");

            // Determine whether the directory exists.
            if (!Directory.Exists(path))
            {
                Directory.CreateDirectory(path);
            }
            Directory.SetCurrentDirectory(path); //so that gnuplot can access the files


            //foreach (string s in data.Print()) { G.Writeln(s); };

            List<string> labels1 = new List<string>();
            List<string> labels2 = new List<string>();

            using (FileStream fs = WaitForFileStream(path + "\\" + file1, GekkoFileReadOrWrite.Write))
            using (StreamWriter tw = G.GekkoStreamWriter(fs))
            {
                for (int t = 0; t < numberOfObs; t++)
                {
                    string s = null;
                    for (int i = 0; i <= count; i++)
                    {
                        Cell c = data.Get(t + 1 + maxLabelsLinesFound, i + 1);
                        if (i == 0 && c.cellType == CellType.Text)
                        {
                            string d = c.CellText.TextData[0];
                            string dOrig = d;
                            d = GetDateStringSuitableForGnuplot(d);
                            labels1.Add(dOrig);
                            labels2.Add(d);
                            s += d + " ";
                        }
                        else if (i > 0 && c.cellType == CellType.Number)
                        {
                            double d = c.number;
                            s += d + " ";
                        }
                        else
                        {
                            G.Writeln2("*** ERROR: Graph error");
                            throw new GekkoException();
                        }
                    }
                    tw.WriteLine(s);
                }
            }

            using (FileStream fs = WaitForFileStream(path + "\\" + file3, GekkoFileReadOrWrite.Write))
            using (StreamWriter tw = G.GekkoStreamWriter(fs))
            {
                if (o.opt_plotcode != null && o.opt_plotcode.Contains("[histo]"))
                {
                    histo = true;
                    o.opt_plotcode = o.opt_plotcode.Replace("[histo]", "");
                }

                tw.WriteLine("set encoding iso_8859_1");

                heading = EncodeDanish(heading);

                tw.WriteLine("set title \"" + heading + "\"");
                tw.WriteLine("set datafile missing \"NaN\"");
                tw.WriteLine("set terminal " + pplotType);
                tw.WriteLine("set output \"" + file2 + "\"");
                //tw.WriteLine("set data style linespoints"); //probably superfluous
                //tw.WriteLine("set title \"Graph\"");
                //tw.WriteLine("set xlabel \"År\"");
                //tw.WriteLine("set ylabel \"Var1\"");

                if (!double.IsNaN(o.opt_ymin) && double.IsNaN(o.opt_ymax))
                {
                    tw.WriteLine("set yrange [" + o.opt_ymin + ":]");
                }
                else if (double.IsNaN(o.opt_ymin) && !double.IsNaN(o.opt_ymax))
                {
                    tw.WriteLine("set yrange [:" + o.opt_ymax + "]");
                }
                else if (!double.IsNaN(o.opt_ymin) && !double.IsNaN(o.opt_ymax))
                {
                    tw.WriteLine("set yrange [" + o.opt_ymin + ":" + o.opt_ymax + "]");
                }

                if (!(Program.options.freq == EFreq.Annual || Program.options.freq == EFreq.Undated))  //ttfreq
                {
                    tw.WriteLine("set xdata time");
                    tw.WriteLine(@"set timefmt ""%Y/%m/%d""");
                    tw.WriteLine(@"set format x ""%Y/%m""");
                }
                else
                {
                    if (numberOfObs > 70)
                    {
                        tw.WriteLine("set xtics 10");
                        tw.WriteLine("set mxtics 10");
                    }
                    else
                    {
                        tw.WriteLine("set xtics 5");
                        tw.WriteLine("set mxtics 5");
                    }
                }
                
                tw.WriteLine("set ticscale 1.4 0.7");
                //tw.WriteLine("set key outside top");
                //tw.WriteLine("set key 100, 100");
                tw.WriteLine("set border 3");
                tw.WriteLine("set xtics nomirror");
                tw.WriteLine("set ytics nomirror");
                tw.WriteLine("set xzeroaxis lt -1");
                tw.WriteLine("set yzeroaxis");
                //tw.WriteLine("set grid");
                //tw.WriteLine("set size 0.5,0.5");
                //tw.WriteLine("set size ratio 0.2"); does not work

                int mxtics = -12345;

                if (Program.options.freq == EFreq.Annual || Program.options.freq == EFreq.Undated)
                {
                }
                else
                {
                    List<int> subperiods = new List<int>();
                    int onlyYears = -12345;
                    if (Program.options.freq == EFreq.Quarterly)
                    {
                        if (labels1.Count <= 12)  //for quarterly, 12 corresponds to 3 years with 4 subpers each
                        {
                            subperiods.Add(1);  //q1
                            subperiods.Add(4);  //q2
                            subperiods.Add(7);  //q3
                            subperiods.Add(10);  //q4
                        }
                        else if (labels1.Count <= 24)
                        {
                            subperiods.Add(1);  //q1
                            subperiods.Add(7);  //q3
                            mxtics = 2;
                        }
                        else if (labels1.Count <= 48)
                        {
                            subperiods.Add(1);  //q1
                            mxtics = 4;
                        }
                        else if (labels1.Count <= 5 * 48)
                        {
                            onlyYears = 5;
                            subperiods.Add(1);  //q1
                            mxtics = 5;
                        }
                        else if (labels1.Count <= 10 * 48)
                        {
                            onlyYears = 10;
                            subperiods.Add(1);  //q1
                            mxtics = 10;
                        }
                        else
                        {
                            onlyYears = 20;
                            subperiods.Add(1);  //q1
                        }
                    }
                    else  //monthly
                    {
                        if (labels1.Count <= 12)  //for monthly, 12 corresponds to 1 year with 12 subpers
                        {
                            subperiods.Add(1);  //m1
                            subperiods.Add(2);  //m2
                            subperiods.Add(3);  //m3
                            subperiods.Add(4);  //m4
                            subperiods.Add(5);  //m5
                            subperiods.Add(6);  //m6
                            subperiods.Add(7);  //m7
                            subperiods.Add(8);  //m8
                            subperiods.Add(9);  //m9
                            subperiods.Add(10);  //m10
                            subperiods.Add(11);  //m11
                            subperiods.Add(12);  //m12
                        }
                        else if (labels1.Count <= 24)
                        {
                            subperiods.Add(1);  //m1
                            subperiods.Add(3);  //m3
                            subperiods.Add(5);  //m5
                            subperiods.Add(7);  //m7
                            subperiods.Add(9);  //m9
                            subperiods.Add(11);  //m11
                            mxtics = 2;
                        }
                        else if (labels1.Count <= 36)
                        {
                            subperiods.Add(1);  //m1
                            subperiods.Add(4);  //m4
                            subperiods.Add(7);  //m7
                            subperiods.Add(10);  //m10
                            mxtics = 3;
                        }
                        else if (labels1.Count <= 48)
                        {
                            subperiods.Add(1);  //m1
                            subperiods.Add(5);  //m5
                            subperiods.Add(9);  //m9
                            mxtics = 4;
                        }
                        else if (labels1.Count <= 72)
                        {
                            subperiods.Add(1);  //m1
                            subperiods.Add(7);  //m7
                            mxtics = 6;
                        }
                        else if (labels1.Count <= 144)
                        {
                            subperiods.Add(1);  //m1
                        }
                        else if (labels1.Count <= 15 * 48)
                        {
                            onlyYears = 5;
                            subperiods.Add(1);  //m1
                            mxtics = 5;
                        }
                        else if (labels1.Count <= 30 * 48)
                        {
                            onlyYears = 10;
                            subperiods.Add(1);  //m1
                            mxtics = 10;
                        }
                        else
                        {
                            onlyYears = 20;
                            subperiods.Add(1);  //m1
                        }
                    }

                    string s3 = null;
                    int c = -1;
                    for (int i = 0; i < labels1.Count; i++)
                    {
                        c++;
                        //int subper=labels2[i]
                        //if (labels1.Count > 20 && c %  != 0) continue;
                        string[] split = labels2[i].Split(new char[] { '/' });
                        if (onlyYears != -12345 && int.Parse(split[0]) % onlyYears != 0) continue;
                        if (subperiods.Contains(int.Parse(split[1])))
                        {
                            s3 += "\"" + labels1[i] + "\" \"" + labels2[i] + "\", ";
                        }
                    }
                    if (s3.EndsWith(", ")) s3 = s3.Substring(0, s3.Length - 2);
                    tw.WriteLine("set xtics (" + s3 + ")");
                }

                if (mxtics != -12345)
                {
                    //for quarterly and monthly
                    if (false)
                    {
                        //TODO: why does this not work??
                        tw.WriteLine("set mxtics " + mxtics);
                    }
                }

                if (histo)
                {
                    if (false)  //not really working (labels)
                    {
                        tw.WriteLine("set size ratio 0.5");
                        tw.WriteLine("set key outside top");
                    }

                    tw.WriteLine("set style fill solid 1.000000 border -1");
                    tw.WriteLine("set boxwidth 0.3");


                    //tw.WriteLine("set style line 1 lt 1 lw 3 lc rgb \"black\" ");
                    tw.WriteLine("set style line 1 lt 1 lw 4.0");
                    tw.WriteLine("set style line 2 lt 2 lw 2.0");
                    tw.WriteLine("set style line 3 lt 3 lw 2.0");

                }

                if (o.opt_plotcode != null)
                {
                    tw.WriteLine("");
                    tw.WriteLine(o.opt_plotcode);  //user code
                    tw.WriteLine("");
                }

                tw.Write("plot ");
                for (int i = 0; i < count; i++)
                {
                    string label = EncodeDanish(labelsNonBroken[i]);

                    if (!histo)
                    {
                        string lineType = "with lines ";
                        if (Program.options.plot_lines_points)
                        {
                            lineType = "with linespoints ";
                        }
                        tw.Write("\"" + file1 + "\" using 1:" + (i + 2) + " " + lineType + "lw 2.0 " + " title \"  " + label + "\" ");
                    }
                    else
                    {
                        if (i == 0) tw.Write("\"" + file1 + "\" using 1:" + (i + 2) + " with linespoints ls 1 " + " title \"  " + label + "\" ");  //obs
                        else if (i == 1) tw.Write("\"" + file1 + "\" using 1:" + (i + 2) + " with linespoints ls 2 " + " title \"  " + label + "\" ");  //fitted
                        else if (i == 2) tw.Write("\"" + file1 + "\" using 1:" + (i + 2) + " with linespoints ls 3 " + " title \"  " + label + "\" ");  //wanted
                        else if (i == 3) tw.Write("\"" + file1 + "\" using 1:" + (i + 2) + " with boxes lw 2.0 " + " title \"  " + label + "\" ");  //residual
                        else tw.Write("\"" + file1 + "\" using 1:" + (i + 2) + " with linespoints lw 2.0 " + " title \"  " + label + "\" ");
                    }



                    if (i < count - 1) tw.Write(",");
                }
                tw.WriteLine();
                tw.Flush();
                tw.Close();
            }

            string emfName = path + "\\" + file2;

            Process p = new Process();
            //p.MainWindowTitle = title;
            p.StartInfo.FileName = Application.StartupPath + "\\gnuplot\\wgnuplot.exe";
            //p.StartInfo.WindowStyle = ProcessWindowStyle.Hidden;
            //NOTE: quotes added because this path may contain blanks
            p.StartInfo.Arguments = Globals.QT + path + "\\" + file3 + Globals.QT;

            bool exited = false;
            try
            {
                p.Start();
                exited = p.WaitForExit(5000);  //5 sec, should always be able to do it in < 1 sec
                if (!exited)
                {
                    MessageBox.Show("*** ERROR: The gnuplot call did not respond within 5 seconds, so the " + G.NL + "gnuplot call was aborted.");
                    throw new GekkoException();
                }
            }
            catch (Exception e)
            {
                if (exited)
                {
                    MessageBox.Show("*** ERROR: There was a internal problem calling gnuplot." + G.NL + "ERROR: " + e.Message);
                }
                throw new GekkoException();
            }

            p.Close();
            //resets current dir to previous location
            Directory.SetCurrentDirectory(currentDir);

            if (o.opt_filename != null && o.opt_filename != "")
            {
                string fileNameWithPath = CreateFullPathAndFileName(o.opt_filename);
                WaitForFileCopy(emfName, fileNameWithPath);
                G.Writeln2("PLOT created file " + fileNameWithPath);
                return;
            }

            if (!o.guiGraphIsRefreshing)
            {
                PrtOptionsHelper po = new PrtOptionsHelper();
                po.isLevel = true;
                po.isLog = false;
                po.isDiff = false;
                po.isPch = false;
                po.isDlog = false;
                po.isMultiplier = false;

                GraphOptions graphOptions = new GraphOptions();
                graphOptions.counter = o.counter;
                graphOptions.localBanks = null;
                graphOptions.emfName = emfName;
                graphOptions.po = po;
                graphOptions.pph = null;
                graphOptions.precedents = null;
                graphOptions.tEnd = o.t2;
                graphOptions.tStart = o.t1;
                graphOptions.graphVars = null;
                graphOptions.graphVarsNames = labelsNonBroken;
                graphOptions.title = null;

                Thread thread = new Thread(new ParameterizedThreadStart(GraphThreadFunction));
                thread.SetApartmentState(ApartmentState.STA);
                thread.CurrentCulture = new System.Globalization.CultureInfo("en-US");  //gets . instead of , in doubles
                thread.Start(graphOptions);

                //Also see #9237532567
                //This stuff makes sure we wait for the window to open, before we move on with the code.
                for (int i = 0; i < 6000; i++)  //up to 60 s, then we move on anyway
                {
                    System.Threading.Thread.Sleep(10);  //0.01s
                    if (graphOptions.windowIsShown)
                    {
                        break;
                    }
                }
            }
            else
            {
                o.guiGraphRefreshingFilename = emfName;
            }
        }
        

        private static void CallGnuplotNew2(Table data, O.Prt o, int count, int maxLabelsLinesFound, List<string> labelsNonBroken)
        {
            //Måske en SYS gnuplot til at starte et vindue op.
            //See #23475432985 regarding options that default = no, and are activated with empty node like <boxstack/>

            //bool isInside = true;
            //bool test2 = false;
            bool firstXLabelFix = true;

            bool isInside = false;  //corresponds to at
            if (Program.options.freq == EFreq.Annual || Program.options.freq == EFreq.Undated)
            {
                //annual
                if (G.equal(Program.options.plot_xlabels_annual, "between")) isInside = true;
            }
            else
            {
                //nonannual
                if (G.equal(Program.options.plot_xlabels_nonannual, "between")) isInside = true;
            }

            //https://groups.google.com/forum/#!topic/comp.graphics.apps.gnuplot/csbgSFAbIv4

            double zoom = 1d;
            double fontfactor = 1d;
            
            //make as wpf window, detect dpi on screen at set size accordingly (http://stackoverflow.com/questions/5977445/how-to-get-windows-display-settings)

            int quarterFix = 0;
            if (Program.options.freq == EFreq.Quarterly || Program.options.freq == EFreq.Monthly) quarterFix = 1;

            if (count == 0)
            {
                G.Writeln2("*** ERROR: PLOT called with 0 variables");
                throw new GekkoException();
            }
            int numberOfObs = GekkoTime.Observations(o.t1, o.t2);
            int rr = Program.RandomInt();
            string file1 = "temp" + rr + ".dat";
            string file2 = "temp" + rr + ".emf";
            string file3 = "temp" + rr + ".gp";
            string heading = "";
            string pplotType = "emf";

            XmlDocument doc = new XmlDocument();

            //Gpt gpt = null;
            if (o.opt_using != null)
            {
                string fileName = o.opt_using;
                bool cancel = false;
                if (fileName == "*")
                {
                    SelectFile("gpt", ref fileName, ref cancel);
                }
                if (cancel) return;

                fileName = AddExtension(fileName, ".gpt");
                fileName = Program.CreateFullPathAndFileNameFromFolder(fileName, null);
                doc = new XmlDocument();
                string xmlText = GetTextFromFileWithWait(fileName);

                try
                {
                    doc.LoadXml(xmlText);
                }
                catch (Exception e)
                {
                    G.Writeln();
                    G.Writeln("*** ERROR: Plot schema file: '" + fileName + "'");
                    WriteXmlError(e, fileName);
                    throw new GekkoException();
                }
            }

            string currentDir = Directory.GetCurrentDirectory();  //remembered in order to switch back
            string path = System.Windows.Forms.Application.LocalUserAppDataPath + "\\gnuplot\\tempfiles";
            // Determine whether the directory exists.
            if (!Directory.Exists(path))
            {
                Directory.CreateDirectory(path);
            }
            Directory.SetCurrentDirectory(path); //so that gnuplot can access the files

            List<string> labels1 = new List<string>();
            List<string> labels2 = new List<string>();
            string fileGp = path + "\\" + file3;

            string fileData = path + "\\" + file1;
            double[] dataMax = new double[count]; for (int i = 0; i < count; i++) dataMax[i] = double.MinValue;
            double[] dataMin = new double[count]; for (int i = 0; i < count; i++) dataMin[i] = double.MaxValue;

            using (FileStream fs = WaitForFileStream(fileData, GekkoFileReadOrWrite.Write))
            using (StreamWriter tw = G.GekkoStreamWriter(fs))
            {
                for (int t = 0; t < numberOfObs; t++)
                {
                    string s = null;
                    for (int i = 0; i <= count; i++)
                    {
                        Cell c = data.Get(t + 1 + maxLabelsLinesFound, i + 1);
                        if (i == 0 && c.cellType == CellType.Text)
                        {
                            string d = c.CellText.TextData[0];
                            string dOrig = d;
                            d = GetDateStringSuitableForGnuplot(d);
                            labels1.Add(dOrig);
                            labels2.Add(d);
                            s += d + " ";
                            if (quarterFix == 1)
                            {
                                string[] split = d.Split(new char[] { '/' });
                                s += FromGnuplotDateToFloatingValue(split) + " ";  //why use gnuplot dates at all, we could have dates with q and m.
                            }
                        }
                        else if (i > 0 && c.cellType == CellType.Number)
                        {
                            double d = c.number;
                            s += d + " ";
                            if (!G.isNumericalError(d))
                            {
                                dataMin[i - 1] = Math.Min(dataMin[i - 1], d);
                                dataMax[i - 1] = Math.Max(dataMax[i - 1], d);
                            }
                        }
                        else
                        {
                            G.Writeln2("*** ERROR: PLOT error");
                            throw new GekkoException();
                        }
                    }
                    tw.WriteLine(s);
                }
            }
            
            XmlNodeList lines3 = doc.SelectNodes("gekkoplot/lines/line");
                    
            // ---------------------------------------------
            // --------- loading main section start
            // ---------------------------------------------

            string size2 = GetText(null, o.opt_size, null, doc.SelectSingleNode("gekkoplot/size"), null);
            string title = GetText(null, o.opt_title, null, doc.SelectSingleNode("gekkoplot/title"), null);
            string subtitle = GetText(null, o.opt_subtitle, null, doc.SelectSingleNode("gekkoplot/subtitle"), null);
            string font = GetText(null, o.opt_font, null, doc.SelectSingleNode("gekkoplot/font"), "Verdana");
            double fontsize = ParseIntoDouble(GetText(null, G.isNumericalError(o.opt_fontsize) ? null : o.opt_fontsize.ToString(), null, doc.SelectSingleNode("gekkoplot/fontsize"), "12"));
            string bold = GetText(null, o.opt_bold, null, doc.SelectSingleNode("gekkoplot/bold"), null);
            string italic = GetText(null, o.opt_italic, null, doc.SelectSingleNode("gekkoplot/italic"), null);
            string ticsInOut = GetText(null, o.opt_tics, null, doc.SelectSingleNode("gekkoplot/tics"), "out");
            string grid = GetText(null, o.opt_grid, null, doc.SelectSingleNode("gekkoplot/grid"), "yes");  //normally null or "" --> grid. Switch off with <grid>no</grid>                        
            string gridstyle = GetText(null, o.opt_gridstyle, null, doc.SelectSingleNode("gekkoplot/gridstyle"), "linecolor rgb \"#d3d3d3\" dashtype 3 linewidth 1.5");
            string key = GetText(null, o.opt_key, null, doc.SelectSingleNode("gekkoplot/key"), "out horiz bot center Left reverse height 1");  //height 1 givers nicer vertical spacing
            string palette = GetText(null, o.opt_palette, null, doc.SelectSingleNode("gekkoplot/palette"), "red,web-green,web-blue,orange,dark-blue,magenta,brown4,dark-violet,grey50,black");
            string stack = GetText(null, o.opt_stack, null, doc.SelectSingleNode("gekkoplot/stack"), "no");  //default: no, #23475432985    
            double boxwidth = ParseIntoDouble(GetText(null, G.isNumericalError(o.opt_boxwidth) ? null : o.opt_boxwidth.ToString(), null, doc.SelectSingleNode("gekkoplot/boxwidth"), "0.75"));
            string boxgap = GetText(null, G.isNumericalError(o.opt_boxgap) ? null : o.opt_boxgap.ToString(), null, doc.SelectSingleNode("gekkoplot/boxgap"), "2");
            string separate = GetText(null, o.opt_separate, null, doc.SelectSingleNode("gekkoplot/separate"), "no"); //default: no, #23475432985                        

            List<string> xlines = GetText(doc.SelectNodes("gekkoplot/xline"));
            if (!o.opt_xline.IsNull()) xlines.Add(o.opt_xline.ToString());
            List<string> xlinebefores = GetText(doc.SelectNodes("gekkoplot/xlinebefore"));
            if (!o.opt_xlinebefore.IsNull()) xlinebefores.Add(o.opt_xlinebefore.ToString());
            List<string> xlineafters = GetText(doc.SelectNodes("gekkoplot/xlineafter"));
            if (!o.opt_xlineafter.IsNull()) xlineafters.Add(o.opt_xlineafter.ToString());

            string ymirror = GetText(null, o.opt_ymirror, null, doc.SelectSingleNode("gekkoplot/ymirror"), "0"); //y2 mirror could be either no (0), tics (1), tics+labels (2), tics+labels+axislabel (3). With grid set, the mirror is not so important.
            string ytitle = GetText(null, o.opt_ytitle, null, doc.SelectSingleNode("gekkoplot/ytitle"), null);
            string y2title = GetText(null, o.opt_y2title, null, doc.SelectSingleNode("gekkoplot/y2title"), null);
            List<string> ylines = GetText(doc.SelectNodes("gekkoplot/yline"));
            if (!G.isNumericalError(o.opt_yline)) ylines.Add(o.opt_yline.ToString());
            List<string> y2lines = GetText(doc.SelectNodes("gekkoplot/y2line"));
            if (!G.isNumericalError(o.opt_y2line)) y2lines.Add(o.opt_y2line.ToString());

            string ymax = GetText(null, o.opt_ymax.ToString(), null, doc.SelectSingleNode("gekkoplot/ymax"), null);
            string ymaxsoft = GetText(null, o.opt_ymaxsoft.ToString(), null, doc.SelectSingleNode("gekkoplot/ymaxsoft"), null);
            string ymaxhard = GetText(null, o.opt_ymaxhard.ToString(), null, doc.SelectSingleNode("gekkoplot/ymaxhard"), null);
            string y2max = GetText(null, o.opt_y2max.ToString(), null, doc.SelectSingleNode("gekkoplot/y2max"), null);
            string y2maxsoft = GetText(null, o.opt_y2maxsoft.ToString(), null, doc.SelectSingleNode("gekkoplot/y2maxsoft"), null);
            string y2maxhard = GetText(null, o.opt_y2maxhard.ToString(), null, doc.SelectSingleNode("gekkoplot/y2maxhard"), null);

            string ymin = GetText(null, o.opt_ymin.ToString(), null, doc.SelectSingleNode("gekkoplot/ymin"), null);
            string yminsoft = GetText(null, o.opt_yminsoft.ToString(), null, doc.SelectSingleNode("gekkoplot/yminsoft"), null);
            string yminhard = GetText(null, o.opt_yminhard.ToString(), null, doc.SelectSingleNode("gekkoplot/yminhard"), null);
            string y2min = GetText(null, o.opt_y2min.ToString(), null, doc.SelectSingleNode("gekkoplot/y2min"), null);
            string y2minsoft = GetText(null, o.opt_y2minsoft.ToString(), null, doc.SelectSingleNode("gekkoplot/y2minsoft"), null);
            string y2minhard = GetText(null, o.opt_y2minhard.ToString(), null, doc.SelectSingleNode("gekkoplot/y2minhard"), null);

            string xzeroaxis = GetText(null, o.opt_xzeroaxis, null, doc.SelectSingleNode("gekkoplot/xzeroaxis"), "yes");
            string x2zeroaxis = GetText(null, o.opt_x2zeroaxis, null, doc.SelectSingleNode("gekkoplot/x2zeroaxis"), "no"); //default: no, #23475432985 

            //the options in <lines> may override this.
            XmlNode linetypeMain = doc.SelectSingleNode("gekkoplot/type");
            XmlNode dashtypeMain = doc.SelectSingleNode("gekkoplot/dashtype");
            XmlNode linewidthMain = doc.SelectSingleNode("gekkoplot/linewidth");
            XmlNode linecolorMain = doc.SelectSingleNode("gekkoplot/linecolor");
            XmlNode pointtypeMain = doc.SelectSingleNode("gekkoplot/pointtype");
            XmlNode pointsizeMain = doc.SelectSingleNode("gekkoplot/pointsize");
            XmlNode fillstyleMain = doc.SelectSingleNode("gekkoplot/fillstyle");

            List<string> labels = GetText(doc.SelectNodes("gekkoplot/label"));
            List<string> arrows = GetText(doc.SelectNodes("gekkoplot/arrows"));

            // ---------------------------------------------
            // --------- loading main section end
            // ---------------------------------------------

            bool stacked = false;
            if (NotNullAndNotNo(stack)) stacked = true; //#23475432985

            List<string> palette2 = null;
            if (palette != null) palette2 = new List<string>(palette.Split(','));
            if (palette2 == null || palette2.Count == 0)
            {
                //this should not be possible, but in any case...
                G.Writeln2("*** ERROR: PLOT gpt palette is empty");
                throw new GekkoException();
            }

            if (o.opt_filename != null)
            {
                pplotType = Path.GetExtension(o.opt_filename);
                if (pplotType.StartsWith(".")) pplotType = pplotType.Substring(1);
                if (pplotType == "")
                {
                    o.opt_filename = AddExtension(o.opt_filename, ".emf");
                    pplotType = "emf";
                }
                if (pplotType != "emf" && pplotType != "png" && pplotType != "svg")
                {
                    G.Writeln2("*** ERROR: In PLOT, expected file type is emf, png or svg");
                    throw new GekkoException();
                }
            }

            
            bool isSeparated = NotNullAndNotNo(separate);  //#23475432985

            List<string> linetypes = new List<string>();
            List<string> dashtypes = new List<string>();
            List<double> linewidths = new List<double>();
            List<string> linecolors = new List<string>();
            List<string> pointtypes = new List<string>();
            List<double> pointsizes = new List<double>();
            List<string> fillstyles = new List<string>();
            List<string> y2s = new List<string>();
            foreach (O.Prt.Element pe in o.prtElements)  //varI 0-based
            {
                foreach (O.Prt.SubElement subPe in pe.subElements)
                {
                    linetypes.Add(pe.linetype);
                    dashtypes.Add(pe.dashtype);
                    linewidths.Add(pe.linewidth);
                    linecolors.Add(pe.linecolor);
                    pointtypes.Add(pe.pointtype);
                    pointsizes.Add(pe.pointsize);
                    fillstyles.Add(pe.fillstyle);
                    y2s.Add(pe.y2);
                }
            }

            double linewidthCorrection = 1d;
            double pointsizeCorrection = 1d;
            if (G.equal(pplotType, "svg") || G.equal(pplotType, "png"))
            {
                linewidthCorrection = 2d / 3d;
                pointsizeCorrection = 0.8d / 0.5d;
            }


            List<int> boxesY = new List<int>();
            List<int> boxesY2 = new List<int>();
            List<int> areasY = new List<int>();
            List<int> areasY2 = new List<int>();

            int numberOfY2s = 0; //not used in first pass, but gathered
            double histoGap = double.NaN;  //not used in first pass
            double d_width = double.NaN;  //not used in first pass
            double d_width2 = double.NaN;  //not used in first pass
            double d_width3 = double.NaN;  //not used in first pass
            double left = double.NaN;  //not used in first pass
            double[] minMax = new double[6]; minMax[0] = double.MaxValue; minMax[1] = double.MinValue; minMax[2] = double.MaxValue; minMax[3] = double.MinValue; minMax[4] = double.MaxValue; minMax[5] = double.MinValue;

            // ---------------------------------------
            // ---------------------------------------
            //          FIRST PASS
            //       first pass just counts
            //       boxes, filledcurves, and
            //       a few other things.
            // ---------------------------------------
            // ---------------------------------------
            
            string discard = PlotHandleLines(true, ref numberOfY2s, minMax, dataMin, dataMax, o, count, labelsNonBroken, quarterFix, file1, lines3, boxesY, boxesY2, areasY, areasY2, linetypeMain, dashtypeMain, linewidthMain, linecolorMain, pointtypeMain, pointsizeMain, fillstyleMain, stacked, palette2, isSeparated, d_width, d_width2, d_width3, left, linetypes, dashtypes, linewidths, linecolors, pointtypes, pointsizes, fillstyles, y2s, linewidthCorrection, pointsizeCorrection, isInside);
            
            StringBuilder txt = new StringBuilder();
                        
            txt.AppendLine("set size " + zoom + "," + zoom + "");
            txt.AppendLine("set encoding iso_8859_1");
            txt.AppendLine("set format y " + Globals.QT + "%g" + Globals.QT);  //uses for instance 1.65e+006, not trying to put uppercase exponent which fails in emf terminal
            txt.AppendLine("set format y2 " + Globals.QT + "%g" + Globals.QT);  //uses for instance 1.65e+006, not trying to put uppercase exponent which fails in emf terminal
            txt.AppendLine("set datafile missing \"NaN\"");

            int ii = 0;
            foreach (string s in key.ToLower().Split(' '))
            {
                if (s.StartsWith("out")) ii++;
                if (s.StartsWith("bot")) ii++;
            }            

            string enhanced = null;
            if (G.equal(pplotType, "emf"))
            {
                enhanced = " enhanced";
                fontsize = 0.95 * fontsize;
            }
            else
            {
                fontsize = 0.75 * fontsize;
            }
                        
            txt.AppendLine("set terminal " + pplotType + enhanced + " font '" + font + "," + (zoom * fontsize) + "'"); ;
            txt.AppendLine("set output \"" + file2 + "\"");
            txt.AppendLine("set key " + key);            

            if (G.equal(Program.options.plot_decimalseparator, "comma"))
            {
                txt.AppendLine("set decimalsign ','");
            }
            
            if (G.equal(pplotType, "emf"))
            {
                fontfactor = 1.4d / 1.2d;
            }
            else if (G.equal(pplotType, "svg"))
            {
                fontfactor = 1.4d / 1.2d;
            }
            else if (G.equal(pplotType, "png"))
            {
                fontfactor = 1.0d / 1.2d;
            }

            double siz1 = (1.5d * zoom * fontsize * fontfactor);
            double siz2 = (zoom * fontsize * fontfactor);

            string bold2 = "";
            if (bold != null) bold2 = bold.Replace(" ", "").ToLower();
            string[] bold3 = bold2.Split(',');
            foreach (string s in bold3)
            {
                if (s.Trim() == "") continue;  //can contain empty entry
                if (s != "title" && s != "ytitle" && s != "xtics" && s != "ytics" && s != "key")
                {
                    G.Writeln2("*** ERROR: <bold = '...'> must be title, ytitle, xtics, ytics or key");
                    throw new GekkoException();
                }
            }
            string title_bold = null; if (bold3.Contains("title")) title_bold = " Bold";
            string ytitle_bold = null; if (bold3.Contains("ytitle")) ytitle_bold = " Bold";            
            string xtics_bold = null; if (bold3.Contains("xtics")) xtics_bold = " Bold";
            string ytics_bold = null; if (bold3.Contains("ytics")) ytics_bold = " Bold";
            string key_bold = null; if (bold3.Contains("key")) key_bold = " Bold";

            string italic2 = "";
            if (italic != null) italic2 = italic.Replace(" ", "").ToLower();
            string[] italic3 = italic2.Split(',');
            string title_italic = null; if (italic3.Contains("title")) title_italic = " Italic";
            string ytitle_italic = null; if (italic3.Contains("ytitle")) ytitle_italic = " Italic";
            string xtics_italic = null; if (italic3.Contains("xtics")) xtics_italic = " Italic";
            string ytics_italic = null; if (italic3.Contains("ytics")) ytics_italic = " Italic";
            string key_italic = null; if (italic3.Contains("key")) key_italic = " Italic";
            foreach (string s in italic3)
            {
                if (s.Trim() == "") continue;  //can contain empty entry
                if (s != "title" && s != "ytitle" && s != "xtics" && s != "ytics" && s != "key")
                {
                    G.Writeln2("*** ERROR: <italic = '...'> must be title, ytitle, xtics, ytics or key");
                    throw new GekkoException();
                }
            }

            txt.AppendLine("set title font " + "'" + font + title_bold + title_italic + "," + siz1 + "'");
            txt.AppendLine("set ylabel font " + "'" + font + ytitle_bold + ytitle_italic + "," + siz2 + "'");
            txt.AppendLine("set y2label font " + "'" + font + ytitle_bold + ytitle_italic + "," + siz2 + "'");
            txt.AppendLine("set xtics font " + "'" + font + xtics_bold + xtics_italic + "," + siz2 + "'");
            txt.AppendLine("set ytics font " + "'" + font + ytics_bold + ytics_italic + "," + siz2 + "'");
            if (numberOfY2s > 0 || ymirror == "2" || ymirror == "3") txt.AppendLine("set y2tics font " + "'" + font + ytics_bold + ytics_italic + "," + siz2 + "'");
            txt.AppendLine("set key font " + "'" + font + key_bold + key_italic + "," + siz2 + "'");

            string set_yrange = null;
            string set_y2range = null;
            if (isSeparated)
            {
                double alpha1 = 0.05d;
                double alpha2 = 0.05;
                double beta = 0.30d;
                //linesMin=4, linesmMax=5
                //boxesMin=0, boxesMax=1
                set_yrange = (minMax[4] - (alpha1 + alpha2 + beta) * (minMax[5] - minMax[4])) + ":" + minMax[5];
                set_y2range = (minMax[0] - alpha2 / beta * (minMax[1] - minMax[0])) + ":" + (minMax[1] + (1 + alpha1) / beta * (minMax[1] - minMax[0]));
            }
            else
            {
                set_yrange = GnuplotYrange(ymin, yminsoft, yminhard, ymax, ymaxsoft, ymaxhard);
                set_y2range = GnuplotYrange(y2min, y2minsoft, y2minhard, y2max, y2maxsoft, y2maxhard);
            }

            if (set_yrange.Trim() != ":") txt.AppendLine("set yrange [" + set_yrange + "]");
            if (set_y2range.Trim() != ":") txt.AppendLine("set y2range [" + set_y2range + "]");

            if (!(Program.options.freq == EFreq.Annual || Program.options.freq == EFreq.Undated))  //ttfreq
            {
                if (quarterFix == 0)
                {
                    txt.AppendLine("set xdata time");
                    txt.AppendLine(@"set timefmt ""%Y/%m/%d""");
                    txt.AppendLine(@"set format x ""%Y/%m""");
                }
            }
            else
            {
                //annual or undated
                if (numberOfObs > 140)
                {
                    txt.AppendLine("set xtics 20");
                    txt.AppendLine("set mxtics 20");
                }
                else if (numberOfObs > 70)
                {
                    txt.AppendLine("set xtics 10");
                    txt.AppendLine("set mxtics 10");
                }
                else
                {
                    txt.AppendLine("set xtics 5");
                    txt.AppendLine("set mxtics 5");
                }
            }

            //txt.AppendLine("set xtic scale 1.7, 0.85");
            txt.AppendLine("set xtic scale 2, 0.7");
            txt.AppendLine("set xtics nomirror " + ticsInOut + "");

            if (NotNullAndNotNo(xzeroaxis)) txt.AppendLine("set xzeroaxis lt -1"); //draws x axis. May get ugly if residuals are present.

            bool setTitlePlaceholder = false;
            if (numberOfY2s == 0 && !isSeparated)
            {
                //the y2 axis is just mirrored
                if (ymirror == "0")  //nothing
                {
                    txt.AppendLine("set ytics nomirror " + ticsInOut);
                    txt.AppendLine("set border 3");                    
                    if (!NullOrEmpty(ytitle)) setTitlePlaceholder = SetYAxisText(ytitle, txt, "'" + font + ytitle_bold + ytitle_italic + "," + siz2 + "'", true);
                   
                }
                else if (ymirror == "1")  //y2 axis
                {
                    txt.AppendLine("set ytics " + ticsInOut);
                    txt.AppendLine("set border 11");                    
                    if (!NullOrEmpty(ytitle)) setTitlePlaceholder = SetYAxisText(ytitle, txt, "'" + font + ytitle_bold + ytitle_italic + "," + siz2 + "'", true);
                }
                else if (ymirror == "2")  //y2 axis and y2 tics
                {
                    txt.AppendLine("set ytics " + ticsInOut);
                    txt.AppendLine("set y2tics " + ticsInOut);
                    txt.AppendLine("set border 11");                    
                    if (!NullOrEmpty(ytitle)) setTitlePlaceholder = SetYAxisText(ytitle, txt, "'" + font + ytitle_bold + ytitle_italic + "," + siz2 + "'", true);                                    
                }
                else if (ymirror == "3")
                {
                    txt.AppendLine("set ytics " + ticsInOut);  //y2 axis and y2 tics and y2 label
                    txt.AppendLine("set y2tics " + ticsInOut);
                    txt.AppendLine("set border 11");                    
                    if (!NullOrEmpty(ytitle)) setTitlePlaceholder = SetYAxisText(ytitle, txt, "'" + font + ytitle_bold + ytitle_italic + "," + siz2 + "'", true);                    
                    if (!NullOrEmpty(ytitle)) setTitlePlaceholder = SetYAxisText(ytitle, txt, "'" + font + ytitle_bold + ytitle_italic + "," + siz2 + "'", false);
                }
            }
            else
            {
                //there is a series being shown at the y2 axis
                txt.AppendLine("set ytics nomirror " + ticsInOut);
                txt.AppendLine("set y2tics " + ticsInOut);
                txt.AppendLine("set border 11");                
                if (!NullOrEmpty(ytitle)) setTitlePlaceholder = SetYAxisText(ytitle, txt, "'" + font + ytitle_bold + ytitle_italic + "," + siz2 + "'", true);                
                if (!NullOrEmpty(y2title)) setTitlePlaceholder = SetYAxisText(y2title, txt, "'" + font + ytitle_bold + ytitle_italic + "," + siz2 + "'", false);
                if (NotNullAndNotNo(x2zeroaxis) || isSeparated) txt.AppendLine("set x2zeroaxis lt -1");  //draws x axis for y2=0, #23475432985 
            }

            //must be after labels
            string subtitle2 = null;
            if (!NullOrEmpty(subtitle)) subtitle2 = subtitle;
            if (!NullOrEmpty(o.opt_subtitle)) subtitle2 = o.opt_subtitle;
            if (!NullOrEmpty(subtitle2)) subtitle2 = "\\n{/*0.80 " + subtitle2 + "}";
            string title2 = null;
            if (!NullOrEmpty(title)) title2 = title;
            if (!NullOrEmpty(o.opt_title)) title2 = o.opt_title;
            if (!NullOrEmpty(title2))
            {
                txt.AppendLine("set title " + Globals.QT + EncodeDanish(GnuplotText(title2 + subtitle2)) + Globals.QT);
            }
            else
            {
                if (setTitlePlaceholder) txt.AppendLine("set title " + Globals.QT + " " + Globals.QT);
            }            

            foreach (string s in xlines)
            {
                GekkoTime gt = G.FromStringToDate(s);
                double d = G.FromDateToFloating(gt) + GetXAdjustmentForInsideTics(isInside);                
                txt.AppendLine("set arrow from " + d + ", graph 0 to " + d + ", graph 1 nohead");
            }

            foreach (string s in xlinebefores)
            {
                GekkoTime gt = G.FromStringToDate(s);
                double d = (G.FromDateToFloating(gt) + G.FromDateToFloating(gt.Add(-1))) / 2d + GetXAdjustmentForInsideTics(isInside);
                txt.AppendLine("set arrow from " + d + ", graph 0 to " + d + ", graph 1 nohead");
            }

            foreach (string s in xlineafters)
            {
                GekkoTime gt = G.FromStringToDate(s);
                double d = (G.FromDateToFloating(gt) + G.FromDateToFloating(gt.Add(1))) / 2d + +GetXAdjustmentForInsideTics(isInside);
                txt.AppendLine("set arrow from " + d + ", graph 0 to " + d + ", graph 1 nohead");
            }

            foreach (string s in ylines)
            {
                double d = ParseIntoDouble(s);
                if (!G.isNumericalError(d)) txt.AppendLine("set arrow from graph 0, first " + d + " to graph 1, first " + d + " nohead");
            }

            foreach (string s in y2lines)
            {
                if (numberOfY2s > 0)  //theses lines are ignored if there is no y2 axis shown
                {
                    double d = ParseIntoDouble(s);
                    if (!G.isNumericalError(d)) txt.AppendLine("set arrow from graph 0, second " + d + " to graph 1, second " + d + " nohead");
                }
            }

            if (G.equal(grid, "yes"))  //it can be an empty <grid/>
            {
                //txt.AppendLine("set style line 102 lc rgb '#d3d3d3' dt 3 lw 1.5");  //line width looks ok in Gekko window, with lw 1 it looks bad there.
                txt.AppendLine("set style line 102 " + gridstyle);  //lt 0 or dt 3 gives ugly lines when viewed in Gekko
                txt.AppendLine("set grid back ls 102");                
            }
            else if (G.equal(grid, "yline"))
            {
                txt.AppendLine("set style line 102 " + gridstyle);  //lt 0 or dt 3 gives ugly lines when viewed in Gekko
                txt.AppendLine("set grid ytics back ls 102");                
            }
            else if (G.equal(grid, "xline")) 
            {
                txt.AppendLine("set style line 102 " + gridstyle);  //lt 0 or dt 3 gives ugly lines when viewed in Gekko                
                txt.AppendLine("set grid xtics back ls 102");
            }

            if (isInside)
            {

                //TODO: if there are too many minor tics, turn them off
                //TODO: if years get too cramped, show every second (even)
                //TODO: if years get too cramped, show only 15, 16, 17, not 2015, 2016, 2017
                //TODO: if years are still very cramped, switch to isInside = false!

                //??? what about mixed freqs?? They can either be (a) only annual at-tics, and q and m are without tics
                //                                             or (b) between-tics, showing highest freq if not too many minor, else next-highest.
                //    with mixed freqs we treat is as highest frequency plot, and sneak in the lower freqs.
                //OPTION plot xlabels nonannual = at | between | auto ;  //auto will start with between and then jump to at
                //OPTION plot xlabels annual    = at | between | auto ;  //auto will start with between and then jump to at
                //OPTION plot xlabels between truncate = digits | skip | both | auto ; 

                double extra = 0;

                int t1 = o.t1.super;
                int t2 = o.t2.super;
                //txt.AppendLine("set xtics " + (t1 - 1) + ",1," + (t2 + 0) + "");
                int sub = 1;
                if (Program.options.freq == EFreq.Quarterly)
                {
                    sub = 4;
                    extra = (double)o.t2.sub / (double)sub;
                }
                else if (Program.options.freq == EFreq.Monthly)
                {
                    sub = 12;
                    extra = (double)o.t2.sub / (double)sub;
                }
                else
                {
                    sub = 1;
                    extra = 1;
                }

                bool deduct = false;
                if (extra <= 0.40) deduct = true;            

                if (Program.options.plot_xlabels_digits != 4 && Program.options.plot_xlabels_digits != 2)
                {
                    G.Writeln2("*** ERROR: 'OPTION plot xlabels digits' should be either 4 or 2");
                    throw new GekkoException();
                }

                string ss = null;
                for (int t = t1; t <= t2; t++)
                {
                    int years = t2 - t1 + 1;
                    bool twoDigits = false;
                    if (Program.options.plot_xlabels_digits == 2) twoDigits = true;

                    int skip = 1;
                    if (twoDigits)
                    {
                        if (years > 2 * 48) skip = 10;
                        else if (years > 48) skip = 5;
                        else if (years > 24) skip = 2;                        
                    }
                    else
                    {
                        //4 digits
                        if (years > 2 * 24) skip = 10;
                        else if (years > 24) skip = 5;
                        else if (years > 12) skip = 2;                        
                    }

                    string tx = t.ToString();
                    if (twoDigits) tx = (t % 100).ToString().PadLeft(2, '0');

                    if (skip > 1 && t % skip != 0) tx = null;  //all uneven are zapped

                    if (deduct && t == t2) tx = null;

                    string tlabel = "\"" + tx + "\"";
                    
                    ss += tlabel + " " + t + " " + "0, ";  //0 is major tic
                    if ((Program.options.freq == EFreq.Monthly && years <= 25) || (Program.options.freq == EFreq.Quarterly && years <= 75))
                    {
                        for (int tt = 1; tt < sub; tt++)  //is skipped if sub = 1
                        {
                            double d = (double)tt / (double)sub;
                            ss += (t + d) + " " + "1, ";  //1 is minor tic
                        }
                    }
                }

                //txt.AppendLine("set mxtics " + sub);

                txt.AppendLine("set xtics (" + ss + ")");
                txt.AppendLine("set xtics offset first 0.5, first 0");  //moves xtic labels a half year to the right, but not the tic itself
                if (firstXLabelFix)
                {
                    if ((o.t1.freq == EFreq.Monthly && o.t1.sub <= 1) || (o.t1.freq == EFreq.Quarterly && o.t1.sub <= 1))  //these could perhaps be <=4 and <=2 respectively. Often the plot starts in first subperiod anyway.
                    {
                        //only show whole first year if monthly and m1-m4 or quarterly and q1-q2
                        double tStart = (double)t1 - 0.000000001d;                      //deducts a small number to activate the first x-axis label
                        txt.AppendLine("set xrange [" + tStart.ToString() + ":]");      //see above
                    }                    
                }
            }
            else
            {
                int mxtics = -12345;
                string ticsTxt = null;
                mxtics = HandleXTics(quarterFix, labels1, labels2, ref ticsTxt, mxtics);
                if (ticsTxt != null) txt.AppendLine(ticsTxt);
            }

            if (o.opt_plotcode != null)
            {
                txt.AppendLine("");
                txt.AppendLine(o.opt_plotcode);  //user code
                txt.AppendLine("");
            }

            //string plotline = null;

            double dx = 1d;
            if (Program.options.freq == EFreq.Quarterly)
            {
                dx = 1d / 4d;
            }
            else if (Program.options.freq == EFreq.Monthly)
            {
                dx = 1d / 12d;
            }

            histoGap = (int)ParseIntoDouble(boxgap);
            if (boxesY.Count + boxesY2.Count == 1) histoGap = 0;
            d_width = dx / (double)(boxesY.Count + boxesY2.Count + histoGap);
            d_width2 = boxwidth * d_width;
            d_width3 = boxwidth * dx;
            left = d_width * (double)(boxesY.Count + boxesY2.Count - 1) / 2d;

            if (boxesY.Count + boxesY2.Count + areasY.Count + areasY2.Count > 0)
            {
                txt.AppendLine("f(x) = (sgn(x+1.2345e-30) + 1)/2");  //1 if x > 0, else 0. 1.2345e-30 added to avoid 0 becoming 0.5
            }
            
            //int boxesCounter = 0;    
            //boxesY = new List<int>();
            //boxesY2 = new List<int>();
            //areasY = new List<int>();
            //areasY2 = new List<int>();
            //numberOfY2s = 0;
            // ---------------------------------------
            // ---------------------------------------
            //          SECOND PASS
            // ---------------------------------------
            // ---------------------------------------
            string plotline = PlotHandleLines(false, ref numberOfY2s, minMax, dataMin, dataMax, o, count, labelsNonBroken, quarterFix, file1, lines3, boxesY, boxesY2, areasY, areasY2, linetypeMain, dashtypeMain, linewidthMain, linecolorMain, pointtypeMain, pointsizeMain, fillstyleMain, stacked, palette2, isSeparated, d_width, d_width2, d_width3, left, linetypes, dashtypes, linewidths, linecolors, pointtypes, pointsizes, fillstyles, y2s, linewidthCorrection, pointsizeCorrection, isInside);

            txt.AppendLine(plotline);


            using (FileStream fs = WaitForFileStream(fileGp, GekkoFileReadOrWrite.Write))
            using (StreamWriter tw = G.GekkoStreamWriter(fs))
            {
                tw.WriteLine(txt);
                tw.Flush(); //probably not necessary
                tw.Close(); //probably not necessary
            }


            if (G.equal(o.opt_dump, "yes"))
            {
                try
                {
                    File.Copy(fileGp, Program.options.folder_working + "\\" + "gekkoplot.gp", true);
                    File.Copy(fileData, Program.options.folder_working + "\\" + "gekkoplot.dat", true);
                    string text = null;
                    text = File.ReadAllText(Program.options.folder_working + "\\" + "gekkoplot.gp");
                    text = text.Replace("temp" + rr, "gekkoplot");
                    File.WriteAllText(Program.options.folder_working + "\\" + "gekkoplot.gp", text);
                    text = File.ReadAllText(Program.options.folder_working + "\\" + "gekkoplot.dat");
                    text = text.Replace("temp" + rr, "gekkoplot");
                    File.WriteAllText(Program.options.folder_working + "\\" + "gekkoplot.dat", text);
                    G.Writeln2("Dumped gnuplot files gekkoplot.gp (script) and gekkoplot.dat (data) in the working folder");
                    
                }
                catch
                {
                    G.Writeln2("+++ WARNING: PLOT<dump> failed: are gekkoplot.gp or gekkoplot.dat blocked?");
                }
            }

            string emfName = path + "\\" + file2;

            Process p = new Process();
            p.StartInfo.FileName = Application.StartupPath + "\\gnuplot\\wgnuplot51.exe";
            //NOTE: quotes added because this path may contain blanks
            p.StartInfo.Arguments = Globals.QT + path + "\\" + file3 + Globals.QT;
            bool msg = false;
            bool exited = false;
            try
            {
                p.Start();
                exited = p.WaitForExit(5000);  //5 sec, should always be able to do it in < 1 sec
                if (!exited)
                {
                    MessageBox.Show("*** ERROR: The gnuplot call did not respond within 5 seconds, so the " + G.NL + "gnuplot call was aborted.");
                    msg = true;
                    throw new GekkoException();
                }
                else if (p.ExitCode != 0)
                {
                    MessageBox.Show("*** ERROR: The generated gnuplot script file had an unexpected error. If you use PLOT<dump>, Gekko will dump \nthe files gekkoplot.gp and gekkoplot.dat in the working folder. \nThese files can be tried out in gnuplot 5.1, to locate the error \n(by means of 'load gekkoplot.gp' in gnuplot).");
                    msg = true;
                    throw new GekkoException();
                }
            }
            catch (Exception e)
            {
                if (exited && !msg)
                {
                    MessageBox.Show("*** ERROR: There was a internal problem calling gnuplot." + G.NL + "ERROR: " + e.Message);
                }
                throw;
            }

            p.Close();
            //resets current dir to previous location
            Directory.SetCurrentDirectory(currentDir);

            if (o.opt_filename != null && o.opt_filename != "")
            {
                string fileNameWithPath = CreateFullPathAndFileName(o.opt_filename);
                WaitForFileCopy(emfName, fileNameWithPath);
                G.Writeln2("PLOT created file " + fileNameWithPath);
                return;
            }

            if (!o.guiGraphIsRefreshing)
            {
                PrtOptionsHelper po = new PrtOptionsHelper();
                po.isLevel = true;
                po.isLog = false;
                po.isDiff = false;
                po.isPch = false;
                po.isDlog = false;
                po.isMultiplier = false;

                GraphOptions graphOptions = new GraphOptions();
                graphOptions.counter = o.counter;
                graphOptions.localBanks = null;
                graphOptions.emfName = emfName;
                graphOptions.po = po;
                graphOptions.pph = null;
                graphOptions.precedents = null;
                graphOptions.tEnd = o.t2;
                graphOptions.tStart = o.t1;
                graphOptions.graphVars = null;
                graphOptions.graphVarsNames = labelsNonBroken;
                graphOptions.title = null;

                Thread thread = new Thread(new ParameterizedThreadStart(GraphThreadFunction));
                thread.SetApartmentState(ApartmentState.STA);
                thread.CurrentCulture = new System.Globalization.CultureInfo("en-US");  //gets . instead of , in doubles
                thread.Start(graphOptions);

                //Also see #9237532567
                //This stuff makes sure we wait for the window to open, before we move on with the code.
                for (int i = 0; i < 6000; i++)  //up to 60 s, then we move on anyway
                {
                    System.Threading.Thread.Sleep(10);  //0.01s
                    if (graphOptions.windowIsShown)
                    {
                        break;
                    }
                }
            }
            else
            {
                o.guiGraphRefreshingFilename = emfName;
            }
        }

        private static bool SetYAxisText(string ytitle, StringBuilder txt, string font, bool isLeft)
        {
            bool setTitlePlaceholder;
            setTitlePlaceholder = true; //to make space
            if (isLeft) txt.AppendLine("set label \"" + GnuplotText(ytitle) + "\" at graph 0, graph 1 offset -3,2.2 left font " + font);
            else txt.AppendLine("set label \"" + GnuplotText(ytitle) + "\" at graph 1, graph 1 offset 3,2.2 right font " + font);
            return setTitlePlaceholder;
        }

        private static string PlotHandleLines(bool firstPass, ref int numberOfY2s, double[] minMax, double[] dataMin, double[] dataMax, O.Prt o, int count, List<string> labelsNonBroken, int quarterFix, string file1, XmlNodeList lines3, List<int> boxesY, List<int> boxesY2, List<int> areasY, List<int> areasY2, XmlNode linetypeMain, XmlNode dashtypeMain, XmlNode linewidthMain, XmlNode linecolorMain, XmlNode pointtypeMain, XmlNode pointsizeMain, XmlNode fillstyleMain, bool stacked, List<string> palette2, bool isSeparated, double d_width, double d_width2, double d_width3, double left, List<string> linetypes, List<string> dashtypes, List<double> linewidths, List<string> linecolors, List<string> pointtypes, List<double> pointsizes, List<string> fillstyles, List<string> y2s, double linewidthCorrection, double pointsizeCorrection, bool isInside)
        {
            string plotline = "plot ";

            int boxesYCounter = 0;
            int boxesY2Counter = 0;
            int areasYCounter = 0;
            int areasY2Counter = 0;
            for (int i = 0; i < count; i++)
            {
                XmlNode line3 = lines3[i];

                //defaults
                string dlinetype = "lines";
                if (Program.options.plot_lines_points) dlinetype = "linespoints";
                string ddashtype = "1";
                string dlinewidth = "3";
                string dlinecolor = palette2[i % palette2.Count].Trim();
                string dpointtype = "7";
                string dpointsize = "0.5";
                string dfillstyle = "solid";
                string dy2_ = "no";

                string linetype = null;
                string dashtype = null;
                string linewidth = null;
                string linecolor = null;
                string pointtype = null;
                string pointsize = null;
                string fillstyle = null;
                string label = null;
                string y2 = null;

                bool isExplicit = false;
                string labelCleaned = labelsNonBroken[i];
                if (labelCleaned.StartsWith(Globals.labelCheatString))
                {
                    isExplicit = true;
                    labelCleaned = labelCleaned.Substring(Globals.labelCheatString.Length);
                }

                // ---------------------------------------------
                // --------- loading lines section start
                // ---------------------------------------------

                linetype = GetText(linetypes[i], o.opt_linetype, line3 == null ? null : line3.SelectSingleNode("type"), linetypeMain, dlinetype);
                dashtype = GetText(dashtypes[i], o.opt_dashtype, line3 == null ? null : line3.SelectSingleNode("dashtype"), dashtypeMain, ddashtype);
                linewidth = GetText(G.isNumericalError(linewidths[i]) ? null : linewidths[i].ToString(), G.isNumericalError(o.opt_linewidth) ? null : o.opt_linewidth.ToString(), line3 == null ? null : line3.SelectSingleNode("linewidth"), linewidthMain, dlinewidth);
                linecolor = GetText(linecolors[i], o.opt_linecolor, line3 == null ? null : line3.SelectSingleNode("linecolor"), linecolorMain, dlinecolor);
                pointtype = GetText(pointtypes[i], o.opt_pointtype, line3 == null ? null : line3.SelectSingleNode("pointtype"), pointtypeMain, dpointtype);
                pointsize = GetText(G.isNumericalError(pointsizes[i]) ? null : pointsizes[i].ToString(), G.isNumericalError(o.opt_pointsize) ? null : o.opt_pointsize.ToString(), line3 == null ? null : line3.SelectSingleNode("pointsize"), pointsizeMain, dpointsize);
                fillstyle = GetText(fillstyles[i], o.opt_fillstyle, line3 == null ? null : line3.SelectSingleNode("fillstyle"), fillstyleMain, dfillstyle);
                y2 = GetText(y2s[i], null, line3 == null ? null : line3.SelectSingleNode("y2"), null, "no"); //default: no, #23475432985
                label = HandleLabel(line3, isExplicit, labelCleaned);

                if (G.equal(linetype, "boxes"))
                {
                    if (isSeparated) y2 = "yes";  //set y for all lines, and y2 for all boxes --> this overrides other settings
                }
                else
                {
                    fillstyle = null;  //fillstyle will fail if combined with other line types.
                    if (isSeparated) y2 = "no";  //set y for all lines, and y2 for all boxes --> this overrides other settings
                }



                // ---------------------------------------------
                // --------- loading lines section end
                // ---------------------------------------------


                if (G.equal(linetype, "boxes") && fillstyle.Contains("solid"))
                {
                    linewidth = "1";  //otherwise the borders of these get blurred
                }

                label = GnuplotText(label);

                string s = null;
                if (!NullOrEmpty(linetype))
                {
                    if (G.equal(linetype, "filledcurve") || G.equal(linetype, "filledcurves"))
                    {
                        s += " with " + linetype + " y1=0";  //so the area is towards the x-axis
                    }
                    else
                    {
                        s += " with " + linetype;
                    }
                }
                if (NotNullAndNotNo(y2))
                {
                    if (firstPass) numberOfY2s++;
                    s += " axes x1y2";  //#23475432985
                }

                try
                {
                    if(linewidthCorrection!=1d)
                    {
                        double temp = double.Parse(linewidth);
                        linewidth = (temp * linewidthCorrection).ToString();
                    }
                    if (pointsizeCorrection != 1d)
                    {
                        double temp = double.Parse(pointsize);
                        pointsize = (temp * pointsizeCorrection).ToString();
                    }
                }
                catch { };


                if (!NullOrEmpty(dashtype)) s += " dashtype " + dashtype;
                if (!NullOrEmpty(linewidth)) s += " linewidth " + linewidth;
                if (!NullOrEmpty(linecolor)) s += " linecolor rgb \"" + linecolor + "\"";
                if (!NullOrEmpty(pointtype)) s += " pointtype " + pointtype;
                if (!NullOrEmpty(pointtype)) s += " pointsize " + pointsize;
                if (!NullOrEmpty(fillstyle)) s += " fillstyle " + fillstyle;
                if (!NullOrEmpty(label)) s += " title " + Globals.QT + label + "   " + Globals.QT;  //blanks added to separate items in the legend                    

                //linestyle is an association of linecolor, linewidth, dashtype, pointtype
                //linetype is the same, just permanent
                //box: fillstyle empty|solid|pattern, border|noborder

                string xAdjustment = null;
                if (G.equal(linetype, "boxes"))
                {
                    if (firstPass)
                    {
                        minMax[0] = Math.Min(minMax[0], dataMin[i]);
                        minMax[1] = Math.Max(minMax[1], dataMax[i]);
                    }

                    if (line3 == null || line3.SelectSingleNode("y2") == null)
                    {
                        boxesYCounter++;
                        if (firstPass) boxesY.Add(i);
                    }
                    else
                    {
                        boxesY2Counter++;
                        if (firstPass) boxesY2.Add(i);
                    }

                    if (stacked)
                    {
                        //see also #34252435
                        string ss = null;
                        if (line3 == null || line3.SelectSingleNode("y2") == null)
                        {
                            //the boxes could be i = 0, 2, 4, 5. The first of these is $1+$3+$5+$6 (note 1 added), the second is $3+$5+$6, etc.                            
                            //the f(x) funcion return 1 if positive, else 0.
                            //with the f function, we get: f($1*$6)*$1 + f($3*$6)*$3 + f($5*$6)*$5 + f($6*$6)*$6 --> the last f($6*$6) could be omitted since it will alway return 1
                            for (int k = boxesYCounter - 1; k < boxesY.Count; k++)
                            {
                                //see similar code below
                                ss += "f($" + (boxesY[k] + quarterFix + 2) + "*$" + (boxesY[boxesYCounter - 1] + quarterFix + 2) + ")*$" + (boxesY[k] + quarterFix + 2) + "+";
                            }
                        }
                        else
                        {
                            //the boxes could be i = 0, 2, 4, 5. The first of these is $1+$3+$5+$6 (note 1 added), the second is $3+$5+$6, etc.
                            for (int k = boxesY2Counter - 1; k < boxesY2.Count; k++)
                            {
                                //see similar code above
                                ss += "f($" + (boxesY2[k] + quarterFix + 2) + "*$" + (boxesY2[boxesYCounter - 1] + quarterFix + 2) + ")*$" + (boxesY2[k] + quarterFix + 2) + "+";
                            }
                        }
                        if (ss != null && ss.EndsWith("+")) ss = ss.Substring(0, ss.Length - 1); //remove last '+'                       
                        if (isInside)
                        {
                            xAdjustment = "($" + (quarterFix + 1) + "+" + GetXAdjustmentForInsideTics(isInside) + ")(" + ss + ")" + ":(" + d_width3 + ")";
                        }
                        else
                        {
                            xAdjustment = "" + (quarterFix + 1) + ":(" + ss + ")" + ":(" + d_width3 + ")";
                        }
                    }
                    else
                    {
                        //adjusting horizontal position for clustered boxes
                        double d = (boxesYCounter + boxesY2Counter - 1) * d_width - left;
                        string minus = "+"; ;
                        if (d < 0)
                        {
                            d = Math.Abs(d);
                            minus = "-";
                        }
                        if (isInside)
                        {
                            xAdjustment = "($" + (quarterFix + 1) + " " + minus + d + "+" + GetXAdjustmentForInsideTics(isInside) + "):" + (i + quarterFix + 2) + ":(" + d_width2 + ")";
                        }
                        else
                        {
                            xAdjustment = "($" + (quarterFix + 1) + " " + minus + d + "):" + (i + quarterFix + 2) + ":(" + d_width2 + ")";
                        }                        
                    }
                }
                else if (G.equal(linetype, "filledcurve") || G.equal(linetype, "filledcurves"))
                {
                    if (firstPass)
                    {
                        minMax[2] = Math.Min(minMax[2], dataMin[i]);
                        minMax[3] = Math.Max(minMax[3], dataMax[i]);
                    }
                    if (line3 == null || line3.SelectSingleNode("y2") == null)
                    {
                        areasYCounter++;
                        if (firstPass) areasY.Add(i);
                    }
                    else
                    {
                        areasY2Counter++;
                        if (firstPass) areasY2.Add(i);
                    }

                    if (stacked)
                    {
                        //see comments under #34252435
                        string ss = null;
                        if (line3 == null || line3.SelectSingleNode("y2") == null)
                        {
                            for (int k = areasYCounter - 1; k < areasY.Count; k++)
                            {
                                //see similar code below
                                ss += "f($" + (areasY[k] + quarterFix + 2) + "*$" + (areasY[areasYCounter - 1] + quarterFix + 2) + ")*$" + (areasY[k] + quarterFix + 2) + "+";
                            }
                        }
                        else
                        {
                            for (int k = areasY2Counter - 1; k < areasY2.Count; k++)
                            {
                                //see similar code above
                                ss += "f($" + (areasY2[k] + quarterFix + 2) + "*$" + (areasY2[areasYCounter - 1] + quarterFix + 2) + ")*$" + (areasY2[k] + quarterFix + 2) + "+";
                            }
                        }
                        if (ss != null && ss.EndsWith("+")) ss = ss.Substring(0, ss.Length - 1);  //remove last '+'                       
                        if (isInside)
                        {
                            xAdjustment = "($" + (quarterFix + 1) + "+" + GetXAdjustmentForInsideTics(isInside) + "):(" + ss + ")";
                        }
                        else
                        {
                            xAdjustment = "" + (quarterFix + 1) + ":(" + ss + ")";
                        }
                    }
                    else
                    {
                        if (isInside)
                        {
                            xAdjustment = "($" + (quarterFix + 1) + "+" + GetXAdjustmentForInsideTics(isInside) + "):" + (i + quarterFix + 2);  //just normal positioning
                        }
                        else
                        {
                            xAdjustment = "" + (quarterFix + 1) + ":" + (i + quarterFix + 2);  //just normal positioning
                        }
                    }
                }
                else
                {
                    if (firstPass)
                    {
                        minMax[4] = Math.Min(minMax[4], dataMin[i]);
                        minMax[5] = Math.Max(minMax[5], dataMax[i]);
                    }
                    if (isInside)
                    {                        
                        xAdjustment = "($" + (quarterFix + 1) + "+" + GetXAdjustmentForInsideTics(isInside) + "):" + (i + quarterFix + 2);
                    }
                    else
                    {
                        xAdjustment = "" + (quarterFix + 1) + ":" + (i + quarterFix + 2);
                    }
                    //xAdjustment = "" + (quarterFix + 1) + ":" + (i + quarterFix + 2);
                }

                //string xlabel = GnuplotText(label);

                plotline += "\"" + file1 + "\" using " + xAdjustment + s;

                if (i < count - 1) plotline += ", ";
            }

            return plotline;
        }

        private static double GetXAdjustmentForInsideTics(bool isInside)
        {
            if (!isInside) return 0d;
            int sub = 1;
            if (Program.options.freq == EFreq.Quarterly) sub = 4;
            else if (Program.options.freq == EFreq.Monthly) sub = 12;
            double adj = 1d / sub / 2d;
            return adj;
        }

        private static bool NotNullAndNotNo(string s)
        {
            //#23475432985
            return s != null && !G.equal(s, "no");
        }

        private static string HandleLabel(XmlNode line3, bool isExplicit, string labelCleaned)
        {
            string label;
            string labelGpt = line3 == null ? null : GetText(line3.SelectSingleNode("label"));
            if (isExplicit)  //for instance: PLOT x*y 'product';
            {
                label = labelCleaned;  //overrides any xml label                        
            }
            else  //for instance: PLOT x*y;
            {
                label = labelCleaned;
                if (!NullOrEmpty(labelGpt)) label = labelGpt;  //xml label overrides variables
            }

            return label;
        }

        private static string GetText(XmlNode x, string def)
        {
            return GetText(null, null, null, x, def);           
        }

        private static string GetText(string y1, string y2, XmlNode y3, XmlNode y4, string y5)
        {
            //it seems the xml reader auto-trims the strings
            string s = y5; //maybe null, "", or a real string

            if(y4 != null)
            {
                if (y4.InnerText.StartsWith("//"))
                {
                    //do nothing, as if the tag does not even exist
                }
                else 
                {
                    s = y4.InnerText;  //if <tag></tag> or <tag/>, s will be = "". We say that this overrides prior settings.                
                }
            }
            else
            {
                //do nothing: the tag does not exist
            }

            if (y3 != null)
            {
                if (y3.InnerText.StartsWith("//"))
                {
                    //do nothing, as if the tag does not even exist
                }
                else
                {
                    s = y3.InnerText;  //if <tag></tag> or <tag/>, s will be = "". We say that this overrides prior settings.                
                }
            }
            else
            {
                //do nothing: the tag does not exist
            }

            if (y2 != null)
            {
                //For instance PLOT <color='red> x1, x2;
                s = y2;
            }

            if (y1 != null)
            {
                //For instance PLOT x1<color='red'>, x2;
                s = y1;
            }            

            return s;
        }

        private static List<string> GetText(XmlNodeList x)
        {
            List<string> ss = new List<string>();
            foreach(XmlNode y in x)
            {
                ss.Add(GetText(y));
            }
            return ss;
        }

        private static string GetText(XmlNode x)
        {
            return GetText(x, null);
        }

        private static bool NullOrEmpty(string x)
        {
            return !(x != null && x.Trim() != "");
        }

        private static string GnuplotText(string s)
        {
            if (s == null) return null;
            return s.Replace(@"_", @"\\_");
        }

        private static int HandleXTics(int quarterFix, List<string> labels1, List<string> labels2, ref string ticsTxt, int mxtics)
        {
            if (Program.options.freq == EFreq.Annual || Program.options.freq == EFreq.Undated)
            {
                //do nothing
                ticsTxt = null;
            }
            else
            {
                List<int> subperiods;
                int onlyYears;
                mxtics = GnuplotHandleXAxisLabels(labels1, mxtics, out subperiods, out onlyYears);

                string s3 = null;
                int c = -1;
                for (int i = 0; i < labels1.Count; i++)
                {
                    c++;
                    //int subper=labels2[i]
                    //if (labels1.Count > 20 && c %  != 0) continue;
                    string[] split = labels2[i].Split(new char[] { '/' });
                    if (onlyYears != -12345 && int.Parse(split[0]) % onlyYears != 0) continue;
                    if (subperiods.Contains(int.Parse(split[1])))
                    {
                        string xx = labels2[i];
                        if (quarterFix == 1)
                        {
                            if (Program.options.freq == EFreq.Quarterly || Program.options.freq == EFreq.Monthly)
                            {
                                xx = FromGnuplotDateToFloatingValue(split);
                            }
                        }
                        s3 += "\"" + labels1[i] + "\" \"" + xx + "\", ";
                    }
                }
                if (s3.EndsWith(", ")) s3 = s3.Substring(0, s3.Length - 2);
                ticsTxt = "set xtics (" + s3 + ")" + G.NL;
            }

            return mxtics;
        }

        private static string FromGnuplotDateToFloatingValue(string[] split)
        {
            return ((double)int.Parse(split[0]) + ((double)int.Parse(split[1]) - 1d) / 12d).ToString();
        }

        private static int GnuplotHandleXAxisLabels(List<string> labels1, int mxtics, out List<int> subperiods, out int onlyYears)
        {
            subperiods = new List<int>();
            onlyYears = -12345;
            if (Program.options.freq == EFreq.Quarterly)
            {
                if (labels1.Count <= 12)  //for quarterly, 12 corresponds to 3 years with 4 subpers each
                {
                    subperiods.Add(1);  //q1
                    subperiods.Add(4);  //q2
                    subperiods.Add(7);  //q3
                    subperiods.Add(10);  //q4
                }
                else if (labels1.Count <= 24)
                {
                    subperiods.Add(1);  //q1
                    subperiods.Add(7);  //q3
                    mxtics = 2;
                }
                else if (labels1.Count <= 48)
                {
                    subperiods.Add(1);  //q1
                    mxtics = 4;
                }
                else if (labels1.Count <= 5 * 48)
                {
                    onlyYears = 5;
                    subperiods.Add(1);  //q1
                    mxtics = 5;
                }
                else if (labels1.Count <= 10 * 48)
                {
                    onlyYears = 10;
                    subperiods.Add(1);  //q1
                    mxtics = 10;
                }
                else
                {
                    onlyYears = 20;
                    subperiods.Add(1);  //q1
                }
            }
            else  //monthly
            {
                if (labels1.Count <= 12)  //for monthly, 12 corresponds to 1 year with 12 subpers
                {
                    subperiods.Add(1);  //m1
                    subperiods.Add(2);  //m2
                    subperiods.Add(3);  //m3
                    subperiods.Add(4);  //m4
                    subperiods.Add(5);  //m5
                    subperiods.Add(6);  //m6
                    subperiods.Add(7);  //m7
                    subperiods.Add(8);  //m8
                    subperiods.Add(9);  //m9
                    subperiods.Add(10);  //m10
                    subperiods.Add(11);  //m11
                    subperiods.Add(12);  //m12
                }
                else if (labels1.Count <= 24)
                {
                    subperiods.Add(1);  //m1
                    subperiods.Add(3);  //m3
                    subperiods.Add(5);  //m5
                    subperiods.Add(7);  //m7
                    subperiods.Add(9);  //m9
                    subperiods.Add(11);  //m11
                    mxtics = 2;
                }
                else if (labels1.Count <= 36)
                {
                    subperiods.Add(1);  //m1
                    subperiods.Add(4);  //m4
                    subperiods.Add(7);  //m7
                    subperiods.Add(10);  //m10
                    mxtics = 3;
                }
                else if (labels1.Count <= 48)
                {
                    subperiods.Add(1);  //m1
                    subperiods.Add(5);  //m5
                    subperiods.Add(9);  //m9
                    mxtics = 4;
                }
                else if (labels1.Count <= 72)
                {
                    subperiods.Add(1);  //m1
                    subperiods.Add(7);  //m7
                    mxtics = 6;
                }
                else if (labels1.Count <= 144)
                {
                    subperiods.Add(1);  //m1
                }
                else if (labels1.Count <= 15 * 48)
                {
                    onlyYears = 5;
                    subperiods.Add(1);  //m1
                    mxtics = 5;
                }
                else if (labels1.Count <= 30 * 48)
                {
                    onlyYears = 10;
                    subperiods.Add(1);  //m1
                    mxtics = 10;
                }
                else
                {
                    onlyYears = 20;
                    subperiods.Add(1);  //m1
                }
            }

            return mxtics;
        }

        private static string GnuplotYrange(string ymin, string yminsoft, string yminhard, string ymax, string ymaxsoft, string ymaxhard)
        {
            // [  yminhard < * < yminsoft  : ymaxsoft < * < ymaxhard ] 
            // TODO: it would be nice to test the inequalities above, because if they are violated, they have no effect --> free borders, even if ymin/ymax is set.

            if (G.equal(ymin, "NaN")) ymin = null;
            if (G.equal(yminsoft, "NaN")) yminsoft = null;
            if (G.equal(yminhard, "NaN")) yminhard = null;
            if (G.equal(ymax, "NaN")) ymax = null;
            if (G.equal(ymaxsoft, "NaN")) ymaxsoft = null;
            if (G.equal(ymaxhard, "NaN")) ymaxhard = null;

            string left = null;
            string right = null;
            if (!NullOrEmpty(ymin))
            {                
                left = ymin;
            }
            else
            {                
                if (!NullOrEmpty(yminhard) && !NullOrEmpty(yminsoft))
                {
                    left = yminhard + " < * < " + yminsoft;
                }
                else if (!NullOrEmpty(yminhard) && NullOrEmpty(yminsoft))
                {
                    left = yminhard + " < * ";
                }
                else if (NullOrEmpty(yminhard) && !NullOrEmpty(yminsoft))
                {
                    left = " * < " + yminsoft;
                }
                else
                {
                    left = "";
                }
            }

            if (!NullOrEmpty(ymax))
            {
                double xx = ParseIntoDouble(ymax);  //just testing
                right = ymax;
            }
            else
            {
                if (!NullOrEmpty(ymaxhard) && !NullOrEmpty(ymaxsoft))
                {
                    right = ymaxsoft + " < * < " + ymaxhard;
                }
                else if (!NullOrEmpty(ymaxhard) && NullOrEmpty(ymaxsoft))
                {
                    right = " * < " + ymaxhard;
                }
                else if (NullOrEmpty(ymaxhard) && !NullOrEmpty(ymaxsoft))
                {
                    right = ymaxsoft + " < * ";
                }
                else
                {
                    right = "";
                }
            }
            return left + ":" + right;
        }            

        private static string GnuplotHeading(O.Prt o, Gpt gpt)
        {
            string heading = null;            
            try { heading = gpt.title; } catch (NullReferenceException) { };
            if (o.opt_title != null) heading = o.opt_title;
            return heading;
        }

        private static double ParseIntoDouble(string x)
        {
            double y = double.NaN;
            if (x != null)
            {
                if (!double.TryParse(x, out y))
                {
                    G.Writeln2("*** ERROR: Could not parse '" + x + "' as a number");
                    throw new GekkoException();
                }
            }
            return y;
        }

        private static string GetDateStringSuitableForGnuplot(string d)
        {
            if (Program.options.freq == EFreq.Quarterly)
            {
                if (d.EndsWith("q1")) d = d.Substring(0, d.Length - 2) + "/01/01" + "";
                else if (d.EndsWith("q2")) d = d.Substring(0, d.Length - 2) + "/04/01" + "";
                else if (d.EndsWith("q3")) d = d.Substring(0, d.Length - 2) + "/07/01" + "";
                else if (d.EndsWith("q4")) d = d.Substring(0, d.Length - 2) + "/10/01" + "";
                else throw new GekkoException();
            }
            else if (Program.options.freq == EFreq.Monthly)
            {
                if (d.EndsWith("m1")) d = d.Substring(0, d.Length - 2) + "/01/01" + "";
                else if (d.EndsWith("m2")) d = d.Substring(0, d.Length - 2) + "/02/01" + "";
                else if (d.EndsWith("m3")) d = d.Substring(0, d.Length - 2) + "/03/01" + "";
                else if (d.EndsWith("m4")) d = d.Substring(0, d.Length - 2) + "/04/01" + "";
                else if (d.EndsWith("m5")) d = d.Substring(0, d.Length - 2) + "/05/01" + "";
                else if (d.EndsWith("m6")) d = d.Substring(0, d.Length - 2) + "/06/01" + "";
                else if (d.EndsWith("m7")) d = d.Substring(0, d.Length - 2) + "/07/01" + "";
                else if (d.EndsWith("m8")) d = d.Substring(0, d.Length - 2) + "/08/01" + "";
                else if (d.EndsWith("m9")) d = d.Substring(0, d.Length - 2) + "/09/01" + "";
                else if (d.EndsWith("m10")) d = d.Substring(0, d.Length - 3) + "/10/01" + "";
                else if (d.EndsWith("m11")) d = d.Substring(0, d.Length - 3) + "/11/01" + "";
                else if (d.EndsWith("m12")) d = d.Substring(0, d.Length - 3) + "/12/01" + "";
                else throw new GekkoException();
            }
            return d;
        }

        private static void CallGnuplot(List<string> graphVars, List<string> graphVarsNames, String file1, String file2, String file3, String currentDir, TextWriter tw, int count, int numberOfObs, string heading, string pplotType)
        {
            bool histo = false;
            if (Globals.runningOnTTComputer) histo = false;

            //tw.WriteLine("set terminal emf size 300 ,200");

            tw.WriteLine("set encoding iso_8859_1");

            heading = EncodeDanish(heading);

            tw.WriteLine("set title \"" + heading + "\"");
            tw.WriteLine("set datafile missing \"NaN\"");
            tw.WriteLine("set terminal " + pplotType);
            tw.WriteLine("set terminal emf");
            tw.WriteLine("set output \"" + file2 + "\"");
            //tw.WriteLine("set data style linespoints"); //probably superfluous
            //tw.WriteLine("set title \"Graph\"");
            //tw.WriteLine("set xlabel \"År\"");
            //tw.WriteLine("set ylabel \"Var1\"");

            if (!(Program.options.freq == EFreq.Annual || Program.options.freq == EFreq.Undated))  //ttfreq
            {
                tw.WriteLine("set xdata time");
                tw.WriteLine(@"set timefmt ""%Y/%m/%d""");
                tw.WriteLine(@"set format x ""%Y/%m""");
            }
            else
            {
                if (numberOfObs > 70)
                {
                    tw.WriteLine("set xtics 10");
                    tw.WriteLine("set mxtics 10");
                }
                else
                {
                    tw.WriteLine("set xtics 5");
                    tw.WriteLine("set mxtics 5");
                }
            }

            tw.WriteLine("set ticscale 1.4 0.7");
            //tw.WriteLine("set key outside top");
            //tw.WriteLine("set key 100, 100");
            tw.WriteLine("set border 3");
            tw.WriteLine("set xtics nomirror");
            tw.WriteLine("set ytics nomirror");
            tw.WriteLine("set xzeroaxis lt -1");
            tw.WriteLine("set yzeroaxis");
            //tw.WriteLine("set grid");
            //tw.WriteLine("set size 0.5,0.5");
            //tw.WriteLine("set size ratio 0.2"); does not work

            if (histo)
            {
                if (false)  //not really working (labels)
                {
                    tw.WriteLine("set size ratio 0.5");
                    tw.WriteLine("set key outside top");
                }

                tw.WriteLine("set style fill solid 1.000000 border -1");
                tw.WriteLine("set boxwidth 0.3");


                //tw.WriteLine("set style line 1 lt 1 lw 3 lc rgb \"black\" ");
                tw.WriteLine("set style line 1 lt 1 lw 4.0");
                tw.WriteLine("set style line 2 lt 2 lw 2.0");
                tw.WriteLine("set style line 3 lt 3 lw 2.0");

            }

            tw.Write("plot ");
            for (int i = 0; i < count; i++)
            {
                string label = EncodeDanish(graphVarsNames[i]);

                if (!histo)
                {
                    string lineType = "with lines ";
                    if (Program.options.plot_lines_points)
                    {
                        lineType = "with linespoints ";
                    }
                    tw.Write("\"" + file1 + "\" using 1:" + (i + 2) + " " + lineType + "lw 2.0 " + " title \"  " + label + "\" ");
                }
                else
                {
                    if (i == 0) tw.Write("\"" + file1 + "\" using 1:" + (i + 2) + " with linespoints ls 1 " + " title \"  " + label + "\" ");  //obs
                    else if (i == 1) tw.Write("\"" + file1 + "\" using 1:" + (i + 2) + " with linespoints ls 2 " + " title \"  " + label + "\" ");  //fitted
                    else if (i == 2) tw.Write("\"" + file1 + "\" using 1:" + (i + 2) + " with linespoints ls 3 " + " title \"  " + label + "\" ");  //wanted
                    else if (i == 3) tw.Write("\"" + file1 + "\" using 1:" + (i + 2) + " with boxes lw 2.0 " + " title \"  " + label + "\" ");  //residual
                    else tw.Write("\"" + file1 + "\" using 1:" + (i + 2) + " with linespoints lw 2.0 " + " title \"  " + label + "\" ");
                }



                if (i < count - 1) tw.Write(",");
            }
            tw.WriteLine();
            tw.Flush();
            tw.Close();

            Process p = new Process();
            //p.MainWindowTitle = title;
            p.StartInfo.FileName = Application.StartupPath + "\\gnuplot\\wgnuplot.exe";
            //p.StartInfo.WindowStyle = ProcessWindowStyle.Hidden;
            p.StartInfo.Arguments = file3;
            p.Start();
            p.WaitForExit();
            p.Close();
            //resets current dir to previous location
            Directory.SetCurrentDirectory(currentDir);
        }

        private static string EncodeDanish(string txt)
        {
            string s = "";
            foreach (char c in txt)
            {
                if (c == 'æ') s += "\\" + (346).ToString();
                else if (c == 'ø') s += "\\" + (370).ToString();
                else if (c == 'å') s += "\\" + (345).ToString();
                else if (c == 'Æ') s += "\\" + (306).ToString();
                else if (c == 'Ø') s += "\\" + (330).ToString();
                else if (c == 'Å') s += "\\" + (305).ToString();
                else s += c.ToString();
            }
            return s;
        }



        private static void ComputeValueForVprt(out double var1, out double varPch, PrtOptionsHelper po, GekkoTime gt0, GekkoTime gt1, TimeSeries tsWork, TimeSeries tsBase)
        {

            GekkoTime gt0MinusOne = gt0.Add(-1);
            var1 = 0;
            varPch = 0;
            if (po.isLevel == true)
            {
                TimeSeries ts = tsWork; if (po.isBaseline) ts = tsBase;

                double sum = 0d;
                double count = 0d;
                foreach (GekkoTime gt in new GekkoTimeIterator( gt0, gt1))
                {
                    double x = ts.GetData(gt);
                    sum += x;
                    count += 1d;
                }
                double avg = sum / count;

                double x1 = ts.GetData(gt1);
                double x0MinusOne = ts.GetData(gt0MinusOne);

                double avgGrowth = (Math.Pow(x1 / x0MinusOne, 1 / count) - 1) * 100d;
                if (x1 == x0MinusOne) avgGrowth = 0d;   //0 and 0 gives 0%

                var1 = avg;
                varPch = avgGrowth;

            }
            else
            {
                G.Writeln2("*** ERROR in VPRT regarding option field, only <r> can be used.");
                throw new GekkoException();
            }
            return;
        }

        public static void ComputeValueForPrintPlotNew(out double var1, out double varPch, string printCode2, GekkoTime gt, TimeSeries tsWork, TimeSeries tsBase, bool isLogTransform, bool isCalledFromTable)
        {
            string printCode = printCode2.Trim();  //when it comes from for instance a table

            if (isCalledFromTable && !G.equal(Globals.tableOption, "n"))
            {
                if (G.equal(Globals.tableOption, "d"))
                {
                    if (G.equal(printCode, "n")) printCode = "d";
                    else if (G.equal(printCode, "d")) printCode = "";
                    else if (G.equal(printCode, "p")) printCode = "";
                    else if (G.equal(printCode, "dp")) printCode = "";
                    else if (G.equal(printCode, "r")) printCode = "rd";
                    else if (G.equal(printCode, "rn")) printCode = "rd";
                    else if (G.equal(printCode, "rd")) printCode = "";
                    else if (G.equal(printCode, "rp")) printCode = "";
                    else if (G.equal(printCode, "rdp")) printCode = "";
                    else if (G.equal(printCode, "m")) printCode = "";
                    else if (G.equal(printCode, "q")) printCode = "";
                    else if (G.equal(printCode, "mp")) printCode = "";
                }
                else if (G.equal(Globals.tableOption, "p"))
                {
                    if (G.equal(printCode, "n")) printCode = "p";
                    else if (G.equal(printCode, "d")) printCode = "";
                    else if (G.equal(printCode, "p")) printCode = "";
                    else if (G.equal(printCode, "dp")) printCode = "";
                    else if (G.equal(printCode, "r")) printCode = "rp";
                    else if (G.equal(printCode, "rn")) printCode = "rp";
                    else if (G.equal(printCode, "rd")) printCode = "";
                    else if (G.equal(printCode, "rp")) printCode = "";
                    else if (G.equal(printCode, "rdp")) printCode = "";
                    else if (G.equal(printCode, "m")) printCode = "";
                    else if (G.equal(printCode, "q")) printCode = "";
                    else if (G.equal(printCode, "mp")) printCode = "";
                }
                else if (G.equal(Globals.tableOption, "dp"))
                {
                    if (G.equal(printCode, "n")) printCode = "dp";
                    else if (G.equal(printCode, "d")) printCode = "";
                    else if (G.equal(printCode, "p")) printCode = "";
                    else if (G.equal(printCode, "dp")) printCode = "";
                    else if (G.equal(printCode, "r")) printCode = "rdp";
                    else if (G.equal(printCode, "rn")) printCode = "rdp";
                    else if (G.equal(printCode, "rd")) printCode = "";
                    else if (G.equal(printCode, "rp")) printCode = "";
                    else if (G.equal(printCode, "rdp")) printCode = "";
                    else if (G.equal(printCode, "m")) printCode = "";
                    else if (G.equal(printCode, "q")) printCode = "";
                    else if (G.equal(printCode, "mp")) printCode = "";
                }
                else if (G.equal(Globals.tableOption, "r") || G.equal(Globals.tableOption, "rn"))
                {
                    if (G.equal(printCode, "n")) printCode = "r";
                    else if (G.equal(printCode, "d")) printCode = "rd";
                    else if (G.equal(printCode, "p")) printCode = "rp";
                    else if (G.equal(printCode, "dp")) printCode = "rdp";
                    else if (G.equal(printCode, "r")) printCode = "";
                    else if (G.equal(printCode, "rn")) printCode = "";
                    else if (G.equal(printCode, "rd")) printCode = "";
                    else if (G.equal(printCode, "rp")) printCode = "";
                    else if (G.equal(printCode, "rdp")) printCode = "";
                    else if (G.equal(printCode, "m")) printCode = "";
                    else if (G.equal(printCode, "q")) printCode = "";
                    else if (G.equal(printCode, "mp")) printCode = "";
                }
                else if (G.equal(Globals.tableOption, "rd"))
                {
                    if (G.equal(printCode, "n")) printCode = "rd";
                    else if (G.equal(printCode, "d")) printCode = "";
                    else if (G.equal(printCode, "p")) printCode = "";
                    else if (G.equal(printCode, "dp")) printCode = "";
                    else if (G.equal(printCode, "r")) printCode = "";
                    else if (G.equal(printCode, "rn")) printCode = "";
                    else if (G.equal(printCode, "rd")) printCode = "";
                    else if (G.equal(printCode, "rp")) printCode = "";
                    else if (G.equal(printCode, "rdp")) printCode = "";
                    else if (G.equal(printCode, "m")) printCode = "";
                    else if (G.equal(printCode, "q")) printCode = "";
                    else if (G.equal(printCode, "mp")) printCode = "";
                }
                else if (G.equal(Globals.tableOption, "rp"))
                {
                    if (G.equal(printCode, "n")) printCode = "rp";
                    else if (G.equal(printCode, "d")) printCode = "";
                    else if (G.equal(printCode, "p")) printCode = "";
                    else if (G.equal(printCode, "dp")) printCode = "";
                    else if (G.equal(printCode, "r")) printCode = "";
                    else if (G.equal(printCode, "rn")) printCode = "";
                    else if (G.equal(printCode, "rd")) printCode = "";
                    else if (G.equal(printCode, "rp")) printCode = "";
                    else if (G.equal(printCode, "rdp")) printCode = "";
                    else if (G.equal(printCode, "m")) printCode = "";
                    else if (G.equal(printCode, "q")) printCode = "";
                    else if (G.equal(printCode, "mp")) printCode = "";
                }
                else if (G.equal(Globals.tableOption, "rdp"))
                {
                    if (G.equal(printCode, "n")) printCode = "rdp";
                    else if (G.equal(printCode, "d")) printCode = "";
                    else if (G.equal(printCode, "p")) printCode = "";
                    else if (G.equal(printCode, "dp")) printCode = "";
                    else if (G.equal(printCode, "r")) printCode = "";
                    else if (G.equal(printCode, "rn")) printCode = "";
                    else if (G.equal(printCode, "rd")) printCode = "";
                    else if (G.equal(printCode, "rp")) printCode = "";
                    else if (G.equal(printCode, "rdp")) printCode = "";
                    else if (G.equal(printCode, "m")) printCode = "";
                    else if (G.equal(printCode, "q")) printCode = "";
                    else if (G.equal(printCode, "mp")) printCode = "";
                }
                else if (G.equal(Globals.tableOption, "m"))
                {
                    if (G.equal(printCode, "n")) printCode = "m";
                    else if (G.equal(printCode, "d")) printCode = "";
                    else if (G.equal(printCode, "p")) printCode = "mp";
                    else if (G.equal(printCode, "dp")) printCode = "";
                    else if (G.equal(printCode, "r")) printCode = "";
                    else if (G.equal(printCode, "rn")) printCode = "";
                    else if (G.equal(printCode, "rd")) printCode = "";
                    else if (G.equal(printCode, "rp")) printCode = "";
                    else if (G.equal(printCode, "rdp")) printCode = "";
                    else if (G.equal(printCode, "m")) printCode = "";
                    else if (G.equal(printCode, "q")) printCode = "";
                    else if (G.equal(printCode, "mp")) printCode = "";
                }
                else if (G.equal(Globals.tableOption, "q"))
                {
                    if (G.equal(printCode, "n")) printCode = "q";
                    else if (G.equal(printCode, "d")) printCode = "";
                    else if (G.equal(printCode, "p")) printCode = "";
                    else if (G.equal(printCode, "dp")) printCode = "";
                    else if (G.equal(printCode, "r")) printCode = "";
                    else if (G.equal(printCode, "rn")) printCode = "";
                    else if (G.equal(printCode, "rd")) printCode = "";
                    else if (G.equal(printCode, "rp")) printCode = "";
                    else if (G.equal(printCode, "rdp")) printCode = "";
                    else if (G.equal(printCode, "m")) printCode = "";
                    else if (G.equal(printCode, "q")) printCode = "";
                    else if (G.equal(printCode, "mp")) printCode = "";
                }
                else if (G.equal(Globals.tableOption, "mp"))
                {
                    if (G.equal(printCode, "n")) printCode = "mp";
                    else if (G.equal(printCode, "d")) printCode = "";
                    else if (G.equal(printCode, "p")) printCode = "";
                    else if (G.equal(printCode, "dp")) printCode = "";
                    else if (G.equal(printCode, "r")) printCode = "";
                    else if (G.equal(printCode, "rn")) printCode = "";
                    else if (G.equal(printCode, "rd")) printCode = "";
                    else if (G.equal(printCode, "rp")) printCode = "";
                    else if (G.equal(printCode, "rdp")) printCode = "";
                    else if (G.equal(printCode, "m")) printCode = "";
                    else if (G.equal(printCode, "q")) printCode = "";
                    else if (G.equal(printCode, "mp")) printCode = "";
                }
                if (printCode == "")
                {
                    G.Writeln2("*** ERROR: TABLE <" + Globals.tableOption + "> and table-file printcode '" + printCode2 + "' do not combine");
                    throw new GekkoException();
                }
            }

            GekkoTime tMinusOne = gt.Add(-1);
            var1 = 0;
            varPch = 0;

            double x = double.NaN;
            double xLag = double.NaN;
            double xLag2 = double.NaN;
            double y = double.NaN;
            double yLag = double.NaN;
            double yLag2 = double.NaN;
            if (tsWork != null)
            {
                x = tsWork.GetData(gt);
                xLag = tsWork.GetData(gt.Add(-1));
                xLag2 = tsWork.GetData(gt.Add(-2));
                if (isLogTransform)
                {
                    x = Math.Log(x);
                    xLag = Math.Log(xLag);
                    xLag2 = Math.Log(xLag2);
                }
            }
            if (tsBase != null)
            {
                y = tsBase.GetData(gt);
                yLag = tsBase.GetData(gt.Add(-1));
                yLag2 = tsBase.GetData(gt.Add(-2));
                if (isLogTransform)
                {
                    y = Math.Log(y);
                    yLag = Math.Log(yLag);
                    yLag2 = Math.Log(yLag2);
                }
            }

            if (printCode == "" || printCode == "n")
            {
                var1 = x;
                varPch = PchFunction(x, xLag);
            }
            else if (printCode == "d")
            {
                var1 = x - xLag;
                varPch = PchFunction(x, xLag);
            }
            else if (printCode == "p")
            {
                var1 = PchFunction(x, xLag);
                varPch = double.PositiveInfinity;
            }
            else if (printCode == "dp")
            {
                var1 = PchFunction(x, xLag) - PchFunction(xLag, xLag2);
                varPch = double.PositiveInfinity;
            }
            else if (printCode == Globals.printCode_s || printCode == Globals.printCode_sn)  //r or rn
            {
                var1 = y;
                varPch = PchFunction(y, yLag);
            }
            else if (printCode == Globals.printCode_sd)  //rd
            {
                var1 = y - yLag;
                varPch = PchFunction(y, yLag);
            }
            else if (printCode == Globals.printCode_sp)  //rp
            {
                var1 = PchFunction(y, yLag);
                varPch = double.PositiveInfinity;
            }
            else if (printCode == Globals.printCode_sdp)  //rdp
            {
                var1 = PchFunction(y, yLag) - PchFunction(yLag, yLag2);
                varPch = double.PositiveInfinity;
            }
            else if (printCode == "m")
            {
                var1 = x - y;
                varPch = PchFunction(x, y);
            }
            else if (printCode == "q")
            {
                var1 = PchFunction(x, y);
                varPch = double.PositiveInfinity;
            }
            else if (printCode == "mp")
            {
                var1 = PchFunction(x, xLag) - PchFunction(y, yLag);
                varPch = double.PositiveInfinity;
            }
            else
            {
                G.Writeln2("*** ERROR: Internal error: unrecognized print code: '" + printCode + "'");
                throw new GekkoException();
            }
            return;
        }

        private static double PchFunction(double x, double x0)
        {
            double z = ((x / x0) - 1d) * 100d;
            if (x == x0) z = 0d;    //0 and 0 gives 0%
            return z;
        }

        private static void ComputeValueForPrintPlot(out double var1, out double varPch, PrtOptionsHelper po, GekkoTime gt, TimeSeries tsWork, TimeSeries tsBase)
        {
            GekkoTime tMinusOneOrTwo = gt.Add(-1);
            var1 = 0;
            varPch = 0;

            if (po.isDp)
            {
                TimeSeries ts = tsWork; if (po.isBaseline) ts = tsBase;
                double var = ts.GetData(gt);
                double varLag = ts.GetData(gt.Add(-1));
                double varLag2 = ts.GetData(gt.Add(-2));
                double pch = (var / varLag - 1) * 100d;
                double pchLag = (varLag / varLag2 - 1) * 100d;
                double dpch = pch - pchLag;
                var1 = dpch;  //TODO: do we get the first year without missing (it uses 2 lags...)?
                varPch = double.NaN;  //TODO: remove this in print
            }
            else if (po.isMp)
            {
                double var = tsWork.GetData(gt);
                double varLag = tsWork.GetData(gt.Add(-1));
                double varBase = tsBase.GetData(gt);
                double varBaseLag = tsBase.GetData(gt.Add(-1));
                double pch = (var / varLag - 1) * 100d;
                double pchBase = (varBase / varBaseLag - 1) * 100d;
                double dpch = pch - pchBase;
                var1 = dpch;
                varPch = double.NaN;  //TODO: remove this in print
            }
            else if (po.isLevel == true)
            {
                TimeSeries ts = tsWork; if (po.isBaseline) ts = tsBase;
                var1 = ts.GetData(gt);
                varPch = ((ts.GetData(gt) / ts.GetData(tMinusOneOrTwo) - 1d) * 100d);
                if (ts.GetData(gt) == ts.GetData(tMinusOneOrTwo)) varPch = 0d;    //0 and 0 gives 0%
            }
            else if (po.isLog == true)
            {
                TimeSeries ts = tsWork; if (po.isBaseline) ts = tsBase;
                var1 = Math.Log(ts.GetData(gt));
            }
            else if (po.isPch == true)
            {
                if (po.isMultiplier == true)
                {
                    if (po.isBaseline)
                    {
                        G.Writeln2("*** ERROR: It is not meaningful to use 'pch', 'multiplier' and 'reference' at the same time");
                        throw new GekkoException();
                    }
                    var1 = ((tsWork.GetData(gt) / tsBase.GetData(gt) - 1d) * 100d);
                    if (tsWork.GetData(gt) == tsBase.GetData(gt)) var1 = 0d;     //0 and 0 gives 0%
                }
                else
                {
                    TimeSeries ts = tsWork; if (po.isBaseline) ts = tsBase;
                    var1 = ((ts.GetData(gt) / ts.GetData(tMinusOneOrTwo) - 1d) * 100d);
                    if (ts.GetData(gt) == ts.GetData(tMinusOneOrTwo)) var1 = 0d;     //0 and 0 gives 0%
                }
            }
            else if (po.isDiff == true)
            {
                if (po.isMultiplier == true)
                {
                    if (po.isBaseline)
                    {
                        G.Writeln2("*** ERROR: It is not meaningful to use 'diff', 'multiplier' and 'reference' at the same time");
                        throw new GekkoException();
                    }
                    var1 = tsWork.GetData(gt) - tsBase.GetData(gt);
                    varPch = ((tsWork.GetData(gt) / tsBase.GetData(gt) - 1d) * 100d);
                    if (tsWork.GetData(gt) == tsBase.GetData(gt)) varPch = 0d;  //0 and 0 gives 0%
                }
                else
                {
                    TimeSeries ts = tsWork; if (po.isBaseline) ts = tsBase;
                    var1 = ts.GetData(gt) - ts.GetData(tMinusOneOrTwo);
                }
            }
            else if (po.isDlog == true)
            {
                if (po.isMultiplier == true)
                {
                    if (po.isBaseline)
                    {
                        G.Writeln2("*** ERROR: It is not meaningful to use 'dlog', 'multiplier' and 'reference' at the same time");
                        throw new GekkoException();
                    }
                    var1 = Math.Log(tsWork.GetData(gt) / tsBase.GetData(gt));
                }
                else
                {
                    TimeSeries ts = tsWork; if (po.isBaseline) ts = tsBase;
                    var1 = Math.Log(ts.GetData(gt) / ts.GetData(tMinusOneOrTwo));
                }
            }
            return;
        }

        //res is altered as a side-effect, and b array too. But x is unaltered.
        public static double rssFunction(out int numericalProblem, IElementalAccessVector res, IElementalAccessVector x, Type assembly)
        {
            numericalProblem = runModel(res, x, assembly);  //res is residuals, implicitly also calculates b array
            double rss = Blas.Default.Dot(res, res);
            return rss;
        }

        //res is altered as a side-effect, and b array too. But x is unaltered.
        public static double rssFunction2(out int numericalProblem, double[] res, double[] x, Type assembly)
        {
            int n = res.Length;
            IElementalAccessVector x2 = new DenseVector(res.Length);
            IElementalAccessVector res2 = new DenseVector(n);
            for (int i1 = 0; i1 < n; i1++)
            {
                res2.SetValue(i1, res[i1]);
                x2.SetValue(i1, x[i1]);
            }
            numericalProblem = runModel(res2, x2, assembly);  //res is residuals, implicitly also calculates b array
            for (int i1 = 0; i1 < n; i1++)
            {
                res[i1] = res2.GetValue(i1);
                //x[i1]=x2.GetValue(i1);  //unaltered
            }
            return double.NaN;
        }

        public static void SolveDfsane(double[] b, Type assembly)
        {
            //Does not seem very robust for solving: chokes on ADAM model...
            double krit = Math.Pow(Program.options.solve_newton_conv_abs, 2);  //0.0001^2 <=> no residual can be > 0.0001, for in that case RSS would be > krit = 0.0001^2
            //Ehm, RSS is divided by 2 now!
            int n = model.m2.fromEqNumberToBNumber.Length;

            IElementalAccessVector residuals = new DenseVector(n);
            IElementalAccessVector x0 = new DenseVector(n);

            int numericalProblem = -12345;
            do
            {
                //put all endogenous with no lag into x (vector of endogenous)
                for (int i = 0; i < model.m2.fromEqNumberToBNumber.Length; i++)
                {
                    x0.SetValue(i, b[model.m2.fromEqNumberToBNumber[i]]);
                }
                residuals = new DenseVector(n);
                numericalProblem = -12345;

                //Globals.timer.Start("RSS");
                double rss = rssFunction(out numericalProblem, residuals, x0, assembly);  //res are altered as a side-effect, x is unaltered - implicitly also calculates b array   //TODO: does this work with feedback?
                //Globals.timer.Stop("RSS");

                bool flag = false;
                if (numericalProblem != -12345)
                {
                    if (!flag) G.Writeln("+++ WARNING: starting values cause numerical errors");
                    flag = true;  //So we don't get the warning message more than once for each year
                    if (Globals.disableStartingValuesFix == 1)
                    {
                        G.Writeln2("*** ERROR: simulation is aborted");
                        return;
                    }
                    FixStartingValuesNumericalError(b, numericalProblem, assembly);
                }
            }
            while (numericalProblem != -12345);

            //residuals are altered as a side-effect, x is unaltered - implicitly also calculates b array

            //Globals.timer.Start("RSS");
            double rss0 = RSS(residuals, x0, assembly);
            //Globals.timer.Stop("RSS");

            double[] par = new double[n];
            for (int i1 = 0; i1 < n; i1++)
            {
                par[i1] = x0.GetValue(i1);
            }
            DfsaneSolver.Solve(par, assembly);

            //converged
            //simulateResults[0] = 123;
        }

        //TODO: Not strict regarding use of b[] -- actually puts result into Program.model.b[] via RSS(). These are typically the same, but what if not
        public static void SolveNewtonAlgorithm(double[] b, Type assembly, NewtonAlgorithmHelper nah)
        {
            //tries first intelligent jumping, and if it fails: normal mode
            //all this jumping around should be done in a proof-number kind of way.
            double[] bTemp = new double[Program.model.b.Length];
            Array.Copy(Program.model.b, bTemp, Program.model.b.Length);

            int iiMax = 2;

            bool printErrors = true;
            bool useIntelligent = false;

            for (int ii = 0; ii < iiMax; ii++)
            {
                if (ii == 0)
                {
                    useIntelligent = true;
                }

                if (ii == 1)
                {
                    if (Program.options.solve_print_details)
                    {
                        G.Writeln("--------------------------------------");
                        G.Writeln("First attempt failed, trying 1 last...");
                        G.Writeln("--------------------------------------");
                    }
                    useIntelligent = false;
                    Array.Copy(bTemp, Program.model.b, Program.model.b.Length);  //resetting
                }

                JacobiNull();  //mostly for safety, to make sure we do not have old stuff from other periods lying around

                double krit = Program.options.solve_newton_conv_abs * Program.options.solve_newton_conv_abs;  //0.0001^2 <=> no residual can be > 0.0001, for in that case RSS would be > krit = 0.0001^2
                //Ehm, RSS is divided by 2 now!
                int n = model.m2.fromEqNumberToBNumber.Length;

                if (Globals.solveScaleNewton)
                {
                    Globals.scaleNewtonValues = new double[n];
                }



                IElementalAccessVector residuals = new DenseVector(n);
                IElementalAccessVector x0 = new DenseVector(n);

                int numericalProblem = -12345;
                do
                {
                    //put all endogenous with no lag into x (vector of endogenous)
                    for (int i = 0; i < model.m2.fromEqNumberToBNumber.Length; i++)
                    {
                        x0.SetValue(i, b[model.m2.fromEqNumberToBNumber[i]]);
                    }
                    residuals = new DenseVector(n);
                    numericalProblem = -12345;

                    double rss = rssFunction(out numericalProblem, residuals, x0, assembly);  //res are altered as a side-effect, x is unaltered - implicitly also calculates b array   //TODO: does this work with feedback?

                    bool flag = false;
                    if (numericalProblem != -12345)
                    {
                        if (!flag)
                        {
                            G.Writeln("+++ WARNING: In period " + nah.t + " the starting values cause numerical errors");
                        }
                        flag = true;  //So we don't get the warning message more than once for each year
                        if (Globals.disableStartingValuesFix == 1)
                        {

                            G.Writeln2("*** ERROR simulating " + nah.tStart + "-" + nah.tEnd + ": in " + nah.t + " the Newton algorithm had starting value problems");
                            G.Writeln("+++ NOTE: You may try feeding the problem to the Gauss algorithm -- has better error handling facilitites");
                            throw new GekkoException();
                        }
                        FixStartingValuesNumericalError(b, numericalProblem, assembly);
                    }
                }
                while (numericalProblem != -12345);

                //residuals are altered as a side-effect, x is unaltered - implicitly also calculates b array

                IElementalAccessVector residualsBase = new DenseVector(residuals.Length);
                Blas.Default.Copy(residuals, residualsBase);

                if (Globals.solveScaleNewton)
                {
                    for (int i = 0; i < residuals.Length; i++)
                    {
                        double res = Math.Abs(residuals.GetValue(i));
                        if (res < 0.01d) Globals.scaleNewtonValues[i] = 1d;
                        else Globals.scaleNewtonValues[i] = 1d / res;
                    }
                }

                if (Globals.emitRCode)
                {
                    //using (FileStream fs=WaitForFileStream(Globals.localTempFilesLocation + "\\" + "R1.r",GekkoFileReadOrWrite.Write))
                    //using (StreamWriter res2 = new StreamWriter(fs)  <<<<< should append here
                    //{
                    //    res2.WriteLine("scale <- rep(NA," + Program.model.fromEqNumberToBNumberFeedbackNEW.Length + ")");
                    //    for (int i = 0; i < Program.model.fromEqNumberToBNumberFeedbackNEW.Length; i++)
                    //    {
                    //        res2.WriteLine("scale[" + (i + 1) + "] <- " + Globals.scaleNewtonValues[i]);
                    //    }
                    //}
                }

                RSS(residuals, x0, assembly);  //residuals are by-product (b[] also altered)
                double rss0 = RssNonScaled(residuals);

                if (Program.options.solve_print_details) G.Writeln("SQRT(RSS) start = " + Math.Sqrt(rss0) + " #residuals = " + residuals.Length);

                double[] residualsArray = new double[residuals.Length];
                //double[,] jacobiArray = PutJacobiIntoArray();

                int backTrackCounter = 0;
                int backTrackCounter2 = 0;

                int iterations = 0;
                if (rss0 > krit)  //else it is already converged
                {
                    for (int it = 0; it < int.MaxValue; it++)
                    {
                        iterations++;
                        if (iterations >= Program.options.solve_newton_itermax) AbortNewtonAlgorithm(nah, printErrors);

                        if (Program.options.solve_print_details) G.Writeln("SQRT(RSS) before iteration #" + it + " = " + Math.Sqrt(rss0), Color.Blue);

                        if (Globals.runningOnTTComputer)
                        {
                            double sum = 0d;
                            List<double> contribution = new List<double>();
                            int largest = -12345;
                            double largestValue = double.NegativeInfinity;
                            for (int i = 0; i < residuals.Length; i++)
                            {
                                double temp = residuals.GetValue(i) * residuals.GetValue(i);
                                sum += temp;
                                if (temp > largestValue)
                                {
                                    largestValue = temp;
                                    largest = i;
                                }
                                contribution.Add(temp);
                            }
                            if (largest >= 0)
                            {
                                double contributionLargest = contribution[largest] / sum;
                                int bnum = model.m2.fromEqNumberToBNumberFeedbackNEW[largest];
                                string var = model.varsBTypeInverted[bnum];
                                string var2 = "";
                                int lag = 0;
                                G.ExtractVariableAndLag(var, out var2, out lag);
                                if (Program.options.solve_print_details) G.Writeln("RSS: largest contribution is equation '" + var2 + "' (share of RSS = " + contributionLargest + ")");
                            }
                        }

                        DateTime t0 = DateTime.Now;
                        Jacobi(x0, assembly);

                        int e = 2; e = e - 1; if (e == 2)
                        {
                            StreamWriter w = new StreamWriter("b:\\j.mtx");
                            int nnn = Program.model.jacobiMatrixDense.GetLength(0);
                            int xsum = 0;
                            for (int i = 0; i < nnn; i++)
                            {
                                for (int j = 0; j < nnn; j++)
                                {
                                    double xx = Program.model.jacobiMatrixDense[i, j];
                                    if (xx != 0d)
                                    {
                                        xsum++;
                                    }
                                }
                            }
                            w.WriteLine("%%MatrixMarket matrix coordinate real general ");
                            w.WriteLine(n + "   " + n + "   " + xsum);
                            for (int i = 0; i < nnn; i++)
                            {
                                for (int j = 0; j < nnn; j++)
                                {
                                    double xx = Program.model.jacobiMatrixDense[i, j];
                                    if (xx != 0d)
                                    {
                                        w.WriteLine((i + 1) + "   " + (j + 1) + "   " + xx);
                                    }
                                }
                            }
                            w.Flush();
                            w.Close();
                        }

                        if (Program.options.solve_print_details)
                        {
                            if (Globals.runningOnTTComputer) G.Writeln("New " + residuals.Length + " Jacobi matrix constructed:" + (DateTime.Now - t0).TotalMilliseconds / 1000d + " seconds", Color.Orange);
                            else G.Writeln("New Jacobi " + residuals.Length + " matrix constructed:" + (DateTime.Now - t0).TotalMilliseconds / 1000d + " seconds");
                        }

                        IElementalAccessVector dx = new DenseVector(n);

                        t0 = DateTime.Now;
                        bool ok = InvertMatrix(residuals, dx);  //jacobyMatrix is also used
                        if (Program.options.solve_print_details)
                        {
                            if (Globals.runningOnTTComputer) G.Writeln("Jacobi " + residuals.Length + " matrix inverted: " + (DateTime.Now - t0).TotalMilliseconds / 1000d + " seconds", Color.Orange);
                            else G.Writeln("Jacobi " + residuals.Length + " matrix inverted: " + (DateTime.Now - t0).TotalMilliseconds / 1000d + " seconds");
                        }

                        if (ok == false)
                        {
                            if (ii == 0)
                            {
                                goto metaIt;
                            }
                            else
                            {
                                G.Writeln2("*** ERROR simulating " + nah.tStart + "-" + nah.tEnd + ": in " + nah.t + " the Newton algorithm stalled");
                                throw new GekkoException();
                            }
                        }

                        IElementalAccessVector x = new DenseVector(n);
                        Blas.Default.Add(x0, dx, x); //x = x0 + dx

                        RSS(residuals, x, assembly);  //residuals are by-product (b[] also altered)
                        double rss = RssNonScaled(residuals);

                        if (Program.options.solve_print_details) G.Writeln("iter = " + it + " SQRT(RSS) = " + Math.Sqrt(rss));

                        if (rss < krit)
                        {
                            break;
                        }

                        //TODO TODO
                        //TODO TODO
                        //TODO TODO #98075324
                        //TODO TODO

                        if (rss < rss0)
                        {

                            if (Globals.solveUseFastSteps == false)
                            {
                                Blas.Default.Copy(x, x0);
                                rss0 = rss;
                                goto newIt;
                            }

                            //successful newton step: try cheaper steps now (_a)
                            double rss0_a = rss;
                            IElementalAccessVector x0_a = new DenseVector(x);
                            for (int i = 0; i < int.MaxValue; i++)
                            {
                                iterations++;
                                if (iterations >= Program.options.solve_newton_itermax) AbortNewtonAlgorithm(nah, printErrors);

                                IElementalAccessVector dx_a = new DenseVector(n);

                                bool isOk = InvertMatrix(residuals, dx_a); //jacobyMatrix is also used

                                IElementalAccessVector x_a = new DenseVector(n);
                                Blas.Default.Add(x0_a, dx_a, x_a); //x_a = x0_a + dx_a

                                RSS(residuals, x_a, assembly);  //residuals are by-product (b[] also altered)
                                double rss_a = RssNonScaled(residuals);

                                if (Program.options.solve_print_details) G.Writeln("    fast iter (no jacobi update) = " + i + " SQRT(RSS) = " + Math.Sqrt(rss_a));
                                if (rss_a > rss0_a)
                                {
                                    Blas.Default.Copy(x0_a, x0);
                                    rss0 = rss0_a;
                                    break;  //no more of these fast iterations, do a proper one
                                }
                                if (i >= Program.options.solve_newton_updatefreq - 1)
                                {
                                    Blas.Default.Copy(x_a, x0);
                                    rss0 = rss_a;
                                    break;  //no more of these fast iterations, do a proper one
                                }
                                if (rss_a < krit)
                                {
                                    Blas.Default.Copy(x_a, x);
                                    rss0 = rss;
                                    goto converged;
                                }
                                Blas.Default.Copy(x_a, x0_a);
                                rss0_a = rss_a;
                            }

                            goto newIt;
                        }
                        //rss > rss0: rss did not diminish as it should: backtrack

                        if (rss > rss0)
                        {
                            if (useIntelligent && Program.options.solve_newton_backtrack == true && backTrackCounter2 >= 20)
                            {
                                //jump into unknown

                                iterations++;
                                if (iterations >= Program.options.solve_newton_itermax) AbortNewtonAlgorithm(nah, printErrors);

                                Jacobi(x, assembly);
                                IElementalAccessVector dx2 = new DenseVector(n);
                                bool ok2 = InvertMatrix(residuals, dx2);  //jacobyMatrix is also used
                                if (ok == false)
                                {
                                    if (ii == 0)
                                    {
                                        goto metaIt;
                                    }
                                    else
                                    {
                                        G.Writeln2("*** ERROR simulating " + nah.tStart + "-" + nah.tEnd + ": in " + nah.t + " the Newton algorithm stalled");
                                        throw new GekkoException();
                                    }
                                }
                                IElementalAccessVector x2 = new DenseVector(n);
                                Blas.Default.Add(x, dx2, x2); //x2 = x + dx2
                                IElementalAccessVector residuals2 = new DenseVector(n);
                                RSS(residuals2, x2, assembly);  //residuals are by-product (b[] also altered)
                                double rss2 = RssNonScaled(residuals2);

                                if (rss2 < rss0)
                                {
                                    if (Program.options.solve_print_details) G.Writeln("Did a successful jump to avoid backtracking");
                                    Blas.Default.Copy(x2, x0);
                                    rss0 = rss2;
                                    backTrackCounter2 = 0;
                                    goto newIt;
                                }
                                else
                                {
                                    //undo, revert jacobi (x and rss and dx are not touched, damping will follow if backtrack is set)
                                    //if (Program.options.solve_print) G.Writeln("jump fail", Color.Orange);
                                    Jacobi(x, assembly);
                                    //--------------------------------------------------------
                                    // It has been checked that this really undoes everything
                                    // relevant, so that search proceeds as if an intelligent
                                    // jump had not been tried out.
                                    // In the long run, the whole algorithm shold
                                    // be done without globals like jacobiMatrix and residuals.
                                    //--------------------------------------------------------
                                }
                            }
                        }

                        if (Program.options.solve_newton_backtrack == false)
                        {
                            Blas.Default.Copy(x, x0);
                            rss0 = rss;
                            goto newIt;
                        }

                        double rss_best = double.MaxValue;
                        IElementalAccessVector x_best = new DenseVector(n);
                        for (int lam = 0; lam < int.MaxValue; lam++)
                        {
                            double lambda = 1d / Math.Pow(2d, lam + 1d);

                            if (lambda < 0.01d)
                            {
                                backTrackCounter2++;
                            }

                            IElementalAccessVector dx_b = new DenseVector(dx);

                            Blas.Default.Scale(lambda, dx_b);

                            IElementalAccessVector x_b = new DenseVector(n);
                            Blas.Default.Add(x0, dx_b, x_b);

                            RSS(residuals, x_b, assembly);  //residuals are by-product (b[] also altered)
                            double rss_b = RssNonScaled(residuals);

                            if (rss_b < rss_best)
                            {
                                rss_best = rss_b;
                                Blas.Default.Copy(x_b, x_best);
                            }

                            if (Program.options.solve_print_details) G.Writeln("  lambda=" + lambda + " rss_b=" + Math.Sqrt(rss_b));

                            if (rss_b < rss0 && rss_b > rss_best)
                            {
                                Blas.Default.Copy(x_best, x0);
                                rss0 = rss_best;
                                break;
                            }
                            if (lambda < 1e-8)
                            {
                                backTrackCounter++;
                                if (backTrackCounter >= 6)
                                {
                                    if (ii == 0)
                                    {
                                        goto metaIt;
                                    }
                                    else
                                    {
                                        G.Writeln2("*** ERROR simulating " + nah.tStart + "-" + nah.tEnd + ": in " + nah.t + " Newton backtrack could not make further progress.");
                                        G.Writeln("    This may indicate that the problem is somehow misspecified, or some of the variables");
                                        G.Writeln("    may have very different scale.");
                                        throw new GekkoException();
                                    }
                                }

                                Blas.Default.Copy(x_b, x0);  //this gives a small perturbation

                                RSS(residuals, x0, assembly);  //residuals are by-product (b[] also altered)
                                rss0 = RssNonScaled(residuals);

                                break;
                            }
                        }
                    newIt: ;
                    }
                }
            converged: ;
                //converged
                Program.model.simulateResults[0] = iterations;
                Program.model.simulateResults[1] = Math.Sqrt(RssNonScaled(residuals));
                return;
            metaIt: ;
            }  //ii
        }

        //TODO: Not strict regarding use of b[] -- actually puts result into Program.model.b[] via RSS(). These are typically the same, but what if not
        public static void Linearize(List<int> isDampedPointers)
        {
            bool useDamp = true;
            //if (Globals.testing)
            //{
            //    Program.options.solve_gauss_damp = 1.00d;  //no damp
            //}

            Type assembly = Program.model.m2.assemblyGauss;
            if (assembly == null)
            {
                G.Writeln("No Gauss-Seidel module found");
                throw new GekkoException();
            }
            List<int> simul = Program.GetLeftsideBNumbers();

            Object[] args = new Object[2];
            args[0] = model.b;
            args[1] = model.simulateResults;

            int n = simul.Count;
            double delta = Globals.jacobiDeltaProbe;
            List<int> damp = new List<int>();
            if (useDamp) damp = isDampedPointers;  //set to true to see damp effect


            //bOriginal contains values corresponding to databank (possibly initialized lagged endogenous)
            double[] bOriginal = new double[model.b.Length];
            Array.Copy(model.b, bOriginal, model.b.Length);

            if (true)
            {
                Program.model.m2.assemblyPrologueEpilogue.InvokeMember("prologue", BindingFlags.InvokeMethod, null, null, args);
                RunOneGaussIterationWithDamping(damp, assembly, args, bOriginal);
            }

            //bNoShock contains values corresponding to running prologue followed by exactly 1 iteration (possibly with damping)
            double[] bNoShock = new double[model.b.Length];
            Array.Copy(model.b, bNoShock, model.b.Length);

            double[,] e = new double[n, n];

            for (int j = 0; j < simul.Count; j++)
            {
                Array.Copy(bOriginal, model.b, model.b.Length);

                EquationHelper eh = Program.model.equations[simul[j]];
                int bj = eh.bNumberLhs;
                model.b[bj] += delta;

                if (true)
                {
                    Program.model.m2.assemblyPrologueEpilogue.InvokeMember("prologue", BindingFlags.InvokeMethod, null, null, args);
                    RunOneGaussIterationWithDamping(damp, assembly, args, bOriginal);
                }

                for (int i = 0; i < simul.Count; i++)
                {
                    //int bi = simul[i];
                    EquationHelper eh2 = Program.model.equations[simul[i]];
                    int bi = eh2.bNumberLhs;
                    double grad = (model.b[bi] - bNoShock[bi]) / delta;
                    e[i, j] = grad;
                }
            }

            double[,] f = e;
            //double[] w = G.CreateArrayDouble(n, Program.options.solve_gauss_damp);

            if (n < 10)
            {
                G.Writeln("Matrix");
                for (int i = 0; i < n; i++)
                {
                    for (int j = 0; j < n; j++)
                    {
                        G.Write(e[i, j] + " ");
                    }
                    //G.Write("   " + b[i]);
                    G.Writeln();
                }
                G.Writeln();
            }

            double[] lambda = new double[n];
            double[] lambdai = new double[n];
            double[,] vl = new double[n, n];
            double[,] vr = new double[n, n];
            G.Writeln("Start finding eigen values");


            if (true)
            {
                StreamWriter w = new StreamWriter("b:\\data.txt");
                int iMax = 0;
                int jMax = 0;
                for (int i = 0; i < n; i++)
                {
                    for (int j = 0; j < n; j++)
                    {
                        if (f[i, j] != 0d)
                        {
                            w.WriteLine((i + 1) + " " + (j + 1) + " " + f[i, j]);
                            iMax = Math.Max(i, iMax);
                            jMax = Math.Max(j, jMax);
                        }
                    }
                }

                int min = Math.Min(iMax, jMax);
                for (int i = min + 1; i < n; i++)
                {
                    if (f[i, i] != 0) throw new GekkoException();  //should not be possible
                    w.WriteLine((i + 1) + " " + (i + 1) + " 1e-20");  //hack
                }

                w.Flush();
                w.Close();

                //Use new R-interface instead!
                //RSimpleInterface s = new RSimpleInterface("b:\\test1.r");
                ////should we try sparsematrix??
                //s.WriteLine("library(Matrix);");
                //s.WriteLine("x = scan('b:\\\\data.txt',what=list(integer(),integer(),numeric()));");
                //s.WriteLine("N= sparseMatrix(i=x[[1]],j=x[[2]],x=x[[3]]);");
                //s.WriteLine("f = matrix(N, " + n + ", " + n + ");");
                //s.WriteLine("evals <- eigen(f, only.values = TRUE)$values;");
                //s.WriteLine("evals;");
                //s.Execute();
            }





        }

        //TODO: Not strict regarding use of b[] -- actually puts result into Program.model.b[] via RSS(). These are typically the same, but what if not
        public static void LinearizeOLD_DELETE_AT_SOME_POINT()
        {

            ParserOLD.OrderAndCompileModel(ECompiledModelType.Newton, false, false);
            Type assembly = GetAssemblyFromModelType(ECompiledModelType.Newton);


            int n = model.m2.fromEqNumberToBNumberFeedbackNEW.Length;
            double delta = Globals.jacobiDeltaProbe;

            ////no, simulPrologue is recursive set, but it should be empty anyway...
            assembly.InvokeMember("simulPrologue", BindingFlags.InvokeMethod, null, null, new Object[] { model.b });
            model.r = new double[model.b.Length];
            SimulateResiduals(model.b, model.r, assembly);

            double[] bOriginal = new double[model.b.Length];
            Array.Copy(model.b, bOriginal, model.b.Length);
            double[] rOriginal = new double[model.r.Length];
            Array.Copy(model.r, rOriginal, model.r.Length);

            double[,] e = new double[n, n];

            int counter = -1;
            foreach (int j in model.m2.fromEqNumberToBNumberFeedbackNEW)
            {
                //G.Writeln(counter + "  " + j);
                counter++;
                int eq_j = model.m2.fromBNumberToEqNumberFeedbackNEW[j];
                model.b[j] += delta;

                ////no, simulPrologue is recursive set, but it should be empty anyway...
                assembly.InvokeMember("simulPrologue", BindingFlags.InvokeMethod, null, null, new Object[] { model.b });
                SimulateResiduals(model.b, model.r, assembly);

                foreach (int i in model.m2.fromEqNumberToBNumberFeedbackNEW)
                {
                    int eq_i = model.m2.fromBNumberToEqNumberFeedbackNEW[i];
                    double grad = (model.r[eq_i] - rOriginal[eq_i]) / delta;
                    double grad2;
                    if (eq_i == eq_j) grad2 = 1d - grad;
                    else grad2 = -grad;
                    //G.Writeln((i) + "," + (j) + "  " + grad2);
                    e[eq_i, eq_j] = grad2;

                }

                Array.Copy(bOriginal, model.b, model.b.Length);
                Array.Copy(rOriginal, model.r, model.r.Length);
            }

            double[,] f = new double[n, n];
            double[] w = G.CreateArrayDouble(n, Program.options.solve_gauss_damp);


            //FIXFIXFIX
            //FIXFIXFIX
            double[] b = new double[] { .12, .13, .14 };
            b = new double[n];
            //FIXFIXFIX
            //FIXFIXFIX


            bool gekkoWay = true;

            for (int i = 0; i < n; i++)
            {
                //rows
                for (int j = 0; j < n; j++)
                {
                    if (!gekkoWay)
                    {
                        //if (i < j)
                        //{
                        //    //upper
                        //    f[i, j] = e[i, j];
                        //}
                        //else if (i > j)
                        //{
                        //    //lower
                        //    double xx = e[i, j];
                        //    double sum = 0d;
                        //    for (int k = 0; k < n; k++)
                        //    {
                        //        double yy = xx * f[j, k];
                        //        sum += yy;
                        //    }
                        //    f[i, j] = sum;
                        //}
                        //else if (i == j)
                        //{
                        //    //diagonal
                        //    if (w[i] != 1d)
                        //    {
                        //        f[i, j] = 1d - w[i] + w[i] * e[i, j];
                        //    }
                        //    else
                        //    {
                        //        f[i, j] = e[i, j];
                        //    }
                        //}

                    }
                    else
                    {
                        if (i < j)
                        {
                            //upper
                            f[i, j] += e[i, j];
                        }
                        else if (i > j)
                        {
                            //lower
                            double eij = e[i, j];
                            if (eij != 0d)
                            {
                                for (int k = 0; k < n; k++)
                                {
                                    f[i, k] += eij * f[j, k];
                                }
                                b[i] += eij * b[j];
                            }
                        }
                        else if (i == j)
                        {
                            //diagonal
                            f[i, j] += e[i, j];
                        }
                    }
                }
            }

            //if (gekkoWay)
            //{

            //    for (int i = 0; i < n; i++)
            //    {
            //        for (int j = 0; j < n; j++)
            //        {
            //            f[i, j] = w[i] * f[i, j];
            //        }
            //        f[i, i] = f[i, i] + (1 - w[i]);
            //    }
            //}

            if (n < 10)
            {
                for (int i = 0; i < n; i++)
                {
                    for (int j = 0; j < n; j++)
                    {
                        G.Write(f[i, j] + " ");
                    }
                    G.Write("   " + b[i]);
                    G.Writeln();
                }
                G.Writeln();
            }

            //double[] lambda = new double[n];
            //double[] lambdai = new double[n];
            //double[,] vl = new double[n, n];
            //double[,] vr = new double[n, n];
            //G.Writeln("Start finding eigen values");
            ////Globals.deleteMe = f;
            //bool ok = alglib.nsevd.rmatrixevd(f, n, 0, ref lambda, ref lambdai, ref vl, ref vr);
            //G.Writeln("OK " + ok);
            //double largest = 0d;
            //for (int i = 0; i < lambda.Length; i++)
            //{
            //    double modulus = Math.Sqrt(lambda[i] * lambda[i] + lambdai[i] * lambdai[i]);
            //    G.Writeln(G.levelFormat(modulus, 10) + " " + G.levelFormat(lambda[i], 10) + " " + G.levelFormat(lambdai[i], 10));
            //    largest = Math.Max(largest, modulus);
            //}
            //G.Writeln("LARGEST LAMBDA = " + largest);
            //G.Writeln();

        }

        private static void AbortNewtonAlgorithm(NewtonAlgorithmHelper nah, bool printError)
        {
            if (printError)
            {

                G.Writeln2("*** ERROR simulating " + nah.tStart + "-" + nah.tEnd + ": in " + nah.t + " the maximum number of newton simulations (" + Program.options.solve_newton_itermax + ") was exceeded.");
                G.Writeln("    You may augment this number, see the Newton options: 'OPTION solve newton ...'");
            }
            throw new GekkoException();
        }

        public static double RssNonScaled(IElementalAccessVector residuals)
        {
            bool check = false;
            double rssNonScaled = 0d;
            double max = double.NegativeInfinity;
            int maxI = -12345;
            for (int i = 0; i < residuals.Length; i++)
            {
                double number = residuals.GetValue(i);
                if (false && G.isNumericalError(number))
                {
                    G.Writeln("NUM ERROR ---> " + model.varsBTypeInverted[Program.model.m2.fromEqNumberToBNumberFeedbackNEW[i]]);
                }
                double number2 = number * number;
                rssNonScaled += number2;
                if (number2 > max)
                {
                    max = number2;
                    maxI = i;
                }
            }

            if (check)
            {
                G.Writeln2("i = " + maxI + " " + max + " " + rssNonScaled + " " + max / rssNonScaled);
                G.Writeln("---> " + model.varsBTypeInverted[Program.model.m2.fromEqNumberToBNumberFeedbackNEW[maxI]]);
            }



            if (double.IsNaN(rssNonScaled)) rssNonScaled = double.MaxValue;  //should count as being worse than anything
            return rssNonScaled;
        }

        private static bool InvertMatrix(IElementalAccessVector residuals, IElementalAccessVector dx)
        {
            if (Program.options.solve_newton_invert == "lu")
            {
                //LU with reuse of factorization
                //Would be nice with sparse parallel LU solver!
                return InvertMatrixLU(residuals, dx);
            }
            else if (Program.options.solve_newton_invert == "iter")
            {
                //Uses an iterative sparse solver (Math.NET), with an LU-solver (alglib) as fallback
                //It seems to be tolerant with respect to equations like "x = x".
                //Problem is that solve of inverted matrix cannot be reused as in InvertMatrixLU(), to
                //use in fast Newton steps. Also, the iterative solver may not converge.
                return InvertMatrixSparseIter(residuals, dx);
            }
            else
            {
                G.Writeln2("*** ERROR: Strange error #793438734");
                throw new GekkoException();
            }
        }

        private static bool InvertMatrixSparseIter(IElementalAccessVector residuals, IElementalAccessVector dx)
        {
            double relCrit = Globals.invertRelativeConvergence;

            for (int i = 0; i < residuals.Length; i++)
            {
                double val = residuals.GetValue(i);
                if (double.IsNaN(val) || double.IsInfinity(val)) return false;
            }

            {
                for (int iter2 = 0; iter2 < 100; iter2++)
                {
                    if (Globals.solveUseOnlyDenseInverse == false)
                    {
                        DefaultLinearIteration iter = null;
                        try
                        {
                            //IElementalAccessVector gradient = new DenseVector(x.Length);
                            //Blas.Default.TransMult(jacobyMatrix, residuals, gradient);  //checked that it MUST be transposed -- else wrong
                            //ILinearSolver solver = new BiCGSolver();  //1.00, BiCG family supposed to be unstable
                            //ILinearSolver solver = new BiCGstabSolver(); //0.47, supposed to be unstable
                            //ILinearSolver solver = new CGSSolver();  //0.46, supposed to be unstable, should have double spped of BiCG, seems unstable
                            //ILinearSolver solver = new IRSolver();  //not conv
                            //ILinearSolver solver = new GMRESSolver();  //1.01, supposed to be stable
                            ILinearSolver solver = new QMRSolver();  //USED: 1.24, more robust versoin of BiCG

                            IPreconditioner M = new IdentityPreconditioner();
                            iter = new DefaultLinearIteration();

                            //playing with conv crits don't change too much regarding steps
                            iter.SetParameters(Globals.invertRelativeConvergence * Math.Pow(10, iter2), Globals.invertAbsoluteConvergence, 1e+5, Globals.invertIterations);  //first param is relative convergence, which is OR'ed with absolute convergence (which we keep pretty strict)

                            M.Setup(model.jacobiMatrix);
                            solver.Preconditioner = M;
                            solver.Iteration = iter;

                            double[] ans = null;

                            ans = Blas.Default.GetArrayCopy(solver.Solve(model.jacobiMatrix, residuals, dx));
                            if (Program.options.solve_print_details) G.Writeln("Matrix inversion took " + iter.IterationCount + " steps");

                            break; //no exception, so we are good to go
                        }
                        catch (Exception e)
                        {
                            if (Program.options.solve_print_details) G.Writeln("Matrix inversion took " + iter.IterationCount + " steps");
                        }
                    }


                    if (Globals.solveUseOnlySparseInverse == false)
                    {
                        {
                            if (Program.options.solve_print_details) G.Writeln("Sparse matrix inversion failed, trying dense matrix inversion (slower)");
                            double[] b = new double[residuals.Length];
                            double[] x = new double[residuals.Length];
                            double[,] a = PutJacobiIntoArray();
                            for (int i = 0; i < residuals.Length; i++)
                            {
                                b[i] = residuals.GetValue(i);
                            }
                            int info = 0;
                            alglib.densesolver.densesolverreport rep = new alglib.densesolver.densesolverreport();
                            //old version below, with some ref
                            //alglib.densesolver.rmatrixsolve(ref a, b.Length, ref b, ref info, ref rep, ref x);
                            //MessageBox.Show("Test that the new alglib method gives the same");
                            alglib.densesolver.rmatrixsolve(a, b.Length, b, ref info, rep, ref x);
                            if (info != 1)
                            {
                                //if (false)  //it seems that rmatrixsolvels can stall completely, never returning from a loop.
                                //{           //providing a timer for it might be a solution, but for now it is switched off. So
                                //    //if the sparse solver does not work, we try the normal alglib solver, but not the
                                //    //least-squares solver. Often the values from the sparse solver are ok to continue
                                //    //with, even though it throws an exception.
                                //    int infols = 0;
                                //    if (Program.options.solve_print_details) G.Writeln("Problem with dense matrix inversion, trying less strict crits");
                                //    alglib.densesolver.densesolverlsreport repls = new alglib.densesolver.densesolverlsreport();
                                //    alglib.densesolver.rmatrixsolvels(ref a, b.Length, b.Length, ref b, 0d, ref infols, ref repls, ref x);
                                //    if (infols != 1)
                                //    {
                                //        if (Program.options.solve_print_details) G.Writeln("Could not perform dense matrix inversion, using result from sparse matrix inversion");
                                //    }
                                //    else
                                //    {
                                //        for (int i = 0; i < x.Length; i++)
                                //        {
                                //            dx.SetValue(i, x[i]);
                                //        }
                                //        break;  //we are good
                                //    }
                                //}
                            }
                            else
                            {
                                for (int i = 0; i < x.Length; i++)
                                {
                                    dx.SetValue(i, x[i]);
                                }
                                break;  //we are good
                            }
                        }
                    }
                }  //iterations
            }

            Blas.Default.Scale(-1d, dx);  //the direction is NEGATIVE!
            //dx is Newton direction
            return true;
        }

        private static bool InvertMatrixLU(IElementalAccessVector residuals, IElementalAccessVector dx)
        {
            int n = residuals.Length;
            for (int i = 0; i < residuals.Length; i++)
            {
                double val = residuals.GetValue(i);
                if (double.IsNaN(val) || double.IsInfinity(val)) return false;
            }

            double[,] lu = null;
            int[] indx;
            if (Program.model.jacobiMatrixInvertedIndex == null)
            {
                //lu = new double[n, n];
                if (Program.model.jacobiMatrixInverted == null) Program.model.jacobiMatrixInverted = new double[n, n];  //The very first time this method is called, the array will be null
                Array.Copy(Program.model.jacobiMatrixDense, Program.model.jacobiMatrixInverted, Program.model.jacobiMatrixDense.Length);
                lu = Program.model.jacobiMatrixInverted;
                indx = new int[n];  //this one is not recycled like jacobiMatrixInverted, to add some security that we are not mistakenly using old stuff from previous periods etc.
                LUDecompose(ref lu, ref indx);
                Program.model.jacobiMatrixInvertedIndex = indx;
            }
            else
            {
                lu = Program.model.jacobiMatrixInverted;
                indx = Program.model.jacobiMatrixInvertedIndex;
            }

            double[] b = new double[residuals.Length];
            for (int i = 0; i < residuals.Length; i++)
            {
                b[i] = residuals.GetValue(i);
            }

            double[] x = new double[residuals.Length];
            Solve(ref b, ref x, indx, lu);

            for (int i = 0; i < x.Length; i++)
            {
                dx.SetValue(i, x[i]);
            }

            Blas.Default.Scale(-1d, dx);  //the direction is NEGATIVE!
            //dx is Newton direction
            return true;
        }

        public static double[,] PutJacobiIntoArray()
        {
            double[,] a = new double[model.jacobiMatrix.RowCount, model.jacobiMatrix.ColumnCount];
            for (int i = 0; i < model.jacobiMatrix.RowCount; i++)
            {
                for (int j = 0; j < model.jacobiMatrix.ColumnCount; j++)
                {
                    a[i, j] = model.jacobiMatrix.GetValue(i, j);
                }
            }
            return a;
        }

        private static double RSS(IElementalAccessVector residuals, IElementalAccessVector x, Type assembly)
        {
            int numericalProblem = -12345;
            double f = double.PositiveInfinity;

            if (true)
            {
                //This puts vector x (the feedback variables) into the corresponding b[] slots
                for (int i = 0; i < model.m2.fromEqNumberToBNumber.Length; i++)
                {
                    model.b[model.m2.fromEqNumberToBNumber[i]] = x.GetValue(i);
                }
                Object[] args = new Object[1];
                args[0] = Program.model.b;
                //This simulates the recursive part of the simultaneous block, where the right values (vector x)
                //regarding the feedback variables are needed in b[]
                assembly.InvokeMember("simulPrologue", BindingFlags.InvokeMethod, null, null, args);

                numericalProblem = -12345;
                model.r = new double[model.m2.fromEqNumberToBNumber.Length];
                SimulateResiduals(model.b, model.r, assembly);  //residuals in the feedback equations
                //y er residualer, mens x er endogene
                for (int i = 0; i < model.m2.fromEqNumberToBNumber.Length; i++)
                {
                    if (G.isNumericalError(model.r[i]))
                    {
                        numericalProblem = i;
                    }
                    residuals.SetValue(i, model.r[i]);
                }
                f = 0d;
                for (int i = 0; i < residuals.Length; i++)
                {
                    double number = residuals.GetValue(i);
                    f += number * number;
                }

            }

            return f;
        }

        private static void FixStartingValuesNumericalError(double[] b, int numericalProblem, Type assembly)
        {
            //DOES NOT WORK WITH FEEDBACK!!!

            //Starting values for endogenous cause numerical problems
            //we must try to find a region where all residuals given the endogenous
            //are valid.
            //Label1:;
            double[] endoValuesStart = new double[model.m2.sparseInfo[numericalProblem].Count];
            for (int iii = 0; iii < model.m2.sparseInfo[numericalProblem].Count; iii++)
            {
                //Remember starting values for endogenous
                int endo = model.m2.sparseInfo[numericalProblem][iii];
                if (b[endo] == 0)
                {
                    //could just as well have been 1d, but we choose 0.001d.
                    b[endo] = Globals.newtonSmallNumber;
                }
                endoValuesStart[iii] = b[endo];
            }

            for (int s1 = 0; s1 < int.MaxValue; s1++)
            {
                //s1 is used for a sequence, 2,4,8, ...
                for (int s2 = 0; s2 < 4; s2++)
                {
                    //s2 is used to switch sign and reciprocity
                    double ss = Math.Pow(Globals.newtonStartingValueProblemSearchParameter, (double)s1 + 1d);
                    if (s2 == 1)
                    {
                        ss = -ss;
                    }
                    else if (s2 == 2)
                    {
                        ss = 1 / ss;
                    }
                    else if (s2 == 3)
                    {
                        ss = -1 / ss;
                    }
                    for (int iii = 0; iii < model.m2.sparseInfo[numericalProblem].Count; iii++)
                    {
                        int endo = model.m2.sparseInfo[numericalProblem][iii];
                        b[endo] = endoValuesStart[iii] * ss;
                        SimulateResidual(b, model.r, numericalProblem, assembly);
                        if (!G.isNumericalError(model.r[numericalProblem]))
                        {
                            return;
                        }
                        b[endo] = endoValuesStart[iii];
                    }
                }
            }
        }


        /// <summary>
        /// Solve by means of Gauss-Seidel method
        /// </summary>
        /// <param name="b">Array with variables</param>
        /// <param name="simulateResults">Results</param>
        /// <param name="culprit">Last variable to converge</param>
        public static void SolveGauss(bool ftOrNft, double[] b, List<int> isDampedPointers, int[] isDampedPointersArray, out string culprit, ECompiledModelType modelType, GekkoTime t, Dictionary<int, int> checkoff)
        {
            List<IterMemory> iterMemories = null;

            if (Program.options.solve_gauss_dump)
            {
                iterMemories = new List<IterMemory>();
                if (ftOrNft)
                {
                    G.Writeln2("*** ERROR: 'OPTION solve gauss dump' cannot be set while doing Fair-Taylor (would exhaust memory)");
                    throw new GekkoException();
                }
                Program.model.bMemory.Add(t.ToString(), iterMemories);
            }

            DateTime t0 = DateTime.Now;

            Type assembly = GetAssemblyFromModelType(modelType);

            //This should never happen, since FIX sets Newton algo, and if FIX is not set, Gauss algo
            //is fine even if there are endo/exo
            //if (Program.model.endogenized.Count != 0 || Program.model.exogenized.Count != 0)
            //{
            //    G.Writeln("+++ ERROR: There are ENDO/EXO variables set. You should clear the goals,");
            //    G.Writeln("           or use the Newton algorithm ('OPTION solve method = newton').", Color.Red);
            //    throw new GekkoException();
            //}

            culprit = "";
            Object[] args = new Object[1];
            args[0] = b;

            //HACK, fixme, todo, NEVER for RES-type simulation
            if (model.m2.endogenous.ContainsKey("qJzdk"))
            {
                Globals.convergenceCheckVariables = new string[] { "qJzdk" };  //emma
            }
            else if (model.m2.endogenous.ContainsKey("ys1"))
            {
                Globals.convergenceCheckVariables = new string[] { "ys1" };  //adam
            }
            else if (model.m2.endogenous.ContainsKey("fcb"))
            {
                Globals.convergenceCheckVariables = new string[] { "fcb" };  //adam
            }
            else if (model.m2.endogenous.ContainsKey("e__wn_mz"))  //saffier model
            {
                Globals.convergenceCheckVariables = new string[] { "e__wn_mz" };
            }

            int varId = -12345;
            string var = Globals.convergenceCheckVariables[0];

            //BTypeData ti = (BTypeData)model.varsBType[var + Globals.lagIndicator + "0"];
            BTypeData ti = null; model.varsBType.TryGetValue(var + Globals.lagIndicator + "0", out ti);
            if (ti == null)
            {
                if (Globals.mayPrintConvergenceCheckVariableMissing == true)
                {
                    //G.Writeln("+++ WARNING: " + var + " does not exist for convergence check");
                    //Globals.mayPrintConvergenceCheckVariableMissing = false;
                }
            }
            else
            {
                varId = ti.bNumber;
            }

            if (Globals.fastGauss)
            {
                if (modelType == ECompiledModelType.GaussFailSafe)
                {
                    Program.model.simulateResults[1] = 0;
                    Program.model.m2.assemblyPrologueEpilogueFailSafe.InvokeMember("prologue", BindingFlags.InvokeMethod, null, null, args);
                }
                else
                {
                    Program.model.simulateResults[1] = 0;
                    Program.model.m2.assemblyPrologueEpilogue.InvokeMember("prologue", BindingFlags.InvokeMethod, null, null, args);
                }

                if (Program.model.simulateResults[1] == 12345)
                {
                    Program.model.simulateResults[0] = 0;  //no iteration has been done yet
                    return;  //failsafe fast return
                }
            }

            int iterCounter = 0;

            int convType = 1;
            if (G.equal(Program.options.solve_gauss_conv, "conv2")) convType = 2;

            int culprit2 = -12345;
            if (iterCounter < Program.options.solve_gauss_itermax && (Globals.solveUseStrictCrits || varId == -12345))
            {
                System.Array.Copy(b, model.bOld, b.Length);  //seems quite fast -- and simplifies damping etc.
                bool probing1Variable = true;  //does not seem to give any significant speedup... hmm
                if (varId == -12345) probing1Variable = false;  //if the var name is not found

                for (int i = 0; i < int.MaxValue; i++)
                {
                    IterMemory iterMemory = null;

                    iterCounter++;
                    Program.model.simulateResults[1] = 0;

                    if (Program.options.solve_gauss_dump)
                    {
                        iterMemory = new IterMemory();
                        try
                        {
                            iterMemory.bBefore = new double[b.Length];
                        }
                        catch (Exception e)
                        {
                            G.Writeln2("*** ERROR: Out of memory -- please run for fewer years with option 'dump'");
                            G.Writeln("           The dump option is quite memory-intensive, since it remembers all", Color.Red);
                            G.Writeln("           intermediate simulation values.", Color.Red);
                            throw new GekkoException();
                        }
                        System.Array.Copy(b, iterMemory.bBefore, b.Length);
                    }

                    try
                    {
                        RunOneGaussIterationWithDamping(isDampedPointers, assembly, args, model.bOld);
                    }
                    catch
                    {
                        throw;
                    }
                    finally
                    {
                        if (Program.options.solve_gauss_dump)
                        {
                            try
                            {
                                iterMemory.bAfter = new double[b.Length];
                            }
                            catch (Exception e)
                            {
                                G.Writeln2("*** ERROR: Out of memory -- please run for fewer years with option 'dump'");
                                G.Writeln("           The dump option is quite memory-intensive, since it remembers all", Color.Red);
                                G.Writeln("           intermediate simulation values.", Color.Red);
                                throw new GekkoException();
                            }
                            System.Array.Copy(b, iterMemory.bAfter, b.Length);
                            iterMemories.Add(iterMemory);
                        }
                    }

                    if (Program.model.simulateResults[1] == 12345)
                    {
                        Program.model.simulateResults[0] = iterCounter;
                        return;  //failsafe fast return
                    }

                    if (iterCounter >= Program.options.solve_gauss_itermax) break;

                    if (iterCounter < Program.options.solve_gauss_itermin)
                    {
                        System.Array.Copy(b, model.bOld, b.Length);
                        continue;
                    }

                    bool converged = true;

                    if (probing1Variable)
                    {
                        double abs; double rel1; double rel2;
                        converged = GaussConvergenceOk(false, false, isDampedPointersArray, b[varId], model.bOld[varId], varId, true, convType, out abs, out rel1, out rel2);
                        if (converged == false)
                        {
                            culprit2 = varId;
                        }
                    }
                    else
                    {
                        //int ii = 0;
                        foreach (int j in Program.model.endogenousBNumbersOriginalInModelList)
                        {
                            //ii++;
                            if (checkoff.ContainsKey(j))
                            {
                                //do nothing
                            }
                            else
                            {
                                double abs; double rel1; double rel2;
                                bool good = GaussConvergenceOk(false, false, isDampedPointersArray, b[j], model.bOld[j], j, false, convType, out abs, out rel1, out rel2);
                                if (good == false)
                                {
                                    culprit2 = j;
                                    converged = false;
                                    //G.Write(" ii" + ii + " ");
                                    break;
                                }
                            }
                        }
                        //G.Writeln("real " + iterCounter + " result " + converged);
                    }

                    if (converged == true && probing1Variable == true)  //done with probe
                    {
                        converged = false;
                        probing1Variable = false;
                        Program.model.simulateResults[2] = culprit2;  //probably irrelevant
                        Program.model.simulateResults[3] = iterCounter;
                        //G.Writeln("shifting");
                        //continue iterating, and now check all variables (may cost 1 superfluous iteration, but never mind)
                    }


                    if (converged == true)  //done with all simulation: SUCCESS
                    {
                        Program.model.simulateResults[2] = culprit2;
                        Program.model.simulateResults[4] = iterCounter;
                        break;  //no more iterations
                    }

                    //G.Writeln("continuing");
                    //not converged if we get here
                    System.Array.Copy(b, model.bOld, b.Length);
                }
            }

            if (culprit2 == -12345)
            {
                culprit = "";
            }
            else
            {
                if (false)  //This stuff is just not working. Try a newton first, and then switch to gauss --> errors
                {
                    try
                    {
                        culprit = G.FromBNumberToVarname(culprit2);
                    }
                    catch
                    {
                        //??? WHY IS THIS NOT A PROBLEM?
                    };
                }

            }

            //reverted equations (J-factors and so on)

            if (Globals.fastGauss)
            {
                if (false && modelType == ECompiledModelType.GaussFailSafe)
                {
                    //This is switched off. Often it is ok that epilogue variables produce missing values.
                    //The model can be deemed converged quite ok, and still have som epilogue variables
                    //with division 0 etc. The difference is that if a prologue or simultaneous variable
                    //produces a missing, and the simulations are continued, the result is that ALL
                    //simultanous variables end up with missing values.
                    //TODO: Maybe the failsafe option should just count how many missings are produced
                    //      and report it.
                    //simulateResults[1] = 0;
                    //Program.model.m2.assemblyCommonFailSafe.InvokeMember("epilogue", BindingFlags.InvokeMethod, null, null, args);
                }
                else
                {
                    //if failsafe is on, this is run without failsafe -- and may produce some missing values!
                    Program.model.simulateResults[1] = 0;
                    Program.model.m2.assemblyPrologueEpilogue.InvokeMember("epilogue", BindingFlags.InvokeMethod, null, null, args);
                }
                if (Program.model.simulateResults[1] == 12345)
                {
                    Program.model.simulateResults[0] = iterCounter;
                    return;  //failsafe fast return
                }
            }

            if (modelType == ECompiledModelType.GaussFailSafe)
            {
                Program.model.assemblyRevertedFailSafe.InvokeMember("revertedAuto", BindingFlags.InvokeMethod, null, null, args);
                Program.model.assemblyRevertedFailSafe.InvokeMember("revertedY", BindingFlags.InvokeMethod, null, null, args);
            }
            else
            {
                Program.model.assemblyReverted.InvokeMember("revertedAuto", BindingFlags.InvokeMethod, null, null, args);
                Program.model.assemblyReverted.InvokeMember("revertedY", BindingFlags.InvokeMethod, null, null, args);
            }
            Program.model.simulateResults[0] = iterCounter;
        }

        private static void RunOneGaussIterationWithDamping(List<int> isDampedPointers, Type assembly, Object[] args, double[] bOld)
        {
            double[] b = (double[])args[0];
            //double[] simulateResults = (double[])args[1];
            assembly.InvokeMember("eqs", BindingFlags.InvokeMethod, null, null, args);
            if (Program.model.simulateResults[1] != 12345)
            {
                //Do not damp if the iteration just failed -- that will just pollute the results.
                //It is in that case better to keep the results excactly as they were when returning
                //from the assembly (these results will later on in the Sim() method be written
                //back to timerseries.
                DampVariables(b, bOld, isDampedPointers);
            }
        }

        private static bool GaussConvergenceOk(bool isFairTaylor, bool isNewtonFairTaylor, int[] isDampedPointersArray, double bj, double bOldj, int j, bool factor, int convType, out double abs, out double rel1, out double rel2)
        {

            //rel1 will be the rel crit using historical variance, whereas rel2 will always return double.NaN.

            //!!If something is changed here, remember to change in Itershow() also

            double dampingCorrection = 1d;
            if (!(isFairTaylor || isNewtonFairTaylor) && isDampedPointersArray[j] == 1)  //if array is null, it is because it is a Fair-Taylor check, where Gauss damping is abstracted away (Fair-Taylor has its own damping)
            {
                dampingCorrection = 1d / (1d - Program.options.solve_gauss_damp); //must multiply difference with this for damped variables, otherwise they look too good!
            }

            abs = double.NaN; rel1 = double.NaN; rel2 = double.NaN;
            if (convType == 1)
            {
                double historicalVariance = Program.model.bVariance[j];
                double absCrit = Program.options.solve_gauss_conv1_abs;
                double relCrit = Program.options.solve_gauss_conv1_rel;
                if (isFairTaylor)
                {
                    absCrit = Program.options.solve_forward_fair_conv1_abs;
                    relCrit = Program.options.solve_forward_fair_conv1_rel;
                }
                else if (isNewtonFairTaylor)
                {
                    absCrit = Program.options.solve_forward_nfair_conv1_abs;
                    relCrit = Program.options.solve_forward_nfair_conv1_rel;
                }
                double valNew = bj;
                double valOld = bOldj;
                //this looks at historical differences from period to period in order to judge whether a deviation between
                //values is 'small' or 'large'
                double relative = double.NaN;
                bool good = CheckRelativeDifferenceSmart(dampingCorrection, factor, historicalVariance, absCrit, relCrit, valNew, valOld, out relative);
                rel1 = relative;
                return good;
            }
            else if (convType == 2)  //the PCIM way
            {
                double x = Math.Abs(bOldj);
                double absolute = Math.Abs(bj - bOldj) * dampingCorrection; //for damped variables, this gives the "true" non-damped difference between iterations
                double relative = absolute / x;
                if (G.isNumericalError(relative))  //happens when historicalVariance = 0
                {
                    if (Math.Abs(bOldj) == 0d) relative = 0d;  //  0/0
                    else relative = double.PositiveInfinity;     //  x/0
                }
                bool good = false;
                if (factor)
                {
                    absolute = 2d * absolute;
                    relative = 2d * relative;
                }

                double tabs = Program.options.solve_gauss_conv2_tabs;
                double trel = Program.options.solve_gauss_conv2_trel;
                if (isFairTaylor)
                {
                    tabs = Program.options.solve_forward_fair_conv2_tabs;
                    trel = Program.options.solve_forward_fair_conv2_trel;
                }
                else if (isNewtonFairTaylor)
                {
                    tabs = Program.options.solve_forward_nfair_conv2_tabs;
                    trel = Program.options.solve_forward_nfair_conv2_trel;
                }

                if (x < tabs)
                {
                    //always ignore variables with a level < 1.0
                    good = true;
                }
                else
                {
                    if (relative < trel)
                    {
                        //good if relaive change is < 0.0001
                        good = true;
                    }
                    else
                    {
                        good = false;
                    }
                };
                return good;
            }
            else
            {
                G.Writeln2("*** ERROR: #98349834");
                throw new GekkoException();
            }
        }

        private static bool CheckRelativeDifferenceSmart(double dampingCorrection, bool factor, double historicalVariance, double absCrit, double relCrit, double valNew, double valOld, out double rel1)
        {
            rel1 = double.NaN;
            double histVar = historicalVariance;
            if (histVar == -12345d)
            {
                G.Writeln2("*** ERROR: hist variance");
                throw new GekkoException();
            }
            if (histVar == double.NaN)
            {
                //fortunetely this is quite seldom, and the line below means relative check gets completely switched off...
                histVar = double.MaxValue;
            }
            double absolute = Math.Abs(valNew - valOld) * dampingCorrection; //for damped variables, this gives the "true" non-damped difference between iterations
            double relative = absolute / histVar;  //denominator is always >= 0, or positive infinity or NaN
            if (G.isNumericalError(relative))  //happens when historicalVariance = 0
            {
                relative = double.MaxValue;  //same as saying relative crit MUST be met.
                //if so, we have 0/0 = NaN or x/0 = inf.
                //the first one could be deemed ok, but it will be ok by absolute crit anyway.
                //then we need to meet the absolute crit instead
                //maybe this is bad for some large variables, could alternatively
                //ignore the variable altogether
            }
            bool good = false;
            if (factor)
            {
                absolute = 2d * absolute;
                relative = 2d * relative;
            }
            if (absolute < absCrit || relative < relCrit)
            {
                good = true;
            }
            else
            {
                good = false;
            };
            rel1 = relative;  //rel1 is returned
            return good;
        }


        /// <summary>
        /// Solve by means of Gauss-Seidel method
        /// </summary>
        /// <param name="b">Array with variables</param>
        /// <param name="simulateResults">Results</param>
        /// <param name="culprit">Last variable to converge</param>
        public static void SolveRes(double[] b)
        {
            Type assembly = GetAssemblyFromModelType(ECompiledModelType.Res);
            Object[] args = new Object[1];
            args[0] = b;
            assembly.InvokeMember("eqs", BindingFlags.InvokeMethod, null, null, args);
        }

        private static void DampVariables(double[] b, double[] bOld, List<int> isDampedPointers)
        {
            foreach (int bNumber in isDampedPointers)
            {
                // NOTE NOTE NOTE NOTE: Damping is redefined in Gekko 2.0: dampNew = 1-dampOld
                double alfa = 1d - Program.options.solve_gauss_damp;  //it is 0.5 per default <=> halfways between new and old value.
                //in PCIM, the default value for alfa is 1.0 <=> no damping at all
                //the smaller alfa is, the harder the damping
                //if alfa were set to 0, there would be no progress at all
                double bNew = alfa * b[bNumber] + (1 - alfa) * bOld[bNumber];
                if (G.isNumericalError(bNew))
                {
                    //if this is so, should we keep the old value? or the new value?
                    //Console.WriteLine();
                }
                b[bNumber] = bNew;
            }
        }

        private static void PrintIterationVariables(double[] b, string[] vars, int iterCounter)
        {
            if (vars == null) return;
            if (vars.Length == 0) return;
            if (true)
            {
                G.Writeln();
                foreach (string var5 in vars)
                {
                    BTypeData temp = (BTypeData)model.varsBType[var5 + Globals.lagIndicator + "0"];
                    int tem2 = temp.bNumber;
                    double num = b[tem2];
                    G.Writeln(iterCounter + "  " + var5 + " = " + num);
                }
                G.Writeln();
            }
        }

        private static Type GetAssemblyFromModelType(ECompiledModelType modelType)
        {
            Type assembly = null;
            if (modelType == ECompiledModelType.Res)
            {
                assembly = model.m2.assemblyRes;
            }
            else if (modelType == ECompiledModelType.Gauss)
            {
                assembly = model.m2.assemblyGauss;
            }
            else if (modelType == ECompiledModelType.GaussFailSafe)
            {
                assembly = model.m2.assemblyGaussFailSafe;
            }
            else if (modelType == ECompiledModelType.Newton)
            {
                assembly = model.m2.assemblyNewton;
            }
            //else if (modelType == ECompiledModelType.After)
            //{
            //    assembly = model.m2.assemblyReverted;
            //}
            else throw new GekkoException();
            return assembly;
        }

        public static void SimulateResiduals(double[] b, double[] r, Type assembly)
        {
            Object[] args = new Object[3];
            args[0] = b;
            args[1] = r;
            args[2] = Globals.scaleNewtonValues;
            assembly.InvokeMember("simulFeedbackAll", BindingFlags.InvokeMethod, null, null, args);
            return;
        }

        public static void SimulateResidual(double[] b, double[] r, int n, Type assembly)
        {
            Object[] args = new Object[4];
            args[0] = b;
            args[1] = r;
            args[2] = n;
            args[3] = Globals.scaleNewtonValues;
            assembly.InvokeMember("simulFeedbackSingle", BindingFlags.InvokeMethod, null, null, args);
            return;
        }


        //The model's residuals (y) depend upon the values of the endogenous (x),
        //for each year simulated (same number of y and x).
        public static int runModel(IElementalAccessVector y, IElementalAccessVector x, Type assembly)
        {
            int numericalProblem = -12345;
            //y er residualer, mens x er endogene
            for (int i = 0; i < model.m2.fromEqNumberToBNumber.Length; i++)
            {
                model.b[model.m2.fromEqNumberToBNumber[i]] = x.GetValue(i);
            }

            model.r = new double[model.m2.fromEqNumberToBNumber.Length];
            SimulateResiduals(model.b, model.r, assembly);

            //y er residualer, mens x er endogene
            for (int i = 0; i < model.m2.fromEqNumberToBNumber.Length; i++)
            {
                if (G.isNumericalError(model.r[i]))
                {
                    numericalProblem = i;
                }
                y.SetValue(i, model.r[i]);
            }
            return numericalProblem;  //problem identifies if there is an inf or NaN (-12345 means no problem)
        }

        public static void Jacobi(IElementalAccessVector x, Type assembly)
        {
            JacobiNull();
            int n = x.Length;

            double delta = Globals.jacobiDeltaProbe;  //must be small enough for an endogenous var
            //cannot be less than this! --> else errors
            //TODO: have a specific delta for each endogenous, based on history

            bool lu = (Program.options.solve_newton_invert == "lu");
            if (lu)
            {
                Program.model.jacobiMatrixDense = new double[n, n];
            }
            else
            {
                Program.model.jacobiMatrix = new SparseRowMatrix(n, n, 5);  //seems faster
            }

            assembly.InvokeMember("simulPrologue", BindingFlags.InvokeMethod, null, null, new Object[] { model.b });
            SimulateResiduals(model.b, model.r, assembly);

            double[] bOriginal = new double[model.b.Length];
            Array.Copy(model.b, bOriginal, model.b.Length);
            double[] rOriginal = new double[model.r.Length];
            Array.Copy(model.r, rOriginal, model.r.Length);

            int counter = -1;
            foreach (int j in model.m2.fromEqNumberToBNumberFeedbackNEW)
            {
                counter++;
                int eq_j = model.m2.fromBNumberToEqNumberFeedbackNEW[j];
                model.b[j] += delta;

                assembly.InvokeMember("simulPrologue", BindingFlags.InvokeMethod, null, null, new Object[] { model.b });
                SimulateResiduals(model.b, model.r, assembly);

                foreach (int i in model.m2.fromEqNumberToBNumberFeedbackNEW)
                {
                    int eq_i = model.m2.fromBNumberToEqNumberFeedbackNEW[i];
                    double grad = (model.r[eq_i] - rOriginal[eq_i]) / delta;
                    if (grad != 0d)
                    {
                        if (lu)
                        {
                            Program.model.jacobiMatrixDense[eq_i, eq_j] = grad;
                        }
                        else
                        {
                            Program.model.jacobiMatrix.SetValue(eq_i, eq_j, grad);
                        }
                    }
                }

                Array.Copy(bOriginal, model.b, model.b.Length);
                Array.Copy(rOriginal, model.r, model.r.Length);
            }
        }

        public static double[,] MultiplyMatrices(double[,] x, double[,] y)
        {
            //  1 2
            //  3 4     5 6 7 8       -->   3x2 * 2x4 = 3x4
            //  5 6     8 9 8 5
            //
            int xRows = x.GetLength(0);
            int xCols = x.GetLength(1);
            int yRows = y.GetLength(0);
            int yCols = y.GetLength(1);
            if (xCols != yRows)
            {
                G.Writeln2("*** ERROR: Matrices do not conform for multiplication");
                throw new GekkoException();
            }
            double[,] z = new double[xRows, yCols];
            for (int i = 0; i < xRows; i++)
            {
                for (int j = 0; j < yCols; j++)
                {
                    double sum = 0d;
                    for (int k = 0; k < xCols; k++)
                    {
                        sum += x[i, k] * y[k, j];
                    }
                    z[i, j] = sum;
                }
            }
            return z;
        }

        //public static double[,] MultiplyMatrix(double[,]a, double[,]b)
        //{
        //    double[,] c = null;
        //    if (a.GetLength(1) == b.GetLength(0))
        //    {
        //        c = new double[a.GetLength(0), b.GetLength(1)];
        //        for (int i = 0; i < c.GetLength(0); i++)
        //        {
        //            for (int j = 0; j < c.GetLength(1); j++)
        //            {
        //                c[i, j] = 0;
        //                for (int k = 0; k < a.GetLength(1); k++) // OR k<b.GetLength(0)
        //                    c[i, j] = c[i, j] + a[i, k] * b[k, j];
        //            }
        //        }
        //    }
        //    else
        //    {
        //        G.Writeln2("*** ERROR: Number of columns in First Matrix should be equal to Number of rows in Second Matrix.");
        //        throw new GekkoException();
        //    }
        //    return c;
        //}


        private static void EigenValues()
        {
            if (true)
            {
                //http://mathdl.maa.org/mathDL/4/?pa=content&sa=viewDocument&nodeId=607&bodyId=967
                // 0.78  -0.33    A matrix         --> G =    0     0.33/0.78                     [0.423]     lambda1=0, lambda2=-0.33*0.44/(0.78*0.45)=-0.414.
                //-0.44   0.45                                0     0.33*0.44/(0.78*0.45)         [0.414]
                //frml _i x1 = 0.22*x1 + 0.33*x2 + 1;
                //frml _i x2 = 0.44*x1 + 0.55*x2 + 1;

                //Program.model.jacobiMatrixDense = new double[3, 3];
                //Program.model.jacobiMatrixDense[0, 0] = 9;
                //Program.model.jacobiMatrixDense[0, 1] = -1;
                //Program.model.jacobiMatrixDense[0, 2] = 2;
                //Program.model.jacobiMatrixDense[1, 0] = -2;
                //Program.model.jacobiMatrixDense[1, 1] = 8;
                //Program.model.jacobiMatrixDense[1, 2] = 4;
                //Program.model.jacobiMatrixDense[2, 0] = 1;
                //Program.model.jacobiMatrixDense[2, 1] = 1;
                //Program.model.jacobiMatrixDense[2, 2] = 8;



                int n = Program.model.jacobiMatrixDense.GetLength(0);
                double[,] ja = Program.model.jacobiMatrixDense;

                double[,] minusU = new double[n, n];
                double[,] DL = new double[n, n];
                //double[,] d = new double[n, n];

                for (int i = 0; i < n; i++)
                {
                    for (int j = 0; j < n; j++)
                    {
                        if (i >= j) DL[i, j] = ja[i, j];
                        //else if (i > j) l[i, j] = ja[i, j];
                        else if (i < j) minusU[i, j] = -ja[i, j];
                    }
                }

                //alglib.inv.rmatrixinverse(ref DL, n);
                //double[,] g = MultiplyMatrix(DL, minusU);

                ////Array.Copy(Program.model.jacobiMatrixDense, j, Program.model.jacobiMatrixDense.Length);
                //double[] lambda = new double[n];
                //double[] lambdai = new double[n];
                //double[,] vl = new double[n, n];
                //double[,] vr = new double[n, n];

                //bool xx = alglib.nsevd.rmatrixevd(g, n, 0, ref lambda, ref lambdai, ref vl, ref vr);
                //double largest = 0d;
                //for (int i = 0; i < lambda.Length; i++)
                //{
                //    double modulus = Math.Sqrt(lambda[i] * lambda[i] + lambdai[i] * lambdai[i]);
                //    G.Writeln(G.levelFormat(modulus, 10) + " " + G.levelFormat(lambda[i], 10) + " " + G.levelFormat(lambdai[i], 10));
                //    largest = Math.Max(largest, modulus);
                //}
                //G.Writeln("LARGEST LAMBDA = " + largest);
                //G.Writeln();
            }
        }

        private static void ClearMatrix(IElementalAccessMatrix dy)
        {
            for (int c1 = 0; c1 < dy.ColumnCount; c1++)
            {
                for (int c2 = 0; c2 < dy.RowCount; c2++)
                {
                    if (dy.GetValue(c2, c1) != 0)
                    {
                        dy.SetValue(c2, c1, 0d);
                    }
                }
            }
        }

        private static void ComputeGradientAndPutIntoFF(double delta, int j, int i, Type assembly, bool lu)
        {
            //int eq = simulFeedbackVarBtypeInverted[i];
            int eq = model.m2.fromBNumberToEqNumberFeedbackNEW[i];
            double val0 = model.r[eq];
            model.b[j] += delta;
            SimulateResidual(model.b, model.r, eq, assembly);
            double val1 = model.r[eq];
            model.b[j] += -delta;
            double grad = (val1 - val0) / delta;
            model.r[eq] = val0;
            if (grad != 0d)
            {
                //int ii = simulFeedbackVarBtypeInverted[j];
                int ii = model.m2.fromBNumberToEqNumberFeedbackNEW[j];
                int jj = eq;
                if (lu)
                {
                    Program.model.jacobiMatrixDense[jj, ii] = grad;
                }
                else
                {
                    Program.model.jacobiMatrix.SetValue(jj, ii, grad);
                }
            }
        }

        private static bool IsSimultaneousPrologueVariable(int endo)
        {
            bool flagSimulProlo = false;
            //slack: should create array with feedb vars first
            for (int i3 = 0; i3 < model.m2.simulRecursive.Count; i3++)
            {
                int simProloEndo = model.m2.sparseInfo[(int)model.m2.simulRecursive[i3]][0];  //could be 0,4,5,7
                if (endo == simProloEndo) flagSimulProlo = true;  //the var is a feedback var
            }
            return flagSimulProlo;
        }
        private static bool IsSimultaneousPrologueVariable1(int endo, Hashtable ht)
        {
            return ht.Contains(endo);
        }

        private static bool isFeedbackVariable(int endo)
        {
            bool flagFeedback = false;
            //slack: should create array with feedb vars first
            for (int i3 = 0; i3 < model.m2.simulFeedback.Count; i3++)
            {
                int feedbEndo = model.m2.sparseInfo[(int)model.m2.simulFeedback[i3]][0];  //could be 0,4,5,7
                if (endo == feedbEndo) flagFeedback = true;  //the var is a feedback var
            }
            return flagFeedback;
        }
        private static bool isFeedbackVariable1(int endo, Hashtable ht)
        {
            return ht.Contains(endo);
        }

        public static void CreateNewTable(string name)
        {
            if (Program.tables.ContainsKey(name))
            {
                Program.tables.Remove(name);
            }
            Table temp = new Table();
            temp.type = "table"; //not a "print" type table -- relevant regarding formatting
            Program.tables.Add(name, temp);
        }

        public static Table GetTable(string name)
        {
            Table xx = null;
            if (Program.tables.TryGetValue(name, out xx))
            {
            }
            else
            {
                G.Writeln2("*** ERROR: Table '" + name + "' does not seem to exist");
            }
            return xx;
        }

        public static string Add1ToFileName(string input, string inputLast, string workingFolder)
        {
            DirectoryInfo di = new DirectoryInfo(workingFolder);
            FileInfo[] rgFiles = di.GetFiles(input + "*." + inputLast);
            int high = -1;
            foreach (FileInfo fi in rgFiles)
            {
                string name = fi.Name;
                int idx = name.IndexOf("." + inputLast);
                if (idx > input.Length && idx < name.Length)
                {
                    string name1 = name.Substring(input.Length, name.Length - input.Length - inputLast.Length - 1);
                    int result;
                    if (int.TryParse(name1, out result))
                    {
                        high = Math.Max(result, high);
                    }
                    else
                    {
                        //ignore
                    }
                }
            }
            string name2 = input + (high + 1) + "." + inputLast;
            return name2;
        }

        static public string UnfoldVariableList(StringReader file)
        {
            // var line can be delimited by spaces or ";", spacing is irrelevant
            // description lines are all following lines (typically 4)
            // a record MUST end with "---" at least, and first line MUST be var line
            // "()" and "//" are ignored all over
            // the index name inside {} must be 1 char only wide
            // file must be in utf-8
            bool firstRealLineFound = false;
            List<Item> shortList = new List<Item>();
            List<Item> longList = new List<Item>();
            int counter = 0;
            int state = 1; //read var
            Item item = new Item();
            bool varlistFound = false;
            while (true)
            {
                //================== read and parse variable line ==============================
                if (file.Peek() < 0) break;
                string line = file.ReadLine();
                line = line.Trim();  //removes all blanks at start or end
                if (G.equal(line, "varlist$") || G.equal(line, "varlist;"))
                {
                    varlistFound = true;
                    continue;
                }
                if (varlistFound == false) continue;
                if (line.Length >= 2 && line.Substring(0, 2) == "()") continue;
                if (line.Length >= 2 && line.Substring(0, 2) == "//") continue;
                //if we get here, varlist$ has been found, and the line is not a ()-line or //-line
                if (firstRealLineFound == false && line == "")
                {
                    continue;
                }
                else
                {
                    firstRealLineFound = true;
                }

                if (line.StartsWith("---"))  //at least three '-' ends a block
                {
                    if (true)
                    {
                        counter++;
                        state = 1;
                        shortList.Add(item);
                        item = new Item();
                        continue;
                    }
                }
                if (state == 1)
                {
                    //expects variable
                    EquationBrowserExtractVariableNameEtc(line, item);
                    state = 2;  //expects description
                    continue;
                }
                if (state == 2)
                {
                    //expects description
                    item.explanation.Add(line);
                    state = 2;  //expects more description
                    continue;
                }
            }
            file.Close();

            foreach (Item shortItem in shortList)
            {
                if (shortItem.listOfLists == null)
                {
                    Item temp = new Item();
                    temp.variable = shortItem.variable;
                    temp.explanation = shortItem.explanation;
                    longList.Add(temp);
                    continue;
                }
                List<Item>[] dimensions = new List<Item>[shortItem.listOfLists.Count + 1];
                dimensions[0] = new List<Item>();
                dimensions[0].Add(shortItem);
                for (int d = 0 + 1; d < dimensions.Length; d++)  //for each list {i}->1, {j}->2 etc.
                {
                    dimensions[d] = new List<Item>();
                    foreach (Item original in dimensions[d - 1])
                    {
                        OneList thisList = shortItem.listOfLists[d - 1];
                        foreach (string element in thisList.indexItems)  //for each element in {i] etc.
                        {
                            Item temp = new Item();
                            string variable = original.variable;
                            variable = variable.Replace("{" + thisList.indexName + "}", element);
                            temp.variable = variable;
                            foreach (string line in original.explanation)
                            {
                                string line2 = line;
                                line2 = line2.Replace("{" + thisList.indexName + "}", element);
                                temp.explanation.Add(line2);
                            }
                            dimensions[d].Add(temp);
                        }
                    }
                }
                List<Item> result = dimensions[dimensions.Length - 1];
                longList.AddRange(result);
            }
            string s = null;
            if (counter > 0)
            {
                s = longList.Count + " var labels read";
            }
            Program.unfoldedVariableList = longList;
            return s;
        }

        private static void EquationBrowserExtractVariableNameEtc(string line, Item itemFolded)
        {
            int sep = line.IndexOfAny(new char[] { ' ', ';' }, 0);  //search for blank or ';' to separate var name and list, starting at pos 0
            if (sep == -1)  //no separation found, so listOfList if just null
            {
                itemFolded.variable = line;
            }
            else
            {
                //it is a list of items, {i}
                //e.g. "dp{i}{j} i=1,2,3,4,5 j=wb,wm,wt"
                string var = line.Substring(0, sep - 0);
                string var3 = var.Trim();
                itemFolded.variable = var3;
                List<OneList> listOfLists = new List<OneList>();
                bool error = false;
                for (int i = 0; i < var3.Length; i++)
                {
                    if (var3[i] == '{')
                    {
                        if (var3.Length > i + 2)
                        {
                            if (var3[i + 2] == '}')
                            {
                                OneList oneList = new OneList();
                                oneList.indexName = var3.Substring(i + 1, 1);
                                listOfLists.Add(oneList);
                            }
                            else
                            {
                                error = true;
                            }
                        }
                        else
                        {
                            error = true;
                        }
                    }
                    if (error)
                    {
                        G.Writeln2("*** ERROR: could not parse indices in '" + var3 + "'");
                        G.Writeln(line);
                        G.Writeln();
                    }
                }

                string restOfLine = line.Substring(sep);
                restOfLine.Replace(';', ' ');  // ';' can be used as delimiter instead of space
                restOfLine.Trim();  //now restOfLine is "i=1,2,3,4,5 j=wb,wm,wt" or "i=1,2,3,4,5;j=wb,wm,wt"

                StringTokenizer2 tok = new StringTokenizer2(restOfLine, false, true);
                tok.IgnoreWhiteSpace = true;
                tok.SymbolChars = new char[] { '=', ';', ',' };
                Token token;
                List<string> al = new List<string>();
                List<string> alType = new List<string>();
                do
                {
                    token = tok.Next();
                    al.Add(token.Value); alType.Add(token.Kind.ToString());
                } while (token.Kind != TokenKind.EOF);
                //below is a very innocent hack that makes stopping easier
                //like this, our tokens will end with these 3: {""/"EOF"}  {""/""}  {""/""}
                al.Add("");
                alType.Add("");
                al.Add("");
                alType.Add("");

                for (int i = 0; i < al.Count; i++)
                {
                    if (i + 1 < al.Count && al[i + 1] == "=")  //we have a new list
                    {
                        string name = al[i];
                        List<string> items = new List<string>();
                        for (int j = i + 2; j < al.Count; j += 2)
                        {
                            if (al[j - 1] == "=" || al[j - 1] == ",")
                            {
                                items.Add(al[j]);
                            }
                            else
                            {
                                //presume we are out of listed items
                                bool success = false;
                                foreach (OneList list in listOfLists)
                                {
                                    if (name == list.indexName)
                                    {
                                        success = true;
                                        list.indexItems = items;
                                        break;  //break out of foreach loop
                                    }
                                }
                                if (success == false)
                                {
                                    G.Writeln2("*** ERROR: indices do not match");
                                    G.Writeln(line);
                                    G.Writeln();
                                }
                                break;  //break out of j loop, continue i loop
                            }
                        }
                    }
                }
                itemFolded.listOfLists = listOfLists;
            }
        }



        public static Excel.Workbook OpenBook(Excel.Workbooks workbooks, string fileName, bool readOnly, bool editable,
        bool updateLinks)
        {
            Excel.Workbook book = workbooks.Open(
                fileName, updateLinks, readOnly,
                Type.Missing, Type.Missing, Type.Missing, Type.Missing, Type.Missing,
                Type.Missing, editable, Type.Missing, Type.Missing, Type.Missing,
                Type.Missing, Type.Missing);
            return book;
        }        

        public static string GetExcelColumnName(int columnNumber)
        {
            int dividend = columnNumber;
            string columnName = String.Empty;
            int modulo;

            while (dividend > 0)
            {
                modulo = (dividend - 1) % 26;
                columnName = Convert.ToChar(65 + modulo).ToString() + columnName;
                dividend = (int)((dividend - modulo) / 26);
            }

            return columnName;
        }


        public static TableLight ReadExcelWorkbook(string file, Databank databank, string sheetName)
        {
            int threadID = (int)AppDomain.GetCurrentThreadId();  //should be ok, just not for "fibre" threads (on SQL server)... never mind
            if (!File.Exists(file))
            {
                G.Writeln2("*** ERROR: File " + file + " does not seem to exist");
                throw new GekkoException();
            }

            //DateTime t00 = DateTime.Now;
            TableLight matrix = new TableLight();
            //using file: this may be a copied file is copylocal is active. Else it is identical to oRead.fileName.

            Excel.Application excel = null;
            Excel.Workbooks workbooks = null;
            Excel.Workbook wkb = null;
            Excel.Sheets objSheets = null;
            Excel.Worksheet sheet = null;            
            Excel.Range range = null;
            Excel.Range temprange = null;
            Excel.Range last = null;
            Object value2 = null;
            Object[,] input = null;

            try
            {
                //Seems this startup always takes 1 second. Maybe put it in Global and reuse from there.
                if (Globals.excelFix)
                {
                    //THIS SEEMS TO WORK, cf also #5298375235                    
                    if (Globals.objApp == null)
                    {
                        Globals.objApp = new Excel.Application();
                    }
                    else if (Globals.excelLastThreadID != threadID)
                    {
                        //#5298375235
                        Globals.excelLastThreadID = threadID;
                        System.Runtime.InteropServices.Marshal.FinalReleaseComObject(Globals.objApp);
                        Globals.objApp = null;
                        GC.Collect();
                        GC.WaitForPendingFinalizers();
                        // GC needs to be called twice in order to get the Finalizers called
                        // - the first time in, it simply makes a list of what is to be
                        // finalized, the second time in, it actually is finalizing. Only
                        // then will the object do its automatic ReleaseComObject.
                        GC.Collect();
                        GC.WaitForPendingFinalizers();
                        Globals.objApp = new Excel.Application();
                    }
                    excel = Globals.objApp;
                }
                else
                {
                    excel = new Excel.Application();
                }

                workbooks = excel.Workbooks;

                wkb = OpenBook(workbooks, file, true, false, false);

                objSheets = wkb.Worksheets;

                if (sheetName == null)
                {
                    //do nothing, [1] is al
                    sheet = wkb.Sheets[1] as Excel.Worksheet;
                }
                else
                {
                    bool match = ExcelSheetCheckMatch(objSheets, sheetName);
                    if (match)
                    {
                        sheet = ExcelSheetTryGetSheet(objSheets, sheetName);
                    }
                    else
                    {
                        G.Writeln2("*** ERROR: The sheet '" + sheetName + "' does not seem to exist");
                    }
                }

                //G.Writeln("open excel " + G.Seconds(d3));

                if (sheet != null)
                {
                    temprange = sheet.Cells;
                    last = temprange.SpecialCells(Excel.XlCellType.xlCellTypeLastCell, Type.Missing);
                    range = sheet.get_Range("A1", last);
                    //DateTime t2 = DateTime.Now;
                    value2 = range.Value2;
                    input = (Object[,])value2;
                    //G.Writeln("interop " + G.Seconds(t2));

                    //This is faster regarding the data, but problem is we will not get an error
                    //that points to the problematic cell. Could be implemented at a later point, if
                    //if Excel reading becomes a bottleneck.
                    //  double[,] dst = new double[input.GetLength(0), input.GetLength(1)];
                    //  Array.Copy(input, dst, input.Length);

                    int rows = input.GetLength(0);
                    int cols = input.GetLength(1);

                    //DateTime t0 = DateTime.Now;

                    for (int i = 0 + 1; i < rows + 1; i++)
                    {
                        for (int j = 0 + 1; j < cols + 1; j++)
                        {
                            Object temp = input[i, j];
                            if (temp == null) continue;
                            CellLight cell;
                            if (temp.GetType() == typeof(double))
                            {
                                cell = new CellLight((double)temp);
                            }
                            else if (temp.GetType() == typeof(int))
                            {
                                int iData = (int)temp;

                                //-2146826281 = #Div/0!
                                //-2146826246 = #N/A
                                //-2146826259 = #Name?
                                //-2146826288 = #Null!
                                //-2146826252 = #Num!
                                //-2146826265 = #Ref!  
                                //-2146826273 = #Value!

                                if (iData == -2146826246)
                                {
                                    //just like it is in a csv file. The -2146826246 is really a hexadecimal error code from Excel, stating that the number is N/A.
                                    cell = new CellLight("#N/A");
                                }
                                else if (iData == -2146826259)
                                {
                                    cell = new CellLight("#Name?");
                                }
                                else if (iData == -2146826281)
                                {
                                    cell = new CellLight("#Div/0");
                                }
                                else
                                {
                                    cell = new CellLight((double)iData);
                                }
                            }
                            else if (temp.GetType() == typeof(string))
                            {
                                cell = new CellLight((string)temp);
                            }
                            else
                            {
                                G.Writeln2("*** ERROR: Cell " + GetExcelCell(i, j, false) + " seems to be neither text or number.");
                                G.Writeln("           It has type " + temp.GetType().ToString(), Color.Red);
                                throw new GekkoException();
                            }
                            matrix.Add(i, j, cell);
                        }
                    }

                    //G.Writeln("loop excel " + G.Seconds(t0));
                }
            }
            catch (Exception ex)
            {
                //if you need to handle stuff
                G.Writeln2("*** ERROR: Get data from Excel failed with the following message:");
                G.Writeln(ex.Message, Color.Red);
            }
            finally
            {
                //not sure how much of this is absolutely necessary
                //see //#5298375235 and fusion it
                GC.Collect();
                GC.WaitForPendingFinalizers();
                GC.Collect();
                GC.WaitForPendingFinalizers();
                value2 = null;
                input = null;
                Marshal.ReleaseComObject(range);
                Marshal.ReleaseComObject(temprange);
                Marshal.ReleaseComObject(last);
                Marshal.ReleaseComObject(sheet);
                Marshal.ReleaseComObject(objSheets);
                wkb.Close(false);
                Marshal.ReleaseComObject(wkb);
                workbooks.Close();
                Marshal.ReleaseComObject(workbooks);
                excel.Quit();
                if (!Globals.excelFix) Marshal.ReleaseComObject(excel);
            }
            //G.Writeln("full excel " + G.Seconds(t00));
            return matrix;
        }        

        public static ExcelDataForCplot CreateExcelWorkbook2(ExcelOptions eo, O.Prt oPrt, bool isMulprt)
        {
            Excel.Workbook objBook = null;

        //TODO: #89073253245
        //this method transposes the input-table itself, which is a bit stupid since the table
        //is easy to transpose when it is constructed (with option rows/cols)
 
            string stampText = null;
            //TODO: think about extensions. If no extension given, it seems append=yes does not work properly.
            ExcelDataForCplot cplotData = new ExcelDataForCplot();  //only used if called from CSHEET, data are fetched and returned, but not used for normal WPLOT use.
            bool copyLocal = true;
            int threadID = (int)AppDomain.GetCurrentThreadId();  //should be ok, just not for "fibre" threads (on SQL server)... never mind
            //int managedThreadId = Thread.CurrentThread.ManagedThreadId;  //duer ikke, er ikke distinkt nok
            int blue = System.Drawing.ColorTranslator.ToOle(Globals.LightBlueWord);
            bool blueColors = Program.options.interface_excel_modernlook;
            string version = GetExcelVersion(eOfficeApp.eOfficeApp_Excel);
            if (eo.fileName != null) G.Write("Calling Excel " + version + " ... ");
            //see MS bug 320369
            //without, there was a bug on Excel 2003 (english version), where the language was set to
            //something different that english.
            System.Globalization.CultureInfo oldCI = System.Threading.Thread.CurrentThread.CurrentCulture;
            System.Threading.Thread.CurrentThread.CurrentCulture = new System.Globalization.CultureInfo("en-US");

            Excel.Workbooks objBooks = null;
            Excel.Sheets objSheets = null;
            Excel.Worksheet objSheet = null;
            Excel.Range range = null;
            Excel.Worksheet newSheet = null;

            bool isStamp = false; if (oPrt != null && G.equal(oPrt.opt_stamp, "yes")) isStamp = true;
            bool isDates = true; if (oPrt != null && G.equal(oPrt.opt_dates, "no")) isDates = false;
            bool isNames = true; if (oPrt != null && G.equal(oPrt.opt_names, "no")) isNames = false;
            bool isColors = true; if (oPrt != null && G.equal(oPrt.opt_colors, "no")) isColors = false;
            bool isAppend = false; if (oPrt != null && G.equal(oPrt.opt_append, "yes")) isAppend = true;
            string sheet = null; if (oPrt != null) sheet = oPrt.opt_sheet;


            bool isRows;
            bool isCols;
            HandleRowsCols(oPrt, out isRows, out isCols);

            bool isTranspose = false;
            if (isCols) isTranspose = true;  //Normally, SHEET has timeseries running in rows, unlike PRT default. So isTranspose means running in rows.

            string startCell = "a1"; if (oPrt != null && oPrt.opt_cell != null) startCell = oPrt.opt_cell;

            int datesInt = 0; if (isDates) datesInt++;
            int namesInt = 0; if (isNames) namesInt++;

            string fileNameWithPath = null;
            string fileName3 = null;
            string fileNameOriginalFile = null;
            string fileNameTempLocalFile = null;

            string ext = null;

            string fileName = null;
            if (oPrt != null && oPrt.opt_filename != null) fileName = oPrt.opt_filename;
            else if (eo.fileName != null) fileName = eo.fileName;

            if (fileName != null)
            {
                fileNameWithPath = CreateFullPathAndFileName(fileName);
                fileName3 = fileNameWithPath;
                if (fileName3.ToLower().EndsWith(".xls")) fileName3 = fileName3.Substring(0, fileName3.Length - 4);
                if (fileName3.ToLower().EndsWith(".xlsx")) fileName3 = fileName3.Substring(0, fileName3.Length - 5);
                //fileName3 is stripped of .xls or .xlsx
                fileNameOriginalFile = "";

                //A bit hacky...........
                if (version == "2000" || version == "2003" || version == "95" || version == "97" || version == "XP")
                {
                    ext = "xls";
                }
                else
                {
                    //"2007"
                    //"2010"
                    //"Unrecognized version", including successor to 2010
                    ext = "xlsx";
                }
                fileNameOriginalFile = fileName3 + "." + ext;
            }

            fileNameTempLocalFile = fileNameOriginalFile;  //3a is original file, 4 may become a local copy below

            if (copyLocal)
            {
                fileNameTempLocalFile = GetTempTsdFilePath(ext);
                if (isAppend)
                {
                    try
                    {
                        WaitForFileCopy(fileNameOriginalFile, fileNameTempLocalFile);
                    }
                    catch (Exception e)
                    {
                        G.Writeln();
                        G.Writeln("*** ERROR: Could not find file: " + fileNameOriginalFile);
                        throw new GekkoException();
                    }
                }
            }

            try
            {
                if (!eo.isCplot)
                {
                    if (isAppend)
                    {
                        //TODO, BUG: there is a problem here, if fileNameWithPath has no extension

                        if (Globals.objApp == null)
                        {
                            Globals.objApp = new Excel.Application();
                        }
                        else if (Globals.excelLastThreadID != threadID)
                        {
                            //#5298375235
                            Globals.excelLastThreadID = threadID;
                            System.Runtime.InteropServices.Marshal.FinalReleaseComObject(Globals.objApp);
                            Globals.objApp = null;
                            GC.Collect();
                            GC.WaitForPendingFinalizers();
                            // GC needs to be called twice in order to get the Finalizers called
                            // - the first time in, it simply makes a list of what is to be
                            // finalized, the second time in, it actually is finalizing. Only
                            // then will the object do its automatic ReleaseComObject.
                            GC.Collect();
                            GC.WaitForPendingFinalizers();
                            Globals.objApp = new Excel.Application();
                        }

                        objBooks = Globals.objApp.Workbooks;
                        objBook = objBooks.Open(fileNameTempLocalFile,
                            Type.Missing, Type.Missing, Type.Missing, Type.Missing,
                            Type.Missing, Type.Missing, Type.Missing, Type.Missing,
                            Type.Missing, Type.Missing, Type.Missing, Type.Missing,
                            Type.Missing, Type.Missing);
                        objSheets = objBook.Worksheets;
                        if (sheet == null)
                        {
                            objSheet = (Excel.Worksheet)objSheets.get_Item(1);
                        }
                        else
                        {
                            bool match = ExcelSheetCheckMatch(objSheets, sheet);
                            if (match)
                            {
                                objSheet = ExcelSheetTryGetSheet(objSheets, sheet);

                            }
                            else
                            {
                                //creating a new one
                                objSheet = (Excel.Worksheet)objSheets.Add(objSheets[1], Type.Missing, Type.Missing, Type.Missing);
                                objSheet.Name = sheet;
                            }
                            // The first argument below inserts the new worksheet as the first one
                        }
                    }
                    else
                    {
                        // Instantiate Excel and start a new workbook.
                        Globals.objApp = new Excel.Application();
                        objBooks = Globals.objApp.Workbooks;
                        objBook = objBooks.Add(Missing.Value);
                        objSheets = objBook.Worksheets;
                        objSheet = (Excel.Worksheet)objSheets.get_Item(1);
                        if (sheet != null)
                        {
                            objSheet.Name = sheet;
                        }
                    }
                }

                Excel.Range range0 = null;

                if (!eo.isCplot) range0 = objSheet.get_Range(startCell, Missing.Value);

                if (isStamp)
                {
                    StampTypes type = StampTypes.Normal;
                    if(isMulprt)type = StampTypes.Multiplier; //we drop .Base for now...

                    List<string> lines = GetDatabankInfo(type);
                    string ss = GetDateTimeStamp() + ". ";
                    foreach (string s in lines)
                    {
                        ss = ss + s + ". ";
                    }
                    if (ss.EndsWith(". ")) ss = ss.Substring(0, ss.Length - 2);
                    cplotData.stamp = ss;
                    if (!eo.isCplot) if (isColors) range0.Font.Color = System.Drawing.ColorTranslator.ToOle(System.Drawing.Color.Gray);
                    if (!eo.isCplot) range0.set_Value(Missing.Value, cplotData.stamp);
                    if (!eo.isCplot) range0 = range0.get_Offset(1, 0);
                }

                if (oPrt != null && oPrt.opt_title != null)
                {
                    cplotData.heading = oPrt.opt_title;
                    if (!eo.isCplot) if (isColors) range0.Font.Bold = true;
                    if (!eo.isCplot) range0.set_Value(Missing.Value, cplotData.heading);
                    if (!eo.isCplot) range0 = range0.get_Offset(1, 0);
                }


                // ======================== DATA MATRIX ===================================

                //Get the range where the starting cell has the address
                //m_sStartingCell and its dimensions are m_iNumRows x m_iNumCols.
                int dataRows = eo.excelData.GetLength(0);
                int dataCols = eo.excelData.GetLength(1);

                int[,] excelColumnLabelsAnnual = new int[1, dataCols];
                if (options.freq == EFreq.Annual)
                {
                    for (int i = 0; i < eo.excelColumnLabels.Length; i++)
                    {
                        //should never give an error
                        excelColumnLabelsAnnual[0, i] = int.Parse(eo.excelColumnLabels[0, i]);
                    }
                }

                if (isTranspose)
                {
                    if (!eo.isCplot) range = range0.get_Offset(namesInt, datesInt);
                    if (!eo.isCplot) range = range.get_Resize(dataCols, dataRows);
                    double[,] data = Transpose(eo.excelData);
                    if (!eo.isCplot) range.set_Value(Missing.Value, data);
                    cplotData.data = data;
                }
                else
                {
                    if (!eo.isCplot) range = range0.get_Offset(datesInt, namesInt);
                    if (!eo.isCplot) range = range.get_Resize(dataRows, dataCols);
                    double[,] data = eo.excelData;
                    if (!eo.isCplot) range.set_Value(Missing.Value, data);
                    cplotData.data = data;
                }

                string na = "na()";
                if (G.equal(Program.options.interface_excel_language, "danish")) na = "ikke.tilgængelig()";

                if (!eo.isCplot)
                {
                    Globals.objApp.DisplayAlerts = false;
                    bool success = (bool)range.Replace(
                        "9,99999E+99",
                        "=" + na,
                        1, //XlLookAt.xlWhole,
                        1, //XlSearchOrder.xlByRows,
                        true, Type.Missing, Type.Missing, Type.Missing);
                    success = (bool)range.Replace(
                        "9.99999E+99",
                        "=" + na,
                        1, //XlLookAt.xlWhole,
                        1, //XlSearchOrder.xlByRows,
                        true, Type.Missing, Type.Missing, Type.Missing);
                    success = (bool)range.Replace(  //309827520439857
                        "65535",
                        "=" + na,
                        1, //XlLookAt.xlWhole,
                        1, //XlSearchOrder.xlByRows,
                        true, Type.Missing, Type.Missing, Type.Missing);
                    Globals.objApp.DisplayAlerts = true;
                }

                //DATES ROW ---------------------------------------------------------------------
                //range = objSheet.get_Range("B2", Missing.Value);

                if (isDates)
                {

                    if (!eo.isCplot)
                    {
                        if (isTranspose)
                        {
                            range = range0.get_Offset(namesInt, 0);
                            range = range.get_Resize(dataCols, 1);
                        }
                        else
                        {
                            range = range0.get_Offset(0, namesInt);
                            range = range.get_Resize(1, dataCols);
                        }
                    }

                    string[,] data2 = null;

                    if (options.freq == EFreq.Annual)
                    {
                        //else the cells are left-justified and with a green triangle (warning)

                        int[,] data = null;
                        if (isTranspose)
                        {
                            data = Transpose(excelColumnLabelsAnnual);
                            if (!eo.isCplot) range.set_Value(Missing.Value, data);
                        }
                        else
                        {
                            data = excelColumnLabelsAnnual;
                            if (!eo.isCplot) range.set_Value(Missing.Value, data);
                        }
                        data2 = ConvertToString(data);
                    }
                    else
                    {
                        string[,] data3 = null;
                        if (isTranspose)
                        {
                            data3 = Transpose(eo.excelColumnLabels);
                            if (!eo.isCplot) range.set_Value(Missing.Value, data3);
                        }
                        else
                        {
                            data3 = eo.excelColumnLabels;
                            if (!eo.isCplot) range.set_Value(Missing.Value, data3);
                        }
                        data2 = data3;
                    }
                    cplotData.dates = data2;
                }

                //====================== VARIABLE NAMES COLUMN -----------------------------------------------------------------

                if (isNames)
                {
                    string[,] labels = null;
                    if (isTranspose)
                    {
                        if (!eo.isCplot) range = range0.get_Offset(0, datesInt);
                        if (!eo.isCplot) range = range.get_Resize(1, dataRows);
                        labels = Transpose(eo.excelRowLabels);
                        if (!eo.isCplot) range.set_Value(Missing.Value, labels);
                    }
                    else
                    {
                        if (!eo.isCplot) range = range0.get_Offset(datesInt, 0);
                        if (!eo.isCplot) range = range.get_Resize(dataRows, 1);
                        labels = eo.excelRowLabels;
                        if (!eo.isCplot) range.set_Value(Missing.Value, labels);
                    }
                    cplotData.varnames = labels;
                }

                cplotData.transpose = isTranspose;
                if (eo.isCplot) return cplotData;

                //====================== coloring ==============================

                if (isColors)
                {
                    if (isTranspose)  //dates running downwards
                    {
                        if (isNames)
                        {
                            //Names row
                            range = range0.get_Offset(0, 0);
                            range = range.get_Resize(1, dataRows + datesInt);
                            if (blueColors)
                            {
                                range.Interior.Color = blue;
                                range.Font.Color = System.Drawing.ColorTranslator.ToOle(System.Drawing.Color.White);
                            }
                            else
                            {
                                range.Borders[Excel.XlBordersIndex.xlEdgeTop].Weight = Excel.XlBorderWeight.xlMedium;
                                range.Borders[Excel.XlBordersIndex.xlEdgeBottom].Weight = Excel.XlBorderWeight.xlMedium;
                            }
                        }
                    }
                    else
                    {
                        if (isDates)
                        {
                            //Dates row
                            range = range0.get_Offset(0, 0);
                            range = range.get_Resize(1, dataCols + namesInt);
                            if (blueColors)
                            {
                                range.Interior.Color = blue;
                                range.Font.Color = System.Drawing.ColorTranslator.ToOle(System.Drawing.Color.White);
                            }
                            else
                            {
                                range.Borders[Excel.XlBordersIndex.xlEdgeTop].Weight = Excel.XlBorderWeight.xlMedium;
                                range.Borders[Excel.XlBordersIndex.xlEdgeBottom].Weight = Excel.XlBorderWeight.xlMedium;
                            }
                        }
                    }

                    //Data border
                    if (isTranspose)
                    {
                        range = range0.get_Offset(0, 0);
                        range = range.get_Resize(dataCols + namesInt, dataRows + datesInt);
                    }
                    else
                    {
                        range = range0.get_Offset(0, 0);
                        range = range.get_Resize(dataRows + datesInt, dataCols + namesInt);
                    }
                    if (blueColors)
                    {
                        range.Borders[Excel.XlBordersIndex.xlEdgeTop].Weight = Excel.XlBorderWeight.xlMedium;
                        range.Borders[Excel.XlBordersIndex.xlEdgeTop].Color = blue;
                        range.Borders[Excel.XlBordersIndex.xlEdgeBottom].Weight = Excel.XlBorderWeight.xlMedium;
                        range.Borders[Excel.XlBordersIndex.xlEdgeBottom].Color = blue;
                        range.Borders[Excel.XlBordersIndex.xlEdgeLeft].Weight = Excel.XlBorderWeight.xlMedium;
                        range.Borders[Excel.XlBordersIndex.xlEdgeLeft].Color = blue;
                        range.Borders[Excel.XlBordersIndex.xlEdgeRight].Weight = Excel.XlBorderWeight.xlMedium;
                        range.Borders[Excel.XlBordersIndex.xlEdgeRight].Color = blue;
                    }
                    else
                    {
                        range.Borders[Excel.XlBordersIndex.xlEdgeTop].Weight = Excel.XlBorderWeight.xlMedium;
                        range.Borders[Excel.XlBordersIndex.xlEdgeBottom].Weight = Excel.XlBorderWeight.xlMedium;
                    }

                }

                // ===================== put cursor =========================

                if (fileName == null)
                {
                    //Return control of Excel to the user.
                    Globals.objApp.Visible = true;
                    Globals.objApp.UserControl = true;
                }
                else
                {
                    // Save the Workbook and quit Excel.
                    Globals.objApp.DisplayAlerts = false;
                    if (isAppend == false)
                    {
                        if (File.Exists(fileNameTempLocalFile)) WaitForFileDelete(fileNameTempLocalFile);  //probably not necessary
                    }
                    if (isAppend)
                    {
                        objBook.Save();
                    }
                    else
                    {
                        objBook.SaveCopyAs(fileNameTempLocalFile);
                        //objBook.SaveAs(fileName4, Missing.Value, Missing.Value,
                        //    Missing.Value, false, false, Excel.XlSaveAsAccessMode.xlNoChange,
                        //    false, false, Missing.Value, Missing.Value, Missing.Value);
                    }

                    if (copyLocal)
                    {
                        try
                        {
                            //Maybe use WaitForFileCopy() here at some point.
                            //Not sure why fileNameOriginalFile is deleted first (safety?)
                            WaitForFileCopy(fileNameTempLocalFile, fileNameOriginalFile);
                        }
                        catch (Exception e)
                        {
                            G.Writeln();
                            G.Writeln("*** ERROR: Could not write Excel file -- is it open/blocked?: " + fileNameOriginalFile);
                            throw new GekkoException();
                        }
                    }

                    ExcelCleanup(ref objBook, ref objBooks, ref objSheets, ref objSheet, ref range, ref newSheet, ref range0);
                    if (!Globals.setPrintMute) G.Writeln2("Wrote dataset with " + dataRows + " rows and " + dataCols + " cols to " + fileNameOriginalFile);
                }
                return null;
            }
            catch (Exception theException)
            {
                //G.Writeln(" ...did not finish");
                String errorMessage;
                errorMessage = "*** ERROR: Excel failed with the following error: ";
                errorMessage = String.Concat(errorMessage, theException.Message);
                errorMessage = String.Concat(errorMessage, " Line: ");
                errorMessage = String.Concat(errorMessage, theException.Source);
                G.Writeln(errorMessage);
                //see MS bug 320369
                System.Threading.Thread.CurrentThread.CurrentCulture = oldCI;
                throw new GekkoException();
            }

            //see MS bug 320369
            System.Threading.Thread.CurrentThread.CurrentCulture = oldCI;
        }

        private static void ExcelCleanup(ref Excel.Workbook objBook, ref Excel.Workbooks objBooks, ref Excel.Sheets objSheets, ref Excel.Worksheet objSheet, ref Excel.Range range, ref Excel.Worksheet newSheet, ref Excel.Range range0)
        {
            objBook.Close(false, Missing.Value, Missing.Value);

            Globals.objApp.DisplayAlerts = true;

            if (newSheet != null)
            {
                System.Runtime.InteropServices.Marshal.FinalReleaseComObject(newSheet);
                newSheet = null;
            }
            if (range != null)
            {
                System.Runtime.InteropServices.Marshal.FinalReleaseComObject(range);
                range = null;
            }
            if (range0 != null)
            {
                System.Runtime.InteropServices.Marshal.FinalReleaseComObject(range0);
                range0 = null;
            }
            if (objSheet != null)
            {
                System.Runtime.InteropServices.Marshal.FinalReleaseComObject(objSheet);
                objSheet = null;
            }
            if (objSheets != null)
            {
                System.Runtime.InteropServices.Marshal.FinalReleaseComObject(objSheets);
                objSheets = null;
            }
            if (objBook != null)
            {
                System.Runtime.InteropServices.Marshal.FinalReleaseComObject(objBook);
                objBook = null;
            }
            if (objBooks != null)
            {
                System.Runtime.InteropServices.Marshal.FinalReleaseComObject(objBooks);
                objBooks = null;
            }
            //see also id7372367
            //Globals.objApp = null;  --> dealt with when Gekko exits.
            GC.Collect();
            GC.WaitForPendingFinalizers();
            // GC needs to be called twice in order to get the Finalizers called
            // - the first time in, it simply makes a list of what is to be
            // finalized, the second time in, it actually is finalizing. Only
            // then will the object do its automatic ReleaseComObject.
            GC.Collect();
            GC.WaitForPendingFinalizers();
        }

        private static Excel.Worksheet ExcelSheetTryGetSheet(Excel.Sheets objSheets, string sheet)
        {
            Excel.Worksheet objSheet;
            try
            {
                objSheet = (Excel.Worksheet)objSheets[sheet];  //seems it is not case sensitive
            }
            catch (Exception e)
            {
                G.Writeln2("*** ERROR: problem while trying to access to existing sheet '" + sheet + "'");
                throw new GekkoException();
            }

            return objSheet;
        }

        private static bool ExcelSheetCheckMatch(Excel.Sheets objSheets, string sheet)
        {
            bool match = false;
            foreach (Excel.Worksheet xx in objSheets)
            {
                if (G.equal(xx.Name.Trim(), sheet.Trim()))
                {
                    match = true;
                }
            }

            return match;
        }

        private static void HandleRowsCols(O.Prt oPrt, out bool isRows, out bool isCols)
        {
            isRows = false;
            isCols = false;
            if (oPrt != null)
            {
                if (G.equal(oPrt.prtType, "sheet") || G.equal(oPrt.prtType, "clip"))
                {
                    isRows = Program.options.sheet_rows;
                    isCols = Program.options.sheet_cols;
                }
                else
                {
                    isRows = false;
                    isCols = true;
                }

                if (isRows && isCols)
                {
                    G.Writeln2("*** ERROR: It seems that OPTION sheet rows/cols are both set to 'yes'");
                    throw new GekkoException();
                }
                if (G.equal(oPrt.opt_rows, "yes") && G.equal(oPrt.opt_cols, "yes"))
                {
                    G.Writeln2("*** ERROR: It seems that options <rows> and <cols> are used at the same time");
                    throw new GekkoException();
                }
                if (G.equal(oPrt.opt_rows, "yes"))
                {
                    isRows = true;
                    isCols = false;
                }
                else if (G.equal(oPrt.opt_cols, "yes"))
                {
                    isRows = false;
                    isCols = true;
                }
            }
            else
            {
                isRows = true;
                isCols = false;
            }
        }

        public static string GetExcelVersion(Program.eOfficeApp app)
        {
            return Program.GetExcelVersion2(Program.GetApplicationVersion(app));
        }

        public static double[,] Transpose(double[,] x)
        {
            double[,] y = new double[x.GetLength(1), x.GetLength(0)];
            for (int i = 0; i < x.GetLength(0); i++)
            {
                for (int j = 0; j < x.GetLength(1); j++)
                {
                    y[j, i] = x[i, j];
                }
            }
            return y;
        }

        public static void Rungenr(int i)
        {
            if (i == 1)
            {
                if (Globals.lastDynamicCsCode != null && Globals.lastDynamicCsCode.Contains("TranslatedCode"))
                {
                    string s = Application.ExecutablePath;
                    string s2 = Path.GetDirectoryName(s);
                    string s3 = s2.Replace("\\Debug", "");
                    string s4 = s3.Replace("\\bin", "");
                    StreamWriter sw = new StreamWriter(s4 + "\\Genr.cs");
                    sw.Write(Globals.lastDynamicCsCode);
                    sw.Flush();
                    sw.Close();
                }
                else
                {
                    G.Writeln2("---> empty CS code... --> fail");
                }
            }
            else if (i == 2)
            {
                //Gekko.TranslatedCode.CodeLines(new P());
                TranslatedCode xx = new TranslatedCode();
                TranslatedCode.CodeLines(new P());
            }
        }


        public delegate object FastInvokeHandler(object _target, object[] _params);

        /// <summary>
        /// A class to invoke methods using System.Reflection.Emit.DynamicMethod (.NET 2.0).
        /// </summary>
        public sealed class FastMethodInvoker
        {
            private FastMethodInvoker() { }

            /// <summary>
            /// Returns DynamicMethod.
            /// </summary>
            /// <param name="_methodInfo">MethodInfo.</param>
            /// <returns>Delegate</returns>
            public static FastInvokeHandler GetMethodInvoker(MethodInfo _methodInfo)
            {
                DynamicMethod dynamicMethod = new DynamicMethod(string.Empty, typeof(object), new Type[] { typeof(object), typeof(object[]) }, _methodInfo.DeclaringType.Module);
                ILGenerator il = dynamicMethod.GetILGenerator();
                ParameterInfo[] ps = _methodInfo.GetParameters();
                Type[] paramTypes = new Type[ps.Length];
                for (int ii = 0; ii < paramTypes.Length; ii++)
                {
                    if (ps[ii].ParameterType.IsByRef)
                        paramTypes[ii] = ps[ii].ParameterType.GetElementType();
                    else
                        paramTypes[ii] = ps[ii].ParameterType;
                }
                LocalBuilder[] locals = new LocalBuilder[paramTypes.Length];

                for (int ii = 0; ii < paramTypes.Length; ii++)
                {
                    locals[ii] = il.DeclareLocal(paramTypes[ii], true);
                }

                for (int ii = 0; ii < paramTypes.Length; ii++)
                {
                    il.Emit(OpCodes.Ldarg_1);
                    EmitFastInt(il, ii);
                    il.Emit(OpCodes.Ldelem_Ref);
                    EmitCastToReference(il, paramTypes[ii]);
                    il.Emit(OpCodes.Stloc, locals[ii]);
                }
                il.Emit(OpCodes.Ldarg_0);
                for (int ii = 0; ii < paramTypes.Length; ii++)
                {
                    if (ps[ii].ParameterType.IsByRef)
                        il.Emit(OpCodes.Ldloca_S, locals[ii]);
                    else
                        il.Emit(OpCodes.Ldloc, locals[ii]);
                }
                il.EmitCall(OpCodes.Callvirt, _methodInfo, null);
                if (_methodInfo.ReturnType == typeof(void))
                    il.Emit(OpCodes.Ldnull);
                else
                    EmitBoxIfNeeded(il, _methodInfo.ReturnType);

                for (int ii = 0; ii < paramTypes.Length; ii++)
                {
                    if (ps[ii].ParameterType.IsByRef)
                    {
                        il.Emit(OpCodes.Ldarg_1);
                        EmitFastInt(il, ii);
                        il.Emit(OpCodes.Ldloc, locals[ii]);
                        if (locals[ii].LocalType.IsValueType)
                            il.Emit(OpCodes.Box, locals[ii].LocalType);
                        il.Emit(OpCodes.Stelem_Ref);
                    }
                }

                il.Emit(OpCodes.Ret);
                FastInvokeHandler invoker = (FastInvokeHandler)dynamicMethod.CreateDelegate(typeof(FastInvokeHandler));
                return invoker;
            }

            /// <summary>
            /// Emits the cast to reference.
            /// </summary>
            /// <param name="il">The il.</param>
            /// <param name="type">The type.</param>
            private static void EmitCastToReference(ILGenerator il, System.Type type)
            {
                if (type.IsValueType)
                {
                    il.Emit(OpCodes.Unbox_Any, type);
                }
                else
                {
                    il.Emit(OpCodes.Castclass, type);
                }
            }

            /// <summary>
            /// Emits the box if needed.
            /// </summary>
            /// <param name="il">The il.</param>
            /// <param name="type">The type.</param>
            private static void EmitBoxIfNeeded(ILGenerator il, System.Type type)
            {
                if (type.IsValueType)
                {
                    il.Emit(OpCodes.Box, type);
                }
            }

            /// <summary>
            /// Emits the fast int.
            /// </summary>
            /// <param name="il">The il.</param>
            /// <param name="value">The value.</param>
            private static void EmitFastInt(ILGenerator il, int value)
            {
                switch (value)
                {
                    case -1:
                        il.Emit(OpCodes.Ldc_I4_M1);
                        return;
                    case 0:
                        il.Emit(OpCodes.Ldc_I4_0);
                        return;
                    case 1:
                        il.Emit(OpCodes.Ldc_I4_1);
                        return;
                    case 2:
                        il.Emit(OpCodes.Ldc_I4_2);
                        return;
                    case 3:
                        il.Emit(OpCodes.Ldc_I4_3);
                        return;
                    case 4:
                        il.Emit(OpCodes.Ldc_I4_4);
                        return;
                    case 5:
                        il.Emit(OpCodes.Ldc_I4_5);
                        return;
                    case 6:
                        il.Emit(OpCodes.Ldc_I4_6);
                        return;
                    case 7:
                        il.Emit(OpCodes.Ldc_I4_7);
                        return;
                    case 8:
                        il.Emit(OpCodes.Ldc_I4_8);
                        return;
                }

                if (value > -129 && value < 128)
                {
                    il.Emit(OpCodes.Ldc_I4_S, (SByte)value);
                }
                else
                {
                    il.Emit(OpCodes.Ldc_I4, value);
                }
            }
        }


        public static int[,] Transpose(int[,] x)
        {
            int[,] y = new int[x.GetLength(1), x.GetLength(0)];
            for (int i = 0; i < x.GetLength(0); i++)
            {
                for (int j = 0; j < x.GetLength(1); j++)
                {
                    y[j, i] = x[i, j];
                }
            }
            return y;
        }

        public static string[,] ConvertToString(int[,] x)
        {
            string[,] y = new string[x.GetLength(0), x.GetLength(1)];
            for (int i = 0; i < x.GetLength(0); i++)
            {
                for (int j = 0; j < x.GetLength(1); j++)
                {
                    y[i, j] = x[i, j].ToString();
                }
            }
            return y;
        }

        public static string[,] Transpose(string[,] x)
        {
            string[,] y = new string[x.GetLength(1), x.GetLength(0)];
            for (int i = 0; i < x.GetLength(0); i++)
            {
                for (int j = 0; j < x.GetLength(1); j++)
                {
                    y[j, i] = x[i, j];
                }
            }
            return y;
        }

        public static string GetExcelVersion2(eOfficeVersion input)
        {
            if (input == eOfficeVersion.eOfficeVersion_95) return "95";
            if (input == eOfficeVersion.eOfficeVersion_97) return "97";
            if (input == eOfficeVersion.eOfficeVersion_XP) return "XP";
            if (input == eOfficeVersion.eOfficeVersion_2000) return "2000";
            if (input == eOfficeVersion.eOfficeVersion_2003) return "2003";
            if (input == eOfficeVersion.eOfficeVersion_2007) return "2007";
            if (input == eOfficeVersion.eOfficeVersion_2010) return "2010";
            if (input == eOfficeVersion.eOfficeVersion_2013) return "2013";
            if (input == eOfficeVersion.eOfficeVersion_2016) return "2016";
            if (input == eOfficeVersion.eOfficeVersion_2019) return "2019?";
            if (input == eOfficeVersion.eOfficeVersion_Unrecognized) return "[Unrecognized version]";
            return "[Unrecognized version]";
        }

        public enum eOfficeVersion
        {
            eOfficeVersion_Unrecognized, // error return value
            eOfficeVersion_95,
            eOfficeVersion_97,
            eOfficeVersion_2000,
            eOfficeVersion_XP,   // XP = 2002 + marketing
            eOfficeVersion_2003,
            eOfficeVersion_2007,
            eOfficeVersion_2010,
            eOfficeVersion_2013,
            eOfficeVersion_2016,
            eOfficeVersion_2019  //???
        };

        public enum GekkoFileReadOrWrite
        {
            Read,
            Write,
            WriteAppend
        };

        public enum eOfficeApp // in case you are looking for a particular app
        {
            eOfficeApp_Word,
            eOfficeApp_Excel,
            eOfficeApp_Outlook,
            eOfficeApp_Access,
            eOfficeApp_PowerPoint,
        };
        public static eOfficeVersion GetApplicationVersion(eOfficeApp appToCheck)
        {
            // some of this function is based on the code in the article at: http://support.microsoft.com/kb/q247985/
            string progID = GetProgID(appToCheck);

            RegistryKey hKey = Registry.ClassesRoot.OpenSubKey(progID, RegistryKeyPermissionCheck.ReadSubTree, System.Security.AccessControl.RegistryRights.ReadKey);
            if (hKey == null)
                return eOfficeVersion.eOfficeVersion_Unrecognized;

            RegistryKey hKey1 = hKey.OpenSubKey("CurVer", RegistryKeyPermissionCheck.ReadSubTree, System.Security.AccessControl.RegistryRights.ReadKey);
            if (hKey1 == null)
            {
                hKey1.Close();
                hKey.Close();
                return eOfficeVersion.eOfficeVersion_Unrecognized;
            }

            // Get the Version information
            string progAndVersion = (string)hKey1.GetValue("");

            // Close the registry keys
            hKey1.Close();
            hKey.Close();

            // Error while querying for value
            if (progAndVersion == null)
                return eOfficeVersion.eOfficeVersion_Unrecognized;

            // At this point progAndVersion contains the ProgID followed by a number.
            // For example, Word 97 will return Word.Application.8 and Word 2000 will return Word.Application.9

            int lastDot = progAndVersion.LastIndexOf('.');
            int firstCharOfVersion = lastDot + 1; // + 1 to get rid of the dot at the front
            string versionString = progAndVersion.Substring(firstCharOfVersion, progAndVersion.Length - firstCharOfVersion);

            return StringToVersion(versionString);
        }

        public static string GetApplicationAsString(eOfficeApp officeApp)
        {
            switch (officeApp)
            {
                case eOfficeApp.eOfficeApp_Word: { return "Word"; } break;
                case eOfficeApp.eOfficeApp_Excel: { return "Excel"; } break;
                case eOfficeApp.eOfficeApp_Outlook: { return "Outlook"; } break;
                case eOfficeApp.eOfficeApp_Access: { return "Access"; } break;
                case eOfficeApp.eOfficeApp_PowerPoint: { return "Powerpoint"; } break;
                default: { /*ASSERT(false);*/
                        return string.Empty; } break; // added another ???
            }
        }

        public static string GetProgID(eOfficeApp officeApp)
        {
            // ProgIDs from http://support.microsoft.com/kb/240794/EN-US/
            switch (officeApp)
            {
                case eOfficeApp.eOfficeApp_Word: { return "Word.Application"; } break;
                case eOfficeApp.eOfficeApp_Excel: { return "Excel.Application"; } break;
                case eOfficeApp.eOfficeApp_Outlook: { return "Outlook.Application"; } break;
                case eOfficeApp.eOfficeApp_Access: { return "Access.Application"; } break;
                case eOfficeApp.eOfficeApp_PowerPoint: { return "Powerpoint.Application"; } break;
                default: { /*ASSERT(false);*/ return string.Empty; } break; // added another ???
            }
        }

        public static eOfficeVersion StringToVersion(string versionString)
        {
            // mapping between the marketing version (e.g. 2003) and the behind-the-scenes version
            if ("7" == versionString)
            {
                return eOfficeVersion.eOfficeVersion_95;
            }
            else if ("8" == versionString)
            {
                return eOfficeVersion.eOfficeVersion_97;
            }
            else if ("9" == versionString)
            {
                return eOfficeVersion.eOfficeVersion_2000;
            }
            else if ("10" == versionString)
            {
                return eOfficeVersion.eOfficeVersion_XP;
            }
            else if ("11" == versionString)
            {
                return eOfficeVersion.eOfficeVersion_2003;
            }
            else if ("12" == versionString)
            {
                return eOfficeVersion.eOfficeVersion_2007;
            }
            else if ("13" == versionString || "14" == versionString)  //apparently 13 is not used because of superstition
            {
                return eOfficeVersion.eOfficeVersion_2010;
            }
            else if ("15" == versionString)  //this seems to be 2013 internal number
            {
                return eOfficeVersion.eOfficeVersion_2013;
            }
            else if ("16" == versionString) 
            {
                return eOfficeVersion.eOfficeVersion_2016;
            }
            else if ("17" == versionString)
            {
                return eOfficeVersion.eOfficeVersion_2019;
            }
            else
            {
                return eOfficeVersion.eOfficeVersion_Unrecognized; // added another ???
            }
        }

        public static void CreateBVariance(TimeSeries[] timeSeriesPointers, GekkoTime t0)
        {
            foreach (int i in Program.model.endogenousBNumbersOriginalInModelList)
            {
                TimeSeries ts = timeSeriesPointers[i];
                //string variable = varNamePointers[i];
                double d = CalculateHistoricalVarianceForVariable(ts, t0);
                Program.model.bVariance[i] = d;
            }
        }

        public static double CalculateHistoricalVarianceForVariable(TimeSeries ts, GekkoTime year0)
        {
            //only abs calc is used
            if (ts == null) return double.NaN;
            double v3 = ts.GetData(year0.Add(-2));  //TODO: what about freq?
            double v2 = ts.GetData(year0.Add(-1));
            double v1 = ts.GetData(year0);

            double v = ((Math.Abs(v3) + Math.Abs(v2) + Math.Abs(v1)) / 3d);  //abs mean, not used it seems
            double dLag = Math.Abs(v2 - v3);  //diff for x(-1)-x(-2)
            double dNonlag = Math.Abs(v1 - v2);  //diff for x-x(-1)
            double d = (dLag + dNonlag) / 2d;  //mean diff
            double rel = d / v;

            if (double.IsInfinity(d))
            {
                //seems there are none of these, how could there?
                d = double.NaN;  //for simplicity later on
            }

            if (d == 0)
            {
                //there are some of these, most with all values = 0
            }

            if (G.isNumericalError(d))
            {
                //seems there are none of these
            }

            return d;
        }

        public static void tokensFromFileToArrayList(String dataFile, bool ignoreWhiteSpace, bool addWorkingFolder, List<string> al, List<string> alType)
        {
            //Only used in TSP utilities

            String all;
            String all2;
            String temp1 = "";
            String temp2 = "";

            //content is read from a .frm file
            string fileName = null;
            if (addWorkingFolder)
            {
                fileName = Program.options.folder_working + "\\" + dataFile;
            }
            else
            {
                fileName = dataFile;
            }

            all = GetTextFromFileWithWait(fileName);

            all2 = G.oddX0000Hack(all);
            StringTokenizer2 tok = new StringTokenizer2(all2, false, true);
            tok.IgnoreWhiteSpace = ignoreWhiteSpace;
            tok.SymbolChars = new char[] { '?', '(', ')', '=', '+', '-', '*', '/', '$' };
            Token token;

            //----------------------------------------------------
            //read into ArrayList alStart and alStartType
            do
            {
                token = tok.Next(); temp1 = token.Kind.ToString(); temp2 = token.Value;
                al.Add(temp2); alType.Add(temp1);
            } while (token.Kind != TokenKind.EOF);
            //adding extra blanks, to avoid problems with overrun when probing alStart[i+x]
            for (int i = 1; i < Globals.extra; i++)
            {
                al.Add(""); alType.Add("");
            }
        }


        public static void MakeFlatOrZero(GekkoTime tStart, GekkoTime tEnd, List<string> list, bool zero)
        {
            Databank db = Program.databanks.GetFirst();
            List<string> unfoldedList = list;

            List<string> listUsedHere = new List<string>();
            if (list.Count == 0)
            {
                Dictionary<string, TimeSeries> vars = db.storage;
                foreach (string var in vars.Keys)
                {
                    listUsedHere.Add(var);
                }
            }
            else
            {
                listUsedHere.AddRange(list);
            }

            foreach (string var in listUsedHere)
            {
                TimeSeries ts = db.GetVariable(var);
                if (ts == null)
                {
                    G.Writeln2("*** ERROR: variable '" + var + "' not found");
                    throw new GekkoException();
                }
                GekkoTime tStartM1 = tStart.Add(-1);
                double lastVal = ts.GetData(tStartM1);
                foreach (GekkoTime t in new GekkoTimeIterator( tStart, tEnd))
                {
                    if (zero)
                    {
                        ts.SetData(t, 0d);
                    }
                    else
                    {
                        ts.SetData(t, lastVal);
                    }
                }
            }
        }

        public static void CompareModelDatabankVarlist()
        {
            if (Program.model == null)
            {
                G.Writeln2("*** ERROR: No model seems to be loaded, cf. the MODEL statement.");
                G.Writeln("*** ERROR: The comparison could not be performed.");
                return;
            }
            int dublets = 0;
            Dictionary<string, int> varlistDublets = new Dictionary<string, int>();
            CaseInsensitiveHashtable varlist = new CaseInsensitiveHashtable();
            if (Program.unfoldedVariableList != null)
            {
                foreach (Program.Item item in Program.unfoldedVariableList)
                {
                    string varName = item.variable;
                    if (varlist.ContainsKey(varName))
                    {
                        dublets++;
                        if (varlistDublets.ContainsKey(varName))
                        {
                            varlistDublets[varName]++;
                        }
                        else
                        {
                            varlistDublets.Add(varName, 2);
                        }
                    }
                    else
                    {
                        varlist.Add(varName, "");
                    }
                }
            }
            else
            {
                G.Writeln("+++ NOTE: a variable list was not found inside model file");
            }

            List<string> bothModelAndVarlist = new List<string>();
            List<string> onlyModelNotVarlist = new List<string>();
            List<string> onlyVarlistNotModel = new List<string>();
            List<string> bothModelAndDatabank = new List<string>();
            List<string> onlyModelNotDatabank = new List<string>();
            List<string> onlyDatabankNotModel = new List<string>();
            List<string> bothDatabankAndVarlist = new List<string>();
            List<string> onlyDatabankNotVarlist = new List<string>();
            List<string> onlyVarlistNotDatabank = new List<string>();

            foreach (string ss in Program.databanks.GetFirst().storage.Keys)
            {
                if (G.GetFreqFromKey(ss) != Program.options.freq) continue;  //filter other freqs
                string s = G.RemoveFreqFromKey(ss);
                if (Program.model.varsDTypeAutoGenerated.ContainsKey(s) || Program.model.varsJTypeAutoGenerated.ContainsKey(s) || Program.model.varsZTypeAutoGenerated.ContainsKey(s)) continue;
                if (Program.model.varsAType.ContainsKey(s))
                {
                    bothModelAndDatabank.Add(s);
                }
                else
                {
                    onlyDatabankNotModel.Add(s);
                }

                if (varlist.ContainsKey(s))
                {
                    bothDatabankAndVarlist.Add(s);
                }
                else
                {
                    onlyDatabankNotVarlist.Add(s);
                }
            }

            foreach (string s in Program.model.varsAType.Keys)
            {
                if (Program.model.varsDTypeAutoGenerated.ContainsKey(s) || Program.model.varsJTypeAutoGenerated.ContainsKey(s) || Program.model.varsZTypeAutoGenerated.ContainsKey(s)) continue;
                if (Program.databanks.GetFirst().ContainsVariable(s))
                {
                }
                else
                {
                    onlyModelNotDatabank.Add(s);
                }
                if (varlist.ContainsKey(s))
                {
                    bothModelAndVarlist.Add(s);
                }
                else
                {
                    onlyModelNotVarlist.Add(s);
                }
            }


            foreach (string s in varlist.Keys)
            {
                if (Program.databanks.GetFirst().ContainsVariable(s))
                {
                }
                else
                {
                    onlyVarlistNotDatabank.Add(s);
                }
                if (Program.model.varsAType.ContainsKey(s))
                {
                }
                else
                {
                    onlyVarlistNotModel.Add(s);
                }
            }

            bothModelAndVarlist.Sort(StringComparer.InvariantCulture);
            onlyModelNotVarlist.Sort(StringComparer.InvariantCulture);
            onlyVarlistNotModel.Sort(StringComparer.InvariantCulture);
            bothModelAndDatabank.Sort(StringComparer.InvariantCulture);
            onlyModelNotDatabank.Sort(StringComparer.InvariantCulture);
            onlyDatabankNotModel.Sort(StringComparer.InvariantCulture);
            bothDatabankAndVarlist.Sort(StringComparer.InvariantCulture);
            onlyDatabankNotVarlist.Sort(StringComparer.InvariantCulture);
            onlyVarlistNotDatabank.Sort(StringComparer.InvariantCulture);

            string fullFileNameAndPath = CreateFullPathAndFileName("compare.txt");

            using (FileStream fs = WaitForFileStream(fullFileNameAndPath, GekkoFileReadOrWrite.Write))
            using (StreamWriter compareFile = G.GekkoStreamWriter(fs))
            {

                if (dublets > 0)
                {
                    compareFile.WriteLine("NOTE: there were " + dublets + " dublets in the varlist.");
                    compareFile.WriteLine("These dublets are ignored in the following comparisons.");
                    compareFile.WriteLine("The dublets are listed at the bottom of this file.");
                    compareFile.WriteLine();
                }
                compareFile.WriteLine("When comparing, auto-generated DJZ-type exogenous variables are ignored.");
                compareFile.WriteLine("Such variables appear in the model, sometimes in the databank");
                compareFile.WriteLine("(for instance when writing after a simulation), but in general");
                compareFile.WriteLine("not in the varlist. So comparing these kinds of variables does not");
                compareFile.WriteLine("make much sense and would just pollute the comparison.");
                compareFile.WriteLine();
                compareFile.WriteLine("----------------------------------------------------------");
                compareFile.WriteLine("--------------------- Model/databank ---------------------");
                compareFile.WriteLine("----------------------------------------------------------");
                compareFile.WriteLine("Both model and databank:     " + G.IntFormat(bothModelAndDatabank.Count, 7) + " variables");
                compareFile.WriteLine("In databank, not in model:   " + G.IntFormat(onlyDatabankNotModel.Count, 7) + " variables");
                compareFile.WriteLine("In model, not in databank:   " + G.IntFormat(onlyModelNotDatabank.Count, 7) + " variables");
                compareFile.WriteLine();
                compareFile.WriteLine("----------------------------------------------------------");
                compareFile.WriteLine("--------------------- Model/varlist  ---------------------");
                compareFile.WriteLine("----------------------------------------------------------");
                compareFile.WriteLine("Both model and varlist:      " + G.IntFormat(bothModelAndVarlist.Count, 7) + " variables");
                compareFile.WriteLine("In model, not in varlist:    " + G.IntFormat(onlyModelNotVarlist.Count, 7) + " variables");
                compareFile.WriteLine("In varlist, not in model:    " + G.IntFormat(onlyVarlistNotModel.Count, 7) + " variables");
                compareFile.WriteLine();
                compareFile.WriteLine("----------------------------------------------------------");
                compareFile.WriteLine("--------------------- Databank/varlist  ------------------");
                compareFile.WriteLine("----------------------------------------------------------");
                compareFile.WriteLine("Both databank and varlist:   " + G.IntFormat(bothDatabankAndVarlist.Count, 7) + " variables");
                compareFile.WriteLine("In varlist, not in databank: " + G.IntFormat(onlyVarlistNotDatabank.Count, 7) + " variables");
                compareFile.WriteLine("In databank, not in varlist: " + G.IntFormat(onlyDatabankNotVarlist.Count, 7) + " variables");
                compareFile.WriteLine();
                compareFile.WriteLine();
                compareFile.WriteLine("Below, missing variables are listed");
                compareFile.WriteLine();
                compareFile.WriteLine("In databank, not in model:   " + G.IntFormat(onlyDatabankNotModel.Count, 7) + " variables");
                compareFile.WriteLine("----------------------------------------------------------");
                G.PrintListWithCommasToFile(compareFile, onlyDatabankNotModel);
                compareFile.WriteLine();
                compareFile.WriteLine();
                compareFile.WriteLine("In model, not in databank:   " + G.IntFormat(onlyModelNotDatabank.Count, 7) + " variables");
                compareFile.WriteLine("----------------------------------------------------------");
                G.PrintListWithCommasToFile(compareFile, onlyModelNotDatabank);
                compareFile.WriteLine();
                compareFile.WriteLine();
                compareFile.WriteLine("In model, not in varlist:    " + G.IntFormat(onlyModelNotVarlist.Count, 7) + " variables");
                compareFile.WriteLine("----------------------------------------------------------");
                G.PrintListWithCommasToFile(compareFile, onlyModelNotVarlist);
                compareFile.WriteLine();
                compareFile.WriteLine();
                compareFile.WriteLine("In varlist, not in model:    " + G.IntFormat(onlyVarlistNotModel.Count, 7) + " variables");
                compareFile.WriteLine("----------------------------------------------------------");
                G.PrintListWithCommasToFile(compareFile, onlyVarlistNotModel);
                compareFile.WriteLine();
                compareFile.WriteLine();
                compareFile.WriteLine("In varlist, not in databank: " + G.IntFormat(onlyVarlistNotDatabank.Count, 7) + " variables");
                compareFile.WriteLine("----------------------------------------------------------");
                G.PrintListWithCommasToFile(compareFile, onlyVarlistNotDatabank);
                compareFile.WriteLine();
                compareFile.WriteLine();
                compareFile.WriteLine("In databank, not in varlist: " + G.IntFormat(onlyDatabankNotVarlist.Count, 7) + " variables");
                compareFile.WriteLine("----------------------------------------------------------");
                G.PrintListWithCommasToFile(compareFile, onlyDatabankNotVarlist);
                compareFile.WriteLine();
                compareFile.WriteLine();
                compareFile.WriteLine();
                compareFile.WriteLine("-----------------------------------------------------------");
                compareFile.WriteLine("The following variables are dublets in the varlist");
                foreach (KeyValuePair<string, int> x in varlistDublets)
                {
                    compareFile.WriteLine(G.varFormat(x.Key) + " --> " + x.Value + " times");
                }
                if (varlistDublets.Count == 0) compareFile.WriteLine("<none>");
                compareFile.Flush();
            }
        }

        public static void CompareModelDatabank()
        {
            //IS THIS OBSOLETE??

            GekkoTime tStart = Globals.globalPeriodStart;
            GekkoTime tEnd = Globals.globalPeriodEnd;

            if (Program.model == null)
            {
                G.Writeln2("*** ERROR: No model seems to be loaded, cf. the MODEL statement.");
                G.Writeln("*** ERROR: The comparison could not be performed.");
                return;
            }

            List<string> bothModelAndDatabank = new List<string>();
            List<string> onlyModelNotDatabank = new List<string>();
            List<string> onlyDatabankNotModel = new List<string>();

            foreach (string s in Program.databanks.GetFirst().storage.Keys)
            {
                if (Program.model.varsDTypeAutoGenerated.ContainsKey(s) || Program.model.varsJTypeAutoGenerated.ContainsKey(s) || Program.model.varsZTypeAutoGenerated.ContainsKey(s)) continue;
                if (Program.model.varsAType.ContainsKey(s))
                {
                    bothModelAndDatabank.Add(s);
                }
                else
                {
                    onlyDatabankNotModel.Add(s);
                }
            }

            foreach (string s in Program.model.varsAType.Keys)
            {
                if (Program.model.varsDTypeAutoGenerated.ContainsKey(s) || Program.model.varsJTypeAutoGenerated.ContainsKey(s) || Program.model.varsZTypeAutoGenerated.ContainsKey(s)) continue;
                if (Program.databanks.GetFirst().storage.ContainsKey(s))
                {
                }
                else
                {
                    onlyModelNotDatabank.Add(s);
                }
            }

            bothModelAndDatabank.Sort(StringComparer.InvariantCulture);
            onlyModelNotDatabank.Sort(StringComparer.InvariantCulture);
            onlyDatabankNotModel.Sort(StringComparer.InvariantCulture);

            List<string> varsWithMissingValues = new List<string>();

            Databank work = Program.databanks.GetFirst();
            foreach (string s in bothModelAndDatabank)
            {
                foreach (GekkoTime t in new GekkoTimeIterator( tStart, tEnd))
                {
                    double value = work.GetVariable(s).GetData(t);
                    if (G.isNumericalError(value))
                    {
                        varsWithMissingValues.Add(s);
                        break;
                    }
                }
            }
            varsWithMissingValues.Sort();  //probably not necessary, but oh well

            string fullFileNameAndPath = CreateFullPathAndFileName("compare.txt");

            using (FileStream fs = WaitForFileStream(fullFileNameAndPath, GekkoFileReadOrWrite.Write))
            using (StreamWriter compareFile = G.GekkoStreamWriter(fs))
            {
                compareFile.WriteLine("When comparing, auto-generated DJZ-type exogenous variables are ignored.");
                compareFile.WriteLine("Such variables appear in the model and sometimes in the databank");
                compareFile.WriteLine("(for instance when writing a databank after a simulation).");
                compareFile.WriteLine("So comparing these kinds of variables does not");
                compareFile.WriteLine("make much sense and would just pollute the comparison.");
                compareFile.WriteLine();
                compareFile.WriteLine("----------------------------------------------------------");
                compareFile.WriteLine("-------------- Compare model and databank ----------------");
                compareFile.WriteLine("----------------------------------------------------------");
                compareFile.WriteLine();
                compareFile.WriteLine("Both model and databank:   " + G.IntFormat(bothModelAndDatabank.Count, 7) + " variables");
                compareFile.WriteLine("In databank, not in model: " + G.IntFormat(onlyDatabankNotModel.Count, 7) + " variables");
                compareFile.WriteLine("In model, not in databank: " + G.IntFormat(onlyModelNotDatabank.Count, 7) + " variables");
                compareFile.WriteLine();
                compareFile.WriteLine("Below, missing variables are listed");
                compareFile.WriteLine();
                compareFile.WriteLine("In model, not in databank:   " + G.IntFormat(onlyModelNotDatabank.Count, 7) + " variables");
                compareFile.WriteLine("----------------------------------------------------------");
                G.PrintListWithCommasToFile(compareFile, onlyModelNotDatabank);
                compareFile.WriteLine();
                compareFile.WriteLine();
                compareFile.WriteLine("From the " + G.IntFormat(bothModelAndDatabank.Count, 7) + " variables in both model and databank,");
                compareFile.WriteLine("there are missing values in " + varsWithMissingValues.Count + " of these, for the given period " + tStart.ToString() + " to " + tEnd.ToString() + ":");
                compareFile.WriteLine("----------------------------------------------------------");
                G.PrintListWithCommasToFile(compareFile, varsWithMissingValues);
                compareFile.WriteLine();
                compareFile.WriteLine();
                compareFile.WriteLine("The following " + G.IntFormat(onlyDatabankNotModel.Count, 7) + " variables are in the databank, but not in the model:");
                compareFile.WriteLine("----------------------------------------------------------");
                G.PrintListWithCommasToFile(compareFile, onlyDatabankNotModel);
                compareFile.WriteLine();
                compareFile.WriteLine();

                compareFile.Flush();
            }
        }

        private static void ResidualCheck(string checkType, bool dlog, bool split)
        {
            string outputPath = Globals.localTempFilesLocation + "\\" + "residualcheck";
            DeleteFolder(outputPath);
            Directory.CreateDirectory(outputPath);

            //This code is not high-performant, but oh well...
            if (split)
            {
                List<string> d = new List<string>();
                foreach (EquationHelper eh in Program.model.equations)
                {
                    string block = eh.modelBlock;
                    if (!d.Contains(block)) d.Add(block);
                }
                d.Sort();
                foreach (string s in d)
                {
                    ResidualCheckHelper(checkType, dlog, s, outputPath);
                }
            }
            else ResidualCheckHelper(checkType, dlog, null, outputPath);

            G.Writeln();
            G.Write("Zipping residual check files... ");
            string zipfile = Program.options.folder_working + "\\residual_check.zip";
            string zipFileNameInput = Program.CreateFullPathAndFileName(zipfile);
            Program.WaitForZipWrite(outputPath, zipFileNameInput);
            G.Writeln("... ended");
            G.Writeln("See 'residual_check.zip'");
            G.Writeln();
        }

        private static void ResidualCheckHelper(string checkType, bool dlog, string block, string path)
        {
            Databank work = Program.databanks.GetFirst();
            List<string> d_type = new List<string>();
            List<string> g_type = new List<string>();
            List<string> i_type = new List<string>();
            List<string> k_type = new List<string>();
            List<string> s_type = new List<string>();
            List<string> after_i_type = new List<string>();
            List<string> after_d_type = new List<string>();

            foreach (EquationHelper eh in Program.model.equations)
            {
                if (block != null && !G.equal(block, eh.modelBlock)) continue; //out-filtering those that are not in chosen block
                string var = eh.lhs;
                string code = eh.equationCode;

                if (true)
                {
                    if (G.equal(code.Substring(0, 1), "i"))
                    {
                        after_i_type.Add(var);
                    }
                    else if (G.equal(code.Substring(0, 1), "d"))  //in frml file, it starts with "y" and typically var name (yEnly)
                    {
                        after_d_type.Add(var);
                    }
                    else
                    {
                        if (code.Length <= 1)
                        {
                            G.Writeln("+++ WARNING: formula code regarding '" + var + "' seems problematic: " + code);
                        }
                        if (code.Length >= 2)
                        {
                            if (code.Substring(0, 1) != "_")
                            {
                                G.Writeln("+++ WARNING: formula code regarding '" + var + "' does not start with '_' or 'i' or 'y': " + code);
                            }
                            else
                            {
                                string type = code.Substring(1, 1).ToLower();
                                if (type == "d")
                                {
                                    d_type.Add(var);
                                }
                                else if (type == "g")
                                {
                                    g_type.Add(var);
                                }
                                else if (type == "i")
                                {
                                    i_type.Add(var);
                                }
                                else if (type == "k")
                                {
                                    k_type.Add(var);
                                }
                                else if (type == "s")
                                {
                                    s_type.Add(var);
                                }
                                else
                                {
                                    G.Writeln("+++ WARNING: there was a unknown formula code type (i.e. not _d, _g, _i, _k or _s) regarding '" + var + "': " + code);
                                }
                            }
                        }
                        else
                        {
                            G.Writeln("+++ WARNING: there was a unknown formula code type (i.e. not _d, _g, _i, _k or _s) regarding '" + var + "': " + code);
                        }
                    }
                }
            }

            int t1 = Globals.globalPeriodStart.super;
            int t2 = Globals.globalPeriodEnd.super;

            string type2 = "";
            bool order = false;
            if (checkType == "absolute")
            {
                type2 = "absolute";
                order = true;
            }
            else if (checkType == "relative")
            {
                type2 = "relative";
                order = true;
            }
            else if (checkType == "alphabetical")
            {
                type2 = "alphabetical";
                order = false;
            }
            else
            {
                //hmmmm
            }

            GekkoTime gt1 = new GekkoTime((Program.options.freq), t1, 1);
            GekkoTime gt2 = new GekkoTime((Program.options.freq), t2, 1);

            Sam(gt1, gt2, Program.databanks.GetRef(), Program.databanks.GetFirst(), type2, order, d_type, "_d", dlog, block, path);
            Sam(gt1, gt2, Program.databanks.GetRef(), Program.databanks.GetFirst(), type2, order, g_type, "_g", dlog, block, path);
            Sam(gt1, gt2, Program.databanks.GetRef(), Program.databanks.GetFirst(), type2, order, i_type, "_i", dlog, block, path);
            Sam(gt1, gt2, Program.databanks.GetRef(), Program.databanks.GetFirst(), type2, order, k_type, "_k", dlog, block, path);
            Sam(gt1, gt2, Program.databanks.GetRef(), Program.databanks.GetFirst(), type2, order, s_type, "_s", dlog, block, path);
            Sam(gt1, gt2, Program.databanks.GetRef(), Program.databanks.GetFirst(), type2, order, after_i_type, "_after_i", dlog, block, path);
            Sam(gt1, gt2, Program.databanks.GetRef(), Program.databanks.GetFirst(), type2, order, after_d_type, "_after_d", dlog, block, path);
        }

        public static string GetModelInfoPath()
        {
            //put in local files on user pc
            int random = Globals.modelRandomID;
            string path = Globals.localTempFilesLocation + "\\" + Globals.modelFileName.Replace(".frm", "") + "__info" + "_" + random;
            return path;
        }

        public static void CreateTempFilesFolder()
        {
            if (!Directory.Exists(Globals.localTempFilesLocation))
            {
                Directory.CreateDirectory(Globals.localTempFilesLocation);
            }
        }

        public static void CreateLocalCopyHelpChm()
        {
            if (Program.options.interface_help_copylocal)
            {
                try
                {
                    string file = "";
                    if (Program.options.folder_help != "")
                    {
                        file = Program.options.folder_help + "\\gekko.chm";
                    }
                    else file = Application.StartupPath + "\\helpfiles\\gekko.chm";
                    if (File.Exists(file))
                    {
                        string tempPath = Globals.localTempFilesLocation + "\\" + "gekko.chm";
                        if (File.Exists(tempPath))
                        {
                            File.SetAttributes(tempPath, FileAttributes.Normal);  //it may be read-only if original file is so
                            File.Delete(tempPath);
                        }

                        File.Copy(file, tempPath, true);

                        G.WritelnGray("Local copying: gekko.chm");
                    }
                }
                catch
                {
                    //do nothing, we will survive this!
                }
            }
        }

        public static string GetTempTsdFilePath(string type)
        {
            string tempPath = null;
            for (int i = 0; i < 100; i++)
            {
                int random = Program.RandomInt(11111111, 99999999);
                tempPath = Globals.localTempFilesLocation + "\\" + "temp" + type + "file" + "_" + random + "." + type;
                if (!File.Exists(tempPath)) break; //should normally be the case
                tempPath = null;  //very rare case probably: try with new random name
            }
            if (tempPath == null)
            {
                //tried random name 100 times, this should never happen... 100 blocked files at one time not very realistic...
                G.Writeln2("*** ERROR: Could not make local copy of tsd file (filename problem)");
                throw new GekkoException();
            }
            return tempPath;
        }

        public static string GetTempTsdxFolderPath()
        {
            //put in local files on user pc
            //Random r = new Random();
            int random = Program.RandomInt(11111111, 99999999);
            string path = Globals.localTempFilesLocation + "\\" + "temptsdxfolder" + "_" + random;
            return path;
        }

        public static void Sam1()
        {
            Sam(Globals.globalPeriodStart, Globals.globalPeriodEnd, Program.databanks.GetRef(), Program.databanks.GetFirst(), "", false);
        }
        public static void Sam2()
        {
            Sam(Globals.globalPeriodStart, Globals.globalPeriodEnd, Program.databanks.GetRef(), Program.databanks.GetFirst(), "absolute", true);
        }
        public static void Sam3()
        {
            Sam(Globals.globalPeriodStart, Globals.globalPeriodEnd, Program.databanks.GetRef(), Program.databanks.GetFirst(), "relative", true);
        }
        public static void SamE1(bool dlog, bool split)
        {
            ResidualCheck("alphabetical", dlog, split);
        }
        public static void SamE2(bool dlog, bool split)
        {
            ResidualCheck("absolute", dlog, split);
        }
        public static void SamE3(bool dlog, bool split)
        {
            ResidualCheck("relative", dlog, split);
        }

        public static void Sam(GekkoTime tStart, GekkoTime tEnd, Databank base2, Databank work, string type, bool order)
        {
            //Called in order to compare databanks, 5 last args inactive
            Sam(tStart, tEnd, base2, work, type, order, null, null, false, null, null);
        }

        public static void Sam(GekkoTime tStart, GekkoTime tEnd, Databank base2, Databank work, string compareType, bool order, List<string> variables, string variablesType, bool dlog, string block, string path)
        {
            //TODO: could be more clearly coded, with 6 compareTypes (3 databank and 3 residuals), doing a 'variables == null' is not too pretty
            //TODO: error handling if var not found in one of the banks in residual check
            //TODO: option to use CalculateHistoricalVarianceForVariable() and CheckRelativeDifferenceSmart()

            if (variables != null && variables.Count == 0)
            {
                return;  //to avoid empty files, especially when dividing into blocks
            }

            List<string> both = variables;  //may be null

            SortedList ordered = new SortedList();
            int count = 0;

            string samFileName = "";

            if (variables == null)
            {
                //i.e. we are doing a databank compare, not a residual compare
                samFileName = "compare_databanks.txt";
                path = Program.options.folder_working;
            }
            else
            {
                string s = "";
                if (block != null)
                {
                    s = "_" + block;
                }
                samFileName = "residuals" + s + variablesType + ".txt";
            }

            int pcounter = 0;
            //string fullPathAndFileName = CreateFullPathAndFileName(samFileName);
            string fullPathAndFileName = path;
            using (FileStream fs = WaitForFileStream(fullPathAndFileName + "\\" + samFileName, GekkoFileReadOrWrite.Write))
            using (StreamWriter samFile = G.GekkoStreamWriter(fs))
            {
                if (variables == null)
                {
                    //i.e. we are doing a databank compare, not a residual compare
                    both = new List<string>();
                    List<string> onlyWork = new List<string>();
                    List<string> onlyGrund = new List<string>();

                    foreach (string tsString in work.storage.Keys) 
                    {
                        if (G.GetFreqFromKey(tsString) != Program.options.freq) continue;  //filter other freqs
                        string s = G.RemoveFreqFromKey(tsString);
                        TimeSeries tsGrund = base2.GetVariable(s);
                        if (tsGrund == null)
                        {
                            onlyWork.Add(s);
                        }
                        else
                        {
                            both.Add(s);
                        }
                    }
                    foreach (string tsString in base2.storage.Keys)  
                    {
                        if (G.GetFreqFromKey(tsString) != Program.options.freq) continue;  //filter other freqs
                        string s = G.RemoveFreqFromKey(tsString);
                        TimeSeries tsWork = work.GetVariable(s);
                        if (tsWork == null)
                        {
                            onlyGrund.Add(s);
                        }
                    }

                    both.Sort(StringComparer.InvariantCulture);
                    onlyWork.Sort(StringComparer.InvariantCulture);
                    onlyGrund.Sort(StringComparer.InvariantCulture);

                    samFile.WriteLine("Comparing first-position (" + GetDatabankFileNameWithPath(Program.databanks.GetFirst().aliasName) + ") and reference (" + GetDatabankFileNameWithPath(Program.databanks.GetRef().aliasName) + ") databanks");
                    samFile.WriteLine();
                    samFile.WriteLine("There are the following " + both.Count + " variables in both banks:");
                    G.PrintListWithCommasToFile(samFile, both);
                    samFile.WriteLine();
                    samFile.WriteLine();
                    samFile.WriteLine("There are the following " + onlyWork.Count + " variables in Work but not in " + Globals.Ref + " databank:");
                    G.PrintListWithCommasToFile(samFile, onlyWork);
                    if (onlyWork.Count == 0) samFile.WriteLine("[none]");
                    samFile.WriteLine();
                    samFile.WriteLine();
                    samFile.WriteLine("There are the following " + onlyGrund.Count + " variables in " + Globals.Ref + " but not in Work databank:");
                    G.PrintListWithCommasToFile(samFile, onlyGrund);
                    if (onlyGrund.Count == 0) samFile.WriteLine("[none]");
                    samFile.WriteLine();
                    samFile.WriteLine();
                }
                else
                {
                    //TODO: use Add1ToFileName kind of logic.
                    //maybe pack result in zip-file, res_check.zip, res_check1.zip of already there.
                    both.Sort(StringComparer.InvariantCulture);
                    samFile.WriteLine("Residual check, looking at '" + variablesType + "' type equations one by one");
                    if (order)
                    {
                        if (compareType == "absolute") samFile.WriteLine("Ordered by absolute differences");
                        if (compareType == "relative") samFile.WriteLine("Ordered by relative differences");
                        if (compareType == "alphabetical") samFile.WriteLine("Ordered alphabetically");
                    }
                    samFile.WriteLine("The following " + both.Count + " equations are checked:");
                    samFile.WriteLine();
                    G.PrintListWithCommasToFile(samFile, both);
                    samFile.WriteLine();
                    samFile.WriteLine();
                }


                //There is a little bit unnecessary overhead here, if compareType is "alphabetical". But never mind.
                foreach (string tsString in both)
                {
                    TimeSeries ts = work.GetVariable(tsString);
                    TimeSeries tsGrund = base2.GetVariable(tsString);

                    if (ts == null || tsGrund == null)
                    {
                        //Should not happen if SIM/RES autocreates variables
                        if (ts == null) G.Writeln("+++ WARNING: Variable '" + tsString + "' was not found in Work databank");
                        if (tsGrund == null) G.Writeln("+++ WARNING: Variable '" + tsString + "' was not found in " + Globals.Ref + " databank");
                        pcounter++;
                        continue;
                    }

                    count++;

                    //See also similar code in Difprt()
                    double max = 0d;
                    foreach (GekkoTime t in new GekkoTimeIterator( tStart, tEnd))
                    {
                        double varDelta = 0;
                        double varPch = 0;

                        double var1 = ts.GetData(t);
                        double var2 = tsGrund.GetData(t);
                        if (var1 == 0 && var2 == 0d)
                        {
                            varPch = 0d;
                            varDelta = var1 - var2;
                        }
                        else if (var2 == 0)
                        {
                            varPch = 1e+100d;
                            varDelta = var1 - var2;
                        }
                        else if (double.IsNaN(var1) && double.IsNaN(var2))
                        {
                            //this is considered okay
                            varPch = 0d;
                            varDelta = 0d;
                        }
                        else if ((double.IsNaN(var1) && !double.IsNaN(var2)) || (!double.IsNaN(var1) && double.IsNaN(var2)))
                        {
                            //this is considered a problem
                            varPch = 1e+100d;
                            varDelta = 1e+100;
                        }
                        else
                        {
                            varPch = ((var1 / var2 - 1d) * 100d);
                            varDelta = var1 - var2;
                        }

                        if (compareType == "absolute")
                        {
                            max = Math.Max(Math.Abs(varDelta), max);
                        }
                        else
                        {
                            max = Math.Max(Math.Abs(varPch), max);
                        }
                        if (G.isNumericalError(max))
                        {
                            //this is igonred
                        }
                    }

                    if (G.isNumericalError(max))
                    {
                        //This probably never happens... for safety...
                        max = 1e+100d;
                    }

                    if (max == 0) continue;  //don't show vars if they are identical
                    double max1 = max * (1d + count / 12345678912d) + count / 12345678912d;
                    if (order)
                    {
                        while (true)
                        {
                            if (ordered.ContainsKey(-max1))
                            {
                                //this is very seldom, multiply with something small and add something small
                                //Random r = new Random();
                                double r2 = Program.RandomDouble();
                                max = max * (1 + r2 / 1000000d) + r2 / 1000000d;
                            }
                            else break;
                        }
                    }
                    if (order) ordered.Add(-max1, tsString);
                    else ordered.Add(tsString, tsString);
                }

                if (variables == null)
                {
                    //databank compare
                    samFile.WriteLine("Out of the " + both.Count + " common variables, there are residuals regarding " + ordered.Count + " of them:");
                    if (ordered.Count == 0) samFile.WriteLine("[none]");
                    samFile.WriteLine();
                }
                else
                {
                    //equation residuals
                    samFile.WriteLine("Out of the " + both.Count + " equations, there are residuals in " + ordered.Count + " of them:");
                    if (ordered.Count == 0) samFile.WriteLine("[none]");
                    samFile.WriteLine();
                }
                int counter = 0;
                foreach (DictionaryEntry key in ordered)
                {
                    counter++;
                    string tsString = (string)key.Value;
                    double number = 0;
                    if (order)
                    {
                        number = (double)key.Key;
                    }
                    TimeSeries ts = work.GetVariable(tsString);
                    TimeSeries tsGrund = base2.GetVariable(tsString);

                    if (variables == null)
                    {
                        samFile.Write(G.varFormat(tsString) + "   WORK       REFERENCE             ABS DIFF      % DIFF");
                    }
                    else
                    {
                        samFile.Write(G.varFormat(tsString) + "   FRML       DATABANK              ABS DIFF      % DIFF");
                    }
                    if (dlog)
                    {
                        samFile.Write("       DLOG");
                    }

                    if (order)
                    {
                        if (compareType == "relative")
                        {

                            samFile.WriteLine("         max = " + G.pchFormatOld(-number));
                        }
                        else
                        {
                            samFile.WriteLine("         max = " + G.levelFormatOld(-number));
                        }
                    }
                    else
                    {
                        samFile.WriteLine();
                    }

                    samFile.Write("-------------------------------------------------------------------");
                    if (dlog) samFile.WriteLine("------------");
                    samFile.WriteLine();

                    foreach (GekkoTime t in new GekkoTimeIterator( tStart, tEnd))
                    {
                        double varLevel = 0;
                        double varLevel2 = 0;
                        double varDelta = 0;
                        double varPch = 0;
                        double varDlog = double.NaN;
                        samFile.Write(t + " ");

                        {
                            varLevel = ts.GetData(t);
                            varLevel2 = tsGrund.GetData(t);
                            varDelta = ts.GetData(t) - tsGrund.GetData(t);
                            varPch = ((ts.GetData(t) / tsGrund.GetData(t) - 1d) * 100d);
                            if (dlog)
                            {
                                varDlog = Math.Log(tsGrund.GetData(t) / ts.GetData(t));
                            }

                            samFile.Write(G.levelFormatOld(varLevel));
                            samFile.Write(" ");
                            samFile.Write(G.levelFormatOld(varLevel2));
                            samFile.Write("       ");
                            samFile.Write(G.levelFormatOld(varDelta));
                            samFile.Write("    ");
                            if (varDelta == 0d) varPch = 0d; //this way, two clean 0's get 0% difference
                            samFile.Write(G.pchFormatOld(varPch));
                            if (dlog)
                            {
                                samFile.Write("    ");
                                samFile.Write(G.levelFormatOld(varDlog, 8));
                            }
                        }
                        samFile.WriteLine();
                    }
                    samFile.WriteLine();
                }
                samFile.Flush();
            }
            if (variables == null) G.Writeln("Databank compare on " + both.Count + " common variables, result put in file '" + samFileName + "'");
            else
            {
                G.Writeln("Residual check on " + both.Count + " equations of type " + variablesType + ", result put in file '" + samFileName + "'");
                if (pcounter > 0) G.Writeln("+++ WARNING: " + pcounter + " variables were missing in either Work or " + Globals.Ref + " databank");
            }
        }


        public static void ReleasePipe()
        {
            //In order to release any current piping to file, so it does not block other users
            if (Globals.pipeFileHelper.pipeFile != null)
            {
                Globals.pipeFileHelper.CloseFile();
            }
            Globals.pipeFileHelper.pipeFile = null;
            Globals.pipeFileHelper.pipeFileFileWithPath = "";
            Globals.pipe = false;
        }

        public static void ReleasePipe2()
        {
            //Release piping to file when doing stuff like "prt fy file=output.txt"
            if (Globals.pipeFileHelper2.pipeFile != null)
            {
                Globals.pipeFileHelper2.CloseFile();
            }
            Globals.pipeFileHelper2.pipeFile = null;
            Globals.pipeFileHelper2.pipeFileFileWithPath = "";
            Globals.pipe2 = false;
        }

        public static string MaybeAddPointAndZero(string s)
        {
            bool isInt = true;
            foreach (char c in s)
            {
                if (!Char.IsDigit(c)) isInt = false;
            }
            if (isInt) s = s + ".0";  //so it does not look like an integer -- user can see it is float
            return s;
        }

        public static string GetDatabankFilename(Databank databank)
        {
            return System.IO.Path.GetFileName(databank.FileNameWithPath);
        }

        private static List<Dictionary<string, string>> CreateSimplePrecedentsForPrtPplot(List<string> variables)
        {
            //just done to use PrtPplot(),
            List<Dictionary<string, string>> ll3 = new List<Dictionary<string, string>>();
            Dictionary<string, string> temp = new Dictionary<string, string>();
            foreach (string v in variables)
            {
                Dictionary<string, string> temp2 = new Dictionary<string, string>();
                temp2.Add(v, "");
                ll3.Add(temp);
            }
            return ll3;
        }

        public static string TableHelper(string inputFileName, bool menuTable)
        {
            //!! used in dynamic code
            //This is called from "TABLE filename.tab" command, including calls from menus which
            //will issue such a command in a thread (is so, menuTable is true).

            //inputFileName = Program.SubstituteAssignVarsInExpression(inputFileName);
            inputFileName = Program.AddExtension(inputFileName, "." + Globals.extensionTable);

            List<string> folders = new List<string>();

            folders.Add(Program.options.folder_table);
            folders.Add(Program.options.folder_table1);
            folders.Add(Program.options.folder_table2);
            if (menuTable)  //never done for normal table call
            {
                folders.Add(Path.GetDirectoryName(inputFileName));
                //Called from menus, a .tab file will always be with a full path.
                //But we want it to look in other folders too, so we strip the
                //path (added to folders above) and keep the filename.
                inputFileName = Path.GetFileName(inputFileName);
            }

            string fileNameTemp = SearchForFile(inputFileName, folders);
            if (fileNameTemp == null)
            {
                string s = FileNotFoundErrorMessage(inputFileName);
                MessageBox.Show(s);
                throw new GekkoException();
            }
            else inputFileName = fileNameTemp;
            return inputFileName;
        }

        public static void MulbkClone()
        {
            Databank first = Program.databanks.GetFirst();
            //DateTime dt3 = DateTime.Now;
            Databank secondary = Program.databanks.GetRef();
            secondary.Clear();
            G.CloneDatabank(secondary, first);
            secondary.FileNameWithPath = first.FileNameWithPath;
        }

        public static void CreateEndoNoLagBNumbers(int[] endoNoLagPointers)
        {
            Program.model.endogenousBNumbersOriginalInModelList = new List<int>();
            for (int i = 0; i < Program.model.varsBType.Count; i++)
            {
                if (endoNoLagPointers[i] != 1)
                {
                    continue;
                }
                Program.model.endogenousBNumbersOriginalInModelList.Add(i);
            }
        }

        /// <summary>
        /// For an endogenous variable, prints the ingoing variables and
        /// values of these.
        /// </summary>
        /// <param name="t">Time period</param>
        /// <param name="var1">Variable name</param>
        public static void PrintEquationVariables(GekkoTime t, string var1)
        {
            bool success = false;
            foreach (EquationHelper eh in Program.model.equations)
            {
                if (G.equal(eh.lhs, var1))
                {
                    PrintEquationVariables(t, eh);
                    success = true;
                }
            }
            if (!success) G.Writeln2("*** ERROR: Variable " + var1 + " was not found as left-hand side variable in model");
        }

        /// <summary>
        /// For an equation number, prints the ingoing variables and
        /// values of these.
        /// </summary>
        /// <param name="t">Time period</param>
        /// <param name="eqNumber">Equation number</param>
        public static void PrintEquationVariables(GekkoTime t, EquationHelper eh)
        {
            int widthRemember = Program.options.print_width;
            int fileWidthRemember = Program.options.print_filewidth;
            Program.options.print_width = int.MaxValue;
            Program.options.print_filewidth = int.MaxValue;

            try
            {
                G.Writeln(eh.equationText);
            }
            finally
            {
                //resetting, also if there is an error
                Program.options.print_width = widthRemember;
                Program.options.print_filewidth = fileWidthRemember;
            }

            string lhs = eh.lhs;
            Dictionary<string, string> precedents = eh.precedentsWithLagIndicator;
            string period = t.ToString();

            TimeSeries tsls = Program.databanks.GetFirst().GetVariable(lhs);

            if (tsls == null)
            {
                G.Writeln2("*** ERROR: Variable '" + lhs + "' does not exist in Work databank");
                throw new GekkoException();
            }

            G.Writeln();
            string period2 = "period " + period;
            //G.Writeln("Time period = " + period);
            G.Writeln("              " + (G.Blanks(14 - period2.Length) + period2) + "       %");

            G.Writeln("----------------------------------------");
            G.Write(lhs + G.Blanks(14 - lhs.Length));
            double t1 = tsls.GetData(t.Add(0));
            double t0 = tsls.GetData(t.Add(0 - 1));
            double pch = (t1 / t0 - 1) * 100d;
            if (t1 - t0 == 0d) pch = 0d;  //this way, two clean 0's get 0% difference
            string pch1 = G.pchFormatOld(pch);
            G.Writeln(G.levelFormatOld(t1) + " " + pch1);
            G.Writeln("----------------------------------------");
            foreach (string var in precedents.Keys)
            {
                string variable; int lag;
                G.ExtractVariableAndLag(var, out variable, out lag);
                string var2 = "";
                if (lag != 0)
                {
                    var2 = variable + "[" + lag + "]";
                }
                else
                {
                    var2 = variable;
                }
                G.Write(var2 + G.Blanks(14 - var2.Length));
                TimeSeries ts = Program.databanks.GetFirst().GetVariable(variable);

                if (variable == null)
                {
                    G.Writeln2("*** ERROR: Variable '" + variable + "' does not exist in Work databank");
                    throw new GekkoException();
                }

                t1 = ts.GetData(t.Add(lag));
                t0 = ts.GetData(t.Add(lag - 1));
                pch = (t1 / t0 - 1) * 100d;
                if (t1 - t0 == 0d) pch = 0d;  //this way, two clean 0's get 0% difference
                pch1 = G.pchFormatOld(pch);
                G.Writeln(G.levelFormatOld(t1) + " " + pch1);
            }
            //G.Writeln();
            G.Writeln("----------------------------------------");
            G.Writeln("Use 'DISP <" + G.FromDateToString(t) + " " + G.FromDateToString(t) + " info> variable;' or 'DECOMP <" + G.FromDateToString(t) + " " + G.FromDateToString(t) + "> variable;' to trace further.");
            G.Writeln();
        }

        //obsolete???
        private static void UpdPrt(List<string> al, List<string> alType)
        {
            //         0        1        2      3
            //      updprt <operator> <var1> <var2>
            Databank work = Program.databanks.GetFirst();
            Databank base2 = Program.databanks.GetRef();
            string op = (string)al[1];

            GekkoTime tStart = Globals.globalPeriodStart;
            GekkoTime tEnd = Globals.globalPeriodEnd;

            string extra = "¤ ";
            extra = "";

            for (int j = 2; j < al.Count; j++)
            {
                string var = (String)al[j];

                if (work.ContainsVariable(var))  //use tryGet for speedup
                {
                    G.Writeln();
                    TimeSeries ts = work.GetVariable(var);

                    G.Write(extra + "upd " + var + " " + tStart.super + " " + tEnd.super + " " + op + " ");
                    int counter = 0;

                    foreach (GekkoTime t in new GekkoTimeIterator(tStart, tEnd))
                    {
                        if (counter % 5 == 0)
                        {
                            G.Writeln();
                            G.Write(extra);
                        }
                        double data = double.NaN;
                        if (op == "=")
                        {
                            data = ts.GetData(t);
                        }
                        else if (op == "+")
                        {
                            if (base2.ContainsVariable(var))
                            {
                                TimeSeries tsgrund = base2.GetVariable(var);
                                data = ts.GetData(t) - tsgrund.GetData(t);
                            }
                            else
                            {
                                G.Writeln2("*** ERROR: updprt: variable '" + var + "' does not exist in base bank");
                            }
                        }
                        else
                        {
                            G.Writeln2("*** ERROR: updprt: operator not supported");
                            return;
                        }
                        string s = string.Format(System.Globalization.CultureInfo.InvariantCulture, "{0:0.0000000000E+00}", data);
                        if (data >= 0) G.Write(" ");
                        G.Write(" " + s);
                        counter++;
                    }
                }
                else
                {
                    G.Writeln2("*** ERROR: updprt: variable '" + var + "' does not exist in work bank");
                }
            }
            G.Writeln();
        }

        public static string AddFreqAtEndOfVariableName(string var)  //used most of the time, uses global freq
        {
            return AddFreqAtEndOfVariableName(var, Program.options.freq);
        }

        public static string AddFreqAtEndOfVariableName(string var, string freq)
        {
            return AddFreqAtEndOfVariableName(var, G.GetFreq(freq));
        }

        public static string AddFreqAtEndOfVariableName(string var, EFreq freq)
        {            
            if (freq == EFreq.Annual) return var;
            string var2 = var;
            if (freq == EFreq.Quarterly || freq == EFreq.Monthly || freq == EFreq.Undated)
            {
                if (var2.EndsWith(Globals.freqIndicator + "q") || var2.EndsWith(Globals.freqIndicator + "m") || var2.EndsWith(Globals.freqIndicator + "u"))
                {
                    //this is just a safety measure, to be deleted sometime
                    G.Writeln2("*** ERROR: strange behavior regarding freq indicator");
                    throw new GekkoException();
                }
                else
                {
                    if (freq == EFreq.Quarterly)
                    {
                        var2 = var + Globals.freqIndicator + "q";
                    }
                    else if (freq == EFreq.Monthly)
                    {
                        var2 = var + Globals.freqIndicator + "m";
                    }
                    else if (freq == EFreq.Undated)
                    {
                        var2 = var + Globals.freqIndicator + "u";
                    }
                    else
                    {
                        G.Writeln2("*** ERROR #745387463");
                        throw new GekkoException();
                    }
                    //for instance fy%q for fY in quarters
                }
            }
            else
            {
                G.Writeln2("*** ERROR: Internal error #74389642");
                throw new GekkoException();
            }
            //nothing done for "a" type
            return var2;
        }



        public static FileStream CheckIfFileIsBeingUsed(string fileName)
        {
            FileStream fs = null;
            try
            {
                //fs = File.Open(fileName, FileMode.Open, FileAccess.Read, FileShare.None);
                fs = File.Open(fileName, FileMode.Open, FileAccess.ReadWrite, FileShare.None);
            }
            catch (Exception e)
            {
                return null;
            }
            return fs;
        }



        public static string DoStuffWithDoubleUnderline(string text)
        {
            //In the long run, using RTF will be replaced by HTML. Double underlines and invisible text is just
            //not funny to write documentation with.
            //identifies double underline (code "\uldb").
            char[] t = text.ToCharArray();
            StringBuilder t2 = new StringBuilder();
            int max = t.Length - 10;  //make room for [i + x]
            for (int i = 0; i < max; i++)
            {
                if (t[i] == '\\' && t[i + 1] == 'u' && t[i + 2] == 'l' && t[i + 3] == 'd' && t[i + 4] == 'b' && t[i + 5] == '\\')
                {
                    t2.Append(t[i]);
                    t2.Append(t[i + 1]);
                    t2.Append(t[i + 2]);
                    t2.Append(t[i + 3]);
                    t2.Append(t[i + 4]);
                    t2.Append(t[i + 5]);
                    for (int j = i + 6; j < max; j++)
                    {
                        if (t[j] == ' ' && t[j + 1] != '\\')
                        {
                            t2.Append(t[j]);
                            t2.Append(" SIMPLELINK0 ");
                            //start of words
                            for (int k = j + 1; k < max; k++)
                            {
                                if (t[k] == '}')
                                {
                                    t2.Append(" SIMPLELINK1 ");

                                    if (true)
                                    {
                                        //find hidden text if any
                                        bool flag2 = false;  //met opening bracket
                                        bool flag3 = false;  //invisible code ("\v " or "\v\")
                                        for (int k2 = k + 1; k2 < max; k2++)
                                        {

                                            if (t[k2] == '\\' && t[k2 + 1] == 'u' && t[k2 + 2] == 'l' && t[k2 + 3] == 'd' && t[k2 + 4] == 'b' && t[k2 + 5] == '\\')
                                            {
                                                //not allowed to pass another underline -- probably something wrong: break out.
                                                t2.Append("<null>");
                                                t2.Append(" SIMPLELINK2 ");
                                                goto Flag2;
                                            }

                                            if (t[k2] == '\\' && t[k2 + 1] == 'v' && (t[k2 + 2] == '\\' || t[k2 + 2] == ' '))
                                            {
                                                flag3 = true;
                                            }
                                            if (t[k2] == '{')
                                            {
                                                flag2 = true;
                                            }
                                            if (t[k2] == '}')
                                            {
                                                if (flag2 && flag3)
                                                {
                                                    //backtrack to find a space to delimit the word
                                                    for (int k3 = k2 - 1; k3 > k; k3--)
                                                    {
                                                        if (t[k3] == ' ')
                                                        {
                                                            string word = new string(t, k3 + 1, k2 - k3 - 1);
                                                            t2.Append(word);
                                                            t2.Append(" SIMPLELINK2 ");
                                                            goto Flag2;
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                Flag2: ;


                                    t2.Append(t[k]);
                                    i = k;

                                    goto Flag1;
                                }
                                else
                                {
                                    t2.Append(t[k]);
                                }
                            }
                        }
                        else t2.Append(t[j]);
                    }
                }
                else
                {
                    t2.Append(t[i]);
                }
            Flag1: ;
            }
            text = t2.ToString();
            return text;
        }

        public static void makeBatFileForAremos()
        {
            GuiDialogMakeBatfile xx = new GuiDialogMakeBatfile(true);
            xx.ShowDialog();
            xx.Close();
        }

        [ProtoContract]
        public class ReadInfo
        {
            public static GekkoTime tStart = Globals.tNull;
            public static GekkoTime tEnd = Globals.tNull;
            public EReadInfoTypes type = EReadInfoTypes.Normal;
            public string fileName = null;
            //public bool copiedIntoBaseMessage = false;
            public int variables;
            public int startPerInFile = -12345;
            public int endPerInFile = -12345;
            public int startPerResultingBank = -12345;
            public int endPerResultingBank = -12345;
            public int createdVars;
            public int nanCounter;
            public string dbName = null; //internal name for the RAM databank (key in hashtable of databanks)
            public double time = 0d;
            public Databank databank = null;
            public bool conversionMessage = false;
            public bool abortedStar = false;
            public bool open = false;
            public bool shouldMerge = false;
            public string pcim = "";  //only used for PCIM databanks.

            // ------- from XML
            public string databankVersion = "";
            public string info1 = null;  //from XML
            public string date;  //from XML
            public string modelName;  //from XML
            public string modelInfo;  //from XML
            public string modelDate;  //from XML
            public string modelSignature;  //from XML
            public string modelHash;  //from XML
            public string modelLastSimPeriod;  //from XML
            public string modelLastSimStamp;  //from XML
            public string modelLargestLag;  //from XML
            public string modelLargestLead;  //from XML

            public void Print()
            {
                if (this.type != EReadInfoTypes.Normal) return;  //no printing of these
                Table tab = new Table();
                tab.CurRow.SetTopBorder(1, 1);
                //this strange stuff is sometimes read from PCIM databanks
                string strange = "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0";
                string info = this.info1;
                if (info == null || info == "" || info == strange) info = "[empty]";
                string date = this.date;
                if (date == null || date == "" || date == strange) date = "[empty]";
                string ext = "";
                if (Path.GetExtension(this.fileName).ToLower() == "bnk") ext = ".bnk";
                tab.CurRow.SetText(1, "DATABANK " + Path.GetFileNameWithoutExtension(this.fileName));
                //tab.CurRow.SetText(1, "DATABANK " + Path.GetFileNameWithoutExtension(this.dbName));
                tab.CurRow.SetBottomBorder(1, 1);
                tab.CurRow.Next();
                tab.CurRow.SetText(1, "Info     : " + info);
                tab.CurRow.Next();
                tab.CurRow.SetText(1, "Date     : " + date);
                tab.CurRow.Next();
                if (open)
                {
                    tab.CurRow.SetText(1, "Open     : Opened " + Path.GetFileName(this.fileName) + " as '" + this.dbName + "'");
                    tab.CurRow.Next();
                }
                tab.CurRow.SetText(1, "File     : " + this.fileName + " " + this.databankVersion);
                tab.CurRow.Next();
                tab.CurRow.SetText(1, "Period   : The file contains data from " + this.startPerInFile + "-" + this.endPerInFile);
                tab.CurRow.Next();
                //#8572309572439
                int total = Program.databanks.GetDatabank(this.dbName).storage.Count;  
                if (this.shouldMerge)
                {
                    tab.CurRow.SetText(1, "Size     : Merged " + this.variables + " variables from file into " + this.dbName + " databank (" + G.SecondsFormat(time) + ")");
                }
                else
                {
                    if (this.open) tab.CurRow.SetText(1, "Size     : Read " + this.variables + " variables from file (" + G.SecondsFormat(time) + ")");
                    else tab.CurRow.SetText(1, "Size     : Read " + this.variables + " variables from file into cleared " + this.dbName + " databank (" + G.SecondsFormat(time) + ")");
                }

                if (!this.open && this.createdVars > 0)
                {
                    tab.CurRow.Next();
                    tab.CurRow.SetText(1, "         : Created " + this.createdVars + " model variables (filled with missing values) in " + this.dbName + " databank");
                }
                if (!this.open)
                {
                    tab.CurRow.Next();
                    tab.CurRow.SetText(1, "           " + this.dbName + " databank now contains " + total + " variables (" + this.startPerResultingBank + "-" + this.endPerResultingBank + ")");
                }
                tab.CurRow.SetText(1, "Note     : Press F2 for info on databanks");

                tab.CurRow.SetBottomBorder(1, 1);
                tab.CurRow.SetLeftBorder(1);
                tab.CurRow.SetRightBorder(1);

                int widthRemember = Program.options.print_width;
                int fileWidthRemember = Program.options.print_filewidth;
                Program.options.print_width = int.MaxValue;
                Program.options.print_filewidth = int.MaxValue;
                try
                {
                    List<string> ss = tab.Print();
                    foreach (string s in ss) G.Writeln(s);

                    if (this.modelName != null)
                    {
                        StringBuilder sb = new StringBuilder();
                        sb.AppendLine("The databank contains the following information regarding its corresponding model:");
                        sb.AppendLine("Model file name: " + this.modelName);
                        sb.AppendLine("Model info: " + this.modelInfo);
                        sb.AppendLine("Model date: " + this.modelDate);
                        sb.AppendLine("Model signature: " + this.modelSignature);
                        sb.AppendLine("Model hash code: " + this.modelHash);
                        sb.AppendLine("Model last SIM period: " + this.modelLastSimPeriod);
                        sb.AppendLine("Model last SIM stamp: " + this.modelLastSimStamp);
                        sb.AppendLine("Model largest lag/lead: " + this.modelLargestLag + "/" + this.modelLargestLead);
                        LinkContainer lc = new LinkContainer(sb.ToString());
                        Globals.linkContainer.Add(lc.counter, lc);
                        G.Write("+++ NOTE: The databank contains MODEL/SIM info ("); G.WriteLink("more", "outputtab:" + lc.counter); G.Writeln(")");
                    }
                }
                finally
                {
                    //resetting, also if there is an error
                    Program.options.print_width = widthRemember;
                    Program.options.print_filewidth = fileWidthRemember;
                }

                if (this.pcim != null && this.pcim != "")
                {
                    G.Writeln("PCIM name/model when the PCIM databank was written: " + this.pcim);
                }

                if (this.nanCounter > 0)
                {
                    G.Writeln();
                    G.Writeln("+++ WARNING: Encountered " + this.nanCounter + " instances of 'NaN' in the file.");
                    G.Writeln("             These are set to missing -- proper .tsd syntax is to use '1.000000E+15'");
                    G.Writeln("             to indicate a missing value");
                    G.Writeln();
                }

                if (this.conversionMessage)
                {
                    LinkContainer lc = new LinkContainer("The databank is a ." + Globals.extensionDatabank + " file version 1.0. Newer ." + Globals.extensionDatabank + " files load around three times faster, so please consider converting the " + Globals.extensionDatabank + " file. Converting from 'oldfile." + Globals.extensionDatabank + "' to 'newfile." + Globals.extensionDatabank + "' is very simple:" + G.NL + G.NL + "  READ <" + Globals.extensionDatabank + "> oldfile;" + G.NL + "  WRITE <" + Globals.extensionDatabank + "> newfile;" + G.NL + G.NL + "There is no loss of data or data quality in this process, so the new ." + Globals.extensionDatabank + " file is a perfect substitute for the old one. The difference is that these old ." + Globals.extensionDatabank + " files are not using a binary format (as the newer ones do).");
                    Globals.linkContainer.Add(lc.counter, lc);
                    G.Write("+++ NOTE: You may convert the databank file for speedier reading (", Color.Gray); G.WriteLink("more", "outputtab:" + lc.counter); G.Writeln(")", Color.Gray);
                }

            }
        }

        public class OneList
        {
            public string indexName;
            public List<string> indexItems;
        }

        public class Item
        {
            public string variable = "";
            public List<OneList> listOfLists;
            public List<string> explanation = new List<string>();
        }

        public class CompileErrorHelper
        {
            public List<string> text = new List<string>();
            public List<int> col = new List<int>();
            public int line = -1;
            public string file = "";
        }

        public class CompiledGenrStatements
        {
            //best to keep this stuff in one place, for safety
            public Dictionary<string, int> list = new Dictionary<string, int>(StringComparer.OrdinalIgnoreCase);
            public Assembly assembly = null;
            public string inputCode = null;
            public string generatedCsCode = null;
            public int checkNumberOfLines = -12345;
        }

        public class PrintHelper
        {
            public int widthDate = 0;
            public int width1 = 0;
            public int width2 = 0;
            public int widthLabel = 0;

        }

        public class WorkerThreadHelper1
        {
            //Titles, arrows
            public string titleField = "NULL";
            public string statusField = "NULL";
            public string leftArrow = "NULL";
            public string rightArrow = "NULL";
            public string homeButton = "NULL";
        }

        public class WorkerThreadHelper2
        {
            //For printing
            public string s;
            public string linktype;
            public bool newline;
            public Color color;
            public bool link;
            public ETabs tab;
            public bool mustScrollToEnd;
            public bool mustAlsoPrintToScreen = false;
        }

        public class DecompHelper
        {
            public string variableWithLag = null;
            //public double contribution = double.NaN;
            public double x0 = double.NaN;
            public double x1 = double.NaN;  //plus epsilon
            public double z = double.NaN;
            public double y0 = double.NaN;
            public double y1 = double.NaN;  //change when x is altered from x0 to x1
            public double slope = double.NaN;
            //public double x1 = double.NaN;
            //public double d_contribution = double.NaN;
            //public double d_x0 = double.NaN;
            //public double d_x1 = double.NaN;
        }

        public class ErrorContainer
        {
            public long counter;
            public List<string> simInitEndoMissingValue = null; //a
            public List<string> simNonExistingVariable = null; //b
            public List<string> simMissingValueExoOrLaggedEndo = null;  //c
            //-----
            public List<string> simInitEndoMissingValueHelper = null; //a
            public ErrorContainer()
            {
                Globals.outputTabTextCounter += 1;
                counter = Globals.outputTabTextCounter;
            }
        }

        public class LinkContainer
        {
            public long counter;
            public string s = null;

            public LinkContainer(string si)
            {
                Globals.linkContainerCounter += 1;
                counter = Globals.linkContainerCounter;
                s = si;
            }
        }

        public class NewtonAlgorithmHelper
        {
            public GekkoTime t;
            public GekkoTime tStart;
            public GekkoTime tEnd;
        }

        public class RememberWriteStatementsHelper
        {
            public List<string> linesVariables = new List<string>();
            public List<string> linesData = new List<string>();
        }

        public class Cache
        {
            Dictionary<object, object> cache = new Dictionary<object, object>();

            /// <summary>
            /// Keeps up with the most recently read items.
            /// Items at the end of the list were read last.
            /// Items at the front of the list have been the most idle.
            /// Items at the front are removed if the cache capacity is reached.
            /// </summary>
            public List<object> priority = new List<object>();
            public Type Type { get; set; }
            public Cache(Type type)
            {
                this.Type = type;
                //TODO: register this cache with the manager
            }
            public object this[object key]
            {
                get
                {
                    lock (this)
                    {
                        if (!cache.ContainsKey(key)) return null;
                        //move the item to the end of the list
                        priority.Remove(key);
                        priority.Add(key);
                        return cache[key];
                    }
                }
                set
                {
                    lock (this)
                    {
                        if (Capacity > 0 && cache.Count == Capacity)
                        {
                            cache.Remove(priority[0]);
                            priority.RemoveAt(0);
                        }
                        cache[key] = value;
                        priority.Remove(key);
                        priority.Add(key);

                        if (priority.Count != cache.Count)
                            throw new Exception("Capacity mismatch.");
                    }
                }
            }
            public int Count { get { return cache.Count; } }
            public int Capacity { get; set; }

            public void Clear()
            {
                lock (this)
                {
                    priority.Clear();
                    cache.Clear();
                }
            }
        }
    }

    public class LocalBanks
    {
        public Databank localWork = null;
        public Databank localBase = null;
    }

    public class PrtHelperElement
    {
        //public string printCode = null;  //will be OBSOLETE
        public List<string> printCodes = new List<string>();
        public int width = -12345;
        public int dec = -12345;
        public int nwidth = -12345;
        public int ndec = -12345;
        public int pwidth = -12345;
        public int pdec = -12345;
    }

    public class PrtHelper
    {
        public string prtType = null;  //prt, mulprt, pctprt etc.
        public List<PrtHelperElement> elementOptions = null;
        public List<string> printCodes = new List<string>();
        //public string printCode = null; // m, d, p, q, etc. --> will be OBSOLETE
        public string printType = null; //PRT, SHEET, CSHEET, PLOT, etc.
        public bool rows = false;
        public int width = -12345;
        public int dec = -12345;
        public int nwidth = -12345;
        public int ndec = -12345;
        public int pwidth = -12345;
        public int pdec = -12345;
        //stuff for VPRT ------------------------
        public bool timeSpanShouldBeSetGlobally = false;
        //stuff mostly for Excel ----------------
        public string title = null;
        public string heading = null;
        public string stamp = null;
        public string fileName = null;
        public string sheet = null;
        public string cell = null;
        public string transpose = null;
        public string dates = null;
        public string labels = null;
        public string colors = null;
        public string append = null;
        public string timefilter = null;
        //general stuff -------------------------
        public bool isGmulprt = false;  //overrules a lot of the others
        public bool isVprt = false;  //overrules a lot of the others
        public bool isCalledFromGraphWindow = false;
    }

    public class PrtPplotHelper
    {
        public bool isDecomp = false;
        public bool isDecompToExcel = false;
        public bool onlyDoTimeseriesCheck = false;
        public bool isGmulprt = false;
        public bool isVprt = false;
        public bool timeSpanShouldBeSetGlobally = false;

        public string prtCsSnippet;

    }



    public class PrtOptionsHelper
    {
        public bool isLevel = false;
        public bool isLog = false;
        public bool isPch = false;
        public bool isDiff = false;
        public bool isDlog = false;
        public bool isMultiplier = false;
        public bool isBaseline = false;
        public bool printPeriod = true;
        public string title = "";
        public string heading = "";
        public bool isGmulprt = false;  //overrules a lot of the others
        public bool isVprt = false;  //overrules a lot of the others
        public bool isDp = false;  //code "dp"
        public bool isMp = false;  //code "mp"
        public bool timeSpanShouldBeSetGlobally = false;  //only used for VPRT, PRT etc. puts it inside ConvertToGekkoTiIme()
        public bool isCalledFromGraphWindow = false;
        public string pplotType = "emf";
    }

    public class IterMemory
    {
        public double[] bBefore;
        public double[] bAfter;
    }

    public class ExcelOptions
    {
        public string printOptions = null;
        public string title = null;
        public string heading = null;
        public string stamp = null;
        public string fileName = null;
        public string sheet = null;
        public string cell = null;
        public string transpose = null;
        public string dates = null;
        public string labels = null;
        public string colors = null;
        public string append = null;
        public bool isCplot = false;
        public string[,] excelRowLabels = null;
        public string[,] excelColumnLabels = null;
        public double[,] excelData = null;
    }

    public class Wildcard : Regex
    {
        /// <summary>
        /// Initializes a wildcard with the given search pattern.
        /// </summary>
        /// <param name="pattern">The wildcard pattern to match.</param>
        public Wildcard(string pattern)
            : base(WildcardToRegex(pattern))
        {
        }

        /// <summary>
        /// Initializes a wildcard with the given search pattern and options.
        /// </summary>
        /// <param name="pattern">The wildcard pattern to match.</param>
        /// <param name="options">A combination of one or more
        /// <see cref="System.Text.RegexOptions"/>.</param>
        public Wildcard(string pattern, RegexOptions options)
            : base(WildcardToRegex(pattern), options)
        {
        }

        /// <summary>
        /// Converts a wildcard to a regex.
        /// </summary>
        /// <param name="pattern">The wildcard pattern to convert.</param>
        /// <returns>A regex equivalent of the given wildcard.</returns>
        public static string WildcardToRegex(string pattern)
        {
            return "^" + Regex.Escape(pattern).
             Replace("\\*", ".*").
             Replace("\\?", ".") + "$";
        }
    }

    public class ExcelDataForCplot
    {
        public bool transpose = false;
        public double[,] data;
        public string[,] varnames;
        public string[,] dates;
        public string stamp = null;
        public string heading = null;
    }

    public enum EHasShownErrorHandling
    {
        True,
        TrueAndAlsoSkippedLines,
        False
    }

    public enum EDataFormat
    {
        None,
        Tsd,
        Tsdx,
        Gbk,
        Tsp,
        Csv,
        Prn,
        Pcim,
        Px,
        Xls,
        Xlsx,
        Gdx
    }

    public enum EOpenType
    {
        Normal,
        Edit, //OPEN<edit>, not used elsewhere
        First, //READ<first>, CLEAR<first>, etc. 
        Sec,  
        Last,
        Pos,
        Ref //READ<ref>, CLEAR<ref>, etc.
    }

    public class ReadOpenMulbkHelper: O_OLD
    {
        public GekkoTime t1 = Globals.tNull;
        public GekkoTime t2 = Globals.tNull;
        public List<List<string>> openFileNames = null;
        private string fileName = null;
        private EDataFormat type = EDataFormat.None;  //type of data(bank)
        private bool merge = false;  //merge or not.
        private string as2 = null; //for OPEN AS.
        private string orientation = null;  //rows or cols
        public EOpenType openType = EOpenType.Normal;
        public int openTypePosition = -12345;
        public bool protect = true;
        public string gdxopt = null;
        public string array = null;      

        public string FileName
        {
            get { return fileName; }
            set { FailIfImmutable(); fileName = value; }
        }

        public EDataFormat Type
        {
            get { return type; }
            set { FailIfImmutable(); type = value; }
        }

        public bool Merge
        {
            get { return merge; }
            set { FailIfImmutable(); merge = value; }
        }

        public string As
        {
            get { return as2; }
            set { FailIfImmutable(); as2 = value; }
        }

        public string Orientation
        {
            get { return orientation; }
            set { FailIfImmutable(); orientation = value; }
        }

    }

    public class O_OLD //arguments to methods
    {
        private int id = -12345;
        private bool immutable = false;

        public void SetId(Q q)  //This method should only be used in .Add() in Q class and not elsewhere!!
        {
            FailIfImmutable();  //for safety, so we are sure the .id is only set once
            this.id = q.Count();
        }

        public int GetId()
        {
            return this.id;
        }

        public bool IsReadOnly
        {
            get { return immutable; }
        }

        public virtual void MakeReadOnly()
        {
            immutable = true;
        }

        protected virtual void FailIfImmutable()
        {
            if (immutable)
            {
                G.Writeln2("*** ERROR: Internal error #46374843");
                throw new GekkoException();
            }
        }

    }

    public class Q  //essentially just a container to store method objects
    {
        private List<O_OLD> storage = new List<O_OLD>();

        public O_OLD this[int i]
        {
            get
            {
                //O o = q[117]
                return storage[i];
            }
            //set --> not allowed
        }

        public void Add(O_OLD o)
        {
            o.SetId(this); //This method should only be used in .Add() in Q class and not elsewhere!! Will set id to storage.Count (ok since item has not been added yet)
            o.MakeReadOnly();  //So the field do not get altered when the object is used later on. The object might be used many time, for instance the statement is inside a loop.
            storage.Add(o);
        }

        public int Count()
        {
            return this.storage.Count;
        }
    }

        public class P
    {
        public bool hasWrittenRunTimeErrorOnce = false;  //bit hacky
        public EHasShownErrorHandling hasShownErrorHandling = EHasShownErrorHandling.False;
        private int counter = 0;  //1 gets added soon enough
        //private Q[] stackQ = new Q[200]; //contains arguments to different methods, new object put in here every time a new .cmd file is run.
        private string[] stack = new string[200];  //2000 nested cmd files -- should be enough
        private string[] stackCommandFileText = new string[200];
        private string[] stackFileSentToAntlr = new string[200];
        public string lastFileSentToANTLR = null;
        public bool isOneLinerFromGui = false;
        public bool hasBeenCmdFile = false;
        //public bool hasBeenIsstartCmdFile = false;
        public bool hasBeenClosebanks = false;
        public bool canShowErrorDialog = true;
        public DateTime timeAtLastUserInteraction = DateTime.Now;
        public DateTime startingTime = DateTime.Now;
        public bool hasBeenCompilationError = false;
        public bool hasSeenStopCommand = false;
        private GekkoDictionary<string, int> commandFileCounter = new GekkoDictionary<string, int>(StringComparer.OrdinalIgnoreCase);
        private GekkoDictionary<string, string> commandFileCounterTainted = new GekkoDictionary<string, string>(StringComparer.OrdinalIgnoreCase);

        public string GetStack(int i)
        {
            return stack[i];
        }

        public bool IsSimple() {
            if (this.isOneLinerFromGui && this.counter <= 1)
            {
                return true;
            }
            return false;
        }

        public string GetStackCommandFileText(int i)
        {
            return stackCommandFileText[i];
        }

        public int GetDepth()
        {
            return counter;
        }

        public void SetLastFileSentToANTLR(string s)
        {
            //This method is called in translated code, for each line (that is not "simple", ie. FOR, IF etc.)
            this.stackFileSentToAntlr[counter] = s;            
        }        

        public void SetText(string s)
        {
            //This method is called in translated code, for each line (that is not "simple", ie. FOR, IF etc.)

            string file = "";
            if (counter > 0) file = this.stackFileSentToAntlr[counter - 1];  //counter will probably always be 1 or larger when this method is called
            this.stack[counter] =  file + s;
            ReportToRunStatus(false);
        }

        public void SetCommandFileText(string s)
        {
            this.stackCommandFileText[counter] = s;
        }

        public void Deeper()
        {
             this.counter++;            
        }

        public void RemoveLast()
        {
            if (counter > 0)
            {
                string temp = this.stack[counter];
                if (temp != null)
                {
                    if (this.commandFileCounter.ContainsKey(temp))
                    {
                        this.commandFileCounter[temp]++;
                    }
                    else
                    {
                        this.commandFileCounter.Add(temp, 1);
                    }

                    if (this.hasShownErrorHandling == EHasShownErrorHandling.True)
                    {
                        //Such a file will be given status "Failed" instead of "Ok".
                        //files with omitted lines will keep "Ok" status, it is up to
                        //the user to remember that he or she is skipping stuff (the number
                        //of skipped lines will be reported at the end, though).
                        //A file with syntax problems is considered unseen, until
                        //it can be parsed, compiled and run.
                        if (!this.commandFileCounterTainted.ContainsKey(temp))
                        {
                            this.commandFileCounterTainted.Add(temp, "");
                        }
                    }
                }
                this.stack[counter] = null;
                this.stackCommandFileText[counter - 1] = null;
                this.stackFileSentToAntlr[counter - 1] = null;

            }
            this.counter--;
        }

        public void ReportToRunStatus(bool enforce)  //enforce forces update, even if little time has elaspsed
        {
            if (Globals.windowRunStatus == null) return;

            DateTime d = DateTime.Now;
            if (!enforce && (d - Globals.windowRunStatusLastCall).TotalMilliseconds < 250) return;
            Globals.windowRunStatusLastCall = d;

            bool stackTab = false;
            bool runTab = false;
            if (Globals.windowRunStatusIsStackTab) stackTab = true;
            else runTab = true;
            if (enforce)
            {
                stackTab = true;
                runTab = true;
            }

            if (stackTab)
            {
                ObservableCollection<RunStatusData> items = new ObservableCollection<RunStatusData>();
                int max = this.GetDepth();
                int start = 1;
                if (this.isOneLinerFromGui) start = 2;  //do not show the 1 user input line starting it all (will be a run statement anyway, if starting a job)
                for (int i = start; i <= max; i++)  //index 0 is not used
                {
                    int lineNumber2;
                    string fileCalled;
                    List<string> commandLines2;
                    //Note: may return '[?]' as file
                    Program.GetErrorLineAndText(this, i, out lineNumber2, out fileCalled, out commandLines2);
                    string line = "?";
                    if (lineNumber2 > 0) line = lineNumber2.ToString();
                    if (lineNumber2 == 0)
                    {
                        continue;  //most of these null-nodes are filtered out, seems a few are left...
                    }
                    if (fileCalled == "[?]")
                    {
                        continue; //filtered out, seems it does not happen anymore...
                    }
                    string calling = "";
                    if (i - start > 0) calling = "...calling:";

                    string fileName = Path.GetFileName(fileCalled);
                    string fileNameAndPath = fileCalled;
                    if (i - start == 0 && fileCalled == "")
                    {
                        fileName = "[User input lines]";
                        fileNameAndPath = "[Multiple lines marked in Main window]";
                    }
                    RunStatusData data = new RunStatusData(fileName, line, fileNameAndPath, calling, null);
                    items.Add(data);
                }
                Gekko.CrossThreadStuff.StackTrace(items);
            }

            if (runTab)
            {
                List<RunStatusData> items = new List<RunStatusData>();
                //ObservableCollection<RunStatusData> items = new ObservableCollection<RunStatusData>();

                foreach (KeyValuePair<string, int> kvp in this.commandFileCounter)
                {
                    string lineText;
                    int lineNumber2;
                    Program.SplitCommandBeingExecuted(out lineText, out lineNumber2, kvp.Key);
                    if (lineText != null && lineText != "")
                    {
                        string status = "OK";
                        if (this.commandFileCounterTainted.ContainsKey(kvp.Key)) status = "Failed";
                        RunStatusData data = new RunStatusData(Path.GetFileName(lineText), kvp.Value.ToString(), lineText, null, status);
                        items.Add(data);
                    }
                }
                items.Sort();
                ObservableCollection<RunStatusData> items2 = new ObservableCollection<RunStatusData>();
                foreach (RunStatusData r in items) items2.Add(r);
                Gekko.CrossThreadStuff.RunStatus(items2);
            }
        }
    }

    class XmlColInfo
    {
        public Attrib attrib = new Attrib();
        public List<string> subcolborders = new List<string>();  //for now this is not really used, but will be later on
    }

    class Attrib
    {
        public Dictionary<string, string> data = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
        public string Get(string s)
        {
            string t = null; data.TryGetValue(s, out t);
            return t;
        }
        public bool Set(string s, string t)
        {
            if (data.ContainsKey(s)) return false;
            data[s] = t;
            return true;
        }
    }

    class XmlHelper
    {
        public StringBuilder s = new StringBuilder();
        public StringBuilder sEnd = new StringBuilder();
        public List<int> colLeftBorders = new List<int>();
        public List<int> colRightBorderPlusOne = new List<int>();
        public int totalCols = 0;
        public int totalRows = 0;
        public bool probe = true;
        public Attrib table = new Attrib();
        public List<XmlColInfo> cols = new List<XmlColInfo>();
        public Attrib rowGlobal = new Attrib();
        public List<int> colA = new List<int>();  //not sure what this is... seems not used at all: nothing is ever added to it
        public List<int> colB = new List<int>();  //not sure what this is... seems not used at all: nothing is ever added to it
        public int rowCounter = 0;
        public bool isLastRow = false;
    }

    public class Utf8Checker
    {
        public static bool Check(string fileName)
        {
            using (BufferedStream fstream = new BufferedStream(File.OpenRead(fileName)))
            {
                return IsUtf8(fstream);
            }
        }

        /// <summary>
        /// Check if stream is utf8 encoded.
        /// Notice: stream is read completely in memory!
        /// </summary>
        /// <param name="stream">Stream to read from.</param>
        /// <returns>True if the whole stream is utf8 encoded.</returns>
        public static bool IsUtf8(Stream stream)
        {
            int count = 4 * 1024;
            byte[] buffer;
            int read;
            while (true)
            {
                buffer = new byte[count];
                stream.Seek(0, SeekOrigin.Begin);
                read = stream.Read(buffer, 0, count);
                if (read < count)
                {
                    break;
                }
                buffer = null;
                count *= 2;
            }
            return IsUtf8(buffer, read);
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="buffer"></param>
        /// <param name="length"></param>
        /// <returns></returns>
        public static bool IsUtf8(byte[] buffer, int length)
        {
            int position = 0;
            int bytes = 0;
            while (position < length)
            {
                if (!IsValid(buffer, position, length, ref bytes))
                {
                    return false;
                }
                position += bytes;
            }
            return true;
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="buffer"></param>
        /// <param name="position"></param>
        /// <param name="length"></param>
        /// <param name="bytes"></param>
        /// <returns></returns>
        public static bool IsValid(byte[] buffer, int position, int length, ref int bytes)
        {
            if (length > buffer.Length)
            {
                throw new ArgumentException("Invalid length");
            }

            if (position > length - 1)
            {
                bytes = 0;
                return true;
            }

            byte ch = buffer[position];

            if (ch <= 0x7F)
            {
                bytes = 1;
                return true;
            }

            if (ch >= 0xc2 && ch <= 0xdf)
            {
                if (position >= length - 2)
                {
                    bytes = 0;
                    return false;
                }
                if (buffer[position + 1] < 0x80 || buffer[position + 1] > 0xbf)
                {
                    bytes = 0;
                    return false;
                }
                bytes = 2;
                return true;
            }

            if (ch == 0xe0)
            {
                if (position >= length - 3)
                {
                    bytes = 0;
                    return false;
                }

                if (buffer[position + 1] < 0xa0 || buffer[position + 1] > 0xbf ||
                    buffer[position + 2] < 0x80 || buffer[position + 2] > 0xbf)
                {
                    bytes = 0;
                    return false;
                }
                bytes = 3;
                return true;
            }


            if (ch >= 0xe1 && ch <= 0xef)
            {
                if (position >= length - 3)
                {
                    bytes = 0;
                    return false;
                }

                if (buffer[position + 1] < 0x80 || buffer[position + 1] > 0xbf ||
                    buffer[position + 2] < 0x80 || buffer[position + 2] > 0xbf)
                {
                    bytes = 0;
                    return false;
                }

                bytes = 3;
                return true;
            }

            if (ch == 0xf0)
            {
                if (position >= length - 4)
                {
                    bytes = 0;
                    return false;
                }

                if (buffer[position + 1] < 0x90 || buffer[position + 1] > 0xbf ||
                    buffer[position + 2] < 0x80 || buffer[position + 2] > 0xbf ||
                    buffer[position + 3] < 0x80 || buffer[position + 3] > 0xbf)
                {
                    bytes = 0;
                    return false;
                }

                bytes = 4;
                return true;
            }

            if (ch == 0xf4)
            {
                if (position >= length - 4)
                {
                    bytes = 0;
                    return false;
                }

                if (buffer[position + 1] < 0x80 || buffer[position + 1] > 0x8f ||
                    buffer[position + 2] < 0x80 || buffer[position + 2] > 0xbf ||
                    buffer[position + 3] < 0x80 || buffer[position + 3] > 0xbf)
                {
                    bytes = 0;
                    return false;
                }

                bytes = 4;
                return true;
            }

            if (ch >= 0xf1 && ch <= 0xf3)
            {
                if (position >= length - 4)
                {
                    bytes = 0;
                    return false;
                }

                if (buffer[position + 1] < 0x80 || buffer[position + 1] > 0xbf ||
                    buffer[position + 2] < 0x80 || buffer[position + 2] > 0xbf ||
                    buffer[position + 3] < 0x80 || buffer[position + 3] > 0xbf)
                {
                    bytes = 0;
                    return false;
                }

                bytes = 4;
                return true;
            }

            return false;
        }
    }


    public class CompareHelper
    {
        public CompareHelper(GekkoTime g1, GekkoTime g2)
        {
            t1 = g1;
            t2 = g2;
        }
        public GekkoTime t1;
        public GekkoTime t2;
    }

    class Person
    {
        private int id;
        private int milesTraveled;
        public int Id
        {
            get { return id; }
            set { id = value; }
        }
        public string Name { get; private set; }
        private static int InstanceCount;

        public Person() : this(0) { }

        public Person(int id) : this(id, string.Empty) { }

        public Person(int id, string name)
        {
            Id = id;
            Name = name;
            InstanceCount++;
        }

        public char this[int index]
        {
            get { return Name[index]; }
        }

        private void Walk(int miles)
        {
            milesTraveled += miles;
        }

        private static void IncreaseInstanceCount()
        {
            InstanceCount++;
        }

        private static int GetInstanceCount()
        {
            return InstanceCount;
        }

        public static void Swap(ref int i, ref int j)
        {
            int tmp = i;
            i = j;
            j = tmp;
        }
    }

    [Serializable]
    [ProtoContract]
    public class Proto
    {
        [ProtoMember(1)]
        public int xx1;
        int xx2;
        private int xx3;
        [ProtoMember(2)]
        public List<int> yy1;
        List<int> yy2;
        private List<int> yy3;
        [ProtoMember(3)]
        public List<int> zz1;
        [ProtoMember(4, AsReference = true)]
        public ProtoHelper hh1;
        [ProtoMember(5, AsReference = true)]
        public ProtoHelper hh2;
        public Proto()
        {
        }
        public Proto(string input)
        {
            G.Writeln(input);
        }
    }

    [ProtoContract]
    public class ProtoHelper
    {
        [ProtoMember(1)]
        public List<int> hh;
    }

    public class PipeFileHelper
    {
        public string pipeFileFileWithPath = "";
        public StreamWriter pipeFile = null;
        public bool pipeFileTypeIsHtml = false;
        public string htmlEndingTagsStuff = "";  //this is going to be appended to a html file when the pipe stops.
        //public bool isPiping = true;
        
        public void CloseFile()
        {
            if (pipeFileTypeIsHtml)
            {
                pipeFile.Write(htmlEndingTagsStuff);
            }
            this.pipeFile.Flush();
            this.pipeFile.Close();
            this.pipeFile.Dispose();

            //this.pipeFile.BaseStream.Flush();  --> does not work
            //this.pipeFile.BaseStream.Close();
            //this.pipeFile.BaseStream.Dispose();
        }
    }

    public class HPfilter
    {
        public double[] HPFilter(double[] data, double lambda)
        {
            {
                {
                    int N = data.Length;
                    int K;
                    double[] a = new double[N];
                    double[] b = new double[N];
                    double[] c = new double[N];

                    // Elemente der Haupt- und Nebendiagonalen

                    a[0] = 1 + lambda;
                    b[0] = -2 * lambda;
                    c[0] = lambda;
                    for (K = 1; K < N - 2; K++)
                    {
                        a[K] = 6 * lambda + 1;
                        b[K] = -4 * lambda;
                        c[K] = lambda;
                    }
                    a[1] = 5 * lambda + 1;
                    a[N - 1] = 1 + lambda;
                    a[N - 2] = 5 * lambda + 1;
                    b[0] = -2 * lambda;
                    b[N - 2] = -2 * lambda;
                    b[N - 1] = 0;
                    c[N - 2] = 0;
                    c[N - 1] = 0;

                    data = pentas(a, b, c, data, N);

                    return data;


                }
            }
        }

        static double[] pentas(double[] a, double[] b, double[] c, double[] data, int N)
        {
            /*
             *  Schneller Algorithmus zur Lösung des LGS BxX=Y
             * unter Berücksichtigung, dass B eine pentadiagonale Matrix ist
             * siehe z.B. Helmut Späth "Numerik, Eine Einführung für
             * Mathematiker und Informatiker", S. 110 ff, Braunschweig &
             * Wiesbaden, 1994
             *
            */

            int K;
            double H1 = 0;
            double H2 = 0;
            double H3 = 0;
            double H4 = 0;
            double H5 = 0;
            double HH1 = 0;
            double HH2 = 0;
            double HH3 = 0;
            double HH4 = 0;
            double HH5 = 0;
            double Z;
            double HB;
            double HC;

            // Vorwärts
            for (K = 0; K < N; K++)
            {
                Z = a[K] - H4 * H1 - HH5 * HH2;
                HB = b[K];
                HH1 = H1;
                H1 = (HB - H4 * H2) / Z;
                b[K] = H1;
                HC = c[K];
                HH2 = H2;
                H2 = HC / Z;
                c[K] = H2;
                a[K] = (data[K] - HH3 * HH5 - H3 * H4) / Z;
                HH3 = H3;
                H3 = a[K];
                H4 = HB - H5 * HH1;
                HH5 = H5;
                H5 = HC;
            }

            // Rückwärts
            H2 = 0;
            H1 = a[N - 1];
            data[N - 1] = H1;

            for (K = N - 2; K > -1; K--)
            {

                data[K] = a[K] - b[K] * H1 - c[K] * H2;
                H2 = H1;
                H1 = data[K];
            }
            return data;
        }
    }

    public enum ECellLightType
    {
        None,
        String,
        Double
    }

    public struct CellLight
    {
        public double data;
        public string text;
        public ECellLightType type;

        public CellLight(double input)
        {
            text = null;
            data = input;
            type = ECellLightType.Double;
        }

        public CellLight(string input)
        {
            text = input;
            data = double.NaN;
            type = ECellLightType.String;
        }

    }

    public class TableLight
    {
        Dictionary<long, CellLight> storage = new Dictionary<long, CellLight>();
        private int rowMax = int.MinValue;
        private int colMax = int.MinValue;
        public string prnOrientation = null;

        private long GetKey(int row, int col)
        {
            //seems we can safely assume number of rows and cols < 2.147.483.647!
            return (long)row + (long)int.MaxValue * (long)col;
        }

        public int GetRowMaxNumber()
        {
            return rowMax;
        }

        public int GetColMaxNumber()
        {
            return colMax;
        }

        public void Add(int row, int col, CellLight value)
        {
            if (row > rowMax) rowMax = row;
            if (col > colMax) colMax = col;
            long key = GetKey(row, col);
            storage.Add(key, value);
        }

        public CellLight Get(int row, int col)
        {
            long key = GetKey(row, col);
            CellLight cell = new CellLight(); storage.TryGetValue(key, out cell);
            //if it does not exist, the cell will have .type = None.
            return cell;
        }

        public bool ContainsKey(int row, int col)
        {
            long key = GetKey(row, col);
            return storage.ContainsKey(key);
        }

        public TableLight Transpose()
        {
            TableLight ttable = new TableLight();
            foreach (KeyValuePair<long, CellLight> kvp in this.storage)
            {
                int row = (int)(kvp.Key % int.MaxValue);
                int col = (int)(kvp.Key / int.MaxValue);
                ttable.Add(col, row, kvp.Value);
            }
            return ttable;
        }
    }

    public class ModelCommentsHelper
    {
        public string infoText = null;
        public string dateText = null;
        public ESignatureStatus signatureStatus;
        public string signatureFoundInFileHeader = null;
        public int infoCounter = 0;
        public int dateCounter = 0;
        public int signatureCounter = 0;
        public string modelHashTrue = null;
        public string varlist;
    }

    public class RunStatusData : INotifyPropertyChanged, IComparable<RunStatusData>
    {
        private string name;
        private string value;
        private string fullName;
        private string calling;
        private string status;
        public event PropertyChangedEventHandler PropertyChanged;

        //public int Compare(RunStatusData x, RunStatusData y)
        //{
        //    return string.Compare(x.Name, y.Name);
        //}

        public int CompareTo(RunStatusData other)
        {
            return string.Compare(this.Name, other.Name);
        }

        public string Name
        {
            get { return this.name; }
            set
            {
                this.name = value;
                OnPropertyChanged("Name");
            }
        }
        public string Value
        {
            get { return this.value; }
            set
            {
                this.value = value;
                OnPropertyChanged("Value");
            }
        }
        public string FullName
        {
            get { return this.fullName; }
            set
            {
                this.fullName = value;
                OnPropertyChanged("FullName");
            }
        }
        public string Calling
        {
            get { return this.calling; }
            set
            {
                this.calling = value;
                OnPropertyChanged("Calling");
            }
        }
        public string Status
        {
            get { return this.status; }
            set
            {
                this.status = value;
                OnPropertyChanged("Status");
            }
        }

        public RunStatusData(string s1, string s2, string s3, string s4, string s5)
        {
            this.Name = s1;
            this.Value = s2;
            this.FullName = s3;
            this.Calling = s4;
            this.Status = s5;
        }

        // Create the OnPropertyChanged method to raise the event
        protected void OnPropertyChanged(string name)
        {
            PropertyChangedEventHandler handler = PropertyChanged;
            if (handler != null)
            {
                handler(this, new PropertyChangedEventArgs(name));
            }
        }
    }

    public class SimOptions
    {
        public string method = "";
        public bool isEigen = false;
        public bool isFix = false;
        public YesNoNull isStatic = YesNoNull.Null;
    }

    public class GekkoDictionary<TKey, TValue> : Dictionary<TKey, TValue>
    {
        public GekkoDictionary()
            : base()
        {
            if (typeof(TKey) == typeof(string))
            {
                //string keys should be called with ignorecase
                G.Writeln2("*** ERROR: Technical error 437834873");
                throw new GekkoException();
            }
        }
        //public GekkoDictionary(int capacity) : base(capacity) { }  //not used
        public GekkoDictionary(IEqualityComparer<TKey> comparer)
            : base(comparer)
        {
            if (typeof(TKey) == typeof(string))
            {
                if (comparer != StringComparer.OrdinalIgnoreCase)
                {
                    //string keys should be called with ignorecase
                    G.Writeln2("*** ERROR: Technical error 437834874");
                    throw new GekkoException();
                }
            }
        }

        //Would be nice to be able override the indexer, but this does not seem possible...
        //Anyway, nice to have a special wrapper for Dictionaries
    }

    public enum EExtrackBankAndRest
    {
        OnlyStrings,
        OnlyStringNoFirstName,
        GetDatabank,
        GetDatabankAndTimeSeries
    }

    public class ExtractBankAndRestHelper
    {
        //public bool simpleNameWithoutAtOrBank = false;
        public string bank;
        public string name;
        public Databank databank;
        public TimeSeries ts;
        public bool hasColon = false;
    }
}
