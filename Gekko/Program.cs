/*
    Gekko Timeseries Software (www.t-t.dk/gekko)..
    Copyright (C) 2021, Thomas Thomsen, T-T Analyse.

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program (see the file COPYING in the root folder).
    Else, see <http://www.gnu.org/licenses/>.
*/

using System.Text.RegularExpressions;
using System;
using System.Drawing;
using System.Windows.Forms;
using System.IO;
using System.Text;
using System.Collections.Generic;
using System.Collections;
using System.Globalization;
using System.Windows.Forms;
using System.Threading;
using MathNet.Numerics.LinearAlgebra.Sparse.Linear;
using MathNet.Numerics.LinearAlgebra.Sparse;
using MathNet.Numerics.LinearAlgebra.Sparse.Tests;
using System.Diagnostics;
using System.ComponentModel;
using System.Drawing;
using System.Data;
using Microsoft.CSharp;
using System.CodeDom;
using System.CodeDom.Compiler;
using System.Runtime.Serialization;
using System.Reflection;
using System.Xml;
using System.Xml.Serialization;
using Office = Microsoft.Office.Core;
using Excel = Microsoft.Office.Interop.Excel;
using System.Runtime.InteropServices;
using System.Security.Permissions;
using Microsoft.Win32;
using System.Security.Cryptography;
using System.Reflection.Emit;
using System.Runtime.Serialization.Formatters.Binary;
using ProtoBuf;
using ProtoBuf.Meta;
using System.Diagnostics;
using System.Collections.ObjectModel;
using System.Linq;
using OfficeOpenXml;
using System.Data;
using System.IO.Compression;

namespace Gekko
{
    
    public enum EEquationType
    {
        D,
        G,
        K,
        I,
        S,
        RevertedT,  //table variables that are run after simulation (same as RevertedY, but not technical and shown in doc systems)        
        RevertedY,  //technical, typically manual reverted J-factors               
        RevertedP,  //these equations are ignored -- only for use in PREDICT
        RevertedAutoGenerated
    }

    public enum EArrowType
    {
        Ver1_0,
        Ver1_0__with_time_int_and_underscore_name
    }

    public enum EAppend
    {
        Yes,
        No,
        Ifexist
    }

    public enum EVariablesForWrite
    {
        Normal,  //series
        OneNonSeries
    }

    public enum EPrtPlotSheet
    {
        Unknown,
        PrintMixedAQMPretty,
        PrintMixedMDPretty,
        PrintNonmixedUgly,  //also for sheet
        Plot
    }

    public enum EDecompBanks
    {
        Work,
        Ref,
        Both
    }

    public enum assignmantTypeLhs
    {
        Inactive,
        Active,
        Series,
        Nonseries
    }

    public enum EGekkoArg
    {
        Normal,
        Special
    }

    public enum EGekkoActionTypes
    {
        Unknown,
        Ols
    }

    public class ExcelDnaData
    {
        public object[,] cells = null; //when transferring from Gekko databank to current sheet
        public TableLight tableLight = null; //when transferring from current sheet to Gekko databank
    }

    public class WalkTokensHelper
    {
        public string t = "t";
        public string tBase = "tBase";
        public bool checkIfVariableIsASet = false;
        public bool replaceSuitableIntInLastPositionWithFixedYear = false;
        public GekkoDictionary<string, List<int>> lagsLeads = new GekkoDictionary<string, List<int>>(StringComparer.OrdinalIgnoreCase);
    }

    public class GekkoAction
    {
        public Action action = null;
        public EGekkoActionTypes type = EGekkoActionTypes.Unknown;
        public string name = null;  //for instance the OLS name given, so that for type == ols, we can expire links with a certain name. If name = null, the link will always expire.
        public GekkoAction(EGekkoActionTypes type, string name, Action action)
        {
            this.type = type;  //can be .Unknown
            this.name = name;  //can be null
            this.action = action;
        }
    }

    public class LinkAction
    {
        public int start = -12345;
        public int end = -12345;
        public string chop1 = null;
        public string chop2 = null;
        public string chop3 = null;
        public string[] ss2 = null;
    }

    public class PlotTable
    {
        public List<List<double>> dates = null;
        public List<List<double>> values = null;
    }

    public class OLSRekurInfo
    {
        public string type = null;  // 'r' (right), 'l' (left), 'e' (elevator)
        public bool chow = true;
        public bool grahphs = true;
        public int df_min = 1;  //can be larger
    }

    public class OLSRekurDatas
    {
        public List<OLSRekurData> datas = new List<OLSRekurData>();
        public OLSRekurData data = null;

        public OLSRekurDatas(int m, int n)
        {
            for (int i = 0; i < m; i++)
            {
                this.datas.Add(new OLSRekurData(n));
            }

            this.data = new OLSRekurData(n);
        }        
    }

    public class OLSRekurData
    {
        public double[] coeff = null;
        public double[] coeff_low = null;
        public double[] coeff_high = null;
        public OLSRekurData(int n)
        {
            this.coeff = new double[n];
            this.coeff_low = new double[n];
            this.coeff_high = new double[n];
        }
    }

    public class OLSResults
    {
        public double[] beta, ypredict, residual, coeff, se, t;
        public double rss, resMean, lhsMean, ssTot, dw, rmse, see, r2, r2cor;
        public double[,] usedCovar, usedCorr;
    }

    public class CellOffset
    {
        public string cell = null;
        public string datecell = null;
        public string namecell = null;
    }

    public class CGSolverOutput
    {
        public int iterations = -12345;
        public double f = double.NaN;
        public double[] x = null;
        public int evals = 0;
    }

    public class CGSolverInput
    {
        public double deltaGradient = 1e-8;
        public double deltaGolden = 1e-8;
        public double krit = Program.options.solve_newton_conv_abs* Program.options.solve_newton_conv_abs;  //0.0001^2 <=> no residual can be > 0.0001, for in that case RSS would be > krit = 0.0001^2
        public bool limitBeta = false;  //does not have any effect on the unit tests (until now)
        public int restartInterval = -12345; //if -12345 --> will use n, setting to 1 --> basic steepest gradient, setting to n is normal conjugate gradient
        // -------------
        public int evals = 0;  //!!!!!!! do not change
    }    

    public class GekkoArg
    {
        public Func<GekkoSmpl, IVariable> f1 = null;
        public Func<GekkoSmpl, IVariable> f2 = null;
        public EGekkoArg type = EGekkoArg.Normal;  //Special: inside <...>        

        public GekkoArg(Func<GekkoSmpl, IVariable> f1, Func<GekkoSmpl, IVariable> f2)
        {
            this.f1 = f1; //original, for instance f('y')
            this.f2 = f2; //alternative code, used for name type, for instance f(y), where y is treated like 'y'
            this.type = EGekkoArg.Normal;
        }
        public GekkoArg(Func<GekkoSmpl, IVariable> f1, Func<GekkoSmpl, IVariable> f2, EGekkoArg type)
        {
            this.f1 = f1; //original, for instance f('y')
            this.f2 = f2; //alternative code, used for name type, for instance f(y), where y is treated like 'y'
            this.type = type;
        }
    }

    public class GekkoTimes
    {
        public GekkoTime t1;
        public GekkoTime t2;
    }

    public class SamHelper
    {
        public Series series1;
        public Series series2;
    }

    public class DecompHelper3
    {
        public Series[] vars = new Series[1];
    }

    public class DecompDict
    {
        public GekkoDictionary<string, Series> storage = new GekkoDictionary<string, Series>(StringComparer.OrdinalIgnoreCase);
        public Series this[string s]
        {
            get
            {                
                Series ts = null; storage.TryGetValue(s, out ts);
                if (ts == null)
                {
                    //string s2 = G.Chop_AddFreq(s, "");
                    ts = new Series(Program.options.freq, G.Chop_AddFreq("decomptemp", G.GetFreq(Program.options.freq)));
                    storage.Add(s, ts);
                }
                return ts;
            }
        }

        public bool Remove(string s)
        {
            return storage.Remove(s);
        }

        public bool ContainsKey(string s)
        {
            return storage.ContainsKey(s);
        }

        public DecompDict DeepClone()
        {
            DecompDict dd = new DecompDict();
            foreach (KeyValuePair<string, Series> kvp in this.storage)
            {
                dd.storage.Add(kvp.Key, kvp.Value.DeepClone(null) as Series);
            }
            return dd;
        }
    }

    public class MyCustomAttribute : Attribute
    {
        public string Lag { get; set; }
    }

    public class GekkoSmplSimple
    {
        //public bool allObservations = false;
        public GekkoTime t1 = GekkoTime.tNull;
        public GekkoTime t2 = GekkoTime.tNull;
        public GekkoSmplSimple(GekkoTime t1, GekkoTime t2)
        {
            this.t1 = t1;
            this.t2 = t2;
        }        
    }

    public class GekkoSmpl2
    {
        public GekkoTime t0 = GekkoTime.tNull;
        public GekkoTime t3 = GekkoTime.tNull;
    }

    public class GekkoSmpl
    {
        public GekkoTime t0 = GekkoTime.tNull;  //start of the period for which the expressions are calculated (<= t1)
        public GekkoTime t1 = GekkoTime.tNull;  //start of real sample, should normally not be lagged (then sumt() etc. will be wrong)
        public GekkoTime t2 = GekkoTime.tNull;  //end of real sample, should normally not be leaded (then sumt() etc. will be wrong)
        public GekkoTime t3 = GekkoTime.tNull;  //end of the period for which the expressions are calculated (>= t2) 
        public GekkoError gekkoError = null; //only set to something, if the sample .t0 to .t3 is too tight       
        //public int gekkoErrorI = 0;
        public int bankNumber = 0;  //0 is inactive, 1 is Ref databank, will only apply to series (vars without sigils)
        public GekkoSmplCommand command = GekkoSmplCommand.Unknown;
        //public List<O.LabelHelperIVariable> labelHelper = new List<O.LabelHelperIVariable>(); //not created all the time, so ok
        //public List<List<O.LabelHelperIVariable>> labelHelper2 = new List<List<O.LabelHelperIVariable>>(); //not created all the time, so ok
        public List<O.RecordedPieces> labelRecordedPieces = new List<O.RecordedPieces>();
        public P p;
        public assignmantTypeLhs lhsAssignmentType = assignmantTypeLhs.Inactive;

        public GekkoSmpl()
        {

        }

        public GekkoSmpl(GekkoTime t1, GekkoTime t2)
        {
            //FIXME
            //FIXME
            //FIXME
            //FIXME
            //FIXME
            this.t0 = t1;
            this.t1 = t1;
            this.t2 = t2;
            this.t3 = t2;
        }

        public bool HasError()
        {
            return this.gekkoError != null;
        }

        public GekkoTimeIterator Iterate03()
        {
            return new GekkoTimeIterator(this.t0, this.t3);
        }

        public GekkoTimeIterator Iterate12()
        {
            return new GekkoTimeIterator(this.t1, this.t2);
        }

        public GekkoTimeIterator Iterate12(EFreq convertToThisFreq)
        {
            return new GekkoTimeIterator(convertToThisFreq, this.t1, this.t2);
        }

        public static GekkoSmpl Global()
        {
            GekkoSmpl smpl = new GekkoSmpl(Globals.globalPeriodStart, Globals.globalPeriodEnd);
            return smpl;
        }

        public int Observations03()
        {
            return GekkoTime.Observations(this.t0, this.t3);
        }

        public int Observations12()
        {
            return GekkoTime.Observations(this.t1, this.t2);
        }

    }

    public class GekkoList<T>
    {
        private List<T> container = new List<T>();

        public static GekkoList<T> Construct()
        {
            return new GekkoList<T>();
        }
        public GekkoList()
        {
            //default constructor
        }

        public GekkoList(T s)
        {
            this.container.Add(s);
        }

        public GekkoList(GekkoList<T> x)
        {
            this.container.AddRange(x.container);
        }

        public GekkoList(List<T>x)
        {
            this.container.AddRange(x);
        }
                
        public GekkoList<T> AddRange(GekkoList<T> x)
        {
            this.container.AddRange(x.container);
            return this;
        }

        public GekkoList<T> AddRange(List<T> x)
        {
            this.container.AddRange(x);
            return this;
        }

        public GekkoList<T> Add(T x)
        {
            this.container.Add(x);
            return this;
        }
    }

    public class DateTimeHelper
    {
        public DateTime dt;
        public string s;
        public long size;
    }
    
    public class BankNameVersion
    {
        public string bank = null;
        public string name = null;
        public string freq = null;
    }

    public class WorkBookHelper
    {
        public static void WorkBookSetData_1(string stamp, ExcelWorksheet ws, int rowcounter, int colcounter)
        {
            //See #087923584975: Strange null setting, but otherwise formulas are kept, including na() values
            ws.Cells[rowcounter, colcounter].Formula = null;
            ws.Cells[rowcounter, colcounter].Value = stamp;
        }

        public static void WorkBookSetData_2(string heading, ExcelWorksheet ws, int rowcounter, int colcounter)
        {
            //See #087923584975: Strange null setting, but otherwise formulas are kept, including na() values
            ws.Cells[rowcounter, colcounter].Formula = null;
            ws.Cells[rowcounter, colcounter].Value = heading;
        }

        //This is the data matrix
        public static void WorkBookSetData_3(ExcelWorksheet ws, double[,] data, int d1, int d2)
        {
            //See #087923584975: Strange null setting, but otherwise formulas are kept, including na() values
            ws.Cells[d1, d2, d1 + data.GetLength(0) - 1, d2 + data.GetLength(1) - 1].Formula = null;
            ws.Cells[d1, d2, d1 + data.GetLength(0) - 1, d2 + data.GetLength(1) - 1].LoadFromArrays(Program.ToJaggedArray(data));
        }

        public static void WorkBookSetData_4(ExcelWorksheet ws, int i, int j, DateTime dt, string f)
        {
            //See #087923584975: Strange null setting, but otherwise formulas are kept, including na() values
            ws.Cells[i, j].Formula = null;
            ws.SetValue(i, j, dt);
            ws.Cells[i, j].Style.Numberformat.Format = f;
        }

        public static void WorkBookSetData_5(ExcelWorksheet ws, int i, int j, DateTime dt, string f)
        {
            //See #087923584975: Strange null setting, but otherwise formulas are kept, including na() values
            ws.Cells[i, j].Formula = null;
            ws.SetValue(i, j, dt);
            ws.Cells[i, j].Style.Numberformat.Format = f;
        }

        public static void WorkBookSetData_6(ExcelWorksheet ws, int d1, int d2, object[][] datesData)
        {
            //See #087923584975: Strange null setting, but otherwise formulas are kept, including na() values
            ws.Cells[d1, d2 - 1, d1 + datesData.Length - 1, d2 - 1 + datesData[0].Length - 1].Formula = null;
            ws.Cells[d1, d2 - 1, d1 + datesData.Length - 1, d2 - 1 + datesData[0].Length - 1].LoadFromArrays(datesData);
        }

        public static void WorkBookSetData_7(ExcelWorksheet ws, int d1, int d2, object[][] datesData)
        {
            //See #087923584975: Strange null setting, but otherwise formulas are kept, including na() values
            ws.Cells[d1 - 1, d2, d1 - 1 + datesData.Length - 1, d2 + datesData[0].Length - 1].Formula = null;
            ws.Cells[d1 - 1, d2, d1 - 1 + datesData.Length - 1, d2 + datesData[0].Length - 1].LoadFromArrays(datesData);
        }

        public static void WorkBookSetData_8(ExcelWorksheet ws, int d1, int d2, string[,] labels)
        {
            //See #087923584975: Strange null setting, but otherwise formulas are kept, including na() values
            ws.Cells[d1 - 1, d2, d1 - 1 + labels.GetLength(0) - 1, d2 + labels.GetLength(1) - 1].Formula = null;
            ws.Cells[d1 - 1, d2, d1 - 1 + labels.GetLength(0) - 1, d2 + labels.GetLength(1) - 1].LoadFromArrays(Program.ToJaggedArray(labels));
        }

        public static void WorkBookSetData_9(ExcelWorksheet ws, int d1, int d2, string[,] labels)
        {
            //See #087923584975: Strange null setting, but otherwise formulas are kept, including na() values
            ws.Cells[d1, d2 - 1, d1 + labels.GetLength(0) - 1, d2 - 1 + labels.GetLength(1) - 1].Formula = null;
            ws.Cells[d1, d2 - 1, d1 + labels.GetLength(0) - 1, d2 - 1 + labels.GetLength(1) - 1].LoadFromArrays(Program.ToJaggedArray(labels));
        }
    }

    public class Zipper
    {
        //this zipper should make sure temp folder always gets deleted, also in case of exceptions etc.
        //alternatively: have Gekko delete all gekkotempfilesxxxxx at program start.

        public string tempFolder = null;
        public string zipFileAndFolder = null;  //may omit path, then it will land in working folder

        public Zipper(string zipFileName)
        {
            this.tempFolder = Globals.localTempFilesLocation + "\\" + "gekkotempfiles_" + Program.RandomInt(11111111, 99999999);
            if (Directory.Exists(this.tempFolder))
            {
                Program.DeleteFolder(this.tempFolder);
            }
            Directory.CreateDirectory(this.tempFolder);
            this.zipFileAndFolder = Program.CreateFullPathAndFileName(zipFileName);
        }

        public void ZipAndCleanup()
        {
            Program.WaitForZipWrite(this.tempFolder, this.zipFileAndFolder);
            Program.DeleteFolder(this.tempFolder);
        }
    }

    public enum ECollapseMethod
    {
        Total,
        Avg,
        First,
        Last,
        Count
    }

    public enum EPrintTypes
    {
        Print,
        Plot,
        Sheet,
        Clip
    }

    public enum EWildcardSearchType
    {
        Copy,
        Delete,
        Rename,
        Write,
        Search
    }

    public enum GekkoSmplCommand
    {
        Unfold,
        Sum,      
        Unknown
    }

    public enum EWriteType
    {
        Tsdx,
        Flat,
        Gbk,
        Gdx,
        Gnuplot,
        Tsd,
        Prn,
        Xlsx,
        Xls,
        Csv,
        R,
        Gcm,
        Tsp,
        Python,
        Arrow
    }

    public enum EPrtCollapseTypes
    {
        Avg,
        Total,
        None
    }

    public enum EReadInfoTypes
    {
        Normal,
        NonExistingGbkFileOpened,
        //OpenedFirstOrRefAlreadyOpenBank
    }

    public enum EdataFormat
    {
        Csv,
        Prn
        //Gnuplot
    }

    public enum ESeriesUpdTypes
    {
        none,        
        d,
        p,
        m,
        q,
        mp,
        dl,  //dlog()
        l,   //log()
        n
    }

    //See #98745239543
    public enum YesNoNull
    {
        Yes,
        No,
        Null
    }

    public enum ESmoothTypes
    {
        Spline,
        Linear,
        Geometric,
        Repeat,
        Overlay
    }

    public enum EOperatorTypes
    {
        ShortVersion,
        LongVersionHasYes,
        LongVersionHasAppend,
        LongVersionOnlyNo,
        Verbose,
        None,
        Null
    }

    public enum ESignatureStatus
    {
        Ok,
        SignatureNotFoundInModelFile,
        SignaturesDoNotMatch
    }

    public enum ETerminalCondition
    {
        Exogenous,
        ConstantLevel,
        ConstantGrowthRate
    }

    public enum EMissingType
    {
        Ok,
        //HasMissingData,  //NaN, M in tables
        HasMissingVariables  //MV in tables
    }

    public enum StampTypes
    {
        Normal,
        Base,
        Multiplier
    }

    public enum EEndoOrExo
    {
        Endo,
        Exo,
        Unknown
    }

    public enum ETabs
    {
        Main,
        Output,
        Help,
        Menu
    }

    public enum ECompiledModelType  //corresponds to Model.cs --> public Type assemblyGauss etc.
    {
        Gauss,
        GaussFailSafe,
        Res,  //single equation forecast
        Newton,
        After,
        //Eigen,  //for eigenvalue analysis
        Unknown
    }

    public class UndoSim
    {
        public long id = 0L;
        public double[,] a = null;
        public GekkoTime tStart0;
        public GekkoTime tStart;
        public GekkoTime tEnd;
        public int obsWithLags;
        public int obsSimPeriod;
    }

    public class PackSim
    {
        public long id = 0L;
        public double[,] a = null;
        public GekkoTime tStart0;
        public GekkoTime tStart;
        public GekkoTime tEnd;
        public int obsWithLags;
        public int obsSimPeriod;
    }

    public class DatabankTimeseriesNotFoundException : Exception
    {
        //only used for 1 thing
        public DatabankTimeseriesNotFoundException()
        {
        }
    }

    public class GekkoException : System.Exception
    {
        public GekkoException() { }
        public GekkoException(string s) : base(s) { }
    }


    /// <summary>
    /// A storage implementation where the key "example7" and the key "ExAmpLe7" are treated as equal.
    /// Used to contain variables in a model. Such variable names are not case-sensitive.
    /// </summary>
    ///
    [Serializable]
    public class CaseInsensitiveHashtable : Hashtable
    {

        public CaseInsensitiveHashtable(SerializationInfo info, StreamingContext context)
            : base(info, context)
        {
        }

        /// <summary>
        /// Constructor
        /// </summary>
        public CaseInsensitiveHashtable()
            : base()
        {
            this.hcp = new CaseInsensitiveHashCodeProvider();
            this.comparer = new CaseInsensitiveComparer();
        }
        /// <summary>
        /// Constructor
        /// </summary>
        /// <param name="capacity"></param>
        public CaseInsensitiveHashtable(int capacity)
            : base(capacity)
        {
            this.hcp = new CaseInsensitiveHashCodeProvider();
            this.comparer = new CaseInsensitiveComparer();
        }
    }

    public class OptString
    {
        public string s1;
        public string s2;
        public OptString(string s1, string s2)
        {
            this.s1 = s1;
            this.s2 = s2;
        }
    }

    public class OptVal
    {
        public string s;
        public double val;
        public OptVal(string s, double val)
        {
            this.s = s;
            this.val = val;
        }
    }

    public class OptDate
    {
        public string s;
        public GekkoTime date;
        public OptDate(string s, GekkoTime date)
        {
            this.s = s;
            this.date = date;
        }
    }

    public class SearchOptions
    {
        public bool ignoreErrors = false;
    }

    public class ToFrom
    {
        public string s1 = null;
        public string s2 = null;
        public bool b1Explicit = false;
        public ToFrom(string s1, string s2, bool b1Explicit)
        {
            this.s1 = s1;
            this.s2 = s2;
            this.b1Explicit = b1Explicit;
        }
    }

        /// <summary>
        /// Simple helper class, obsolete??
        /// </summary>
        public class TwoStrings
    {
        public string s1 = null;
        public string s2 = null;
        public string s2Type = null;
        public TwoStrings(string s1, string s2)
        {
            this.s1 = s1;
            this.s2 = s2;
        }
        public TwoStrings(string s1, string s2, bool noblanks)
        {
            if (noblanks)
            {
                this.s1 = s1.Replace(" ", "");
                this.s2 = s2.Replace(" ", "");
            }
            else
            {
                this.s1 = s1;
                this.s2 = s2;
            }
        }
    }

    public class StackHelper
    {
        public string line;  //has a lot of text added
        public string file;
        public int line2;  //as a simple int
    }

        

    /// <summary>
    /// Simple helper class
    /// </summary>
    public class CompilerOptions
    {
        public bool gauss;
        public bool jacobi;
        public bool newtonNonFeedBack;
        public bool newton;
        public bool gaussFailSafe;
        public long compilerOptionsHash;
    }

    /// <summary>
    /// Helper class
    /// </summary>
    ///
    [Serializable]
    [ProtoContract]
    public class EquationHelper
    {
        [ProtoMember(1)]
        public string lhsWithLagIndicator;  //left hand side with lag indicator (e.g. "fy¤-1").
        [ProtoMember(2)]
        public string lhs;
        [ProtoMember(3)]
        public GekkoDictionary<string, string> precedentsWithLagIndicator = new GekkoDictionary<string, string>(StringComparer.OrdinalIgnoreCase);
        [ProtoMember(5)]
        public int equationNumber = -12345;
        [ProtoMember(6)]
        public string equationText = "";
        [ProtoMember(7)]
        public double typicalVariance = double.NaN;
        [ProtoMember(8)]
        public string equationCode = "";
        [ProtoMember(9)]
        public string csCodeRhs = "";
        [ProtoMember(10)]
        public string csCodeRhsLongVersion = "";
        [ProtoMember(11)]
        public string csCodeRhsHumanVersion = "";
        [ProtoMember(12)]
        public string csCodeLhsGauss = "";
        [ProtoMember(13)]
        public string csCodeLhsJacobi = "";
        [ProtoMember(14)]
        public string csCodeLhsHuman = "";
        [ProtoMember(15)]
        public int bNumberLhs = -12345;
        [ProtoMember(16)]
        public string equationCodeJ = "";
        [ProtoMember(17)]
        public string equationCodeD = "";
        [ProtoMember(18)]
        public string equationCodeZ = "";
        [ProtoMember(19)]
        public bool equationCodeJadditive = false;
        [ProtoMember(20)]
        public bool equationCodeJmultiplicative = false;
        [ProtoMember(21)]
        public EEquationType equationType;
        [ProtoMember(22)]
        public string Jname = "";
        [ProtoMember(23)]
        public string Dname = "";
        [ProtoMember(24)]
        public string Zname = "";
        //[ProtoMember()] !!!!!!!! ignore this!
        public Gekko.Parser.ASTNodeSimple equationsNodeRoot = null;
        [ProtoMember(25)]
        public bool isAfterModel = false;  //if equation is after 
        [ProtoMember(26)]
        public bool isAfter2Model = false; //if equation is after AFTER2$ Here, both isAfterModel and isAfter2Model are true at same time
        [ProtoMember(27)]
        public string modelBlock = "";                
        [ProtoMember(28)]
        public int largestLag = 0; //always 0 or positive        
        [ProtoMember(29)]
        public int largestLead = 0; //always 0 or positive         

        public List<Func<GekkoSmpl, IVariable>> expressions = null; //do not protobuf this
        public Action<string, GekkoTime> predictAction = null; //do not protobuf this

    }

    /// <summary>
    /// Helper class
    /// </summary>
    public class UserFunctionsHelper
    {
        public ArrayList arguments;
        public List<string> rhs;
        public List<string> rhsType;
    }

    /// <summary>
    /// Helper class
    /// </summary>
    public class UserFunctionsHelper1
    {
        public List<string> al;
        public List<string> alType;
    }


    /// <summary>
    /// Helper class
    /// </summary>
    public class ReadFrmHelper
    {
        public bool fatalErrorRegardingModelFrmls = false;
    }

    /// <summary>
    /// Simple helper class
    /// </summary>
    public class BnkReader
    {
        public int lastRecordRead;
        public String varName;
        public int startPeriod;
        public int endPeriod;
    }

    /// <summary>
    /// Simple helper class
    /// </summary>
    public class ThreeStrings
    {
        public String s1;
        public String s2;
        public String s3;
    }

    /// <summary>
    /// Simple helper class
    /// </summary>
    ///
    [Serializable]
    [ProtoContract]
    public class BTypeData
    {
        [ProtoMember(1)]
        public string variable;
        [ProtoMember(2)]
        public int bNumber;
        [ProtoMember(3)]
        public int aNumber;
        [ProtoMember(4)]
        public int lag;
        //public ArrayList equations;
        [ProtoMember(5)]
        public int leftHandSideEquation;
    }

    /// <summary>
    /// Simple helper class
    /// </summary>
    ///
    [Serializable]
    [ProtoContract]
    public class ATypeData
    {
        [ProtoMember(1)]
        public string varName;
        [ProtoMember(2)]
        public int aNumber;
    }


    /// <summary>
    /// Simple helper class
    /// </summary>
    public class FourInts
    {
        public int start1;
        public int end1;
        public int start2;
        public int end2;

    }

    /// <summary>
    /// Simple helper class
    /// </summary>
    public class TwoInts
    {
        public int int1;
        public int int2;
        
    }

    public class NewtonFairTaylorHelper
    {
        public List<NewtonFairTaylorHelper1> shocks = null;
        public double[,] jacobi = null;
    }

    public class NewtonFairTaylorHelper1
    {
        public bool isFirstBaseline = false;
        public GekkoTime gt;
        public int varNumber;
        public int varCounter;
    }

    /// <summary>
    /// Simple helper class
    /// </summary>
    public class TranslateVarData
    {
        public int w;
        public int s;
        public int sForA;

    }


    /// <summary>
    /// Simple helper class
    /// </summary>
    public class MacroHelper
    {
        public string s;
    }

    public interface DB
    {

    }
    
    
    public static class Program
    {
        /// <summary>
        /// Container for all user options
        /// </summary>
        public static Options options = new Options();

        public static GekkoDictionary<string, string> alias = null;

        /// <summary>
        /// Container for all the stuff related to the current model
        /// </summary>
        public static Model model = new Gekko.Model();
        
        //these should be cleared with closeall
        /// <summary>
        /// Contains names of the open databanks. Not case-sensitive. The name of any bank points to a
        /// storage with variable names. Which again points to a double[] array with data for each period.
        /// </summary>
        public static Databanks databanks = new Databanks();        
        public static Dictionary<string, Table> tables = new Dictionary<string, Table>(StringComparer.OrdinalIgnoreCase);
        public static CompiledGenrStatements compiledGenrStatements = new CompiledGenrStatements();

        //varlist stuff
        public static List<Item> unfoldedVariableList = null;  //the unfolded variable list
        public static int guiBrowseNumber = 0;
        public static List<string> guiBrowseHistory = new List<string>();

        public static int guiBrowseHelpNumber = 0;
        public static List<string> guiBrowseHelpHistory = new List<string>();

        public static int RandomInt(int min, int max)
        {
            lock (Globals.randomSyncLock)
            {
                return Globals.random777.Next(min, max);
            }
        }

        public static int RandomInt()
        {
            lock (Globals.randomSyncLock)
            {
                return Globals.random777.Next();
            }
        }

        public static double RandomDouble()
        {
            lock (Globals.randomSyncLock)
            {
                return Globals.random777.NextDouble();
            }
        }

        public static void PrintExceptionAndFinishThread(Exception e2, P p)
        {
            if (!Globals.threadIsInProcessOfAborting && !(p.hasSeenStopCommand > 0))  //STOP should not show errors
            {

                string eType = e2.GetType().Name;

                if (FindException(e2, "lexer error"))
                {
                    Parser.ParseHelper ph = new Parser.ParseHelper();
                    string s2 = p.GetStackCommandFileText(p.GetDepth());
                    string s3 = "";
                    if (s2 != null) s3 = s2;
                    Gekko.Parser.Frm.ParserFrmCreateAST.PrintModelParserErrors(Program.CreateListOfStringsFromString(e2.Message), Program.CreateListOfStringsFromString(s3), ph);
                }
                if (FindException(e2, "***") || FindException(e2, "+++"))
                {
                    //for instance "*** ERROR: blablabla" or "+++ NOTE: blablabla"
                    //if *** we know that it is a Gekko-generated error text
                    G.Writeln("    " + e2.Message);
                }
                string ramProblem = "";
                if (FindException(e2, "System.OutOfMemoryException"))
                {
                    G.Writeln2("*** ERROR: Out of memory (RAM). Please close some unnessecary programs if possible.");
                    Process[] processlist = Process.GetProcesses();
                    int counter = 0;
                    foreach (Process theprocess in processlist)
                    {
                        counter++;
                        ramProblem += "#" + counter;
                        try
                        {
                            ramProblem += " name:" + theprocess.ProcessName;
                        }
                        catch { };
                        try
                        {
                            ramProblem += " id:" + theprocess.Id;
                        }
                        catch { };
                        try
                        {
                            ramProblem += " ram:" + theprocess.WorkingSet64 / 1024;
                        }
                        catch { };
                        try
                        {
                            ramProblem += " maxram:" + theprocess.PeakWorkingSet64 / 1024;
                        }
                        catch { };
                        try
                        {
                            ramProblem += " created:" + theprocess.StartTime.ToString().Replace(" ", "_");
                        }
                        catch { };
                        ramProblem += G.NL;
                    }
                }

                if (FindException(e2, "GekkoException"))
                {
                    G.Write("*** ERROR: The command failed");
                }
                else
                {
                    G.Write("*** ERROR: The command failed due to internal Gekko error");
                }
                string s = "";

                if (ramProblem != "")
                {
                    s += "NOTE: Since this is a RAM problem, the error report contains information on the active processes";
                    s += "running on the computer. If you do not wish this information to be contained in the error report,";
                    s += "please delete the section below 'The following is a list of active processes' before sending";
                    s += "the report to the Gekko editor (active processes are usually not sensitive information, and";
                    s += "no content of these processes is used (only their RAM usage etc.)" + G.NL + G.NL;
                    s += e2.ToString() + G.NL;
                    s += G.NL + "The following is a list of active processes:" + G.NL + ramProblem;
                }
                else
                {
                    s += G.NL + e2.ToString();
                }

                if (Globals.errorMemory != null)
                {
                    s += G.NL + G.NL + "---------------------------------------------------------------------" + G.NL;
                    List<string> xx = G.ExtractLinesFromText(Globals.errorMemory.ToString());
                    for (int i = 0; i < xx.Count; i++)
                    {
                        if (i > 30) continue;  //so that we don't accidentally get 100's of lines from user output pasted in. The intention is to only get a copy of messages since last error message.
                        s += xx[i] + G.NL;
                    }
                }

                if (Globals.lastDynamicCsCode != null)
                {
                    //this is nice to have to trace the error if this sort of problem appears!
                    s += G.NL + G.NL + "----------------------------- Non-compiling cs code: ----------------------------------" + G.NL;
                    s += Globals.lastDynamicCsCode;
                    s += G.NL;
                }

                LinkContainer lc = new LinkContainer(s);
                Globals.linkContainer.Add(lc.counter, lc);
                G.Write(" ("); G.WriteLink("more", "stacktrace:" + lc.counter); G.Write(")"); G.Writeln();

                
            }
            Gui.gui.ThreadFinished();  //removes the job from the stack of jobs, otherwise we will wait for this halted job forever. Could use thread stop instead??
        }

        public static void ProtectError(string s)
        {
            G.Writeln2("*** ERROR: " + s);
            throw new GekkoException();
        }

        public static void GekkoExceptionCleanup(P p)
        {
            //This method is also called when exceptions arise in unit testing (FAIL() method)
            StopPipeAndMute(1);
            Program.options.series_dyn = null;  //this is because if there is a runtime error inside af BLOCK series dyn = ... ; ... ; END; it is best to have dyn switched off afterwards. If the program has a RESET/RESTART, this does not matter, but if not, setting = null guards agains <dyn> surprises after the runtime error. This option is special in that it can only be set in a BLOCK, not in an OPTION.

            if (Globals.threadIsInProcessOfAborting)
            {
                G.Writeln();
                G.Writeln("-------------------------------------------------------------", Color.Red);
                G.Writeln("------------ The job was stopped by the user ----------------", Color.Red);                
                G.Writeln("---------------- (Red stop button) --------------------------", Color.Red);                
                G.Writeln("-------------------------------------------------------------", Color.Red);
                G.Writeln();                
            }
            if (Globals.applicationIsInProcessOfAborting)
            {
                Application.Exit();  //will go to #3452345523 after
            }
        }                

        public static void StopPipeAndMute(int i)
        {
            if (i == 1)
            {
                Program.ReleasePipe();
                Program.ReleasePipe2();
                              
            }
            else if (i == 2)
            {
                if (Globals.pipe == true) Program.Pipe("con", null);             
            }

            //in both cases:
            if (G.Equal(Program.options.interface_mute, "yes"))
            {
                Program.options.interface_mute = "no";
                G.Writeln2("+++ NOTE: Because of errors, OPTION interface mute = 'no'");
            }
        }

        public static bool FindException(Exception ex, string s)
        {
            if (ex == null) return false;
            if (ex.Message != null && ex.Message.Contains(s)) return true;
            Exception temp = ex;
            for (int i = 0; i < 1000; i++)  //1000 nested levels should be enough...
            {
                temp = temp.InnerException;
                if (temp == null) return false;
                if (temp.Message != null && temp.Message.Contains(s)) return true;
            }
            return false;
        }


        public static string GetStackTraceWithOffset(Exception e2)
        {
            StackTrace st = new System.Diagnostics.StackTrace(e2);
            string stackTrace = "";
            foreach (StackFrame frame in st.GetFrames())
            {
                stackTrace = "           " + "at " + frame.GetMethod().Module.Name + "." +
                    frame.GetMethod().ReflectedType.Name + "."
                    + frame.GetMethod().Name
                    + "  (IL offset: 0x" + frame.GetILOffset().ToString("x") + ")\n" + stackTrace;
            }
            return stackTrace;
        }

        public static void SetGlobalTimePeriodAbstract(bool direct, GekkoTime t1, GekkoTime t2)
        {
            if (direct)
            {
                Globals.globalPeriodStart = t1;
                Globals.globalPeriodEnd = t2;                
            }
        }

        public static void SetGlobalTimePeriodAbstractNew(bool direct, GekkoTime t1, GekkoTime t2)
        {
            if (direct)
            {
                Globals.globalPeriodStart = t1;
                Globals.globalPeriodEnd = t2;
            }
        }

        //ok that it is not referenced to, is used in Gekcel
        public static void PrepareExcelDna(string s)
        {
            Globals.excelDna = true;
            Globals.excelDna2 = false;
            Globals.excelDnaPath = s;
        }        
        
        static int skipSpaces(string c, int ii)
        {
            int i;
            //skip spaces (tab is included counted)
            for (i = ii; i < c.Length; i++)
            {
                if (c[i] == ' ' || c[i] == '\t')     //'\t' is tab
                {
                    //do nothing
                }
                else return i;
            }
            return -12345;
        }

        /// <summary>
        /// Returns pos after next new line code ('\r\n'). Returns -12345 if not found.
        /// </summary>
        /// <param name="c">Array of characters</param>
        /// <param name="ii">Start position to search from</param>
        /// <returns>Found position.</returns>
        static int skipPastNewLine(char[] c, int ii)
        {  //
            int i;
            for (i = ii; i < c.Length; i++)
            {
                if (!(c[i] == '\r' && c[i + 1] == '\n'))
                {
                    //do nothing
                }
                else return i + 2;
            }
            return -12345;
        }

        
        

        public static String RemoveTrailingD(String lag)
        {
            String lag1 = "";
            //problem is: all lags look like this: fy(-2d)
            //the d is added to indicate double precision
            if (lag.EndsWith("d"))
            {
                //remove last "d"
                lag1 = lag.Substring(0, lag.Length - 1);
            }
            else
            {
                lag1 = lag;
            }
            return lag1;
        }

        
        /// <summary>
        /// s must be of form "var¤-1", multiple Globals.lagIndicator not allowed.
        /// if "var¤-1¤-1", .s1 is ok but .s2 not.
        /// if no Globals.lagIndicator the raw input is returned.
        /// </summary>
        /// <param name="s"></param>
        /// <returns></returns>
        static TwoStrings getVariableAndLag(String s)
        {
            String var = "";
            String lag = "";
            int find = s.IndexOf(Globals.lagIndicator, 0);
            if (find != -1)
            {
                var = s.Substring(0, find);
                lag = s.Substring(find + 1);
            }
            else
            {
                var = s;
                lag = "0";
            }
            TwoStrings ts = new TwoStrings(var, lag);
            return ts;
        }


        public static TableLight ReadCsvPrn(EDataFormat type, string file)
        {
            //everything is stored as strings, no parsing into values... (probably because it is not that simple, comma vs. dot, NaN, etc.)
            //will remove quotes on cells
            //does not handle ';' inside a quoted string

            char delimiter = ';';
            if (G.Equal(Program.options.interface_csv_delimiter , "comma")) delimiter = ',';
                        
            string freqHere = G.GetFreq(Program.options.freq);

            string fullFileNameAndPath = CreateFullPathAndFileName(file);

            if (!File.Exists(fullFileNameAndPath))
            {
                if (type == EDataFormat.Csv) G.Writeln2("*** ERROR: csv file does not exist");
                else if (type == EDataFormat.Prn) G.Writeln2("*** ERROR: prn file does not exist");
                throw new GekkoException();
            }

            string input = GetTextFromFileWithWait(fullFileNameAndPath);
            List<string> lines = G.ExtractLinesFromText(input);

            //#98045298375
            TableLight matrix = new TableLight();  //1-based coords. Could perhaps design a more lightweight version of cells for this if memory or speed becomes an issue. Perhaps with basic cell stuff, and then a field pointing to object with alignment etc. Or use inheritance.

            if (type == EDataFormat.Prn)
            {
                string orientation = null;
                List<string> lines2 = new List<string>();
                bool first = true;
                foreach (string s in lines)
                {
                    if (s.Trim() == "") continue;  //ignore empty lines
                    if (s.StartsWith("//")) continue;  //ignore //
                    string[] split = s.Split(new char[] { ' ' }, StringSplitOptions.RemoveEmptyEntries);  //could be variable name with blank such as "ab cd" or something to trim like " abcd", but that is strange/wrong anyway!
                    string line2 = null;
                    foreach (string ss in split)
                    {
                        string ss2 = ss.Trim();  //probably superfluous
                        if (ss2.StartsWith("\""))
                        {
                            if (!ss2.EndsWith("\""))
                            {
                                G.Writeln2("*** ERROR: item '" + ss2 + "' seems malformed");
                                throw new GekkoException();
                            }
                            ss2 = ss2.Substring(1, ss2.Length - 2);
                            if (ss2.Contains("\""))
                            {
                                G.Writeln2("*** ERROR: item '\"" + ss2 + "\"' seems malformed");
                                throw new GekkoException();
                            }
                        }
                        string s3 = ss2;
                        first = false;
                        line2 += s3 + ";";
                    }
                    lines2.Add(line2);
                }
                lines = lines2;
            }

            int row = 0;
            foreach (string line in lines)
            {
                if (line.Trim() == "") continue;  //ignore blank line
                if (line.StartsWith("//")) continue;  //ignore //
                row++;
                string[] chunks = line.Split(delimiter);
                int col = 0;
                foreach (string s2 in chunks)
                {
                    bool hasQuotes = false;
                    string s = s2.Trim();
                    if (s.StartsWith("'") && s.EndsWith("'"))
                    {
                        s = s.Substring(1, s.Length - 2);
                        hasQuotes = true;
                    }
                    if (s.StartsWith("\"") && s.EndsWith("\""))
                    {
                        s = s.Substring(1, s.Length - 2);
                        hasQuotes = true;
                    }
                    col++;
                    CellLight cell = new CellLight(s, hasQuotes);
                    if (s != "") matrix.Add(row, col, cell);  //no need to keep empty cells in matrix (there can be many such)
                }
            }

            return matrix;
        }

        public static void GetTimeseriesFromWorkbookMatrix(CellOffset offset, ReadOpenMulbkHelper oRead, Databank databank, TableLight matrix2, ReadInfo readInfo, string dateformat, string datetype)
        {

            //We could 'taste' the file, but how to distinguish A and U for instance?
            //Perhaps augment READ/IMPORT with freq indication for such files?
            EFreq freqHere = Program.options.freq;

            int rowOffset = 0;  //tested, not implemented in ANTLR yet.
            int colOffset = 0;
            string sheetName = null; //not implemented yet: takes first sheet it finds.

            bool transpose = ShouldTranspose(oRead, matrix2, rowOffset, colOffset);
            TableLight matrix = matrix2;
            if (transpose)
            {
                matrix = matrix2.Transpose();
            }

            bool isFirst = false;
            string format = SplitDateFormatInTwo(dateformat, ref isFirst);

            GekkoTime per1 = GekkoTime.tNull;
            GekkoTime per2 = GekkoTime.tNull;

            int variableCounter = 0;
            string annualIndicator1 = "Y";
            string annualIndicator2 = "A1";

            string[] start = new string[2];
            string[] end = new string[2];

            int i_data, j_data, i_names, j_names, i_dates, j_dates;
            HandleRectangularFileFormatCellOffset(offset, transpose, out i_data, out j_data, out i_names, out j_names, out i_dates, out j_dates);

            int matrixMaxRow = matrix.GetRowMaxNumber();
            int matrixMaxCol = matrix.GetColMaxNumber();

            //Series are running in rows per default, else data is transposed
            //There may be gaps, like this:
            // ..   ..  ..   2001   2002   2003
            // ..   ..  ..    ..     ..     ..
            // ..   x1  ..   100     200    161
            // ..   x2  ..   200     100    132

            // Here, datecell=d1, namecell=b3, cell=d3

            List<GekkoTime> datesInMatrix = new List<GekkoTime>();

            for (int col = j_dates; col <= matrixMaxCol; col++)
            {
                int row = i_dates;

                CellLight cell = matrix.Get(row, col);

                //---------------------
                //DATES ROW
                //---------------------

                //========================================================================================================
                //                          FREQUENCY LOCATION, indicates where to implement more frequencies
                //========================================================================================================
                // There is a lot of date stuff below

                string cellText = null;
                
                if (cell.type == ECellLightType.String) cellText = cell.text;
                else if (cell.type == ECellLightType.Double) cellText = cell.data.ToString();
                else if (cell.type == ECellLightType.DateTime) cellText = cell.dateTime.ToString();                

                if (cellText == null)
                {
                    G.Writeln2("*** ERROR in cell " + GetExcelCell(row, col, transpose) + ".");
                    G.Writeln2("    This cell should contain a date and not be empty.", Color.Red);
                    throw new GekkoException();
                }

                //The below is only for error messages
                if (col == j_dates)
                {
                    start[0] = cellText;
                    start[1] = GetExcelCell(row, col, transpose);
                }
                if (true)  //made for each date
                {
                    end[0] = cellText;
                    end[1] = GetExcelCell(row, col, transpose);
                }

                string date = cellText;
                date = date.Trim();  //removes blanks at start and end
                date = date.ToLower();  //if q or m (or y)

                GekkoTime gt = new GekkoTime(0, 0, 0); //will not activate .IsNull() == true

                if (G.Equal(datetype, "excel"))
                {
                    if (oRead.Type == EDataFormat.Csv || oRead.Type == EDataFormat.Prn)
                    {
                        //Excel-dates are converted to yyyy-mm-dd when a xlsx is exported to csv.
                        //So this restriction seems sensibl.
                        G.Writeln2("*** ERROR: You cannot use <datetype='excel'> for .csv or .prn file types");
                        throw new GekkoException();
                    }

                    //this is quite easy, since there is no formatting to worry about.
                    //any dateformat is just ignored, is not relevant since the internal number is exact

                    //must indicate frequency below, since DateTime has no frequency (is a point).
                    if (cell.type == ECellLightType.Double)
                    {
                        gt = GekkoTime.FromDateTimeToGekkoTime(freqHere, GekkoTime.FromExcelDateToDateTime(cell.data));
                    }
                    else if (cell.type == ECellLightType.DateTime)
                    {
                        gt = GekkoTime.FromDateTimeToGekkoTime(freqHere, cell.dateTime);
                    }
                    else
                    {
                        G.Writeln2("*** ERROR: Cell " + GetExcelCell(row, col, transpose) + ". Could not interpret this date: '" + cell.text + "'");
                        G.Writeln("           It is supposed to be an Excel date, counting days since January 1, 1900. But Gekko cannot", Color.Red);
                        G.Writeln("           convert it to a value.", Color.Red);
                        throw new GekkoException();
                    }
                }
                else
                {
                    //datetype = text

                    if (IsGekkoDateFormat(format))
                    {
                        //no format given, Gekko date format expected

                        //if freq=a and 2001y, this is treated as integer 2001
                        //if freq=a and 98, this is treated as 1998 (logic of GekkoTime.FromStringToGekkoTime()).
                        //if freq=q and 200102, this is treated as 2001q2
                        //if freq=m and 200102, this is treated as 2001m2
                        //if 20010230, this is always treated as 2001m2d30 (we do not expect undated freq with 8 digits)
                        //data with freq U MUST have "option freq u" set.

                        bool error = false;
                        bool done = false;

                        if ((freqHere == EFreq.A))
                        {
                            if (date.Length == 5 && date.EndsWith(annualIndicator1, true, null))
                            {
                                //remove 'Y' if it is there
                                date = date.Remove(date.Length - 1);
                            }
                        }

                        if (G.IsInteger(date))
                        {
                            // 200102 --> q or m (if Q or M is set)
                            // 20010230 --> daily (always)
                            // undated must have freq U
                            //

                            if (freqHere == EFreq.U)
                            {
                                gt = new GekkoTime(freqHere, int.Parse(date), 1);
                                done = true;
                            }
                            else if (date.Length == 6 && (freqHere == EFreq.Q || freqHere == EFreq.M))
                            {
                                //It might be a date like 199503, that is, 1995q3 or 1995m3
                                //We have to use the global freq here, how else to know the freq??
                                //Only with freq Q or M
                                gt = new GekkoTime(freqHere, int.Parse(date.Substring(0, 4)), int.Parse(date.Substring(4, 2)), 1);
                                done = true;
                            }
                            else if (date.Length == 8)
                            {
                                //It might be a date like 19950302, that is, 1995m3d2
                                //Always, regardless of global freq, we do not expect U freq data this large
                                gt = new GekkoTime(EFreq.D, int.Parse(date.Substring(0, 4)), int.Parse(date.Substring(4, 2)), int.Parse(date.Substring(6, 2)));
                                done = true;
                            }
                        }

                        if (done)
                        {
                            error = false;
                        }
                        else
                        {
                            gt = GekkoTime.FromStringToGekkoTime(date, true, false);
                            if (gt.IsNull()) error = true;
                        }

                        if (error)
                        {
                            G.Writeln2("*** ERROR: Cell " + GetExcelCell(row, col, transpose) + ". Could not interpret this date: '" + date + "'");
                            G.Writeln("           You may want to change the frequency: OPTION freq = ...", Color.Red);
                            throw new GekkoException();
                        }
                    }
                    else
                    {
                        //non-Gekko date format
                        //we have a yyyy-mm-dd-like format that we need to look into
                        DateTime dt = GekkoTime.FromYYYYMMDDToDateTime(format, date);
                        gt = GekkoTime.FromDateTimeToGekkoTime(freqHere, dt);
                    }
                }

                if (readInfo.startPerInFile == -12345) readInfo.startPerInFile = gt.super;
                if (readInfo.endPerInFile == -12345) readInfo.endPerInFile = gt.super;
                else
                {
                    if (gt.super > readInfo.endPerInFile) readInfo.endPerInFile = gt.super;
                }

                if (col == j_dates)
                {
                    per1 = gt;
                }

                if (gt.freq == EFreq.D)  //just test succession
                {
                    if (col > j_dates)
                    {
                        if (!gt.StrictlyLargerThan(per2))
                        {
                            G.Writeln2("*** ERROR: The date " + gt.ToString() + " is not larger than the previous: " + per2.ToString());
                            throw new GekkoException();
                        }                        
                    }
                    per2 = gt;
                }
                else //tested for each observation, except for daily obs
                {
                    per2 = gt;
                    int expectedPeriods = GekkoTime.Observations(per1, gt);
                    if (expectedPeriods != (col - j_dates + 1))
                    {
                        G.Writeln2("*** ERROR: Expected to find " + expectedPeriods + " observations between the periods");
                        G.Writeln("           '" + start[0] + "' (cell " + start[1] + ")" + " and '" + end[0] + "' (cell " + end[1] + ").", Color.Red);
                        throw new GekkoException();
                    }
                }
                datesInMatrix.Add(gt);
            }

            for (int row = i_data; row <= matrixMaxRow; row++)
            //for (int row = 1 + rowOffset; row <= matrixMaxRow; row++)
            {

                Series ts = null;

                for (int col = j_data; col <= matrixMaxCol; col++)
                //for (int col = 1 + colOffset; col <= matrixMaxCol; col++)
                {
                    //if (row - rowOffset == 1 && col - colOffset == 1)

                    

                    CellLight cell = matrix.Get(row, col);


                    if (true)  //data row
                    {
                        //---------------------
                        //DATA ROW
                        //---------------------
                        //`do this only for first data column

                        
                        if (col == j_data)
                        {
                            //-----------------------
                            //VARIABLE NAME
                            //-----------------------

                            ts = GetTimeseriesFromWorkbookMatrixHelper(databank, freqHere, transpose, ref variableCounter, row, col, matrix, j_names);
                        }

                        if (true)
                        {
                            //-----------------------
                            //NUMERIC DATA (rest of row)
                            //-----------------------
                            //Second column and on (data)
                            double d = double.NaN;
                            bool shouldSkip = false;

                            if (cell.type != ECellLightType.None)
                            {
                                if (cell.type == ECellLightType.Double) d = cell.data;
                                else if (cell.type == ECellLightType.String)
                                {
                                    if (IsNonAvailableText(cell.text))
                                    {
                                        d = double.NaN;
                                    }
                                    else if (oRead.Type == EDataFormat.Csv || oRead.Type == EDataFormat.Prn)
                                    {
                                        string s3 = cell.text;
                                        if (G.Equal(Program.options.interface_csv_decimalseparator, "comma"))
                                        {
                                            s3 = s3.Replace(",", ".");  //bit of a hack, will not handle 1.500,75   (--> 1500.75)
                                        }
                                        try
                                        {
                                            d = G.ParseIntoDouble(s3);
                                        }
                                        catch
                                        {
                                            G.Writeln2("*** ERROR: Cell " + GetExcelCell(row, col, transpose) + ". Could not parse '" + s3 + "' as a number");
                                            G.Writeln("+++ NOTE:  You may change separator: OPTION interface csv decimalseparator");
                                            if (s3.Trim() == ".")
                                            {
                                                G.Writeln("+++ NOTE:  You cannot use dot ('.') to indicate missing value, use M or NA instead");
                                            }
                                            throw new GekkoException();
                                        }
                                    }
                                    else
                                    {
                                        //must be xls or xlsx, and not #n/a or the like
                                        G.Writeln2("*** ERROR in spreadsheet cell " + GetExcelCell(row, col, transpose) + ".");
                                        G.Writeln("    This cell is text: expected numeric value.", Color.Red);
                                        throw new GekkoException();
                                    }
                                }
                            }
                            else
                            {
                                shouldSkip = true;  //empty cell
                            }

                            if (!shouldSkip)
                            {
                                if (d == 1e+15d)  //we use this as code for missing, as in AREMOS.
                                {
                                    d = double.NaN;
                                }                                     
                                ts.SetData(datesInMatrix[col - j_data], d);                         
                            }
                        }
                        if (ts != null) ts.Trim(); //to save ram
                    }
                    
                }                
            }
            //See almost identical code in readTsd and readPcim and readTsp...
            readInfo.variables = variableCounter;
            if (oRead.Merge)
            {
                readInfo.startPerResultingBank = G.GekkoMin(readInfo.startPerInFile, databank.yearStart);
                readInfo.endPerResultingBank = G.GekkoMax(readInfo.endPerInFile, databank.yearEnd);
            }
            else
            {
                readInfo.startPerResultingBank = readInfo.startPerInFile;
                readInfo.endPerResultingBank = readInfo.endPerInFile;
            }
            //Databank currentBank = Program.databanks.GetDatabank(databank.name);
            //currentBank.yearStart = readInfo.startPerResultingBank;
            //currentBank.yearEnd = readInfo.endPerResultingBank;
        }

        private static Series GetTimeseriesFromWorkbookMatrixHelper(Databank databank, EFreq freqHere, bool transpose, ref int variableCounter, int row, int col, TableLight matrix, int j_cellnames)
        {
            Series ts;

            CellLight cell = matrix.Get(row, j_cellnames);

            string cellText = null;

            if (cell.type != ECellLightType.None)
            {
                if (cell.type == ECellLightType.String) cellText = cell.text;
                else if (cell.type == ECellLightType.Double)
                {
                    G.Writeln2("*** ERROR in spreadsheet cell " + GetExcelCell(row, col, transpose) + ".");
                    G.Writeln("    This cell is a value: expected a variable name.", Color.Red);
                    throw new GekkoException();
                }
            }

            if (cellText == null)
            {
                G.Writeln2("*** ERROR in spreadsheet cell " + GetExcelCell(row, col, transpose) + ".");
                G.Writeln("    This cell should contain a variable name and not be empty.", Color.Red);
                throw new GekkoException();
            }

            string varName = cellText.Trim();  //the name may contain blanks like 'elveff '
            varName = G.Chop_FreqAdd(varName, Program.options.freq);
            variableCounter++;
            if (!databank.ContainsIVariable(varName))
            {
                Series data2 = new Series(freqHere, varName);
                databank.AddIVariable(varName, data2);
                ts = data2;
            }
            else
            {
                ts = databank.GetIVariable(varName) as Series;
            }

            return ts;
        }

        private static bool IsGekkoDateFormat(string format)
        {
            return format == null || G.Equal(format, "gekko");
        }

        

        private static bool IsNonAvailableText(string text)
        {
            return IsNonAvailableText(text, true);
        }

        private static bool IsNonAvailableText(string text, bool alsoMAndNa)
        {
            //the last ones are the Danish codes
            //the M is Gekko standard for missing value, NA is also allowed, both also with "".
            bool isNonAvailableText = false;
            if(alsoMAndNa)
            {
                if (G.Equal(text, "M") || G.Equal(text, "\"M\"") || G.Equal(text, "NA") || G.Equal(text, "\"NA\"")) isNonAvailableText = true;
            }
            if (G.Equal(text, "#N/A") || G.Equal(text, "#NAME?") || G.Equal(text, "#I/T") || G.Equal(text, "#NAVN?")) isNonAvailableText = true;
            return isNonAvailableText;
        }

        private static bool ShouldTranspose(ReadOpenMulbkHelper oRead, TableLight matrix2, int rowOffset, int colOffset)
        {
            bool transpose = false;
            if (G.Equal(oRead.Orientation, "cols")) transpose = true;  //we assume ROWS is default (logical for databanks with more series than observations)
            if (oRead.Type == EDataFormat.Prn)
            {
                CellLight cellA1 = matrix2.Get(1 + rowOffset, 1 + colOffset);
                if (cellA1.type == ECellLightType.None)
                {
                    G.Writeln2("*** ERROR: No data in position A1");
                    throw new GekkoException();
                }
                transpose = HandlePrnFirstElement(cellA1, rowOffset, colOffset, matrix2);
            }
            return transpose;
        }

        private static bool HandlePrnFirstElement(CellLight cell, int rowOffset, int colOffset, TableLight matrix)
        {
            bool transpose = false;
            if (cell.type != ECellLightType.String)
            {
                G.Writeln2("*** ERROR: Expected 'date' or 'name' as first element in prn file");
                throw new GekkoException();
            }
            if (G.Equal(cell.text.Trim(), "date")) transpose = true; //corresponds to READ<csv cols>, timeseries are in columns.
            else if (G.Equal(cell.text.Trim(), "name")) transpose = false; //corresponds to READ<csv>, timeseries are in rows.
            else
            {
                G.Writeln2("*** ERROR: Expected 'date' or 'name' as first element in prn file");
                throw new GekkoException();
            }

            return transpose;
        }

        private static string GetExcelCell(int row, int col, bool transpose)
        {
            string coord = null;
            if (!transpose)
            {
                coord = GetExcelColumnName(col) + row.ToString();
            }
            else
            {
                coord = GetExcelColumnName(row) + col.ToString();
            }
            return coord;
        }

        private static List<string> GetListFromWildcards(string w, Databank databank)
        {
            Wildcard wildcard = new Wildcard(w, RegexOptions.IgnoreCase);
            List<string> found = new List<string>();
            string end = Globals.freqIndicator.ToString() + Program.options.freq;  //.freq is always lower key
            foreach (string s in databank.storage.Keys)
            {
                if (s.StartsWith("_tmptmp")) continue;  //Hack: these are deleted after each command, but in for instance PRT command a _tmptmp var is created just before
                //Annoying slower code because the use of freqIndicator is not stringent.
                //Should be fixed so that annual is always %a.
                string s2 = s;
                if (!s.Contains(Globals.freqIndicator)) s2 = s2 + Globals.freqIndicator + "a";
                if (!s2.EndsWith(end)) continue;  //filter out variables with different frequency
                string s3 = s2.Replace(end, "");
                if (wildcard.IsMatch(s3))
                {
                    found.Add(s3);
                }
            }
            found.Sort(StringComparer.InvariantCulture);  //what about a and A?
            return found;
        }

        public static void OpenOrRead(CellOffset offset, bool wipeDatabankBeforeInsertingData, ReadOpenMulbkHelper oRead, bool open, List<ReadInfo> readInfos, bool create)
        {
            //open = true if called with OPEN command                      

            int n = 1;
            List<int> list = new List<int>();
            if (open)
            {
                CheckOpenSyntax(oRead);  //checks for * etc.
                n = oRead.openFileNames.Count;
                if (n > 1)
                {
                    if (oRead.openType == EOpenType.Edit)
                    {
                        G.Writeln2("*** ERROR: OPEN<edit> must be used with 1 databank");
                        throw new GekkoException();
                    }
                    else if (oRead.openType == EOpenType.Ref)
                    {
                        G.Writeln2("*** ERROR: OPEN<ref> must be used with 1 databank");
                        throw new GekkoException();
                    }
                }
                if (Program.databanks.ShouldPutBankLast(oRead.openType, oRead.openTypePosition))
                {
                    for (int i = 0; i < n; i++)
                    {
                        list.Add(i);
                    }
                }
                else
                {
                    for (int i = n - 1; i >= 0; i--)
                    {
                        list.Add(i);
                    }
                }
            }
            else
            {
                //READ or IMPORT has only 1 bank
                list.Add(1);
            }

            foreach (int i in list)
            {
                ReadInfo readInfo = new ReadInfo();

                string localFileThatShouldBeDeletedPathAndFilename = null;

                string file = null;
                string as2 = null;
                if (open)
                {
                    file = G.StripQuotes(oRead.openFileNames[i][0]);
                    as2 = oRead.openFileNames[i][1];
                    if (as2 == "") as2 = null;
                }
                else
                {
                    file = G.StripQuotes(oRead.FileName);
                    as2 = oRead.As;
                }

                string originalFileName = file;

                bool isGbk = true;
                //bool isProtobuf = false;
                string extension = "" + Globals.extensionDatabank + "";

                if (oRead.Type == EDataFormat.Tsd)  //overrules any global settings
                {
                    isGbk = false;
                    extension = "tsd";
                }
                if (oRead.Type == EDataFormat.Gbk)  //overrules any global settings
                {
                    isGbk = true;
                    extension = "" + Globals.extensionDatabank + "";
                }
                if (oRead.Type == EDataFormat.Tsdx)  //overrules any global settings
                {
                    isGbk = true;
                    extension = "tsdx";
                }
                if (oRead.Type == EDataFormat.Tsp)  //overrules any global settings
                {
                    isGbk = false;
                    extension = "tsp";
                }
                if (oRead.Type == EDataFormat.Csv)
                {
                    extension = "csv";
                    isGbk = false;
                }
                if (oRead.Type == EDataFormat.Prn)
                {
                    extension = "prn";
                    isGbk = false;
                }
                if (oRead.Type == EDataFormat.Flat)
                {
                    extension = "flat";
                    isGbk = false;
                }
                if (oRead.Type == EDataFormat.Aremos)
                {
                    extension = "aremos";
                    isGbk = false;
                }
                if (oRead.Type == EDataFormat.Xls)
                {
                    extension = "xls";
                    isGbk = false;
                }
                if (oRead.Type == EDataFormat.Xlsx)
                {
                    extension = "xlsx";
                    isGbk = false;
                }
                if (oRead.Type == EDataFormat.Pcim)
                {
                    extension = "bnk";
                    isGbk = false;
                }
                if (oRead.Type == EDataFormat.Gdx)
                {
                    extension = "gdx";
                    isGbk = false;
                }
                if (oRead.Type == EDataFormat.Px)
                {
                    extension = "px";
                    isGbk = false;
                }

                string originalFileNameWithExtension =  AddExtension(originalFileName, "." + extension);  //just for error messages


                // ---------------------------------------------------------------------------------
                //                  Start of categories
                // ---------------------------------------------------------------------------------

                //                   +---------------------------+---------------------------------+                
                //                   |       fileExists          |         file does not exist     |
                // ------------------+---------------------------+---------------------------------+
                //                   |                                                             |
                //  alreadyOpen      |              move existing bank around                      |
                //                   |                                                             |
                // ----------------------------------------------+---------------------------------+
                //                   |                           |                                 |
                //  not already open |  read into position       |  fail unless OPEN<edit/create>  |
                //                   |   maybe editable          |      createBrandNew             |
                // ------------------+---------------------------+---------------------------------+
                //
                // Note: regarding databank name there is the complication that this may given as '*'
                //       and also that ... AS ... may be used. In general, the resulting 'real' databank
                //       name (not file name) as shown in the F2 window is readInfo.dbName

                bool cancel = false;                
                file = ReadHelper(file, ref cancel, extension);
                if (cancel)
                {
                    readInfo.abortedStar = true;
                    return;  //from READ * cancelling
                }
                bool category2_fileExists = false;
                if (file == null)
                {
                    readInfo.dbName = Path.GetFileNameWithoutExtension(originalFileName);
                }
                else
                {
                    readInfo.dbName = Path.GetFileNameWithoutExtension(file);                    
                    category2_fileExists = true;
                }
                if (as2 != null && as2.Trim() != "*")
                {
                    //overrides in all cases (except OPEN a AS *), if the name is explicitly given with AS                  
                    readInfo.dbName = as2;
                }

                // -----
                // -----

                int existI; int workI; int refI;
                Databanks.FindBanksI(readInfo.dbName, out existI, out workI, out refI);
                bool category1_alreadyOpen = false;
                if (existI != -12345)
                {
                    category1_alreadyOpen = true;
                }

                // -----
                // -----

                bool category3_createBrandNew = false;
                if (open && !category2_fileExists && !category1_alreadyOpen)
                {
                    if (oRead.editable)
                    {
                        category3_createBrandNew = true;
                    }
                    else
                    {
                        if (create)
                        {
                            category3_createBrandNew = true;
                        }
                        else
                        {
                            G.Writeln2("*** ERROR: OPEN: The databank '" + originalFileNameWithExtension + "' could not be found (see OPEN<create> if this is intentional).");
                            throw new GekkoException();
                        }
                    }
                }

                // ---------------------------------------------------------------------------------
                //                  End of categories
                // ---------------------------------------------------------------------------------
                
                if (file == null)
                {
                    if (!Globals.excelDna)  //because we Gekcel-cheat with IMPORT<xlsx>, so file == null, but should not report an error here
                    {
                        if (!open)
                        {
                            G.Writeln2("*** ERROR: OPEN: The databank '" + originalFileNameWithExtension + "' could not be found");
                            throw new GekkoException();
                        }
                    }
                }
                
                if (as2 != null && as2 == "*") as2 = readInfo.dbName;    //With READ * TO *, as2 will be '*'. In that case, we use the filename. This will only happen regarding READ, we do not have an OPEN * AS * (would not be useful, OPEN * would do exactly the same)
                if (as2 != null) readInfo.dbName = as2;

                DateTime dt1 = DateTime.Now;

                //bool isReadFromFile = true; //always true for READ/MULBK

                //readInfo.databank = databank;

                string originalFilePath = file;

                string tsdxFile = null;
                string tempTsdxPath = null;

                int NaNCounter = 0;

                bool copyLocal = Program.options.databank_file_copylocal;

                readInfo.fileName = file;

                Databank databank = null;

                //if (nonExistingGbkFileOpened) readInfo.type = EReadInfoTypes.NonExistingGbkFileOpened;

                Databank databankTemp = null;  //temp bank where the external file is read into

                // ---------------------------------------------------------------------------------
                //                  Read the file into databankTemp
                // ---------------------------------------------------------------------------------

                string hash = null;

                if (!open || (open && !category1_alreadyOpen && category2_fileExists))
                {
                    if (copyLocal && !Globals.excelDna2)
                    {
                        DateTime t0 = DateTime.Now;
                        localFileThatShouldBeDeletedPathAndFilename = GetTempTsdFilePath(extension);
                        WaitForFileCopy(file, localFileThatShouldBeDeletedPathAndFilename);
                        G.WritelnGray("Local copying: " + G.SecondsFormat((DateTime.Now - t0).TotalMilliseconds));
                        file = localFileThatShouldBeDeletedPathAndFilename;
                    }

                    databankTemp = GetDatabankFromFile(offset, oRead, readInfo, file, originalFilePath, oRead.dateformat, oRead.datetype, ref tsdxFile, ref tempTsdxPath, ref NaNCounter);
                    if (open)
                    {
                        if (!file.Contains(Globals.isAProto))  //probably does not happen anymore
                        {
                            hash = Program.GetMD5Hash(GetTextFromFileWithWait(file));
                        }
                    }
                }
                else
                {
                    //open && readInfo.type != EReadInfoTypes.Normal
                    databankTemp = null; //already so, but just to state it here
                }

                // ---------------------------------------------------------------------------------
                //                  Now handle READ/IMPORT or OPEN
                // ---------------------------------------------------------------------------------
                
                if (open)
                {
                    // -----------------------
                    //OPEN or READ...TO...
                    // -----------------------

                    databank = Program.databanks.OpenDatabankNew(readInfo.dbName, databankTemp, oRead.openType, oRead.openTypePosition, existI, workI, refI, create); //puts it in storage[2], returns bool that says if it is just moved around in databank list, or freshly read from file                        
                                        
                    databank.editable = false;
                    if (oRead.openType == EOpenType.Edit) databank.editable = true;

                    databank.name = readInfo.dbName;
                }
                else
                {
                    // -----------------------
                    //READ/IMPORT
                    // -----------------------


                    // ----------------------
                    //READ or IMPORT, puts data into First or Ref
                    // ----------------------
                    AllFreqsHelper dates = null;
                    if (!oRead.t1.IsNull() && oRead.t1.freq == EFreq.U)
                    {
                        G.Writeln2("*** ERROR: Date-truncation not yet implemented for undated frequency.");
                        throw new GekkoException();
                    }
                    else
                    {
                        dates = G.ConvertDateFreqsToAllFreqs(oRead.t1, oRead.t2);  //returns null if no truncation
                    }

                    //READ or READ<first>
                    databank = Program.databanks.GetFirst();
                    if (oRead.openType == EOpenType.Ref) databank = Program.databanks.GetRef();

                    //TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO 
                    //TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO 
                    //TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO 
                    //
                    // when it is a simple read or import into an empty bank
                    // and there is not time-truncation, just set dataBank = dataBankTemp
                    //
                    //TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO 
                    //TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO 
                    //TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO 

                    if (wipeDatabankBeforeInsertingData)
                    {
                        databank.Clear();
                    }

                    if (false && dates == null)
                    {
                        //foreach (KeyValuePair<string, IVariable> kvp in databankTemp.storage)
                        //{
                        //    if (databank.ContainsIVariable(kvp.Key)) databank.RemoveIVariable(kvp.Key);
                        //    IVariable iv = kvp.Value;
                        //    databank.AddIVariable(kvp.Key, iv); //no need to deep clone kvp.Value
                        //}
                    }
                    else
                    {
                        //Cannot do a simple deflate in this case: has to move stuff from deflated file into existing first databank

                        //
                        // ------ WORK ----------            ------ FILE ---------
                        //
                        //           x1     x2                  x1      x3
                        //
                        // 2000       2                                1000
                        // 2001       3     100                 10     2000
                        // 2002       4     200                 11
                        // 2003             300                 12
                        //                    
                        // We merge in the two dimensions:
                        //
                        // ------ WORK ----------        
                        //
                        //           x1     x2     x3       
                        //
                        // 2000       2            1000     
                        // 2001      10     100    2000  
                        // 2002      11     200          
                        // 2003      12     300          
                        //
                        // If non-series or array-series, just replace any File object already in Work (never mind time truncation)
                        // SERIES: Easy copy if series is not in Work (x3)
                        // SERIES: If in Work, only inject over the overlap of date period and series data period)
                        // ARRAYSERIES: do as above, just for these subseries
                        //            

                        int maxYearInProtobufFile = -12345;
                        int minYearInProtobufFile = -12345;

                        foreach (KeyValuePair<string, IVariable> kvp in databankTemp.storage)  //for each ivar in temp databank 
                        {
                            string name = kvp.Key;
                            IVariable iv = kvp.Value;

                            if (iv.Type() == EVariableType.Series)
                            {
                                //NOTE: we only time-truncate series and array-series at the direct level, not series inside lists, maps etc.

                                Series tsExisting = GetTsExisting(databank, name);  //may be null
                                Series tsProtobuf = iv as Series;  //cannot be null

                                if (tsProtobuf.type == ESeriesType.ArraySuper)
                                {
                                    //---------------------------
                                    // handle array-timeseries
                                    //---------------------------
                                    
                                    if (tsExisting == null)
                                    {
                                        databank.AddIVariable(name, tsProtobuf); //the sub-timeseries will follow automatically!
                                    }
                                    else
                                    {
                                        if (tsExisting.dimensions == tsProtobuf.dimensions)
                                        {
                                            //now, we have same-name and same-dim array-timeseries in both Work and protobuf file.
                                            MapMultidim gmapExisting = tsExisting.dimensionsStorage;
                                            MapMultidim gmapProtobuf = tsProtobuf.dimensionsStorage;

                                            foreach (KeyValuePair<MapMultidimItem, IVariable> kvpGmap in gmapProtobuf.storage)
                                            {
                                                MapMultidimItem nameDimProtobuf = kvpGmap.Key;
                                                Series tsDimProtobuf = kvp.Value as Series;  //must be timeseries, no need to check that the type is so

                                                IVariable ivDimExisting = null; gmapExisting.TryGetValue(nameDimProtobuf, out ivDimExisting);
                                                Series tsDimExisting = null; if (ivDimExisting != null) tsDimExisting = ivDimExisting as Series;

                                                //now we have a tsDimProtobuf, and if tsDimExisting != null, we merge the data

                                                if (tsDimExisting == null)
                                                {
                                                    //add this sub-series to the array-timeseries                                   
                                                    tsProtobuf.Truncate(dates);
                                                    gmapProtobuf.AddIVariableWithOverwrite(nameDimProtobuf, tsProtobuf);
                                                }
                                                else
                                                {
                                                    //now we need to merge the two series
                                                    //also see #98520983
                                                    bool shouldOverwriteLaterOn = false;
                                                    MergeTwoTimeseriesWithDateWindow(dates, tsExisting, tsProtobuf, ref maxYearInProtobufFile, ref minYearInProtobufFile, ref shouldOverwriteLaterOn);
                                                    MergeTwoTimeseriesWithDateWindowHelper(dates, gmapExisting, nameDimProtobuf, tsProtobuf, shouldOverwriteLaterOn);
                                                }
                                            }
                                        }
                                        else
                                        {
                                            //dimensions do not match, wipt existing out!
                                            databank.AddIVariableWithOverwrite(name, tsProtobuf);  //the sub-timeseries will follow automatically!
                                        }
                                    }
                                }
                                else
                                {
                                    //---------------------------
                                    // handle normal timeseries
                                    //---------------------------

                                    //also see #98520983
                                    bool wipeExistingOut = false;
                                    MergeTwoTimeseriesWithDateWindow(dates, tsExisting, tsProtobuf, ref maxYearInProtobufFile, ref minYearInProtobufFile, ref wipeExistingOut);
                                    MergeTwoTimeseriesWithDateWindowHelper(dates, databank, name, tsProtobuf, wipeExistingOut);
                                }
                            }
                            else
                            {
                                //Non-series
                                //Easy: string, val, date, list, map, matrix
                                databank.AddIVariableWithOverwrite(name, iv);
                            }
                        }

                    }
                    databank.FileNameWithPath = databankTemp.FileNameWithPath;

                }

                //readInfo.startPerInFile = minYearInProtobufFile;
                //readInfo.endPerInFile = maxYearInProtobufFile;
                //readInfo.startPerResultingBank = G.GekkoMin(minYearInProtobufFile, databank.yearStart);
                //readInfo.endPerResultingBank = G.GekkoMax(maxYearInProtobufFile, databank.yearEnd);

                HandleCleanAndParentForTimeseries(databank, oRead.Merge);  //otherwise it will look dirty                    

                if (Program.options.solve_data_create_auto == true)
                {
                    string freq = G.GetFreq(Program.options.freq);

                    if (!open && (oRead.openType == EOpenType.First || oRead.openType == EOpenType.Normal))  //READ or READ<first>
                    {
                        IVariable all = Program.databanks.GetGlobal().GetIVariable("#all");
                        if (all != null)
                        {
                            List all_list = all as List;
                            if (all_list != null)
                            {
                                foreach (IVariable iv in all_list.list)
                                {
                                    ScalarString ss = iv as ScalarString;
                                    if (ss == null) continue;
                                    string s = ss.string2;
                                    string s2 = G.Chop_GetName(s);
                                    //This will create them if no already there
                                    IVariable iv2 = O.GetIVariableFromString(O.UnChop(Globals.First.ToLower(), s2, freq, null), O.ECreatePossibilities.Can);
                                    IVariable iv3 = O.GetIVariableFromString(O.UnChop(Globals.Ref.ToLower(), s2, freq, null), O.ECreatePossibilities.Can);
                                }
                            }
                        }
                    }
                }

                //Cleanup of local files
                if (copyLocal && !Globals.excelDna2)
                {
                    if (true)
                    {
                        try
                        {
                            File.SetAttributes(localFileThatShouldBeDeletedPathAndFilename, FileAttributes.Normal);  //it may be read-only if original file is so
                            File.Delete(localFileThatShouldBeDeletedPathAndFilename);  //hmm probably best not to use WaitForFileDelete() here, since it seems it is ok if delete fails here
                        }
                        catch (Exception e)
                        {
                            //do nothing
                        }
                    }

                    if (isGbk)
                    {
                    
                        try
                        {
                            File.SetAttributes(tsdxFile, FileAttributes.Normal);  //it may be read-only if original file is so
                            File.Delete(tsdxFile);  //hmm probably best not to use WaitForFileDelete() here, since it seems it is ok if delete fails here
                        }
                        catch (Exception e)
                        {
                            //do nothing
                        }

                        try
                        {
                            DirectoryInfo folderInfo = new DirectoryInfo(tempTsdxPath);
                            if (System.IO.Directory.Exists(folderInfo.FullName))
                            {
                                System.IO.Directory.Delete(folderInfo.FullName, true);
                            }
                        }
                        catch (Exception e)
                        {
                            //do nothing
                        }
                    }
                }

                readInfo.time = (DateTime.Now - dt1).TotalMilliseconds;

                databank.info1 = readInfo.info1;
                databank.date = readInfo.date;
                databank.FileNameWithPath = readInfo.fileName;

                if (open)
                {
                    if (!oRead.editable)
                    {
                        databank.editable = false;
                    }
                    else
                    {
                        if (!isGbk)
                        {
                            if (databank.editable == true)
                            {
                                G.Writeln2("The file is opened as non-editable, since it is not a ." + Globals.extensionDatabank + " file");
                                databank.editable = false;
                            }
                        }
                    }
                }
                readInfo.databank = databank;
                readInfos.Add(readInfo);

                //databank.Trim();  //This way, the bank is not too bulky in RAM. The operation takes almost no time, and if it is a .tsdx file, the timeseries are already trimmed and trimming is hence skipped.
                //databank.readInfo = readInfo;  //Not really used at the moment, but practical to have a pointer to this information!                

                if (open)
                {
                    if (category3_createBrandNew)
                    {
                        databank.fileHash = Globals.brandNewFile; //signifies that the bank is brand new
                        databank.FileNameWithPath = Program.CreateFullPathAndFileName(originalFileNameWithExtension);
                    }
                    else
                    {
                        if (category2_fileExists && !category1_alreadyOpen)
                        {
                            if (hash != null) databank.fileHash = hash; //typically the MD5 has already been done on the copylocal temp file
                            else databank.fileHash = Program.GetMD5Hash(GetTextFromFileWithWait(databank.FileNameWithPath));
                        }
                    }
                }
            }  //for each bank in list

            return;
        }

        public static Databank GetDatabankFromFile(CellOffset offset, ReadOpenMulbkHelper oRead, ReadInfo readInfo, string file, string originalFilePath, string dateformat, string datetype, ref string tsdxFile, ref string tempTsdxPath, ref int NaNCounter)
        {
            //note: file is altered below, not sure why

            Databank databankTemp = new Databank("temporary"); //doing it like this, merging is much easier

            if (oRead.Type == EDataFormat.Pcim)
            {
                Program.ReadPCIM(databankTemp, readInfo, file);
            }
            else if (oRead.Type == EDataFormat.Csv || oRead.Type == EDataFormat.Prn || oRead.Type == EDataFormat.Xls || oRead.Type == EDataFormat.Xlsx)
            {
                ReadSheet(offset, oRead, readInfo, file, databankTemp, originalFilePath, dateformat, datetype);
            }
            else if (oRead.Type == EDataFormat.Tsd)
            {
                ReadTsd(oRead, readInfo, ref file, ref databankTemp, originalFilePath, ref NaNCounter);
            }
            else if (oRead.Type == EDataFormat.Tsd || oRead.Type == EDataFormat.Tsdx || oRead.Type == EDataFormat.Gbk || oRead.Type == EDataFormat.None)
            {
                ReadGbk(oRead, readInfo, ref file, ref databankTemp, originalFilePath, ref tsdxFile, ref tempTsdxPath);
            }
            else if (oRead.Type == EDataFormat.Tsp)
            {
                TspUtilities.tspDataUtility(file, databankTemp, oRead, readInfo);
            }
            else if (oRead.Type == EDataFormat.Gdx)
            {
                GamsData.ReadGdx(databankTemp, readInfo, file);
            }
            else if (oRead.Type == EDataFormat.Px)
            {
                Program.ReadPxHelper(databankTemp, oRead, readInfo, file);
            }
            else if (oRead.Type == EDataFormat.Flat)
            {
                Program.ReadFlat(databankTemp, readInfo, file);
            }
            else if (oRead.Type == EDataFormat.Aremos)
            {
                Program.ReadAremos(databankTemp, readInfo, file);
            }
            else
            {
                G.Writeln2("*** ERROR #78632432");
                throw new GekkoException();
            }

            return databankTemp;
        }


        private static void CheckOpenSyntax(ReadOpenMulbkHelper oRead)
        {
            int counter = 0;
            foreach (List<string> ss in oRead.openFileNames)
            {
                if (ss[0] == "*") counter++;
            }
            if (counter >= 1)
            {
                //there is at least one *
                if (counter == 1 && oRead.openFileNames.Count == 1)
                {
                    //ok
                }
                else
                {
                    G.Writeln2("*** ERROR: The '*' cannot be used in a list of filenames");
                    throw new GekkoException();
                }
            }

            if (counter >= 1 && oRead.openFileNames.Count > 1)
            {
                if (oRead.openFileNames[0][0] != "*")
                {

                }
            }
            else if (counter > 1)
            {
                G.Writeln2("*** ERROR: The '*' filename should not be stated in a list of files to open");
                throw new GekkoException();
            }
        }

        public static bool IsDatabankDirty(Databank removed)
        {
            bool isDirty = false;
            if (removed.isDirty) isDirty = true;
            else
            {               

                foreach (IVariable iv in removed.storage.Values)
                {
                    Series ts = iv as Series;
                    if (ts == null) continue;
                    if (ts.IsDirty())
                    {
                        isDirty = true;
                        break;
                    }
                }
            }
            return isDirty;
        }

        public static void HandleCleanAndParentForTimeseries(Databank db, bool merge)
        {
            db.isDirty = false;
            foreach (IVariable iv in db.storage.Values)
            {
                Series ts = iv as Series;
                if (ts == null) continue;
                if (ts.type == ESeriesType.ArraySuper)
                {
                    foreach (Series tsSub in ts.dimensionsStorage.storage.Values)
                    {
                        if (tsSub.type == ESeriesType.Light) tsSub.meta = new Gekko.SeriesMetaInformation();
                        tsSub.meta.parentDatabank = db;
                        if (!merge) tsSub.SetDirty(false);
                    }
                }
                if (!merge) ts.SetDirty(false);  //if we are not merging, the bank is comletely new, and the timeseries are all considered clean. When merging, dirt is all over.
                ts.meta.parentDatabank = db;
            }
        }

        private static void ReadSheet(CellOffset offset, ReadOpenMulbkHelper oRead, ReadInfo readInfo, string file, Databank databank, string originalFilePath, string dateformat, string datetype)
        {
            //TODO:
            //For speedup:
            //Use simpler Dictionary<long,helper>, where long is row + 2^32*col, and counting maxrow and
            //maxcol. Optionally inputkeys and maxrow/col can be transposed. Helper is a struct with
            //string+double fields. If string==null and double.NaN, the values is simply not put in.
            //if string==null, it is assumed to be a double field.

            //DateTime t000 = DateTime.Now;
            readInfo.fileName = originalFilePath;
            TableLight matrix = null;
            string prnType = null;
            if (oRead.Type == EDataFormat.Csv || oRead.Type == EDataFormat.Prn)
            {
                if (!oRead.Merge)
                {
                    databank.Clear();
                }
                matrix = ReadCsvPrn(oRead.Type, file);
            }
            else
            {
                if (Globals.excelDna)
                {                    
                    matrix = Globals.excelDnaData.tableLight;
                }
                else
                {
                    matrix = ReadExcelWorkbook(file, oRead.sheet);
                }
            }
            GetTimeseriesFromWorkbookMatrix(offset, oRead, databank, matrix, readInfo, dateformat, datetype);
        }

        public static int ExcelColumnNameToNumber(string columnName)
        {
            if (string.IsNullOrEmpty(columnName)) throw new GekkoException();
            columnName = columnName.ToUpperInvariant();
            int sum = 0;
            for (int i = 0; i < columnName.Length; i++)
            {
                sum *= 26;
                sum += (columnName[i] - 'A' + 1);
            }
            return sum;
        }        

        public enum ESheetCollection
        {
            Matrix,
            List,
            Map,
            None
        }

        public static void SheetImport(O.SheetImport o)
        {
            List<string> listItems = null;

            ESheetCollection type = ESheetCollection.None;
            if (G.Equal(o.opt_matrix, "yes")) type = ESheetCollection.Matrix;
            else if (G.Equal(o.opt_list, "yes")) type = ESheetCollection.List;
            else if (G.Equal(o.opt_map, "yes")) type = ESheetCollection.Map;

            if (type != ESheetCollection.None)
            {
                listItems = O.Restrict(o.names, true, true, false, false);
            }
            else
            {
                listItems = O.Restrict(o.names, true, false, true, false);
            }

            string collectionName = null;

            if (type != ESheetCollection.None)
            {
                if (listItems.Count == 0 || listItems.Count > 1)
                {
                    G.Writeln2("*** ERROR: For SHEET<import " + type.ToString().ToLower() + ">, only 1 name must be provided");
                    throw new GekkoException();
                }
                collectionName = listItems[0];
            }
            
            bool isMissing = false;
            if (G.Equal(o.opt_missing, "yes"))
            {
                isMissing = true;
            }

            //do copylocal
            string fileName = o.fileName;
            fileName = AddExtension(fileName, ".xlsx");
            fileName = Program.CreateFullPathAndFileNameFromFolder(fileName, null);
            //TableLight inputTable = ReadExcelWorkbook(fileName, o.opt_sheet);            
                        
            EDataFormat fileType = EDataFormat.Xlsx;
            if (G.Equal(o.opt_xls, "yes")) fileType = EDataFormat.Xls;
            else if (G.Equal(o.opt_xlsx, "yes")) fileType = EDataFormat.Xlsx;
            else if (G.Equal(o.opt_csv, "yes")) fileType = EDataFormat.Csv;
            else if (G.Equal(o.opt_prn, "yes")) fileType = EDataFormat.Prn;
            //else
            //{
            //    G.Writeln2("*** ERROR: SHEET<import> must be used with file type xlsx, xls, csv or prn");
            //    throw new GekkoException();
            //}

            TableLight inputTable = null;
            if (fileType == EDataFormat.Csv || fileType == EDataFormat.Prn)
            {
                inputTable = ReadCsvPrn(fileType, fileName);
            }
            else if (fileType == EDataFormat.Xls || fileType == EDataFormat.Xlsx)
            {
                inputTable = ReadExcelWorkbook(fileName, o.opt_sheet);
            }            

            bool transpose = false;  //corresponding to row-wise reading
            if (G.Equal(o.opt_cols, "yes"))
            {
                transpose = true;
                if (type != ESheetCollection.None) G.Writeln2("+++ NOTE: Because of <cols> option, the resulting " + type.ToString().ToLower() + " is transposed");
            }

            if (transpose)
            {
                //reading downwards by cols
                inputTable = inputTable.Transpose();
            }

            int obs = GekkoTime.Observations(o.t1, o.t2);
            int n = listItems.Count;

            string s = "a1";
            if (o.opt_cell != null) s = o.opt_cell;
            int index = s.IndexOfAny(new char[] { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9' });
            string chars = s.Substring(0, index);
            int num = Int32.Parse(s.Substring(index));
            int rowOffset = num - 1;
            int colOffset = ExcelColumnNameToNumber(chars) - 1;

            if (transpose)
            {
                //switch them
                int temp = rowOffset;
                rowOffset = colOffset;
                colOffset = temp;
            }

            //check between 1... large number

            if (type == ESheetCollection.None)
            {
                for (int row = 1 + rowOffset; row < 1 + rowOffset + n; row++)
                {
                    Series ts = O.GetIVariableFromString(listItems[row - 1 - rowOffset], O.ECreatePossibilities.Must) as Series;
                    for (int col = 1 + colOffset; col < 1 + colOffset + obs; col++)
                    {                        
                        CellLight cell = inputTable.Get(row, col);
                        if (cell.type == ECellLightType.None) continue;
                        double v = GetValueFromSpreadsheetCell(transpose, row, col, cell);
                        ts.SetData(o.t1.Add(col - 1 - colOffset), v);
                    }
                }
            }
            else
            {
                Matrix outputMatrix = null;
                List outputList = null;
                Map outputMap = null;               

                int rr = inputTable.GetRowMaxNumber() - rowOffset;
                int cc = inputTable.GetColMaxNumber() - colOffset;
                if (rr <= 0 || cc <= 0)
                {
                    G.Writeln2("*** ERROR: There is not data in the sheet area");
                    throw new GekkoException();
                }

                if (type == ESheetCollection.Matrix)
                {
                    if (isMissing) outputMatrix = new Matrix(rr, cc, double.NaN);
                    else outputMatrix = new Matrix(rr, cc);
                }
                else if (type == ESheetCollection.List) outputList = new List();
                else if (type == ESheetCollection.Map) outputMap = new Map();

                for (int row = 1 + rowOffset; row <= inputTable.GetRowMaxNumber(); row++)
                {
                    if (type == ESheetCollection.List)
                    {
                        outputList.Add(new List());  //adding a new row
                    }
                    for (int col = 1 + colOffset; col <= inputTable.GetColMaxNumber(); col++)
                    {
                        
                        CellLight cell = inputTable.Get(row, col);
                        if (cell.type == ECellLightType.None)
                        {
                            if (type == ESheetCollection.List)
                            {
                                (outputList.list[row - 1 - rowOffset] as List).Add(GekkoNull.gekkoNull);
                            }                            
                            continue;
                        }                        

                        if (type == ESheetCollection.Matrix)
                        {
                            double v = GetValueFromSpreadsheetCell(transpose, row, col, cell);
                            outputMatrix.data[row - 1 - rowOffset, col - 1 - colOffset] = v;
                        }
                        else if (type == ESheetCollection.List || type == ESheetCollection.Map)
                        {

                            bool isNaNText = false;
                            if(cell.type==ECellLightType.String)
                            {
                                if (IsNonAvailableText(cell.text, false)) isNaNText = true;  //will not be true if M or NA
                            }

                            IVariable iv = null;
                            if (isNaNText)
                            {
                                iv = new ScalarVal(double.NaN);
                            }
                            else if (cell.type == ECellLightType.DateTime)
                            {
                                int sub = -12345;
                                EFreq freq = Program.options.freq;
                                //uses current freq 
                                GekkoTime gt5 = GekkoTime.FromDateTimeToGekkoTime(freq, cell.dateTime);
                                int super = gt5.super;
                                sub = gt5.sub;

                                iv = new ScalarDate(new GekkoTime(freq, super, sub));
                            }
                            else if (cell.type == ECellLightType.Double)
                            {
                                //will not try to interpret a string like M or NA or #I/T as a missing,
                                //since it IS not a string here
                                iv = new ScalarVal(GetValueFromSpreadsheetCell(transpose, row, col, cell));
                            }
                            else if (cell.type == ECellLightType.String)
                            {
                                //A string like #I/T has isNaNText = true and is handled above
                                //but we may have a M or NA here, which will just become a string
                                //later on: maybe option for M and NA strings...?
                                iv = new ScalarString(cell.text.Trim());                                
                            }
                            else if (cell.type == ECellLightType.None)
                            {
                                iv = GekkoNull.gekkoNull;
                            }
                            else
                            {
                                throw new GekkoException();
                            }

                            if (type == ESheetCollection.List)
                            {
                                (outputList.list[row - 1 - rowOffset] as List).Add(iv);
                            }
                            else
                            {
                                string coord = Globals.symbolScalar + GetExcelCell(row - 1 - rowOffset + 1, col - 1 - colOffset + 1, transpose);  //1 is added, so that first coord is called with i = 1, j = 1, not i = 0, j = 0.
                                outputMap.Add(coord, iv); //topleft will always be "%a1"
                            }                            
                        }                        
                    }
                }
                IVariable output = null;
                if (type == ESheetCollection.Matrix) output = outputMatrix;
                else if (type == ESheetCollection.List) output = outputList;
                else if (type == ESheetCollection.Map) output = outputMap;
                O.AddIVariableWithOverwriteFromString(collectionName, output);
                G.Writeln2("Imported " + type.ToString().ToLower() + " " + collectionName + " (" + rr + "x" + cc + " elements)");
            }
        }

        public static double GetValueFromSpreadsheetCell(bool transpose, int row, int col, CellLight cell)
        {
            double v = double.NaN;
            if (cell.type == ECellLightType.String)
            {
                if (IsNonAvailableText(cell.text))
                {
                    //keep NaN
                }
                else
                {
                    G.Writeln2("*** ERROR in spreadsheet cell " + GetExcelCell(row, col, transpose) + ", content: '" + cell.text + "'");
                    throw new GekkoException();
                }
            }
            else if (cell.type == ECellLightType.Double)
            {
                v = cell.data;
            }
            else
            {
                G.Writeln2("*** ERROR: Could not understand spreadsheet cell " + GetExcelCell(row, col, transpose) + " as a number");
                throw new GekkoException();
            }
            return v;
        }


        public static void ReadGbk(ReadOpenMulbkHelper oRead, ReadInfo readInfo, ref string file, ref Databank databank, string originalFilePath, ref string tsdxFile, ref string tempTsdxPath)
        {
            
            //Note: file is altered below in several places, including is_a_protobuffer_file stuff
            
            //NOTE: time-truncation is only done at the uppermost level: series or array-series. Stuff inside LIST or MAP is not time-truncated.

            //bool mergeOrTimeLimit = oRead.Merge || dates != null;

            readInfo.databankVersion = "";
            //try to unzip it here
            tempTsdxPath = GetTempTsdxFolderPath();
            if (!Directory.Exists(tempTsdxPath))  //should almost never exist, since name is random
            {
                Directory.CreateDirectory(tempTsdxPath);
            }
            else
            {
                //in the very rare case, any files here will be overwritten
            }
            string unzippedFile = Path.GetFileNameWithoutExtension(originalFilePath) + ".tsd";
                        
            DateTime dt2 = DateTime.Now;
            string foundTsdFile = WaitForZipRead_TSDX(tempTsdxPath, file, unzippedFile, originalFilePath);
            G.WritelnGray("Unzipping took: " + G.Seconds(dt2));
            
            //both protobuffers and tsd files

            tsdxFile = file;
            //file = tempTsdxPath + "\\" + unzippedFile;
            file = tempTsdxPath + "\\" + foundTsdFile;
            string databankVersion = null;

            XmlDocument doc = new XmlDocument();
            //We can presume that DatabankInfo.xml is in UTF-8, since it is typically written by Gekko
            //So no need to use GetTextFromFile()
            string fileXml = tempTsdxPath + "\\" + "DatabankInfo.xml";
            using (FileStream fs = WaitForFileStream(fileXml, GekkoFileReadOrWrite.Read))
            {
                try
                {
                    doc.Load(fs);
                }
                catch (Exception e)
                {
                    G.Writeln2("*** ERROR: XML file 'DatabankInfo.xml' inside " + Globals.extensionDatabank + " file.");
                    WriteXmlError(e, fileXml);
                    throw new GekkoException();
                }

                XmlElement root = doc.DocumentElement; //"DatabankInfo"

                databankVersion = root.GetAttribute("databankVersion").Trim();
                if (databankVersion == "") databankVersion = "1.0";
                string gekkoVersion = root.GetAttribute("gekkoVersion").Trim();
                if (databankVersion != "") readInfo.databankVersion = "(vers: " + databankVersion + ")";
                
                if (!Globals.tsdxVersions.Contains(databankVersion))
                {
                    G.Writeln2("*** ERROR: The databank version " + databankVersion + " is unknown to this Gekko version (" + Globals.gekkoVersion + ")");
                    G.Write("           Known databank versions: "); G.PrintListWithCommas(Globals.tsdxVersions, false);
                    G.Writeln("           The databank seems to have been written by Gekko version " + gekkoVersion);
                    G.Writeln("           Troubleshooting, try this page: " + Globals.databankformatUrl);
                    throw new GekkoException();
                }

                XmlNodeList descriptions = doc.GetElementsByTagName("Info1");
                foreach (XmlNode description in descriptions)  //should be only 1 in this loop
                {
                    readInfo.info1 = description.InnerText.Trim();
                }

                XmlNodeList dates5 = doc.GetElementsByTagName("Date");
                foreach (XmlNode date in dates5) //should be only 1 in this loop
                {
                    readInfo.date = date.InnerText.Trim();
                }

                XmlNodeList modelNames = doc.GetElementsByTagName("ModelName");
                foreach (XmlNode modelName in modelNames) //should be only 1 in this loop
                {
                    readInfo.modelName = modelName.InnerText.Trim();
                }

                XmlNodeList modelInfos = doc.GetElementsByTagName("ModelInfo");
                foreach (XmlNode modelInfo in modelInfos) //should be only 1 in this loop
                {
                    readInfo.modelInfo = modelInfo.InnerText.Trim();
                }

                XmlNodeList modelDates = doc.GetElementsByTagName("ModelDate");
                foreach (XmlNode modelDate in modelDates) //should be only 1 in this loop
                {
                    readInfo.modelDate = modelDate.InnerText.Trim();
                }

                XmlNodeList modelSignatures = doc.GetElementsByTagName("ModelSignature");
                foreach (XmlNode modelSignature in modelSignatures) //should be only 1 in this loop
                {
                    readInfo.modelSignature = modelSignature.InnerText.Trim();
                }

                XmlNodeList modelHashs = doc.GetElementsByTagName("ModelHash");
                foreach (XmlNode modelHash in modelHashs) //should be only 1 in this loop
                {
                    readInfo.modelHash = modelHash.InnerText.Trim();
                }

                XmlNodeList modelLastSimPeriods = doc.GetElementsByTagName("ModelLastSimPeriod");
                foreach (XmlNode modelLastSimPeriod in modelLastSimPeriods) //should be only 1 in this loop
                {
                    readInfo.modelLastSimPeriod = modelLastSimPeriod.InnerText.Trim();
                }

                XmlNodeList modelLastSimStamps = doc.GetElementsByTagName("ModelLastSimStamp");
                foreach (XmlNode modelLastSimStamp in modelLastSimStamps) //should be only 1 in this loop
                {
                    readInfo.modelLastSimStamp = modelLastSimStamp.InnerText.Trim();
                }

                XmlNodeList modelLargestLags = doc.GetElementsByTagName("ModelLargestLag");
                foreach (XmlNode modelLargestLag in modelLargestLags) //should be only 1 in this loop
                {
                    readInfo.modelLargestLag = modelLargestLag.InnerText.Trim();
                }

                XmlNodeList modelLargestLeads = doc.GetElementsByTagName("ModelLargestLead");
                foreach (XmlNode modelLargestLead in modelLargestLeads) //should be only 1 in this loop
                {
                    readInfo.modelLargestLead = modelLargestLead.InnerText.Trim();
                }
            }

            Databank deserializedDatabank = null;
            readInfo.fileName = originalFilePath;

            if (databankVersion == "1.0" || databankVersion == "1.1")
            {
                deserializedDatabank = ReadGbk_1_1(oRead, readInfo, ref file, databank, originalFilePath, ref tsdxFile, ref tempTsdxPath, databankVersion);
            }
            else
            {
                string fileName = null;
                if (File.Exists(tempTsdxPath + "\\" + Globals.protobufFileName)) fileName = tempTsdxPath + "\\" + Globals.protobufFileName;  //legacy
                else if (File.Exists(tempTsdxPath + "\\" + Globals.protobufFileName2)) fileName = tempTsdxPath + "\\" + Globals.protobufFileName2;  //usual name
                else if (File.Exists(tempTsdxPath + "\\" + Program.options.databank_file_gbk_internal)) fileName = tempTsdxPath + "\\" + Program.options.databank_file_gbk_internal;  //IF the usual name is changed
                else
                {
                    G.Writeln2("*** ERROR: Could not find data storage file inside zipped databank file");
                    G.Writeln("           Troubleshooting, try this page: " + Globals.databankformatUrl, Color.Red);
                    throw new GekkoException();
                }
                
                using (FileStream fs = WaitForFileStream(fileName, GekkoFileReadOrWrite.Read))
                {
                    ////May take a little time to create: so use static serializer if doing serialize on a lot of small objects
                    //RuntimeTypeModel serializer = TypeModel.Create();
                    //serializer.UseImplicitZeroDefaults = false;  //otherwise an int that has default constructor value -12345 but is set to 0 will reappear as a -12345 (instead of 0). For int, 0 is default, false for bools etc.
                    try
                    {
                        DateTime dt3 = DateTime.Now;

                        RuntimeTypeModel serializer = TypeModel.Create();

                        deserializedDatabank = serializer.Deserialize(fs, null, typeof(Databank)) as Databank;

                        foreach (IVariable iv in deserializedDatabank.storage.Values)
                        {
                            iv.DeepCleanup();  //fixes maps and lists with 0 elements, also binds MapMultiDim.parent
                        }
                        readInfo.variables = deserializedDatabank.storage.Count;
                        G.WritelnGray("Protobuf deserialize took: " + G.Seconds(dt3));
                    }
                    catch (Exception e)
                    {
                        G.Writeln2("*** ERROR: Unexpected technical error when reading " + Globals.extensionDatabank + " databank in version " + Globals.currentGbkVersion + " format (protobuffers)");
                        G.Writeln("           Message: " + e.Message, Color.Red);
                        G.Writeln("           Troubleshooting, try this page: " + Globals.databankformatUrl, Color.Red);

                        throw;
                    }

                }  //end of using

            }

            int maxYearInProtobufFile = int.MinValue;
            int minYearInProtobufFile = int.MaxValue;

            if (true)
            {
                //Can do it fast, just swapping the deserialized bank instead of the current, with no copying around
                try
                {
                    //discarding the old bank completely, and replacing with the new one
                    deserializedDatabank.name = databank.name;
                    Program.databanks.ReplaceDatabank(databank, deserializedDatabank);
                    //readInfo.databank = deserializedDatabank;  //since this pointer is altered
                    databank = deserializedDatabank;  //since this pointer is altered
                    databank.FileNameWithPath = originalFilePath;
                }
                catch (Exception e)
                {
                    G.Writeln2("*** ERROR: Unexpected technical error while reading " + Globals.extensionDatabank + " databank");
                    throw new GekkoException();
                }
                if (!(databankVersion == "1.0" || databankVersion == "1.1"))
                {
                    readInfo.startPerInFile = minYearInProtobufFile;
                    readInfo.endPerInFile = maxYearInProtobufFile;
                }
                readInfo.startPerResultingBank = readInfo.startPerInFile;
                readInfo.endPerResultingBank = readInfo.endPerInFile;
            }

            //if (emptyWarnings > 0) G.Writeln("+++ WARNING: " + emptyWarnings + " variables with empty string as name in ." + Globals.extensionDatabank + " file (skipped)");

            //Databank currentBank = Program.databanks.GetDatabank(databank.name);
            //currentBank.yearStart = readInfo.startPerResultingBank;
            //currentBank.yearEnd = readInfo.endPerResultingBank;

        }

        private static Databank ReadGbk_1_1(ReadOpenMulbkHelper oRead, ReadInfo readInfo, ref string file, Databank databank, string originalFilePath, ref string tsdxFile, ref string tempTsdxPath, string databankVersion)
        {
            Databank deserializedDatabank;
            int nanCounter = 0;
            ReadInfo readInfo_oldbank = new ReadInfo();
            Databank_1_1 databank_1_1 = null;
            Utilities_1_1.ReadGbkOld_1_1(databank.name, databankVersion, oRead, readInfo_oldbank, ref file, ref databank_1_1, originalFilePath, ref tsdxFile, ref tempTsdxPath, ref nanCounter);
            if (databank_1_1.storage.Count == 0)
            {
                G.Writeln2("*** ERROR: Old databank in " + readInfo.databankVersion + " format has 0 variables");
                throw new GekkoException();
            }
            deserializedDatabank = new Databank(databank.name);

            readInfo.startPerInFile = readInfo_oldbank.startPerInFile;
            readInfo.endPerInFile = readInfo_oldbank.endPerInFile;
            readInfo.variables = readInfo_oldbank.variables;

            foreach (KeyValuePair<string, TimeSeries_1_1> kvp in databank_1_1.storage)
            {
                TimeSeries_1_1 ts1 = kvp.Value;
                string name = ts1.variableName;

                if (ts1.IsGhost()) continue;
                if (name.Contains(Globals.symbolTurtle))
                {
                    //array-timeseries
                    string[] ss = GetArrayTimeseriesName(name);
                    string[] ss2 = new string[ss.Length - 1];
                    for (int i = 1; i < ss.Length; i++)
                    {
                        ss2[i - 1] = ss[i];
                    }
                    //string ghostName = ss[0];


                    string ghostName = ss[0] + Globals.freqIndicator + G.GetFreq(ts1.freqEnum);
                    Series tsGhost = deserializedDatabank.GetIVariable(ghostName) as Series;
                    if (tsGhost == null)
                    {
                        tsGhost = new Series(ts1.freqEnum, ghostName);
                        tsGhost.meta.label = ts1.label;
                        tsGhost.SetArrayTimeseries(ss2.Length + 1, !ts1.IsTimeless());
                        deserializedDatabank.AddIVariableWithOverwrite(tsGhost);
                    }

                    Series tsSub = null;

                    if (ts1.IsTimeless())
                    {
                        tsSub = new Series(ESeriesType.Timeless, ts1.freqEnum, null);
                        tsSub.SetTimelessData(double.NaN);
                        if (ts1.dataArray != null && ts1.dataArray.Length > 0) tsSub.SetTimelessData(ts1.dataArray[0]);
                    }
                    else
                    {
                        tsSub = new Series(ESeriesType.Normal, ts1.freqEnum, null);
                        GekkoTime t1 = ts1.GetRealDataPeriodFirst();
                        GekkoTime t2 = ts1.GetRealDataPeriodLast();
                        foreach (GekkoTime t in new GekkoTimeIterator(t1, t2))
                        {
                            tsSub.SetData(t, ts1.GetData(t));  //could be sped up with arrays, but never mind
                        }
                    }

                    tsGhost.dimensionsStorage.AddIVariableWithOverwrite(new MapMultidimItem(ss2, tsGhost), tsSub);

                }
                else
                {
                    //normal timeseries

                    Series ts2 = null;

                    if (ts1.IsTimeless())
                    {
                        ts2 = new Series(ESeriesType.Timeless, ts1.freqEnum, name + Globals.freqIndicator + G.GetFreq(ts1.freqEnum));
                        ts2.SetTimelessData(double.NaN);
                        if (ts1.dataArray != null && ts1.dataArray.Length > 0) ts2.SetTimelessData(ts1.dataArray[0]);
                    }
                    else
                    {
                        ts2 = new Series(ESeriesType.Normal, ts1.freqEnum, name + Globals.freqIndicator + G.GetFreq(ts1.freqEnum));

                        GekkoTime t1 = ts1.GetRealDataPeriodFirst();
                        GekkoTime t2 = ts1.GetRealDataPeriodLast();
                        if (t1.super != -12345)
                        {
                            foreach (GekkoTime t in new GekkoTimeIterator(t1, t2))
                            {
                                ts2.SetData(t, ts1.GetData(t));  //could be sped up with arrays, but never mind
                            }
                        }
                    }
                    ts2.meta.label = ts1.label;
                    ts2.meta.stamp = ts1.stamp;
                    ts2.meta.source = ts1.source;                    

                    deserializedDatabank.AddIVariableWithOverwrite(ts2);
                }
            }

            return deserializedDatabank;
        }

        private static void MergeTwoTimeseriesWithDateWindowHelper(AllFreqsHelper dates, Databank databank, string name, Series tsProtobuf, bool wipeExistingOut)
        {
            if (wipeExistingOut)
            {
                //better to keep this outside of MergeTwoTimeseriesWithDateWindow()                                     
                tsProtobuf.Truncate(dates);
                databank.AddIVariableWithOverwrite(name, tsProtobuf);
            }
        }

        private static void MergeTwoTimeseriesWithDateWindowHelper(AllFreqsHelper dates, MapMultidim gmap, MapMultidimItem gmapItem, Series tsProtobuf, bool shouldOverwriteLaterOn)
        {
            if (shouldOverwriteLaterOn)
            {
                //better to keep this outside of MergeTwoTimeseriesWithDateWindow()                                     
                tsProtobuf.Truncate(dates);
                gmap.AddIVariableWithOverwrite(gmapItem, tsProtobuf);
            }
        }

        public static void MergeTwoTimeseriesWithDateWindow(AllFreqsHelper dates, Series tsExisting, Series tsSource, ref int maxYearInProtobufFile, ref int minYearInProtobufFile, ref bool shouldOverwriteLaterOn)
        {
            if (tsSource.type == ESeriesType.Timeless || (tsExisting != null && tsExisting.type == ESeriesType.Timeless))
            {
                //!!! BEWARE: remember to truncate and add it to container outside of this method
                //if either is timeless, just wipe existing out
                //handle it like non-series
                shouldOverwriteLaterOn = true;
            }
            else
            {
                //non-timeless

                if (tsExisting == null)
                {
                    //!!! BEWARE: remember to truncate and add it to container outside of this method
                    //Does not exist already: just put it in, but remember to truncate dates                    
                    shouldOverwriteLaterOn = true;
                }
                else
                {
                    //already exists: now we must merge the observations
                    //There are 3 time-windows in play: Work bank window, file window and dates window:
                    //  - Existing: the window of the existing timeseries (will not have any effect on the merging)
                    //  - Source: the window of the series from the deflated protobuf file
                    //  - Dates window: time-truncation of the file window
                    //So we find the overlap of the source window and the date window (if it is active at all)
                    //Then we put that overlap into the existing timeseries

                    //  --> useRealDataPeriodForSource = true
                    //       source       existing          dates (2002-6)    Result
                    //2001                 
                    //2002                    M              x                    M
                    //2003      M           100              x                  100
                    //2004      M           200              x                  200
                    //2005      1           300              x                    1
                    //2006      2           400              x                    2
                    //2007      3             M                                   M                 
                    //2008      M
                    //2009 
                    //2010 
                    //
                    // Here, firstSource is 2005, lastSource is 2007
                    // Common window will be 2005-2006        
                    // This funcionality is good for merging databanks

                    GekkoTime firstSource = GekkoTime.tNull;
                    GekkoTime lastSource = GekkoTime.tNull;

                    //takes a bit of time but not that much
                    firstSource = tsSource.GetRealDataPeriodFirst(); //takes a bit of time, but then we get the real period 
                    lastSource = tsSource.GetRealDataPeriodLast(); //takes a bit of time, but then we get the real period                                        

                    //only for printing out the period
                    maxYearInProtobufFile = G.GekkoMax(maxYearInProtobufFile, lastSource.super);
                    minYearInProtobufFile = G.GekkoMin(minYearInProtobufFile, firstSource.super);

                    if (firstSource.IsNull())
                    {
                        //no real data at all (lastSource will be null, too)
                        //do not write anything, no matter if dates = null or not.
                    }
                    else
                    {
                        //We have a data window in tsSource. Truncate the window with dates window (if it exists)
                        if (dates != null)
                        {
                            //this will adjust first and last to comply with the dates window
                            var tuple = GetFirstLastDates(dates, firstSource, lastSource);
                            GekkoTime firstTruncated = tuple.Item1;
                            GekkoTime lastTruncated = tuple.Item2;
                            //offset is not used

                            int nob = GekkoTime.Observations(firstTruncated, lastTruncated);
                            if (nob > 0)  //can be 0 or negative, if the windows do not overlap at all
                            {

                                int index1;
                                int index2;
                                try
                                {
                                    double[] data_beware_do_not_alter = tsSource.GetDataSequenceUnsafePointerReadOnlyBEWARE(out index1, out index2, firstTruncated, lastTruncated);  //should not optionally replace NaN with 0
                                    tsExisting.SetDataSequence(firstTruncated, lastTruncated, data_beware_do_not_alter, index1);
                                }
                                catch (Exception e)
                                {
                                    G.Writeln2("*** ERROR: Unexpected technical error while merging databanks");
                                    throw new GekkoException();
                                }
                            }
                            else
                            {
                                //does not get written, since there is no window overlap
                            }
                        }
                        else
                        {
                            //firstExisting is guaranteed to be != tNull, so lastExisting is so too
                            int index1;
                            int index2;
                            double[] data_beware_do_not_change = tsSource.GetDataSequenceUnsafePointerReadOnlyBEWARE(out index1, out index2, firstSource, lastSource);  //should not optionally replace NaN with 0
                            tsExisting.SetDataSequence(firstSource, lastSource, data_beware_do_not_change, index1);
                        }
                    }
                }
            }

        }

        private static Series GetTsExisting(Databank databank, string name)
        {
            IVariable ivExisting = databank.GetIVariable(name);
            Series tsExisting = null;
            if (ivExisting != null)
            {
                tsExisting = ivExisting as Series;
                if (tsExisting == null)
                {
                    //should not be possible since the name has no sigil
                    G.Writeln2("*** ERROR: Internal error #8974325235");
                    throw new GekkoException();
                }
            }

            return tsExisting;
        }

        private static void ReadTsd(ReadOpenMulbkHelper oRead, ReadInfo readInfo, ref string file, ref Databank databank, string originalFilePath, ref int NaNCounter)
        {
            bool isTsdx = false;
            //bool mergeOrTimeLimit = oRead.Merge || dates != null;
            readInfo.fileName = originalFilePath;
            //also deals with merging (not clearing the databank first if merging)
            ReadAllTsdRecords(file, oRead.Merge, isTsdx, databank, ref NaNCounter, readInfo);
            readInfo.nanCounter = NaNCounter;
            readInfo.startPerResultingBank = readInfo.startPerInFile;
            readInfo.endPerResultingBank = readInfo.endPerInFile;

        }

        public static Tuple<GekkoTime, GekkoTime, int> GetFirstLastDates(AllFreqsHelper dates, GekkoTime first, GekkoTime last)
        {
            //offset is the distance from first to dates.t1. If dates.t1 < first, offset will be 0.
            //So offset tells us when to start taking data in the array of the existing timeseries, as counted from the first date.
            //BEWARE: offset is the distance counted from the INPUT of first, not the OUTPUT of first
            //All in all, offset is a bit dangerous

            //If the dates window and the first/last window do not overlap, we will get a timeperiod returned
            //where first > last. This means that GekkoTime.Observations(first, last) will be <= 0. So test
            //that GekkoTime.Observations(first, last) > 0 before putting any data in.
            //

            GekkoTime firstRv = first;
            GekkoTime lastRv = last;

            int offset = 0;
            if (first.freq == EFreq.A)
            {
                if (dates.t1Annual.StrictlyLargerThan(first))
                {
                    offset = GekkoTime.Observations(first, dates.t1Annual) - 1;
                    firstRv = dates.t1Annual;
                }
                if (dates.t2Annual.StrictlySmallerThan(last))
                {
                    lastRv = dates.t2Annual;
                }
            }
            else if (first.freq == EFreq.Q)
            {
                if (dates.t1Quarterly.StrictlyLargerThan(first))
                {
                    offset = GekkoTime.Observations(first, dates.t1Quarterly) - 1;
                    firstRv = dates.t1Quarterly;
                }
                if (dates.t2Quarterly.StrictlySmallerThan(last))
                {
                    lastRv = dates.t2Quarterly;
                }
            }
            else if (first.freq == EFreq.M)
            {
                if (dates.t1Monthly.StrictlyLargerThan(first))
                {
                    offset = GekkoTime.Observations(first, dates.t1Monthly) - 1;
                    firstRv = dates.t1Monthly;
                }
                if (dates.t2Monthly.StrictlySmallerThan(last))
                {
                    lastRv = dates.t2Monthly;
                }
            }
            return new Tuple<GekkoTime, GekkoTime, int>(firstRv, lastRv, offset);
        }

        public static void ReadAllTsdRecords(string file, bool merge, bool isTsdx, Databank databank, ref int NaNCounter, ReadInfo readInfo)
        {
            int smallWarnings = 0;
            int emptyWarnings = 0;
            if (!merge)
            {
                databank.Clear();
            }

            if (Globals.threadIsInProcessOfAborting) throw new GekkoException();
            double[] tempArray = new double[100000]; //we don't expect series with more than 100000 obs.
            int counter = 0;
            using (FileStream fs = WaitForFileStream(file, GekkoFileReadOrWrite.Read))
            using (StreamReader sr = new StreamReader(fs))
            {
                //file should not contain æøå, so no need to use GetTextFromFileWithWait()

                string line = null;
                int nextState = 1;
                string varName = null;
                string frequency = null;
                EFreq freq = EFreq.A;

                DateTime t0 = DateTime.Now;
                DateTime t1 = DateTime.Now;
                DateTime t2 = DateTime.Now;
                int ii = 0;
                int d1min = int.MaxValue;
                int d2max = int.MinValue;
                int d1 = 0, d1sub = 0, d2 = 0, d2sub = 0; int d1subsub = 0; int d2subsub = 0;
                int countdata = 0;
                int obs = 0;
                int obsLeft = 0;
                //int datalines = 0;
                Series ts = null;

                int lineCounter = 0;

                while ((line = sr.ReadLine()) != null)
                {
                    lineCounter++;

                    try
                    {

                        line = line.Replace("\0", " ");
                        string lineTrim = line.Trim();
                        if (lineTrim == "") continue;

                        if (nextState == 1)
                        {
                            varName = lineTrim;
                            nextState = 2;
                        }

                        else if (nextState == 2)
                        {
                            //read expression
                            string expr = line.Substring(0, 32).Trim();

                            //read stamp
                            string stamp = line.Substring(32, 8).Trim();

                            //read date
                            int iiStart = 37;
                            string date1 = line.Substring(iiStart + 7, 4);
                            string date1sub = line.Substring(iiStart + 11, 2);
                            string date1subsub = line.Substring(iiStart + 13, 2);
                            string date2 = line.Substring(iiStart + 15, 4);
                            string date2sub = line.Substring(iiStart + 19, 2);
                            string date2subsub = line.Substring(iiStart + 21, 2);
                            frequency = line.Substring(iiStart + 23, 1).ToLower(); //a or q or m or d
                            try
                            {
                                d1 = int.Parse(date1);
                            }
                            catch
                            {
                                G.Writeln2("*** ERROR: " + varName + ": could not parse '" + date1 + "' as an int (start year)");
                                throw new GekkoException();
                            }
                            try
                            {
                                d1sub = int.Parse(date1sub);
                            }
                            catch
                            {
                                G.Writeln2("*** ERROR: " + varName + ": could not parse '" + date1sub + "' as an int (start sub-period)");
                                throw new GekkoException();
                            }
                            if (frequency == "d")
                            {
                                try
                                {
                                    d1subsub = int.Parse(date1subsub);
                                }
                                catch
                                {
                                    G.Writeln2("*** ERROR: " + varName + ": could not parse '" + date1subsub + "' as an int (start day)");
                                    throw new GekkoException();
                                }
                            }
                            try
                            {
                                d2 = int.Parse(date2);
                            }
                            catch
                            {
                                G.Writeln2("*** ERROR: " + varName + ": could not parse '" + date2 + "' as an int (end year)");
                                throw new GekkoException();
                            }
                            try
                            {
                                d2sub = int.Parse(date2sub);
                            }
                            catch
                            {
                                G.Writeln2("*** ERROR: " + varName + ": could not parse '" + date2sub + "' as an int (end sub-period)");
                                throw new GekkoException();
                            }
                            if (frequency == "d")
                            {
                                try
                                {
                                    d2subsub = int.Parse(date2subsub);
                                }
                                catch
                                {
                                    G.Writeln2("*** ERROR: " + varName + ": could not parse '" + date2subsub + "' as an int (end day)");
                                    throw new GekkoException();
                                }
                            }

                            d1min = G.GekkoMin(d1, d1min);  //finding min and max years
                            d2max = G.GekkoMax(d2, d2max);

                            //preparing nextState = 3
                            {

                                bool ok = G.IsSimpleToken(varName);
                                string label = null;
                                if (!ok)
                                {
                                    if (varName.Length >= 17)
                                    {
                                        //Of this type, where the first 16 chars is the name, and the rest is the label
                                        //gdp2            GDP in version 2, mia. DKK
                                        string v1 = varName.Substring(0, 16).Trim();
                                        string v2 = varName.Substring(16, varName.Length - 16).Trim();

                                        if (!G.IsSimpleToken(v1))
                                        {
                                            G.Writeln2("*** ERROR: tsd read: the following name is malformed:");
                                            G.Writeln("         : " + v1);
                                            G.Writeln("         : The name should contain letters, digits or underscore only");
                                            G.Writeln("         : (It seems there is a label starting in position 17, this is ok)");
                                            throw new GekkoException();
                                        }

                                        varName = v1;
                                        label = v2;
                                    }
                                    else
                                    {

                                        G.Writeln2("*** ERROR: tsd read: the following name is malformed:");
                                        G.Writeln("         : " + varName);
                                        G.Writeln("         : The name should contain letters, digits or underscore only");
                                        throw new GekkoException();
                                    }
                                }

                                countdata = 0;
                                freq = G.GetFreq(frequency);

                                obs = GekkoTime.Observations(new GekkoTime(freq, d1, d1sub, d1subsub), new GekkoTime(freq, d2, d2sub, d2subsub));

                                obsLeft = obs;
                                ts = null;
                                if (IsNonsenseVariableName(varName))
                                {
                                    emptyWarnings++;
                                    ts = new Series(freq, varName);  //completely phoney, will not live after exit of this method: just so that we can continue
                                }
                                else
                                {
                                    ts = FindOrCreateTimeSeriesInDataBank(databank, varName, freq);
                                }
                                if (label != null && label != "") ts.meta.label = label;
                                if (expr != null && expr != "") ts.meta.source = expr;                                
                                if (stamp != null && stamp != "") ts.meta.stamp = stamp;
                                //datalines = 0;
                                nextState = 3;
                            }

                        }
                        else if (nextState == 3)
                        {
                            int n = Math.Min(5, obsLeft);
                            for (int i5 = 0; i5 < n; i5++)
                            {
                                double ss = double.NaN;
                                bool success = false;
                                int width = 0;
                                if (isTsdx)
                                {
                                    width = 21;
                                }
                                else
                                {
                                    width = 15;
                                }
                                success = G.TryParseIntoDouble(line.Substring(ii + i5 * width, width), out ss);
                                if (!success)
                                {
                                    string toParse = line.Substring(ii + i5 * width, width).Trim();
                                    if (G.Equal(toParse, "NaN") || G.Equal(toParse, "-NaN"))
                                    {
                                        ss = 1e+15;  //signals missing value
                                        NaNCounter++;
                                    }
                                    else
                                    {
                                        G.Writeln2("*** ERROR: " + varName + ": could not parse '" + toParse + "' as a number");
                                        //sr.Close();
                                        throw new GekkoException();
                                    }
                                }

                                if (ss == 1e+15)
                                {
                                    ss = double.NaN;
                                }
                                else
                                {
                                    if (Math.Abs(ss) < 1e-37 && ss != 0d)
                                    {
                                        smallWarnings++;
                                        ss = 0d;  //numbers smaller than this become imprecise when imported from AREMOS
                                                  //AREMOS sets all numbers > 1e+15 to 1e+15 when exporting, so no need to do this for large numbers
                                    }
                                }
                                tempArray[countdata] = ss;
                                countdata++;
                                obsLeft--;
                            }

                            if (obsLeft == 0)
                            {
                                GekkoTime gt1 = new GekkoTime(freq, d1, d1sub, d1subsub);
                                GekkoTime gt2 = new GekkoTime(freq, d2, d2sub, d2subsub);

                                int offset = 0;

                                int nob = GekkoTime.Observations(gt1, gt2);
                                if (nob > 0)
                                {
                                    ts.SetDataSequence(gt1, gt2, tempArray, offset);
                                    ts.Trim(); //to save ram                                                             
                                }
                                counter++;
                                nextState = 1;
                            }
                        }
                    }
                    catch
                    {
                        G.Writeln("*** ERROR: TSD import failed on line: " + lineCounter);  //#0984252438
                        throw;
                    }
                }  //end of readline from file
                readInfo.startPerInFile = d1min;
                readInfo.endPerInFile = d2max;
                readInfo.variables = counter;
                if (emptyWarnings > 0) G.Writeln2("+++ WARNING: " + emptyWarnings + " variables with empty string as name in .tsd file (skipped)");
                if (smallWarnings > 0) G.Writeln2("+++ WARNING: " + smallWarnings + " numbers numerically smaller than 1.0e-37 were set to 0");

            }
        }

        public static void ReadFlat(Databank databank, ReadInfo readInfo, string fileLocal)
        {
            
            // x1 2001 2004 10 m -20 30.0

            int emptyWarnings = 0;
            int firstYearWarnings = 0;

            DateTime dt1 = DateTime.Now;

            int variableCounter = 0;

            
            char[] c = new char[] { ' ' };
            double[] tempArray = new double[10000];

            int n = 0;

            int year1 = int.MaxValue;
            int year2 = int.MinValue;

            //Is all code without æøå, so no need to use GetTextFromFile() to handle ANSI
            using (FileStream fs = WaitForFileStream(fileLocal, GekkoFileReadOrWrite.Read))
            using (StreamReader sr = new StreamReader(fs))
            {
                while (sr.Peek() >= 0)
                {
                    string line = sr.ReadLine().Trim();
                    n++;
                    if (line == "" || line.StartsWith("//")) continue;
                    string[] linesplit = line.Split(c, StringSplitOptions.RemoveEmptyEntries);
                    string varname = linesplit[0];
                    if (linesplit.Length < 3)
                    {
                        G.Writeln2("*** ERROR: IMPORT<flat>: Expected two dates for series '" + varname + "' (line " + n + ")");
                        throw new GekkoException();
                    }

                    string per1 = linesplit[1];
                    GekkoTime gt1 = GekkoTime.FromStringToGekkoTime(per1, true);
                    year1 = Math.Min(year1, gt1.super);

                    string per2 = linesplit[2];
                    GekkoTime gt2 = GekkoTime.FromStringToGekkoTime(per2, true);
                    year2 = Math.Max(year2, gt2.super);

                    if (gt1.freq != gt2.freq)
                    {
                        G.Writeln2("*** ERROR: IMPORT<flat>: Dates for series '" + varname + "' have different frequencies (line " + n + ")");
                        throw new GekkoException();
                    }

                    int obs = GekkoTime.Observations(gt1, gt2);
                    int obs2 = linesplit.Length - 3;

                    if (obs < 1)
                    {
                        G.Writeln2("*** ERROR: IMPORT<flat>: Invalid time period for series '" + varname + "' (line " + n + ")");
                        throw new GekkoException();
                    }

                    if (obs > 10000)
                    {
                        G.Writeln2("*** ERROR: IMPORT<flat>: More then 10000 periods for series '" + varname + "' (line " + n + ")");
                        throw new GekkoException();
                    }

                    if (obs2 == 0)
                    {
                        G.Writeln2("*** ERROR: IMPORT<flat>: Expected > 0 observations for series '" + varname + "' (line " + n + ")");
                        throw new GekkoException();
                    }

                    if (obs != obs2 && obs2 > 1)  //for obs2 = 1, any timeperiod is ok.
                    {
                        G.Writeln2("*** ERROR: IMPORT<flat>: Expected " + obs + " observations for for series '" + varname + "', got " + obs2 + " (line " + n + ")");
                        throw new GekkoException();
                    }

                    Series ts = FindOrCreateTimeSeriesInDataBank(databank, varname, gt1.freq);

                    for (int i = 3; i < linesplit.Length; i++)
                    {
                        int ii = i - 3;  //starts with 0
                        string s = linesplit[i];

                        double ss = double.NaN;

                        if (G.Equal(s, "m") || G.Equal(s, "m()"))
                        {
                            //do nothing, it is a missing value.
                        }
                        else
                        {
                            try
                            {
                                ss = G.ParseIntoDouble(s, true);
                            }
                            catch
                            {
                                G.Writeln2("*** ERROR: Could not understand '" + s + "' as a number for series '" + varname + "' (line " + n + ")");
                                throw new GekkoException();
                            }
                        }

                        tempArray[ii] = ss;
                    }

                    if (obs2 == 1)
                    {
                        for (int i = 1; i < obs; i++)
                        {
                            tempArray[i] = tempArray[0];  //copy the first value to the rest
                        }
                    }

                    ts.SetDataSequence(gt1, gt2, tempArray);
                    ts.Trim();  //to save RAM
                }
            }

            readInfo.startPerInFile = year1;
            readInfo.endPerInFile = year2;
            readInfo.nanCounter = 0;
            //readInfo.databankVersion = "(vers: PCIM " + ver + ")";

            readInfo.variables = n;  //does not count emptyWarnings
            readInfo.time = (DateTime.Now - dt1).TotalMilliseconds;
            
            readInfo.startPerResultingBank = readInfo.startPerInFile;
            readInfo.endPerResultingBank = readInfo.endPerInFile;
            

        }

        public static void ReadAremos(Databank databank, ReadInfo readInfo, string fileLocal)
        {

            // AREMOS dump format


            /*
            
            The following is an AREMOS procedure to dump all banks listed (here: abase, arsbased, ...)
            
            -------------------------------------------------------------------
            procedure dump1 list m;                    !navne uden .bnk extension
              set report columns 35 decimals 20;
              set databank limit 25000;                !hold øje med at der ikke er nogen 'Search truncated by limit'
              for i = #m;
                close *; clear;
                open #i;
                dump * #i|.dmp;
                close *; clear;
              end;
            end;

            list banker = abase, arsbased, dbase, dbasemd, justbyt, KADAM, kadamaar, kadamk, kadamkaar, knrsup, matis, matisk, t5, testdump;
            dump1 #banker; 
            -------------------------------------------------------------------

            In Gekko:

            -------------------------------------------------------------------
            reset;

            global:#i = abase, arsbased, dbase, dbasemd, justbyt, KADAM, kadamaar, kadamk, kadamkaar, matis, matisk, t5;

            time 1900 2500;
            for string %i = #i;
              clear work;
              import<aremos>{%i}.dmp;
              write {%i};
            end;
            -------------------------------------------------------------------

            The format looks like this from AREMOS:
             
             SERIES<ANNUAL
             90 120 > X.A
              =              1.00000000000000000000, ...
                             1.00000000000000000000;

             SERIES<QUARTERLY
             90Q1 120Q4 > X.Q
              =              4.00000000000000000000, ...
                             4.00000000000000000000;

             SERIES<MONTHLY
             90M1 120M12 > X.M
              =             12.00000000000000000000, ...
                            12.00000000000000000000;

             MATRIX M1.NULL  =
                [              1.00000000000000000000,
                               2.00000000000000000000 ] ||
                [              3.00000000000000000000,
                               4.00000000000000000000 ];
             
             LIST M2.NULL
              = A,B,C
             ;

             * 
             * 
             * */

            int emptyWarnings = 0;
            int firstYearWarnings = 0;

            int matrixError = 0;

            DateTime dt1 = DateTime.Now;

            int variableCounter = 0;


            char[] c = new char[] { ' ' };
            double[] tempArray = new double[10000];

            int n = 0;

            int year1 = int.MaxValue;
            int year2 = int.MinValue;

            string txt = Program.GetTextFromFileWithWait(fileLocal);
            TokenList tokens = StringTokenizer2.GetTokensWithLeftBlanksSkipNewlines(txt, 10, null, null, null, null);
                         
            int nSeries = 0;
            int nList = 0;

            for (int i = 0; i < tokens.storage.Count; i++)
            {

                if (G.Equal(tokens[i].s, "matrix"))
                {
                    matrixError++;
                }
                else if (G.Equal(tokens[i].s, "series"))
                {
                    nSeries++;

                    if (tokens[i + 1].s != "<")
                    {
                        G.Writeln2("*** ERROR: Expected '<', " + tokens[i + 1].LineAndPosText());
                        throw new GekkoException();
                    }

                    string freq2 = tokens[i + 2].s;
                    EFreq freq = EFreq.A;
                    if (G.Equal(freq2, "annual")) freq = EFreq.A;
                    else if (G.Equal(freq2, "quarterly")) freq = EFreq.Q;
                    else if (G.Equal(freq2, "monthly")) freq = EFreq.M;
                    else
                    {
                        G.Writeln2("*** ERROR: Expected 'ANNUAL', 'QUARTERLY' or 'MONTHLY', " + tokens[i + 2].LineAndPosText());
                        throw new GekkoException();
                    }

                    GekkoTime gt1 = GekkoTime.tNull;
                    GekkoTime gt2 = GekkoTime.tNull;
                    int offset = 0;
                    if (tokens[i + 4].leftblanks == 0 && tokens[i + 6].leftblanks == 0)
                    {
                        offset = 2;
                        string t1 = tokens[i + 3].s + tokens[i + 4].s;
                        gt1 = GekkoTime.FromStringToGekkoTime(t1);
                        string t2 = tokens[i + 5].s + tokens[i + 6].s;
                        gt2 = GekkoTime.FromStringToGekkoTime(t2);
                    }
                    else
                    {
                        string t1 = tokens[i + 3].s;
                        gt1 = GekkoTime.FromStringToGekkoTime(t1);
                        string t2 = tokens[i + 4].s;
                        gt2 = GekkoTime.FromStringToGekkoTime(t2);
                    }

                    year1 = Math.Min(year1, gt1.super);
                    year2 = Math.Max(year2, gt2.super);

                    if (tokens[i + 5 + offset].s != ">")
                    {
                        G.Writeln2("*** ERROR: Expected '>', " + tokens[i + 5 + offset].LineAndPosText());
                        throw new GekkoException();
                    }

                    string name1 = tokens[i + 6 + offset].s;
                    
                    if (tokens[i + 7 + offset].s != ".")
                    {
                        G.Writeln2("*** ERROR: Expected '.', " + tokens[i + 7 + offset].LineAndPosText());
                        throw new GekkoException();
                    }
                    string name2 = tokens[i + 8 + offset].s;

                    string name = name1;
                    if (!G.Equal(name2, "null"))
                    {
                        if (!G.Equal(name2, G.GetFreq(freq)))
                        {
                            //for instance quarterly x.sol (not x.q)
                            G.Writeln2("+++ WARNING: Changed " + name1 + "." + name2 + " into " + name1 + "_" + name2 + "!" + G.GetFreq(freq));
                            name += "_" + name2;
                        }
                    }
                    name = name + Globals.freqIndicator + G.GetFreq(freq);
                    Series ts = new Series(freq, name);
                    if (databank.ContainsIVariable(name))
                    {
                        G.Writeln2("*** ERROR: Dublet series name ('" + name + "')");
                        throw new GekkoException();
                    }
                    databank.AddIVariable(name, ts);

                    if (tokens[i + 9 + offset].type == ETokenType.QuotedString)
                    {
                        ts.meta.label = G.StripQuotes(tokens[i + 9 + offset].s);
                        offset++;                        
                    }

                    if (tokens[i + 9 + offset].type == ETokenType.QuotedString)
                    {
                        ts.meta.source = G.StripQuotes(tokens[i + 9 + offset].s);
                        offset++;
                    }

                    if (tokens[i + 9 + offset].s != "=")
                    {
                        G.Writeln2("*** ERROR: Expected '=', " + tokens[i + 9 + offset].LineAndPosText());
                        throw new GekkoException();
                    }

                    int counter = -1;

                    int state = 0;
                    for (int j = i + 10 + offset; j < tokens.storage.Count; j++)
                    {
                        if (state == 0)
                        {
                            bool minus = false;
                            if (G.Equal(tokens[j].s, "-"))
                            {
                                minus = true;
                                j++;
                            }

                            double d = double.NaN;
                            if (G.Equal(tokens[j].s, "m"))
                            {
                                //do nothing, it is a missing value.
                                counter++;
                                ts.SetData(gt1.Add(counter), d);
                            }
                            else
                            {
                                try
                                {
                                    d = G.ParseIntoDouble(tokens[j].s);
                                    counter++;
                                    if (minus) d = -d;
                                    ts.SetData(gt1.Add(counter), d);
                                }
                                catch
                                {
                                    G.Writeln2("*** ERROR: Could not understand '" + tokens[j].s + "' as a number, " + tokens[j].LineAndPosText());
                                    throw new GekkoException();
                                }
                            }
                            state = 1;
                        }
                        else
                        {
                            if (tokens[j].s == ";")
                            {
                                i = j;
                                break;
                            }
                            else if (tokens[j].s != ",")
                            {
                                G.Writeln2("*** ERROR: Expected ',', " + tokens[j].LineAndPosText());
                                throw new GekkoException();
                            }
                            state = 0;
                        }
                    }
                }
                else if (G.Equal(tokens[i].s, "list"))
                {                    
                    nList++;

                    int offset = 0;

                    string name1 = tokens[i + 1 + offset].s;
                    if (tokens[i + 2 + offset].s != ".")
                    {
                        G.Writeln2("*** ERROR: Expected '.', " + tokens[i + 2 + offset].LineAndPosText());
                        throw new GekkoException();
                    }
                    string name2 = tokens[i + 3 + offset].s;

                    string name = name1;
                    if (!G.Equal(name2, "null"))
                    {
                        G.Writeln2("*** ERROR: Expected '.', " + tokens[i + 7 + offset].LineAndPosText());
                    }
                    name = Globals.symbolCollection + name;

                    List lst = new List();
                    
                    if (databank.ContainsIVariable(name))
                    {
                        G.Writeln2("*** ERROR: Dublet list name ('" + name + "')");
                        throw new GekkoException();
                    }
                    databank.AddIVariable(name, lst);

                    if (tokens[i + 4 + offset].s != "=")
                    {
                        G.Writeln2("*** ERROR: Expected '=', " + tokens[i + 4 + offset].LineAndPosText());
                        throw new GekkoException();
                    }

                    int counter = -1;

                    int state = 0;
                    for (int j = i + 5 + offset; j < tokens.storage.Count; j++)
                    {
                        if (state == 0)
                        {
                            counter++;
                            lst.list.Add(new ScalarString(tokens[j].s));
                            state = 1;
                        }
                        else
                        {
                            if (tokens[j].s == ";")
                            {
                                i = j;
                                break;
                            }
                            else if (tokens[j].s != ",")
                            {
                                G.Writeln2("*** ERROR: Expected ',', " + tokens[j].LineAndPosText());
                                throw new GekkoException();
                            }
                            state = 0;
                        }
                    }
                }
            }

            G.Writeln();
            if (nSeries > 0) G.Writeln(nSeries + " series imported");
            if (nList > 0) G.Writeln(nList + " lists imported");

            if (matrixError > 0)
            {
                G.Writeln("+++ NOTE: Matrix not yet implemented (" + matrixError + " statements ignored)");
            }

            n = nSeries + nList;
            
            readInfo.startPerInFile = year1;
            readInfo.endPerInFile = year2;
            readInfo.nanCounter = 0;

            readInfo.variables = n;  //does not count emptyWarnings
            readInfo.time = (DateTime.Now - dt1).TotalMilliseconds;

            readInfo.startPerResultingBank = readInfo.startPerInFile;
            readInfo.endPerResultingBank = readInfo.endPerInFile;

        }

        public static void ReadPxHelper(Databank databank, ReadOpenMulbkHelper oRead, ReadInfo readInfo, string fileLocal)
        {
            //merge and date truncation:
            //do this by first reading into a Gekko databank, and then merge that with the merge facilities from gbk read

            DateTime dt1 = DateTime.Now;
                        
            string pxLinesText = Program.GetTextFromFileWithWait(fileLocal);  //also removes some kinds of funny characters

            int vars = -12345;
            GekkoTime startYear;
            GekkoTime endYear;            
            ReadPx(databank, oRead.array, false, null, null, null, pxLinesText, out vars, out startYear, out endYear);

            readInfo.startPerInFile = startYear.super;
            readInfo.endPerInFile = endYear.super;
            readInfo.variables = vars;
            readInfo.time = (DateTime.Now - dt1).TotalMilliseconds;
            
            readInfo.startPerResultingBank = readInfo.startPerInFile;
            readInfo.endPerResultingBank = readInfo.endPerInFile;            

            return;

        }

        public static void ReadPCIM(Databank databank, ReadInfo readInfo, string fileLocal)
        {

            //try
            {
                //Databank databank = readInfo.databank;

                int emptyWarnings = 0;
                int firstYearWarnings = 0;

                DateTime dt1 = DateTime.Now;
                int variableCounter = 0;                

                //Is all code without æøå, so no need to use GetTextFromFile() to handle ANSI
                using (FileStream fs = WaitForFileStream(fileLocal, GekkoFileReadOrWrite.Read))
                using (BinaryReader binreader = new BinaryReader(fs))
                {
                    float ver = binreader.ReadSingle();
                    G.WritelnGray("Version: " + ver);
                    Int16 fmaxa = binreader.ReadInt16();  //number of variables+1
                    Int16 ffil = binreader.ReadInt16();
                    char[] fmodel = new char[12];
                    fmodel = binreader.ReadChars(12);
                    string model = new string(fmodel);
                    Int16 fsmpl1 = binreader.ReadInt16();
                    Int16 fsmpl2 = binreader.ReadInt16();
                    Int16 fant = binreader.ReadInt16();
                    Int16 fmsta = binreader.ReadInt16();
                    Int16 fcre = binreader.ReadInt16();
                    Int16 fmaxl = binreader.ReadInt16();
                    char[] fhdg = new char[80];
                    fhdg = binreader.ReadChars(80);
                    string sfhdg = new string(fhdg);
                    char[] fdato = new char[8];
                    fdato = binreader.ReadChars(8);
                    string sfdato = new string(fdato);
                    char[] ftid = new char[5];
                    ftid = binreader.ReadChars(5);
                    string sftid = new string(ftid);
                    readInfo.info1 = sfhdg.Trim();
                    string date = sfdato + " " + sftid;
                    string date2 = sfdato;
                    date2 = date2.Replace(" ", "");
                    string[] date3 = date2.Split('/');
                    if (date3.Length == 3)
                    {
                        string d0 = date3[0].Trim();
                        string d1 = date3[1].Trim();
                        string d2 = date3[2].Trim();
                        string date4 = date3[2];
                        int date5 = 0;
                        if (int.TryParse(date4, out date5))
                        {
                            if (date5 <= 20)
                            {
                                int date6 = date5 + 2000;
                                //date += " (the '" + date5 + "' probably means " + date6 + ")";
                                d2 = date6.ToString();
                            }
                            else if (date5 >= 70 && date5 <= 99)
                            {
                                int date6 = date5 + 1900;
                                //date += " (the '" + date5 + "' probably means " + date6 + ")";
                                d2 = date6.ToString();
                            }
                        }
                        date = d0 + "-" + d1 + "-" + d2 + " " + sftid;
                    }

                    readInfo.date = date.Trim();
                    readInfo.pcim = model.Trim();
                    Int16[] fid = new Int16[ffil];   //year
                    for (int i = 0; i < ffil; i++)
                    {
                        fid[i] = binreader.ReadInt16();
                    }

                    int varnamelength = 16;
                    if (Math.Abs(ver - 3.1d) < 0.00001) varnamelength = 8;

                    binreader.BaseStream.Position = 0;
                    binreader.BaseStream.Position = fmaxa * 4;
                    string[] navne = new string[fmaxa];  //variable names
                    char[] temp = new char[varnamelength];
                    for (int i = 0; i < fmaxa; i++)
                    {
                        temp = binreader.ReadChars(varnamelength);
                        navne[i] = new string(temp);
                        if (navne[i].Trim() == "")
                        {
                            G.Writeln();
                        }
                    }
                    int antalper = fsmpl2 - fsmpl1 + 1;  //antal perioder

                    float[,] gigant = new float[fmaxa, antalper + 1];  //per 0 is empty
                    for (int per = 0; per < antalper + 1; per++)
                    {
                        for (int var = 0; var < fmaxa; var++)
                        {
                            float val = binreader.ReadSingle();  //it seems that for per=0, all val er always 0. Maybe something to do with Fortran arrays starting at index 1??
                            gigant[var, per] = val;
                            if (per == 0 && val != 0)
                            {
                                firstYearWarnings++; //for almost all banks this is never so, but some banks may contain a number in this slot. This number will be ignored, but the issue will be reported.
                            }
                        }
                    }

                    binreader.Close();

                    //turning the loop around, so we can use tempArray speedup
                    double[] tempArray = new double[10000]; //we don't expect series with more than 10000 obs.
                    int year1 = fid[0];
                    int year2 = year1 + antalper - 1;

                    if (fid[antalper - 1] != year1 + antalper - 1)
                    {
                        G.Writeln2("*** ERROR: Strange error while reading PCIM databank file");
                        throw new GekkoException();
                    }

                    for (int var = 0; var < fmaxa - 1; var++)  //There are really only fmaxa-1 variables, the last one in navne[] is fake
                    {
                        string varName = navne[var];
                        varName = varName.Trim();

                        if (IsNonsenseVariableName(varName))  //empty or "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
                        {
                            emptyWarnings++; //probably some artefact creeping in???
                            continue;
                        }

                        Series ts = FindOrCreateTimeSeriesInDataBank(databank, varName, EFreq.A);

                        if (true)
                        {
                            //faster
                            for (int per = 0; per < antalper; per++)
                            {
                                short year = fid[per];
                                float ss = gigant[var, per + 1];  //<==== because gigant[] is 1-based, not 0-based
                                tempArray[per] = ss;
                            }
                            GekkoTime gt1 = new GekkoTime(EFreq.A, year1, 1);
                            GekkoTime gt2 = new GekkoTime(EFreq.A, year2, 1);
                            ts.SetDataSequence(gt1, gt2, tempArray);
                            ts.Trim();  //to save RAM
                            variableCounter++;
                            //G.Writeln(varName + " var# " + var);
                        }
                        
                    }

                    readInfo.startPerInFile = year1;
                    readInfo.endPerInFile = year2;
                    readInfo.nanCounter = 0;
                    readInfo.databankVersion = "(vers: PCIM " + ver + ")";

                    readInfo.variables = variableCounter;  //does not count emptyWarnings
                    readInfo.time = (DateTime.Now - dt1).TotalMilliseconds;
                    
                    readInfo.startPerResultingBank = readInfo.startPerInFile;
                    readInfo.endPerResultingBank = readInfo.endPerInFile;
                    

                    if (firstYearWarnings > 0) G.Writeln("+++ WARNING: " + firstYearWarnings + " variables had data before databank time period (data skipped)");

                    //readInfo.databank.info1 = readInfo.info1;
                    //readInfo.databank.date = readInfo.date;
                    //readInfo.databank.FileNameWithPath = readInfo.fileName;

                    return;
                }
            }
        }


        public static void ReadPx(Databank databank, string array, bool isDownload, string source, string tableName, List<string> codesHeaderJson, string pxLinesText, out int vars, out GekkoTime perStart, out GekkoTime perEnd)
        {            
            bool isArray = false; if (G.Equal(array, "yes")) isArray = true;

            bool hyphenFound = false;
            bool underscoreFound = false;

            string freq = "a";

            List<string> dates = new List<string>();

            List<string> lines2 = G.ExtractLinesFromText(pxLinesText);
            pxLinesText = null;  //clearing it

            List<string> codesHeader = new List<string>();
            List<List<string>> codes = new List<List<string>>();
            List<List<string>> values = new List<List<string>>();

            //int counter = 0;
            string codeTimeString = "CODES(\"tid\")=";
            string codeTimeString2 = "CODES(\"time\")=";
            string codeString = "CODES(";            
            string valueString = "VALUES(";
            string matrixString = "MATRIX=";

            List<string> codesCombi = null;
            List<string> valuesCombi = null;
            int state = 0;  //DATA=1, CODES("tid")=2, CODES(...)=3, VALUES(...)=4
            StringBuilder lineHelper = new StringBuilder();
            double[] data = null;
            int ii = 0;
            int jj = 0;

            List<int> fractions = new List<int>();
            List<double> fractions2 = new List<double>();
            for (double dd = 0.1; dd <= 1.0; dd = dd + 0.1)
            {
                fractions.Add((int)(dd * (double)lines2.Count));
                fractions2.Add(dd);
            }

            int lineCounter = 0;

            G.Writeln2("Starting to read " + lines2.Count + " data lines from data file");

            GekkoTime gt0 = GekkoTime.tNull;
            GekkoTime gt1 = GekkoTime.tNull;

            long allCounter = 0;
            long allCounter2 = 0;

            foreach (string line2 in lines2)
            {
                lineCounter++;
                if (lines2.Count >= 10000)
                {
                    for (int i = 0; i < fractions.Count; i++)
                    {
                        if (fractions[i] == lineCounter)
                        {
                            G.Writeln("    Progress: " + (int)(Math.Round(100 * fractions2[i])) + "% of " + lines2.Count + " data lines");
                        }
                    }
                }

                string line = line2.Trim();
                bool semi = false;
                bool firstLine = false;

                if (line.StartsWith("DATA=", StringComparison.OrdinalIgnoreCase))
                {
                    lineHelper = null; //not used 
                    state = 1;
                    firstLine = true;
                    line = line.Substring("DATA=".Length);
                    line = line.Trim();  //may have blank after =
                }
                else if (line.StartsWith(codeTimeString, StringComparison.OrdinalIgnoreCase) || line.StartsWith(codeTimeString2, StringComparison.OrdinalIgnoreCase))
                {
                    lineHelper = new StringBuilder();
                    firstLine = true;
                    state = 2;
                }
                else if (line.StartsWith(codeString, StringComparison.OrdinalIgnoreCase))
                {
                    lineHelper = new StringBuilder();
                    firstLine = true;
                    state = 3;
                }
                else if (line.StartsWith(valueString, StringComparison.OrdinalIgnoreCase))
                {
                    lineHelper = new StringBuilder();
                    firstLine = true;
                    state = 4;
                }
                else if (line.StartsWith(matrixString, StringComparison.OrdinalIgnoreCase))
                {
                    if (tableName == null)
                    {
                        tableName = line.Substring(matrixString.Length).Replace("\"", "").Replace(";", "").Trim();
                    }
                }
                else
                {
                    firstLine = false;
                }

                if (line.EndsWith(";"))
                {
                    line = line.Substring(0, line.Length - 1);
                    semi = true;
                }

                if (state == 1)
                {
                    //special treatment
                }
                else
                {
                    lineHelper.Append(line);
                    if (!semi) continue;
                }

                if (state == 1)
                {
                    //state=1                            

                    if (firstLine)
                    {
                        codesCombi = new List<string>();
                        valuesCombi = new List<string>();

                        List<string> codesHeader2 = codesHeaderJson;
                        if (codesHeader2 == null)
                        {
                            codesHeader2 = codesHeader;
                            codesHeader2.Add("TID");  //will be removed again below!
                        }

                        //we are using codesHeaderJson instead of codesHeader (these are more verbose)
                        Walk(isArray, tableName, codesHeader2, codes, codesCombi, values, valuesCombi, 0, "", "", ref hyphenFound, ref underscoreFound);
                        data = G.CreateArrayDouble(codesCombi.Count * dates.Count, double.NaN);  //fill it with NaN for safety. Statistikbanken sometimes return only a subset of the data (and the subset is zeroes)
                    }

                    string s = line;

                    int sstate = 1;
                    int lastStart = 0;
                    //int counter = 0;
                    for (int i5 = 0; i5 < s.Length; i5++)
                    {
                        
                        char c = s[i5];
                        if ((c == ' ' || i5 == s.Length - 1) && sstate == 1)
                        {
                            int add = 0;
                            if (i5 == s.Length - 1)
                            {
                                add = 1;
                            }
                            string temp2 = s.Substring(lastStart, i5 - lastStart + add).Trim();
                            //counter++;
                            allCounter2++;
                            
                            double value = double.NaN;

                            if (temp2 == "")
                            {
                                continue;  //if there are more than 1 blank
                            }

                            if (temp2 == "\".\"" || temp2 == "\"..\"" || temp2 == "\"...\"" || temp2 == "\"....\"" || temp2 == "\":\"")
                            {
                                //See http://www.inside-r.org/packages/cran/pxr/docs/read.px
                                //do nothing, "." and ".." and "..." and "...." and ":" will be missing value (these include the quotes in the Axis file)
                            }
                            else
                            {

                                try
                                {
                                    value = G.ParseIntoDouble(temp2);
                                }
                                catch
                                {
                                    G.Writeln2("*** ERROR: Could not convert '" + temp2 + "' into a number");
                                    throw new GekkoException();
                                }
                            }
                            if (ii + jj * dates.Count >= data.Length)
                            {
                                G.Writeln2("*** ERROR: More than " + data.Length + " numbers found in data section");
                                throw new GekkoException();
                            }
                            data[ii + jj * dates.Count] = value;  //i is date, j is variable
                            ii++;
                            if (ii > dates.Count - 1)
                            {
                                ii = 0;
                                jj++;
                            }
                        }

                        if (c != ' ' && sstate == 2)
                        {
                            lastStart = i5;
                        }

                        if (c == ' ')
                        {
                            sstate = 2;  //blanks
                        }
                        else
                        {
                            sstate = 1;  //nonblanks
                        }

                    }
                }
                else if (state == 2)
                {
                    string s = lineHelper.ToString();
                    if (s.StartsWith(codeTimeString, StringComparison.OrdinalIgnoreCase)) s = s.Substring(codeTimeString.Length);
                    else if (s.StartsWith(codeTimeString2, StringComparison.OrdinalIgnoreCase)) s = s.Substring(codeTimeString2.Length);

                    string[] ss = null;
                    if (Globals.fixPxProblem)
                    {
                        ss = G.SplitCsv(s).ToArray();
                    }
                    else
                    {
                        ss = s.Split(new char[] { ',' }, StringSplitOptions.RemoveEmptyEntries);
                    }

                    foreach (string s2 in ss)
                    {
                        string s3 = s2;

                        if (Globals.fixPxProblem)
                        {
                            s3 = s3.Trim();
                        }
                        else
                        {
                            s3 = s2.Substring(1, s2.Length - 2);
                        }

                        if (s3.IndexOf("m", StringComparison.OrdinalIgnoreCase) != -1)
                        {
                            freq = "m";
                        }
                        if (s3.IndexOf("k", StringComparison.OrdinalIgnoreCase) != -1)
                        {
                            freq = "q";
                        }
                        if (s3.IndexOf("q", StringComparison.OrdinalIgnoreCase) != -1)
                        {
                            freq = "q";
                        }
                        dates.Add(s3);
                    }
                }
                else if (state == 3)
                {
                    //state=3
                    //For instance:
                    //
                    //  CODES("ydelse, k?n og alder")="TOT","NET","LDP","LKT","AKI","ADP","AKT","MEN","KVR","U25","O25","O30","O40","O50","O60";
                    //  CODES("s?sonkorrigering og faktiske tal")="10";
                    //
                    string line777 = lineHelper.ToString();
                    int i = line777.IndexOf("=");
                    if (i < 0)
                    {
                        G.Writeln2("*** ERROR: Expected a '=' in this line: " + line777);
                        throw new GekkoException();
                    }

                    string s3 = line777.Substring(0, i); s3 = s3.Substring(7); s3 = s3.Substring(0, s3.Length - 2);
                    codesHeader.Add(s3);

                    string s = line777.Substring(i + 1);
                    //if (s.EndsWith(";")) s = s.Substring(0, s.Length - 1);
                    
                    string[] ss = null;
                    if (Globals.fixPxProblem)
                    {
                        ss = G.SplitCsv(s).ToArray();
                    }
                    else
                    {
                        ss = s.Split(new char[] { ',' }, StringSplitOptions.RemoveEmptyEntries);
                    }


                    List<string> names2 = new List<string>();
                    foreach (string s2 in ss)
                    {
                        string s4 = s2;
                        if (Globals.fixPxProblem)
                        {
                            s4 = s4.Trim();
                        }
                        else
                        {
                            s4 = s2.Substring(1, s2.Length - 2);
                        }

                        names2.Add(s4);
                    }
                    if (names2.Count == 0)
                    {
                        G.Writeln2("*** ERROR: Expected 1 or more items in this line: " + line);
                        throw new GekkoException();
                    }
                    codes.Add(names2);
                }
                else if (state == 4)
                {
                    //state=4
                    string line5 = lineHelper.ToString();
                    int i = line5.IndexOf("=");
                    if (i < 0)
                    {
                        G.Writeln2("*** ERROR: Expected a '=' in this line: " + line5);
                        throw new GekkoException();
                    }
                    string s = line5.Substring(i + 1);
                    //if (s.EndsWith(";")) s = s.Substring(0, s.Length - 1);

                    string[] ss = null;
                    if (Globals.fixPxProblem)
                    {
                        ss = G.SplitCsv(s).ToArray();
                    }
                    else
                    {
                        ss = s.Split(new char[] { ',' }, StringSplitOptions.RemoveEmptyEntries);
                    }

                    List<string> values2 = new List<string>();
                    foreach (string s2 in ss)
                    {
                        string s5 = s2;
                        if (Globals.fixPxProblem)
                        {
                            s5 = s5.Trim();
                        }
                        else
                        {
                            s5 = s2.Substring(1, s2.Length - 2);
                        }

                        values2.Add(s5);
                    }
                    if (values2.Count == 0)
                    {
                        G.Writeln2("*** ERROR: Expected 1 or more items in this line: " + line5);
                        throw new GekkoException();
                    }
                    values.Add(values2);
                }

                if (semi) state = 0;  //resetting

            }  //for each line

            if (dates.Count == 0)
            {
                G.Writeln2("*** ERROR: No time dimension found in px file");
                throw new GekkoException();
            }

            G.Writeln("    All data read, now putting into series");

            if (isArray)
            {
                // ------------------------------ array-series ---------------------------------------

                int dimensionsWithoutTime = codes.Count;

                //put in the array-timeseries ghost
                string varNameWithFreq = G.Chop_AddFreq(tableName, freq);
                Series tsGhost = new Series(G.GetFreq(freq), varNameWithFreq);
                tsGhost.SetArrayTimeseries(dimensionsWithoutTime + 1, true);
                //Databank databank = Program.databanks.GetFirst();
                databank.AddIVariableWithOverwrite(tsGhost.name, tsGhost);
                tsGhost.SetDirty(true);

                for (int j = 0; j < codesCombi.Count; j++)
                {
                    Series ts = null;
                    
                    ts = new Series(ESeriesType.Normal, G.GetFreq(freq), Globals.seriesArraySubName + Globals.freqIndicator + freq);

                    ts.meta.label = valuesCombi[j];
                    ts.meta.source = source;
                    ts.meta.stamp = Globals.dateStamp;                    
                    ts.SetDirty(true);

                    GekkoTime gt_start = GekkoTime.FromStringToGekkoTime(dates[0], true);
                    GekkoTime gt_end = GekkoTime.FromStringToGekkoTime(dates[dates.Count - 1], true);

                    if (gt_start.freq != gt_end.freq)
                    {
                        G.Writeln2("*** ERROR: Frequency mismatch problem in px file");
                        throw new GekkoException();
                    }

                    if (GekkoTime.Observations(gt_start, gt_end) != dates.Count)
                    {
                        //Guards against holes in the date sequence
                        //Note that gt_start and gt_end may be changed with datesRestrict below
                        G.Writeln2("*** ERROR: Expected " + dates.Count + " obs between " + dates[0] + " and " + dates[dates.Count - 1]);
                        throw new GekkoException();
                    }

                    int offset = 0;

                    int obs = GekkoTime.Observations(gt_start, gt_end);

                    ts.SetDataSequence(gt_start, gt_end, data, j * dates.Count + offset);  //the last is the offset
                    ts.Trim();  //to save ram
                    allCounter += obs;
                    if (gt0.IsNull()) gt0 = gt_start;
                    if (gt1.IsNull()) gt1 = gt_end;
                    if (gt_start.StrictlySmallerThan(gt0)) gt0 = gt_start;
                    if (gt_end.StrictlyLargerThan(gt1)) gt1 = gt_end;

                    string[] split = codesCombi[j].Split(new char[] { Globals.pxInternalDelimiter }, StringSplitOptions.RemoveEmptyEntries);
                    string[] split2 = new string[(split.Length - 1) / 2];
                    for (int i = 0; i < split2.Length; i++)
                    {
                        split2[i] = split[2 * i + 2];
                    }

                    tsGhost.dimensionsStorage.AddIVariableWithOverwrite(new MapMultidimItem(split2, tsGhost), ts);
                }
            }

            else
            {

                // ------------------------------ normal series ---------------------------------------

                for (int j = 0; j < codesCombi.Count; j++)
                {

                    Series ts = null;

                    if (true)
                    {
                        string name2 = codesCombi[j].Replace(Globals.pxInternalDelimiter, '_');
                        string name3 = G.Chop_AddFreq(name2, freq);
                        ts = new Series(G.GetFreq(freq), name3);
                        ts.meta.label = valuesCombi[j];
                        ts.meta.source = source;
                        ts.meta.stamp = Globals.dateStamp;
                        ts.SetDirty(true);
                    }

                    if (true)  //can be switched off
                    {

                        GekkoTime gt_start = GekkoTime.FromStringToGekkoTime(dates[0], true);
                        GekkoTime gt_end = GekkoTime.FromStringToGekkoTime(dates[dates.Count - 1], true);

                        if (gt_start.freq != gt_end.freq)
                        {
                            G.Writeln2("*** ERROR: Frequency mismatch problem in px file");
                            throw new GekkoException();
                        }

                        if (GekkoTime.Observations(gt_start, gt_end) != dates.Count)
                        {
                            //Guards against holes in the date sequence
                            //Note that gt_start and gt_end may be changed with datesRestrict below
                            G.Writeln2("*** ERROR: Expected " + dates.Count + " obs between " + dates[0] + " and " + dates[dates.Count - 1]);
                            throw new GekkoException();
                        }
                        
                        int offset = 0;
                        
                        int obs = GekkoTime.Observations(gt_start, gt_end);

                        ts.SetDataSequence(gt_start, gt_end, data, j * dates.Count + offset);  //the last is the offset
                        ts.Trim();  //to save ram
                        allCounter += obs;
                        if (gt0.IsNull()) gt0 = gt_start;
                        if (gt1.IsNull()) gt1 = gt_end;
                        if (gt_start.StrictlySmallerThan(gt0)) gt0 = gt_start;
                        if (gt_end.StrictlyLargerThan(gt1)) gt1 = gt_end;
                    }

                    //put in the timeseries
                    string varNameWithFreq = G.Chop_AddFreq(tableName, freq);
                    //Databank databank = Program.databanks.GetFirst();
                    databank.AddIVariableWithOverwrite(ts.name, ts);
                    ts.SetDirty(true);

                }
            }

            string downloadOrImport = "Read";
            if (isDownload) downloadOrImport = "Downloaded";

            G.Writeln("--> " + downloadOrImport + " " + codesCombi.Count + " timeseries in total, frequency " + freq + ", " + G.FromDateToString(gt0) + "-" + G.FromDateToString(gt1));

            if (isArray)
            {
                G.Writeln("    First timeseries in px file: " + G.PrettifyTimeseriesHash(GetArrayName(tableName, codesCombi[0]), true, false));
                G.Writeln("    Last timeseries in px file: " + G.PrettifyTimeseriesHash(GetArrayName(tableName, codesCombi[codesCombi.Count - 1]), true, false));
            }
            else
            {
                G.Writeln("    First timeseries in px file: " + codesCombi[0].Replace(Globals.pxInternalDelimiter, '_'));
                G.Writeln("    Last timeseries in px file: " + codesCombi[codesCombi.Count - 1].Replace(Globals.pxInternalDelimiter, '_'));
            }

            //return values
            vars = codesCombi.Count;
            perStart = gt0;
            perEnd = gt1;

            if (data.LongLength != allCounter2)
            {
                //See not in constrution of data array
                G.Writeln2("+++ WARNING: " + downloadOrImport + " " + allCounter2 + " numbers, expected " + data.LongLength);
                G.Writeln("+++ WARNING: Please review the resulting timeseries carefully!");
                if (Globals.runningOnTTComputer || G.IsUnitTesting()) throw new GekkoException();
            }            

            if (hyphenFound)
            {
                //Only for !isArray
                G.Writeln2("+++ WARNING: Hyphens ('-') in names have been removed");
            }

            if (underscoreFound)
            {
                //Only for !isArray
                G.Writeln2("+++ WARNING: Underscores ('_') in names have been removed");
            }
            
        }        

        private static string GetArrayName(string tableName, string codesCombi)
        {
            string name3 = null;
            string name2 = codesCombi;
            string[] ss = name2.Split(Globals.pxInternalDelimiter);
            List<string> dims = new List<string>();
            for (int i = 2; i < ss.Length; i += 2)
            {
                //kind of hacky, make it more robust later on
                dims.Add(ss[i]);
            }
            foreach (string s in dims)
            {
                name3 += Globals.symbolTurtle + s;
            }
            name3 = tableName + name3;
            return name3;
        }

        private static void Walk(bool isArray, string table, List<string> codesHeader, List<List<string>> codes, List<string> codesCombi, List<List<string>> values, List<string> valuesCombi, int depth, string sCodes, string sValues, ref bool hyphenFound, ref bool underscoreFound)
        {
            //Hmmm what if a table name or column has a name with '_' inside? Probably not probable.
            if (depth > codes.Count - 1)
            {
                if (sCodes.EndsWith(Globals.pxInternalDelimiter.ToString())) sCodes = sCodes.Substring(0, sCodes.Length - 1);
                if (sValues.StartsWith(", ")) sValues = sValues.Substring(2);

                string name2 = null;

                string temp = table + sCodes;
                StringBuilder sb = new StringBuilder();
                for (int i = 0; i < temp.Length; i++)
                {
                    char tempi = temp[i];
                    if (!isArray) //accept funny strings for arrays
                    {
                        if (tempi == '-')
                        {
                            hyphenFound = true;
                        }
                        else if (tempi == '_')
                        {
                            underscoreFound = true;
                        }
                    }

                    if (tempi == 'æ') sb.Append("ae");
                    else if (tempi == 'ø') sb.Append("oe");
                    else if (tempi == 'å') sb.Append("aa");
                    else if (tempi == 'Æ') sb.Append("AE");
                    else if (tempi == 'Ø') sb.Append("OE");
                    else if (tempi == 'Å') sb.Append("AA");
                    else if (!isArray && !(G.IsLetterOrDigit(tempi) || tempi == Globals.pxInternalDelimiter))  //for non-arrays, only letter or digit is allowed, everything else is thrown out
                    {
                        //ignore it
                    }
                    else
                    {
                        sb.Append(tempi);  //here we know that it is englishletter or digit or underscore
                    }
                }
                name2 = sb.ToString();

                codesCombi.Add(name2);
                valuesCombi.Add(sValues);
                return;
            }

            for (int i = 0; i < codes[depth].Count; i++)
            {
                string sCodesTemp = sCodes + Globals.pxInternalDelimiter + codesHeader[depth] + Globals.pxInternalDelimiter + codes[depth][i];
                string sValuesTemp = sValues + ", " + values[depth][i];
                Walk(isArray, table, codesHeader, codes, codesCombi, values, valuesCombi, depth + 1, sCodesTemp, sValuesTemp, ref hyphenFound, ref underscoreFound);
            }
        }
        
        
        public static string NumberFormat(double d, string format2)
        {
            return NumberFormat(d, format2, null);
        }

        public static string NumberFormat(double d, string format2, string culture)
        {
            string format = null;
            if (format2.Contains(":"))
            {
                format = "{0," + format2 + "}";  //0, is just that it is the first element in a list of numbers
            }
            else
            {
                format = "{0,0:" + format2 + "}";  //0,0: first element, with 0 blanks padding
            }
            string x = null;
            try
            {
                if (culture == null) x = String.Format(format, d);
                else
                {
                    CultureInfo ci = CultureInfo.CreateSpecificCulture(culture);  //for instance "da-DK", "en-US", "fr-FR", etc.
                    x = String.Format(ci, format, d);
                }
            }
            catch (Exception e)
            {
                G.Writeln2("*** ERROR: format() function failed. The internal error message is this:");
                G.Writeln("           " + e.Message);
                throw new GekkoException();
            }
            return x;
        }

        public static string StringFormat(string s, string format2)
        {
            string format = null;            
            format = "{0," + format2 + "}";  //0, is just that it is the first element in a list of numbers
            string x = null;
            try
            {
                x = String.Format(format, s);
            }
            catch (Exception e)
            {
                G.Writeln2("*** ERROR: format() function failed. The internal error message is this:");
                G.Writeln("           " + e.Message);
                throw new GekkoException();
            }
            return x;
        }

        public static bool IsNonsenseVariableName(string varName)
        {
            bool nonsense = false;
            if (varName == "" || varName == "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")
            {
                nonsense = true;
            }
            return nonsense;
        }


        private static void WriteTsdRecord(GekkoTime per1, GekkoTime per2, StreamWriter res, Series ts, string name, bool isCaps, bool isTsdx)
        {
            int index1 = -12345;
            int index2 = -12345;
            //TODO: can return null
            //TODO: and it might be called half overlapped like this:
            //            +++++++++++++++++++++++
            //      ---------------
            double[] dataArray = null;
            if (per1.IsNull() && per2.IsNull())
            {
                index1 = ts.meta.firstPeriodPositionInArray;
                index2 = ts.meta.lastPeriodPositionInArray;
                dataArray = ts.GetDataSequenceUnsafePointerReadOnlyBEWARE();
                per1 = ts.GetPeriodFirst();
                per2 = ts.GetPeriodLast();
            }
            else
            {
                //also sets index1 and index2.
                dataArray = ts.GetDataSequenceBEWARE(out index1, out index2, per1, per2);  //a little bit slack not to use a pointer
            }

            int count2 = 0;
            string s = "";
            double oldValue = double.NaN;
            bool firstTime = true;
            string varName = ts.name;
            if (isCaps) varName = varName.ToUpper();  //for use with AREMOS


            //========================================================================================================
            //                          FREQUENCY LOCATION, indicates where to implement more frequencies
            //========================================================================================================

            string sub1 = "";
            string sub2 = "";
            string freq = "A";
            if (ts.freq == EFreq.A)
            {
                sub1 = "0101";
                sub2 = "0101";
            }
            else if (ts.freq == EFreq.Q || ts.freq == EFreq.M)
            {
                freq = G.GetFreq(ts.freq).ToUpper();
                sub1 = per1.sub.ToString("D2") + "01";
                sub2 = per2.sub.ToString("D2") + "01";
            }
            else if (ts.freq == EFreq.D)
            {
                freq = G.GetFreq(ts.freq).ToUpper();
                sub1 = per1.sub.ToString("D2") + per1.subsub.ToString("D2");
                sub2 = per2.sub.ToString("D2") + per2.subsub.ToString("D2");
            }
            else throw new GekkoException();

            string varName2 = G.Chop_RemoveFreq(varName);
            if (varName.Length <= 16 && ts.meta.label != null && ts.meta.label.Length > 0)
            {
                res.WriteLine(varName2 + G.Blanks(16 - varName2.Length) + ts.meta.label);
            }
            else
            {
                //do not write label if name > 16 chars
                res.WriteLine(varName2);
            }

            string stmp = "01/01/00";
            if (ts.meta.stamp != null && ts.meta.stamp.Length == 10)
            {
                try
                {
                    int i = int.Parse(ts.meta.stamp.Substring(6, 4));
                    if (i >= 2000) i = i - 2000;
                    else i = i - 1900;
                    string temp = ts.meta.stamp.Substring(3, 2) + "/" + ts.meta.stamp.Substring(0, 2) + "/" + i;
                    if (temp.Length == 8) stmp = temp;
                }
                catch
                {
                }
            }

            string src = ts.meta.source;
            if (src == null) src = "";
            if (src.Length > 16) src = src.Substring(0, 16);
            else src = src + G.Blanks(16 - src.Length);

            string nul = "  0";
            if (ts.freq == EFreq.D)
            {
                //necessary for AREMOS, otherwise the program crashes completely!
                nul = "  0         1111111";  //weekdays sun, mon, tue, wed, thu, fri, sat --> are active
            }

            res.WriteLine("                " + src + stmp + "0000" + per1.super + sub1 + per2.super + sub2 + freq + nul); //time is set to 0000

            for (int index = index1; index <= index2; index++)
            {
                count2++;
                double value = double.NaN;
                {
                    value = dataArray[index];
                }

                if (double.IsNaN(value))
                {
                    value = 1.0e+15;
                }

                if (Math.Abs(value) <= 1.0e-99d)
                {
                    //otherwise we will get exponents with 3 characters,
                    //and PCIM does not like that
                    value = 0;
                }
                if (Math.Abs(value) >= 1.0e+99d)
                {
                    //otherwise we will get exponents with 3 characters,
                    //and PCIM does not like that
                    //Too large a number
                    //Missing does not have a sign
                    value = 1.0e+15d;
                }

                if (firstTime || (!firstTime && value != oldValue)) //This trick makes it run about 25% faster
                {
                    if (isTsdx)
                    {
                        s = string.Format(System.Globalization.CultureInfo.InvariantCulture, "{0:0.00000000000000E+00}", value);
                    }
                    else
                    {
                        s = string.Format(System.Globalization.CultureInfo.InvariantCulture, "{0:0.00000000E+00}", value);
                    }
                }

                firstTime = false;
                oldValue = value;

                if (value < 0)
                {

                    res.Write(s);

                }
                else
                {
                    res.Write(" " + s);
                }
                if (count2 % 5 == 0 && index != index2) res.WriteLine();  //new line for each 5 numbers written
            }
            res.WriteLine();
        }

        private static void WriteFlatRecord(GekkoTime per1, GekkoTime per2, StreamWriter res, Series ts, string name, StringBuilder sb)
        {
            sb.Clear();
            sb.Append(name).Append(" ").Append(per1.ToString()).Append(" ").Append(per2.ToString()).Append(" ");            
            foreach (GekkoTime t in new GekkoTimeIterator(per1, per2))
            {
                double d = ts.GetDataSimple(t);
                string s = d.ToString();
                if (G.isNumericalError(d)) s = "m";
                sb.Append(s).Append(" ");
            }
            res.WriteLine(sb);
        }

        private static void WriteTspRecord(GekkoTime per1, GekkoTime per2, StreamWriter res, Series ts, string name, bool isCaps)
        {
            int index1 = -12345;
            int index2 = -12345;
            //TODO: can return null
            //TODO: and it might be called half overlapped like this:
            //            +++++++++++++++++++++++
            //      ---------------
            double[] dataArray = null;
            if (per1.IsNull() && per2.IsNull())
            {
                index1 = ts.meta.firstPeriodPositionInArray;
                index2 = ts.meta.lastPeriodPositionInArray;
                dataArray = ts.GetDataSequenceUnsafePointerReadOnlyBEWARE();
                per1 = ts.GetPeriodFirst();
                per2 = ts.GetPeriodLast();
            }
            else
            {
                //also sets index1 and index2.
                dataArray = ts.GetDataSequenceBEWARE(out index1, out index2, per1, per2);  //a little bit slack not to use a pointer
            }

            int count2 = 0;
            string s = "";
            string varName = G.Chop_GetName(name); // ts.name;
            if (isCaps) varName = varName.ToUpper();

            if (ts.freq == EFreq.A)
            {
                G.Writeln2("*** ERROR: WRITE <tsp> only implemented for annual data");
                throw new GekkoException();
            }

            res.WriteLine("smpl " + per1.super + " " + per2.super + ";");
            res.WriteLine("load " + varName + ";");

            for (int index = index1; index <= index2; index++)
            {
                count2++;
                double value = double.NaN;
                {
                    value = dataArray[index];
                }
                if (double.IsNaN(value))
                {
                    res.WriteLine(".");
                }
                else
                {
                    res.WriteLine(value);
                }
            }
            res.WriteLine(";");
            res.WriteLine();
        }

        public static void WriteTsdRecord2(int yr1, int yr2, StreamWriter res, int varNumber, double[] data, String var2)
        {
            //TODO: quarters
            if (Program.options.freq != EFreq.A)
            {
                G.Writeln2("*** ERROR: Tsp to tsd conversion only works on annual data");
                throw new GekkoException();
            }
            res.WriteLine(var2);
            //res.WriteLine("                                 1/ 1/ 10800" + (yr1 + 0) + "0100" + (yr2 + 0) + "0100A  0");
            res.WriteLine("                                11/22/ 72014" + (yr1 + 0) + "0101" + (yr2 + 0) + "0101A2 0         0000000");

            int count2 = 0;
            for (int t = yr1; t <= yr2; t++)
            {
                count2++;
                double value = double.NaN;
                if (varNumber == -12345 && data != null)
                {
                    value = data[t];
                }
                else
                {
                    G.Writeln2("*** ERROR internal error 9329329");
                    //value = a[varNumber, t];
                }

                if (double.IsNaN(value))
                {
                    value = 1.0e+15;
                }

                if (Math.Abs(value) <= 1.0e-99d)
                {
                    //otherwise we will get exponents with 3 characters,
                    //and PCIM does not like that
                    value = 0;
                }
                if (Math.Abs(value) >= 1.0e+99d)
                {
                    //otherwise we will get exponents with 3 characters,
                    //and PCIM does not like that
                    //Too large a number
                    //Missing does not have a sign
                    value = 1.0e+15d;
                }

                String valueExp = string.Format(System.Globalization.CultureInfo.InvariantCulture, "{0:0.000000E+00}", value);

                if (value < 0)
                {
                    res.Write("  " + valueExp);
                }
                else
                {
                    res.Write("   " + valueExp);
                }
                if (count2 % 5 == 0) res.WriteLine();  //new line for each 5 numbers written
            }
            if (count2 % 5 != 0) res.WriteLine();

        }


        public static int key = 129;

        public static string EncryptDecrypt(string textToEncrypt)
        {
            StringBuilder inSb = new StringBuilder(textToEncrypt);
            StringBuilder outSb = new StringBuilder(textToEncrypt.Length);
            char c;
            for (int i = 0; i < textToEncrypt.Length; i++)
            {
                c = inSb[i];
                if (i > 17)
                {
                    c = (char)(c ^ key);
                }
                outSb.Append(c);
            }
            StringBuilder outSb1 = new StringBuilder(outSb.ToString());
            for (int i = 0; i < Math.Abs(outSb.Length / 2d); i++)
            {
                if (i % 3 == 0 && i > 17)
                {
                    outSb1[i] = outSb[outSb.Length - i - 1];
                    outSb1[outSb.Length - i - 1] = outSb[i];
                }
            }
            return outSb1.ToString();
        }

        public static void DeleteTemporaryCsFilesFromLastTime()
        {
            //delete temporary .cs files from last time
            string path = Globals.localTempFilesLocation;
            if (Directory.Exists(path))
            {
                string[] fileList = Directory.GetFiles(path, "*.cs");
                foreach (string file in fileList)
                {
                    FileInfo imgInfo = new FileInfo(file);
                    imgInfo.Delete();
                }
            }
        }

        public static EquationHelper FindEquationByMeansOfVariableName(string lhsName)
        {
            
            int r = -12345;
            if (Program.model?.modelGekko?.fromVariableToEquationNumber != null && Program.model.modelGekko.fromVariableToEquationNumber.TryGetValue(lhsName + Globals.lagIndicator + "0", out r))
            {
                //r will get a value
            }
            else
            {
                return null;
            }

            int number = r;
            EquationHelper found = Program.model.modelGekko.equations[number];  //should alway find something
            return found;
        }

        public static void EndogenizeExogenizeStuff(bool isFix)
        {
            Program.model.modelGekko.m2.endogenous.Clear();
            foreach (string var in Program.model.modelGekko.endogenousOriginallyInModel.Keys)
            {
                Program.model.modelGekko.m2.endogenous.Add(var, "");
            }

            Program.model.modelGekko.m2.endoSubstitution.Clear();
            Program.model.modelGekko.m2.endoSubstitutionBNumbers.Clear();

            if (isFix)  //we skip this for normal SIM, just as if the ENDO/EXO lists were empty even if they are not
            {
                //TODO: Maybe model.endogenized and model.exogenized should be List<string> to begin with,
                //      to preserve order. Might be better for simulation.
                //      BUT then we would have to re-thing caching, where order is scrambled anyway. Probably
                //      preserving order is not noticable anyway, especially when using direct inverter (LU).
                List<string> endogeni = new List<string>();
                List<string> exogeni = new List<string>();
                IEnumerator e1 = null;
                IEnumerator e2 = null;
                e1 = Program.model.modelGekko.endogenized.GetEnumerator();
                e2 = Program.model.modelGekko.exogenized.GetEnumerator();
                while (e1.MoveNext())
                {
                    e2.MoveNext();
                    //string s1 = (string)(((DictionaryEntry)e1.Current).Key);
                    string s1 = ((KeyValuePair<string, string>)e1.Current).Key;
                    string s2 = ((KeyValuePair<string, string>)e2.Current).Key;
                    endogeni.Add(s1);
                    exogeni.Add(s2);
                }
                //This sorting is so that we get the same order no matter which order (and case) the means/goals were set
                //This is probably more safe regarding cacheing of the results. Not sorting might give hard to track errors.
                endogeni.Sort(StringComparer.OrdinalIgnoreCase);
                exogeni.Sort(StringComparer.OrdinalIgnoreCase);

                //endogenous/exogenous are altered due to endogenized/exogenized
                for (int i = 0; i < endogeni.Count; i++)
                {
                    string s1 = endogeni[i];
                    string s2 = exogeni[i];
                    //BTypeData ss1 = (BTypeData)Program.model.modelGekko.varsBType[s1 + Globals.lagIndicator + "0"];
                    BTypeData ss1 = null; Program.model.modelGekko.varsBType.TryGetValue(s1 + Globals.lagIndicator + "0", out ss1);
                    if (ss1 == null)
                    {
                        //TODO: general error handling regarding endo/exo
                        //now we get runtime error
                        G.Writeln2("*** ERROR: regarding endogenize: variable " + s1 + " does not exist in model");
                        throw new GekkoException();
                    }
                    int s1BNumber = ss1.bNumber;
                    //int varNumber = ss1.bNumber;
                    if (Program.model.modelGekko.m2.endogenous.ContainsKey(s1))
                    {
                        G.Writeln2("*** ERROR: regarding endogenize: variable " + s1 + " is already endogenous");
                        throw new GekkoException();
                    }
                    else
                    {
                        Program.model.modelGekko.m2.endogenous.Add(s1, "");
                        //Program.model.modelGekko.endogenousBNumbers.Add(s1BNumber, "");  DO NOT ACTIVATE THIS ONE -- endogenousBNumbers are dealt with in the ordering code
                        //BTypeData ss2 = (BTypeData)Program.model.modelGekko.varsBType[s2 + Globals.lagIndicator + "0"];
                        BTypeData ss2 = null; Program.model.modelGekko.varsBType.TryGetValue(s2 + Globals.lagIndicator + "0", out ss2);
                        if (ss2 == null)
                        {
                            //TODO: general error handling regarding endo/exo
                            //now we get runtime error
                            G.Writeln2("*** ERROR: regarding exogenize: variable " + s2 + " does not exist in model");
                            throw new GekkoException();
                        }
                        int s2BNumber = ss2.bNumber;

                        if (Program.model.modelGekko.m2.endogenous.ContainsKey(s2))
                        {
                            Program.model.modelGekko.m2.endogenous.Remove(s2);
                            //Program.model.modelGekko.endogenousBNumbers.Remove(s2BNumber);  //DO NOT ACTIVATE THIS ONE -- endogenousBNumbers are dealt with in the ordering code
                            Program.model.modelGekko.m2.endoSubstitution.Add(s2, s1);
                            Program.model.modelGekko.m2.endoSubstitutionBNumbers.Add(s2BNumber, s1BNumber);
                        }
                        else
                        {
                            G.Writeln2("*** ERROR: regarding exogenize: variable " + s2 + " is not endogenous");
                            throw new GekkoException();
                        }
                    }
                }
            }

            // ---------------------- endogenous with b-number -- end ------------------------

            Program.model.modelGekko.m2.fromEqNumberToBNumber = G.CreateArray(Program.model.modelGekko.m2.endogenous.Count, -12345);  //used in newton
            Program.model.modelGekko.m2.fromBNumberToEqNumber = G.CreateArray(1000000, -12345);  //slack, fix, used in newton
            Program.model.modelGekko.m2.sparseInfo = new List<int>[Program.model.modelGekko.m2.endogenous.Count]; //used in newton
            Program.model.modelGekko.m2.sparseInfoLeftRightSeparated = new List<int>[Program.model.modelGekko.m2.endogenous.Count]; //used for ordering

            foreach (EquationHelper eh in Program.model.modelGekko.equations)
            {
                int varNumber = eh.bNumberLhs;
                List<int> arl = new List<int>();
                List<int> arl2 = new List<int>();
                Program.model.modelGekko.m2.sparseInfo[eh.equationNumber] = arl;
                Program.model.modelGekko.m2.sparseInfoLeftRightSeparated[eh.equationNumber] = arl2;

                int x = -12345;
                if (Program.model.modelGekko.m2.endoSubstitutionBNumbers.TryGetValue(varNumber, out x))
                {
                    varNumber = x;
                }

                Program.model.modelGekko.m2.fromEqNumberToBNumber[eh.equationNumber] = varNumber;
                Program.model.modelGekko.m2.fromBNumberToEqNumber[varNumber] = eh.equationNumber;

                //-------------------------

                List<int> temp = new List<int>();
                //Hmmm, using Contains() on a List<> could waste time instead of Dictionary, but these lists are probably short anyway
                if (!Program.model.modelGekko.m2.sparseInfo[eh.equationNumber].Contains(varNumber))
                {
                    //to avoid duplicates
                    Program.model.modelGekko.m2.sparseInfo[eh.equationNumber].Add(varNumber);
                }
                foreach (string s in eh.precedentsWithLagIndicator.Keys)
                {
                    BTypeData temp3 = (BTypeData)Program.model.modelGekko.varsBType[s];
                    int rhsVarNumber = temp3.bNumber;
                    if (Program.model.modelGekko.endogenousBNumbersOriginallyInModel.ContainsKey(rhsVarNumber))
                    {
                        if (!Program.model.modelGekko.m2.sparseInfo[eh.equationNumber].Contains(rhsVarNumber))
                        {
                            //to avoid duplicates
                            Program.model.modelGekko.m2.sparseInfo[eh.equationNumber].Add(rhsVarNumber);
                        }
                        //if (!first && !((ArrayList)sparseInfoLeftRightSeparated[eqNumber]).Contains(varNumber1))
                        if (!temp.Contains(rhsVarNumber))
                        {
                            //to avoid duplicates
                            temp.Add(rhsVarNumber);
                        }
                    }
                }
                Program.model.modelGekko.m2.sparseInfoLeftRightSeparated[eh.equationNumber].Add(varNumber);
                Program.model.modelGekko.m2.sparseInfoLeftRightSeparated[eh.equationNumber].AddRange(temp);
            }
        }

        public static void FeedbackOrderingStuff(ECompiledModelType modelType, bool isCalledFromModelStatement)
        {

            //int xx;
            //xx = fromEqNumberToBNumber.Length; //(a)
            //xx = fromBNumberToEqNumber.Length; //(a1)

            //xx = fromEqNumberToBNumberRecursiveNEW.Count;  //(b)
            //xx = fromBNumberToEqNumberRecursiveNEW.Length; //(b1)

            //xx = fromEqNumberToBNumberFeedbackNEW.Length;  //(c)
            //xx = fromBNumberToEqNumberFeedbackNEW.Length;  //(c1)


            //frml _i i1=0.5*g;
            //frml _i i=i1;
            //frml _i y=c+i+g+e-m;                          //frml _i g=g+y-(c+i+g+e-m);
            //frml _i c=0.2*y+0.1*c+0.1*e;
            //frml _i e=-0.2*m+0.2*c-0.1*y *y;
            //frml _i m=m2;
            //frml _i m2=m3;
            //frml _i m3=m4;
            //frml _i m4=m5;
            //frml _i m5=m6;
            //frml _i m6=m7;
            //frml _i m7=m8;
            //frml _i m8=0.1*c     ;
            //frml _i x=2*y;
            //frml _i z=2*x;


            //   (a)   (b)    (c)
            //-------------------------
            //0   0    13     3
            //1   2    12     4
            //2   3    11
            //3   4    10
            //4   5    9
            //5   6    8
            //6   7    7
            //7   8    6
            //8   9    5
            //9   10
            //10  11
            //11  12
            //12  13
            //13  14
            //14  15


            //   (a1)  (b2)  (c2)       <m> = -12345
            //------------------------------------------
            //0   0    <m>   <m>        prologue
            //1  <m>   <m>   <m>        exo
            //2   1    <m>   <m>        prologue
            //3   2    <m>    1
            //4   3    <m>    0
            //5   4     8    <m>
            //6   5     7    <m>
            //7   6     6    <m>
            //8   7     5    <m>
            //9   8     4    <m>
            //10  9     3    <m>
            //11  10    2    <m>
            //12  11    1    <m>
            //13  12    0    <m>
            //14  13   <m>   <m>        epilogue
            //15  14   <m>   <m>        epilogue


            // sparseInfoLeftRightSeparated
            //
            //    before                after endo/exo of g and e.
            //------------------------------------------------
            //0     0                 0     0,1                   ++  added 1
            //1     2,0               1     2,0
            //2     3,4,2,5,6         2     3,4,2,1,6             ++  1 instead of 5
            //3     4,3,4,5           3     4,3,4                 ++  removed 5
            //4     5,6,4,3           4     1,1,6,4,3             ++  1's instead of 5
            //5     6,7               5     6,7
            //6     7,8               6     7,8
            //7     8,9               7     8,9
            //8     9,10              8     9,10
            //9     10,11             9     10,11
            //10    11,12             10    11,12
            //11    12,13             11    12,13
            //12    13,4              12    13,4
            //13    14,3              13    14,3
            //14    15,14             14    15,14

            //endogenized exo variable "g" (1):
            //add the number at rhs in equations where it is found at rhs
            //exogenized endo variable "e" (5):
            //remove where it is found at   rhs
            //at eq where it is at lhs: put in endogenized instead at lhs AND at rhs

            DateTime t0 = DateTime.Now;

            foreach (string endo in Program.model.modelGekko.m2.endoSubstitution.Keys)
            {
                //slack: iterate KeyValuePair<> instead
                string exo = Program.model.modelGekko.m2.endoSubstitution[endo];
                int exoBtype = Program.model.modelGekko.varsBType[exo + Globals.lagIndicator + "0"].bNumber;
                int endoBtype = Program.model.modelGekko.varsBType[endo + Globals.lagIndicator + "0"].bNumber;
                ArrayList eqsRhsExo = FindEqsWithVarOnRightHandSide(exo);
                ArrayList eqsRhsEndo = FindEqsWithVarOnRightHandSide(endo);
                int eqLhsEndo = FindEqWithVarOnLeftHandSide(endo);
                //for each equation with exo var on rhs
                foreach (int eq in eqsRhsExo)
                {
                    //EquationHelper eh = (EquationHelper)equations[eq];
                    //eh.rhs.Add(exoBtype, "");
                    List<int> al = Program.model.modelGekko.m2.sparseInfoLeftRightSeparated[eq];
                    for (int i = 1; i < al.Count; i++)
                    {
                        int number = al[i];
                        if (number == exoBtype) G.Writeln2("*** ERROR #32108743");
                    }
                    al.Add(exoBtype);
                }

                foreach (int eq in eqsRhsEndo)
                {
                    List<int> al = Program.model.modelGekko.m2.sparseInfoLeftRightSeparated[eq];
                    int toRemoveI = -12345;
                    for (int i = 1; i < al.Count; i++)
                    {
                        int number = al[i];
                        if (number == endoBtype)
                        {
                            toRemoveI = i;
                        }
                    }
                    al.RemoveAt(toRemoveI);
                }
                List<int> al1 = Program.model.modelGekko.m2.sparseInfoLeftRightSeparated[eqLhsEndo];
                al1[0] = exoBtype;
                al1.Add(exoBtype);
                //G.Writeln(exo + " " + endo + " " + eqsRhsEndo.ToString() + " " + eqsRhsExo.ToString() + eqLhsEndo);
            }

            Program.model.modelGekko.m2.sparseInfoSmart = new List<List<int>>();
            Program.model.modelGekko.m2.sparseInfoSmartCondensed = new List<List<int>>();  //creates an identical copy here
            for (int i = 0; i < Program.model.modelGekko.varsBType.Count; i++)
            {
                Program.model.modelGekko.m2.sparseInfoSmart.Add(null);
                Program.model.modelGekko.m2.sparseInfoSmartCondensed.Add(null);
            }
            for (int i = 0; i < Program.model.modelGekko.m2.sparseInfoLeftRightSeparated.Length; i++)
            {
                bool first = true;
                List<int> vars = Program.model.modelGekko.m2.sparseInfoLeftRightSeparated[i];
                foreach (int var in vars)
                {
                    if (first == true)
                    {
                        //first index is left side
                        Program.model.modelGekko.m2.sparseInfoSmart[vars[0]] = new List<int>();
                        Program.model.modelGekko.m2.sparseInfoSmartCondensed[vars[0]] = new List<int>();
                        first = false;
                        continue;
                    }
                    Program.model.modelGekko.m2.sparseInfoSmart[vars[0]].Add(var);
                    Program.model.modelGekko.m2.sparseInfoSmartCondensed[vars[0]].Add(var);
                }
            }

            
            //=================================
            //=================================
            //======== Ordering start =========
            //=================================
            //=================================


            List<List<int>> rowsIndexes = new List<List<int>>();
            List<List<int>> columnsIndexes = new List<List<int>>();
            for (int i = 0; i < Program.model.modelGekko.m2.endogenous.Count; i++)
            {
                rowsIndexes.Add(new List<int>());
                columnsIndexes.Add(new List<int>());
            }

            List<List<int>> rowsIndexes2 = new List<List<int>>();
            List<List<int>> columnsIndexes2 = new List<List<int>>();
            for (int i = 0; i < Program.model.modelGekko.m2.endogenous.Count; i++)
            {
                rowsIndexes2.Add(new List<int>());
                columnsIndexes2.Add(new List<int>());
            }

            //sparseInfoLeftRightSeparated has lhs at [0], content is b[]-type numbers
            foreach (List<int> al2 in Program.model.modelGekko.m2.sparseInfoLeftRightSeparated)
            {
                bool shouldAddOnRightHandSide = false;
                int lhs2 = al2[0];

                if (Program.model.modelGekko.m2.endoSubstitutionBNumbers.ContainsKey(lhs2))
                {
                    shouldAddOnRightHandSide = true;
                    lhs2 = Program.model.modelGekko.m2.endoSubstitutionBNumbers[lhs2];
                    for (int i = 1; i < al2.Count; i++)
                    {
                        if (al2[i] == lhs2) shouldAddOnRightHandSide = false;
                    }
                }

                int lhs = Program.model.modelGekko.m2.fromBNumberToEqNumber[lhs2];
                for (int i = 1; i < al2.Count; i++)
                {
                    int rhsi2 = al2[i];
                    int rhsi = Program.model.modelGekko.m2.fromBNumberToEqNumber[rhsi2];
                    PutIntoIndidenceMatrix(rowsIndexes, columnsIndexes, rowsIndexes2, columnsIndexes2, lhs, rhsi);
                }
                if (shouldAddOnRightHandSide == true)
                {
                    PutIntoIndidenceMatrix(rowsIndexes, columnsIndexes, rowsIndexes2, columnsIndexes2, lhs, lhs);
                }
            }

            Program.model.modelGekko.m2.prologue = new List<int>();
            Program.model.modelGekko.m2.epilogue = new List<int>();
            Program.model.modelGekko.m2.simulRecursive = new List<int>();
            Program.model.modelGekko.m2.simulFeedback = new List<int>();

            List<int> simulRecursive = new List<int>();
            List<int> simulEpi = new List<int>();

            FindRecursive(rowsIndexes, columnsIndexes, Program.model.modelGekko.m2.prologue);
            FindRecursive(columnsIndexes, rowsIndexes, Program.model.modelGekko.m2.epilogue);  //note: should be reversed, see next statement
            Program.model.modelGekko.m2.epilogue.Reverse();

            int orderingIterations = 0;
            for (int i6 = 0; i6 < int.MaxValue; i6++)
            {
                FindDiagonal(rowsIndexes, columnsIndexes, Program.model.modelGekko.m2.simulFeedback);
                if (!(Globals.solveNewtonOnlyFeedback && Globals.runningOnTTComputer)) FindRecursive(rowsIndexes, columnsIndexes, simulRecursive);

                //this one is good:
                //These are simple equations with 1 var on right-hand side
                if (!(Globals.solveNewtonOnlyFeedback && Globals.runningOnTTComputer)) FindRowsWithSum1(rowsIndexes, columnsIndexes, simulRecursive);


                //this one is bad:
                //These equations may have many right-hand vars, but impact is only in one other equation
                if (1 == 0)
                {
                    FindColsWithSum1(rowsIndexes, columnsIndexes, simulRecursive);
                }

                Heuristic(rowsIndexes, columnsIndexes, Program.model.modelGekko.m2.simulFeedback);

                bool flag = false;
                for (int i = 0; i < columnsIndexes.Count; i++)
                {
                    if (columnsIndexes[i] != null)
                    {
                        flag = true;
                        orderingIterations = i6;
                        break;
                    }
                }
                if (!flag) break;
            }

            if (!(Globals.solveNewtonOnlyFeedback && Globals.runningOnTTComputer))
            {
                Program.model.modelGekko.m2.simulFeedback.Sort();  //easier comparable to gauss-seidel inner loop
            }

            //A little bit cheating, since these numbers will always relate to the last .m2 model
            //But never mind, typically only shown for non-fixed model
            Program.model.modelGekko.modelInfo.endo3 = Program.model.modelGekko.m2.prologue.Count + Program.model.modelGekko.m2.simulFeedback.Count + simulRecursive.Count + Program.model.modelGekko.m2.epilogue.Count;
            Program.model.modelGekko.modelInfo.prologue = Program.model.modelGekko.m2.prologue.Count;
            Program.model.modelGekko.modelInfo.simultaneous = Program.model.modelGekko.m2.simulFeedback.Count + simulRecursive.Count;
            Program.model.modelGekko.modelInfo.simultaneousFeedback = Program.model.modelGekko.m2.simulFeedback.Count;
            Program.model.modelGekko.modelInfo.simultaneousRecursive = simulRecursive.Count;
            Program.model.modelGekko.modelInfo.epilogue = Program.model.modelGekko.m2.epilogue.Count;

            for (int i = 0; i < rowsIndexes2.Count; i++)
            {
                if (!simulRecursive.Contains(i))
                {
                    DeleteRowAndColumn(rowsIndexes2, columnsIndexes2, i);
                }
            }

            FindRecursive(rowsIndexes2, columnsIndexes2, Program.model.modelGekko.m2.simulRecursive);
            FindRecursive(columnsIndexes2, rowsIndexes2, simulEpi);  //this one is empty and should be!! Good test also.

            if (!(simulEpi.Count == 0))
            {
                G.Writeln2("*** ERROR in feedback/recursive");
            }

            //=================================
            //=================================
            //======== Ordering end ===========
            //=================================
            //=================================

            

            simulRecursive = null;  //the ordering is not correct in simulRecursive: we use simulPrologue instead below.
            //at the moment, this is not strictly necessary, but still give a nicer ordering
            //and a good check

            WriteOrderingInfoToFile(rowsIndexes);

            Program.model.modelGekko.m2.fromEqNumberToBNumberRecursiveNEW = new List<int>();
            foreach (int eq in Program.model.modelGekko.m2.simulRecursive)
            {
                Program.model.modelGekko.m2.fromEqNumberToBNumberRecursiveNEW.Add(Program.model.modelGekko.m2.fromEqNumberToBNumber[eq]);
            }
            Program.model.modelGekko.m2.fromBNumberToEqNumberRecursiveNEW = G.CreateArray(Program.model.modelGekko.varsBType.Count, -12345);
            for (int i = 0; i < Program.model.modelGekko.m2.fromEqNumberToBNumberRecursiveNEW.Count; i++)
            {
                int j = (int)Program.model.modelGekko.m2.fromEqNumberToBNumberRecursiveNEW[i];
                Program.model.modelGekko.m2.fromBNumberToEqNumberRecursiveNEW[j] = i;
            }
            Program.model.modelGekko.m2.fromEqNumberToBNumberFeedbackNEW = new int[Program.model.modelGekko.m2.simulFeedback.Count];
            int i1 = -1;
            foreach (int eq in Program.model.modelGekko.m2.simulFeedback)
            {
                i1++;
                Program.model.modelGekko.m2.fromEqNumberToBNumberFeedbackNEW[i1] = Program.model.modelGekko.m2.fromEqNumberToBNumber[eq];
            }

            try
            {
                //TODO: This is a hack, but probably rare with > 1.000.000 b-elements
                Program.model.modelGekko.m2.fromBNumberToEqNumberFeedbackNEW = G.CreateArray(1000000, -12345);  //slack
            }
            catch (Exception e)
            {
                G.Writeln2("*** ERROR: Array size problem in MODEL command");
                throw new GekkoException();
            }

            for (int i = 0; i < Program.model.modelGekko.m2.fromEqNumberToBNumberFeedbackNEW.Length; i++)
            {
                int j = Program.model.modelGekko.m2.fromEqNumberToBNumberFeedbackNEW[i];
                Program.model.modelGekko.m2.fromBNumberToEqNumberFeedbackNEW[j] = i;
            }

            //at this point in feedb2.frm:
            //===================================
            //simulRecursive = 12,11,10,9,8,7,6,5,4
            //simulFeedback = 3,2
            //fromEqNumberToBNumberRecursiveNEW = 13,12,11,10,9,8,7,6,5
            //fromEqNumberToBNumberFeedbackNEW = 4,3
            //===================================
            //equations 0,1 and 13,14 are prologue and epilogue

            //            sparseInfoSmart
            //fy    0	1,2,3,4
            //fy.1  1	null (!endonolag)
            //tg    2	null
            //fi    3	0,3,4
            //fe    4

            //fy = fy.1 + tg + fi + fe
            //fi = fy + fi + fe

            //sæt fy exo og tg endo: ( 0 og 2 skifter plads)

            //tg = fy  (fy.1 + fi + fe)
            //fi = fy + tg + fi + fe

            //tg    0	1,2,3,4
            //fy.1  1	null (!endonolag)
            //fy    2	null
            //fi    3	2,3,4
            //fe    4

            Dictionary<int, string> fromEqNumberToBNumberRecursiveHelper = new Dictionary<int, string>();
            foreach (int i in Program.model.modelGekko.m2.fromEqNumberToBNumberRecursiveNEW) fromEqNumberToBNumberRecursiveHelper.Add(i, null);
            
            //transposing matrix
            //never relevant for goals search, since means are feedback type.
            Program.model.modelGekko.m2.sparseInfoSmartCondensedTransposed = new List<List<int>>();
            for (int i = 0; i < Program.model.modelGekko.m2.sparseInfoSmartCondensed.Count; i++)
            {
                Program.model.modelGekko.m2.sparseInfoSmartCondensedTransposed.Add(null);
                if (Program.model.modelGekko.m2.sparseInfoSmartCondensed[i] != null)
                {
                    Program.model.modelGekko.m2.sparseInfoSmartCondensedTransposed[i] = new List<int>();
                }
            }
            
            //never relevant for goals search, since means are feedback type.
            Program.model.modelGekko.m2.sparseInfoSmartTransposed = new List<List<int>>();
            for (int i = 0; i < Program.model.modelGekko.m2.sparseInfoSmart.Count; i++)
            {
                Program.model.modelGekko.m2.sparseInfoSmartTransposed.Add(null);
                if (Program.model.modelGekko.m2.sparseInfoSmart[i] != null)
                {
                    Program.model.modelGekko.m2.sparseInfoSmartTransposed[i] = new List<int>();
                }
            }

            //never relevant for goals search, since means are feedback type.
            for (int i = 0; i < Program.model.modelGekko.varsBType.Count; i++)
            {
                if (Program.model.modelGekko.m2.sparseInfoSmart[i] != null)
                {
                    List<int> row = Program.model.modelGekko.m2.sparseInfoSmart[i];
                    foreach (int j in row)
                    {
                        if (!(Program.model.modelGekko.m2.sparseInfoSmartTransposed[j]).Contains(i))
                        {
                            //if (fromEqNumberToBNumberFeedbackNEW.Contains(i))
                            if (Array.IndexOf(Program.model.modelGekko.m2.fromEqNumberToBNumberFeedbackNEW, i) != -1)
                            {
                                //this is an extra condition, implying that we only get
                                //FR-type array for all the last n columns
                                //the transposed version is not identical to non-transposed
                                (Program.model.modelGekko.m2.sparseInfoSmartTransposed[j]).Add(i);
                            }
                        }
                    }
                }
            }

            //       feedb    recurs
            // -------------|----------
            // feedb   FF1  |  FR1
            //        ------|------
            // recur   RF1  |  RR1
            //--------------|----------
            //
            //
        }

        private static int FindEqWithVarOnLeftHandSide(string endo)
        {
            int eqEndo = -12345;
            foreach (EquationHelper eh in Program.model.modelGekko.equations)
            {
                if (G.Equal(eh.lhs, endo))
                {
                    eqEndo = eh.equationNumber;
                }
            }
            if (eqEndo == -12345) G.Writeln2("*** ERROR: variable " + endo + " is not found as left-hand side var");
            return eqEndo;
        }

        private static void WriteOrderingInfoToFile(List<List<int>> rowsIndexes)
        {
            string path = Program.GetModelInfoPath();

            // Determine whether the directory exists, else create it (used for model related files)
            if (!Directory.Exists(path))
            {
                Directory.CreateDirectory(path);
            }

            using (FileStream fs = WaitForFileStream(path + "\\" + Globals.modelFileName.Replace(".frm", "") + ".ordering", GekkoFileReadOrWrite.Write))
            using (StreamWriter res = G.GekkoStreamWriter(fs))
            {
                res.WriteLine("Number of endogenous  = " + G.IntFormat(rowsIndexes.Count, 7));
                res.WriteLine("----------------------------------");
                res.WriteLine("Prologue              = " + G.IntFormat(Program.model.modelGekko.m2.prologue.Count, 7));
                res.WriteLine("Simultaneous feedback = " + G.IntFormat(Program.model.modelGekko.m2.simulFeedback.Count, 7));
                res.WriteLine("Simultanous recursive = " + G.IntFormat(Program.model.modelGekko.m2.simulRecursive.Count, 7));
                res.WriteLine("Epilogue              = " + G.IntFormat(Program.model.modelGekko.m2.epilogue.Count, 7));
                res.WriteLine();
                res.Write("The prologue variables can be considered a kind of pre-model of recursive equations feeding into ");
                res.Write("the simultanous block. The epilogue variables can be considered a kind of recursive after-model, depending ");
                res.WriteLine("upon the simultanous block, but not being simultanous itself.");
                res.Write("Inside the simulatenous block, there is a (typically) small kernel of intertwined variables being ");
                res.Write("heavily simultanous: the feedback set. The simultaneous recursive set is a set of simultaneous variables ");
                res.Write("being truly simultanous, but can be understood as being recursive relative to the feedback set. That is, ");
                res.Write("given the feedback (and prologue) variables, the simultanous recursive set can be computed as a (typically) ");
                res.Write("long chain of recursive equations depending only upon each other. These properties are used to reduce the ");
                res.WriteLine("dimensionality of the problem when using the Newton method for goals/means etc.");
                res.WriteLine("");
                res.WriteLine("--- Prologue variables (" + Program.model.modelGekko.m2.prologue.Count + ") ---");
                PrintEquationLeftHandSideNames(Program.model.modelGekko.m2.prologue, res);
                res.WriteLine();
                res.WriteLine("--- Simultaneous block #1 of 2: feedback variables (" + Program.model.modelGekko.m2.simulFeedback.Count + ") ---");
                PrintEquationLeftHandSideNames(Program.model.modelGekko.m2.simulFeedback, res);
                res.WriteLine();
                res.WriteLine("--- Simultaneous block #2 of 2: recursive variables (" + Program.model.modelGekko.m2.simulRecursive.Count + ") ---");
                PrintEquationLeftHandSideNames(Program.model.modelGekko.m2.simulRecursive, res);
                res.WriteLine();
                res.WriteLine("--- Epilogue variables (" + Program.model.modelGekko.m2.epilogue.Count + ") ---");
                PrintEquationLeftHandSideNames(Program.model.modelGekko.m2.epilogue, res);
                res.WriteLine();
                res.Flush();
            }
        }

        private static void PutIntoIndidenceMatrix(List<List<int>> rowsIndexes, List<List<int>> columnsIndexes, List<List<int>> rowsIndexes2, List<List<int>> columnsIndexes2, int lhs, int rhsi)
        {
            rowsIndexes[lhs].Add(rhsi);
            columnsIndexes[rhsi].Add(lhs);
            rowsIndexes2[lhs].Add(rhsi);
            columnsIndexes2[rhsi].Add(lhs);
        }

        private static void PrintEquationLeftHandSideNames(List<int> al, StreamWriter res)
        {
            foreach (int i in al)
            {
                int tmp = Program.model.modelGekko.m2.fromEqNumberToBNumber[i];
                string var = Program.model.modelGekko.varsBTypeInverted[tmp];
                TwoStrings ts = getVariableAndLag(var);
                string var2 = G.GetUpperLowerCase(ts.s1);
                res.WriteLine("  " + var2);
            }
        }

        private static void Heuristic(List<List<int>> rowsIndexes, List<List<int>> columnsIndexes, List<int> feedback)
        {
            int max2 = -12345;
            int imax = -12345;
            for (int i = 0; i < columnsIndexes.Count; i++)
            {
                List<int> a = columnsIndexes[i];
                if (a != null)
                {
                    List<int> b = rowsIndexes[i];
                    int sza = a.Count;
                    int szb = b.Count;
                    int prod = sza * szb;  //seems to be good rule
                    //int prod = szb; //for jul05 reduces feedb set from 267 to 240, but is slower overall. Also for saffier.
                    if (prod > max2)
                    {
                        max2 = prod;
                        imax = i;
                    }
                }
            }
            if (imax != -12345)
            {
                feedback.Add(imax);
                DeleteRowAndColumn(rowsIndexes, columnsIndexes, imax);
            }
        }

        public static string GetCompilerOptions()
        {
            if (Environment.Is64BitProcess) return Globals.compilerOptions64;
            else return Globals.compilerOptions32;
        }

        private static void FindDiagonal(List<List<int>> rowsIndexes, List<List<int>> columnsIndexes, List<int> fb)
        {
            for (int i = 0; i < rowsIndexes.Count; i++)
            {
                List<int> a = rowsIndexes[i];
                if (a != null)
                {
                    if (a.Contains(i))
                    {
                        fb.Add(i);
                        DeleteRowAndColumn(rowsIndexes, columnsIndexes, i);
                    }
                }
            }
        }

        private static void FindColsWithSum1(List<List<int>> rowsIndexes, List<List<int>> columnsIndexes, List<int> rec)
        {
            for (int i = 0; i < columnsIndexes.Count; i++)
            {
                List<int> a = columnsIndexes[i];
                if (a != null)
                {
                    if (a.Count == 1)
                    {
                        int subst = (int)a[0];
                        if (i != subst)
                        {

                            rec.Add(i);


                            if (!(rowsIndexes[subst]).Contains(subst))
                            {
                                (rowsIndexes[subst]).Add(subst);
                            }
                            if (!(columnsIndexes[subst]).Contains(subst))
                            {
                                (columnsIndexes[subst]).Add(subst);
                            }

                            DeleteRowAndColumn(rowsIndexes, columnsIndexes, i);
                        }
                    }
                }
            }
        }

        private static void FindRowsWithSum1(List<List<int>> rowsIndexes, List<List<int>> columnsIndexes, List<int> rec)
        {
            for (int i = 0; i < rowsIndexes.Count; i++)
            {
                List<int> a = rowsIndexes[i];
                if (a != null)
                {
                    if (a.Count == 1)
                    {
                        int subst = (int)a[0];  //the right-hand var (y in c = 0.8 y)
                        if (i != subst)  //should not be equal -- meaning it depends only on itself
                        {
                            //this is an equation like "c = 0.8 y"
                            rec.Add(i);  //add "c" to recursive set
                            List<int> b = columnsIndexes[i];
                            for (int j = 0; j < b.Count; j++)
                            {
                                //for each equation containing "c"
                                int c = (int)b[j];  //the left-hand side of that eq (e.g. the equation i = 0.5 c)
                                if (!(rowsIndexes[c]).Contains(subst))
                                {
                                    //if equation "i" does not contain "y", add it
                                    (rowsIndexes[c]).Add(subst);
                                }
                                if (!(columnsIndexes[subst]).Contains(c))
                                {
                                    //if var "y" does not appear in equaton "i" add it
                                    (columnsIndexes[subst]).Add(c);
                                }


                            }
                            DeleteRowAndColumn(rowsIndexes, columnsIndexes, i);
                        }
                    }
                }
            }
        }

        private static void FindRecursive(List<List<int>> rowsIndexes, List<List<int>> columnsIndexes, List<int> pro)
        {
            while (true)
            {
                bool hit = false;
                for (int i = 0; i < rowsIndexes.Count; i++)
                {

                    List<int> a = rowsIndexes[i];
                    if (a != null && a.Count == 0)
                    {
                        hit = true;
                        //rowsum is 0 for this row
                        pro.Add(i);
                        DeleteRowAndColumn(rowsIndexes, columnsIndexes, i);
                    }
                }
                if (!hit) break;
            }
        }

        private static void DeleteRowAndColumn(List<List<int>> rowsIndexes, List<List<int>> columnsIndexes, int i)
        {
            List<int> b = columnsIndexes[i];
            for (int j = 0; j < b.Count; j++)
            {
                int c = (int)b[j];
                List<int> d = rowsIndexes[c];
                if (!d.Contains(i)) G.Writeln("error");
                d.Remove(i);
            }

            List<int> b2 = rowsIndexes[i];
            for (int j = 0; j < b2.Count; j++)
            {
                int c = (int)b2[j];
                List<int> d = columnsIndexes[c];
                if (!d.Contains(i)) G.Writeln("error");
                d.Remove(i);
            }


            rowsIndexes[i] = null;
            columnsIndexes[i] = null;
        }

        private static void PrintMatrix(IElementalAccessMatrix ic)
        {
            for (int i1 = 0; i1 < ic.RowCount; i1++)
            {
                for (int i2 = 0; i2 < ic.ColumnCount; i2++)
                {
                    double val = ic.GetValue(i1, i2);
                    //int val1 = (int)val;
                    G.Write(val + " ");
                }
                G.Writeln();
            }
        }

        
        private static ArrayList FindEqsWithVarOnRightHandSide(string var1)
        {
            ArrayList eqs = new ArrayList();
            foreach (EquationHelper eh in Program.model.modelGekko.equations)
            {
                foreach (string rhsVar in eh.precedentsWithLagIndicator.Keys)
                {
                    if (G.Equal(rhsVar, var1 + Globals.lagIndicator + "0"))
                    {
                        eqs.Add(eh.equationNumber);
                    }
                }
            }
            return eqs;
        }       

        public static void EmitCodeFromANTLR(string text, string fileName, bool isLibrary, int skip, P p)
        {
            //#98073245298345
            //Here, we are translating (1) a gui oneliner, (2) a gui command block, or a gcm file (that might be .ini or called with LIBRARY).
            
            ////So we wipe out the uFunctions, to have a clean desk.
            ////We do not wipe it if it is a library, since it has already been wiped just before (LIBRARY must be the first command).
            //if (!isLibrary) Globals.uFunctionStorageCs = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);

            int max = 1;
            if (G.Equal(Program.options.interface_debug, "dialog")) max = int.MaxValue;  //should suffice as tries :-)

            for (int i = 0; i < max; i++)  //number of tries to run a cmd file that has parser/lexer errors
            {
                string islooping = "parser";
                if (i > 0) islooping = "parser_islooping";

                Parser.ConvertHelper ch = null;

                Parser.ParseHelper ph = new Parser.ParseHelper();
                ph.commandsText = text;
                ph.fileName = fileName;
                ph.isModel = false;

                string commandLinesFlat = null;
                //It is either txt or fileName, depending of how method is called

                if (Globals.runningOnTTComputer && Globals.showTimings) G.Writeln("Handle start: " + G.SecondsFormat((DateTime.Now - p.startingTime).TotalMilliseconds), Color.LightBlue);

                if (fileName != "")
                {
                    //a file
                    if (!fileName.Contains("tablecode." + Globals.defaultCommandFileExtension))  //don't count an autogenerated table as a cmd file
                    {
                        p.hasBeenCmdFile = true;
                    }
                    string input = GetTextFromFileWithWait(fileName);
                    commandLinesFlat = HandleObeyFiles2(input);
                    if (skip != 0)
                    {
                        List<string> ss = Program.CreateListOfStringsFromString(commandLinesFlat);
                        commandLinesFlat = "";
                        for (int ii = 0; ii < skip; ii++)
                        {
                            if (ii == ss.Count)
                            {
                                G.Writeln2("Skip is set after file end");
                                break;
                            }
                            commandLinesFlat += ss[ii] + G.NL;
                        }                                                
                    }
                    ph.isOneLinerFromGui = false;
                }
                else if (text != "")
                {
                    //oneliner from GUI
                    if (text.Contains("\n"))
                    {
                        commandLinesFlat = HandleObeyFiles2(text);  //is handled exactly as if it was a file
                        ph.isOneLinerFromGui = false;  //is a more-liner........
                    }
                    else
                    {
                        string text0 = HandleOneLiners(text);
                        commandLinesFlat = HandleObeyFiles2(text0);
                        ph.isOneLinerFromGui = true;
                        p.isOneLinerFromGui = true;
                    }
                }

                ph.commandsText = commandLinesFlat;
                p.SetCommandFileText(commandLinesFlat);

                try
                {
                    if (Globals.runningOnTTComputer && Globals.showTimings) G.Writeln("Parse start: " + G.SecondsFormat((DateTime.Now - p.startingTime).TotalMilliseconds), Color.LightBlue);
                    p.lastFileSentToANTLR = fileName;
                    p.SetLastFileSentToANTLR(fileName);
                                        
                    ch = Gekko.Parser.Gek.ParserGekCreateAST.CreateAST(ph, p);
                    
                    if (Globals.runningOnTTComputer && Globals.showTimings) G.Writeln("Parse end: " + G.SecondsFormat((DateTime.Now - p.startingTime).TotalMilliseconds), Color.LightBlue);
                }
                catch (Exception e)
                {
                    if (G.Equal(Program.options.interface_debug, "dialog"))
                    {
                        string eh = Program.ErrorHandling(islooping, p, false);

                        if (eh == "stop")
                        {
                            //throw new GekkoException(); //this will make a double error -- but the other one will be identified later on (both text and filename are null) and skipped -- a little bit hacky, but oh well...
                            throw;
                        }
                        else if (eh == "retry")
                        {
                            continue;  //try again
                        }
                        else
                        {
                            G.Writeln2("*** ERROR: Strange error in gcm file -- please report this to the developer");
                            //throw new GekkoException();
                            throw;
                        }
                    }
                    else
                    {
                        string eh = Program.ErrorHandling(islooping, p, true);
                        throw new GekkoException(); //this will make a double error -- but the other one will be identified later on (both text and filename are null) and skipped -- a little bit hacky, but oh well...
                    }
                }

                ch.commandsText = commandLinesFlat;
                if (fileName == "") Globals.commandMemory.storage.AppendLine(text); //is syntax-ok, but may run-time fail

                if (isLibrary)
                {
                    //skip it, there will be no code, since code outside functions is not allowed in gcm files storing user functions (called with LIBRARY)
                }
                else
                {
                    try
                    {
                        Gekko.Parser.Gek.ParserGekCompileAndRunAST.CompileAndRunAST(ch, p);
                    }
                    catch (Exception e)
                    {
                        if (!G.IsDebugSession) throw;
                    }
                }

                break;  //if we get to here, everything is ok so break the file-trying loop
            }
            //if (!G.IsUnitTesting()) ShowPeriodInStatusField("");
        }

        public static void PrecedentsHelper(string variableName, IVariable iv, Databank db)
        {
            if (Globals.precedents != null && iv != null)
            {
                Series rv_series = iv as Series;
                if (rv_series != null)
                {
                    Program.AddToPrecedents(db, rv_series.GetName());
                }
            }
        }

        public static void WriteHtml(StringBuilder sb, string s)
        {
            sb.AppendLine("<p>" + s + "</p>");
        }

        public static void WriteHtmlColor(StringBuilder sb, string s)
        {
            sb.AppendLine("<p><font color=\"#009933\">" + s + "</font></p>");
        }

        public static void Browser()
        {
            bool jsmFix = true;

            G.Writeln2("Starting html browser generation");
            DateTime dt0 = DateTime.Now;

            string pathAndFile = Program.options.folder_working + "\\" + "browser.json";
            string jsonCode = G.RemoveComments(GetTextFromFileWithWait(pathAndFile));

            System.Web.Script.Serialization.JavaScriptSerializer serializer = new System.Web.Script.Serialization.JavaScriptSerializer();
            Dictionary<string, object> jsonTree = null;
            try
            {
                jsonTree = (Dictionary<string, object>)serializer.DeserializeObject(jsonCode);
            }
            catch (Exception e)
            {
                G.Writeln2("+++ WARNING: The .json file does not seem correctly formatted.");
                G.Writeln("             " + e.Message);
                //throw;
            }

            // -------------------------------------------------------------

            string settings_index_filename = null;
            try { settings_index_filename = (string)jsonTree["index_filename"]; } catch { }
            if (settings_index_filename == null)
            {
                G.Writeln2("*** ERROR: JSON: index_filename not found"); throw new GekkoException();
            }

            string settings_list_filename = null;
            try { settings_list_filename = (string)jsonTree["list_filename"]; } catch { }
            if (settings_list_filename == null)
            {
                G.Writeln2("*** ERROR: JSON: list_filename not found"); throw new GekkoException();
            }

            string settings_find_filename = null;
            try { settings_find_filename = (string)jsonTree["find_filename"]; } catch { }
            if (settings_find_filename == null)
            {
                G.Writeln2("*** ERROR: JSON: find_filename not found"); throw new GekkoException();
            }

            string settings_css_filename = null;
            try { settings_css_filename = (string)jsonTree["css_filename"]; } catch { }
            if (settings_css_filename == null)
            {
                G.Writeln2("*** ERROR: JSON: css_filename not found"); throw new GekkoException();
            }

            string settings_dok_filename = null;
            try { settings_dok_filename = (string)jsonTree["dok_filename"]; } catch { }
            if (settings_dok_filename == null)
            {
                G.Writeln2("*** ERROR: JSON: dok_filename not found"); throw new GekkoException();
            }

            string settings_est_filename = null;
            try { settings_est_filename = (string)jsonTree["est_filename"]; } catch { }
            if (settings_est_filename == null)
            {
                G.Writeln2("*** ERROR: JSON: est_filename not found"); throw new GekkoException();
            }
            
            string settings_icon_filename = null;
            try { settings_icon_filename = (string)jsonTree["icon_filename"]; } catch { }
            if (settings_icon_filename == null)
            {
                G.Writeln2("*** ERROR: JSON: icon_filename not found"); throw new GekkoException();
            }
            
            string settings_vars_foldername = null;
            try { settings_vars_foldername = (string)jsonTree["vars_foldername"]; } catch { }
            if (settings_vars_foldername == null)
            {
                G.Writeln2("*** ERROR: JSON: vars_foldername not found"); throw new GekkoException();
            }

            string settings_commands = null;
            try { settings_commands = (string)jsonTree["commands"]; } catch { }
            if (settings_commands == null)
            {
                G.Writeln2("*** ERROR: JSON: commands not found"); throw new GekkoException();
            }

            string settings_plot_start = null;
            try { settings_plot_start = (string)jsonTree["plot_start"]; } catch { }
            if (settings_plot_start == null)
            {
                G.Writeln2("*** ERROR: JSON: plot_start not found"); throw new GekkoException();
            }

            string settings_plot_end = null;
            try { settings_plot_end = (string)jsonTree["plot_end"]; } catch { }
            if (settings_plot_end == null)
            {
                G.Writeln2("*** ERROR: JSON: plot_end not found"); throw new GekkoException();
            }

            string settings_plot_line = null;
            try { settings_plot_line = (string)jsonTree["plot_line"]; } catch { }
            if (settings_plot_line == null)
            {
                G.Writeln2("*** ERROR: JSON: plot_line not found"); throw new GekkoException();
            }

            string settings_print_start = null;
            try { settings_print_start = (string)jsonTree["print_start"]; } catch { }
            if (settings_print_start == null)
            {
                G.Writeln2("*** ERROR: JSON: print_start not found"); throw new GekkoException();
            }

            string settings_print_end = null;
            try { settings_print_end = (string)jsonTree["print_end"]; } catch { }
            if (settings_print_end == null)
            {
                G.Writeln2("*** ERROR: JSON: print_end not found"); throw new GekkoException();
            }            

            string include_p_type = null;
            try { include_p_type = (string)jsonTree["include_p_type"]; } catch { }
            if (include_p_type == null)
            {
                G.Writeln2("*** ERROR: JSON: include_p_type"); throw new GekkoException();
            }

            bool settings_show_source = true;
            try { settings_show_source = (bool)jsonTree["show_source"]; } catch { }
            
            object[] settings_ekstrafiler = null;
            try { settings_ekstrafiler = (object[])jsonTree["ekstrafiler"]; } catch { }
            if (settings_ekstrafiler == null)
            {
                G.Writeln2("*** ERROR: JSON: ekstrafiler"); throw new GekkoException();
            }

            // -------------------------------------------------------------

            string list_title = "Variabelliste. Søg i browseren med Ctrl + F(find)";

            string browserFolder = "browser";

            List<string> files = new List<string>();
            files.Add(settings_index_filename);
            files.Add(settings_find_filename);
            files.Add(settings_list_filename);
            files.Add(settings_css_filename);
            files.Add(settings_dok_filename);
            files.Add(settings_est_filename);
            files.Add(settings_icon_filename);
            files.Add(browserFolder);
            files.Add(settings_vars_foldername);
            foreach (string file in files)
            {
                if (file == null) continue;
                if (file.Contains("/") || file.Contains("\\"))
                {
                    G.Writeln2("*** ERROR: '" + file + "' should not contain '/' or '\\'");
                    throw new GekkoException();
                }
            }

            string rootFolder = Program.options.folder_working + "\\" + browserFolder;
            string subFolder = Program.options.folder_working + "\\" + browserFolder + "\\" + settings_vars_foldername;

            BrowserCleanupFolders(rootFolder, subFolder);

            //index.html and styles.css is copied to root folder of browser system
            List<string> filesToCopy = new List<string>();
            filesToCopy.Add(settings_index_filename);
            filesToCopy.Add(settings_css_filename);
            filesToCopy.Add(settings_icon_filename);
            foreach (object o in settings_ekstrafiler)
            {
                string s = null;
                try
                {
                    s = (string)o;
                }
                catch (Exception e)
                {
                    G.Writeln2("*** ERROR: JSON: ekstrafiler"); throw new GekkoException();
                }
                if (s != null) filesToCopy.Add(s);
            }

            foreach (string fileToCopy in filesToCopy)
            {
                string fileNameIndex = Program.options.folder_working + "\\" + fileToCopy;
                string fileNameIndex2 = rootFolder + "\\" + fileToCopy;
                if (!File.Exists(fileNameIndex))
                {
                    G.Writeln2("*** ERROR: '" + fileNameIndex + "' was not found");
                    throw new GekkoException();
                }
                File.Copy(fileNameIndex, fileNameIndex2, true);
            }

            Program.RunCommandCalledFromGUI(settings_commands, new P());

            int gap = 20;

            GekkoTime plotStart = new GekkoTime(EFreq.A, G.IntParse(settings_plot_start), 1);
            GekkoTime plotEnd = new GekkoTime(EFreq.A, G.IntParse(settings_plot_end), 1);
            GekkoTime plot_line = new GekkoTime(EFreq.A, G.IntParse(settings_plot_line), 1);
            GekkoTime print_start = new GekkoTime(EFreq.A, G.IntParse(settings_print_start), 1);
            GekkoTime print_end = new GekkoTime(EFreq.A, G.IntParse(settings_print_end), 1);

            string bank1 = Path.GetFileName(Program.databanks.GetFirst().FileNameWithPath);
            string bank2 = Path.GetFileName(Program.databanks.GetRef().FileNameWithPath);

            List ml = O.GetIVariableFromString("#all", O.ECreatePossibilities.NoneReportError, true) as List;
            List<string> vars = O.GetListOfStringsFromIVariable(ml);

            if (G.Equal(include_p_type, "yes"))
            {
                GekkoDictionary<string, string> temp = new GekkoDictionary<string, string>(StringComparer.OrdinalIgnoreCase);
                foreach (string s in vars) temp.Add(s, null);
                foreach (EquationHelper eh in Program.model.modelGekko.equationsNotRunAtAll)
                {
                    if (eh.equationType != EEquationType.RevertedP) continue;
                    if (!temp.ContainsKey(eh.lhs)) temp.Add(eh.lhs, null);
                    foreach (string s12 in eh.precedentsWithLagIndicator.Keys)
                    {
                        string s13 = G.ExtractOnlyVariableIgnoreLag(s12);
                        if (!temp.ContainsKey(s13)) temp.Add(s13, null);
                    }
                }
                vars.Clear();
                foreach (string s14 in temp.Keys) vars.Add(s14);
            }

            if (false)
            {
                List<string> ss9 = new List<string>();
                foreach (string s in vars)
                {
                    if (s.ToLower().StartsWith("phk")) ss9.Add(s);
                }
                //MessageBox.Show(ss9);                
                List<EquationHelper> p = Program.model.modelGekko.equationsNotRunAtAll;
                List<EquationHelper> yt = Program.model.modelGekko.equationsReverted;
                //here we could use .lhsvariable and .precedentsWithLagIndicator to
                //obtain variables for p-type equations.
                return;  //qwerty
            }

            if (Globals.browserLimit)
            {                
                vars = new List<string> { "aaa", "fcp", "PHK", "jphk", "fee", "Jfee", "fy", "tg", "peesq", "ktiorn", "tfon", "phk2", "phk3", "JNTPPIK" };  //phk2 is t-type, phk3 is p-type and JNTPPIK is y-type. The y-type is not shown
                Globals.browserLimit = false;  //for safety
            }
            else if (Globals.runningOnTTComputer)
            {
                DialogResult result = MessageBox.Show("Only a few vars?", "Vars", MessageBoxButtons.YesNo, MessageBoxIcon.None, MessageBoxDefaultButton.Button1, MessageBoxOptions.DefaultDesktopOnly);
                if (result == DialogResult.Yes)
                {
                    vars = new List<string> { "aaa", "fcp", "PHK", "jphk", "fee", "Jfee", "fy", "tg", "peesq", "ktiorn", "tfon" };
                }                
            }


            vars.Sort(StringComparer.OrdinalIgnoreCase);

            // -------------------------------------------
            // Data generation
            // -------------------------------------------

            GekkoDictionary<string, List<string>> datagen = BrowserDataGenerationExtract();

            // -------------------------------------------
            // Html
            // -------------------------------------------

            GekkoDictionary<string, List<Tuple<string, string>>> doc = new GekkoDictionary<string, List<Tuple<string, string>>>(StringComparer.OrdinalIgnoreCase);
            string dokFileName = Program.options.folder_working + "\\" + settings_dok_filename;
            string dok2 = Program.GetTextFromFileWithWait(dokFileName);
            List<string> dok = G.ExtractLinesFromText(dok2);
            for (int i = 0; i < dok.Count; i++)
            {
                string line = dok[i].Trim();
                if (line.StartsWith("!")) continue;
                string[] ss = line.Split(new string[] { " " }, StringSplitOptions.RemoveEmptyEntries);
                if (ss.Length < 3) continue;
                string varname = ss[0];
                string path = ss[1];
                string descr = null;
                for (int ii = 2; ii < ss.Length; ii++)
                {
                    descr += ss[ii] + " ";
                }
                if (!doc.ContainsKey(varname))
                {
                    List<Tuple<string, string>> tuples = new List<Tuple<string, string>>();
                    doc.Add(varname, tuples);
                }
                doc[varname].Add(new Tuple<string, string>(path, descr));

            }

            List<string> vars2 = new List<string>();

            GekkoDictionary<string, List<string>> est2 = new GekkoDictionary<string, List<string>>(StringComparer.OrdinalIgnoreCase);
            string est = Program.GetTextFromFileWithWait(Program.options.folder_working + "\\" + settings_est_filename);
            List<string> lines = G.ExtractLinesFromText(est);
            int listI = -12345;
            for (int i = 0; i < lines.Count; i++)
            {
                if (lines[i].Trim().StartsWith(Globals.ols1))
                {
                    if (listI != -12345)
                    {

                        int fat = 5;
                        var tags1 = new List<Tuple<string, string>>() { new Tuple<string, string>("/*", "*/") };
                        var tags2 = new List<string>() { "//" };
                        string depLine = lines[listI + 1].Trim();
                        depLine = depLine.Replace(Globals.ols2, "").Trim();
                        List<TokenHelper> a = StringTokenizer2.GetTokensWithLeftBlanks(depLine, fat, tags1, tags2, null, null).storage;

                        //List<TokenHelper> a = StringTokenizer2.GetTokensWithLeftBlanks(lines[listI + 1].Trim(), 5, true);
                        string varLine = null;
                        for (int i2 = 0; i2 < a.Count; i2++)
                        {
                            if (a[i2].type == ETokenType.Word)
                            {
                                if (i2 - 1 >= 0 && a[i2].leftblanks == 0 && (a[i2 - 1].s == Globals.symbolCollection.ToString() || a[i2 - 1].s == Globals.symbolScalar.ToString()))
                                {
                                    //skip a #x or %x                                 }
                                    continue;
                                }
                                if (a[i2 + 1].s == "(")
                                {
                                    //function call, skip it
                                    continue;
                                }
                                varLine = a[i2].s;
                                break;
                            }
                        }

                        List<string> xx = new List<string>();
                        for (int ii = listI; ii < i; ii++)
                        {
                            xx.Add(lines[ii]);
                        }
                        if (est2.ContainsKey(varLine))
                        {
                            List<string> lines2 = est2[varLine];
                            lines2.Add("");
                            lines2.AddRange(xx);
                        }
                        else
                        {
                            est2.Add(varLine, xx);
                        }
                    }
                    listI = i;
                }
            }

            foreach (string var in vars)
            {
                StringBuilder sb = new StringBuilder();
                Series ts1 = Program.databanks.GetFirst().GetIVariable(var + "!a") as Series;

                if (ts1 == null)
                {
                    G.Writeln2("*** ERROR: Could not find series " + var + " in databank " + Program.databanks.GetFirst().name);
                }

                Series ts2 = Program.databanks.GetRef().GetIVariable(var + "!a") as Series;
                string jName = null;  //name of possible j-led
                bool jNameAutoGen = false;

                sb.AppendLine("<table cellpadding = `0` cellspacing = `0` width = `800px` border = `0`>");
                sb.AppendLine("<tr>");
                sb.AppendLine("<td width = `80%`><big><b> " + var + "</b></big></td>");
                sb.AppendLine("<td width = `10%`><a href=`..\\" + settings_find_filename + "`>Søg</a></td>");
                sb.AppendLine("<td width = `10%`><a href=`..\\" + settings_index_filename + "`>Hjem</a></td>");
                sb.AppendLine("</tr>");
                sb.AppendLine("</table>");

                //List<string> varExpl = Program.GetVariableExplanation(var);
                //string explanation2 = Program.GetVariableExplanationAugmented(var, G.ExtractOnlyVariableIgnoreLag(var, Globals.leftParenthesisIndicator)).Trim();
                List<string> varExpl = Program.GetVariableExplanationAugmented(var);

                foreach (string line in varExpl)
                {
                    if (line != "")
                    {
                        string line2 = Program.SpecialXmlChars(line);
                        WriteHtmlColor(sb, line2);
                    }
                }

                string explanation = null;
                if (varExpl != null && varExpl.Count > 0) explanation = G.HandleQuoteInQuote(varExpl[0], true);
                vars2.Add(var + "¤" + explanation);

                StringBuilder sb4 = new StringBuilder();

                if (true)
                {
                    EEndoOrExo type1 = VariableTypeEndoExo(var);
                    string type = "";
                    if (type1 == EEndoOrExo.Exo) type = "Eksogen, ";
                    else if (type1 == EEndoOrExo.Endo) type = "Endogen, ";

                    string freq = "[ukendt frekvens]";
                    if (ts1.freq == EFreq.A)
                    {
                        freq = "Årlig";
                    }
                    else if (ts1.freq == EFreq.Q)
                    {
                        freq = "Kvartalsvis";
                    }
                    else if (ts1.freq == EFreq.M)
                    {
                        freq = "Månedlig";
                    }
                    else if (ts1.freq == EFreq.U)
                    {
                        freq = "Udateret";
                    }

                    bool noData = ts1.IsNullPeriod(); //We are opening up to this possibility of 'empty' data

                    //GekkoTime first = ts.GetPeriodFirst();
                    //GekkoTime last = ts.GetPeriodLast();

                    GekkoTime first = ts1.GetRealDataPeriodFirst();
                    GekkoTime last = ts1.GetRealDataPeriodLast();

                    sb4.Append(type);
                    string stamp = null;
                    if (ts1.meta.stamp != null && ts1.meta.stamp != "") stamp = " (opdateret: " + ts1.meta.stamp + ")";
                    if (ts1.freq == EFreq.A || ts1.freq == EFreq.U) 
                    {
                        if (noData || first.super == -12345 || last.super == -12345)
                        {
                            sb4.Append(freq + ", ingen dataperiode");
                        }
                        else
                        {
                            //we don't want 1995a1 to 2005a1, instead 1995 to 2005
                            sb4.Append(freq + " data fra " + first.super + " til " + last.super + stamp);
                        }
                    }
                    else
                    {
                        if (noData || first.super == -12345 || last.super == -12345)
                        {
                            sb4.Append(freq + ", ingen dataperiode");
                        }
                        else
                        {
                            sb4.Append(freq + " data fra " + first.super + ts1.freq.ToString() + first.sub + " til " + last.super + ts1.freq.ToString() + last.sub + stamp);
                        }
                    }
                    WriteHtml(sb, sb4.ToString());

                }

                if (ts1.meta.label != null) WriteHtml(sb, "Label: " + ts1.meta.label);

                if (settings_show_source)
                {
                    if (ts1.meta.source != null)
                    {
                        //We keep the SERIES (or SER), there may be options etc. But we capitalize it.
                        string src2 = ts1.meta.source.Trim();
                        if (src2 != "")
                        {
                            int i = src2.IndexOf("(hash ");
                            if (i > -1)
                                src2 = src2.Substring(0, i);
                            WriteHtml(sb, "Seneste beregning: " + src2);
                        }
                    }
                }

                if (ts1.meta.units != null)
                {
                    //We keep the SERIES (or SER), there may be options etc. But we capitalize it.
                    string src2 = ts1.meta.units.Trim();
                    if (src2 != "")
                    {
                        WriteHtml(sb, "Enheder: " + src2);
                    }
                }

                List<Tuple<string, string>> tuples = null; doc.TryGetValue(var, out tuples);
                if (tuples != null)
                {
                    int counter = -1;
                    sb.Append("<table style=`margin: 0px; padding: 0px; border: 0px; width = 800px;`>");
                    foreach (Tuple<string, string> tuple in tuples)
                    {
                        counter++;
                        string s = null;
                        if (counter == 0) s = "Dokumentation:&nbsp;&nbsp;";
                        sb.Append("<tr>");
                        //sb.Append("<td width = `1%`>" + s + "</td>");
                        //sb.Append("<td width = `99%`><a href = `" + tuple.Item1 + "`>" + tuple.Item2 + "</a></td>");
                        sb.Append("<td>" + s + "</td>");
                        sb.Append("<td><a href = `" + tuple.Item1 + "`>" + tuple.Item2 + "</a></td>");
                        sb.Append("</tr>");
                    }
                    sb.Append("</table>");
                }


                if (G.HasModelGekko())
                {
                    List<string> list = new List<string>();
                    if (Program.model.modelGekko.dependents.ContainsKey(var))
                    {
                        Dictionary<string, string> d2 = Program.model.modelGekko.dependents[var].storage;
                        if (d2 != null)
                        {
                            foreach (string d3 in d2.Keys)
                            {
                                list.Add(d3);
                            }
                        }
                        list.Sort(StringComparer.InvariantCulture);
                    }
                    
                    EquationHelper eq = Program.FindEquationByMeansOfVariableName(var);

                    if (eq == null)
                    {
                        for (int i = 0; i < Program.model.modelGekko.equationsReverted.Count; i++)
                        {
                            EquationHelper eh = Program.model.modelGekko.equationsReverted[i];
                            if (G.Equal(var, eh.lhs))
                            {
                                eq = eh;
                                break;
                            }
                        }
                    }

                    if (eq == null)
                    {
                        for (int i = 0; i < Program.model.modelGekko.equationsNotRunAtAll.Count; i++)
                        {
                            EquationHelper eh = Program.model.modelGekko.equationsNotRunAtAll[i];
                            if (G.Equal(var, eh.lhs))
                            {
                                eq = eh;
                                break;
                            }
                        }
                    }

                    if (eq != null && eq.equationCode != null)
                    {
                        foreach (string s in eq.precedentsWithLagIndicator.Keys)
                        {
                            string jvar = null;
                            int lag = 0;
                            G.ExtractVariableAndLag(s, out jvar, out lag);
                            if (jvar.StartsWith("j", StringComparison.OrdinalIgnoreCase))
                            {
                                if (G.Contains(jvar, var))
                                {
                                    jName = jvar;
                                    if (!G.Contains(eq.equationText, jvar))
                                    {
                                        jNameAutoGen = true;
                                    }
                                    break;
                                }
                            }
                        }
                    }

                    if (eq != null && eq.modelBlock != null && eq.modelBlock != "" && eq.modelBlock != "Unnamed")
                    {
                        WriteHtml(sb, "Modelblock: " + eq.modelBlock);
                    }

                    StringBuilder sb5 = new StringBuilder();
                    sb5.Append("Påvirker: ");
                    if (list.Count == 0) sb5.Append("<none>");
                    else
                    {

                        int counter = 0;
                        for (int i = 0; i < list.Count; i++)
                        {
                            string s = list[i];


                            sb5.Append(HtmlLink(s));


                            if (i < list.Count - 1) sb5.Append(", ");


                        }
                        sb5.AppendLine();

                    }
                    WriteHtml(sb, sb5.ToString());

                    if (eq != null)
                    {
                        StringBuilder sb2 = new StringBuilder();
                        if (eq.equationType == EEquationType.RevertedAutoGenerated || eq.equationType == EEquationType.RevertedP || eq.equationType == EEquationType.RevertedT || eq.equationType == EEquationType.RevertedY)
                        {
                            sb2.AppendLine("----------------------------------------------");
                            sb2.AppendLine("    Note that this equation is run *after*");
                            sb2.AppendLine("    the model itself is solved.");
                            sb2.AppendLine("----------------------------------------------");
                            sb2.AppendLine("");
                        }
                        string equationText = eq.equationText;
                        if (jNameAutoGen) equationText += G.NL + G.NL + "J-led: " + jName;
                        InsertLinksIntoEquation(equationText, true, sb2);
                        WriteHtmlPreCode(sb, sb2.ToString());
                    }

                }

                string xxx = null;
                if (est2.ContainsKey(var))
                {
                    List<string> xx = est2[var];
                    foreach (string s in xx)
                    {
                        xxx += s + G.NL;
                    }
                }
                if (xxx != null)
                {
                    FoldingButtonStart(sb, "Estimationsoutput");
                    WriteHtmlPreCode(sb, xxx);
                    FoldingButtonEnd(sb);
                }

                List<string> datagen2 = null; datagen.TryGetValue(var, out datagen2);
                if (datagen2 != null)
                {
                    WriteHtml(sb, "Datagenerering:");
                    string s5 = null;
                    foreach (string s in datagen2)
                    {
                        s5 += s + G.NL;
                    }
                    WriteHtmlPreCode(sb, s5);
                }

                bool hasFilter = false; if (Program.options.timefilter && Globals.globalPeriodTimeFilters2.Count > 0) hasFilter = true;

                int max = Program.options.print_disp_maxlines;
                if (hasFilter || Program.options.print_disp_maxlines == -1) max = int.MaxValue;

                string l1 = bank1.ToLower().Replace(".gbk", "") + ":" + var;
                string l2 = bank2.ToLower().Replace(".gbk", "") + ":" + var;

                if (ts2 == null)
                {
                    //only plot the series from Work
                    Program.RunCommandCalledFromGUI("plot <" + plotStart.ToString() + " " + plotEnd.ToString() + " " + "xlineafter = " + plot_line.ToString() + " > " + var + " '" + l1 + "' file=" + subFolder + "\\" + var.ToLower() + ".svg;", new P());
                    Program.RunCommandCalledFromGUI("plot <" + plotStart.ToString() + " " + plotEnd.ToString() + " " + "xlineafter = " + plot_line.ToString() + " yminhard = -100 ymaxhard = 100 yminsoft = -1 ymaxsoft = 1  p> " + var + " '" + l1 + "' file=" + subFolder + "\\" + var.ToLower() + "___p" + ".svg;", new P());
                }
                else
                {
                    Program.RunCommandCalledFromGUI("plot <" + plotStart.ToString() + " " + plotEnd.ToString() + " " + "xlineafter = " + plot_line.ToString() + " > @" + var + " '" + l2 + "' <type = lines dashtype = '3'>, " + var + " '" + l1 + "' file=" + subFolder + "\\" + var.ToLower() + ".svg;", new P());
                    Program.RunCommandCalledFromGUI("plot <" + plotStart.ToString() + " " + plotEnd.ToString() + " " + "xlineafter = " + plot_line.ToString() + " yminhard = -100 ymaxhard = 100 yminsoft = -1 ymaxsoft = 1  p> @" + var + " '" + l2 + "' <type = lines dashtype = '3'>, " + var + " '" + l1 + "' file=" + subFolder + "\\" + var.ToLower() + "___p" + ".svg;", new P());
                }
                
                sb.AppendLine("<img src = `" + var.ToLower() + ".svg" + "`>");

                sb.AppendLine("<p/>");

                FoldingButtonStart(sb, "Vækst %");
                sb.AppendLine("<img src = `" + var.ToLower() + "___p.svg" + "`>");
                FoldingButtonEnd(sb);

                if (jName != null)
                {

                    FoldingButtonStart(sb, "J-led");
                    sb.AppendLine("<img src = `" + jName.ToLower() + ".svg" + "`>");
                    FoldingButtonEnd(sb);
                }

                if (true)
                {

                    StringBuilder sb3 = new StringBuilder();
                    sb3.AppendLine(bank1 + G.Blanks(30 - bank1.Length + gap) + bank2);
                    sb3.AppendLine();
                    sb3.AppendLine("Period        value        %  " + G.Blanks(gap) + "Period        value        %  ");
                    int counter = 0;
                    foreach (GekkoTime gt in new GekkoTimeIterator(print_start, print_end))
                    {
                        counter++;
                        if (hasFilter)  //some periods are set via TIMEFILTER
                        {
                            if (ShouldFilterPeriod(gt)) continue;
                        }

                        int counter2 = -1;
                        foreach (Series ts in new List<Series> { ts1, ts2 })
                        {
                            counter2++;
                            if (ts == null)
                            {
                                //ignore it
                            }
                            else
                            {
                                BrowserWritePrintLine(ts, sb3, gt);
                                if (counter2 == 0) sb3.Append(G.Blanks(gap + 1));
                            }
                        }

                        sb3.AppendLine();
                    }

                    WriteHtmlPreCode(sb, sb3.ToString());

                }

                StringBuilder x = new StringBuilder();
                x.AppendLine("<!DOCTYPE HTML PUBLIC `-//W3C//DTD HTML 4.01 Transitional//EN`>");
                x.AppendLine("<html>");
                x.AppendLine("  <head>");
                x.AppendLine("    <link rel=`stylesheet` href=`..\\" + settings_css_filename + @"` type=`text/css`>");
                x.AppendLine("    <link rel = `shortcut icon` href = `..\\" + settings_icon_filename + "` type = `image/vnd.microsoft.icon`>");
                x.AppendLine("    <meta http-equiv=`Content-Type` content=`text/html; charset=iso-8859-1`>");
                x.AppendLine("    <title>" + var + "</title>");
                x.AppendLine("  </head>");

                x.AppendLine("  <script LANGUAGE = `JavaScript`> <!--");
                x.AppendLine("  function hide(id) {");
                x.AppendLine("  var x = document.getElementById(`b` + id);");
                x.AppendLine("  if (x.style.display === `none`)");
                x.AppendLine("  {");
                x.AppendLine("      x.style.display = `block`; ");
                x.AppendLine("  }");
                x.AppendLine("   else");
                x.AppendLine("   {");
                x.AppendLine("      x.style.display = `none`; ");
                x.AppendLine("   }");
                x.AppendLine("  }");
                x.AppendLine("  // -->");
                x.AppendLine("  </script >");

                x.AppendLine("  <body>");
                x.Append(sb);
                x.AppendLine("  </body>");
                x.AppendLine("</html>");

                string pathAndFilename = subFolder + "\\" + var.ToLower() + ".html";
                using (FileStream fs = Program.WaitForFileStream(pathAndFilename, Program.GekkoFileReadOrWrite.Write))
                using (StreamWriter sw = G.GekkoStreamWriter(fs))
                {
                    sw.Write(x.Replace('`', '\"'));
                }
            }

            StringBuilder x2 = new StringBuilder();
            x2.AppendLine("<!DOCTYPE HTML PUBLIC `-//W3C//DTD HTML 4.01 Transitional//EN`>");
            x2.AppendLine("<html>");
            x2.AppendLine("  <head>");
            x2.AppendLine("    <link rel=`stylesheet` href=`" + settings_css_filename + "` type=`text/css`>");
            x2.AppendLine("    <link rel = `shortcut icon` href = `" + settings_icon_filename + "` type = `image/vnd.microsoft.icon`>");
            x2.AppendLine("    <meta http-equiv=`Content-Type` content=`text/html; charset=iso-8859-1`>");
            x2.AppendLine("    <title>List of vars</title>");
            x2.AppendLine("  </head>");
            x2.AppendLine("  <body>");
            //x2.AppendLine("  <p><big><b>SMECdok, take two. Søg i browseren med Ctrl+F (find)</b></big></p>");

            x2.AppendLine("  <table cellpadding = `0` cellspacing = `0` width = `1000px` border = `0`> ");
            x2.AppendLine("  <tr>");
            x2.AppendLine("  <td width = `70 %` ><b><big>" + list_title + "</big></b></td>");
            x2.AppendLine("  <td width = `10 %` ><a href = `" + settings_find_filename + "` > Søg </a></td >");
            x2.AppendLine("  <td width = `20 %` ><a href = `" + settings_index_filename + "` > Hjem </a></td >");
            x2.AppendLine("  </tr>");
            x2.AppendLine("  </table>");

            x2.AppendLine("  <p>&nbsp;</p>");

            x2.AppendLine("<table style = `width:100%`>");

            foreach (string var2 in vars)
            {
                List<string> varExpl = Program.GetVariableExplanation(var2);
                string expl = "";
                if (varExpl != null && varExpl.Count > 0) expl = Program.SpecialXmlChars(varExpl[0]);

                x2.Append("<tr>");
                x2.Append("<td width = `20%`>");
                x2.Append(HtmlLink(var2, settings_vars_foldername + "/" + var2.ToLower() + ".html"));
                x2.Append("</td>");
                x2.Append("<td width = `80%`>");
                x2.Append(expl);
                x2.Append("</td>");
                x2.Append("</tr>");
            }
            x2.AppendLine("</table>");

            x2.AppendLine("  </p>");
            x2.AppendLine("  </body>");
            x2.AppendLine("</html>");
            string pathAndFilename2 = rootFolder + "\\" + settings_list_filename;
            using (FileStream fs = Program.WaitForFileStream(pathAndFilename2, Program.GekkoFileReadOrWrite.Write))
            using (StreamWriter sw = G.GekkoStreamWriter(fs))
            {
                sw.Write(x2.Replace('`', '\"'));
            }


            // ----------------- find -------------------------------------

            vars2.Sort(StringComparer.OrdinalIgnoreCase);

            StringBuilder x3 = new StringBuilder();
            x3.AppendLine("<html>");
            x3.AppendLine("<head>");
            x3.AppendLine("<link rel = `stylesheet` href = `" + settings_css_filename + "` type = `text/css` >");
            x3.AppendLine("<link rel = `shortcut icon` href = `" + settings_icon_filename + "` type = `image/vnd.microsoft.icon`>");
            x3.AppendLine("</head>");

            //x3.AppendLine("<script LANGUAGE = `JavaScript` SRC = `variable.js` ></script>");
            x3.AppendLine("<script LANGUAGE = `JavaScript` > <!-- ");

            string s1 = null;
            string s2 = null;
            foreach (string s in vars2)
            {
                string[] ss = s.Split('¤');
                s1 += "`" + ss[0] + "`" + ", ";
                s2 += "`" + ss[1] + "`" + ", ";
            }

            string write = null;            
            string join = null;
            if (jsmFix)
            {
                write = "document.write";
            }
            else
            {
                write = "content.push";
                join = "document.body.innerHTML = content.join(``);";                
            }

            string js = @"

            function varnavns() {
                var varnavn = [" + s1.ToLower() + @"];
                return varnavn;
            }

            function beskrivs() {
                var beskriv = [" + s2 + @"];
                return beskriv;
            }

            function findvarnavn(){
                var content = [];
                var varnavn = varnavns();
                var beskriv = beskrivs();
                antal = varnavn.length;
                tekst = new String;
                tekst1 = new String;
                tekst = document.form1.tekst.value;
                fundet = false;

                " + write + @"(`Søgning efter variablen: '` + tekst + `'<br><br>`);

                for (var i = 0; i < antal; i++)
                {
                    tekst1 = varnavn[i];
                    if (tekst1.toUpperCase() == tekst.toUpperCase())
                    {
                        fundet = true;

                        " + write + @"(`<b><a href=" + settings_vars_foldername + @"/` + varnavn[i] + `.html style='text-decoration:none'>` + varnavn[i] + `</a></b>`);
                        " + write + @"(`<br>` + beskriv[i] + `<br><hr><br>`);
                    } //endif
                } //endfor

                for (var i = 0; i < antal; i++)
                {
                    tekst1 = varnavn[i];
                    if (tekst1.toUpperCase().indexOf(tekst.toUpperCase()) != -1)
                    {
                        if (tekst1.toUpperCase() != tekst.toUpperCase())
                        {
                            fundet = true;
                            " + write + @"(`<a href=" + settings_vars_foldername + @"/` + varnavn[i] + `.html style='text-decoration:none;'>` + varnavn[i] + `</a>`);
                            " + write + @"(`<br>` + beskriv[i] + `<br><br>`);
                        } //endif
                    } //endif
                } //endfor

                if (fundet == false)
                {
                    " + write + @"(`... gav intet resultat.<br>`);
                } //endif
                " + write + @"(`<br><br><a href=" + settings_find_filename + @">Søg igen</a> <br> <a href=" + settings_index_filename + @">Gå til hovedside</a>`);
                tekst1.free;
                tekst.free;
                " + join + @"
            }  //endfunction

            function check(event) {
            var charCode = (navigator.appName == `Netscape`) ? event.which : event.keyCode;
        if (charCode == 13) findvarnavn();
        }  // endfunction

        function findbeskriv()
        {
            var content = [];
            var varnavn = varnavns();
            var beskriv = beskrivs();
            antal = varnavn.length;
            tekst = new String;
            tekst2 = new String;
            tekst = document.form2.tekst.value;

            " + write + @"(`Søgeresultat<br>Søgning efter teksten: '` + tekst + `' i variabelliste<br><br>`);
            fundet = false;
            for (var i = 0; i < antal; i++)
            {
                tekst2 = beskriv[i];
                if (tekst2.toUpperCase().indexOf(tekst.toUpperCase()) != -1)
                {
                    fundet = true;
                    " + write + @"(`<b><a href=" + settings_vars_foldername + @"/` + varnavn[i] + `.html style='text-decoration:none'>` + varnavn[i] + `</a></b>`);
                    " + write + @"(`<br>` + beskriv[i] + `<br><br>`);
                } //endif
            } //endfor
            if (fundet == false)
            {
                " + write + @"(`... gav intet resultat.<br>`);
            } //endif
            " + write + @"(`<br><br><a href=" + settings_find_filename + @">Søg igen</a> <br> <a href=" + settings_index_filename + @">Gå til hovedside</a>`);
            tekst.free;
            tekst2.free;

            " + join + @"
        }  //endfunction

        function check2(event) {
            var charCode = (navigator.appName == `Netscape`) ? event.which : event.keyCode;
        if (charCode == 13) findbeskriv();
        }  // endfunction

        ";

            x3.AppendLine(js);
            x3.AppendLine("// -->");
            x3.AppendLine("</script>");
            x3.AppendLine("<body onload = `document.form1.tekst.focus()`>");
            x3.AppendLine("<table width=`100 % `><tr><td>");
            x3.AppendLine("<p><b>Indtast søgeord</b></p>");
            //x3.AppendLine("<p>Angiv mnemoteknisk variabelnavn eller foretag fritekstsøgning i variabelbeskrivelserne</p>");
            //x3.AppendLine("<p>&nbsp;</p>");
            x3.AppendLine("");
            x3.AppendLine("Søgning efter variabelnavn:");
            x3.AppendLine("<FORM NAME = `form1` >");
            x3.AppendLine("<INPUT NAME=`tekst` SIZE=`50` TYPE=`text` onKeyPress=`return check(event)`>");
            x3.AppendLine("<INPUT TYPE = `submit` VALUE=`Søg` onClick=`findvarnavn()`>");
            x3.AppendLine("</FORM>");
            x3.AppendLine("<p>&nbsp;</p>");
            x3.AppendLine("Fritekstsøgning i variabelbeskrivelserne:");
            x3.AppendLine("<FORM NAME = `form2`>");
            x3.AppendLine("<INPUT NAME=`tekst` SIZE=`50` TYPE=`text` onKeyPress=`return check2(event)`>");
            x3.AppendLine("<INPUT TYPE = `submit` VALUE=`Søg` onClick=`findbeskriv()`>");
            x3.AppendLine("</FORM></center>");
            x3.AppendLine("</td></tr></table>");
            x3.AppendLine("</body>");
            x3.AppendLine("</html>");

            string pathAndFilename3 = rootFolder + "\\" + settings_find_filename;
            using (FileStream fs = Program.WaitForFileStream(pathAndFilename3, Program.GekkoFileReadOrWrite.Write))
            using (StreamWriter sw = G.GekkoStreamWriter(fs))
            {
                sw.Write(x3.Replace('`', '\"'));
            }

            G.Writeln2("End of html browser generation, " + G.Seconds(dt0));

        }        

        private static void BrowserCleanupFolders(string rootFolder, string varsFolder)
        {
            List<string> folders = new List<string> { rootFolder, varsFolder };

            foreach (string folder in folders)
            {
                if (!Directory.Exists(folder))
                {
                    Directory.CreateDirectory(folder);
                }
                else
                {
                    string[] files = Directory.GetFiles(folder + "\\");
                    if (files.Length > 0)
                    {
                        if (!G.IsUnitTesting())
                        {
                            DialogResult result = MessageBox.Show("All " + files.Length + " files in '" + folder + "' will be deleted", "Gekko helper", MessageBoxButtons.YesNo, MessageBoxIcon.None, MessageBoxDefaultButton.Button1, MessageBoxOptions.DefaultDesktopOnly);
                            if (result == DialogResult.Yes)
                            {
                                //ok
                            }
                            else
                            {
                                G.Writeln2("*** ERROR: User abort");
                                throw new GekkoException();
                            }
                        }
                    }

                    foreach (string file in files)
                    {
                        File.Delete(file);
                    }
                }
            }
        }

        private static void FoldingButtonEnd(StringBuilder sb)
        {
            sb.AppendLine("</div>");
        }

        private static void FoldingButtonStart(StringBuilder sb, string buttonText)
        {
            int buttonId = Globals.foldingButtonCounter++;
            sb.AppendLine("<button onclick = `hide(" + buttonId + ")` style = `border-radius: 4px; padding: 4px; background-color: #009933; border: none; color: white; text-align: center; text-decoration: none; display: inline-block; font-size: 12px;  color:;`>" + buttonText + "</button>");
            sb.AppendLine("<div id = `b" + buttonId + "` style = `display: none;`>");
        }

        private static GekkoDictionary<string, List<string>> BrowserDataGenerationExtract()
        {
            GekkoDictionary<string, List<string>> datagen = new GekkoDictionary<string, List<string>>(StringComparer.OrdinalIgnoreCase);

            string genr = Program.GetTextFromFileWithWait(Program.options.folder_working + "\\" + "genr.gcm");

            int fat = 3;            
            var tags1 = new List<Tuple<string, string>>() { new Tuple<string, string>("/*", "*/") };
            var tags2 = new List<string>() { "//" };
            List<TokenHelper> a = StringTokenizer2.GetTokensWithLeftBlanks(genr, fat, tags1, tags2, null, null).storage;            
            //List<TokenHelper> a = Program.GetTokensWithLeftBlanks(genr, fat, true);

            List<List<TokenHelper>> statements = new List<List<TokenHelper>>();

            int n = a.Count - fat;
            int start = 0;
            for (int i = 0; i < n; i++)
            {
                for (int ii = i; ii < n; ii++)
                {
                    if (a[ii].s == ";")
                    {
                        int i1 = i; //start token, may be EOL
                        for (int iii = i; iii <= ii; iii++)
                        {
                            if (a[iii].type != ETokenType.EOL && a[iii].type != ETokenType.Comment)
                            {
                                i1 = iii;
                                break;
                            }
                        }

                        int i2 = ii;  //end token, will be ';'

                        List<TokenHelper> th = new List<TokenHelper>();
                        for (int i3 = i1; i3 <= i2; i3++)
                        {
                            if (a[i3].s == null || a[i3].s == "") continue;
                            th.Add(a[i3]);
                        }
                        th.Add(new TokenHelper());
                        th.Add(new TokenHelper());
                        th.Add(new TokenHelper());
                        statements.Add(th);

                        i = ii;
                        break;
                    }
                }
            }

            for (int j = 0; j < statements.Count; j++)
            {
                List<TokenHelper> th = statements[j];

                if (IsNonSeriesStatement(th))
                {
                    continue;
                }

                Tuple<int, int> opt = StringTokenizer2.FindOptionFieldInSeriesAssignment(th);
                int hasSeriesKeyword = 0;
                if (G.Equal(th[0].s, "ser") || G.Equal(th[0].s, "series")) hasSeriesKeyword = 1;
                string temp = null;
                int nameStart = -12345;
                int nameEnd = -12345;
                if (opt.Item1 == -12345)
                {
                    //no option field, "x = 1" OR "ser x = 1"
                    //if we start at hasSeriesKeyword, it is: "x = 1"
                    nameStart = hasSeriesKeyword;
                    nameEnd = StringTokenizer2.FindS(th, nameStart + 1, "=");
                    if (nameEnd != -12345) nameEnd--;
                }
                else
                {
                    //option field, "<...> x = 1" OR "x <...> = 1" OR "ser <...> x = 1" OR "ser x <...> = 1"
                    //if we start at hasSeriesKeyword, it is: "<...> x = 1" OR "x <...> = 1"
                    if (th[hasSeriesKeyword].s == "<")
                    {
                        //option field before variable, for instance <...> x =  OR series <...> x = 
                        nameStart = opt.Item2 + 1;
                        nameEnd = StringTokenizer2.FindS(th, nameStart + 1, "=");
                        if (nameEnd != -12345) nameEnd--;
                    }
                    else
                    {
                        //option field after variable, for instance x <...> = OR series x <...> = 
                        nameStart = hasSeriesKeyword;
                        nameEnd = StringTokenizer2.FindS(th, nameStart + 1, "<");
                        if (nameEnd != -12345) nameEnd--;
                    }
                }

                if (nameStart != -12345 && nameEnd != -12345)
                {
                    bool lhsFunction = false;
                    if (nameEnd > nameStart + 1 && G.Equal(th[nameStart + 1].s, "(") && th[nameStart + 1].leftblanks == 0 && G.Equal(th[nameEnd].s, ")"))
                    {
                        if (G.Equal(th[nameStart].s, "log") || G.Equal(th[nameStart].s, "dlog") || G.Equal(th[nameStart].s, "dif") || G.Equal(th[nameStart].s, "diff"))
                        {
                            lhsFunction = true;
                            nameStart += 2;
                            nameEnd--;
                        }
                    }

                    if (nameStart == nameEnd && th[nameStart].type == ETokenType.Word)
                    {
                        //simple name
                        string name = th[nameStart].s;
                        string s3 = GetTextFromLeftBlanksTokens(th, 0, th.Count - 1).Trim();
                        BrowserAddItem(datagen, name.Trim(), s3.Trim());
                    }
                    else
                    {
                        //may be a composed name like x%i, x{%i}, x{i} or x[2000]

                        if (true)
                        {
                            //finding scalar vars in lhs name
                            GekkoDictionary<string, List<string>> scalarsOnLhsInSerStatement = new GekkoDictionary<string, List<string>>(StringComparer.OrdinalIgnoreCase);
                            for (int i = nameStart; i <= nameEnd; i++)
                            {
                                string mem = null;
                                if (BrowserIsScalar(th, i))
                                {
                                    //a%i or a{%i} or a{i}
                                    scalarsOnLhsInSerStatement.Add(th[i + 1].s, null);
                                }
                            }

                            //finding lists corresponding to scalar names

                            for (int jj = j - 1; jj >= 0; jj--)
                            {
                                List<TokenHelper> th2 = statements[jj];
                                if (G.Equal(th2[0].s, "for") && G.Equal(th2[1].s, "string") && th2[2].s == "%" && th2[3].type == ETokenType.Word && th2[4].s == "=" && scalarsOnLhsInSerStatement.ContainsKey(th2[3].s))
                                {
                                    //We have found the definition of one of the scalars in the lhs SERIES name.
                                    List<string> rhsVars = new List<string>();
                                    for (int i2 = 5; i2 < th2.Count; i2++)
                                    {
                                        if ((th2[i2].type == ETokenType.Word || th2[i2].type == ETokenType.QuotedString) && (th2[i2 + 1].s == "," || th2[i2 + 1].s == ";"))
                                        {
                                            rhsVars.Add(G.StripQuotes(th2[i2].s));
                                        }
                                    }
                                    scalarsOnLhsInSerStatement[th2[3].s] = rhsVars;
                                }
                            }

                            List<KeyValuePair<string, List<string>>> xx = new List<KeyValuePair<string, List<string>>>();
                            foreach (KeyValuePair<string, List<string>> xxx in scalarsOnLhsInSerStatement) xx.Add(xxx);

                            if (scalarsOnLhsInSerStatement.Count == 0)
                            {
                                //probably nothing to add, complicated name but no scalars found, for instance fy[2000] = ...
                                string name = th[nameStart].s;
                                string s3 = GetTextFromLeftBlanksTokens(th, 0, th.Count - 1).Trim();
                                BrowserAddItem(datagen, name.Trim(), s3.Trim());
                            }
                            else if (scalarsOnLhsInSerStatement.Count == 1 && xx[0].Value != null)
                            {
                                foreach (string listItem in xx[0].Value)
                                {

                                    string s7 = null;
                                    for (int i = nameStart; i <= nameEnd; i++)
                                    {
                                        if (th[i].s == "{" && th[i + 1].s == Globals.symbolScalar.ToString() && th[i + 2].type == ETokenType.Word && th[i + 2].leftblanks == 0 && th[i + 3].s == "}" && G.Equal(th[i + 2].s, xx[0].Key))
                                        {
                                            s7 += listItem;  //no blanks
                                            i += 3;
                                        }
                                        else
                                        {
                                            s7 += th[i].s;
                                        }
                                    }

                                    string s8 = null;
                                    for (int i = 0; i < th.Count; i++)
                                    {
                                        if (th[i].s == "{" && th[i + 1].s == Globals.symbolScalar.ToString() && th[i + 2].type == ETokenType.Word && th[i + 2].leftblanks == 0 && th[i + 3].s == "}" && G.Equal(th[i + 2].s, xx[0].Key))
                                        {
                                            s8 += G.Blanks(th[i].leftblanks) + listItem;  //with blanks
                                            i += 3;
                                        }
                                        else
                                        {
                                            s8 += G.Blanks(th[i].leftblanks) + th[i].s;
                                        }
                                    }

                                    BrowserAddItem(datagen, s7.Trim(), s8.Trim());
                                }
                            }
                            else
                            {
                                //G.Writeln2("*** ERROR: Nested FOR not supported yet");
                                //throw new GekkoException();
                            }
                        }
                    }
                }
            }            
            return datagen;
        }

        public static bool IsNonSeriesStatement(List<TokenHelper> th)
        {
            return !G.Equal(th[0].s, "ser") && !G.Equal(th[0].s, "series") && Globals.commandNames.Contains(th[0].s, StringComparer.OrdinalIgnoreCase);
        }

        private static void BrowserAddItem(GekkoDictionary<string, List<string>> datagen, string name, string s3)
        {
            string[] ss = name.Split('[');
            if (ss.Length > 1) name = ss[0];

            if (datagen.ContainsKey(name))
            {
                datagen[name].Add(s3);
            }
            else
            {
                datagen.Add(name, new List<string>() { s3 });
            }
        }

        private static bool BrowserIsScalar(List<TokenHelper> th, int i)
        {
            //if token i+1 is a scalar name, %i or {i}
            if ((th[i].s == Globals.symbolScalar.ToString() && th[i + 1].type == ETokenType.Word && th[i + 1].leftblanks == 0) || (th[i].s == "{" && th[i + 1].type == ETokenType.Word && th[i + 2].s == "}"))
            {
                return true;
            }
            return false;
        }

        private static string GetTextFromLeftBlanksTokens(List<TokenHelper> a, int a1, int a2)
        {
            string s2 = null;
            for (int i = a1; i <= a2; i++)
            {
                s2 += G.Blanks(a[i].leftblanks) + a[i].s;
            }

            return s2;
        }

        private static void BrowserWritePrintLine(Series ts, StringBuilder sb3, GekkoTime gt)
        {
            if (Program.options.freq == EFreq.A) sb3.Append((gt.super) + " ");
            else sb3.Append(gt.super + ts.freq.ToString() + gt.sub + " ");

            double n1 = ts.GetDataSimple(gt);
            double n0 = ts.GetDataSimple(gt.Add(-1));

            double level1 = n1;
            double pch1 = ((n1 / n0 - 1) * 100d);

            if (n1 == n0) pch1 = 0d;

            string levelFormatted;
            string pchFormatted;
            Program.ConvertToPrintFormat(level1, pch1, out levelFormatted, out pchFormatted);

            sb3.Append(levelFormatted + " " + pchFormatted + " ");
        }

        private static void WriteHtmlPreCode(StringBuilder sb, string sb2)
        {
            sb.Append("<pre><code>"); sb.Append(sb2); sb.Append("</code></pre>");
        }

        private static void InsertLinksIntoEquation(string equationText, bool html, StringBuilder sb)
        {
            int widthRemember = -12345;
            int fileWidthRemember = -12345;
            if (!html)
            {
                widthRemember = Program.options.print_width;
                fileWidthRemember = Program.options.print_filewidth;
                Program.options.print_width = int.MaxValue;
                Program.options.print_filewidth = int.MaxValue;
            }
            try
            {
                int fat = 20;                
                List<TokenHelper> a = StringTokenizer2.GetTokensWithLeftBlanks(equationText, fat, null, null, null, null).storage;
                //List<TokenHelper> a = GetTokensWithLeftBlanks(equationText, 20, false);

                int counter = -1;
                for (int i = 0; i < a.Count; i++)
                {
                    
                    counter++;
                    //string s = tokens[i].s;
                    //if (s == "£") G.Writeln();


                    if (a[i].leftblanks > 0)
                    {
                        if (!html)
                        {
                            G.Write(G.Blanks(a[i].leftblanks));
                        }
                        else
                        {
                            sb.Append(G.Blanks(a[i].leftblanks));
                        }
                    }
                    if (counter > 1 && a[i].type == ETokenType.Word && Program.model.modelGekko.varsAType.ContainsKey(a[i].s))
                    {
                        if (!html)
                        {
                            G.WriteLink(a[i].s, "disp:" + a[i].s);
                        }
                        else
                        {
                            sb.Append(HtmlLink(a[i].s));
                        }
                    }
                    else
                    {
                        if (!html)
                        {
                            G.Write(a[i].s);
                        }
                        else
                        {
                            sb.Append(a[i].s);
                        }
                    }

                }
                if (!html)
                {
                    G.Writeln();
                }
            }
            finally
            {
                if (!html)
                {
                    //resetting, also if there is an error
                    Program.options.print_width = widthRemember;
                    Program.options.print_filewidth = fileWidthRemember;
                }
            }
        }

        private static string HtmlLink(string txt)
        {
            return HtmlLink(txt, txt.ToLower() + ".html");
        }

        private static string HtmlLink(string txt, string link)
        {
            return "<a href = \"" + link + "\" >" + txt + "</a>";
        }

        // BROWSER END


        public static List<string> MatchRangeInDatabank(string s1, string s2, Databank db)
        {
            List<string> input = new List<string>();
            input.AddRange(db.storage.Keys);
            string endsWith = null;
            if (Program.options.freq != EFreq.A) endsWith = Globals.freqIndicator + G.GetFreq(Program.options.freq);
            List<IVariable> m = new List<IVariable>();
            foreach (string s in input) m.Add(new ScalarString(s));
            List<string> temp = Program.MatchRange(s1, s2, m, endsWith);
            return temp;
        }

        public static List<string> MatchRange(string s1, string s2, List<IVariable> input, string endsWith)
        {
            List<string> temp = new List<string>();
            if (endsWith == null)
            {
                foreach (IVariable iv in input)
                {
                    string s = O.ConvertToString(iv);
                    if (string.Compare(s, s1, true) >= 0 && string.Compare(s, s2, true) <= 0)
                    {
                        temp.Add(s);
                    }
                }
            }
            else
            {
                foreach (IVariable iv in input)
                {
                    string s = O.ConvertToString(iv);
                    if (!s.EndsWith(endsWith)) continue;
                    string ss = s.Substring(0, s.Length - endsWith.Length);
                    if (string.Compare(ss, s1, true) >= 0 && string.Compare(ss, s2, true) <= 0)
                    {
                        temp.Add(ss);
                    }
                }
            }
            temp.Sort(StringComparer.OrdinalIgnoreCase);
            return temp;
        }
        

        public static void MaybePlaySound(P p)
        {
            if (Program.options.interface_sound == false) return;
            if (p.hasBeenCmdFile == false) return;
            //if (p.hasBeenIsstartCmdFile == true) return;
            int sec = Program.options.interface_sound_wait;
            if ((DateTime.Now - p.timeAtLastUserInteraction).TotalMilliseconds / 1000d > (double)sec)
            {
                PlaySound();
                p.timeAtLastUserInteraction = DateTime.Now;
            }
        }

        public static void PlaySound()
        {
            System.Media.SoundPlayer simpleSound = new System.Media.SoundPlayer(Application.StartupPath + "\\images\\" + Program.options.interface_sound_type + ".wav");
            simpleSound.Play();
        }

        public static void ShowPeriodInStatusField(string s)
        {
            if (G.IsUnitTesting()) return;

            string s1 = "";
            //TODO: make a smart trim procedure
            if (s.Length > 90)
            {
                s1 = s.Remove(88);
                s1 += "...";
            }
            else
            {
                s1 = s;
            }

            string start = "";
            string end = "";

            start = G.FromDateToString(Globals.globalPeriodStart);
            end = G.FromDateToString(Globals.globalPeriodEnd);

            string f = G.GetFreqString();

            string workingFolder = "";
            string banks = "";
            if (s1.Equals(""))
            {
                int wCount = Program.databanks.GetFirst().storage.Count;
                int rCount = Program.databanks.GetRef().storage.Count;
                string originalDataFileWork = "[empty]";
                string originalDataFileBaseline = "[empty]";
                string w = GetDatabankFileNameWithPath(Program.databanks.GetFirst());
                string b = GetDatabankFileNameWithPath(Program.databanks.GetRef());
                if (w != null) originalDataFileWork = w;
                if (b != null) originalDataFileBaseline = b;
                string banks1 = "";
                string banks2 = "";

                if (originalDataFileWork != "") banks1 = originalDataFileWork;
                try
                {
                    banks1 = Path.GetFileName(banks1);
                }
                catch { }
                if (banks1.EndsWith(".tsd", StringComparison.OrdinalIgnoreCase)) banks1 = banks1.Substring(0, banks1.Length - ".tsd".Length);
                if (banks1.EndsWith("." + Globals.extensionDatabank, StringComparison.OrdinalIgnoreCase)) banks1 = banks1.Substring(0, banks1.Length - Globals.extensionDatabank.Length - 1);
                //TODO: make a smart trim procedure

                if (banks1.Length > 30)
                {
                    string ss1 = banks1.Substring(0, 17);
                    string ss2 = banks1.Substring(banks1.Length - 10);
                    banks1 = ss1 + "..." + ss2;
                }
                if (originalDataFileBaseline != "") banks2 = originalDataFileBaseline;
                try
                {
                    banks2 = Path.GetFileName(banks2);
                }
                catch { }
                if (banks2.EndsWith(".tsd", StringComparison.OrdinalIgnoreCase)) banks2 = banks2.Substring(0, banks2.Length - 4);
                if (banks2.EndsWith("." + Globals.extensionDatabank, StringComparison.OrdinalIgnoreCase)) banks2 = banks2.Substring(0, banks2.Length - Globals.extensionDatabank.Length - 1);
                if (banks2.Length > 30)
                {
                    string ss1 = banks2.Substring(0, 17);
                    string ss2 = banks2.Substring(banks2.Length - 10);
                    banks2 = ss1 + "..." + ss2;

                }

                if (wCount == 0) banks1 = "[empty]";
                if (rCount == 0) banks2 = "[empty]";

                if (banks1 == "[empty]" && banks2 == "[empty]")
                {
                    banks = "";
                }
                else if (banks2 == "[empty]")
                {
                    banks = "    |    First: " + banks1;
                }
                else
                {
                    banks = "    |    First: " + banks1 + "    |    " + "Ref" + ": " + banks2;
                }

                workingFolder = Program.options.folder_working;

            }

            //========================================================================================================
            //                          FREQUENCY LOCATION, indicates where to implement more frequencies
            //========================================================================================================
            string ss = "Period: " + f + " " + start + "-" + end + G.NL + "First: " + GetDatabankFileNameWithPath(Program.databanks.GetFirst()) + G.NL + "" + Globals.Ref + ": " + GetDatabankFileNameWithPath(Program.databanks.GetRef()) + G.NL + "Working folder: " + Program.options.folder_working + G.NL + "Mode: " + Program.options.interface_mode;

            if (ss != Gui.gui.toolStripStatusLabel1.ToolTipText) Gui.gui.toolStripStatusLabel1.ToolTipText = ss;

            if (Globals.workerThread != null)
            {
                string ss2 = f + " " + start + "-" + end + banks + "    |    " + workingFolder;
                WorkerThreadHelper1 wh = new WorkerThreadHelper1();                
                wh.statusField = ss2;
                Globals.workerThread.gekkoGui.Invoke(Globals.workerThread.gekkoGui.threadDelegateSetTitle, wh);
            }

            int i = 0; 
            foreach (Graph g in Globals.windowsGraph)
            {
                i++;
            }
            foreach (Window1 g in Globals.windowsDecomp)
            {
                i++;
            }            
            CrossThreadStuff.CutButtonEnabled(i > 0);
        }

        private static string GetDatabankFileNameWithPath(Databank bank)
        {
            string fileName = "[no bank filename]";
            if (bank != null)
            {
                fileName = bank.FileNameWithPath;
            }
            return fileName;
        }

        
        public static void WriteErrorMessage(int lineNumber, string problemLine, string text, string fileName)
        {
            if (Globals.threadIsInProcessOfAborting) return;
            G.Writeln(text, Color.Red, true);  //will also be red for a STOP command, but without counting as an error
            G.Writeln("    " + "[" + G.IntFormat(lineNumber, 4) + "]:" + "   " + G.ReplaceGlueNew(problemLine), Color.Blue, true);
        }

        private static string GetOriginalTableFileName(string fileName)
        {
            string s2 = "";
            if (fileName.Contains("tablecode." + Globals.defaultCommandFileExtension))
            {
                string s = GetTextFromFileWithWait(fileName);
                List<string> ss = G.ExtractLinesFromText(s);
                s2 = ss[2];
                s2 = s2.Replace(Globals.tableConverterText3, "");
                //G.Writeln("*** ERROR: The original table filename: " + s2);
            }
            return s2;
        }
                

        public static void Unfix(Databank databank, string endoOrExoPrefix)
        {
            List<string> delete = new List<string>();
            foreach (KeyValuePair<string, IVariable> kvp in databank.storage)
            {
                if (kvp.Key.StartsWith(endoOrExoPrefix + "_", StringComparison.OrdinalIgnoreCase) && kvp.Key.EndsWith(Globals.freqIndicator + G.GetFreq(Program.options.freq), StringComparison.OrdinalIgnoreCase))
                {
                    //starts with endo_ or exo_ and is of annual type
                    delete.Add(kvp.Key);
                }
            }
            int count = 0;
            foreach (string s in delete)
            {
                databank.RemoveIVariable(s);
                count++;
            }
            if(count > 0) G.Writeln2("Removed " + count + " " + endoOrExoPrefix + "_... variables");
        }

        public static void Unfix()  //formerly ClearGoals()
        {
            if (G.Equal(Program.options.model_type, "gams"))            
            {
                Unfix(Program.databanks.GetFirst(), "endo");
                Unfix(Program.databanks.GetFirst(), "exo");
            }
            else
            {

                if (G.HasModelGekko())
                {
                    if (Program.model.modelGekko.exogenized.Count == 0 && Program.model.modelGekko.endogenized.Count == 0)
                    {
                        G.Writeln2("No goals are set, so nothing to unfix");
                    }
                    else
                    {
                        string s = "Unfixed/cleared ";
                        if (Program.model.modelGekko.exogenized != null)
                        {
                            s += Program.model.modelGekko.exogenized.Count + " EXO and ";
                        }
                        if (Program.model.modelGekko.endogenized != null)
                        {
                            s += Program.model.modelGekko.endogenized.Count + " ENDO variables.";
                        }
                        Endo(null);  //--> better than clearing as above, since hasBeenEndoExoStatementsSinceLastSim flag is set
                        Exo(null);
                        G.Writeln2(s);
                        G.Writeln("Please note that only SIM<fix> (and not SIM) enforces the ENDO/EXO goals");
                    }
                }
                else
                {
                    G.Writeln2("No model defined -- not possible to clear/unfix goals");
                }
            }
        }

        public static void Sign()
        {
            StringBuilder sb = new StringBuilder();
            if (!G.HasModelGekko())
            {
                G.Writeln2("*** ERROR: It seems no model is defined. See MODEL command.");
                throw new GekkoException();
            }
            if (Program.model.modelGekko.signatureStatus == ESignatureStatus.SignatureNotFoundInModelFile)
            {
                sb.AppendLine();
                sb.AppendLine("You may add a signature to the model file by means of");
                sb.AppendLine("the following line somewhere in the beginning of the model file:");
                sb.AppendLine();
                sb.AppendLine("  // Signature: " + Program.model.modelGekko.modelHashTrue);
                sb.AppendLine();
                sb.AppendLine("NOTE: You may use '()' instead of '//'.");
            }
            if (Program.model.modelGekko.signatureStatus == ESignatureStatus.SignaturesDoNotMatch)
            {
                sb.AppendLine();
                sb.AppendLine("You may (a) revert the model equations back to their original state,");
                sb.AppendLine("or (b) insert the true hash code as a new signature in the model file.");
            }
            if (true)
            {
                sb.AppendLine();
                sb.AppendLine("The signature is a so-called MD5 hash code, that is, a string of");
                sb.AppendLine("characters representing the whole model file. The hash code can be");
                sb.AppendLine("thought of as a check-sum or fingerprint.");
                sb.AppendLine();
                sb.AppendLine("When computing the hash code, Gekko ignores any empty lines, or");
                sb.AppendLine("lines starting with the comment symbol ('//' or '()'). So you");
                sb.AppendLine("may add or remove (whole-line) commentaries as you like, without ");
                sb.AppendLine("altering the hash code, but changing or reordering the equations");
                sb.AppendLine("in any way will result in a new hash code.");
                sb.AppendLine();
                sb.AppendLine("Any variable list after the VARLIST$ or VARLIST; tag will also be ignored");
                sb.AppendLine("when computing the hash code.");
            }
            LinkContainer lc = new LinkContainer(sb.ToString());
            Globals.linkContainer.Add(lc.counter, lc);

            G.Writeln();
            string s = Program.model.modelGekko.signatureFoundInFileHeader;
            if (Program.model.modelGekko.signatureStatus == ESignatureStatus.SignatureNotFoundInModelFile)
            {
                s = "[not found]";
                G.Write("No signature was found in model file");
            }
            else if (Program.model.modelGekko.signatureStatus == ESignatureStatus.Ok)
            {
                G.Write("The signature matches the true hash code of the model file");
            }
            else if (Program.model.modelGekko.signatureStatus == ESignatureStatus.SignaturesDoNotMatch)
            {
                G.Write("The signature does not match the true hash code of the model file");
            }
            G.Write(" ("); G.WriteLink("more", "outputtab:" + lc.counter); G.Write(")"); G.Writeln();
            G.Writeln("- Signature in model file      : " + s);
            G.Writeln("- True model file hash code    : " + Program.model.modelGekko.modelHashTrue);
        }

        public static void Unswap(bool print)
        {
            Databanks.Unswap();
        }

        public static void Unswap()
        {
            Unswap(true);
        }

        private class ArrayComparer : IEqualityComparer<string[]>
        {
            public bool Equals(string[] item1, string[] item2)
            {
                if (item1[0] == item2[0] && item1[1] == item2[1] && item1[2] == item2[2] && item1[3] == item2[3])
                {
                    return true;
                }
                else
                {
                    return false;
                }
            }


            public int GetHashCode(string[] item)
            {
                return item[0].GetHashCode();
            }
        }
        
        private static string GetRhomeWin32NT(StringBuilder logger)
        {
            RegistryKey rCoreKey = GetRCoreRegistryKeyWin32(logger);
            return GetRInstallPathFromRCoreKegKey(rCoreKey, logger);
        }

        private static string RecurseFirstSubkey(RegistryKey rCoreKey, StringBuilder logger)
        {
            string[] subKeyNames = rCoreKey.GetSubKeyNames();
            if (subKeyNames.Length > 0)
            {
                var versionNum = subKeyNames.First();
                var rVersionCoreKey = rCoreKey.OpenSubKey(versionNum);
                //doLogSetEnvVarInfo("As a last resort, trying to recurse into " + rVersionCoreKey, logger);
                return GetRInstallPathFromRCoreKegKey(rVersionCoreKey, logger);
            }
            else
            {
                //doLogSetEnvVarWarn("No sub-key found under " + rCoreKey, logger);
                return null;
            }
        }
        
        public static void GetVersionAndGekkoExeLocationFromAssembly()
        {
            try
            {
                string version = Assembly.GetExecutingAssembly().GetName().Version.ToString();
                if (version.EndsWith(".0"))
                {
                    version = version.Substring(0, version.Length - 2);
                }
                Globals.gekkoVersion = version;
                string path = Assembly.GetExecutingAssembly().Location; 
                Globals.gekkoExePath = path;
            }
            catch (Exception e) { };
        }


        public static string IsJit()
        {
            var HasDebuggableAttribute = false;
            var IsJITOptimized = false;
            var IsJITTrackingEnabled = false;
            var BuildType = "";
            var DebugOutput = "";

            Assembly ReflectedAssembly = null;

            try
            {
                ReflectedAssembly = Assembly.LoadFile(Globals.gekkoExePath);
            }
            catch (Exception e)
            {

            }

            //	var ReflectedAssembly = Assembly.LoadFile(@"path to the dll you are testing");
            object[] attribs = ReflectedAssembly.GetCustomAttributes(typeof(DebuggableAttribute), false);

            // If the 'DebuggableAttribute' is not found then it is definitely an OPTIMIZED build
            if (attribs.Length > 0)
            {
                // Just because the 'DebuggableAttribute' is found doesn't necessarily mean
                // it's a DEBUG build; we have to check the JIT Optimization flag
                // i.e. it could have the "generate PDB" checked but have JIT Optimization enabled
                DebuggableAttribute debuggableAttribute = attribs[0] as DebuggableAttribute;
                if (debuggableAttribute != null)
                {
                    HasDebuggableAttribute = true;
                    IsJITOptimized = !debuggableAttribute.IsJITOptimizerDisabled;

                    // IsJITTrackingEnabled - Gets a value that indicates whether the runtime will track information during code generation for the debugger.
                    IsJITTrackingEnabled = debuggableAttribute.IsJITTrackingEnabled;
                    BuildType = debuggableAttribute.IsJITOptimizerDisabled ? "Debug" : "Release";

                    // check for Debug Output "full" or "pdb-only"
                    DebugOutput = (debuggableAttribute.DebuggingFlags &
                                    DebuggableAttribute.DebuggingModes.Default) !=
                                    DebuggableAttribute.DebuggingModes.None
                                    ? "Full" : "pdb-only";
                }
            }
            else
            {
                IsJITOptimized = true;
                BuildType = "Release";
            }

            string s = null;

            s += G.NL;
            s += "----- ONLY ON TT COMPUTER -----------------" + G.NL;
            s += $"{nameof(HasDebuggableAttribute)}: {HasDebuggableAttribute}" + " (not grave if True)" + G.NL;
            s += $"{nameof(IsJITOptimized)}: {IsJITOptimized}" + " (TT: should be True)" + G.NL;
            s += $"{nameof(IsJITTrackingEnabled)}: {IsJITTrackingEnabled}" + " (TT: should be False)" + G.NL;
            s += $"{nameof(BuildType)}: {BuildType}" + " (TT: should be Release)" + G.NL;
            s += $"{nameof(DebugOutput)}: {DebugOutput}" + G.NL;
            s += "--> See also the DumpBin() method (unused) that can check files" + G.NL;

            s += "-------------------------------------------" + G.NL;            

            return s;
        }

        public static void TestRam(bool read)
        {

            if (true)
            {
                //with 32 bit around:                2.81 mio m chunks = 100 --> 281 mio 32 bits (4 bytes) --> 1.12 GB. 
                //with 32 bit large-ram-aware about: 6.21 RamLargeAware                                    --> 2.48 GB
                //with 64 bit it probably uses pagefile, got all the way up to around 40 mio chunks        --> 16 GB...
                //     However, 64-bit got SLOW fast, so probably needs tuning regarding page file. 

                G.Writeln(Get64Bitness());

                int ii = 0;
                //memory test to test 64-bit versions

                int chunk = 100;
                int i_report = 100000000 / 4 / chunk;  //100 MB

                //chunk = 3;
                //i_report = 4;

                DateTime t = DateTime.Now;
                LinkedList<List<int>> list = new LinkedList<List<int>>();
                try
                {
                    for (int i = 0; i < int.MaxValue; i++)
                    {

                        List<int> temp = new List<int>(chunk);
                        for (int i2 = 0; i2 < chunk; i2++)
                        {
                            temp.Add(i2);  //from 0...99
                        }

                        list.AddLast(temp);
                        if (i % i_report == 0)
                        {
                            double gb = (double)(chunk * 4) * (double)i / 1e9d;
                            G.Writeln("GB = " + gb + " ----> write ram = " + G.Seconds(t));
                            t = DateTime.Now;

                            if (read)
                            {
                                double d = 0d;
                                //double d2 = 0d;

                                foreach (List<int> temp2 in list)
                                {
                                    foreach (int temp3 in temp2)
                                    {
                                        d += (double)temp3;
                                        //d2 += 1d;
                                    }
                                }
                                //if 1 chunk runs from i1-i2 (inclusive), we get sum = (i2-i1+1)*(i1+i2)/2
                                double check = (double)(i + 1) * (double)chunk * ((double)chunk - 1) / 2;

                                G.Writeln("     Reading test: " + (d - check) + " == 0 ----> read ram = " + G.Seconds(t) + " ... per GB = " + Math.Round((DateTime.Now - t).TotalMilliseconds / 1000d / gb, 2));
                                //G.Writeln("     Test   " + d2 + "   " + d2 * 4d / 1e9d);  //just a test that the GB are correctly calculated

                                t = DateTime.Now;
                            }


                        }
                        ii = i;
                    }
                }
                catch (Exception e)
                {
                    if (Globals.threadIsInProcessOfAborting || Globals.applicationIsInProcessOfAborting)
                    {
                        MessageBox.Show("+++ NOTE: Hard abort of memory test");
                    }
                    else
                    {
                        MessageBox.Show("+++ NOTE: Memory test ran out of memory (not unexpected)");
                    }
                    //MessageBox.Show("ii = " + ii + ", chunk = " + chunk + ", " + Ex.Message + " " + Ex.InnerException);
                    //Microsoft.VisualBasic.Devices.ComputerInfo CI = new ComputerInfo();
                    //Console.WriteLine(CI.AvailablePhysicalMemory);
                }
            }
        }

        public static List<string> DumpBin()
        {
            List<string> rv = new List<string>();
            string s = @"call ""c:\Program Files(x86)\Microsoft Visual Studio\2017\Community\VC\Tools\MSVC\14.16.27023\bin\Hostx64\x64\dumpbin"" /headers *.exe | findstr ""machine Dump"" > dumpbin.txt";  //fethces lines with either "machine" or "Dump"
            return rv;
        }

        public static string Get64Bitness()
        {
            string s = null;
            if (Environment.Is64BitProcess) s = "64-bit process on ";
            else s = "32-bit process on ";
            if (Environment.Is64BitOperatingSystem) s += "64-bit operating system";
            else s += "32-bit operating system";
            return s;
        }

        private static string GetRCurrentVersionStringFromRegistry(RegistryKey rCoreKey)
        {
            return rCoreKey.GetValue("Current Version") as string;
        }

        private static string GetRInstallPathFromRCoreKegKey(RegistryKey rCoreKey, StringBuilder logger)
        {
            string installPath = null;
            string[] subKeyNames = rCoreKey.GetSubKeyNames();
            string[] valueNames = rCoreKey.GetValueNames();
            if (valueNames.Length == 0)
            {
                //doLogSetEnvVarWarn("Did not find any value names under " + rCoreKey, logger);
                return RecurseFirstSubkey(rCoreKey, logger);
            }
            else
            {
                const string installPathKey = "InstallPath";
                if (valueNames.Contains(installPathKey))
                {
                    //doLogSetEnvVarInfo("Found sub-key InstallPath under " + rCoreKey, logger);
                    installPath = (string)rCoreKey.GetValue(installPathKey);
                }
                else
                {
                    //doLogSetEnvVarInfo("Did not find sub-key InstallPath under " + rCoreKey, logger);
                    if (valueNames.Contains("Current Version"))
                    {
                        //doLogSetEnvVarInfo("Found sub-key Current Version under " + rCoreKey, logger);
                        string currentVersion = GetRCurrentVersionStringFromRegistry(rCoreKey);
                        if (subKeyNames.Contains(currentVersion))
                        {
                            var rVersionCoreKey = rCoreKey.OpenSubKey(currentVersion);
                            return GetRInstallPathFromRCoreKegKey(rVersionCoreKey, logger);
                        }
                        else
                        {
                            //doLogSetEnvVarWarn("Sub key " + currentVersion + " not found in " + rCoreKey, logger);
                        }
                    }
                    else
                    {
                        //doLogSetEnvVarInfo("Did not find sub-key Current Version under " + rCoreKey, logger);
                        return RecurseFirstSubkey(rCoreKey, logger);
                    }
                }
            }
            //doLogSetEnvVarInfo(string.Format("InstallPath value of key " + rCoreKey.ToString() + ": {0}",
            // installPath == null ? "null" : installPath), logger);
            return installPath;
        }

        private static void CheckPlatformWin32()
        {
            if (Environment.OSVersion.Platform != PlatformID.Win32NT)
                throw new NotSupportedException("This method is supported only on the Win32NT platform");
        }

        private static RegistryKey GetRCoreRegistryKeyWin32(StringBuilder logger)
        {
            CheckPlatformWin32();
            var rCore = Registry.LocalMachine.OpenSubKey(@"SOFTWARE\R-core");
            if (rCore == null)
            {
                //doLogSetEnvVarInfo(@"Local machine SOFTWARE\R-core not found - trying current user", logger);
                rCore = Registry.CurrentUser.OpenSubKey(@"SOFTWARE\R-core");
                if (rCore == null)
                    throw new ApplicationException("Windows Registry key 'SOFTWARE\\R-core' not found in HKEY_LOCAL_MACHINE nor HKEY_CURRENT_USER");
            }
            //doFoundWinRegKey(rCore, logger);
            bool is64Bit = Environment.Is64BitProcess;
            var subKey = is64Bit ? "R64" : "R";
            var r = rCore.OpenSubKey(subKey);
            if (r == null)
            {
                throw new ApplicationException(string.Format(
                   "Windows Registry sub-key '{0}' of key '{1}' was not found", subKey, rCore.ToString()));
            }
            //doFoundWinRegKey(rCore, logger);
            return r;
        }

        public static string MatrixFromGekkoToROrPython<T>(string name, T[,] m, int type)
        {
            //See also MatrixFromROrPythonToGekko()
            if (m == null || m.Length == 0) return null;
            string s = null;
            if (type == 0)
            {
                //hmmm, why not just use the double loop, strange...
                //maybe because of comma
                s = name + " = c(" + m[0, 0];
                for (int i = 1; i < m.GetLength(0); i++)
                    s += "," + m[i, 0];
                for (int j = 1; j < m.GetLength(1); j++)
                    for (int i = 0; i < m.GetLength(0); i++)
                        s += "," + m[i, j];
                s += ")" + G.NL;
                s += "dim(" + name + ") = c(" + m.GetLength(0) + ", " + m.GetLength(1) + ")";
            }
            else
            {
                s = name + " = ";
                s += "numpy.array([";
                for (int i = 0; i < m.GetLength(0); i++)
                {
                    if (i > 0) s += ",";
                    s += "[";
                    for (int j = 0; j < m.GetLength(1); j++)
                    {
                        if (j > 0) s += ",";
                        if (typeof(T) == typeof(double))
                        {
                            double[,] xx = m as double[,];
                            double d = xx[i, j];
                            if (G.isNumericalError(d))
                                s += "numpy.nan";
                            else
                                s += m[i, j];
                        }
                        else
                        {
                            s += m[i, j];
                        }
                    }
                    s += "]";
                }
                s += "])";
            }
            return s;
        }

        public static void ROrPythonExport(List names, string target, int type)
        {
            //type 0 = R, type 1 = Python

            List<string> fileContent = null;
            string programName = null;            
            if (type == 0)
            {
                fileContent = Globals.r_fileContent;
                programName = "R";                
            }
            else 
            {
                fileContent = Globals.python_fileContent;
                programName = "Python";                
            }            
            string all = null;
            List<string> exportItems = O.Restrict(names, true, true, false, false);  //only matrices, #x
            if (exportItems != null)
            {
                foreach (string s in exportItems)
                {
                    string rawS = G.Chop_RemoveBank(s).Replace(Globals.symbolCollection.ToString(), "");
                    IVariable iv = O.GetIVariableFromString(s, O.ECreatePossibilities.NoneReportError, true);
                    if (iv != null && iv.Type() == EVariableType.Matrix)
                    {
                        Matrix m = (Matrix)iv;
                        all += Program.MatrixFromGekkoToROrPython<double>(rawS, m.data, type) + G.NL;
                    }
                    else
                    {
                        G.Writeln2("*** ERROR: Could not find matrix " + s);
                        throw new GekkoException();
                    }
                }
            }

            if (target == null)
            {
                //insert at top
                List<string> l2 = new List<string>();
                if (all != null) l2.Add(all);
                if (fileContent != null) l2.AddRange(fileContent);
                fileContent.Clear();
                foreach (string s in l2) fileContent.Add(s);
            }
            else
            {
                bool hit = false;
                List<string> l2 = new List<string>();
                if (fileContent == null)
                {
                    G.Writeln2("*** ERROR: the " + programName.ToUpper() + "_FILE is empty");
                    throw new GekkoException();
                }
                foreach (string line in fileContent)
                {
                    l2.Add(line);
                    if (line.TrimStart().ToLower().StartsWith("gekkoimport "))
                    {
                        string[] ss = line.Split(new string[] { " " }, StringSplitOptions.RemoveEmptyEntries);
                        if (ss.Length > 1)
                        {
                            if (G.IsIdent(ss[1]))
                            {
                                string foundBlock = ss[1];
                                if (G.Equal(target, foundBlock))
                                {
                                    l2.Add(all);
                                    hit = true;
                                }
                            }
                        }
                    }
                }
                if (hit == false)
                {
                    G.Writeln2("*** ERROR: Could not find statement 'gekkoimport " + target + "' in the " + programName + " file");
                    throw new GekkoException();
                }

                fileContent.Clear();
                foreach (string s in l2) fileContent.Add(s);
                
                //fileContent = l2;

            }
        }

        public static void RunR(Gekko.O.R_run o)
        {           

            string RFileName = Globals.localTempFilesLocation + "\\tempRFile.r";
            string RExportFileName = Globals.localTempFilesLocation + "\\tempR2Gekko.txt";
            List<string> lines2 = new List<string>();

            string def1 = "#gekkoexport function def start";
            string def2 = "#gekkoexport function def end";

            lines2.Add(def1);
            lines2.Add("gekkoexport  <- function(input) {");
            lines2.Add("  name <- deparse(substitute(input))");
            lines2.Add("  filename <- `" + RExportFileName.Replace("\\", "\\\\") + "`");
            lines2.Add("  cols <- NCOL(input)");
            lines2.Add("  write(paste(`name = `, name), filename, append=TRUE)");
            lines2.Add("  write(paste(`rows = `, as.character(NROW(input))), filename, append=TRUE)");
            lines2.Add("  write(paste(`cols = `, as.character(NCOL(input))), filename, append=TRUE)");
            lines2.Add("  write(t(input), file = filename, n=cols, append=TRUE)");
            lines2.Add("  write(`-------------------`, filename, append=TRUE)");
            lines2.Add("}");
            lines2.Add(def2);
            string f = G.ExtractTextFromLines(lines2).ToString().Replace("`", Globals.QT);

            if (o.fileName != null)
            {
                //called in the new way
                Globals.r_fileContent = null;
                Globals.r_fileContent = G.ExtractLinesFromText(Program.GetTextFromFileWithWait(o.fileName));
                Program.ROrPythonExport(o.names, o.opt_target, 0);
            }
            else
            {
                //called in old way
                if (Globals.r_fileContent == null)
                {
                    G.Writeln2("*** ERROR: No R file defined in R_FILE");
                    throw new GekkoException();
                }
            }

            using (FileStream fs = WaitForFileStream(RFileName, GekkoFileReadOrWrite.Write))            
            using (StreamWriter sw = G.GekkoStreamWriter(fs))  //using new StreamWriter() not good here, then problem with chars like (c) copyright in filename. See also #7284242898
            {
                sw.Write(f);
                foreach (string s2 in Globals.r_fileContent)
                {
                    if (s2.TrimStart().ToLower().StartsWith("gekkoimport ")) continue;
                    sw.WriteLine(s2);
                }
                sw.Flush();
                sw.Close();
            }

            //Make r2gekko.txt file that R later on fills into
            using (FileStream fs = WaitForFileStream(RExportFileName, GekkoFileReadOrWrite.Write))
            using (StreamWriter sw = G.GekkoStreamWriter(fs))
            {
                sw.WriteLine("R2Gekko version 1.0");
                sw.WriteLine("-------------------");
                sw.Flush();
                sw.Close();
            }

            string exe = "rscript.exe";

            string RPathUsedHere = null;
            if (Program.options.r_exe_folder.Trim() == "")
            {
                //no path stated manually
                if (Globals.detectedRPath == null || Globals.detectedRPath == "[[RDetectFailed]]")
                {
                    //do not do this every time R is called!
                    string RPath = GetRhomeWin32NT(null);
                    if (RPath == null || RPath.Trim() == "") Globals.detectedRPath = "[[RDetectFailed]]";
                    else Globals.detectedRPath = RPath + "\\bin\\" + exe;
                }
                else
                {
                    //either second etc. time, or previous detect fail                    
                }
                RPathUsedHere = Globals.detectedRPath;
            }
            else
            {
                //overrides
                if (Program.options.r_exe_folder.ToLower().EndsWith("\\" + exe))
                {
                    RPathUsedHere = Program.options.r_exe_folder;
                }
                else
                {
                    if (Program.options.r_exe_folder.EndsWith("\\")) RPathUsedHere = Program.options.r_exe_folder + exe;
                    else RPathUsedHere = Program.options.r_exe_folder + "\\" + exe;
                }
            }

            //Now RPathUsedHere should be either
            // - A file path ending with "\rscript.exe"
            // - "[[RDetectFailed]]"

            if (RPathUsedHere == "[[RDetectFailed]]")
            {
                G.Writeln2("*** ERROR: R.exe folder could not be auto-detected.");
                G.Writeln("           Please state the R.exe folder manually with OPTION r exe folder = ...");
                throw new GekkoException();
            }

            //Now RPathUsedHere is a file path ending with "\Rscript.exe"            

            G.Writeln2("----- R start -----");
            string ss7 = "\"\"" + RPathUsedHere + "\" --no-save \"" + RFileName + "\"\"";
            Program.ExecuteShellCommand(ss7, G.Equal(o.opt_mute, "yes"));
            G.Writeln("------ R end ------");

            //Old way --> r.StartInfo.Arguments = " CMD BATCH --no-save " + Globals.QT + RFileName + Globals.QT + " " + Globals.QT + RFileName + ".txt" + Globals.QT;
                        
            string s = Program.GetTextFromFileWithWait(RExportFileName);
            List<string> lines = G.ExtractLinesFromText(s);
            MatrixFromROrPythonToGekko(lines, 0);            
        }

        private static void MatrixFromROrPythonToGekko(List<string> lines, int type)
        {
            //See also MatrixFromGekkoToROrPython()
            string data = null;
            string name = null;
            int rows = -12345;
            int cols = -12345;
            bool first = true;
            foreach (string line in lines)
            {
                if (type == 0 && line.StartsWith("R2Gekko")) continue;
                if (type == 1 && line.StartsWith("Python2Gekko")) continue;
                if (line.StartsWith("---"))
                {
                    if (first)
                    {
                        first = false;
                        continue;
                    }
                    else
                    {
                        string[] ss = data.Split(new char[] { ' ' }, StringSplitOptions.RemoveEmptyEntries);

                        Matrix m = new Matrix(rows, cols);

                        int cnt = -1;
                        foreach (string s2 in ss)
                        {
                            cnt++;
                            double d = double.NaN;
                            if (s2 != "NA") d = G.ParseIntoDouble(s2);
                            m.data[cnt / cols, cnt % cols] = d;
                        }

                        Program.databanks.GetFirst().AddIVariableWithOverwrite(Globals.symbolCollection + name, m);

                        data = null;
                        name = null;
                        rows = -12345;
                        cols = -12345;
                        continue;
                    }
                }
                if (line.StartsWith("name ="))
                {
                    name = line.Split('=')[1].Trim();
                    continue;
                }
                if (line.StartsWith("rows ="))
                {
                    rows = int.Parse(line.Split('=')[1].Trim());
                    continue;
                }
                if (line.StartsWith("cols ="))
                {
                    cols = int.Parse(line.Split('=')[1].Trim());
                    continue;
                }
                data += line + " ";
            }
        }

        public static void RunPython(Gekko.O.Python_run o)
        {
            string pythonFileName = Globals.localTempFilesLocation + "\\tempPyFile.py";
            string pythonExportFileName = Globals.localTempFilesLocation + "\\tempPy2Gekko.txt";
            List<string> lines2 = new List<string>();

            string def1 = "#gekkoexport function def start";
            string def2 = "#gekkoexport function def end";

            lines2.Add(def1);
            //-------
            lines2.Add(@"");
            lines2.Add(@"import numpy");
            lines2.Add(@"import inspect");
            lines2.Add(@"def gekkoexport(input, name2 = None):");
            lines2.Add(@"  if name2 is None:");
            lines2.Add(@"    frame = inspect.currentframe()");
            lines2.Add(@"    frame = inspect.getouterframes(frame)[1]");
            lines2.Add(@"    s = inspect.getframeinfo(frame[0]).code_context[0].strip()");
            lines2.Add(@"    args = s[s.find('gekkoexport('):-1].split(')')");
            lines2.Add(@"    name = args[0].replace('gekkoexport(', '') # only one gekkoexport() per line, and no expressions");
            lines2.Add(@"  else:");
            lines2.Add(@"    name = name2");
            lines2.Add(@"  filename = r'" + pythonExportFileName + "'");
            lines2.Add(@"  dim = -12345");
            lines2.Add(@"  isList = False");
            lines2.Add(@"  if isinstance(input, list):");
            lines2.Add(@"    isList = True");
            lines2.Add(@"    if (isinstance(input[0], list)):");
            lines2.Add(@"      dim = 2 #could be higher...");
            lines2.Add(@"      rows = len(input)");
            lines2.Add(@"      cols = len(input[0])");
            lines2.Add(@"    else:");
            lines2.Add(@"      dim = 1");
            lines2.Add(@"      rows = len(input)");
            lines2.Add(@"      cols = 1");
            lines2.Add(@"  elif isinstance(input, (int, float)):");
            lines2.Add(@"    dim = 0");
            lines2.Add(@"    rows = 1");
            lines2.Add(@"    cols = 1");
            lines2.Add(@"  else:");
            lines2.Add(@"    if len(input.shape) == 1:");
            lines2.Add(@"      dim = 1");
            lines2.Add(@"      rows = input.shape[0]");
            lines2.Add(@"      cols = 1");
            lines2.Add(@"    else:");
            lines2.Add(@"      dim = len(input.shape)");
            lines2.Add(@"      rows, cols = input.shape");
            lines2.Add(@"  f = open(filename, 'a')");
            lines2.Add(@"  f.write('name = ' + name + '\n')");
            lines2.Add(@"  f.write('rows = ' + str(rows) + '\n')");
            lines2.Add(@"  f.write('cols = ' + str(cols) + '\n')");
            lines2.Add(@"  if dim == 0:");
            lines2.Add(@"    f.write(str(input) + '\n')");
            lines2.Add(@"  elif dim == 1:");
            lines2.Add(@"    for i in range(0, rows):");
            lines2.Add(@"      f.write(str(input[i]) + '\n')");
            lines2.Add(@"  elif dim == 2:");
            lines2.Add(@"    for i in range(0, rows):");
            lines2.Add(@"      for j in range(0, cols):");
            lines2.Add(@"        if isList:");
            lines2.Add(@"          f.write(str(input[i][j]) + '\n')");
            lines2.Add(@"        else:");
            lines2.Add(@"          f.write(str(input[i, j]) + '\n')");
            lines2.Add(@"  f.write('-------------------\n')");
            lines2.Add(@"  f.close()");
            //-------
            lines2.Add(def2);
            string f = G.ExtractTextFromLines(lines2).ToString().Replace("`", Globals.QT);
            
            if (true)
            {
                Globals.python_fileContent = null;
                Globals.python_fileContent = G.ExtractLinesFromText(Program.GetTextFromFileWithWait(o.fileName));
                Program.ROrPythonExport(o.names, o.opt_target, 1);
            }

            using (FileStream fs = WaitForFileStream(pythonFileName, GekkoFileReadOrWrite.Write))
            using (StreamWriter sw = new StreamWriter(fs))    //using G.GekkoStreamWriter() not good here, then problem with chars like (c) copyright in filename. See also #7284242898
            {
                sw.Write(f);
                foreach (string s2 in Globals.python_fileContent)
                {
                    if (s2.TrimStart().ToLower().StartsWith("gekkoimport ")) continue;
                    sw.WriteLine(s2);
                }
                sw.Flush();
                sw.Close();
            }

            //Make python2gekko.txt file that Python later on fills into
            using (FileStream fs = WaitForFileStream(pythonExportFileName, GekkoFileReadOrWrite.Write))
            using (StreamWriter sw = G.GekkoStreamWriter(fs))
            {
                sw.WriteLine("Python2Gekko version 1.0");
                sw.WriteLine("------------------------");
                sw.Flush();
                sw.Close();
            }            

            string pythonPathUsedHere = null;
            if (Program.options.python_exe_folder.Trim() == "")
            {
                //no path stated manually
                if (Globals.detectedPythonPath == null || Globals.detectedPythonPath == "[[PythonDetectFailed]]")
                {
                    //do not do this every time Python is called!
                    string pythonPath = GetPythonPath();
                    if (pythonPath == null || pythonPath.Trim() == "") Globals.detectedPythonPath = "[[PythonDetectFailed]]";
                    else Globals.detectedPythonPath = pythonPath;
                }
                else
                {
                    //either second etc. time, or previous detect fail                    
                }
                pythonPathUsedHere = Globals.detectedPythonPath;
            }
            else
            {
                //overrides
                if (Program.options.python_exe_folder.ToLower().EndsWith("\\python.exe"))
                {
                    pythonPathUsedHere = Program.options.python_exe_folder;
                }
                else
                {
                    if (Program.options.python_exe_folder.EndsWith("\\")) pythonPathUsedHere = Program.options.python_exe_folder + "python.exe";
                    else pythonPathUsedHere = Program.options.python_exe_folder + "\\python.exe";
                }
            }

            //Now pythonPathUsedHere should be either
            // - A file path ending with "\python.exe"
            // - "[[PythonDetectFailed]]"

            if (pythonPathUsedHere == "[[PythonDetectFailed]]")
            {
                G.Writeln2("*** ERROR: python.exe path could not be auto-detected.");
                G.Writeln("           Please state the python.exe path manually with OPTION python exe folder = ...");
                throw new GekkoException();
            }

            G.Writeln2("----- Python start -----");
            //Python needs -u argument to show long-running processes output line by line
            string ss7 = "\"\"" + pythonPathUsedHere + "\" -u \"" + pythonFileName + "\"\"";
            Program.ExecuteShellCommand(ss7, G.Equal(o.opt_mute, "yes"));
            G.Writeln("------ Python end ------");
            
            string s = Program.GetTextFromFileWithWait(pythonExportFileName);
            List<string> lines = G.ExtractLinesFromText(s);
            MatrixFromROrPythonToGekko(lines, 1);                        
        }

        public static string GetPythonPath()
        {
            //https://gis.stackexchange.com/questions/44411/how-can-i-programmatically-get-the-path-of-python-exe-used-by-arcmap
            IDictionary environmentVariables = Environment.GetEnvironmentVariables();
            string pathVariable = environmentVariables["Path"] as string;
            if (pathVariable != null)
            {
                string[] allPaths = pathVariable.Split(';');
                foreach (var path in allPaths)
                {
                    string pythonPathFromEnv = path + "\\python.exe";
                    if (File.Exists(pythonPathFromEnv))
                        return pythonPathFromEnv;
                }
            }
            return null;
        }

        
        public static void AddToPrecedents(Databank db, string varnameWithFreq)
        {
            
            string two = db.name + ":" + varnameWithFreq;
            if (!Globals.precedents.ContainsKey(two))
            {
                Globals.precedents.Add(two, 0);
            }
        }
        public static void X12a(Gekko.O.X12a o)
        {
            List<string> listItems = O.Restrict(o.names, true, false, true, false);

            //TODO: implement for array-series. For array-series x, produce x_saa etc. Or how is it done
            //

            string tempName = "tempX12aFile";
            string spcFileName = Globals.localTempFilesLocation + "\\" + tempName + ".spc";
            List<string> lines2 = new List<string>();

            //Delete tempX12aFile.*
            string[] files = Directory.GetFiles(Globals.localTempFilesLocation, "" + tempName + "*.*");
            foreach (string file in files) WaitForFileDelete(file);

            string meta = null;
            int counter = 0;

            List<Series> tss = new List<Series>();

            for (int i = 0; i < listItems.Count; i++)
            {
                IVariable iv = O.GetIVariableFromString(listItems[i], O.ECreatePossibilities.NoneReportError, true);

                Series ts = O.ConvertToSeries(iv) as Series;
                tss.Add(ts);  //for later use

                //GetTimeSeriesFromStringWildcard() implicitly calls GetInfoFromStringWildcard() which we will call again later.
                //List<Series> tss = Program.GetTimeSeriesFromStringWildcard(o.listItems[i], o.opt_bank);
                //foreach (Series ts in tss)
                //{
                counter++;
                string data = null;
                foreach (GekkoTime t in new GekkoTimeIterator(o.t1, o.t2))
                {
                    double v = ts.GetDataSimple(t);
                    if (G.isNumericalError(v))
                    {
                        G.Writeln2("*** ERROR: Missing value in '" + ts.name + "', period " + G.FromDateToString(t));
                        throw new GekkoException();
                    }
                    //data += t.super + " " + t.sub + " " + v.ToString() + G.NL;
                    data += v.ToString() + G.NL;
                }
                //Create data files
                meta += tempName + counter + ".dat" + G.NL;
                using (FileStream fs = WaitForFileStream(Globals.localTempFilesLocation + "\\" + tempName + counter + ".dat", GekkoFileReadOrWrite.Write))
                using (StreamWriter sw = G.GekkoStreamWriter(fs))
                {
                    sw.Write(data);
                    sw.Flush();
                    sw.Close();
                }
                //}
            }

            using (FileStream fs = WaitForFileStream(Globals.localTempFilesLocation + "\\" + tempName + ".dta", GekkoFileReadOrWrite.Write))
            using (StreamWriter sw = G.GekkoStreamWriter(fs))
            {
                sw.Write(meta);
                sw.Flush();
                sw.Close();
            }
            string s2 = null;
            s2 += "series {" + G.NL;  //for instance 2000.2
            s2 += "start = " + o.t1.super + "." + o.t1.sub + G.NL;  //for instance 2000.2
            s2 += "period = " + GetFreqNumbers(o.t1.freq) + G.NL;  //4 or 12
            s2 += "}" + G.NL;

            s2 += "x11{ " + o.opt_param + " }" + G.NL;

            //Create tempX12aFile.spc
            using (FileStream fs = WaitForFileStream(spcFileName, GekkoFileReadOrWrite.Write))
            using (StreamWriter sw = G.GekkoStreamWriter(fs))
            {
                sw.Write(s2);
                sw.Flush();
                sw.Close();
            }

            string currentDir = Directory.GetCurrentDirectory();  //remembered in order to switch back
            Directory.SetCurrentDirectory(Globals.localTempFilesLocation);
            try
            {
                Process process = new Process();
                string startup = null;
                if (G.IsUnitTesting())
                {
                    startup = Globals.ttPath2 + "\\" + Globals.ttPath3 + "\\Gekko\\bin\\Debug";
                }
                else
                {
                    startup = Application.StartupPath;
                }

                process.StartInfo.FileName = startup + "\\X12A.EXE";
                process.StartInfo.WindowStyle = ProcessWindowStyle.Hidden;
                //tempName does not contain blanks, so quotes are not needed
                //TODO: perhaps do this like PLOT with random numbers attached
                process.StartInfo.Arguments = tempName + " -d " + tempName;
                process.Start();
                process.WaitForExit();
                process.Close();
            }
            finally
            {
                Directory.SetCurrentDirectory(currentDir);
            }

            List<string> ext = new List<string>() { "c17", "d10", "d11", "d12", "d13", "saa" };
            //Import data
            files = Directory.GetFiles(Globals.localTempFilesLocation, "" + tempName + "*.*");
            bool first = true;
            foreach (string file in files)
            {
                int i = -1;
                foreach (Series ts0 in tss)

                //for (int i = 0; i < o.listItems.Count; i++)
                {
                    i++;
                    //List<BankNameVersion> list = GetInfoFromStringWildcard(o.listItems[i], o.opt_bank);
                    //foreach (BankNameVersion bnv in list)
                    //{
                    foreach (string e in ext)
                    {
                        string sss = Path.GetFileName(file);
                        if (G.Equal(sss, tempName + (i + 1) + "." + e))
                        {

                            string varName2 = null; string freq = null; O.ChopFreq(ts0.name, ref freq, ref varName2);
                            string varName = varName2 + "_" + e + Globals.freqIndicator + freq;

                            Series ts = new Series(o.t1.freq, varName);
                            string s = Program.GetTextFromFileWithWait(file);
                            List<string> lines = G.ExtractLinesFromText(s);
                            foreach (string line in lines)
                            {
                                if (line.TrimStart().ToLower().StartsWith("date")) continue;
                                if (line.TrimStart().ToLower().StartsWith("---")) continue;
                                string[] ss = line.Split(new string[] { "\t" }, StringSplitOptions.RemoveEmptyEntries);
                                if (ss.Length != 2)
                                {
                                    G.Writeln2("*** ERROR: Error #8907523 in X12A");
                                    throw new GekkoException();
                                }
                                try
                                {
                                    if (ss[0].Length != 6)
                                    {
                                        G.Writeln2("*** ERROR: Error #897525 in X12A");
                                        throw new GekkoException();
                                    }
                                    int i1 = int.Parse(ss[0].Substring(0, 4));
                                    int i2 = int.Parse(ss[0].Substring(4, 2));
                                    GekkoTime gt = new GekkoTime(o.t1.freq, i1, i2);
                                    ts.SetData(gt, G.ParseIntoDouble(ss[1]));
                                }
                                catch
                                {
                                    G.Writeln2("*** ERROR: Error #897524 in X12A");
                                    throw new GekkoException();
                                }
                            }
                            Databank db = ts0.meta.parentDatabank;

                            db.AddIVariableWithOverwrite(ts);
                            if (first) G.Writeln();
                            G.Writeln("Adjusted timeseries: " + db.name + ":" + varName);
                            first = false;
                        }
                    }
                    //}
                }
            }

            if (first)
            {
                G.Writeln2("Did not produce any adjusted timeseries. See more info in the tempX12aFile...");
                G.Writeln("files here: " + Globals.localTempFilesLocation);
            }
            if (!(o.opt_param.ToLower().Contains("totals") && o.opt_param.ToLower().Contains("force")))
            {
                if (o.opt_param.ToLower().Contains("saa"))
                {
                    G.Writeln("+++ NOTE: For 'saa' type, you need 'force=totals'");
                }
            }
        }

        private static string GetFreqNumbers(EFreq freq)
        {
            string per = "";
            if (freq == EFreq.A)
            {
                G.Writeln2("*** ERROR: You cannot use X12A on an annual timeseries");
                throw new GekkoException();
            }
            else if (freq == EFreq.U)
            {
                G.Writeln2("*** ERROR: You cannot use X12A on an undated timeseries");
                throw new GekkoException();
            }
            else if (freq == EFreq.Q)
            {
                per = "4";
            }
            else if (freq == EFreq.M)
            {
                per = "12";
            }
            else if (freq == EFreq.D)
            {
                per = "365";
            }
            return per;
        }

        public static void ShowMatrix(Matrix a, string label)
        {
            if (a.data.GetLength(0) < 1 || a.data.GetLength(1) < 1)
            {
                G.Writeln2("The matrix has dimensions " + a.data.GetLength(0) + "x" + a.data.GetLength(1) + ", and cannot be printed");
                throw new GekkoException();
            }
            Gekko.Table tab = new Gekko.Table();
            for (int i = 0; i < a.data.GetLength(0); i++)
            {
                for (int j = 0; j < a.data.GetLength(1); j++)
                {
                    Cell c = new Cell();
                    c.cellType = CellType.Number;
                    c.number = a.data[i, j];
                    c.numberFormat = "f" + Program.options.print_fields_nwidth + "." + Program.options.print_fields_ndec + "";
                    tab.Set(new Coord(i + 2, j + 2), c);
                }
            }
            for (int i = 0; i < a.data.GetLength(0); i++)
            {
                //row dimension
                Cell c = null;
                if (a.rownames != null && i < a.rownames.Count && a.rownames[i].Trim() != "")
                {
                    c = new Cell();
                    c.cellType = CellType.Text;
                    c.CellText = new Gekko.Text();
                    c.CellText.TextData = new List<string> { a.rownames[i].Trim() };
                    c.align = -1;
                }
                else
                {
                    c = new Cell();
                    c.cellType = CellType.Number;
                    c.number = i + 1;
                    c.numberFormat = "f4.0";
                }
                tab.Set(new Coord(i + 2, 1), c);
            }
            for (int i = 0; i < a.data.GetLength(1); i++)
            {
                //col dimension                
                Cell c = null;
                if (a.colnames != null && i < a.colnames.Count && a.colnames[i].Trim() != "")
                {
                    c = new Cell();
                    c.cellType = CellType.Text;
                    c.CellText = new Gekko.Text();
                    c.CellText.TextData = new List<string> { a.colnames[i].Trim() };
                    c.align = 1;
                }
                else
                {
                    c = new Cell();
                    c.cellType = CellType.Number;
                    c.number = i + 1;
                    c.numberFormat = "f4.0";
                }
                tab.Set(new Coord(1, i + 2), c);
            }
            List<string> xx = tab.PrintText();

            int widthRemember = Program.options.print_width;
            int fileWidthRemember = Program.options.print_filewidth;
            Program.options.print_width = int.MaxValue;
            Program.options.print_filewidth = int.MaxValue;

            //G.Writeln();

            string label2 = G.ReplaceGlueNew(label);
            label2 = ScalarString.SubstituteScalarsInString(label2, false, true);  //#lkjadsfkalsdfjaskl

            PrintLabel(label2);
            foreach (string s in xx)
            {
                G.Writeln(s);
            }

            Program.options.print_width = widthRemember;
            Program.options.print_filewidth = fileWidthRemember;

            Globals.lastPrtOrMulprtTable = tab;  //this puts the matrix on the clipboard.
            CrossThreadStuff.CopyButtonEnabled(true);
        }



        public static bool IsLargeAware(string file)
        {
            using (var fs = File.OpenRead(file))
            {
                return IsLargeAware(fs);
            }
        }

        /// <summary>
        /// Checks if the stream is a MZ header and if it is large address aware
        /// </summary>
        /// <param name="stream">Stream to check, make sure its at the start of the MZ header</param>
        /// <exception cref=""></exception>
        /// <returns></returns>
        public static bool IsLargeAware(Stream stream)
        {
            const int IMAGE_FILE_LARGE_ADDRESS_AWARE = 0x20;

            var br = new BinaryReader(stream);

            if (br.ReadInt16() != 0x5A4D)       //No MZ Header
                return false;

            br.BaseStream.Position = 0x3C;
            var peloc = br.ReadInt32();         //Get the PE header location.

            br.BaseStream.Position = peloc;
            if (br.ReadInt32() != 0x4550)       //No PE header
                return false;

            br.BaseStream.Position += 0x12;
            return (br.ReadInt16() & IMAGE_FILE_LARGE_ADDRESS_AWARE) == IMAGE_FILE_LARGE_ADDRESS_AWARE;
        }

        public static void Stamp()
        {                        
                G.Writeln2("*** ERROR: Please use: TELL currentDateTime();");
                throw new GekkoException();            
        }

        public static void FlowChart(string s, string code, GekkoTime period)
        {
            Dictionary<string, int> counter = new Dictionary<string, int>(StringComparer.OrdinalIgnoreCase);
            List<GekkoFlowChart.FlowNode> sw2 = new List<GekkoFlowChart.FlowNode>();
            List<GekkoFlowChart.FlowArrow> sw = new List<GekkoFlowChart.FlowArrow>();

            int maxDepth = 20;
            double prune = Globals.pruneDecomp;  //is relative, NOT percent
            //int year = int.Parse(s2);  //TODO: quarters etc.

            counter.Add(s, counter.Count);

            GekkoFlowChart.FlowNode fn = new GekkoFlowChart.FlowNode();
            fn.varName = s;
            fn.counter = counter[s];
            fn.labelBig = Program.FlowInsertLabel(s);
            if (Program.VariableTypeEndoExo(s) == EEndoOrExo.Exo) fn.isExogenous = true;
            else fn.isExogenous = false;
            fn.isStartNode = true;
            sw2.Add(fn);

            Dictionary<string, int> d = new Dictionary<string, int>(StringComparer.OrdinalIgnoreCase);
            d.Add(s, 0);
            Program.DecompForFlowChart(s, period, maxDepth, prune, 1d, 0, counter, sw, sw2, d, code);
            G.Writeln();

            GekkoFlowChart.Helper h = new GekkoFlowChart.Helper();
            h.flowArrows = sw;
            h.flowNodes = sw2;
            GekkoFlowChart.FruchtermanReingoldLayout.h = h;
            GekkoFlowChart.DataModel.instance = new GekkoFlowChart.DataModel(-12345, Globals.pruneDecomp, true);
            System.Windows.Window w = new GekkoFlowChart.MainWindow();
            w.Show();
        }

        public static string FlowInsertLabel(string s)
        {
            string rv = "";
            foreach (string s2 in GetVariableExplanationAugmented(s))
            {
                rv += s2 + G.NL;
            }
            return rv;
        }

        public static List<string> GetVariableExplanationNEW(string variableName, bool printName, bool printData, GekkoTime tStart, GekkoTime tEnd)
        {
            List<string> rv = new List<string>();
            IVariable iv = O.GetIVariableFromString(variableName, O.ECreatePossibilities.NoneReturnNull, false);
            Series ts = null;
            if (iv != null) ts = iv as Series;
            if (printName)
            {
                rv.Add("Series: " + variableName);
            }
            List<string> varExpl = Program.GetVariableExplanation(variableName);
            foreach (string line in varExpl)
            {
                if (line != "")
                {
                    rv.Add(line);
                }
            }

            try
            {                
                
                if (ts.type == ESeriesType.Normal || ts.type == ESeriesType.Timeless)
                {
                    if (!G.NullOrBlanks(ts.meta.label))
                    {
                        rv.Add("Label: " + ts.meta.label);
                    }
                    else
                    {
                        if (ts.mmi != null && ts.mmi.parent != null && !G.NullOrBlanks(ts.mmi.parent.meta.label))
                        {
                            rv.Add("Label: " + ts.mmi.parent.meta.label);
                        }
                    }

                    if (!G.NullOrBlanks(ts.meta.source))
                    {
                        rv.Add("Source: " + ts.meta.source);
                    }
                    else
                    {
                        if (ts.mmi != null && ts.mmi.parent != null && !G.NullOrBlanks(ts.mmi.parent.meta.source))
                        {
                            rv.Add("Source: " + ts.mmi.parent.meta.source);
                        }
                    }

                    if (!G.NullOrBlanks(ts.meta.units))
                    {
                        rv.Add("Units: " + ts.meta.units);
                    }
                    else
                    {
                        if (ts.mmi != null && ts.mmi.parent != null && !G.NullOrBlanks(ts.mmi.parent.meta.units))
                        {
                            rv.Add("Units: " + ts.mmi.parent.meta.units);
                        }
                    }
                }

                if (printData)
                {

                    rv.Add("-----------------------------------------------");
                    rv.Add("Period        value        %");

                    int counter = 0;

                    //must be able to handle TIME where freq does not match the series freq
                    foreach (GekkoTime gt in new GekkoTimeIterator(Program.ConvertFreqs(tStart, tEnd, ts.freq)))
                    {
                        counter++;
                        string sss = gt.ToString() + " ";

                        double n1 = ts.GetDataSimple(gt);
                        double n0 = ts.GetDataSimple(gt.Add(-1));

                        double level1 = n1;
                        double pch1 = ((n1 / n0 - 1) * 100d);

                        if (n1 == n0) pch1 = 0d;

                        string levelFormatted;
                        string pchFormatted;
                        Program.ConvertToPrintFormat(level1, pch1, out levelFormatted, out pchFormatted);

                        sss += levelFormatted + " " + pchFormatted + " ";
                        rv.Add(sss);
                    }
                }
            }
            catch
            {
                //no need to fail on this
            }
            return rv;
        }

        public static List<string> GetVariableExplanationAugmented(string variableNameWithOrWithoutLag)
        {
            string ss = "";
            string var2 = G.ExtractOnlyVariableIgnoreLag(variableNameWithOrWithoutLag, Globals.leftParenthesisIndicator);
            List<string> ss2 = Program.GetVariableExplanationNEW(var2, true, false, GekkoTime.tNull, GekkoTime.tNull);
            return ss2;
        }

        public static void DecompForFlowChart(string s, GekkoTime year, int maxDepth, double prune, double factor, int depth, Dictionary<string, int> counter, List<GekkoFlowChart.FlowArrow> sw, List<GekkoFlowChart.FlowNode> sw2, Dictionary<string, int> d, string code)
        {
            if (!Program.model.modelGekko.m2.endogenous.ContainsKey(s))
            {
                //do nothing
            }
            else
            {
                G.Writeln("FLOW = " + s + ", depth = " + depth + ", factor = " + factor);
                DecompOptions decompOptions = new DecompOptions();
                //decompOptions.vars = new List<string>() { s };
                decompOptions.t1 = year;
                decompOptions.t2 = year;
                decompOptions.localBanks = new LocalBanks();
                decompOptions.type = "sq";  //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
                decompOptions.variable = s;
                Table table = Program.DecompHelper2(decompOptions, code, false);
                //table.PrintCellsForDebug();
                //List<string> stable = table.Print();
                //foreach (string s in stable) G.Writeln(s);

                string dependent = table.Get(2, 1).CellText.TextData[0];

                for (int i = 3; i < table.GetRowMaxNumber() + 1; i++)
                {
                    string variable = table.Get(i, 1).CellText.TextData[0];
                    double effect = table.Get(i, 2).number;
                    double ff = factor * effect / 100d;
                    //G.Writeln(i + " " + table.Get(i, 1).CellText.TextData[0] + " " + table.Get(i, 2).number);
                    if (Math.Abs(effect) > prune * 100d)
                    {
                        if (!counter.ContainsKey(variable))
                        {
                            GekkoFlowChart.FlowNode fn = new GekkoFlowChart.FlowNode();
                            counter.Add(variable, counter.Count);
                            fn.varName = variable;
                            fn.counter = counter[variable];
                            fn.labelBig = FlowInsertLabel(variable);
                            if (Program.VariableTypeEndoExo(variable) == EEndoOrExo.Exo) fn.isExogenous = true;
                            else fn.isExogenous = false;
                            fn.isStartNode = false;
                            fn.id = counter[variable];
                            sw2.Add(fn);
                            //if (G.Equal(variable, "pm59"))
                            //    G.Writeln();
                        }
                        GekkoFlowChart.FlowArrow fa = new GekkoFlowChart.FlowArrow();
                        fa.varName1 = variable;
                        fa.varName2 = dependent;
                        fa.counter1 = counter[variable];
                        fa.counter2 = counter[dependent];
                        fa.weight = ff;

                        string aname = fa.varName1 + "," + fa.varName2;
                        if (d.ContainsKey(aname))
                        {
                            continue;  //no loops
                        }

                        d.Add(aname, 0);
                        sw.Add(fa);

                        if (depth < maxDepth && Math.Abs(ff) > prune)
                        {
                            if (d.ContainsKey(variable)) continue;  //do not do loops
                            DecompForFlowChart(variable, year, maxDepth, prune, ff, depth + 1, counter, sw, sw2, d, code);
                        }
                    }
                }
            }
        }

        public static bool TestKP2010Model()
        {
            Dictionary<string, CompareHelper> skip = new Dictionary<string, CompareHelper>(StringComparer.OrdinalIgnoreCase);
            skip.Add("RKQYFA", new CompareHelper(new GekkoTime((Program.options.freq), 2011, 1), new GekkoTime((Program.options.freq), 2011, 1)));
            skip.Add("RKQYFB", new CompareHelper(new GekkoTime((Program.options.freq), 2011, 1), new GekkoTime((Program.options.freq), 2011, 1)));
            skip.Add("RKQYFNB", new CompareHelper(new GekkoTime((Program.options.freq), 2011, 1), new GekkoTime((Program.options.freq), 2011, 1)));
            skip.Add("RKQYFNF", new CompareHelper(new GekkoTime((Program.options.freq), 2011, 1), new GekkoTime((Program.options.freq), 2011, 1)));
            skip.Add("RKQYFNK", new CompareHelper(new GekkoTime((Program.options.freq), 2011, 1), new GekkoTime((Program.options.freq), 2011, 1)));
            skip.Add("RKQYFNM", new CompareHelper(new GekkoTime((Program.options.freq), 2011, 1), new GekkoTime((Program.options.freq), 2011, 1)));
            skip.Add("RKQYFNN", new CompareHelper(new GekkoTime((Program.options.freq), 2011, 1), new GekkoTime((Program.options.freq), 2011, 1)));
            skip.Add("RKQYFNQ", new CompareHelper(new GekkoTime((Program.options.freq), 2011, 1), new GekkoTime((Program.options.freq), 2011, 1)));
            skip.Add("RKQYFNT", new CompareHelper(new GekkoTime((Program.options.freq), 2011, 1), new GekkoTime((Program.options.freq), 2011, 1)));
            skip.Add("RKQYFQH", new CompareHelper(new GekkoTime((Program.options.freq), 2011, 1), new GekkoTime((Program.options.freq), 2011, 1)));
            skip.Add("RKQYFQQ", new CompareHelper(new GekkoTime((Program.options.freq), 2011, 1), new GekkoTime((Program.options.freq), 2011, 1)));
            skip.Add("RKQYFQT", new CompareHelper(new GekkoTime((Program.options.freq), 2011, 1), new GekkoTime((Program.options.freq), 2011, 1)));
            //btydd is due to _G__D code, see patchZvar option (probably Gekko error)
            skip.Add("BTYDD", new CompareHelper(new GekkoTime((Program.options.freq), 2020, 1), new GekkoTime((Program.options.freq), 2020, 1)));
            //bven/bveq is strange: seems pcim error not consistent with equation
            skip.Add("bven", new CompareHelper(new GekkoTime((Program.options.freq), 2012, 1), new GekkoTime((Program.options.freq), 2020, 1)));
            skip.Add("bveq", new CompareHelper(new GekkoTime((Program.options.freq), 2012, 1), new GekkoTime((Program.options.freq), 2020, 1)));
            //ecpuxh difference probably because of data inaccuracy (tsd-file)
            skip.Add("ecpuxh", new CompareHelper(new GekkoTime((Program.options.freq), 2013, 1), new GekkoTime((Program.options.freq), 2016, 1)));
            skip.Add("efcpuxh", new CompareHelper(new GekkoTime((Program.options.freq), 2013, 1), new GekkoTime((Program.options.freq), 2013, 1)));
            //pivo is 0 in Gekko and missing in PCIM. Probably due to changed relation in Gekko. Variable not meaningful anyway.
            skip.Add("pivo", new CompareHelper(new GekkoTime((Program.options.freq), 2009, 1), new GekkoTime((Program.options.freq), 2020, 1)));
            //Tiskia is a bit strange: why is there a JR<>0 in PCIM, but not in Gekko.
            skip.Add("tiskia", new CompareHelper(new GekkoTime((Program.options.freq), 2012, 1), new GekkoTime((Program.options.freq), 2020, 1)));
            //uagap and ulgap: differences seem ok
            skip.Add("uagap", new CompareHelper(new GekkoTime((Program.options.freq), 2013, 1), new GekkoTime((Program.options.freq), 2015, 1)));
            skip.Add("ulgap", new CompareHelper(new GekkoTime((Program.options.freq), 2014, 1), new GekkoTime((Program.options.freq), 2015, 1)));

            int t1 = 2005;  //base databank starts in 2000
            //int t2 = 2100;
            int t2 = 2020;  //to avoid too many errors
            //these are set a bit loose to avoid too many errors

            double absCrit = 0.001d;
            double relCritSmart = 0.01d;  //1%
            double relCritNormal = 0.01d;  //1%

            List<string> both = new List<string>();
            Databank work = Program.databanks.GetFirst();
            Databank base2 = Program.databanks.GetRef();
            foreach (string tsString in work.storage.Keys)
            {
                Series tsGrund = base2.GetIVariable(tsString + "!a") as Series;
                if (tsGrund != null)
                {
                    both.Add(tsString);
                }
            }
            both.Sort(StringComparer.InvariantCulture);
            int counter = 0;
            foreach (string s in both)
            {
                //these eliminate a lot of variables
                if (s.ToLower().StartsWith("j")) continue;
                if (s.ToLower().StartsWith("z")) continue;

                Series tsWork = work.GetIVariable(s + "!a") as Series;
                Series tsBase = base2.GetIVariable(s + "!a") as Series;
                bool ok2 = true;

                double maxVariance = 0d;
                foreach (GekkoTime t in new GekkoTimeIterator(new GekkoTime((Program.options.freq), t1, 1), new GekkoTime((Program.options.freq), t2, 1)))
                {
                    double variance = CalculateHistoricalVarianceForVariable(tsBase, t);
                    if (variance > maxVariance) maxVariance = variance;
                }

                foreach (GekkoTime t in new GekkoTimeIterator(new GekkoTime((Program.options.freq), t1, 1), new GekkoTime((Program.options.freq), t2, 1)))
                {

                    double valueWork = tsWork.GetDataSimple(t);
                    double valueBase = tsBase.GetDataSimple(t);
                    double relative = double.NaN;
                    bool isOk = SolveGauss777.CheckRelativeDifferenceSmart(1d, false, maxVariance, absCrit, relCritSmart, valueWork, valueBase, out relative);

                    if (!isOk)
                    {
                        if (Math.Abs(valueWork / valueBase - 1) < relCritNormal) isOk = true;  //overrules any problems if "real" % is small enough
                    }

                    if (!isOk)
                    {
                        if (skip.ContainsKey(s))
                        {
                            CompareHelper ch = skip[s];
                            if (t.LargerThanOrEqual(ch.t1) && t.SmallerThanOrEqual(ch.t2))
                            {
                                isOk = true;
                            }
                        }
                    }
                    if (!isOk)
                    {
                        G.Writeln("jul05 full check: variable " + s + " deviated in " + t.ToString() + " (variance is " + maxVariance + ")");
                        ok2 = false;
                        return false;  //can comment this out, in order to get full list of problems
                    }
                }
                if (ok2 == false) counter++;
            }
            return true;
        }

        public static void Randommodelcheck()
        {
            Series ts = Program.databanks.GetFirst().GetIVariable("sum" + "!a") as Series;
            foreach (GekkoTime t in new GekkoTimeIterator(new GekkoTime((Program.options.freq), 2002, 1), new GekkoTime((Program.options.freq), 2100, 1)))
            {
                if (Math.Abs(ts.GetDataSimple(t)) > 3 * 1.0e-4)  //hmmm seems error can be a little > 0.0001
                {
                    G.Writeln2("*** ERROR: Problem with this model -- try PRT sum");
                    throw new GekkoException();
                }
            }
            G.Writeln("Check ok");
        }

        public static void Randommodel()
        {

            int endoexo = 0;  //0 means none, 2 means 2 goals
            bool gaussMode = true;
            double factor = 2d; if (gaussMode) factor = factor / 2d;
            int nn = 50;
            Random r = new Random(11111);  //11111 used for regressions, with nn = 1000 and factor = 1d;



            for (int ii = 0; ii < nn; ii++)
            {
                if (true)
                {
                    int n = 20;
                    int p1 = 10;
                    int p2 = 10;
                    double[,] e = new double[n, n];
                    double[,] x = new double[n, 2];

                    for (int j1 = 0; j1 < n; j1++)
                    {
                        for (int j2 = 0; j2 < n; j2++)
                        {
                            if (r.Next(0, 100) < p1) e[j1, j2] = (double)r.Next(1, 999) / 1000d;
                        }
                        if (r.Next(0, 100) < p2) x[j1, 0] = (double)r.Next(1, 999) / 1000d;
                        if (r.Next(0, 100) < p2) x[j1, 1] = (double)r.Next(1, 999) / 1000d;
                    }

                    for (int j1 = 0; j1 < n; j1++)
                    {
                        double sum = 0d;
                        for (int j2 = 0; j2 < n; j2++)
                        {
                            sum += e[j1, j2];
                        }
                        if (sum == 0)
                        {
                            //row sum = 0
                            if (j1 > 0) e[j1, j1 - 1] = 0.55555d;
                            else e[j1, n - 1] = 0.55555d;
                        }
                    }

                    int i = r.Next(0, n - 1);
                    for (int j2 = 0; j2 < n; j2++)
                    {
                        e[i, j2] = 0;
                    }
                    x[i, 1] = 0.66666;  //inducing an equation Ei = 0.66666*X1, to start a prologue chain

                    double sum0 = 0d;
                    double sum1 = 0d;
                    for (int j1 = 0; j1 < n; j1++)
                    {
                        sum0 += x[j1, 0];
                        sum1 += x[j1, 1];
                    }

                    if (sum0 == 0)
                    {
                        x[r.Next(0, n - 1), 0] = 0.44444;
                    }
                    if (sum1 == 0)
                    {
                        x[r.Next(0, n - 1), 1] = 0.44444;
                    }

                    string ss = "";
                    for (int j1 = 0; j1 < n; j1++)
                    {
                        ss += "FRML _GJRD e" + j1 + " = 0." + r.Next(1, 999) + " + ";
                        for (int j2 = 0; j2 < n; j2++)
                        {
                            if (e[j1, j2] != 0) ss += e[j1, j2] * factor + "*e" + j2 + " + ";
                        }
                        if (x[j1, 0] != 0) ss += x[j1, 0] + "*x" + 0 + " + ";
                        if (x[j1, 1] != 0) ss += x[j1, 1] + "*x" + 1 + " + ";

                        if (r.Next(0, 100) < 10) ss += "0.001*e" + r.Next(0, n - 1) + "(-1) + ";

                        if (ss.EndsWith("+ ")) ss = ss.Substring(0, ss.Length - 2);
                        ss = ss + ";\n";
                    }

                    string vv = ss;
                    for (int j1 = 0; j1 < n; j1++)
                    {
                        vv = vv.Replace("FRML _GJRD e" + j1 + " = ", "abs(e" + j1 + " - (");
                    }
                    vv = vv.Replace(";", ")) + ");
                    if (vv.EndsWith("+ \n"))
                    {
                        vv = vv.Substring(0, vv.Length - 3);
                        vv += ";\n";
                    }
                    vv = "GENR sum = " + vv;
                    string vvv = "";
                    if (endoexo == 1) vvv = "EXO e0; ENDO x0;\n";
                    if (endoexo == 2) vvv = "EXO e0 e1; ENDO x0 x1;\n";
                    vv = "RESET; MODEL m" + ii + ";\n READ<tsd> m;\n " + vvv + "SIM 2002 2100;\n " + vv + "\n PRT<2002 2005> sum e0 e1 e2;\n";

                    //ok that this is not G.GekkoStreamWriter()
                    StreamWriter sw = new StreamWriter(Program.options.folder_working + "m" + ii + ".frm");
                    sw.Write(ss);
                    sw.Flush();
                    sw.Close();

                    //ok that this is not G.GekkoStreamWriter()
                    StreamWriter sw2 = new StreamWriter(Program.options.folder_working + "m" + ii + "." + Globals.defaultCommandFileExtension);
                    if (endoexo > 0) sw2 = new StreamWriter(Program.options.folder_working + "n" + ii + "." + Globals.defaultCommandFileExtension);
                    sw2.Write(vv);
                    sw2.Flush();
                    sw2.Close();

                    G.Writeln("Created random model " + ii);

                }
            }
        }

        private static double[,] PutTimeseriesIntoArrayPossiblyNegative(GekkoTime tStart0, GekkoTime tEnd, List<string> varsX)
        {
            int obs = GekkoTime.Observations(tStart0, tEnd);
            double[,] aX = new double[varsX.Count, obs];
            int id = -1;
            foreach (string var in varsX)
            {
                id++;
                int length = -12345;
                int index1 = -12345;
                int index2 = -12345;
                double[] x = null;
                string var2 = var;
                bool negative = false;
                if (var.StartsWith("-"))
                {
                    var2 = var2.Substring(1);
                    negative = true;
                }

                Series ts = O.GetIVariableFromString(G.Chop_FreqAdd(var2, EFreq.A), O.ECreatePossibilities.NoneReportError, true) as Series;

                if (ts == null)
                {
                    G.Writeln2("*** ERROR: Variable '" + var2 + "' does not exist");
                    throw new GekkoException();
                }
                else
                {
                    //Hmmm, Annual?? What about quarters/months??
                    x = ts.GetDataSequenceBEWARE(out index1, out index2, tStart0, tEnd);  //implicit ", false" ending this method, no setting of start/end period of timeseries
                    length = index2 - index1 + 1;
                    if (negative)
                    {
                        double[] xNew = new double[x.Length];
                        for (int i = 0; i < x.Length; i++)
                        {
                            //NaN and +/- Infinity pass ok through this
                            xNew[i] = -x[i];
                        }
                        x = xNew;  //points to this temp array: otherwise real timeseries data will be overridden
                    }
                }
                Buffer.BlockCopy(x, 8 * index1, aX, 8 * id * obs, 8 * length);  //TODO: what if out of bounds regarding x???
                //I guess after this loop is done, the whole of a[,] will be filled with data or NaN.
                //It should not be possible that there is a 0 left originating from "double[,] a = new double[vars, obs];"
            }
            return aX;
        }

        //dynamic methods
               

        private static void LUDecompose(ref double[,] lu, ref int[] indx)
        {
            

            //Running a 1000x1000 dense matrix with code below takes about 2800 ms
            //Compare this with the 1200 ms described here: http://mathnetnumerics.codeplex.com/discussions/360326
            //See also the 1800 ms here: http://www.meta-numerics.net/Pages/Performance.aspx
            //Random r = new Random();
            //int n2 = 1000;
            //lu = new double[n2, n2];
            //indx = new int[n2];
            //for (int ii = 0; ii < n2; ii++)
            //{
            //    for (int jj = 0; jj < n2; jj++)
            //    {
            //        lu[ii, jj] = r.NextDouble();
            //    }
            //}
            //DateTime t0 = DateTime.Now;


            int i, imax = 0, j, k, n = lu.GetLength(0);
            double big, temp1, temp2;
            double[] vv = new double[n];
            //preChecks
            if (lu.GetLength(0) != lu.GetLength(1) || lu.GetLength(0) != indx.Length)
                throw new Exception("matrix dimension problem only use square matrices");
            //for each row find the absolute value of the greatest cell and store in vv
            for (i = 0; i < n; i++)
            {
                big = 0.0;
                for (j = 0; j < n; j++)
                    if ((temp1 = Math.Abs(lu[i, j])) > big) big = temp1;
                if (big == 0.0)
                {
                    int endoNumber = (int)Program.model.modelGekko.m2.simulFeedback[i];
                    EquationHelper eh = Program.model.modelGekko.equations[endoNumber];
                    G.Writeln();
                    G.Writeln2("*** ERROR: Trying to invert a singular matrix. This is because the equations are");
                    G.Writeln("           somehow undetermined, for instance because of an equation 'X = X',", Color.Red);
                    G.Writeln("           or an equation 'Y = Z', where Z is exogenous, and the variable", Color.Red);
                    G.Writeln("           Y has been exogenized (by means of the EXO command).", Color.Red);
                    G.Writeln("           The problem arises in the following equation:", Color.Red);
                    G.Writeln(eh.equationText, Color.Blue);
                    G.Writeln("           Please correct the equation or the goals/means (ENDO/EXO variables).", Color.Red);
                    G.Writeln();
                    throw new GekkoException();
                }

                vv[i] = 1.0 / big;//calculate scaling and save
            }
            //k is for colums start with the left look for the columns under the diagonal for the biggest value want to move the largest over diagonal
            for (k = 0; k < n; k++)//find the largest pivot element
            {
                big = 0.0;
                for (i = k; i < n; i++)
                {
                    temp1 = vv[i] * Math.Abs(lu[i, k]);
                    if (temp1 > big)
                    {
                        big = temp1;
                        imax = i;
                    }
                }

                if (k != imax)//do we need a row change
                {
                    for (j = 0; j < n; j++)// counter for the colums
                    {
                        temp1 = lu[imax, j];// change the rows
                        lu[imax, j] = lu[k, j];
                        lu[k, j] = temp1;
                    }
                    vv[imax] = vv[k];
                    //G.Writeln2("Swapped row " + k + " and row " + imax);
                }
                indx[k] = imax;

                for (i = k + 1; i < n; i++)
                {
                    temp1 = lu[i, k] /= lu[k, k];//divide pilot element
                    if (temp1 != 0d)  //TT changed: changes time from 4 secs on 813x813 to 1.75 secs
                    {
                        for (j = k + 1; j < n; j++)
                        {
                            //lu[i, j] -= temp * lu[k, j];  //<---- original before TT changed, the change improves 1.75 secs to 1.57 secs.
                            temp2 = lu[k, j];
                            if (temp2 != 0d)
                            {
                                lu[i, j] -= temp1 * temp2;
                            }
                        }
                    }
                }
            }

            

        }

        private static void Density(double[,] lu)
        {
            double sum = 0d;
            double zero = 0d;
            foreach (double d in lu)
            {
                sum++;
                if (d == 0d) zero++;
            }
            double ratio = zero / sum;
            //G.Writeln2("Density = " + (1-ratio) * 100 + "%");
        }

        private static void Solve(ref double[] b, ref double[] x, int[] indx, double[,] lu)
        {
            if (b.Length != lu.GetLength(0) || x.Length != lu.GetLength(0))
                throw new Exception("vector dimension problem");

            int n = lu.GetLength(0);
            int i, ii = 0, ip, j;
            double sum = 0;
            for (i = 0; i < n; i++) x[i] = b[i];
            for (i = 0; i < n; i++)
            {
                ip = indx[i];
                sum = x[ip];
                x[ip] = x[i];
                if (ii != 0)
                    for (j = ii - 1; j < i; j++) sum -= lu[i, j] * x[j];
                else if (sum != 0.0)
                    ii = i + 1;
                x[i] = sum;
            }
            for (i = n - 1; i >= 0; i--)
            {
                sum = x[i];
                for (j = i + 1; j < n; j++) sum -= lu[i, j] * x[j];
                x[i] = sum / lu[i, i];
            }
        }

        private static StringBuilder ConvertPcimTable(string file)
        {
            StringBuilder x = new StringBuilder();
            int start = 4;
            int longest = 0;

            for (int u = 0; u < 2; u++)
            {
                x = new StringBuilder();

                string colformat = "";

                x.AppendLine("<?xml version=`1.0` encoding=`Windows-1252`?>");
                x.AppendLine("<gekkotable>");
                x.AppendLine("  <tableversion>1.0</tableversion>");
                x.AppendLine("  <header>");
                x.AppendLine("    <printinfo type=`full` />");
                x.AppendLine("  </header>");
                x.AppendLine("  <table>");
                x.AppendLine("    <cols>");
                x.AppendLine("      <colborder />");
                x.AppendLine("      <col txtalign=`left`></col>");
                x.AppendLine("      <colglue />");
                x.AppendLine("      <col txtalign=`right` />");
                x.AppendLine("      <colborder />");
                x.AppendLine("      <col type=`expand` txtalign=`center`></col>");
                x.AppendLine("      <colborder />");
                x.AppendLine("    </cols>");
                x.AppendLine("    <rows>");

                string tab = ",";
                //string file = Program.options.folder_working + "\\s56b.TAB";
                List<string> lines = G.ExtractLinesFromText(GetTextFromFileWithWait(file));
                int counter = 0;
                foreach (string line2 in lines)
                {
                    counter++;
                    string line = line2.Trim();
                    //char[] c = line.ToCharArray();
                    if (line.StartsWith("01"))
                    {
                        int ii = ToInt(Substring(line, 3, 5));
                        if (ii == int.MaxValue || ii < 1)
                        {
                            TableConvertError(u, file, counter, line, "Number of variable fields < 1...??");
                        }
                        else if (ii > 1)
                        {
                            TableConvertError(u, file, counter, line, "Converter only works with 1 variable field.");
                        }
                        ii = 1;
                    }
                    else if (line.StartsWith("02"))
                    {
                        int w = ToInt(Substring(line, 3, 4));
                        if (w == int.MaxValue || w < 1)
                        {
                            TableConvertError(u, file, counter, line, "Width problem....");
                        }
                        string code = Substring(line, 5, 5).ToLower();
                        if (code == "i")
                        {
                        }
                        else if (code == "f")
                        {
                        }
                        else
                        {
                            TableConvertError(u, file, counter, line, "Number format is not 'i' or 'f'...");
                        }
                        int decimals = int.MaxValue;
                        if (line.Length > 5) decimals = ToInt(Substring(line, 6, 6));
                        if (decimals == int.MaxValue)
                        {
                            if (code == "i")
                            {
                            }
                            else
                            {
                                TableConvertError(u, file, counter, line, "Number of decimals not found for 'f'-number");
                            }
                            colformat = "f" + w + ".0";
                        }
                        else
                        {
                            colformat = "f" + w + "." + decimals;
                        }
                        x.AppendLine("      <rowformat varformat=`" + colformat + "`/>");
                    }
                    else if (line.StartsWith("03"))
                    {
                        //ignore these borders
                    }
                    else if (line.StartsWith("06"))
                    {
                        string s = line.Substring(start - 1);

                        s = G.ReplaceFirstOccurrence(s, tab, "");

                        if (u == 0 && s != "" && !line.Substring(start - 2).StartsWith(" "))
                        {
                            start = 3;
                            //continue;  //for instance 06Investments
                        }
                        string[] ss = s.Split('');
                        string s1 = ss[0].TrimEnd();
                        string s2 = null;
                        if (ss.Length > 1) s2 = ss[1].Trim();
                        if (ss.Length > 2)
                        {
                            TableConvertError(u, file, counter, line, "Only expected 2 delimiter characters...");
                        }
                        if (s2 == null || s2 == "")
                        {
                            string span = "2";
                            if (u == 1 && s1.Length > longest) span = "3";
                            x.AppendLine("      <row>");
                            x.AppendLine("        <txt colspan=`" + span + "`>" + s1 + "</txt>");
                            x.AppendLine("      </row>");
                            //if (s1.Length > longest) longest = s1.Length;
                        }
                        else
                        {
                            string lbl = "";
                            string text = "";
                            string var = "";
                            if (s1 != "" && s2 != "")
                            {
                                if (s1.ToLower().EndsWith(s2.ToLower()))
                                {
                                    //easy, same name both places
                                    if (s1.Length == s2.Length)
                                    {
                                        text = "";
                                        lbl = "$";
                                        var = s2;
                                    }
                                    else
                                    {
                                        string s3 = s1.Substring(s1.Length - s2.Length - 1, 1);
                                        if (s3 == " " || s3 == "." || s3 == ",")
                                        {
                                            string temp = s1.Substring(0, s1.Length - s2.Length).TrimEnd();
                                            if (temp.Length == 0) text = " ";
                                            else text = temp;
                                            lbl = "$";
                                            var = s1.Substring(s1.Length - s2.Length).Trim();
                                        }
                                    }
                                }
                            }

                            if (text == "")
                            {
                                string lastWord = "";
                                for (int i = s1.Length - 1; i >= 1; i--)
                                {
                                    if (!(G.IsLetterOrDigitOrUnderscore(s1[i]) || s1[i] == '+' || s1[i] == '-' || s1[i] == '*' || s1[i] == '/' || s1[i] == '(' || s1[i] == ')'))
                                    {
                                        if (s1[i] == ' ' && s1[i - 1] == ' ')  //two blanks before word
                                        {
                                            if (i < s1.Length - 1)
                                            {
                                                lastWord = s1.Substring(i + 1);
                                            }
                                        }
                                        break;
                                    }
                                }

                                if (lastWord != "")
                                {

                                    //try looking at last word
                                    text = s1.Substring(0, s1.Length - lastWord.Length).TrimEnd();
                                    lbl = lastWord;
                                    var = s2.Trim();
                                }
                            }

                            if (text == "")
                            {
                                text = s1.TrimEnd();
                                lbl = "";
                                var = s2.Trim();
                            }

                            if (var.ToLower().StartsWith("series")) var = var.Substring(4);
                            var = var.Replace("$", "");
                            var = var.Replace(";", "");
                            var = var.Trim();

                            text = SpecialXmlChars(text);

                            x.AppendLine("      <row>");
                            x.AppendLine("        <txt>" + text + "</txt>");
                            x.AppendLine("        <txt>" + lbl + "</txt>");
                            if (text.Length + lbl.Length + 2 > longest) longest = text.Length + lbl.Length + 2;
                            if (var.ToLower() == "year")
                            {
                                x.AppendLine("        <date/>");
                            }
                            else
                            {
                                x.AppendLine("        <var>" + var + "</var>");
                            }
                            x.AppendLine("      </row>");
                        }
                    }
                    else if (line.StartsWith("07"))
                    {
                        //blank line
                        x.AppendLine("      <row/>");
                    }
                    else if (line.StartsWith("08"))
                    {
                        //sideskift
                    }
                    else if (line.StartsWith("11"))
                    {
                        string s = Substring(line, 3, 3);
                        if (s == null)
                        {
                            TableConvertError(u, file, counter, line, "Problem with delimiter character");
                        }
                        tab = s;
                    }
                    else if (line.StartsWith("12"))
                    {
                        if (line.Length > 2)
                        {
                            string s = line.Substring(2).Trim();
                            x.AppendLine("<!-- " + SpecialXmlChars(s) + " -->");
                        }
                    }
                    else if (line.StartsWith("13"))
                    {
                        //finish of this table
                    }
                    else if (line.StartsWith("18"))
                    {
                        //new screen
                    }
                    else if (line.StartsWith("04") || line.StartsWith("05") || line.StartsWith("41"))
                    {
                        string s = "";
                        if (line.Length == 2)
                        {
                        }
                        else
                        {
                            s = line.Substring(start - 1);
                            if (u == 0 && s != "" && !line.Substring(start - 2).StartsWith(" "))
                            {
                                start = 3;
                                //continue;  //for instance 41Investments
                            }
                        }
                        s = SpecialXmlChars(s);
                        string span = "2";
                        if (u == 1 && s.Length > longest) span = "3";
                        x.AppendLine("      <row>");
                        x.AppendLine("        <txt colspan=`" + span + "`>" + s + "</txt>");
                        x.AppendLine("      </row>");
                        //if (s.Length > longest) longest = s.Length;
                    }
                    else if (line.StartsWith("20") || line.StartsWith("21"))
                    {
                        TableConvertError(u, file, counter, line, "Code 20 and 21 (multiplier) are not converted");
                    }
                    else if (line.StartsWith("22"))
                    {
                        TableConvertError(u, file, counter, line, "Code 22 (scaling) is not converted -- please fix with 'varscale' in XML table");
                    }
                    else if (line.StartsWith("24"))
                    {
                        TableConvertError(u, file, counter, line, "Code 24 (% growth under variables) is not converted");
                    }
                    else if (line.StartsWith("27"))
                    {
                        if (line.Substring(2, 1).ToLower() == "t")
                        {
                            x.AppendLine("      <rowformat vardisplay=`p`/>");
                        }
                        if (line.Substring(2, 1).ToLower() == "f")
                        {
                            x.AppendLine("      <rowformat vardisplay=`n`/>");
                        }
                    }
                    else if (line.StartsWith("28"))
                    {
                        TableConvertError(u, file, counter, line, "Code 28 (differences) is not converted");
                    }
                    else if (line.StartsWith("30"))
                    {
                        TableConvertError(u, file, counter, line, "Code 28 (multiplier difference) is not converted");
                    }
                    else if (line.StartsWith("44") || line.StartsWith("45") || line.StartsWith("46") || line.StartsWith("47"))
                    {
                        //ignore table headers
                    }
                    else if (line.StartsWith("55"))
                    {
                        TableConvertError(u, file, counter, line, "Code 55 (alignment) is not converted");
                    }
                    else if (line.StartsWith("91"))
                    {
                        x.AppendLine("      <rowborder/>");
                    }
                    else if (line.StartsWith("92"))
                    {
                        x.AppendLine("      <rowborder/>");
                    }
                    else if (line.StartsWith("93"))
                    {
                        x.AppendLine("      <rowborder/>");
                    }
                    else if (line.StartsWith("94"))
                    {
                        x.AppendLine("      <rowborder/>");
                    }
                    else if (line.StartsWith("95"))
                    {
                        x.AppendLine("      <rowborder/>");
                    }
                    else if (line.StartsWith("96"))
                    {
                        x.AppendLine("      <rowborder/>");
                    }
                    else if (line.StartsWith("97"))
                    {
                        x.AppendLine("      <rowborder/>");
                    }
                    else if (line.StartsWith("98"))
                    {
                        x.AppendLine("      <rowborder/>");
                    }
                    else if (line.StartsWith("99"))
                    {
                        //finish tabledef
                    }
                    else if (line.StartsWith("menu"))
                    {
                        //ignore menu calls
                    }
                    else if (line == "")
                    {
                    }
                    else
                    {
                        string code = "";
                        if (line.Length >= 2) code = line.Substring(0, 2);
                        TableConvertError(u, file, counter, line, "Did not recognize this table code: " + code);
                    }
                }  //end of foreach

                x.AppendLine("    </rows>");
                x.AppendLine("  </table>");
                x.AppendLine("</gekkotable>");

                x.Replace("`", "\"");
                //break;
            }  // for u

            return x;
        }

        private static string SpecialXmlChars(string text)
        {

            text = text.Replace("&", "&amp;");
            text = text.Replace("<", "&lt;");
            text = text.Replace(">", "&gt;");
            text = text.Replace("<", "");
            text = text.Replace("\"", "&quot;");
            text = text.Replace("'", "&#39;");
            return text;
        }

        private static void TableConvertError(int u, string file, int counter, string line, string s)
        {
            if (u > 0)
            {
                Globals.convertTableErrorCounter++;
                G.Writeln();
                G.Writeln2("*** ERROR: In " + file + " line " + counter);
                G.Writeln("           Could not understand: " + line, Color.Red);
                G.Writeln("           " + s, Color.Red);
                G.Writeln("           " + "(Total error count: " + Globals.convertTableErrorCounter + ")");
                G.Writeln();
            }
        }

        private static void MenuConvertError(string file, int counter, string line, string s)
        {
            if (true)
            {
                Globals.convertMenuErrorCounter++;
                G.Writeln();
                G.Writeln2("*** ERROR: In " + file + " line " + counter);
                G.Writeln("           Could not understand: " + line, Color.Red);
                G.Writeln("           " + s, Color.Red);
                G.Writeln("           " + "(Total error count: " + Globals.convertMenuErrorCounter + ")");
                G.Writeln();
            }
        }

        private static string Substring(string line, int p1, int p2)
        {
            string x = null;
            try
            {
                x = line.Substring(p1 - 1, p2 - p1 + 1);
            }
            catch (Exception e) { };
            return x;
        }

        private static int ToInt(string input)
        {
            int output = int.MaxValue;
            if (input == null) return output;
            try
            {
                output = int.Parse(input);
            }
            catch (Exception e) { };
            return output;
        }

        private static string ReadFromDb()
        {
            return "abcdefghijklmnopqrstuvyxz0123456789abcdefghijklmnopqrstuvyxz0123456789abcdefghijklmnopqrstuvyxz0123456789" + 1;
        }

        public static void Mem(string tpe)
        {
            //call with null, string, date, val --> will be lower-case when called

            bool foundSomething = false;

            List<Databank> banks = new List<Databank>();
            banks.Add(Program.databanks.GetLocal());
            banks.AddRange(Program.databanks.storage);
            banks.Add(Program.databanks.GetGlobal());

            if (tpe == null || tpe == "val" || tpe == "date" || tpe == "string")
            {   //scalars

                foreach (Databank db in banks)
                {
                    int counter = 0;

                    List<string> keys = new List<string>();

                    foreach (KeyValuePair<string, IVariable> kvp in db.storage)
                    {
                        if (kvp.Value.Type() == EVariableType.Val || kvp.Value.Type() == EVariableType.Date || kvp.Value.Type() == EVariableType.String)
                        {
                            if (tpe == null)
                            {
                                keys.Add(kvp.Key);
                            }
                            else
                            {
                                if (tpe == "val" && kvp.Value.Type() == EVariableType.Val) keys.Add(kvp.Key);
                                else if (tpe == "date" && kvp.Value.Type() == EVariableType.Date) keys.Add(kvp.Key);
                                else if (tpe == "string" && kvp.Value.Type() == EVariableType.String) keys.Add(kvp.Key);
                            }
                        }
                    }

                    if (keys.Count() == 0) continue;

                    foundSomething = true;

                    keys.Sort(StringComparer.OrdinalIgnoreCase);

                    Table tab = new Table();
                    int row = 1;
                    tab.SetBorder(row, 1, row, 3, BorderType.Top);
                    tab.Set(row, 1, "type      ");
                    tab.Set(row, 2, "name    ");  //blanks to get some spacing
                    tab.Set(row, 3, "value    ");
                    tab.SetBorder(row, 1, row, 3, BorderType.Bottom);
                    row++;
                    foreach (string s in keys)
                    {
                        IVariable a = db.storage[s];
                        string value = "";
                        if (a.Type() == EVariableType.Date)
                        {
                            if (tpe != null && tpe != "date") continue;
                            value = G.FromDateToString(a.ConvertToDate(O.GetDateChoices.Strict));
                        }
                        else if (a.Type() == EVariableType.String)
                        {
                            if (tpe != null && tpe != "string") continue;
                            value = "'" + a.ConvertToString() + "'";
                        }
                        else if (a.Type() == EVariableType.Val)
                        {
                            if (tpe != null && tpe != "val") continue;
                            value = a.ConvertToVal().ToString();
                            if (value == "NaN") value = "M";
                        }

                        string type = a.Type().ToString().ToUpper();

                        tab.Set(row, 1, type);
                        tab.Set(row, 2, s);
                        tab.Set(row, 3, value);
                        row++;
                        counter++;
                    }
                    tab.SetBorder(row - 1, 1, row - 1, 3, BorderType.Bottom);

                    string tpe2 = "";
                    if (tpe != null) tpe2 = " " + tpe.ToUpper();
                    G.Writeln2(db.name + " databank: " + counter + tpe2 + " scalar(s) found");
                    foreach (string s in tab.Print()) G.Writeln(s);
                }
                if (!foundSomething)
                {
                    if (tpe == null) G.Writeln2("No scalars found in any open databank");
                    else G.Writeln2("No " + tpe.ToUpper() + " scalar(s) found in any open databank");
                }
            }
            else if (tpe == "ser" || tpe == "series")
            {
                Table tab = new Table();
                int row = 1;
                tab.SetBorder(row, 1, row, 2, BorderType.Top);

                bool hit = false;

                foreach (Databank db in banks)
                {
                    string s = null;
                    Dictionary<EFreq, long> count = new Dictionary<EFreq, long>();
                    foreach (KeyValuePair<string, IVariable> kvp in db.storage)
                    {
                        if (kvp.Value.Type() != EVariableType.Series) continue;
                        Series ts = kvp.Value as Series;
                        if (!count.ContainsKey(ts.freq)) count.Add(ts.freq, 0);
                        count[ts.freq]++; hit = true;
                    }
                    foreach (KeyValuePair<EFreq, long> kvp in count)
                    {
                        s += kvp.Value + " (" + G.GetFreqString(kvp.Key) + "), ";
                    }
                    if (s != null)
                    {
                        s = s.Substring(0, s.Length - 2);
                        tab.Set(row, 1, db.name);
                        tab.Set(row, 2, s);
                        row++;
                    }
                }
                tab.SetBorder(row - 1, 1, row - 1, 2, BorderType.Bottom);

                if (hit)
                {
                    G.Writeln();
                    foreach (string s in tab.Print()) G.Writeln(s);
                }
                else
                {
                    G.Writeln2("No series found in any open databank");
                }
            }
            else  //list, map, matrix
            {
                foreach (Databank db in banks)
                {
                    int counter = 0;

                    List<string> keys = new List<string>();

                    foreach (KeyValuePair<string, IVariable> kvp in db.storage)
                    {
                        if (tpe == "list" && kvp.Value.Type() == EVariableType.List) keys.Add(kvp.Key);
                        else if (tpe == "map" && kvp.Value.Type() == EVariableType.Map) keys.Add(kvp.Key);
                        else if (tpe == "matrix" && kvp.Value.Type() == EVariableType.Matrix) keys.Add(kvp.Key);
                    }

                    if (keys.Count() == 0) continue;

                    foundSomething = true;

                    keys.Sort(StringComparer.OrdinalIgnoreCase);

                    Table tab = new Table();
                    int row = 1;
                    tab.SetBorder(row, 1, row, 4, BorderType.Top);
                    tab.Set(row, 1, "type    ");
                    tab.Set(row, 2, "name    ");
                    tab.Set(row, 3, "size    ");  //blanks to get some spacing                    
                    tab.SetBorder(row, 1, row, 4, BorderType.Bottom);
                    row++;
                    foreach (string s in keys)
                    {
                        IVariable a = db.storage[s];
                        string value = "";
                        string modelList = "";
                        if (a.Type() == EVariableType.List)
                        {
                            List list = a as List;
                            value = list.list.Count().ToString();
                            if (G.Equal(db.name, "Global"))
                            {
                                if (G.Equal(s, "#all") || G.Equal(s, "#endo") || G.Equal(s, "#exo") || G.Equal(s, "#exod") || G.Equal(s, "#exodjz") || G.Equal(s, "#exoj") || G.Equal(s, "#exotrue") || G.Equal(s, "#exoz"))
                                {
                                    modelList = "(model list)";
                                }
                            }
                        }
                        else if (a.Type() == EVariableType.Map)
                        {
                            Map map = a as Map;
                            value = map.storage.Count().ToString();
                        }
                        else if (a.Type() == EVariableType.Matrix)
                        {
                            Matrix matrix = a as Matrix;
                            value = matrix.DimensionsAsString();
                        }

                        string type = a.Type().ToString().ToUpper();

                        tab.Set(row, 1, type);
                        tab.Set(row, 2, s);
                        tab.Set(row, 3, value);
                        tab.Set(row, 4, modelList);
                        row++;
                        counter++;
                    }
                    tab.SetBorder(row - 1, 1, row - 1, 4, BorderType.Bottom);
                                        
                    G.Writeln2(db.name + " databank: " + counter + " " + tpe.ToUpper() + "s found");
                    foreach (string s in tab.Print()) G.Writeln(s);
                }
                if (!foundSomething)
                {   
                    G.Writeln2("No " + tpe.ToUpper() + " variables found in any open databank");
                }
            }
        }

        public static void SplitCommandBeingExecuted(out string originalFileName, out int lineNumber, string s)
        {
            string[] split = s.Split('¤');
            originalFileName = split[0];
            string lineNumber2 = split[1];
            lineNumber = int.Parse(lineNumber2);  //1-based it seems
        }

        public static List<string> CreateListOfStringsFromString(string inputFile)
        {
            List<string> inputFileLines = new List<string>();
            StringReader inputFileStringReader = new StringReader(inputFile);
            while (true)
            {
                string aLine = inputFileStringReader.ReadLine();
                if (aLine != null)
                {
                    inputFileLines.Add(aLine);
                }
                else
                {
                    break;
                }
            }
            return inputFileLines;
        }

        public static void Decomp(O.Decomp1 o)
        {
            

            DecompOptions decompOptions = new DecompOptions();                        
            decompOptions.t1 = o.t1;
            decompOptions.t2 = o.t2;
            decompOptions.expressionOld = o.label;            
            decompOptions.expression = o.expression;
            //decompOptions.smplForFunc = o.smplForFunc;
            decompOptions.prtOptionLower = o.opt_prtcode.ToLower();
            decompOptions.name = o.name;
            Decomp(decompOptions);

        }
                

        public static string[] GetListOfStringsFromListOfIvariables(IVariable[] indexes)
        {
            string[] keys = new string[indexes.Length];
            int stringCount = 0;
            int i = -1;
            foreach (IVariable iv in indexes)
            {
                i++;
                if (iv.Type() == EVariableType.String)
                {
                    //note: see same kind of code just below, //#98073245243875
                    stringCount++;
                    ScalarString ss = iv as ScalarString;
                    keys[i] = ss.string2;
                }
                else if (iv.Type() == EVariableType.Val)  //will handle 007 in x[a, 007], will become x['a', '007']
                {
                    //note: see same kind of code just below, //#98073245243875
                    int ii = O.ConvertToInt(iv, false);
                    if (ii != int.MaxValue)
                    {
                        stringCount++;
                        byte b = (iv as ScalarVal).numberOfLeadingZeroes;
                        HandleLeadingZeroes(keys, i, b, ii);
                    }
                }
                else if (iv.Type() == EVariableType.List)
                {
                    List iv_list = iv as List;
                    if (iv_list.Count() == 1)
                    {
                        //Singleton list is allowed as a scalar
                        IVariable singleton = iv_list.list[0];
                        if (singleton.Type() == EVariableType.String)
                        {
                            //note: see same kind of code just above, //#98073245243875
                            stringCount++;
                            ScalarString ss = singleton as ScalarString;
                            keys[i] = ss.string2;
                        }
                        else if (singleton.Type() == EVariableType.Val)  //will not handle 007 in x[a, 007], must be x[a, '007']
                        {
                            //note: see same kind of code just above, //#98073245243875
                            int ii = O.ConvertToInt(singleton, false);
                            if (ii != int.MaxValue)
                            {
                                stringCount++;
                                keys[i] = ii.ToString();
                                byte b = (singleton as ScalarVal).numberOfLeadingZeroes;
                                HandleLeadingZeroes(keys, i, b, ii);

                            }
                        }
                    }
                }
            }
            if (indexes.Length != stringCount)
            {
                keys = null;  //signals a problem
            }

            return keys;
        }

        private static void HandleLeadingZeroes(string[] keys, int i, byte b, int ii)
        {
            string z = null;            
            if (b > 0)
            {
                z = new string('0', b);
            }
            if (ii < 0)
            {
                //This should never happen: Gekko will not parse x[-0007] as a something that can
                //be parsed into a string --> it will always be interpreted as a lag, because the
                //first char after '[' is a '-'. So x[-...] or x[+...] are always lags or leads.
                //This is to avoid x[5] being interpreted as x leaded 5 periods, rather than, say,
                //five-year olds in the population.
                keys[i] = "-" + z + (-ii).ToString(); //b = 3, ii = -7 --> "-0007"
            }
            else
            {
                keys[i] = z + ii.ToString(); //b = 3, ii = 7 --> "0007"
            }
        }

        public static IVariable GetListOfIVariablesFromListOfScalarStrings(IVariable rv)
        {
            List rv_list = rv as List;
            List y = new List();
            if (rv_list == null)
            {
                G.Writeln2("*** ERROR: #09874323987");
                throw new GekkoException();
            }
            else
            {
                foreach (IVariable iv in rv_list.list)
                {
                    ScalarString iv_string = iv as ScalarString;
                    if (iv_string == null)
                    {
                        G.Writeln2("*** ERROR: #09874323987");
                        throw new GekkoException();
                    }
                    IVariable x = O.GetIVariableFromString(iv_string.string2, O.ECreatePossibilities.NoneReportError, true);  //should never return an error here
                    y.Add(x);
                }
                rv = y;  //point to this instead, it is List<ScalarString> transformed into List<IVariable>
            }

            return rv;
        }

        public static IVariable[] GetListOfIVariablesFromListOfStrings(string[] indexes)
        {
            IVariable[] keys = new IVariable[indexes.Length];
            int stringCount = 0;
            int i = -1;
            foreach (string s in indexes)
            {
                i++;
                keys[i] = new ScalarString(indexes[i]);
            }
            return keys;
        }

        public static List<string> UnfoldFlexibleListIntoListOfStrings(IVariable iv)
        {
            List<string> rv = new List<string>();

            if (iv.Type() == EVariableType.String)
            {
                rv.Add(iv.ConvertToString());
            }
            else if (iv.Type() == EVariableType.List)
            {
                List l = iv as List;
                foreach(IVariable iv2 in l.list)
                {
                    if (iv2.Type() == EVariableType.String)
                    {
                        rv.Add(iv2.ConvertToString());
                    }
                }
            }            
            return rv;
        }


        public static void Decomp(DecompOptions decompOptions)
        {
            Thread thread = new Thread(new ParameterizedThreadStart(DecompThreadFunction));
            thread.SetApartmentState(ApartmentState.STA);
            thread.CurrentCulture = CultureInfo.InvariantCulture;
            //thread.CurrentCulture = new System.Globalization.CultureInfo("en-US");  //gets . instead of , in doubles
            thread.Start(decompOptions);
            if (true)
            {
                //Also see #9237532567
                //This stuff makes sure we wait for the window to open, before we move on with the code.
                for (int i = 0; i < 6000; i++)  //up to 60 s, then we move on anyway
                {
                    System.Threading.Thread.Sleep(10);  //0.01s
                    if (decompOptions.numberOfRecalcs > 0)
                    {
                        break;
                    }
                }
            }
        }


        // Thread for decomp window
        public static void DecompThreadFunction(Object o)
        {
            DecompOptions decompOptions = (DecompOptions)o;
            //decompOptions.isCalledFromDecompWindow = false;

            Window1 w = null;
            if (true)
            {
                w = new Window1(decompOptions);
                Globals.windowsDecomp.Add(w);
            }

            //if (decompOptions.expressionOld == null && decompOptions.variable != null)
            //{
            //    decompOptions.expressionOld = decompOptions.variable;
            //}

            //if (decompOptions.name == null && decompOptions.variable != null)
            //{
            //    decompOptions.name = decompOptions.variable;
            //}

            string name = null;
            if (decompOptions.name != null)
            {
                List name_list = decompOptions.name as List;
                List<string> name_list2 = O.Restrict(name_list, false, false, false, true);
                if (name_list2.Count != 1)
                {
                    G.Writeln2("*** ERROR: List of names not accepted in DECOMP");
                    throw new GekkoException();
                }
                name = name_list2[0];
            }
            else
            {
                if (decompOptions.variable != null) name = decompOptions.variable;
            }
                        
            if (name != null)
            {
                string name2 = G.Chop_GetName(name);
                List<string> name3 = G.Chop_GetIndex(name);

                decompOptions.variable = name2;
                decompOptions.variable_subelement = name3;
                decompOptions.expressionOld = null;
                decompOptions.expression = null;

                if (Program.model.modelGams != null)
                {
                    if (Program.model.modelGams == null)
                    {
                        G.Writeln2("*** ERROR: DECOMP: A GAMS model is not loaded, cf. the MODEL command.");
                        throw new GekkoException();
                    }
                    if (Program.model.modelGams.equationsByVarname != null)
                    {
                        ModelGamsEquation found = GamsModel.DecompEvalGams(null, decompOptions.variable);
                        decompOptions.expression = found.expressions[0];
                        decompOptions.expressionOld = found.lhs + " = " + found.rhs;
                    }
                }
                else
                {

                    if (!G.HasModelGekko())
                    {
                        G.Writeln2("*** ERROR: DECOMP: A model is not loaded, cf. the MODEL command.");
                        throw new GekkoException();
                    }

                    EquationHelper found = DecompEval(decompOptions.variable);
                    decompOptions.expression = Globals.expressions[0];
                    decompOptions.expressionOld = found.equationText;
                }
            }

            if (decompOptions.name == null)
            {
                w.Title = "Decompose expression";
            }
            else
            {
                w.Title = "Decompose " + decompOptions.variable + "";
            }
            w.Tag = decompOptions;

            w.SetRadioButtons();
            w.RecalcCellsWithNewType();
            decompOptions.numberOfRecalcs++;  //signal for Decomp() method to move on

            if (w.isClosing)  //if something goes wrong, .isClosing will be true
            {
                //The line below removes the window from the global list of active windows.
                //Without this line, this half-dead window will mess up automatic closing of windows (Window -> Close -> Close all...)
                if (Globals.windowsDecomp.Count > 0) Globals.windowsDecomp.RemoveAt(Globals.windowsDecomp.Count - 1); }
            else
            {
                if (decompOptions.isNew)
                {
                    //do not show it yet
                }
                else
                {
                    if (!G.IsUnitTesting())
                    {
                        w.ShowDialog();
                        w.Close();  //probably superfluous
                        w = null;  //probably superfluous
                    }
                }
            }
        }
        
        public static EquationHelper DecompEval(string variable)
        {
            EquationHelper found = Program.FindEquationByMeansOfVariableName(variable);
            if (found == null)
            {
                G.Writeln2("*** ERROR: DECOMP: Could not find variable '" + variable + "' as left-hand side in model");
                throw new GekkoException();
            }
            string[] ss = found.equationText.Split('=');

            string rhs = ss[1].Trim();

            string lhsText = ss[0].Trim();
            string[] ss0 = lhsText.Split(new char[] { ' ' }, StringSplitOptions.RemoveEmptyEntries);
            if (!G.Equal(ss0[0], "frml"))
            {
                G.Writeln2("*** ERROR: Model equation '" + variable + "': Equation does not start with 'frml'");
                throw new GekkoException();
            }

            string lhs = null;
            for (int i = 2; i < ss0.Length; i++)
            {
                lhs += ss0[i];
            }
            lhs = lhs.Trim();  //trimmed with no blanks                                                              

            if (rhs.EndsWith("$")) rhs = rhs.Substring(0, rhs.Length - 1) + ";";  //only replace last $, not other $

            rhs = rhs.Trim();
            if (rhs.EndsWith(";")) rhs = rhs.Substring(0, rhs.Length - 1);

            for (int i = 1; i < 20; i++)
            {
                rhs = rhs.Replace("(-" + i + ")", "[-" + i + "]");
                rhs = rhs.Replace("(+" + i + ")", "[+" + i + "]");
            }

            string type = "none";  //dlog, dif, diff, log
            if (lhs.StartsWith("dlog(", StringComparison.OrdinalIgnoreCase))
            {
                type = "dlog";
                rhs = found.lhs + "[-1] * exp(" + rhs + ")";
            }
            else if (lhs.StartsWith("dif(", StringComparison.OrdinalIgnoreCase))
            {
                type = "dif";
                rhs = found.lhs + "[-1] + (" + rhs + ")";
            }
            else if (lhs.StartsWith("diff(", StringComparison.OrdinalIgnoreCase))
            {
                type = "diff";
                rhs = found.lhs + "[-1] + (" + rhs + ")";
            }
            else if (lhs.StartsWith("diff(", StringComparison.OrdinalIgnoreCase))
            {
                type = "log";
                rhs = "exp(" + rhs + ")";
            }

            if (found.equationCodeJ != "" && found.equationCodeJ != "_" && found.equationCodeJ != "__")
            {
                if (found.equationCodeJadditive)
                {
                    rhs = rhs + " + " + found.Jname;
                }
                else if (found.equationCodeJmultiplicative)
                {
                    rhs = "(" + rhs + ") * (1 + " + found.Jname + ")";
                }
                else
                {
                    //should not happen
                    G.Writeln2("*** ERROR: Problem with J-factors in equation " + found.lhs);
                    throw new GekkoException();
                }
            }

            if (found.equationCodeD != "" && found.equationCodeD != "_")
            {
                rhs = "(1 - " + found.Dname + ") * (" + rhs + ") + " + found.Dname + " * " + found.Zname;
            }

            //rhs = found.lhs + " = " + rhs + ";";
            rhs = rhs + ";";

            try
            {
                if (Globals.printAST)
                {
                    G.Writeln2("-------------- EVAL ---------------");
                    G.Writeln2("EVAL " + G.ReplaceGlueNew(rhs));
                    G.Writeln2("-----------------------------------");
                }                               
                
                CallEval(null, rhs);
            }
            catch (Exception e)
            {

            }

            return found;
        }

        
    
        public static string EquationLhsRhs(string lhs, string rhs, bool simple)
        {
            //This method is just so that we keep the two ways of decomposing together,
            //that is, calling an equation like DECOMP eq1, or DECOMP y = x1 + x2.
            //The former has simple = true, the latter simple = false.
            //if (simple) return "-(" + lhs + ") + " + rhs;
            //else return "O.Add(" + Globals.smpl + ", O.Negate(" + Globals.smpl + ", " + lhs + "), " + rhs + ")";
            if (simple)
                //return lhs + " - (" + rhs + " + " + Globals.decompExpressionName + ")";
                return lhs + " - (" + rhs + ")";
            else
                //return "O.Add(" + Globals.smpl + ", " + lhs + ", O.Negate(" + Globals.smpl + ", O.Add(" + Globals.smpl + ", " + rhs + ", " + Globals.decompExpressionName + ")))";
                return "O.Add(" + Globals.smpl + ", " + lhs + ", O.Negate(" + Globals.smpl + ", (" + rhs + ")))";
        }

        
        
        public static O.Prt PrtSnippet(string s, string s2)
        {
            CompilerResults cr;
            CreatePrtSnippetDll(out cr, s, s2);
            //O.Prt o = new O.Prt();
            //Object[] args = new Object[1];
            //args[0] = o;
            O.Prt o = null;
            try
            {
                Object ret = null;
                ret = cr.CompiledAssembly.GetType("Gekko.PrtSnippet").InvokeMember("Snippet", BindingFlags.InvokeMethod, null, null, null);
                o = (O.Prt)ret;
                return o;
            }
            catch (Exception e)
            {
                MessageBox.Show("ERROR: Some databanks or timeseries may be unavailable.\nPlease close the PLOT window and consult the error\nmessage in the Gekko output window.");
            }
            return o;
        }

        public static List<string> TestSim(List<string> list, int start, int end)
        {
            List<string> res = new List<string>();
            CompilerResults cr;
            CreateTestSimDll(out cr, list, start, end);
            Object[] args2 = new Object[1];
            args2[0] = res;
            cr.CompiledAssembly.GetType("Gekko.TranslatedCode").InvokeMember("TestSim", BindingFlags.InvokeMethod, null, null, args2);
            return res;
        }

        public static Table DecompHelper2(DecompOptions decompOptions, string transformationCodeAugmented, bool useLocalData)
        {
            GekkoTime tStart = decompOptions.t1;
            GekkoTime tEnd = decompOptions.t2;

            bool isRaw = false;
            if (transformationCodeAugmented.ToLower().StartsWith("x")) isRaw = true;

            string type = decompOptions.type;
            //GekkoParserTimePeriod tp = decompOptions.tp;
            //List<string> vars = decompOptions.vars;
            LocalBanks localBanks = decompOptions.localBanks;
            string modelHash = decompOptions.modelHash;

            Table table = new Table();  //!!BEWARE: this object is also used for flowcharts, so if the layout is changed, change it in flowcharts also

            decompOptions.decompTablesFormat.isPercentageType = false;
            if (transformationCodeAugmented.StartsWith("s") || transformationCodeAugmented.EndsWith("p") || transformationCodeAugmented.EndsWith("dp") || transformationCodeAugmented.EndsWith("q") || transformationCodeAugmented.EndsWith("mp"))
            {
                decompOptions.decompTablesFormat.isPercentageType = true;
                table.Set(1, 1, "% ");
            }

            string var2 = decompOptions.variable;

            if (true)
            {

                string leftSideVariable = G.GetUpperLowerCase(var2);

                if (!G.HasModelGekko())
                {
                    G.Writeln2("*** ERROR: DECOMP: There does not seem to be any model defined");
                    throw new GekkoException();
                }

                if (decompOptions.expressionOld == null && !Program.model.modelGekko.fromVariableToEquationNumber.ContainsKey(leftSideVariable + Globals.lagIndicator + "0"))
                {
                    G.Writeln2("*** ERROR: DECOMP: variable '" + leftSideVariable + "' does not exist as left-hand side variable in model");
                    throw new GekkoException();
                }

                Dictionary<string, string> precedents = null;
                EquationHelper eh = null;
                if (decompOptions.expressionOld != null)
                {
                    precedents = decompOptions.precedents[0];
                }
                else
                {
                    int eqNumber = (int)Program.model.modelGekko.fromVariableToEquationNumber[leftSideVariable + Globals.lagIndicator + "0"];
                    eh = Program.model.modelGekko.equations[eqNumber];
                    precedents = eh.precedentsWithLagIndicator;
                }

                CompilerResults cr;
                CreateDecompDll(leftSideVariable, decompOptions.expressionOld != null, eh, out cr);

                List<Dictionary<string, string>> precedents2 = new List<Dictionary<string, string>>();
                precedents2.Add(precedents);
                CheckVariableExistence(null, precedents2, false, false, false, false);  //checking in work bank, also ok for time decomp
                List<string> p2 = new List<string>();
                p2.AddRange(precedents.Keys);
                p2.Sort(StringComparer.InvariantCulture);

                //Beware: best to keep this constant for different years to deal with timeless variables
                double delta = Globals.jacobiDeltaProbe;  //can just as well be the same stepsize as used in newton algorithm

                Dictionary<string, List<DecompHelper>> decompHelpers = new Dictionary<string, List<DecompHelper>>();

                List<Databank> banks = new List<Databank>();

                Databank work = Program.databanks.GetFirst();
                Databank base2 = Program.databanks.GetRef();
                banks.Add(work);
                banks.Add(base2);
                List<string> allVariables = GetAllVariablesForDecompose(leftSideVariable, p2);

                int counter = -1;
                foreach (Databank bank in banks)
                {
                    counter++;
                    Databank databank = bank;

                    foreach (GekkoTime t in new GekkoTimeIterator(tStart.Add(-2), tEnd))  //-2 to deal with dp option
                    {
                        List<DecompHelper> decompContributions = new List<DecompHelper>();

                        double y0 = double.NaN;
                        y0 = RunDecompEquation(cr, t, databank);

                        double yDatabank = double.NaN;
                        if (decompOptions.expressionOld != null)
                        {
                            yDatabank = y0;
                        }
                        else
                        {
                            yDatabank = (databank.GetIVariable(leftSideVariable + Globals.freqIndicator + G.GetFreq(Program.options.freq)) as Series).GetDataSimple(t);
                        }

                        foreach (string variableWithLag in p2)
                        {
                            string variable = null;
                            int lag = -12345;
                            G.ExtractVariableAndLag(variableWithLag, out variable, out lag);

                            double before = (databank.GetIVariable(variable + Globals.freqIndicator + G.GetFreq(Program.options.freq)) as Series).GetDataSimple(t.Add(lag));
                            double after = before + delta;
                            (databank.GetIVariable(variable + Globals.freqIndicator + G.GetFreq(Program.options.freq)) as Series).SetData(t.Add(lag), after);
                            double y1 = double.NaN;
                            try
                            {
                                y1 = RunDecompEquation(cr, t, databank);
                            }
                            finally
                            {
                                //to make 100% sure it is always reset
                                (databank.GetIVariable(variable + Globals.freqIndicator + G.GetFreq(Program.options.freq)) as Series).SetData(t.Add(lag), before);
                            }

                            DecompHelper dh = new DecompHelper();
                            dh.variableWithLag = variableWithLag;
                            dh.y0 = y0;
                            dh.y1 = y1;
                            dh.x0 = before;
                            dh.x1 = after;
                            dh.slope = (dh.y1 - dh.y0) / (dh.x1 - dh.x0);
                            dh.z = yDatabank;
                            decompContributions.Add(dh);
                        }

                        //double truth = y1 - y0;
                        //double alpha = truth / sum;

                        //factors.Add(t + ": explanation = " + G.pchFormat(alpha * 100, 10) + "%");
                        //G.Writeln(t + "  " + "sum " + sum + "   truth " + truth + "  alpha " + alpha);
                        string key = "FIRST";
                        if (counter == 1) key = "REF";

                        decompHelpers.Add(key + "," + t.ToString(), decompContributions);  //key for instance "Work,2010"
                    }
                }

                if (decompOptions.decompTablesFormat.showErrors)
                {

                    if (isRaw)
                    {
                        table.Set(3, 1, Globals.decompText2a);
                        table.Set(4, 1, Globals.decompText1a);
                        table.Get(3, 1).backgroundColor = "LightYellow";
                        table.Get(4, 1).backgroundColor = "LightRed";
                    }
                    else
                    {
                        table.Set(3, 1, Globals.decompText2);
                        table.Set(4, 1, Globals.decompText1);
                        table.Get(3, 1).backgroundColor = "LightRed";
                        table.Get(4, 1).backgroundColor = "LightRed";
                    }
                }

                int o = 0;
                if (decompOptions.decompTablesFormat.showErrors) o = 2;

                int j = -1;
                foreach (GekkoTime t in new GekkoTimeIterator(tStart, tEnd))
                {
                    j++;
                    if (j == 0)
                    {
                        List<DecompHelper> dhList2 = decompHelpers["FIRST," + t.ToString()];
                        int i = -1;
                        foreach (DecompHelper dh in dhList2)
                        {
                            i++;
                            table.Set(i + 3 + o, 1, G.FormatVariableAndLag(dh.variableWithLag)); //What should format be?
                        }
                        if (decompOptions.expressionOld != null)
                        {
                            table.Set(2, 1, Globals.decompText0);
                        }
                        else
                        {
                            table.Set(2, 1, G.PrettifyTimeseriesHash(leftSideVariable, true, false));
                        }

                    }
                    table.SetDate(1, j + 2, t.ToString());

                    List<DecompHelper> data = null; decompHelpers.TryGetValue("FIRST," + t.ToString(), out data);
                    List<DecompHelper> data_lag = null; decompHelpers.TryGetValue("FIRST," + t.Add(-1).ToString(), out data_lag);
                    List<DecompHelper> data_lag2 = null; decompHelpers.TryGetValue("FIRST," + t.Add(-2).ToString(), out data_lag2);
                    List<DecompHelper> data_base = null; decompHelpers.TryGetValue("REF," + t.ToString(), out data_base);
                    List<DecompHelper> data_base_lag = null; decompHelpers.TryGetValue("REF," + t.Add(-1).ToString(), out data_base_lag);
                    List<DecompHelper> data_base_lag2 = null; decompHelpers.TryGetValue("REF," + t.Add(-2).ToString(), out data_base_lag2);

                    int offset_i = 2;
                    int offset_j = 2;

                    int decimals = 0;
                    if (decompOptions.decompTablesFormat.isPercentageType) decimals = decompOptions.decompTablesFormat.decimalsPch;
                    else decimals = decompOptions.decompTablesFormat.decimalsLevel;

                    string format = "f16." + decimals.ToString();

                    if (isRaw)
                    {
                        double line0 = double.NaN;
                        double line1 = double.NaN;
                        double line2 = double.NaN;
                        switch (transformationCodeAugmented)
                        {
                            case "xmn":
                                break;
                            case "xm":
                                {
                                    line0 = data[0].z - data_base[0].z;
                                    table.SetNumber(0 + offset_i, j + offset_j, line0, format);  //What should format be?
                                    if (decompOptions.decompTablesFormat.showErrors)
                                    {
                                        line2 = data[0].y0 - data_base[0].y0;
                                    }
                                    for (int i = 0; i < data.Count; i++)
                                    {
                                        table.SetNumber(i + offset_i + 1 + o, j + offset_j, data[i].x0 - data_base[i].x0, format);  //What should format be?
                                    }
                                }
                                break;
                            case "xq":
                                {
                                    line0 = (data[0].z / data_base[0].z - 1d) * 100d;
                                    table.SetNumber(0 + offset_i, j + offset_j, line0, format);  //What should format be?
                                    if (decompOptions.decompTablesFormat.showErrors)
                                    {
                                        line2 = (data[0].y0 / data_base[0].y0 - 1d) * 100d;
                                    }
                                    for (int i = 0; i < data.Count; i++)
                                    {
                                        table.SetNumber(i + offset_i + 1 + o, j + offset_j, (data[i].x0 / data_base[i].x0 - 1d) * 100d, format);  //What should format be?
                                    }
                                }
                                break;
                            case "xsm":
                                G.Writeln2("*** ERROR: DECOMP option <" + transformationCodeAugmented + "> does not make (much) sense: did you mean <ms>?");
                                break;
                            // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                            case "":
                            case "xn":
                                {
                                    line0 = data[0].z;
                                    table.SetNumber(0 + offset_i, j + offset_j, line0, format);  //What should format be?
                                    if (decompOptions.decompTablesFormat.showErrors)
                                    {
                                        line2 = data[0].y0;
                                    }
                                    for (int i = 0; i < data.Count; i++)
                                    {
                                        table.SetNumber(i + offset_i + 1 + o, j + offset_j, data[i].x0, format);  //What should format be?
                                    }
                                }
                                break;
                            case "xb":
                            case "xbn":
                                {
                                    line0 = data_base[0].z;
                                    table.SetNumber(0 + offset_i, j + offset_j, line0, format);  //What should format be?
                                    if (decompOptions.decompTablesFormat.showErrors)
                                    {
                                        line2 = data_base[0].y0;
                                    }
                                    for (int i = 0; i < data.Count; i++)
                                    {
                                        table.SetNumber(i + offset_i + 1 + o, j + offset_j, data_base[i].x0, format);  //What should format be?
                                    }
                                }
                                break;
                            case "xd":
                                {
                                    line0 = data[0].z - data_lag[0].z;
                                    table.SetNumber(0 + offset_i, j + offset_j, line0, format);  //What should format be?
                                    if (decompOptions.decompTablesFormat.showErrors)
                                    {
                                        line2 = data[0].y0 - data_lag[0].y0;
                                    }
                                    for (int i = 0; i < data.Count; i++)
                                    {
                                        table.SetNumber(i + offset_i + 1 + o, j + offset_j, data[i].x0 - data_lag[i].x0, format);  //What should format be?
                                    }
                                }
                                break;
                            case "xbd":
                                {
                                    line0 = data_base[0].z - data_base_lag[0].z;
                                    table.SetNumber(0 + offset_i, j + offset_j, line0, format);  //What should format be?
                                    if (decompOptions.decompTablesFormat.showErrors)
                                    {
                                        line2 = data_base[0].y0 - data_base_lag[0].y0;
                                    }
                                    for (int i = 0; i < data.Count; i++)
                                    {
                                        table.SetNumber(i + offset_i + 1 + o, j + offset_j, data_base[i].x0 - data_base_lag[i].x0, format);  //What should format be?
                                    }
                                }
                                break;
                            case "xp":
                                {
                                    line0 = (data[0].z / data_lag[0].z - 1d) * 100d;
                                    table.SetNumber(0 + offset_i, j + offset_j, line0, format);  //What should format be?
                                    if (decompOptions.decompTablesFormat.showErrors)
                                    {
                                        line2 = (data[0].y0 / data_lag[0].y0 - 1d) * 100d;
                                    }
                                    for (int i = 0; i < data.Count; i++)
                                    {
                                        table.SetNumber(i + offset_i + 1 + o, j + offset_j, (data[i].x0 / data_lag[i].x0 - 1d) * 100d, format);  //What should format be?
                                    }
                                }
                                break;
                            case "xbp":
                                {
                                    line0 = (data_base[0].z / data_base_lag[0].z - 1d) * 100d;
                                    table.SetNumber(0 + offset_i, j + offset_j, line0, format);  //What should format be?
                                    if (decompOptions.decompTablesFormat.showErrors)
                                    {
                                        line2 = (data_base[0].y0 / data_base_lag[0].y0 - 1d) * 100d;
                                    }
                                    for (int i = 0; i < data.Count; i++)
                                    {
                                        table.SetNumber(i + offset_i + 1 + o, j + offset_j, (data_base[i].x0 / data_base_lag[i].x0 - 1d) * 100d, format);  //What should format be?
                                    }
                                }
                                break;
                            case "xdp":
                                {
                                    line0 = (data[0].z / data_lag[0].z - 1d) * 100d - (data_lag[0].z / data_lag2[0].z - 1d) * 100d;
                                    table.SetNumber(0 + offset_i, j + offset_j, line0, format);  //What should format be?
                                    if (decompOptions.decompTablesFormat.showErrors)
                                    {
                                        line2 = (data[0].y0 / data_lag[0].y0 - 1d) * 100d - (data_lag[0].y0 / data_lag2[0].y0 - 1d) * 100d;
                                    }
                                    for (int i = 0; i < data.Count; i++)
                                    {
                                        table.SetNumber(i + offset_i + 1 + o, j + offset_j, (data[i].x0 / data_lag[i].x0 - 1d) * 100d - (data_lag[i].x0 / data_lag2[i].x0 - 1d) * 100d, format);  //What should format be?
                                    }
                                }
                                break;
                            case "xbdp":
                                {
                                    line0 = (data_base[0].z / data_base_lag[0].z - 1d) * 100d - (data_base_lag[0].z / data_base_lag2[0].z - 1d) * 100d;
                                    table.SetNumber(0 + offset_i, j + offset_j, line0, format);  //What should format be?
                                    if (decompOptions.decompTablesFormat.showErrors)
                                    {
                                        line2 = (data_base[0].y0 / data_base_lag[0].y0 - 1d) * 100d - (data_base_lag[0].y0 / data_base_lag2[0].y0 - 1d) * 100d;
                                    }
                                    for (int i = 0; i < data.Count; i++)
                                    {
                                        table.SetNumber(i + offset_i + 1 + o, j + offset_j, (data_base[i].x0 / data_base_lag[i].x0 - 1d) * 100d - (data_base_lag[i].x0 / data_base_lag2[i].x0 - 1d) * 100d, format);  //What should format be?
                                    }
                                }
                                break;
                            case "xmp":
                                {
                                    line0 = (data[0].z / data_lag[0].z - 1d) * 100d - (data_base[0].z / data_base_lag[0].z - 1d) * 100d;
                                    table.SetNumber(0 + offset_i, j + offset_j, line0, format);  //What should format be?
                                    if (decompOptions.decompTablesFormat.showErrors)
                                    {
                                        line2 = (data[0].y0 / data_lag[0].y0 - 1d) * 100d - (data_base[0].y0 / data_base_lag[0].y0 - 1d) * 100d;
                                    }
                                    for (int i = 0; i < data.Count; i++)
                                    {
                                        table.SetNumber(i + offset_i + 1 + o, j + offset_j, (data[i].x0 / data_lag[i].x0 - 1d) * 100d - (data_base[i].x0 / data_base_lag[i].x0 - 1d) * 100d, format);  //What should format be?
                                    }
                                }
                                break;
                            case "xsd":
                                G.Writeln2("*** ERROR: DECOMP option <" + transformationCodeAugmented + "> does not make (much) sense: did you mean <s>?");
                                break;


                                //======================================================================================

                        }  //end of switch

                        if (decompOptions.decompTablesFormat.showErrors)
                        {
                            line1 = line0 - line2;
                            table.SetNumber(2 + offset_i, j + offset_j, line1, format);
                            table.SetNumber(1 + offset_i, j + offset_j, line2, format);
                            table.Get(1 + offset_i, j + offset_j).backgroundColor = "LightYellow";
                            table.Get(2 + offset_i, j + offset_j).backgroundColor = "LightRed";
                        }

                    }  //if raw type (starts with x)
                    else
                    {
                        string code1 = "";
                        string code2 = transformationCodeAugmented;
                        if (transformationCodeAugmented.ToLower().StartsWith("s"))
                        {
                            code1 = "s";
                            code2 = transformationCodeAugmented.Substring(1);
                        }

                        double[] tableTemp = new double[data.Count + 1 + o];
                        double sum = double.NaN;
                        double truth = double.NaN;
                        double dataError = double.NaN;
                        double nonlinError = double.NaN;

                        if (true)
                        {
                            List<DecompHelper> data_CUR = null;
                            List<DecompHelper> data_ALT = null;
                            List<DecompHelper> dataLag_CUR = null;
                            List<DecompHelper> dataLag_ALT = null;
                            if (G.Equal(code2, "d") || G.Equal(code2, "p"))
                            {
                                data_CUR = data;
                                data_ALT = data_lag;
                            }
                            else if (G.Equal(code2, "bd") || G.Equal(code2, "bp"))
                            {
                                data_CUR = data_base;
                                data_ALT = data_base_lag;
                            }
                            else if (G.Equal(code2, "m") || G.Equal(code2, "q"))
                            {
                                data_CUR = data;
                                data_ALT = data_base;
                            }
                            else if (G.Equal(code2, "dp"))
                            {
                                data_CUR = data;
                                data_ALT = data_lag;
                                dataLag_CUR = data_lag;
                                dataLag_ALT = data_lag2;
                            }
                            else if (G.Equal(code2, "bdp"))
                            {
                                data_CUR = data_base;
                                data_ALT = data_base_lag;
                                dataLag_CUR = data_base_lag;
                                dataLag_ALT = data_base_lag2;
                            }
                            else if (G.Equal(code2, "mp"))
                            {
                                data_CUR = data;
                                data_ALT = data_lag;
                                dataLag_CUR = data_base;
                                dataLag_ALT = data_base_lag;
                            }
                            else
                            {
                                G.Writeln2("*** ERROR: Internal error regarding decomposition");
                                throw new GekkoException();
                            }
                            bool isRelative = false; //will be divided with lagged or baseline level
                            if (G.Equal(code2, "p") || G.Equal(code2, "bp") || G.Equal(code2, "dp") || G.Equal(code2, "bdp") || G.Equal(code2, "q") || G.Equal(code2, "mp"))
                            {
                                isRelative = true;
                            }
                            if (G.Equal(code2, "dp") || G.Equal(code2, "bdp") || G.Equal(code2, "mp"))
                            {
                                double sumNolag = double.NaN;
                                double sumLag = double.NaN;
                                double truthNolag = double.NaN;
                                double truthLag = double.NaN;
                                double dataErrorNolag = double.NaN;
                                double dataErrorLag = double.NaN;
                                double nonlinErrorNolag = double.NaN;
                                double nonlinErrorLag = double.NaN;
                                double[] tableTempNolag = new double[data.Count + 1 + o];
                                double[] tableTempLag = new double[data.Count + 1 + o];
                                DecompHelper3(ref sumNolag, ref truthNolag, ref dataErrorNolag, ref nonlinErrorNolag, o, tableTempNolag, data_CUR, data_ALT, isRelative);
                                DecompHelper3(ref sumLag, ref truthLag, ref dataErrorLag, ref nonlinErrorLag, o, tableTempLag, dataLag_CUR, dataLag_ALT, isRelative);
                                sum = sumNolag - sumLag;
                                truth = truthNolag - truthLag;
                                dataError = dataErrorNolag - dataErrorLag;
                                nonlinError = nonlinErrorNolag - nonlinErrorLag;
                                for (int i = 0; i < tableTemp.Length; i++)
                                {
                                    tableTemp[i] = tableTempNolag[i] - tableTempLag[i];
                                }
                            }
                            else
                            {
                                DecompHelper3(ref sum, ref truth, ref dataError, ref nonlinError, o, tableTemp, data_CUR, data_ALT, isRelative);
                            }
                        }

                        tableTemp[0] = truth;

                        if (decompOptions.decompTablesFormat.showErrors)
                        {
                            tableTemp[1] = nonlinError;
                            tableTemp[2] = dataError;
                        }
                        else
                        {
                            for (int i = 1; i < data.Count + 1; i++)
                            {
                                tableTemp[i] *= truth / sum;
                            }
                        }

                        if (G.Equal(code1, "s"))
                        {
                            double tableTemp0 = tableTemp[0];
                            for (int i = 0; i < data.Count + 1 + o; i++)
                            {
                                tableTemp[i] = tableTemp[i] / tableTemp0 * 100d;
                            }
                        }

                        for (int i = 0; i < data.Count + 1 + o; i++)
                        {
                            table.SetNumber(i + offset_i, j + offset_j, tableTemp[i], format);  //What should format be?
                        }

                        if (decompOptions.decompTablesFormat.showErrors)
                        {
                            table.Get(1 + offset_i, j + offset_j).backgroundColor = "LightRed";
                            table.Get(2 + offset_i, j + offset_j).backgroundColor = "LightRed";
                        }
                    }
                }
            }
            return table;
        }

        private static void DecompHelper3(ref double sum, ref double truth, ref double dataError, ref double nonlinError, int o, double[] tableTemp, List<DecompHelper> data, List<DecompHelper> data_ALT, bool isRelative)
        {
            sum = 0d;
            for (int i = 0; i < data.Count; i++)
            {
                double val = data_ALT[i].slope * (data[i].x0 - data_ALT[i].x0);
                sum += val;
                tableTemp[i + 1 + o] = val;
            }
            double y = data[0].y0;  //y0 is the same in all of the items, so item 0 is chosen arbitrarily
            double z = data[0].z;
            double y_ALT = data_ALT[0].y0;
            double z_ALT = data_ALT[0].z;
            truth = z - z_ALT;
            dataError = (z - z_ALT) - (y - y_ALT);
            nonlinError = (y - y_ALT) - sum;
            if (isRelative)
            {
                double factor = 100d / data_ALT[0].z;
                for (int i = 0; i < data.Count; i++)
                {
                    tableTemp[i + 1 + o] *= factor;
                }
                truth *= factor;
                dataError *= factor;
                nonlinError *= factor;
                sum *= factor;
            }
        }

        private static List<string> GetAllVariablesForDecompose(string leftSideVariable, List<string> p2)
        {
            List<string> allVariables = new List<string>();

            Dictionary<string, string> rightSideVariables = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
            foreach (string variableWithLag in p2)
            {
                if (variableWithLag.Contains(Globals.lagIndicator + Globals.lagIndicator))
                {
                    string[] split = variableWithLag.Split(new string[] { Globals.lagIndicator + Globals.lagIndicator }, StringSplitOptions.None);
                    if (split.Length != 2)
                    {
                        G.Writeln2("*** ERROR: internal error related to fixed periods");
                        throw new GekkoException();
                    }
                    //rightSideVariables.Add(split[0], "");
                    G.Writeln2("*** ERROR: fixed periods (" + split[0] + Globals.leftParenthesisIndicator + split[1] + Globals.rightParenthesisIndicator + ") cannot be used when decomposing");
                    throw new GekkoException();
                }
                else
                {
                    string variable = null;
                    int lag = -12345;
                    G.ExtractVariableAndLag(variableWithLag, out variable, out lag);
                    if (!rightSideVariables.ContainsKey(variable))
                    {
                        rightSideVariables.Add(variable, "");
                    }
                }
            }
            allVariables.AddRange(rightSideVariables.Keys);
            if (!rightSideVariables.ContainsKey(leftSideVariable))
            {
                allVariables.Add(leftSideVariable);
            }
            return allVariables;
        }

        private static void CreateDecompDll(string varName, bool isExpression, EquationHelper eh, out CompilerResults cr)
        {
            string code = "";
            if (isExpression)
            {
                code = varName;
            }
            else
            {
                code = eh.csCodeRhsLongVersion;
            }

            StringBuilder s2 = new StringBuilder();
            s2.AppendLine("using System;");
            s2.AppendLine("using System.Collections.Generic;");
            s2.AppendLine("using System.Text;");
            s2.AppendLine("namespace Gekko");
            s2.AppendLine("{");
            s2.AppendLine("    public class TranslatedCode");
            s2.AppendLine("    {");
            s2.AppendLine("public static void DecompEquation(double[] result, GekkoTime t, Databank databank)");
            s2.AppendLine("{");
            s2.Append("double data = ");
            s2.AppendLine(code + ";");
            s2.AppendLine("result[0] = data;");
            s2.AppendLine("return;");
            s2.AppendLine("}");  //method DecompEquation()
            s2.AppendLine("}");  //class TranslatedCode
            s2.AppendLine("}");  //namespace Gekko
            s2.Replace("`", Globals.QT);
            CompilerParameters compilerParams = new CompilerParameters();
            compilerParams = new CompilerParameters();
            compilerParams.CompilerOptions = Program.GetCompilerOptions();
            compilerParams.GenerateInMemory = true;
            compilerParams.IncludeDebugInformation = false;
            compilerParams.ReferencedAssemblies.Add("system.dll");
            compilerParams.ReferencedAssemblies.Add(Application.ExecutablePath);
            compilerParams.GenerateExecutable = false;
            cr = Globals.iCodeCompiler.CompileAssemblyFromSource(compilerParams, s2.ToString());
            if (cr.Errors.HasErrors)
            {
                throw new GekkoException();
            }
        }

        public static void CreatePredictActions(string code)
        {
            StringBuilder s2 = new StringBuilder();
            s2.AppendLine("using System;");
            s2.AppendLine("using System.Collections.Generic;");
            s2.AppendLine("using System.Text;");
            s2.AppendLine("namespace Gekko");
            s2.AppendLine("{");
            s2.AppendLine("    public class TranslatedCode");
            s2.AppendLine("    {");
            s2.AppendLine("public static void PredictActions()");
            s2.AppendLine("{");
            s2.AppendLine(code + ";");
            s2.AppendLine("}");  //method Predict()
            s2.AppendLine("}");  //class TranslatedCode
            s2.AppendLine("}");  //namespace Gekko
            s2.Replace("`", Globals.QT);
            CompilerParameters compilerParams = new CompilerParameters();
            compilerParams = new CompilerParameters();
            compilerParams.CompilerOptions = Program.GetCompilerOptions();
            compilerParams.GenerateInMemory = true;
            compilerParams.IncludeDebugInformation = false;
            compilerParams.ReferencedAssemblies.Add("system.dll");
            Gekko.Parser.Frm.ParserFrmCompileAST.ReferencedAssembliesGekko(compilerParams);
            compilerParams.GenerateExecutable = false;
            string code2 = s2.ToString();
            CompilerResults cr = Globals.iCodeCompiler.CompileAssemblyFromSource(compilerParams, code2);
            if (cr.Errors.HasErrors)
            {
                throw new GekkoException();
            }

            Object[] args = new Object[0];
            cr.CompiledAssembly.GetType("Gekko.TranslatedCode").InvokeMember("PredictActions", BindingFlags.InvokeMethod, null, null, args);            
        }


        private static void CreatePrtSnippetDll(out CompilerResults cr, string s, string s3)
        {
            StringBuilder s2 = new StringBuilder();
            s2.AppendLine("using System;");
            s2.AppendLine("using System.Collections.Generic;");
            s2.AppendLine("using System.Text;");
            s2.AppendLine("namespace Gekko");
            s2.AppendLine("{");
            s2.AppendLine("    public class PrtSnippet");
            s2.AppendLine("    {");
            s2.AppendLine(s3);
            s2.AppendLine("public static O.Prt Snippet()");
            s2.AppendLine("{");
            s2.AppendLine(Globals.gekkoSmplInit);
            s2.AppendLine(s);
            s2.AppendLine("}");  //method
            s2.AppendLine("}");  //class
            s2.AppendLine("}");  //namespace
            s2.Replace("`", Globals.QT);
            CompilerParameters compilerParams = new CompilerParameters();
            compilerParams = new CompilerParameters();
            compilerParams.CompilerOptions = Program.GetCompilerOptions();
            compilerParams.GenerateInMemory = false;
            compilerParams.IncludeDebugInformation = false;
            compilerParams.ReferencedAssemblies.Add("system.dll");
            compilerParams.ReferencedAssemblies.Add(Application.ExecutablePath);
            compilerParams.GenerateExecutable = false;
            cr = Globals.iCodeCompiler.CompileAssemblyFromSource(compilerParams, s2.ToString());
            if (cr.Errors.HasErrors)
            {
                throw new GekkoException();
            }
        }

        public static List<int> GetLeftsideBNumbers()
        {
            //Gets equation numbers in simultaneous gauss-seidel block
            //Note that this method takes a little time: do not put inside loop!
            List<int> allSimul = new List<int>();
            allSimul.AddRange(Program.model.modelGekko.m2.simulRecursive);
            allSimul.AddRange(Program.model.modelGekko.m2.simulFeedback);
            allSimul.Sort();
            return allSimul;
        }

        private static void CreateTestSimDll(out CompilerResults cr, List<string> list, int start, int end)
        {
            //This is a method only used for debugging purposes
            StringBuilder s2 = new StringBuilder();
            s2.AppendLine("using System;");
            s2.AppendLine("using System.Collections.Generic;");
            s2.AppendLine("using System.Text;");
            s2.AppendLine("namespace Gekko");
            s2.AppendLine("{");
            s2.AppendLine("    public class TranslatedCode");
            s2.AppendLine("    {");
            s2.AppendLine("public static void TestSim(List<string>res)");
            s2.AppendLine("{");
            s2.AppendLine("GekkoTime tStart, tEnd; tStart = Globals.globalPeriodStart; tEnd = Globals.globalPeriodEnd;");
            s2.AppendLine("foreach (GekkoTime t in new GekkoTimeIterator( tStart, tEnd)) {");
            s2.AppendLine("double hs;");
            s2.AppendLine("double vs;");
            s2.AppendLine("double difMax = 0d;");
            s2.AppendLine("double pchMax = 0d;");
            s2.AppendLine("double dif;");
            s2.AppendLine("double pch;");
            s2.AppendLine("string difMaxName = ``;");
            s2.AppendLine("string pchMaxName = ``;");
            s2.AppendLine("double difMaxVs = 0d;");
            s2.AppendLine("double pchMaxVs = 0d;");
            s2.AppendLine("double difMaxHs = 0d;");
            s2.AppendLine("double pchMaxHs = 0d;");
            s2.AppendLine("Databank databank = Program.databanks.GetDatabank(`Work`);");

            int count = -1;

            foreach (string s in list)
            {
                count++;
                if (count < start) continue;
                if (count > end) break;
                int eqNumber = (int)Program.model.modelGekko.fromVariableToEquationNumber[s + Globals.lagIndicator + "0"];
                EquationHelper eh = Program.model.modelGekko.equations[eqNumber];
                string code = eh.csCodeRhsLongVersion;
                s2.Append("hs = ");
                s2.AppendLine(code + ";");
                s2.AppendLine("vs = databank.GetVariable(`" + s + "`).GetDataNonLight(t);");
                s2.AppendLine("dif = Math.Abs(hs - vs);");
                s2.AppendLine("pch = Math.Abs((hs / vs - 1) * 100);");
                s2.AppendLine("if (dif > difMax) {difMaxVs=vs; difMaxHs=hs; difMax = dif; difMaxName = `" + s + "`; }");
                s2.AppendLine("if (pch > pchMax) {pchMaxVs=vs; pchMaxHs=hs; pchMax = pch; pchMaxName = `" + s + "`; }");
                //s2.AppendLine("G.Writeln(`XXXXXX: ` + t.ToString() + `: ` + dif + ` ` + pch);");
                s2.AppendLine();
            }
            s2.AppendLine("G.Writeln(`Abs: ` + t.ToString() + `: ` + difMaxName + ` = ` + difMax);");

            s2.AppendLine("res.Add(`abs¤` + t.ToString() + `¤` + difMaxName + `¤` + difMax + `¤` + difMaxVs + `¤` + difMaxHs);");

            s2.AppendLine("G.Writeln(`Rel: ` + t.ToString() + `: ` + pchMaxName + ` = ` + pchMax);");

            s2.AppendLine("res.Add(`rel¤` + t.ToString() + `¤` + pchMaxName + `¤` + pchMax + `¤` + pchMaxVs + `¤` + pchMaxHs);");

            s2.AppendLine("}");  //end time loop
            s2.AppendLine("}");  //method DecompEquation()
            s2.AppendLine("}");  //class TranslatedCode
            s2.AppendLine("}");  //namespace Gekko
            s2.Replace("`", Globals.QT);
            CompilerParameters compilerParams = new CompilerParameters();
            compilerParams = new CompilerParameters();
            compilerParams.CompilerOptions = Program.GetCompilerOptions();
            compilerParams.GenerateInMemory = false;
            compilerParams.IncludeDebugInformation = false;
            compilerParams.ReferencedAssemblies.Add("system.dll");
            compilerParams.ReferencedAssemblies.Add(Application.ExecutablePath);
            compilerParams.GenerateExecutable = false;
            cr = Globals.iCodeCompiler.CompileAssemblyFromSource(compilerParams, s2.ToString());
            if (cr.Errors.HasErrors)
            {
                throw new GekkoException();
            }
        }

        private static double RunDecompEquation(CompilerResults cr, GekkoTime t, Databank db)
        {
            Object[] args2 = new Object[3];
            args2[0] = new double[1];
            args2[1] = t;
            args2[2] = db;
            cr.CompiledAssembly.GetType("Gekko.TranslatedCode").InvokeMember("DecompEquation", BindingFlags.InvokeMethod, null, null, args2);
            double val0 = ((double[])(args2[0]))[0];
            return val0;
        }

        public static List<string> HandleModelFiles(List<string> input, ModelCommentsHelper modelCommentsHelper)
        {
            List<string> output = new List<string>();
            List<string> outputVarlist = new List<string>();
            List<string> outputRunBefore = new List<string>();
            List<string> outputRunAfter = new List<string>();

            bool outputVarlistFlag = false;
            bool outputRunBeforeFlag = false;
            bool outputRunAfterFlag = false;
            foreach (string line in input)
            {
                string line2 = line.Trim();
                if (line2.ToLower().StartsWith("varlist$") || line2.ToLower().StartsWith("varlist;"))
                {
                    outputVarlistFlag = true;
                    outputRunBeforeFlag = false;
                    outputRunAfterFlag = false;                    
                }
                else if (line2.ToLower().StartsWith("runbefore$") || line2.ToLower().StartsWith("runbefore;"))
                {
                    outputVarlistFlag = false;
                    outputRunBeforeFlag = true;
                    outputRunAfterFlag = false;
                }
                else if (line2.ToLower().StartsWith("runafter$") || line2.ToLower().StartsWith("runafter;"))
                {
                    outputVarlistFlag = false;
                    outputRunBeforeFlag = false;
                    outputRunAfterFlag = true;
                }
                if (outputVarlistFlag) outputVarlist.Add(line);
                else if (outputRunBeforeFlag) outputRunBefore.Add(line);
                else if (outputRunAfterFlag) outputRunAfter.Add(line);
                else output.Add(line);
            }

            StringBuilder temp1 = new StringBuilder();
            foreach (string line in outputVarlist) temp1.AppendLine(line);            
            modelCommentsHelper.cutout_varlist = temp1.ToString();

            StringBuilder temp2 = new StringBuilder();
            foreach (string line in outputRunBefore) temp2.AppendLine(line);
            modelCommentsHelper.cutout_runbefore = temp2.ToString();

            StringBuilder temp3 = new StringBuilder();
            foreach (string line in outputRunAfter) temp3.AppendLine(line);
            modelCommentsHelper.cutout_runafter = temp3.ToString();

            return output;
        }

        public static string HandleModelFiles(string input, ModelCommentsHelper modelCommentsHelper)
        {
            //As a side-effect, Program.model.modelGekko.varlist is filled with stuff after VARLIST$
            List<string> lines = G.ExtractLinesFromText(input);
            List<string> linesNew = HandleModelFiles(lines, modelCommentsHelper);  //after this, there is no varlist stuff in linesNew
            GetModelHashAndXml(linesNew, modelCommentsHelper); //does some rough removing of comments, empty lines etc.
            Globals.modelFileLines = linesNew;
            StringBuilder sb = new StringBuilder();
            foreach (string line in linesNew)
            {
                sb.AppendLine(line);
            }
            string s2 = sb.ToString();
            return s2;
        }


        private static void GetModelHashAndXml(List<string> linesNew, ModelCommentsHelper modelCommentsHelper)
        {
            StringBuilder sb = new StringBuilder();
            StringBuilder comment = new StringBuilder();
            bool problem = false;
            for (int i = 0; i < 2; i++)
            {
                sb = new StringBuilder();
                comment = new StringBuilder();
                int nestedCommentCounter = 0;
                foreach (string s in linesNew)
                {
                    string s2 = s.Trim();
                    if (i == 0)
                    {
                        //TODO: handle ### model blocks together with comment blocks
                        if (s2.StartsWith("/*")) nestedCommentCounter++;
                        if (s2.EndsWith("*/")) nestedCommentCounter--;
                        if (nestedCommentCounter > 1 || nestedCommentCounter < 0)  //should be 0 or 1, nothing else, so nested comments will -> problem
                        {
                            problem = true;
                            break;
                        }
                        if (nestedCommentCounter == 1)
                        {
                            ExtractComment(comment, s2, modelCommentsHelper);
                            continue;  //inside comment
                        }
                    }
                    if (s2.StartsWith("()") || s2.StartsWith("//"))
                    {
                        ExtractComment(comment, s2, modelCommentsHelper);
                        if (!s2.Contains("###"))
                        {
                            continue;  //we ignore a normal comment. But if the comment contains '###'
                                       //it will be hashed. So model block lines count in hash code!
                        }
                    }
                    if (s2 == "") continue;
                    sb.AppendLine(s2);  //used for hash code
                }
                if (problem == false) break;
            }

            if (modelCommentsHelper.infoText == null && modelCommentsHelper.infoCounter > 0)
            {
                G.Writeln("+++ NOTE: The correct syntax for info is 'Info: ' (followed by text)");
                G.Writeln("          Note capital 'I' and the blank after ':'");
            }
            if (modelCommentsHelper.dateText == null && modelCommentsHelper.dateCounter > 0)
            {
                G.Writeln("+++ NOTE: The correct syntax for date is 'Date: ' (followed by date)");
                G.Writeln("          Note capital 'D' and the blank after ':'");
            }
            if (modelCommentsHelper.signatureFoundInFileHeader == null && modelCommentsHelper.signatureCounter > 0)
            {
                G.Writeln("+++ NOTE: The correct syntax for signature is 'Signature: ' (followed by the signature)");
                G.Writeln("          Note capital 'S' and the blank after ':'");
            }

            //The statement below makes sure that -- if a cached model is to be used -- the MODEL statement that created the cached model and the current MODEL statement are done under the same frequency
            sb.AppendLine("SubPeriods: " + O.CurrentSubperiods().ToString());  //for instance: "Frequency: 4". Cf. Program.model.modelGekko.subPeriods

            string trueHash = Program.GetMD5Hash(sb.ToString());  //Pretty unlikely that two different .frm files could produce the same hash.
            trueHash = trueHash.Trim();  //probably not necessary
            G.WritelnGray("HASH: " + trueHash);

            Program.model.modelGekko.modelInfo.info = "[empty]";
            if (modelCommentsHelper.infoText != null) Program.model.modelGekko.modelInfo.info = modelCommentsHelper.infoText;

            Program.model.modelGekko.modelInfo.date = "[empty]";
            if (modelCommentsHelper.dateText != null) Program.model.modelGekko.modelInfo.date = modelCommentsHelper.dateText;

            if (modelCommentsHelper.signatureFoundInFileHeader == null)
            {
                modelCommentsHelper.signatureStatus = ESignatureStatus.SignatureNotFoundInModelFile;
            }
            else
            {
                if (modelCommentsHelper.signatureFoundInFileHeader == trueHash)
                {
                    modelCommentsHelper.signatureStatus = ESignatureStatus.Ok;
                }
                else
                {
                    modelCommentsHelper.signatureStatus = ESignatureStatus.SignaturesDoNotMatch;
                }
            }

            modelCommentsHelper.modelHashTrue = trueHash;

            return;
        }

        private static string IdentifyModelBlock(string s2)
        {
            string s3 = s2;
            if (s2.Contains("###"))
            {
                string[] xx = s2.Split(new string[] { "###" }, StringSplitOptions.None);
                if (xx.Length > 1)
                {
                    s3 = "MODELBLOCK " + xx[1].Trim();
                }
            }
            return s3;
        }

        private static void ExtractComment(StringBuilder sb, string s2, ModelCommentsHelper modelCommentsHelper)
        {
            string s3 = s2.Trim();
            if (s3.StartsWith("/*")) s3 = s3.Substring(2);
            else if (s3.StartsWith("*/")) s3 = s3.Substring(2);
            else if (s3.StartsWith("//")) s3 = s3.Substring(2);
            else if (s3.StartsWith("()")) s3 = s3.Substring(2);
            s3 = s3.Trim();
            //-------------
            if (s3.StartsWith("Info: "))
            {
                if (modelCommentsHelper.infoText != null)
                {
                    G.Writeln2("*** ERROR: Model file contains several comment lines starting with 'Info: '");
                    throw new GekkoException();
                }
                modelCommentsHelper.infoText = s3.Substring(6).Trim();
            }
            if (s3.ToLower().StartsWith("info:") || s3.ToLower().StartsWith("info :")) modelCommentsHelper.infoCounter++;
            //-------------
            if (s3.StartsWith("Date: "))
            {
                if (modelCommentsHelper.dateText != null)
                {
                    G.Writeln2("*** ERROR: Model file contains several comment lines starting with 'Date: '");
                    throw new GekkoException();
                }
                modelCommentsHelper.dateText = s3.Substring(6).Trim();
            }
            if (s3.ToLower().StartsWith("date:") || s3.ToLower().StartsWith("date :")) modelCommentsHelper.dateCounter++;
            //-------------
            if (s3.StartsWith("Signature: "))
            {
                if (modelCommentsHelper.signatureFoundInFileHeader != null)
                {
                    G.Writeln2("*** ERROR: Model file contains several comment lines starting with 'Signature: '");
                    throw new GekkoException();
                }
                modelCommentsHelper.signatureFoundInFileHeader = s3.Substring(11).Trim();
            }
            if (s3.ToLower().StartsWith("signature:") || s3.ToLower().StartsWith("signature :")) modelCommentsHelper.signatureCounter++;
            //-------------
            sb.AppendLine(s3);
        }

        public static string HandleObeyFiles2(string input)
        {
            List<string> lines = G.ExtractLinesFromText(input);

            List<string> linesNew = null;
            linesNew = HandleObeyFilesNew(lines);

            Globals.cmdFileLines = linesNew;  //used if there is a lexer error
            StringBuilder sb = new StringBuilder();
            foreach (string line in linesNew)
            {
                sb.AppendLine(line);
            }
            string s2 = sb.ToString();
            return s2;
        }

        public static double Percentile(double[] sequence, double excelPercentile)
        {
            //handles NaN values, return Excel-style Percentile
            //for sequence 1,2,3,4,5 these correspond to 0%, 25%, 50%, 75%, 100% and interpolates between them.
            //that seems reasonable. Uses N-1 = 4 to multiply the %, seems this corresponds to the gaps between numbers (commas).
            //again this seems reasonable if 1 and 5 are min and max.

            if (excelPercentile < 0 || excelPercentile > 1d)
            {
                G.Writeln2("*** ERROR: The percentile parameter should be between 0 and 1");
                throw new GekkoException();
            }

            Array.Sort(sequence);
            if (double.IsNaN(sequence[0]))
            {
                int x = 0;
                for (int i = 0; i < sequence.Length; i++)
                {
                    if (!double.IsNaN(sequence[i]))
                    {
                        break;
                    }
                    x = i;
                }
                double[] seq2 = new double[sequence.Length - (x + 1)];
                for (int i = x + 1; i < sequence.Length; i++)
                {
                    double y = sequence[i];
                    if (double.IsNaN(y))
                    {
                        G.Writeln2("*** ERROR: #9807435237");  //should not happen in .NET 4.0 or higher
                        throw new GekkoException();
                    }
                    seq2[i - (x + 1)] = y;
                }
                sequence = seq2;
            }
            int N = sequence.Length;
            double n = (N - 1) * excelPercentile + 1;
            // Another method: double n = (N + 1) * excelPercentile;
            if (n == 1d) return sequence[0];
            else if (n == N) return sequence[N - 1];
            else
            {
                int k = (int)n;
                double d = n - k;
                return sequence[k - 1] + d * (sequence[k] - sequence[k - 1]);
            }
        }
        

        public static TwoInts f(int x) { return new TwoInts(); }

        

        public static string HandleOneLiners(string text)
        {
            if (Globals.runningOnTTComputer)
            {
                string s2 = text.Trim();
                if (s2.EndsWith(";")) s2 = s2.Substring(0, s2.Length - 1);
                s2 = s2.Trim();

                if (s2.StartsWith("I(\""))
                {
                    int i = s2.IndexOf("\")");
                    text = s2.Substring(3, i - 3);
                }

                if (s2.StartsWith("bvar"))
                {
                    string[] bv = s2.Split(' ');
                    string xxxx = bv[1];
                    xxxx = xxxx.Replace(";", "");
                    int xx = int.Parse(xxxx);
                    string xxx = Program.model.modelGekko.varsBTypeInverted[xx];
                    G.Writeln("b[" + xx + "] = " + xxx);
                    return "";
                }
                if (s2.Length == 8)
                {
                    string sub = s2;
                    if (G.Equal(sub, "rungenr1"))
                    {
                        //typing "rungenr1" will put cs code in Genr.cs
                        G.Writeln2("Put code in Genr.cs. Now you should compile...");
                        Program.Rungenr(1);
                        return "";  //no need for the parser to chew on this afterwards!
                    }
                    else if (G.Equal(sub, "rungenr2"))
                    {
                        //typing "rungenr2" will run stuff in Genr.cs for debugging
                        G.Writeln2("Running Genr.cs for debugging:");
                        Program.Rungenr(2);
                        return "";  //no need for the parser to chew on this afterwards!
                    }
                }
                

                if (s2.Length == 7)
                {
                    string sub = s2;
                    if (G.Equal(sub, "timings"))
                    {
                        Globals.showTimings = !Globals.showTimings;
                        G.Writeln("TIMINGS = " + Globals.showTimings);
                        return "";  //no need for the parser to chew on this afterwards!
                    }
                }

                if (s2.Length == 7)
                {
                    string sub = s2;
                    if (G.Equal(sub, "packsim"))
                    {
                        Globals.alwaysEnablcPackForSimulation = true;
                        G.Writeln("alwaysEnablcPackForSimulation = " + Globals.alwaysEnablcPackForSimulation);
                    }
                }

                if (s2.Length == 6)
                {
                    string sub = s2;
                    if (G.Equal(sub, "aremos"))
                    {
                        //typing "aremos" on the prompt opens the dialog for creating a wa.bat file.
                        //not intended for "normal" Gekko users.
                        makeBatFileForAremos();
                        return "";  //no need for the parser to chew on this afterwards!
                    }
                }                
                               


                if (s2.Length == 5)
                {
                    string sub = s2;
                    if (G.Equal(sub, "flush"))
                    {
                        Flush();  //removes cached models
                        return "";
                    }
                }

                if (s2.Length == 3)
                {
                    string sub = s2;
                    if (G.Equal(sub, "sub"))
                    {
                        if (Globals.decompSubstitute == true) Globals.decompSubstitute = false;
                        else Globals.decompSubstitute = true;
                        return "";
                    }
                }

                if (s2.Length == 11)
                {
                    string sub = s2;
                    if (G.Equal(sub, "randommodel"))
                    {
                        Randommodel();
                        return "";  //no need for the parser to chew on this afterwards!
                    }
                }

                if (s2.Length == 16)
                {
                    string sub = s2;
                    if (G.Equal(sub, "randommodelcheck"))
                    {
                        Randommodelcheck();
                        return "";  //no need for the parser to chew on this afterwards!
                    }
                }


                if (s2.Length == 6)
                {
                    string sub = s2;
                    if (G.Equal(sub, "deploy"))
                    {
                        //Deploy
                        G.Writeln2("Use 'deploy' from Total Commander prompt");
                        G.Writeln(@"Also see c:\Thomas\Gekko\GekkoCS\Deploy\!seher");
                        return "";   //no need for the parser to chew on this afterwards!
                    }
                }

                if (s2.Length == 7)
                {

                    string sub = s2;

                    if (G.Equal(sub, "testsim"))
                    {
                        int n = 1000;
                        double[] abs = new double[3000];  //years
                        double[] rel = new double[3000];  //years
                        string[] absVar = new string[3000];  //years
                        string[] relVar = new string[3000];  //years

                        double[] absVs = new double[3000];  //years
                        double[] relVs = new double[3000];  //years

                        double[] absHs = new double[3000];  //years
                        double[] relHs = new double[3000];  //years

                        int min = int.MaxValue;
                        int max = int.MinValue;
                        List<string> list = Program.GetListOfStringsFromList(Program.databanks.GetFirst().GetIVariable(Globals.symbolCollection + "endo"));
                        int x = list.Count;
                        G.Writeln("Testing " + x + " endogenous vars");
                        for (int i = 0; i < x; i += n)
                        {
                            G.Writeln("Testing " + i + " up to " + (i + n - 1));
                            List<string> res = TestSim(list, i, i + n - 1);
                            foreach (string s in res)
                            {
                                string[] s3 = s.Split('¤');
                                string type = s3[0];
                                int year = int.Parse(s3[1]);
                                string var = s3[2];
                                double val = G.ParseIntoDouble(s3[3]);
                                double vs = G.ParseIntoDouble(s3[4]);
                                double hs = G.ParseIntoDouble(s3[5]);
                                if (year < min) min = year;
                                if (year > max) max = year;
                                if (type == "abs")
                                {
                                    if (val > abs[year])
                                    {
                                        abs[year] = val;
                                        absVar[year] = var;
                                        absVs[year] = vs;
                                        absHs[year] = hs;
                                    }
                                }
                                else
                                {
                                    if (val > rel[year])
                                    {
                                        rel[year] = val;
                                        relVar[year] = var;
                                        relVs[year] = vs;
                                        relHs[year] = hs;
                                    }
                                }
                            }
                        }

                        G.Writeln();
                        for (int y = min; y <= max; y++)
                        {
                            G.Writeln("rel% " + y + " " + relVar[y] + " " + rel[y] + "%     left " + relVs[y] + " right " + relHs[y]);
                        }

                        G.Writeln();
                        for (int y = min; y <= max; y++)
                        {
                            G.Writeln("abs " + y + " " + absVar[y] + " " + abs[y] + "     left " + absVs[y] + " right " + absHs[y]);
                        }

                        return "";  //no need for the parser to chew on this afterwards!
                    }
                }

                if (s2.Length == 3)
                {
                    string sub = s2;
                    if (G.Equal(sub, "lex"))
                    {
                        //show raw tokens
                        //only for debugging
                        //not intended for "normal" Gekko users.
                        if (Globals.debugTokens) Globals.debugTokens = false;
                        else Globals.debugTokens = true;
                        if (Globals.debugTokens == true)
                        {
                            G.Writeln("Lexing will be done...");
                        }
                        else
                        {
                            G.Writeln("Lexing undone...");
                        }
                        return "";  //no need for the parser to chew on this afterwards!
                    }
                }

                

                if (s2.Length == 3)
                {
                    string sub = s2;
                    if (G.Equal(sub, "ast"))
                    {
                        //typing "ast" on the prompt means AST tree is printed out on screen
                        //only for debugging
                        //not intended for "normal" Gekko users.
                        Globals.printAST = true;
                        G.Writeln("AST tree will be printed...");
                        return "";  //no need for the parser to chew on this afterwards!
                    }
                }

                if (s2.Length == "testram".Length)
                {
                    string sub = s2;
                    if (G.Equal(sub, "testram"))
                    {
                        Program.TestRam(false);
                        return "";  //no need for the parser to chew on this afterwards!
                    }
                }

                if (s2.Length == "testram2".Length)
                {
                    string sub = s2;
                    if (G.Equal(sub, "testram2"))
                    {
                        Program.TestRam(true);
                        return "";  //no need for the parser to chew on this afterwards!
                    }
                }                

                if (s2.Length == 7)
                {
                    string sub = s2;
                    if (G.Equal(sub, "timings"))
                    {
                        Globals.showTimings = true;
                        G.Writeln("Timings shown...");
                        return "";  //no need for the parser to chew on this afterwards!
                    }
                }                
                
                if (s2.Length == 5)
                {
                    string sub = s2;
                    if (G.Equal(sub, "proto"))
                    {
                        if (Globals.databanksAsProtobuffers == true) Globals.databanksAsProtobuffers = false;
                        else Globals.databanksAsProtobuffers = true;
                        G.Writeln("Protobuf using is set to: " + Globals.databanksAsProtobuffers);
                        return "";  //no need for the parser to chew on this afterwards!
                    }
                }

                if (s2.Length == 4)
                {
                    string sub = s2;
                    if (G.Equal(sub, "gray"))
                    {
                        if (Globals.printGrayLinesForDebugging == true) Globals.printGrayLinesForDebugging = false;
                        else Globals.printGrayLinesForDebugging = true;
                        G.Writeln("Gray printing (debug) is set to: " + Globals.printGrayLinesForDebugging);
                        return "";  //no need for the parser to chew on this afterwards!
                    }
                }

                if (s2.StartsWith("prune "))
                {
                    string[] ss2 = s2.Split(' ');
                    double prune = G.ParseIntoDouble(ss2[1].Trim());
                    Globals.pruneDecomp = prune;
                    G.Writeln("Flowchart prune set to: " + Globals.pruneDecomp);
                    G.Writeln();
                    return "";
                }

                
                if (s2.Length == "killexcel".Length)
                {
                    if (G.Equal(s2, "killexcel"))
                    {
                        DialogResult result = MessageBox.Show("Delete all processes with 'excel' in their names? CLOSE EXCEL SHEETS BEFOREHAND!!", "Gekko helper", MessageBoxButtons.YesNo, MessageBoxIcon.None, MessageBoxDefaultButton.Button2, MessageBoxOptions.DefaultDesktopOnly);
                        if (result == DialogResult.Yes)
                        {
                            G.Writeln("");
                            int counter = 0;
                            Process[] ps = Process.GetProcesses();
                            foreach (var process in ps)
                            {
                                string name = process.ProcessName;
                                if (name.ToLower().Contains("excel"))
                                {
                                    process.Kill();
                                    G.Writeln("Killed '" + name + "'");
                                    counter++;
                                }
                            }
                            G.Writeln("Killed " + counter + " Excel processes");
                        }
                        else G.Writeln2("Cancelled");
                        return "";  //no need for the parser to chew on this afterwards!
                    }
                }

                if (s2.Length == 6)
                {
                    string sub = s2;
                    if (G.Equal(sub, "locked"))
                    {
                        //typing "locked" on the prompt searches for locked files (sharing violation)
                        //in working folder and sub-dirs
                        //intended for bug finding
                        if (true)
                        {
                            string workingFolder = G.GetWorkingFolder();
                            G.Writeln("Searching for locked files in " + workingFolder);
                            G.Writeln("The search includes sub-folders");
                            G.Writeln("----------- search starts --------------");
                            Globals.lockedCounter = 0;
                            FindLockedFiles(G.GetWorkingFolder());
                            G.Writeln("----------- search ends   --------------");
                            G.Writeln("Found " + Globals.lockedCounter + " locked files");
                            G.Writeln();
                        }
                        return "";  //no need for the parser to chew on this afterwards!
                    }
                }
            }
            return text;
        }


        private static void FindLockedFiles(string folder)
        {
            foreach (string file in Directory.GetFiles(folder))
            {
                try
                {
                    using (FileStream fs = File.Open(file, FileMode.Open, FileAccess.Read, FileShare.None))
                    {
                        fs.Close();
                    }
                    // The file is not locked
                }
                catch (Exception)
                {
                    // The file is locked
                    G.Writeln("locked: " + file);
                    Globals.lockedCounter++;
                }

            }
            foreach (string subDir in Directory.GetDirectories(folder))
            {
                FindLockedFiles(subDir);
            }
        }



        public static void ConvertMenu2()
        {
            string folder = "";
            FolderBrowserDialog fbd = new FolderBrowserDialog();
            fbd.SelectedPath = Program.options.folder_working;
            if (fbd.ShowDialog() == DialogResult.OK)
            {
                folder = fbd.SelectedPath;
            }
            if (folder != "")
            {
                string outputPath = Globals.localTempFilesLocation + "\\" + "menufilesconversion";
                DeleteFolder(outputPath);
                Directory.CreateDirectory(outputPath);

                Globals.convertMenuCounter = 0;
                Globals.convertMenuErrorCounter = 0;

                G.Writeln("Starting conversion of menus...");

                ConvertMenu(0, folder, folder, outputPath);

                bool ok = true;
                try
                {
                    string stylesFile = Application.StartupPath + "\\images\\" + "styles.css";
                    string tableIconFile = Application.StartupPath + "\\images\\" + "table.png";
                    WaitForFileCopy(stylesFile, outputPath + "\\styles.css");
                    WaitForFileCopy(tableIconFile, outputPath + "\\table.png");
                }
                catch (Exception e)
                {
                    ok = false;
                    G.Writeln2("*** ERROR: Problem with style-sheets, may impact the menus (files styles.css and table.png)");
                }

                G.Writeln();
                G.Write("Zipping converted files... ");
                string zipFileNameInput = Program.CreateFullPathAndFileName(Program.options.folder_working + "\\converted_menus.zip");
                Program.WaitForZipWrite(outputPath, zipFileNameInput);
                G.Writeln("... ended");
                G.Writeln();
                G.Writeln("Converted " + Globals.convertMenuCounter + " menus from folder: " + folder);
                G.Writeln("There were " + Globals.convertMenuErrorCounter + " error messages.");
                G.Writeln("See the file converted_menus.zip in the working folder.");
                if (ok)
                {
                    G.Writeln("Note the two files styles.css and table.png in the root of the zip file: these");
                    G.Writeln("two files are used to style the menus, without them the menus will look ugly!");
                }
            }
            else
            {
                G.Writeln2("*** ERROR: please choose a folder");
            }
        }

        public static void ConvertMenu(int depth, string start, string folder, string outputPath)
        {
            foreach (string file in Directory.GetFiles(folder))
            {
                if (file.ToLower().EndsWith(".cmd"))
                {
                    //G.Writeln("table file: " + file);
                    string extra = file.Replace(start, "");

                    StringBuilder x = new StringBuilder();

                    try
                    {
                        x = ConvertPcimMenu(depth, file);
                    }
                    catch (Exception e)
                    {
                        G.Writeln();
                        G.Writeln("Conversion failed completely: " + file);
                        G.Writeln();
                        x = null;
                    }

                    if (x != null)
                    {
                        Globals.convertMenuCounter++;
                        string newfile = outputPath + extra;
                        if (newfile.ToLower().EndsWith(".cmd"))
                        {
                            newfile = newfile.Substring(0, newfile.Length - 4);
                            newfile = newfile + ".html";
                        }
                        else
                        {
                            G.Writeln2("*** ERROR: Converting menus: file name: " + newfile);
                        }
                        string path = Path.GetDirectoryName(newfile);
                        if (!Directory.Exists(path))
                        {
                            Directory.CreateDirectory(path);
                        }

                        using (FileStream fs = WaitForFileStream(newfile, GekkoFileReadOrWrite.Write))
                        using (StreamWriter sw = G.GekkoStreamWriter(fs))
                        {
                            sw.Write(x);
                            sw.Flush();
                        }
                    }
                }
            }
            if (true)  //we allow converting subfolders
            {
                foreach (string subDir in Directory.GetDirectories(folder))
                {
                    ConvertMenu(depth + 1, start, subDir, outputPath);
                }
            }
        }


        public static void ConvertTabToText2(string folder)
        {

            string outputPath = Globals.localTempFilesLocation + "\\" + "tabtotextconversion";

            DeleteFolder(outputPath);
            Directory.CreateDirectory(outputPath);

            Globals.convertTabToTextCounter = 0;
            Globals.convertTabToTextErrorCounter = 0;

            G.Writeln("Starting conversion of tables to text...");

            try
            {
                Program.options.interface_debug = "none";
                ConvertTabToText(0, folder, folder, outputPath);
            }
            finally
            {
                WaitForFileDelete(Program.options.folder_working + "\\" + "temptabtotextfile.txt");
                Program.options.interface_debug = "dialog";
            }

            G.Writeln();
            G.Write("Zipping converted files... ");
            string zipFileNameInput = Program.CreateFullPathAndFileName(Program.options.folder_working + "\\converted_table_text.zip");
            Program.WaitForZipWrite(outputPath, zipFileNameInput);
            G.Writeln("... ended");
            G.Writeln();
            G.Writeln("Converted " + Globals.convertTabToTextCounter + " tables from folder: " + folder);
            G.Writeln("with " + Globals.convertTabToTextErrorCounter + " non-converted tables (errors).");
            G.Writeln("Result is in the file converted_table_text.zip in the working folder.");
        }

        public static void ConvertTabToText(int depth, string start, string folder, string outputPath)
        {
            foreach (string file in Directory.GetFiles(folder))
            {
                string extra = file.Replace(start, "");
                if (file.ToLower().EndsWith("." + Globals.extensionTable))
                {
                    StringBuilder x = null;

                    try
                    {
                        string s = ConvertTabToTextHelper(depth, file);
                        x = new StringBuilder(s);
                    }
                    catch (Exception e)
                    {
                        G.Writeln2("*** ERROR: Conversion failed completely: " + file);
                        G.Writeln("----------------------------------------------------------------------");
                        G.Writeln("");
                        Globals.convertTabToTextErrorCounter++;
                        x = null;
                    }

                    if (x != null)
                    {
                        Globals.convertTabToTextCounter++;
                        G.Writeln("Total converted tables: " + Globals.convertTabToTextCounter);
                        string newfile = outputPath + extra;
                        string path = Path.GetDirectoryName(newfile);
                        if (!Directory.Exists(path))
                        {
                            Directory.CreateDirectory(path);
                        }

                        newfile = Path.ChangeExtension(newfile, ".txt");

                        using (FileStream fs = WaitForFileStream(newfile, GekkoFileReadOrWrite.Write))
                        using (StreamWriter sw = G.GekkoStreamWriter(fs))
                        {
                            sw.Write(x);
                            sw.Flush();
                        }
                    }
                }
                else if (file.ToLower().EndsWith(".html"))
                {
                    //for HTML menu files, we change links to .tab files to .txt files (unfortunately necessary in order to get IE to read them).
                    string newfile = outputPath + extra;
                    string path = Path.GetDirectoryName(newfile);
                    if (!Directory.Exists(path))
                    {
                        Directory.CreateDirectory(path);
                    }

                    string s = GetTextFromFileWithWait(file);
                    s = s.Replace("." + Globals.extensionTable + "\"", ".txt\"");
                    using (FileStream fs = WaitForFileStream(newfile, GekkoFileReadOrWrite.Write))
                    using (StreamWriter sw = G.GekkoStreamWriter(fs))
                    {
                        sw.Write(s);
                        sw.Flush();
                    }
                }
            }
            if (true)  //we allow converting subfolders
            {
                foreach (string subDir in Directory.GetDirectories(folder))
                {
                    ConvertTabToText(depth + 1, start, subDir, outputPath);
                }
            }
        }


        public static StringBuilder ConvertPcimMenu(int depth, string file)
        {
            StringBuilder x = new StringBuilder();

            StringBuilder x2 = new StringBuilder();

            string title = null;

            List<string> lines = G.ExtractLinesFromText(GetTextFromFileWithWait(file));
            int counter = 0;

            string path = "";
            for (int i = 0; i < depth; i++)
            {
                path = path + "../";
            }

            foreach (string line2 in lines)
            {
                if (line2.ToLower() == "case") continue;  //kind of empty line
                string line = line2.Trim();
                counter++;
                if (line.Contains("\""))
                {
                    MenuConvertError(file, counter, line, "Menu lines should not contain full quotes (\")");
                }


                if (line.ToLower().StartsWith("nymenu "))
                {
                }
                else if (line.ToLower().StartsWith("select "))
                {
                }
                else if (line.ToLower().StartsWith("case "))
                {
                    string lineTrunc = line.Substring(5);
                    string[] split = lineTrunc.Split('/');
                    if (split.Length == 1)
                    {
                        if (title == null)
                        {
                            title = split[0].Trim();  //only first time
                        }
                        else
                        {
                            //2. time and on
                            x2.AppendLine("      <li>" + split[0].Trim() + "</li>");
                        }
                    }
                    else if (split.Length == 2)
                    {
                        x2.AppendLine("      <li><a href=`" + split[1].Trim() + ".html`>" + split[0].Trim() + "</a></li>");
                    }
                    else if (split.Length >= 3)
                    {
                        if (split.Length > 3) MenuConvertError(file, counter, line, "There are more than 2 '/' in the line: cannot understand");

                        string s1 = split[0].Trim();

                        string lastWord = "";
                        for (int i = s1.Length - 1; i >= 1; i--)
                        {
                            if (!(G.IsLetterOrDigitOrUnderscore(s1[i]) || s1[i] == '-' || s1[i] == '(' || s1[i] == ')'))
                            {
                                if (s1[i] == ' ' && s1[i - 1] == ' ')  //two blanks before word
                                {
                                    if (i < s1.Length - 1)
                                    {
                                        lastWord = s1.Substring(i + 1);
                                    }
                                }
                                break;
                            }
                        }

                        string text = s1;
                        string lbl = "";

                        if (lastWord != "")
                        {
                            //try looking at last word
                            text = s1.Substring(0, s1.Length - lastWord.Length).TrimEnd();
                            lbl = lastWord;
                        }
                        text = text + " ";

                        string img = "<img src=`" + path + "table.png`>";

                        if (lbl != "")
                        {
                            x2.AppendLine("      <li><a href=`" + split[2].Trim() + "." + Globals.extensionTable + "`>" + img + " " + text + " <font color=`silver`>(" + lbl + ")</font>" + "</a>" + "</li>");
                        }
                        else
                        {
                            x2.AppendLine("      <li><a href=`" + split[2].Trim() + "." + Globals.extensionTable + "`>" + img + " " + text + "</a>" + "</li>");
                        }
                    }
                }
                else
                {
                    MenuConvertError(file, counter, line, "Could not recognize this as a menu line, skipping");
                }
            }

            if (title == null) title = "Menu";

            x.AppendLine("<!DOCTYPE HTML PUBLIC `-//W3C//DTD HTML 4.01 Transitional//EN`>");
            x.AppendLine("<html>");
            x.AppendLine("  <head>");
            x.AppendLine("    <link rel=`stylesheet` href=`" + path + "styles.css` type=`text/css`>");
            x.AppendLine("    <meta http-equiv=`Content-Type` content=`text/html; charset=iso-8859-1`>");
            x.AppendLine("    <title>" + title + "</title>");
            x.AppendLine("  </head>");
            x.AppendLine("  <body>");
            x.AppendLine("  <big><b>" + title + "</b></big><br>");
            x.AppendLine("    <ul>");
            x.Append(x2);
            x.AppendLine("    </ul>");
            x.AppendLine("  </body>");
            x.AppendLine("</html>");

            x.Replace("`", "\"");

            return x;
        }


        public static string ConvertTabToTextHelper(int depth, string file)
        {
            string tt1 = "__tabletimestart";
            string tt2 = "__tabletimeend";

            P p = new P();
            Program.XmlTable(file, "txt", null, p);
            Program.Pipe("temptabtotextfile.txt", null);  //no append
            O.Run o = new O.Run();
            o.fileName = Globals.localTempFilesLocation + "\\" + "tablecode." + Globals.defaultCommandFileExtension;
            o.p = p;
            Program.Run(o);
            Program.Pipe("con", null);

            string s = GetTextFromFileWithWait(Program.options.folder_working + "\\" + "temptabtotextfile.txt");

            return s;
        }


        public static void ConvertTab2()
        {
            string folder = "";
            FolderBrowserDialog fbd = new FolderBrowserDialog();
            fbd.SelectedPath = Program.options.folder_working;
            if (fbd.ShowDialog() == DialogResult.OK)
            {
                folder = fbd.SelectedPath;
            }
            if (folder != "")
            {
                string outputPath = Globals.localTempFilesLocation + "\\" + "tabfilesconversion";

                DeleteFolder(outputPath);
                Directory.CreateDirectory(outputPath);

                Globals.convertTableCounter = 0;
                Globals.convertTableErrorCounter = 0;

                G.Writeln("Starting conversion of tables...");

                ConvertTab(folder, folder, outputPath);

                G.Writeln();
                G.Write("Zipping converted files... ");
                string zipFileNameInput = Program.CreateFullPathAndFileName(Program.options.folder_working + "\\converted_tables.zip");
                Program.WaitForZipWrite(outputPath, zipFileNameInput);
                G.Writeln("... ended");
                G.Writeln();
                G.Writeln("Converted " + Globals.convertTableCounter + " tables from folder: " + folder);
                G.Writeln("There were " + Globals.convertTableErrorCounter + " error messages.");
                G.Writeln("See the file converted_tables.zip in the working folder.");
            }
            else
            {
                G.Writeln2("*** ERROR: please choose a folder");
            }
        }

        public static void ConvertTab(string start, string folder, string outputPath)
        {
            foreach (string file in Directory.GetFiles(folder))
            {
                if (file.ToLower().EndsWith("." + "tab"))
                {
                    //G.Writeln("table file: " + file);
                    string extra = file.Replace(start, "");

                    StringBuilder x = new StringBuilder();

                    try
                    {
                        x = ConvertPcimTable(file);
                    }
                    catch (Exception e)
                    {
                        G.Writeln();
                        G.Writeln("Conversion failed completely: " + file);
                        G.Writeln();
                        x = null;
                    }

                    if (x != null)
                    {
                        Globals.convertTableCounter++;
                        string newfile = outputPath + extra;  //path and filename
                        if (newfile.ToLower().EndsWith(".tab"))
                        {
                            newfile = newfile.Substring(0, newfile.Length - 4);
                            newfile = newfile + "." + Globals.extensionTable + "";
                        }
                        else
                        {
                            //This should not be possible....
                        }
                        string path = Path.GetDirectoryName(newfile);
                        if (!Directory.Exists(path))
                        {
                            Directory.CreateDirectory(path);
                        }

                        using (FileStream fs = WaitForFileStream(newfile, GekkoFileReadOrWrite.Write))
                        using (StreamWriter sw = G.GekkoStreamWriter(fs))
                        {
                            sw.Write(x);
                            sw.Flush();
                        }
                    }
                }
            }
            foreach (string subDir in Directory.GetDirectories(folder))
            {
                ConvertTab(start, subDir, outputPath);
            }
        }

        public static void DeleteFolder(string s, string omitType)
        {
            if (!Directory.Exists(s)) return;
            DeleteFolderHelper(new DirectoryInfo(s), omitType);
        }

        public static void DeleteFolder(string s)
        {
            DeleteFolder(s, null);
        }

        //Seems it does not delete the folders, but only their content
        private static void DeleteFolderHelper(DirectoryInfo directoryInfo, string omitType)
        {
            foreach (FileInfo file in directoryInfo.GetFiles())
            {
                if (omitType != null && G.Equal("." + omitType, file.Extension)) continue;  //skip it
                file.Delete();  //hmm probably best not to use WaitForFileDelete() here, exceptions are typically caught in a wrapper on this method, and not critical if it fails (used for cleanup)
            }
            foreach (DirectoryInfo subfolder in directoryInfo.GetDirectories())
            {
                DeleteFolderHelper(subfolder, omitType);
            }
        }

        private static bool Has2IdentsFollowing(string lineNewVersion, int start)
        {
            //The method looks for two idents like "a1 b2 " or "a1 b2>". Any spaces before, in middle or after are ok.
            //A '=' right after the second token is ok too.
            int j = skipSpaces(lineNewVersion, start);
            if (j == -12345) return false;
            if (!G.IsLetterOrUnderscore(lineNewVersion[j])) return false;
            int blank = -12345;
            for (int k = j + 1; k < lineNewVersion.Length; k++)
            {
                if (lineNewVersion[k] == ' ')
                {
                    blank = k;
                    break;
                }
                if (!G.IsLetterOrDigitOrUnderscore(lineNewVersion[k]))
                {
                    return false;
                }
            }
            j = skipSpaces(lineNewVersion, blank);
            if (j == -12345) return false;
            if (!G.IsLetterOrUnderscore(lineNewVersion[j])) return false;
            for (int k = j + 1; k < lineNewVersion.Length; k++)
            {
                if (lineNewVersion[k] == ' ' || lineNewVersion[k] == '=' || lineNewVersion[k] == '>')
                {
                    //these are ok: <m p q>, <stamp rows=yes>, <m p>
                    //so the first two tokens will not by tried to be interpreted as two dates
                    break;
                }
                if (!G.IsLetterOrDigitOrUnderscore(lineNewVersion[k]))
                {
                    return false;
                }
            }
            return true;
        }

        private static List<string> HandleObeyFilesNew(List<string> inputFileLines)
        {
            List<string> inputFileLines2 = new List<string>();
            int lineCounter = 0;
            foreach (string line in inputFileLines)
            {
                lineCounter++;
                string lineNewVersion = line;

                if (lineNewVersion == Globals.iniFileSecretName)  //this strange name is made in GuiAutoExecStuff()
                {
                    //lineNewVersion = "run '" + Globals.autoExecCmdFileName + "';";
                    lineNewVersion = "ini;";
                }
                else if (lineNewVersion == "RunGekkoTabToTextStuff")
                {
                    ConvertTabToText2(Globals.RunGekkoTabToTextStuff_folder);
                    lineNewVersion = "";  //deleting it, has been handled above
                }

                string lineComment = lineNewVersion.Trim();

                if (Globals.addGlue)
                {

                    // Special rule to make sure PRT<m d> is not interpreted as time period, so in that case we get
                    // PRT<m d> --> PRT <¨<m d>
                    //
                    // Else: (ldu is letterDigitUnderscore)
                    // For every ldu, '(', '[', '{', '%', '#'
                    //   see if preceding char is ldu, ')', ']', '}', '%' or '#'.
                    //   if so, put a glue in between.
                    //   EXCEPTION: ldu before ldu gets no glue (of course)!
                    // For '|' there is glue before, UNLESS there is a blank before OR after the '|'
                    // For '.' ...
                    //
                    // For "<m d>" kind of options, we use a special kind of marker ('<<<' instead of '<') to indicate that it is
                    // an "<ident ident..." type.
                    //List<char> glued1 = new List<char> { ')', ']', '}', Globals.symbolMemvar, Globals.symbolList };
                    //List<char> glued2 = new List<char> { '(', '[', '{', Globals.symbolMemvar, Globals.symbolList };
                    List<char> glued3 = new List<char> { '|', '\\' };  //note special rules for '.', see glued3a
                    List<char> glued3a = new List<char> { '=', '+', '-', '/', '*', '^', '(', '{', '[', '<', '>', ',', ':', ' ' };  // "=.12", "+.12", "-.12" etc.
                    List<char> glued4 = new List<char> { '@' };  //only checked if no blank right of this
                    List<char> glued5 = new List<char> { '.' };  //only checked if no blank right of this
                    List<char> glued6 = new List<char> { '*', '?' };  //wildcards: a*b and a?b cannot have blanks.
                    List<char> glued7 = new List<char> { Globals.freqIndicator };

                    //=========== note =========================
                    // [c1] [c2] [c3], where c2 is the char analyzed.
                    //==========================================

                    StringBuilder sb = new StringBuilder();
                    for (int i = 0; i < lineNewVersion.Length; i++)  //ignore if first on line
                    {
                        char c1 = '\n';
                        if (i > 0) c1 = lineNewVersion[i - 1];
                        char c2 = lineNewVersion[i];
                        char c3 = '\n';
                        if (i < lineNewVersion.Length - 1) c3 = lineNewVersion[i + 1];
                        char c4 = '\n';
                        if (i < lineNewVersion.Length - 2) c4 = lineNewVersion[i + 2];
                        
                        // -------------------------------------------------------------
                        // Handle PRT<m d> etc.
                        // -------------------------------------------------------------
                        if (c2 == '<')
                        {
                            //Special rule to make sure the first two tokens inside <> in PRT<m d> or PRT<stamp row=yes> are not interpreted as time period
                            //If we have for instance "<m d>", the below will return true, and it will be transformed
                            //into "<¨<m d>". This makes it easier to identify such cases in the parser. We would not like
                            //to try to interpret <m d> as a time period, so two raw idents will never be thought of as a
                            //period. That way, missspellings like "<m dd>" will be caught in syntax, and it will not try
                            //to understand <filter row> as dates either. But <%t1 %t2> will be just fine as dates, as will
                            //<2010 2012>. Expressions can also be used for dates.
                            //So all in there is special treatment of the first two items in <>, since this is the only place
                            //a date is allowed.
                            if (Has2IdentsFollowing(lineNewVersion, i + 1))
                            {
                                sb.Append(Globals.symbolGlueChar5);
                                continue;
                            }
                        }

                        // -------------------------------------------------------------
                        // Handle x(, x[, x{, %x, #x
                        // c2 is current char, c1 is previous
                        // -------------------------------------------------------------
                        if (c1 != '\n')
                        {
                            /*
                                   a(      --->   a¨(     and same for the others
                                   a[      --->   special [_[ symbol
                                   a{
                                   a%  //part of name
                                   a#  //part of name

                                   )a  //for instance a%(%b)c, not need for glue here like this: a%(%b)|c as in a%d|c.
                                   ){  //same logic
                                   )%  //same logic
                                   )#  //same logic
                                   )[  //for instance #(list%i)[2] --> special [_[ symbol

                                   }a
                                   }{
                                   }%
                                   }#
                                   }[  //for instance {%a}[2000] or {a}[2000], --> special [_[ symbol

                                   %a
                                   %(
                                   %{

                                   ][  //for instance #m[3][2001q3], --> special [_[ symbol

                                   #(
                                   #{



                                   ...#a --> what is that??



                            */
                            bool glue = false;
                            bool glue2 = false;

                            if (G.IsLetterOrDigitOrUnderscore(c1) && c2 == '(') glue = true;
                            else if (G.IsLetterOrDigitOrUnderscore(c1) && c2 == '[') glue2 = true;
                            else if (G.IsLetterOrDigitOrUnderscore(c1) && c2 == '{') glue = true;
                            else if (G.IsLetterOrDigitOrUnderscore(c1) && c2 == Globals.symbolScalar) glue = true;
                            else if (G.IsLetterOrDigitOrUnderscore(c1) && c2 == Globals.symbolCollection) glue = true;

                            else if (c1 == ')' && G.IsLetterOrDigitOrUnderscore(c2)) glue = true;
                            else if (c1 == ')' && c2 == '{') glue = true;
                            else if (c1 == ')' && c2 == Globals.symbolScalar) glue = true;
                            else if (c1 == ')' && c2 == Globals.symbolCollection) glue = true;
                            else if (c1 == ')' && c2 == '[') glue2 = true;

                            else if (c1 == '}' && G.IsLetterOrDigitOrUnderscore(c2)) glue = true;
                            else if (c1 == '}' && c2 == '{') glue = true;
                            else if (c1 == '}' && c2 == Globals.symbolScalar) glue = true;
                            else if (c1 == '}' && c2 == Globals.symbolCollection) glue = true;
                            else if (c1 == '}' && c2 == '[') glue2 = true;

                            else if (c1 == Globals.symbolScalar && G.IsLetterOrDigitOrUnderscore(c2)) glue = true;
                            else if (c1 == Globals.symbolScalar && c2 == '(') glue = true;
                            else if (c1 == Globals.symbolScalar && c2 == '{') glue = true;

                            //else if (c1 == Globals.symbolDollar[0] && G.IsLetterOrDigitOrUnderscore(c2)) glue = true;
                            //else if (c1 == Globals.symbolDollar[0] && c2 == '(') glue = true;
                            //else if (c1 == Globals.symbolDollar[0] && c2 == '{') glue = true;

                            else if (c1 == Globals.symbolCollection && G.IsLetterOrDigitOrUnderscore(c2)) glue = true;
                            else if (c1 == Globals.symbolCollection && c2 == '(') glue = true;
                            else if (c1 == Globals.symbolCollection && c2 == '{') glue = true;

                            else if (c1 == ']' && c2 == '[') glue2 = true;

                            if (glue)
                            {
                                sb.Append(Globals.symbolGlueChar1);
                                sb.Append(c2);
                                continue;
                            }
                            else if (glue2)
                            {
                                sb.Append(Globals.symbolGlueChar6);
                                continue;
                            }

                            // -------------------------------------------------------------
                            // Handle x|x, x\\x
                            // c2 is current char, c1 is previous
                            // -------------------------------------------------------------
                            //glued3: '|', '\\'
                            else if (glued3.Contains(c2)) //add glue if "xx|yy", but not "xx| yy" or "xx |yy" or "xx | yy", and same regarding "\\"
                            {
                                //Handling '|' and '\\'
                                if (c3 != '\n')
                                {
                                    if (c1 != ' ' && c3 != ' ')
                                    {
                                        sb.Append(Globals.symbolGlueChar1); //12|34 --> 12¨|34, and 12\\34 --> 12¨\\34
                                        sb.Append(c2);
                                        continue;
                                    }
                                }
                            }
                        }

                        // -------------------------------------------------------------
                        // Handle stand-alone [a*b*c*d] that may look like a 1x1 matrix
                        // -------------------------------------------------------------
                        if (c2 == '[')
                        {
                            int iRight = -12345;

                            for (int ii = i + 1; ii < lineNewVersion.Length; ii++)
                            {
                                if (lineNewVersion[ii] == ']')
                                {
                                    iRight = ii;
                                    break;
                                }
                            }
                            if (iRight != -12345)
                            {
                                string inside = lineNewVersion.Substring(i + 1, iRight - i - 1);
                                if (CheckIfLooksLikeWildcard(inside))
                                {
                                    sb.Append(Globals.symbolGlueChar7);
                                    continue;
                                }
                            }
                        }

                        // -------------------------------------------------------------
                        // Handle @
                        // -------------------------------------------------------------
                        if (glued4.Contains(c2))
                        {
                            //handling '@'
                            if (c3 != '\n')
                            {
                                if (c3 == ' ')
                                {
                                    //ignore
                                }
                                else
                                {
                                    //PRT @x --> PRT @¨x, but PRT @ x --> PRT @ x.
                                    //Note that the glue is AFTER the @.
                                    sb.Append(c2);
                                    sb.Append(Globals.symbolGlueChar1);
                                    continue;
                                }
                            }
                        }

                        // -------------------------------------------------------------
                        // Handle wildcards a*b, a?b -> a½*½b, a½?½b, also {'a'}*{'b'} will become {'a'}½*½{'b'}
                        // A * will get glue (½) to the left if there is ldu to the left. a* -> a½*
                        // A * will get glue (½) to the right if there is ldu the right.  *b -> *½b
                        // -------------------------------------------------------------
                        if (glued6.Contains(c2))
                        {
                            if (G.IsLetterOrDigitOrUnderscore(c1) || c1 == '}')
                            {
                                sb.Append(Globals.symbolGlueChar4);
                            }
                            sb.Append(c2);
                            if (G.IsLetterOrDigitOrUnderscore(c3) || c3 == '{')
                            {
                                sb.Append(Globals.symbolGlueChar4);
                            }
                            continue;
                        }                        

                        // -------------------------------------------------------------
                        // Handle dots (.)
                        // -------------------------------------------------------------
                        if (glued5.Contains(c2))
                        {
                            //c2 is a '.'
                            if (c1 != '\n' && c3 != '\n')
                            {

                                if (c3 == ' ')
                                {
                                    //do nothing, normal dot, for instance 12. 34
                                }
                                else if (char.IsDigit(c3))
                                {
                                    if (glued3a.Contains(c1))
                                    {
                                        //  +.12, **.12, >.12, (.12, etc.
                                        sb.Append(Globals.symbolGlueChar3);  //GLUEDOTNUMBER
                                        sb.Append(c2);
                                        continue;
                                    }
                                    else if (char.IsDigit(c1))
                                    {
                                        //in stuff like 12.34 the dot becomes a GLUEDOTNUMBER
                                        //but only if stuff before 12 is not ident, for instance
                                        //x12.34. We could have hgn2.1, and that is not a number.
                                        bool number = true;
                                        for (int ii = i - 1 - 1; ii >= 0; ii--)
                                        {
                                            //.... +123.45 loops through pure digits until + is met. Here number would be true.
                                            if (glued3a.Contains(lineNewVersion[ii]) || lineNewVersion[ii] == ';') break;  //for instance a "," or "+" to delimit the number ('token'), or the ';' in #m = [1.2;2.3]
                                            if (!char.IsDigit(lineNewVersion[ii]))
                                            {
                                                number = false;
                                                break;
                                            }
                                        }
                                        if (number)
                                        {
                                            sb.Append(Globals.symbolGlueChar3);  //GLUEDOTNUMBER
                                            sb.Append(c2);
                                            continue;
                                        }
                                        else
                                        {
                                            sb.Append(Globals.symbolGlueChar2);  //GLUEDOT
                                            sb.Append(c2);
                                            continue;
                                        }
                                    }
                                }
                                if (c1 != ' ' && c3 != ' ')
                                {
                                    sb.Append(Globals.symbolGlueChar2);  //GLUEDOT
                                    sb.Append(c2);
                                    continue;
                                }
                            }
                            else
                            {
                                if (c3 != '\n')
                                {
                                    if (char.IsDigit(c3))
                                    {
                                        //if line starts with .1, the dot is a GLUEDOTNUMBER
                                        sb.Append(Globals.symbolGlueChar3);  //GLUEDOTNUMBER
                                        continue;
                                    }
                                }
                            }
                        }

                        // -------------------------------------------------------------
                        // Handle exclamation (!)  --> if no spaces --> ¨!¨
                        // -------------------------------------------------------------
                        if (glued7.Contains(c2))
                        {
                            //c2 is a '!'
                            if (c1 != '\n' && c3 != '\n')
                            {
                                if (c1 != ' ' && c3 != ' ')
                                {
                                    sb.Append(Globals.symbolGlueChar1);
                                    sb.Append(c2);
                                    sb.Append(Globals.symbolGlueChar1);
                                    continue;
                                }
                            }
                        }

                        sb.Append(c2);
                    }
                    lineNewVersion = sb.ToString();
                }
                inputFileLines2.Add(lineNewVersion);
            }
            if (inputFileLines.Count != inputFileLines2.Count) throw new GekkoException();

            List<string> inputFileLines3 = new List<string>();

            if (Globals.runningOnTTComputer)
            {
                if (Globals.printAST)
                {
                    foreach (string s in inputFileLines2)
                    {
                        G.Writeln("-debug- " + s, Color.Orange);

                    }
                }
            }
            
            return inputFileLines2;
        }

        public static bool CheckIfLooksLikeWildcard2(string inside)
        {
            if (inside == null) return false;
            if (inside.Contains("*") || inside.Contains("?")) return true;
            return false;
        }

        public static bool CheckIfLooksLikeWildcard(string inside)
        {
            //finds [a*b?] patterns, handled like {'a*b?'}
            //note that [bank:a*b?] is also allowed
            //note that [bank:a*b?!q] is also allowed
            //problem is that [a*b] looks like a matrix definition, therefore this code.

            if (inside == null) return false;

            string[] sss = inside.Split(Globals.symbolBankColon2);

            if (sss.Length > 2) return false;

            string bank = null;
            string rest = null;
            if (sss.Length == 1)
            {
                rest = sss[0].Trim();
            }
            else
            {
                bank = sss[0].Trim();
                rest = sss[1].Trim();
            }
            if (bank != null && !G.IsSimpleToken(bank)) return false;

            string rest1 = null;
            string rest2 = null;  //freq
            string[] ssss = rest.Split(Globals.freqIndicator);
            if (ssss.Length == 1)
            {
                rest1 = ssss[0].Trim();
            }
            else
            {
                rest1 = ssss[0].Trim();
                rest2 = ssss[1].Trim();
            }

            int starCountFreq = 0;
            if (rest2 != null)
            {
                if (G.IsSimpleToken(rest2))
                {
                    //good
                }
                else if (rest2 == "*")
                {
                    //good
                    starCountFreq = 1;
                }
                else return false;
            }
        
            //seems this regex splits after '*' and '?', but keeps these delimiters
            string[] ss = Regex.Matches(rest1, @"[-\*?]|[^\*?-]+")
                .Cast<Match>()
                .Select(m => m.Value)
                .ToList()
                .ToArray<string>();

            int starCount = 0;
            int qCount = 0;
            for (int ii = 0; ii < ss.Length; ii++)
            {
                if (ss[ii] == "*")
                {
                    starCount++;
                }
                else if (ss[ii] == "?")
                {
                    qCount++;
                }
                else
                {
                    //why this test??
                    foreach (char c in ss[ii])
                    {
                        if (G.IsLetterOrDigitOrUnderscore(c) || c == Globals.symbolScalar || c == Globals.symbolCollection)
                        {
                            //good
                        }
                        else
                        {
                            //must be clean '0_ab_12x' type of word, can also contain % or #.
                            //blanks not allowed
                            return false;
                        }
                    }
                }
            }

            //if (starCount > 1) return false;  //only 1 accepted here, else use {'...'}
            if (starCount + qCount + starCountFreq == 0) return false;
            return true;
        }

       

        private static int GetNextIdent(string lineNewVersion, int i, out string ident)
        {
            //-12345 if no hit, else the first position to read for next thing to read
            ident = null;
            int rv = -12345;
            bool first = true;
            int start = -12345;
            for (int ii = i; ii < lineNewVersion.Length; ii++)
            {
                if (start == -12345 && lineNewVersion[ii] == ' ') continue;
                if (first) start = ii;
                if (first && !G.IsLetterOrUnderscore(lineNewVersion[ii]))
                {
                    return -12345;  //first letter is non-valid
                }
                if (!first && !G.IsLetterOrDigitOrUnderscore(lineNewVersion[ii]))
                {
                    ident = lineNewVersion.Substring(start, ii - start);
                    return ii;  //second+ letter is non-valid
                }
                first = false;
            }

            return rv;
        }

        private static int GetNextHash(string lineNewVersion, int i)
        {
            //-12345 if no hit, else the first position to read for next thing to read
            int rv = -12345;
            for (int ii = i; ii < lineNewVersion.Length; ii++)
            {
                if (lineNewVersion[ii] == ' ') continue;
                if (lineNewVersion[ii] == '#')
                {
                    return ii + 1;
                }
                return -12345;
            }
            return rv;
        }

        private static int GetNextEquals(string lineNewVersion, int i)
        {
            //-12345 if no hit, else the first position to read for next thing to read
            int rv = -12345;
            for (int ii = i; ii < lineNewVersion.Length; ii++)
            {
                if (lineNewVersion[ii] == ' ') continue;
                if (lineNewVersion[ii] == '=')
                {
                    return ii + 1;
                }
                return -12345;
            }
            return rv;
        }

        private static int GetNextEquals2(string lineNewVersion, int i)
        {
            for (int ii = i; ii < lineNewVersion.Length; ii++)
            {
                if (lineNewVersion[ii] != '=') continue;
                return ii + 1;
            }
            return -12345;
        }

        private static int GetNextComment(string lineNewVersion, int i)
        {
            //-12345 if no hit, else the last position without the comment
            //dows not require spaces
            int rv = -12345;
            for (int ii = i; ii < lineNewVersion.Length - 1; ii++)
            {
                if (lineNewVersion[ii] == '/' && (lineNewVersion[ii + 1] == '/' || lineNewVersion[ii + 1] == '*')) return ii - 1;
            }
            return rv;
        }

        private static bool IsCmdFileFound(string fileName)
        {
            bool found = false;
            List<string> folders = new List<string>();
            folders.Add(Program.options.folder_command);
            folders.Add(Program.options.folder_command1);
            folders.Add(Program.options.folder_command2);
            //The assumption is that this check is ok to do at parse time (not run time), since it is not realistic
            //to imagine .cmd files being created dynamically while the command files are running.
            fileName = FindFile(fileName, folders);  //calls CreateFullPathAndFileName()
            if (fileName != null) found = true;
            return found;
        }

        public static double Periods(string per1, string per2)
        {
            return 1;
        }

        private static void HandleCollapseData(Series ts, Series counter, double data, GekkoTime gt, ECollapseMethod method, ref GekkoTime gt_min, ref GekkoTime gt_max)
        {
            if (gt_min.IsNull()) gt_min = gt;
            else
            {
                if (gt.StrictlySmallerThan(gt_min)) gt_min = gt;
            }

            if (gt_max.IsNull()) gt_max = gt;
            else
            {
                if (gt.StrictlyLargerThan(gt_max)) gt_max = gt;
            }

            if (double.IsNaN(ts.GetDataSimple(gt)))
            {
                ts.SetData(gt, data);
            }
            else
            {
                if (method == ECollapseMethod.First)
                {
                    //skip it if something already there
                }
                else if (method == ECollapseMethod.Last)
                {
                    //overwrite (no summing) if something already there
                    ts.SetData(gt, data);
                }
                else
                {
                    ts.SetData(gt, ts.GetDataSimple(gt) + data);
                }
            }

            if (double.IsNaN(counter.GetDataSimple(gt)))
            {
                counter.SetData(gt, 1d);  //first one
            }
            else
            {
                counter.SetData(gt, counter.GetDataSimple(gt) + 1d); //add 1
            }

        }

        public static void CollapsePoints(O.Read o)
        {
            if (o.readTo != null)
            {
                G.Writeln2("*** ERROR: IMPORT<collapse=...> does not work with IMPORT ... TO ...");
                throw new GekkoException();
            }

            if (o.opt_ref != null)
            {
                G.Writeln2("*** ERROR: IMPORT<collapse=...> does not work with <ref>");
                throw new GekkoException();
            }

            if (o.opt_first != null)
            {
                G.Writeln2("*** ERROR: IMPORT<collapse=...> does not work with <first>");
                throw new GekkoException();
            }

            if (o.opt_merge != null)
            {
                G.Writeln2("*** ERROR: IMPORT<collapse=...> does not work with <merge>");
                throw new GekkoException();
            }

            if (o.opt_xls == null && o.opt_xlsx == null)
            {
                G.Writeln2("*** ERROR: IMPORT<collapse=...> should be used with xls- or xlsx-files");
                throw new GekkoException();
            }

            string x = "xlsx";
            if (o.opt_xls != null) x = "xls";

            ECollapseMethod emethod = ECollapseMethod.Total;
            if (G.Equal(o.opt_method, "avg")) emethod = ECollapseMethod.Avg;
            else if (G.Equal(o.opt_method, "first")) emethod = ECollapseMethod.First;
            else if (G.Equal(o.opt_method, "last")) emethod = ECollapseMethod.Last;
            else if (G.Equal(o.opt_method, "count")) emethod = ECollapseMethod.Count;

            EFreq freq = G.GetFreq(o.opt_collapse);

            bool isTranspose = false;
            if (G.Equal(o.opt_cols, "yes")) isTranspose = true;

            string fn = Program.CreateFullPathAndFileName(Program.AddExtension(o.fileName, "." + x));

            //string s = Program.GetTextFromFileWithWait(fileName_string);

            TableLight matrix = null;
            matrix = Program.ReadExcelWorkbook(fn, o.opt_sheet);
            G.Writeln2("Read " + matrix.GetRowMaxNumber() + "x" + matrix.GetColMaxNumber() + " matrix from file");
            if (isTranspose) matrix = matrix.Transpose();

            //Expects series to run row-wise (first col is names, first row is dates)

            CellOffset offset = new CellOffset();
            offset.cell = o.opt_cell;
            offset.namecell = o.opt_namecell;
            offset.datecell = o.opt_datecell;

            int i_data, j_data, i_names, j_names, i_dates, j_dates;
            HandleRectangularFileFormatCellOffset(offset, isTranspose, out i_data, out j_data, out i_names, out j_names, out i_dates, out j_dates);

            //expects dates to run i a row
            List<DateTime> dateList = new List<DateTime>();
            for (int j = j_dates; j <= matrix.GetColMaxNumber(); j++)
            {
                CellLight c = matrix.Get(i_dates, j);
                if (c.type == ECellLightType.Double)
                {
                    DateTime temp = DateTime.MinValue;
                    try
                    {
                        temp = GekkoTime.FromExcelDateToDateTime(c.data);
                    }
                    catch
                    {
                        G.Writeln2("*** ERROR: Cell " + Program.GetExcelCell(i_dates, j, isTranspose) + " does not seem to be a date");
                        throw new GekkoException();
                    }

                    if (temp.Year < 1500 || temp.Year > 2500)
                    {
                        G.Writeln2("*** ERROR: Cell " + Program.GetExcelCell(i_dates, j, isTranspose) + " does not seem to make sense (year = " + temp.Year + ")");
                        throw new GekkoException();
                    }
                    dateList.Add(temp);
                }
                else if (c.type == ECellLightType.DateTime)
                {
                    dateList.Add(c.dateTime);
                }
                else
                {
                    G.Writeln2("*** ERROR: Expected cell " + Program.GetExcelCell(i_dates, j, isTranspose) + " to be date format, is " + c.type.ToString() + ": '" + c.text + "'");
                    throw new GekkoException();
                }
            }

            List<string> nameList = new List<string>();
            for (int i = i_names; i <= matrix.GetRowMaxNumber(); i++)
            {
                CellLight c = matrix.Get(i, j_names);
                if (c.type != ECellLightType.String)
                {
                    G.Writeln2("*** ERROR: Expected cell " + Program.GetExcelCell(i, j_names, isTranspose) + " to be a string, is " + c.type.ToString());
                    throw new GekkoException();
                }
                string s = c.text;
                if (!G.IsSimpleToken(s))
                {
                    G.Writeln2("*** ERROR: Expected cell " + Program.GetExcelCell(i, j_names, isTranspose) + " to be a variable name, is '" + s + "'");
                    throw new GekkoException();
                }
                nameList.Add(s);
            }

            GekkoTime gt_min = GekkoTime.tNull;
            GekkoTime gt_max = GekkoTime.tNull;

            for (int i = i_data; i <= matrix.GetRowMaxNumber(); i++)
            {
                string varnameWithFreq = G.Chop_AddFreq(nameList[i - i_data], G.GetFreq(freq));
                Series ts = new Series(freq, varnameWithFreq);
                Series counter = new Series(freq, null);  //will be discared afterwards but practical here
                for (int j = j_data; j <= matrix.GetColMaxNumber(); j++)
                {
                    DateTime dt = dateList[j - j_data];
                    CellLight c = matrix.Get(i, j);
                    double v = Program.GetValueFromSpreadsheetCell(isTranspose, i, j, c);
                    int subPer = -12345;
                    GekkoTime gt5 = GekkoTime.FromDateTimeToGekkoTime(freq, dt);
                    int per = gt5.super;
                    subPer = gt5.sub;
                    GekkoTime gt = new GekkoTime(freq, per, subPer);
                    HandleCollapseData(ts, counter, v, gt, emethod, ref gt_min, ref gt_max);
                }

                if (emethod == ECollapseMethod.Avg)
                {
                    foreach (GekkoTime gt in new GekkoTimeIterator(ts.GetRealDataPeriodFirst(), ts.GetRealDataPeriodLast()))
                    {
                        if (!double.IsNaN(ts.GetDataSimple(gt)))
                        {
                            ts.SetData(gt, ts.GetDataSimple(gt) / counter.GetDataSimple(gt));
                        }
                    }
                }
                else if (emethod == ECollapseMethod.Count)
                {
                    foreach (GekkoTime gt in new GekkoTimeIterator(ts.GetRealDataPeriodFirst(), ts.GetRealDataPeriodLast()))
                    {
                        ts.SetData(gt, counter.GetDataSimple(gt));
                    }
                }

                if (!o.t1.IsNull())
                {
                    ts.Truncate(o.t1, o.t2);
                }

                //string nameWithFreq = Program.AddFreqAtEndOfVariableName(varnameWithFreq, freq);
                IVariable ts2a = null; Program.databanks.GetFirst().storage.TryGetValue(varnameWithFreq, out ts2a);
                Series ts2 = ts2a as Series;

                GekkoTime tt1 = ts.GetRealDataPeriodFirst();
                GekkoTime tt2 = ts.GetRealDataPeriodLast();
                if (!tt1.IsNull())
                {
                    //there is some data in ts
                    if (ts2 == null)
                    {
                        Program.databanks.GetFirst().AddIVariable(varnameWithFreq, ts);
                    }
                    else
                    {
                        foreach (GekkoTime gt in new GekkoTimeIterator(tt1, tt2))
                        {
                            ts2.SetData(gt, ts.GetDataSimple(gt));
                        }
                    }
                }
            }

            int vars = matrix.GetRowMaxNumber() - i_data + 1;
            int obs = matrix.GetColMaxNumber() - j_data + 1;
            G.Writeln("Imported " + vars + " timeseries from " + obs + " data points");
            G.Writeln("The collapsed series (" + G.GetFreqString(freq) + ") span the timeperiod " + gt_min.ToString() + " to " + gt_max.ToString());
        }

        private static void HandleRectangularFileFormatCellOffset(CellOffset o, bool isTranspose, out int i_data, out int j_data, out int i_names, out int j_names, out int i_dates, out int j_dates)
        {
            if (o.cell == null)
            {
                o.cell = "b2";
            }
            Program.FromXls1Based(o.cell, out i_data, out j_data, isTranspose);

            if (i_data < 2 || j_data < 2)
            {
                G.Writeln2("*** ERROR: <cell=...> has an illegal value (cannot be first row or column)");
                throw new GekkoException();
            }
            if (o.namecell == null)
            {
                i_names = i_data;
                j_names = j_data - 1;
            }
            else
            {
                Program.FromXls1Based(o.namecell, out i_names, out j_names, isTranspose);
            }
            if (o.datecell == null)
            {
                i_dates = i_data - 1;
                j_dates = j_data;
            }
            else
            {
                Program.FromXls1Based(o.datecell, out i_dates, out j_dates, isTranspose);
            }

            if (i_data != i_names)
            {
                G.Writeln2("*** ERROR: Positions " + o.namecell + " for names and " + o.cell + " for data do not correspond");
                throw new GekkoException();
            }

            if (j_data != j_dates)
            {
                G.Writeln2("*** ERROR: Positions " + o.datecell + " for names and " + o.cell + " for data do not correspond");
                throw new GekkoException();
            }
        }

        public static void FromXls(string s, out int rowOffset, out int colOffset, bool transpose)
        {
            //0-based
            int i_data, j_data; Program.FromXls1Based(s, out i_data, out j_data, transpose);
            rowOffset = i_data - 1;
            colOffset = j_data - 1;
        }

        public static void FromXls1Based(string s, out int rowOffset, out int colOffset, bool transpose)
        {
            int index = s.IndexOfAny(new char[] { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9' });
            string chars = s.Substring(0, index);
            int num = Int32.Parse(s.Substring(index));
            if (transpose)
            {
                rowOffset = ExcelColumnNameToNumber(chars);
                colOffset = num;
            }
            else
            {
                rowOffset = num;
                colOffset = ExcelColumnNameToNumber(chars);
            }
        }

        public static string GetTextFromFileWithWait(string filename)
        {
            //Encoding encoding = Encoding.Default;
            String original = String.Empty;

            filename = CreateFullPathAndFileName(filename);

            if (!File.Exists(filename))
            {
                G.Writeln2("*** ERROR: file '" + filename + "' does not exist");
                throw new GekkoException();
            }

            Encoding current = null;

            bool utf8checker = false;
            using (FileStream fs = WaitForFileStream(filename, GekkoFileReadOrWrite.Read))
            {
                utf8checker = Utf8Checker.IsUtf8(fs);  //NOTE: tastes the file: this may be slow on very large files. So avoid GetTextFromFileWithWait() on databank reading etc. //previously, sr.CurrentEncoding was used, but it is not precise enough to detect UTF8 without BOM mark at start (TextPad for instance)
                fs.Position = 0;  //to rewind
                Encoding encoding = Encoding.Default;
                if (utf8checker) encoding = Encoding.UTF8;
                using (System.IO.StreamReader sr = new System.IO.StreamReader(fs, encoding))
                {
                    original = sr.ReadToEnd();
                    current = sr.CurrentEncoding;
                    sr.Close();
                }
            }

            string s = null;

            if (utf8checker)
            {
                s = original;
            }
            else
            {
                //Convert bytes from ANSI to UTF8
                byte[] encBytes = current.GetBytes(original);  //'current' will always be equal to 'encoding' I guess, but just for safety
                byte[] utf8Bytes = Encoding.Convert(current, Encoding.UTF8, encBytes);
                s = Encoding.UTF8.GetString(utf8Bytes);
            }

            s = s.Replace(Convert.ToChar(160).ToString(), " ");  //non-breaking space
            s = s.Replace(Convert.ToChar(173).ToString(), "");  //soft hyphen

            //the code below is probably too dangerous: what about newlines etc.??
            //s = Regex.Replace(s, @"[^\u0000-\u001F]+", string.Empty);  //see http://stackoverflow.com/questions/123336/how-can-you-strip-non-ascii-characters-from-a-string-in-c, here we use 0-1F, that is: 0-31

            return s;
        }


        public static void AdjustFreq()
        {
            //hash #980432

            //========================================================================================================
            //                          FREQUENCY LOCATION, indicates where to implement more frequencies
            //========================================================================================================

            Tuple<GekkoTime, GekkoTime> freqs = ConvertFreqs(Globals.globalPeriodStart, Globals.globalPeriodEnd, Program.options.freq);

            if (Program.options.freq == EFreq.A)
            {
                G.Writeln("Freq changed to annual (A)");
                Globals.globalPeriodStart = freqs.Item1;
                Globals.globalPeriodEnd = freqs.Item2;                
            }
            else if (Program.options.freq == EFreq.Q)
            {
                G.Writeln("Freq changed to quarterly (Q) -- note that start/end quarters have been translated from " + Globals.globalPeriodStart.freq.ToString() + " freq");
                Globals.globalPeriodStart = freqs.Item1;
                Globals.globalPeriodEnd = freqs.Item2;                
            }
            else if (Program.options.freq == EFreq.M)
            {
                G.Writeln("Freq changed to monthly (M) -- note that start/end months have been translated from " + Globals.globalPeriodStart.freq.ToString() + " freq");
                Globals.globalPeriodStart = freqs.Item1;
                Globals.globalPeriodEnd = freqs.Item2;                
            }
            else if (Program.options.freq == EFreq.D)
            {
                G.Writeln("Freq changed to daily (D) -- note that start/end months have been translated from " + Globals.globalPeriodStart.freq.ToString() + " freq");
                Globals.globalPeriodStart = freqs.Item1;
                Globals.globalPeriodEnd = freqs.Item2;
            }
            else if (Program.options.freq == EFreq.U)
            {

                G.Writeln("Frequency changed to undated (U)");
                Globals.globalPeriodStart = new GekkoTime(EFreq.U, Globals.globalPeriodStart.super, 1);
                Globals.globalPeriodEnd = new GekkoTime(EFreq.U, Globals.globalPeriodEnd.super, 1);                
            }                      

        }

        public static string GetSHA256Hash(string modelText)
        {
            System.Text.UTF8Encoding encoding = new System.Text.UTF8Encoding();
            byte[] modelTextInBytes = encoding.GetBytes(modelText);
            byte[] result;
            using (SHA256 shaM = new SHA256Managed())
            {
                result = shaM.ComputeHash(modelTextInBytes);
            }
            string hashValue = Convert.ToBase64String(result);
            return hashValue;
        }

        public static string GetSHA256HashFromStream(Stream stream)
        {
            byte[] result;
            using (SHA256 shaM = new SHA256Managed())
            {
                result = shaM.ComputeHash(stream);
            }
            string hashValue = Convert.ToBase64String(result);
            return hashValue;
        }

        public static string GetMD5Hash(string input)
        {
            // step 1, calculate MD5 hash from input
            MD5 md5 = System.Security.Cryptography.MD5.Create();
            byte[] inputBytes = System.Text.Encoding.UTF8.GetBytes(input);  //UTF8 seems best choice
            byte[] hash = md5.ComputeHash(inputBytes);
            // step 2, convert byte array to hex string
            StringBuilder sb = new StringBuilder();
            string s = Convert.ToBase64String(hash).Replace("=", "").Replace("+", "a").Replace("/", "b");
            //We remove empty indicator (=), and replace the two non-alphanumeric as well for simplicity.
            //a Bas64-encoding can put 6 bits in each symbol, so that 128 bits become 23 symbols.
            //This is a little better than hex (32 symbols).
            return s;
        }

        public static void Run(O.Run o)
        {
            bool cancel = false;
            string fileName = o.fileName;
            if (fileName == "*")
            {
                Program.SelectFile(Globals.extensionCommand, ref fileName, ref cancel);
            }
            if (cancel) return;
            RunHelper(o);
        }        

        public static void Ini(P p)
        {
            string s = "gekko.ini";
                       
            List<string> folders = new List<string>();
            folders.Add(G.GetProgramDir());
            string fileName2 = FindFile(s, folders, false);  //also calls CreateFullPathAndFileName()
            if (fileName2 == null)
            {
                G.Writeln2("No INI file '" + Globals.autoExecCmdFileName + "' found in program folder");
            }
            else
            {
                Globals.cmdPathAndFileName = fileName2;  //always contains a path, is used if there is a lexer error
                Globals.cmdFileName = Path.GetFileName(Globals.cmdPathAndFileName);
                Program.EmitCodeFromANTLR("", fileName2, false, 0, p);
                G.Writeln();
                G.Writeln("Finished running INI file ('" + Path.GetFileName(Globals.cmdPathAndFileName) + "') from program folder");
            }

            folders = new List<string>();
            folders.Add(Program.options.folder_command);
            folders.Add(Program.options.folder_command1);
            folders.Add(Program.options.folder_command2);
            fileName2 = FindFile(s, folders, true);  //also calls CreateFullPathAndFileName()
            if (fileName2 == null)
            {
                G.Writeln2("No INI file '" + Globals.autoExecCmdFileName + "' found in working folder");
                return;  //used for gekko.ini file
            }
            else
            {
                Globals.cmdPathAndFileName = fileName2;  //always contains a path, is used if there is a lexer error
                Globals.cmdFileName = Path.GetFileName(Globals.cmdPathAndFileName);
                Program.EmitCodeFromANTLR("", fileName2, false, 0, p);
                G.Writeln();
                G.Writeln("Finished running INI file ('" + Path.GetFileName(Globals.cmdPathAndFileName) + "') from working folder");
            }
        }

        public static void RunHelper(O.Run o)
        {
            string s = o.fileName;
            s = G.StripQuotes(s);            
            s = Program.AddExtension(s, "." + Globals.extensionCommand);            
            
            List<string> folders = new List<string>();
            folders.Add(Program.options.folder_command);
            folders.Add(Program.options.folder_command1);
            folders.Add(Program.options.folder_command2);

            string fileName2 = FindFile(s, folders);  //also calls CreateFullPathAndFileName()

            if (fileName2 == null)
            {
                //calling RUN gekko.ini here manually will fail if the file does not exist, which is fine
                G.Writeln2("*** ERROR: Could not find file: " + s);                
                throw new GekkoException();
            }
            
            Program.EmitCodeFromANTLR("", fileName2, false, (int)o.opt_skip, o.p);

            if (G.Equal(s, Globals.autoExecCmdFileName))
            {
                G.Writeln();
                G.Writeln("Finished running INI file ('" + Path.GetFileName(Globals.cmdPathAndFileName) + "') from working folder");
            }
            //G.Writeln("Finished adding file: " + s);
        }

        public static string CreateFullPathAndFileName(string s)
        {
            return CreateFullPathAndFileNameFromFolder(s, null);
        }        

        public static string CreateFullPathAndFileNameFromFolder(string file, string path)
        {            
            //This method can be called with path = null or path = "", in that case it reduces to
            //only adding the working folder is file is without colon.
            //Path is given from options: "option folder bank = ..." for instance
            //String is user input.
            //RULES:
            //If file includes colon
            //   return = file
            //else
            //   if path includes colon
            //      return = path + file
            //   else
            //      return working_folder + path + file
            //   end
            //end
            //
            //    +++           If path = null or path = "", the above reduces to this:
            //    +++           If file includes colon
            //    +++              return = file
            //    +++           else
            //    +++              return working_folder + "" + file (i.e. working_folder + file)
            //    +++           end
            //
            if (path == null) path = "";
            if (file == null)
            {
                G.Writeln2("*** ERROR: Expected a file name, but it is not defined");
                throw new GekkoException();
            }
            file = file.Trim(); //Most probably not necessary, but better safe than sorry
            path = path.Trim(); //Most probably not necessary, but better safe than sorry
            string fileName2 = "";
            if (file.Contains(":\\"))
            {
                fileName2 = file;
            }
            else
            {
                if (path.Contains(":\\"))
                {
                    fileName2 = path + "\\" + file;
                }
                else
                {
                    fileName2 = Program.options.folder_working + "\\" + path + "\\" + file;  //path may be = "", and workingFolder may end with "\\", and file may start with "\\" --> 4 successive "\\" to be reduced later on
                }
            }

            while (true)
            {
                int count = fileName2.Length;
                fileName2 = fileName2.Replace("\\\\", "\\");
                if (count == fileName2.Length) break;  //keeps on going until nothing more to substitute
            }

            string rv = O.ResolvePath(fileName2);

            return rv;  //see https://stackoverflow.com/questions/970911/net-remove-dots-from-the-path
        }
        
        public static void Disp(GekkoTime tStart, GekkoTime tEnd, List<string> list, O.Disp o)
        {
            Disp(tStart, tEnd, list, false, false, false, o);
        }

        public static void DispSearch(string s)
        {
            Databank db = Program.databanks.GetFirst();
                        
            int widthRemember = Program.options.print_width;
            int fileWidthRemember = Program.options.print_filewidth;
            Program.options.print_width = int.MaxValue;
            Program.options.print_filewidth = int.MaxValue;
            try
            {
                s = G.StripQuotes(s);

                List<string> vars = new List<string>();
                List<string> expl = new List<string>();
                //List<string> both = new List<string>();
                GekkoDictionary<string, string> both2 = new GekkoDictionary<string, string>(StringComparer.OrdinalIgnoreCase);

                //bool differentFreq = false;

                if (Program.unfoldedVariableList != null && Program.unfoldedVariableList.Count > 0)
                {
                    List<string> explanation = new List<string>();
                    if (Program.unfoldedVariableList == null) return;

                    foreach (Program.Item item in Program.unfoldedVariableList)
                    {
                        string ss = "";
                        if (item.explanation.Count > 0) ss = item.explanation[0];
                        if (G.Contains(ss, s))
                        {
                            if (!both2.ContainsKey(item.variable)) both2.Add(item.variable, ss);
                        }
                    }
                }

                if (true)
                {
                    //try variable labels
                    foreach (IVariable iv in db.storage.Values)
                    {
                        Series ts = iv as Series;
                        if (ts == null) continue;                        
                        if (Program.options.freq != ts.freq) continue;
                        string label = ts?.meta.label;
                        if (label == null) continue;
                        if (G.Contains(label, s))
                        {                            
                            string s3 = G.Chop_RemoveFreq(ts.name);                            
                            if (!both2.ContainsKey(s3)) both2.Add(s3, label);
                        }
                    }
                }

                int max = 0;
                foreach (string k in both2.Keys)
                {
                    max = Math.Max(max, k.Length);
                }
                max = Math.Max(max, "Variable".Length);

                int max2 = 0;
                foreach (string k in both2.Values)
                {
                    max2 = Math.Max(max2, k.Length);
                }

                List<string> lines = new List<string>();
                foreach (KeyValuePair<string, string> kvp in both2)
                {
                    lines.Add(kvp.Key + "¤" + kvp.Value);
                }
                lines.Sort(StringComparer.OrdinalIgnoreCase);

                if (lines.Count > 0)
                {
                    string w = "Variable" + G.Blanks(max - "Variable".Length + 2) + "Label";
                    string w2 = new string('-', max + max2 + 2);
                    G.Writeln();
                    G.Writeln(w);
                    G.Writeln(w2);

                    foreach (string xx in lines)
                    {
                        if (Globals.threadIsInProcessOfAborting) throw new GekkoException();
                        string[] xxx = xx.Split('¤');
                        G.WriteLink(xxx[0], "disp:" + xxx[0]);
                        G.Write(G.Blanks(max - xxx[0].Length + 2));
                        G.Writeln(xxx[1]);
                    }
                    G.Writeln(w2);
                    G.Writeln();
                }
                else
                {
                    G.Writeln2("The string '" + s + "' did not match any variable labels");
                }
            }
            finally
            {
                //resetting, also if there is an error
                Program.options.print_width = widthRemember;
                Program.options.print_filewidth = fileWidthRemember;
            }

            return;
        }

        public static int CompareMapMultidimItems(MapMultidimItem left, MapMultidimItem right)
        {
            if (left.storage.Length != right.storage.Length)
            {
                G.Writeln2("*** ERROR: #9843298473");
                throw new GekkoException();
            }
            for (int i = 0; i < left.storage.Length; i++)
            {
                string sleft = left.storage[i];
                string sright = right.storage[i];
                int ii = G.CompareNatural(sleft, sright, CultureInfo.InvariantCulture, CompareOptions.IgnoreCase);
                if (ii != 0) return ii;
            }
            return 0;
        }

        public static void UnfoldLists(IVariable iv, List<IVariable> m)
        {
            //Recursive list unfolding
            List mm = iv as List;
            if (mm != null)
            {
                foreach (IVariable iv2 in mm.list)
                {
                    UnfoldLists(iv2, m);                    
                }
            }
            else m.Add(iv);
        }


        public static void Disp(GekkoTime tStart, GekkoTime tEnd, List<string> list, bool showDetailed, bool showAllPeriods, bool clickedLink, O.Disp o)
        {
            EVariableType type = EVariableType.Series;            
            int nonSeries = 0;

            GekkoSmpl smpl = new GekkoSmpl(tStart, tEnd);
            //if (o != null && G.Equal(o.opt_info, "yes"))
            //{
            //    Info(tStart, tEnd, list);
            //    return;
            //}

            Globals.dispLastDispStart = tStart; //kept if user chooses to click a link -- in that case we want to use same time settings
            Globals.dispLastDispEnd = tEnd; //kept if user chooses to click a link

            int seriesCounter = 0;

            List<string> names = null;

            List<IVariable> m = new List<IVariable>();
            if (list != null)
            {
                //seems list is always null when called from command
                foreach (string listItem in list)
                {
                    IVariable x = O.GetIVariableFromString(listItem, O.ECreatePossibilities.NoneReportError, true);
                    m.Add(x);
                }
            }
            else
            {

                names = Program.Search(o.iv, null, EVariableType.Var);
                
                foreach(string s in names)
                {
                    m.Add(O.GetIVariableFromString(s, O.ECreatePossibilities.NoneReportError, true));
                }

            }
                        
            for (int i5 = 0;i5<m.Count;i5++)
            {

                IVariable x = m[i5];
                string name = null;
                if (names != null) name = names[i5];
                else name = list[i5];

                //one listitem could be obk:fx*, fy, #m, obk:#m, @fy
                
                //IVariable x = O.Lookup(smpl, null, new ScalarString(listItem), null, false, EVariableType.Var);

                Series ts = x as Series;

                if (ts == null)
                {                    
                    PrintNonSeries(x, null, 0);
                    nonSeries++;
                    continue;
                }
                else
                {

                    seriesCounter++;

                    string var = null;
                    string bank = null;
                    if (name == null)
                    {
                        var = ts.GetName();
                        bank = ts.GetParentDatabank().name;
                    }
                    else
                    {
                        var = name;
                        bank = ts.GetParentDatabank().name;
                    }

                    string varnameWithoutFreq = G.Chop_RemoveFreq(var);

                    if (G.Equal(Program.options.model_type, "gams"))
                    {
                        DispGams(tStart, tEnd, showDetailed, showAllPeriods, clickedLink, true, ts, var, bank, varnameWithoutFreq);
                    }
                    else
                    {
                        DispNonGams(tStart, tEnd, showDetailed, showAllPeriods, clickedLink, ts, bank, varnameWithoutFreq);
                    }
                }                
            }

            if (seriesCounter + nonSeries == 0)
            {
                G.Writeln2("Did not find any variable(s) to display");
            }
            else if (seriesCounter == 0 && nonSeries > 0)
            {
                //nomessage
            }
            else
            {
                if (seriesCounter + nonSeries > 1)
                {
                    G.Writeln2("Displayed " + (seriesCounter + nonSeries) + " variables");
                }

            }
            
        }

        private static void DispNonGams(GekkoTime tStart, GekkoTime tEnd, bool showDetailed, bool showAllPeriods, bool clickedLink, Series ts, string bank, string varnameWithoutFreq)
        {
            //ADAM-style, normal timeseries

            string note = null;

            bool isTimeless = ts.type == ESeriesType.Timeless;

            G.Writeln();
            G.Writeln("==========================================================================================");
            G.Writeln("SERIES " + bank + Globals.symbolBankColon + " " + ts.GetNameWithoutCurrentFreq(true));
            if (true)
            {
                EEndoOrExo type1 = VariableTypeEndoExo(varnameWithoutFreq);
                string type3 = "";
                if (type1 == EEndoOrExo.Exo) type3 = "Exogenous, ";
                else if (type1 == EEndoOrExo.Endo) type3 = "Endogenous, ";

                string freq = "[unknown frequency]";

                freq = G.GetFreqString(ts.freq);

                bool noData = ts.IsNullPeriod(); //We are opening up to this possibility of 'empty' data                    

                //GekkoTime first = ts.GetPeriodFirst();
                //GekkoTime last = ts.GetPeriodLast();

                GekkoTime first = ts.GetRealDataPeriodFirst();
                GekkoTime last = ts.GetRealDataPeriodLast();

                G.Write(type3);
                string stamp = null;
                if (ts.meta.stamp != null && ts.meta.stamp != "") stamp = " (updated: " + ts.meta.stamp + ")";
                if (ts.freq == EFreq.A || ts.freq == EFreq.U)
                {
                    if (noData || first.super == -12345 || last.super == -12345)
                    {
                        G.Writeln(freq + ", no data period");
                    }
                    else
                    {
                        //we don't want 1995a1 to 2005a1, instead 1995 to 2005
                        G.Writeln(freq + " data from " + first.super + " to " + last.super + stamp);
                    }
                }
                else
                {
                    if (noData || first.super == -12345 || last.super == -12345)
                    {
                        G.Writeln(freq + ", no data period");
                    }
                    else
                    {
                        G.Writeln(freq + " data from " + first.ToString() + " to " + last.ToString() + stamp);
                    }
                }

                


                List<string> expls = Program.GetVariableExplanationNEW(varnameWithoutFreq, false, false, GekkoTime.tNull, GekkoTime.tNull);
                foreach (string expl in expls) G.Writeln(expl);

                bool eqsPrinted = false;
                List<MapMultidimItem> keys = null;
                GekkoDictionary<string, string>[] temp = null;
                if (ts.type == ESeriesType.ArraySuper)
                {
                    keys = ts.dimensionsStorage.storage.Keys.ToList();
                    keys.Sort(CompareMapMultidimItems);
                    temp = new GekkoDictionary<string, string>[ts.dimensions];
                }                

                if (!G.IsUnitTesting()) Gui.gui.GuiBrowseArrowsStuff(varnameWithoutFreq, clickedLink, 0);

                if (G.HasModelGekko())
                {
                    DispHelperShowNormalEquation(showDetailed, varnameWithoutFreq);
                }
                else
                {
                    if (Program.model.modelGams?.equationsByVarname != null)
                    {
                        note = "+++ NOTE: There is a GAMS model loaded, perhaps you should use 'OPTION model type = gams;'?";
                    }
                }

                if (ts.dimensions > 0)
                {
                    DispHelperArraySeries(ts, keys, temp, eqsPrinted);
                }
                else
                {
                    DispHelperNormalSeries(tStart, tEnd, showAllPeriods, ts, varnameWithoutFreq, isTimeless);
                }                

                G.Writeln("==========================================================================================");
                if (note != null) G.Writeln(note);


            }
        }

        private static void DispHelperShowNormalEquation(bool showDetailed, string varnameWithoutFreq)
        {
            List<string> d4 = new List<string>();
            if (Program.model?.modelGekko?.dependents !=null && Program.model.modelGekko.dependents.ContainsKey(varnameWithoutFreq))
            {
                Dictionary<string, string> d2 = Program.model.modelGekko.dependents[varnameWithoutFreq].storage;
                if (d2 != null)
                {
                    foreach (string d3 in d2.Keys)
                    {
                        d4.Add(d3);
                    }
                }
                d4.Sort(StringComparer.InvariantCulture);
            }

            EquationHelper found = Program.FindEquationByMeansOfVariableName(varnameWithoutFreq);

            if (found != null && found.modelBlock != null && found.modelBlock != "" && found.modelBlock != "Unnamed")
            {
                G.Writeln("Modelblock: " + found.modelBlock);
            }

            G.Write("Influences: ");
            if (d4.Count == 0) G.Writeln("<none>");
            else
            {
                G.PrintListWithCommas(d4, true);
            }

            G.Writeln("------------------------------------------------------------------------------------------");

            if (found != null)
            {
                int widthRemember = Program.options.print_width;
                int fileWidthRemember = Program.options.print_filewidth;
                Program.options.print_width = int.MaxValue;
                Program.options.print_filewidth = int.MaxValue;
                try
                {
                    //check for endo (but really not necessary, exo just does not exist)
                    //G.Writeln(found.equationFormula);
                    string strSplit = found.equationText;
                    strSplit = strSplit.Replace("\r\n", "£");  //hack: £ unlikely to be used much
                    char[] arrDelimiters = new char[] { ' ', '(', ')', '=', '+', '-', '*', '/', ',', ';', '$', '£' };  //last one is part of new line (\r\n)
                    List<string> alWork = Program.SplitStringAndKeepDelimiters(strSplit, arrDelimiters);
                    foreach (string s in alWork)
                    {
                        if (s == "£") G.Writeln();
                        else
                        {
                            if (Program.model.modelGekko.varsAType.ContainsKey(s))
                            {
                                //seems the word exists as variable
                                G.WriteLink(s, "disp:" + s);
                            }
                            else
                            {
                                G.Write(s);
                            }
                        }
                    }
                    G.Writeln();
                }
                finally
                {
                    //resetting, also if there is an error
                    Program.options.print_width = widthRemember;
                    Program.options.print_filewidth = fileWidthRemember;
                }

                G.Writeln("------------------------------------------------------------------------------------------");
                string rhs = found.csCodeRhsHumanVersion;
                rhs = rhs.Replace("\r\n", "");
                //rhs = rhs.Replace("[", "(");
                //rhs = rhs.Replace("]", ")");
                rhs = rhs.Replace("[0]", "");

                if (showDetailed)
                {
                    G.Writeln(found.csCodeLhsHuman + " = " + rhs + " " + ";");
                }
                else
                {
                    G.WriteLink("Show detailed equation", "disp2:" + varnameWithoutFreq);
                    G.Writeln();
                }
            }
        }

        private static void DispGams(GekkoTime tStart, GekkoTime tEnd, bool showDetailed, bool showAllPeriods, bool clickedLink, bool gamsToGekko, Series ts, string var, string bank, string varnameWithoutFreq)
        {
            string note = null;

            string s2 = "[" + G.GetListWithCommas(ts.meta.domains) + "]";
            if (s2 == "[]") s2 = null;

            bool isTimeless = ts.type == ESeriesType.Timeless;

            string ss = "SERIES";
            if (ts.type == ESeriesType.ArraySuper) ss = "ARRAY-SERIES";
            G.Writeln2("==========================================================================================");
            G.Writeln(ss + " " + bank + Globals.symbolBankColon + " " + varnameWithoutFreq + s2);

            List<string> expls = Program.GetVariableExplanationNEW(varnameWithoutFreq, false, false, GekkoTime.tNull, GekkoTime.tNull);
            foreach (string expl in expls) G.Writeln(expl);

            //if (!G.NullOrBlanks(ts.meta.label)) G.Writeln(ts.meta.label);

            if (ts.type == ESeriesType.ArraySuper)
            {

            }
            else
            {
                if (ts.mmi != null)
                {
                    //then it is a sub-series
                    Series parent = ts.mmi.parent;
                    if (parent != null)
                    {
                        //if (!G.NullOrBlanks(parent.meta.label)) G.Writeln(parent.meta.label);
                        if (parent.meta.fix == EFixedType.Parameter)
                        {
                            G.Writeln("Fixed (parameter)");
                        }
                    }
                }

                if (isTimeless)
                {
                    if (ts.meta.fix == EFixedType.Timeless)
                    {
                        G.Writeln("Fixed: " + Globals.fixedTimelessText);
                    }
                }
                else
                {
                    if (ts.meta.fix == EFixedType.Normal)
                    {
                        string s = ts.meta.fixedNormal.ToString();  //fixedNormal does exist if EFixedType.Normal
                        G.Writeln("Fixed: " + s);
                    }
                }
            }            

            List<MapMultidimItem> keys = null;
            GekkoDictionary<string, string>[] temp = null;

            if (ts.type == ESeriesType.ArraySuper)
            {
                keys = ts.dimensionsStorage.storage.Keys.ToList();
                keys.Sort(CompareMapMultidimItems);
                temp = new GekkoDictionary<string, string>[ts.dimensions];
            }

            bool eqsPrinted = false;

            if (Program.model.modelGams != null)
            {
                if (Program.model.modelGams.equationsByVarname != null)
                {
                    eqsPrinted = DispHelperShowGamsEquations(showDetailed, clickedLink, gamsToGekko, var, varnameWithoutFreq, eqsPrinted);
                }
            }
            else
            {
                if (Program.model?.modelGekko?.equations != null)
                {
                    note = "+++ NOTE: There is a normal model loaded, perhaps you should use 'OPTION model type = default;'?";
                }
            }

            if (ts.dimensions > 0)
            {
                DispHelperArraySeries(ts, keys, temp, eqsPrinted);
            }
            else
            {
                DispHelperNormalSeries(tStart, tEnd, showAllPeriods, ts, varnameWithoutFreq, isTimeless);
            }

            G.Writeln("==========================================================================================");

            if (note != null) G.Writeln(note);
        }

        public static bool HasGamsEquation(string var)
        {
            if (var == null) return false;
            return Program.model.modelGams?.equationsByVarname != null && Program.model.modelGams.equationsByVarname.ContainsKey(var);
        }

        private static bool DispHelperShowGamsEquations(bool showDetailed, bool clickedLink, bool gamsToGekko, string var, string varnameWithoutFreq, bool eqsPrinted)
        {
            string varnameWithoutFreqAndIndex = G.Chop_RemoveIndex(varnameWithoutFreq);

            GekkoDictionary<string, string> dependents = new GekkoDictionary<string, string>(StringComparer.OrdinalIgnoreCase);
            foreach (KeyValuePair<string, List<ModelGamsEquation>> e4 in Program.model.modelGams.equationsByVarname)
            {
                foreach (ModelGamsEquation e5 in e4.Value)
                {
                    GekkoDictionary<string, string> knownVars2 = GetKnownVars(e5.rhsGams);
                    if (knownVars2.ContainsKey(varnameWithoutFreqAndIndex) && !dependents.ContainsKey(e4.Key))
                    {
                        dependents.Add(e4.Key, null);
                    }
                }
            }            

            List<string> precedents2 = new List<string>();
            precedents2.AddRange(dependents.Keys);
            precedents2.Sort();

            if (precedents2.Count > 0)
            {
                G.Write("Variable " + varnameWithoutFreqAndIndex + " influences: ");
                int counter = -1;
                foreach (string s in precedents2)
                {
                    counter++;
                    if (counter > 0)
                    {
                        G.Write(", ");
                    }
                    G.WriteLink(s, "disp:" + s);
                }
                G.Writeln();
            }

            //List<ModelGamsEquation> eqs = null; Program.modelGams.equations.TryGetValue(varnameWithoutFreqAndIndex, out eqs);
            List<ModelGamsEquation> eqs = GamsModel.GetGamsEquationsByVarname(varnameWithoutFreqAndIndex);


            if (G.IsUnitTesting())
            {
                Globals.unitTestDependents = new List<string>();
                if (eqs != null)
                {
                    foreach (ModelGamsEquation eq in eqs)
                    {
                        Globals.unitTestDependents.Add(eq.nameGams);
                    }
                }
            }

            if (eqs != null && eqs.Count > 0)
            {
                if (G.Chop_HasIndex(varnameWithoutFreq) && eqs.Count > 1)
                {
                    G.Writeln("+++ NOTE: Some of the following equations may relate to other elements of " + varnameWithoutFreqAndIndex + " than " + varnameWithoutFreq);
                }

                PrintEquationWithLinks(gamsToGekko, varnameWithoutFreqAndIndex, eqs, showDetailed);
                eqsPrinted = true;

                if (!showDetailed)
                {
                    G.Writeln();
                    G.WriteLink("Show GAMS equation" + G.S(eqs.Count), "disp2:" + var);
                    G.Writeln();
                }
            }

            if (!G.IsUnitTesting()) Gui.gui.GuiBrowseArrowsStuff(varnameWithoutFreqAndIndex, clickedLink, 0);
            return eqsPrinted;
        }

        private static void DispHelperArraySeries(Series ts, List<MapMultidimItem> keys, GekkoDictionary<string, string>[] temp, bool eqsPrinted)
        {
            // --------------
            // Array-series
            // --------------

            GekkoTime t1 = GekkoTime.tNull;
            GekkoTime t2 = GekkoTime.tNull;

            foreach (IVariable iv in ts.dimensionsStorage.storage.Values)
            {
                Series ts2 = iv as Series;
                if (ts == null || ts.freq != ts2.freq) continue;
                GekkoTime tt1 = ts2.GetRealDataPeriodFirst();
                GekkoTime tt2 = ts2.GetRealDataPeriodLast();
                if (tt1.StrictlySmallerThan(t1)) t1 = tt1;
                if (tt2.StrictlyLargerThan(t2)) t2 = tt2;
            }

            string period = null;
            if (t1.IsNull() || t2.IsNull())
            {
                //skip period
            }
            else
            {
                period = " (period " + t1.ToString() + " - " + t2.ToString() + ")";
            }

            if (eqsPrinted) G.Writeln("");

            G.Writeln(G.GetFreqString(ts.freq) + " series has " + keys.Count + " elements in " + ts.dimensions + " dimensions" + period);

            double dimCount2 = 1d;
            string dimCount = null;
            for (int i = 0; i < ts.dimensions; i++)
            {
                string domain = null;
                try
                {
                    domain = ts.meta.domains[i];  //can fail in different ways, easiest with try-catch
                }
                catch { };
                if (domain == "*") domain = null;
                if (domain != null) domain = domain + ", ";
                temp[i] = new GekkoDictionary<string, string>(StringComparer.OrdinalIgnoreCase);
                int ii = 0;
                foreach (MapMultidimItem key in keys)
                {
                    if (!temp[i].ContainsKey(key.storage[i])) temp[i].Add(key.storage[i], null);
                    ii++;
                }
                List<string> temp2 = temp[i].Keys.ToList();
                temp2.Sort(G.CompareNaturalIgnoreCase);
                dimCount2 = dimCount2 * temp[i].Count;
                dimCount += temp2.Count + " * ";
                if (temp[i].Count > 0)
                {
                    G.Writeln("Dimension " + (i + 1) + " (" + domain + temp[i].Count + " members): " + G.GetListWithCommas(temp2));
                }
            }
            dimCount = dimCount.Substring(0, dimCount.Length - " * ".Length);

            if (keys == null || keys.Count == 0)
            {
                //do nothing
            }
            else
            {
                MapMultidimItem mm = keys[0];
                string first = keys[0].ToString();
                string last = keys[keys.Count - 1].ToString();

                G.Writeln("First/last elements (alphabetically): " + G.Chop_RemoveFreq(ts.name) + "[" + first + "]" + " ... " + G.Chop_RemoveFreq(ts.name) + "[" + last + "]");
                if (ts.dimensions > 1)
                {
                    G.Writeln("Dimension span: " + dimCount + " = " + dimCount2 + ", density: " + keys.Count + "/" + dimCount2 + " = " + Program.NumberFormat(100d * (keys.Count / dimCount2), "0.00") + "%");
                }

                int countFix = 0;
                foreach (KeyValuePair<MapMultidimItem, IVariable> kvp in ts.dimensionsStorage.storage)
                {
                    Series sub = kvp.Value as Series;
                    if (sub.meta.fix == EFixedType.Timeless || sub.meta.fix == EFixedType.Normal) countFix++;
                }
                if (countFix > 0)
                {
                    string name = ts.GetName();
                    G.Write("Fixed: " + countFix + " out of " + ts.dimensionsStorage.storage.Count + " elements (");
                    G.WriteLink("more", "dispfix:" + name);
                    G.Writeln(")");
                }
                if (ts.meta.fix == EFixedType.Parameter)
                {
                    G.Writeln("Fixed (parameter)");
                }


            }
        }

        private static void DispHelperNormalSeries(GekkoTime tStart, GekkoTime tEnd, bool showAllPeriods, Series ts, string varnameWithoutFreq, bool isTimeless)
        {
            // --------------
            // Normal series (possibly timeless)
            // --------------

            bool hasFilter = false; if (Program.options.timefilter && Globals.globalPeriodTimeFilters2.Count > 0) hasFilter = true;

            int max = Program.options.print_disp_maxlines;
            if (hasFilter || Program.options.print_disp_maxlines == -1) max = int.MaxValue;

            if (max > 0)
            {

                if (isTimeless)
                {
                    G.Writeln("------------------------------------------------------------------------------------------");
                    G.Writeln("Value = " + G.levelFormatOld(ts.GetTimelessData()) + " (timeless)");
                    //G.Writeln("------------------------------------------------------------------------------------------");
                }
                else
                {

                    G.Writeln("------------------------------------------------------------------------------------------");
                    G.Writeln("Period        value        %");

                    int counter = 0;

                    //must be able to handle TIME where freq does not match the series freq
                    foreach (GekkoTime gt in new GekkoTimeIterator(ConvertFreqs(tStart, tEnd, ts.freq)))                    
                    {
                        counter++;
                        if (hasFilter)  //some periods are set via TIMEFILTER
                        {
                            //if some filter is set, we never truncate output to 3 or 5 lines (showAllPeriods)
                            if (ShouldFilterPeriod(gt)) continue;
                        }
                        else
                        {
                            if (!showAllPeriods && counter > max)
                            {
                                continue;
                            }
                        }

                        G.Write(gt.ToString() + " ");
                        //if (Program.options.freq == EFreq.A) G.Write((gt.super) + " ");
                        //else G.Write(gt.super + G.GetFreq(ts.freq) + gt.sub + " ");

                        double n1 = ts.GetDataSimple(gt);
                        double n0 = ts.GetDataSimple(gt.Add(-1));

                        double level1 = n1;
                        double pch1 = ((n1 / n0 - 1) * 100d);

                        if (n1 == n0) pch1 = 0d;

                        string levelFormatted;
                        string pchFormatted;
                        Program.ConvertToPrintFormat(level1, pch1, out levelFormatted, out pchFormatted);

                        G.Write(levelFormatted + " " + pchFormatted + " ");
                        G.Writeln();
                    }
                    int surplus = counter - max;
                    if (!showAllPeriods && surplus > 0)
                    {
                        G.Writeln("------------------------------------------------------------------------------------------");
                        string ps = "period";
                        if (surplus > 1) ps = "periods";

                        if (false)
                        {
                            G.Write(surplus + " " + ps + " hidden (");                            
                            G.WriteLink("show", "disp3:" + varnameWithoutFreq);
                            G.Writeln(")");
                        }
                        else
                        {
                            //G.WriteLink("show", "disp3:" + ts.GetName());
                            // ---------                
                            Action a = () =>
                            {                                
                                Globals.guiHomeMainEnabled = true;                                
                                List<string> temp = new List<string>();                                
                                string varnameWithBankAndFreq = ts.GetParentDatabank().name + Globals.symbolBankColon + ts.GetName();
                                temp.Add(varnameWithBankAndFreq);
                                Program.Disp(ConvertFreqs(tStart, tEnd, ts.freq).Item1, ConvertFreqs(tStart, tEnd, ts.freq).Item2, temp, false, true, true, null);
                            };
                            G.Writeln(surplus + " " + ps + " hidden (" + G.GetLinkAction("show", new GekkoAction(EGekkoActionTypes.Unknown, null, a)) + ")");
                        }
                    }
                }
            }
        }

        private static void PrintEquationWithLinks(bool gamsToGekko, string varnameWithoutFreq, List<ModelGamsEquation> eqs, bool showGamsEquation)
        {
            int widthRemember = Program.options.print_width;
            int fileWidthRemember = Program.options.print_filewidth;
            Program.options.print_width = int.MaxValue;
            Program.options.print_filewidth = int.MaxValue;

            try
            {
                foreach (ModelGamsEquation eq in eqs)
                {

                    string lhs = null;
                    string rhs = null;
                    string conditionals = null;

                    if (showGamsEquation)
                    {
                        lhs = eq.lhsGams;
                        rhs = eq.rhsGams;
                        conditionals = eq.conditionalsGams;
                    }
                    else
                    {
                        lhs = eq.lhs;
                        rhs = eq.rhs;
                        conditionals = eq.conditionals;
                    }

                    G.Writeln();

                    PrintEquation(lhs); G.Write(" = ");
                    //G.Write(lhs + " = ");
                    //int length = (lhs + " = ").Length;

                    PrintEquation(rhs); G.Writeln(";");
                    G.Writeln("Conditionals: " + eq.conditionals);

                }
            }

            finally
            {
                //resetting, also if there is an error
                Program.options.print_width = widthRemember;
                Program.options.print_filewidth = fileWidthRemember;
            }
            
        }

        private static void PrintEquation(string rhs)
        {
            GekkoDictionary<string, string> knownVars = GetKnownVars(rhs, true);
            TokenList tokens = StringTokenizer2.GetTokensWithLeftBlanks(rhs);  //slack, tokenizing two times
            for (int i = 0; i < tokens.storage.Count; i++)
            {
                TokenHelper token = tokens[i];
                if (token.leftblanks > 0) G.Write(G.Blanks(token.leftblanks));
                if (token.type == ETokenType.Word && knownVars.ContainsKey(token.s))
                {
                    G.WriteLink(token.s, "disp:" + token.s);
                }
                else
                {
                    if (token.type == ETokenType.EOL)
                    {
                        G.Writeln();
                        TokenHelper next = tokens[i + 1];
                        if (next != null && next.type == ETokenType.EOL) i++;  //skip it
                        tokens[i + 1].leftblanks = 4;
                        continue;
                    }
                    G.Write(token.s);
                }
            }
            //G.Writeln(";");
        }

        private static GekkoDictionary<string, string> GetKnownVars(string input)
        {
            return GetKnownVars(input, false);
        }

        private static GekkoDictionary<string, string> GetKnownVars(string input, bool useDatabank)
        {
            GekkoDictionary<string, string> knownVars = new GekkoDictionary<string, string>(StringComparer.OrdinalIgnoreCase);
            TokenList tokens = StringTokenizer2.GetTokensWithLeftBlanks(input);
            foreach (TokenHelper token in tokens.storage)
            {
                if (token.type == ETokenType.Word)
                {
                    //List<ModelGamsEquation> e3 = null; Program.modelGams.equations.TryGetValue(token.s, out e3);
                    List<ModelGamsEquation> e3 = GamsModel.GetGamsEquationsByVarname(token.s);

                    if (e3 != null)
                    {
                        if (!knownVars.ContainsKey(token.s)) knownVars.Add(token.s, null);
                    }
                    else
                    {
                        if (useDatabank)
                        {
                            string varnameWithFreq = token.s + Globals.freqIndicator + G.GetFreq(Program.options.freq);
                            if (Program.databanks.GetFirst().ContainsIVariable(varnameWithFreq))
                            {
                                if (!knownVars.ContainsKey(token.s)) knownVars.Add(token.s, null);
                            }
                        }
                    }
                }
            }
            return knownVars;
        }


        private static List<GekkoDictionary<string, string>> GetDimensions(List<string> names)
        {
            List<GekkoDictionary<string, string>> dimensions = new List<GekkoDictionary<string, string>>();
            foreach (string s in names)
            {
                string[] ss = GetArrayTimeseriesName(s);
                int dims = ss.Length - 1;
                for (int i = dimensions.Count; i < dims; i++)
                {
                    dimensions.Add(new GekkoDictionary<string, string>(StringComparer.OrdinalIgnoreCase));
                }
                for (int i = 0; i < dims; i++)
                {
                    string name = ss[i + 1];
                    if (!dimensions[i].ContainsKey(name))
                    {
                        dimensions[i].Add(name, "");
                    }
                }
            }

            return dimensions;
        }

        private static string[] GetArrayTimeseriesName(string s)
        {
            return s.Split(new string[] { Globals.symbolTurtle }, StringSplitOptions.None);
        }

        public static List<string> SplitStringAndKeepDelimiters(string strSplit, char[] arrDelimiters)
        {
            // Start of tokenizing
            // Create a work array where the finished result also will be
            List<string> alWork = new List<string>();
            alWork.Add(strSplit);
            // Temporary variables
            Object[] arrSplitted;
            Char[] arrChar = new Char[1];
            List<string> alTemp = new List<string>();
            // Process each delimiter
            foreach (Char c in arrDelimiters)
            {
                // Clear temp vars
                arrChar[0] = c;
                alTemp.Clear();
                // Process each string
                foreach (String strWork in alWork)
                {
                    // Split it by delimiter
                    arrSplitted = strWork.Split(arrChar, StringSplitOptions.None);
                    if (arrSplitted.Length > 1)
                    {
                        // Split took place, add delimiter between every item
                        for (int n = 0; n < arrSplitted.Length; n++)
                        {
                            alTemp.Add((string)arrSplitted[n]);
                            if (n < arrSplitted.Length - 1)
                            {
                                alTemp.Add(c.ToString());
                            }
                        }
                    }
                    else
                    {
                        // No split took place, use original string
                        alTemp.Add(strWork);
                    }
                }
                // Copy temp array to work array
                // In C++ it would be some nice pointer swapping instead!
                alWork.Clear();
                alWork.AddRange(alTemp);
            }
            return alWork;
        }

        public static List<string> GetVariableExplanation(string var)
        {
            List<string> explanation = new List<string>();
            if (Program.unfoldedVariableList == null) return explanation;
            foreach (Program.Item item in Program.unfoldedVariableList)
            {
                if (G.Equal(var, item.variable))
                {
                    explanation = item.explanation;
                }
            }
            return explanation;
        }

        public static void ConvertToPrintFormat(double level1, double pch1, out string levelFormatted, out string pchFormatted)
        {
            levelFormatted = G.levelFormatOld(level1);
            pchFormatted = G.pchFormatOld(pch1);
        }


        public static EEndoOrExo VariableTypeEndoExo(string var)
        {
            EEndoOrExo type = EEndoOrExo.Unknown;
            if (var == null) return type;
            if (G.HasModelGekko())
            {
                //checks if left-hand var in model. So this ignores exo/endo commands.
                //so the E and X only describes the model equations as they are
                if (Program.model.modelGekko?.endogenousOriginallyInModel != null && Program.model.modelGekko.endogenousOriginallyInModel.ContainsKey(var))
                {
                    type = EEndoOrExo.Endo;
                }
                else if (Program.model?.modelGekko?.varsAType != null && Program.model.modelGekko.varsAType.ContainsKey(var))
                {
                    type = EEndoOrExo.Exo;
                }
            }
            return type;
        }

        public static IVariable ff1(GekkoSmpl smpl, IVariable iv)
        {
            //used to test Func<> in function arguments, #980745824309
            iv = O.Add(smpl, iv, Globals.scalarVal1);
            return iv;
        }        

        public static IVariable ff3(GekkoSmpl smpl, GekkoArg arg1)
        {
            //used to test Func<> in function arguments, #980745824309
            IVariable iv = arg1.f2(smpl);
            iv = O.Add(smpl, iv, Globals.scalarVal1);
            return iv;
        }
               

        public static void Tell(string text, bool nocr)
        {            
            if (Globals.runningOnTTComputer && text == "arrow")
            {
                Arrow.Run();     
            }

            if (nocr) G.Write(text);
            else G.Writeln(text);
        }

        public static string Find(O.Find o)  //returns equation name
        {

            List<string> vars = O.Restrict(o.iv, false, false, false, true);
            string variableName = vars[0];

            Globals.itemHandler = new ItemHandler();

            string firstText = null;
            List<string> firstList = new List<string>();
            string firstEqName = null;

            int lineCounter = 0;

            foreach (KeyValuePair<string, List<ModelGamsEquation>> kvp in Program.model.modelGams.equationsByEqname)
            {
                string eqName = kvp.Value[0].nameGams;  //has only 1

                //List<List<string>> results = new List<List<string>>();

                int counter = 0;
                foreach (EquationVariablesGams eqVarsGams in kvp.Value[0].expressionVariablesWithSets) //foreach sub-eq
                {
                    if (eqVarsGams == null) continue;
                    counter++;
                    {
                        bool found = false;
                        foreach (string ss in eqVarsGams.equationVariables) //foreach variable (first item is name)
                        {
                            string[] ss2 = ss.Split('¤');
                            string ss3 = ss2[0];
                            if (ss2.Length > 1 && ss2[1] == "[0]")
                            {
                                if (G.Equal(variableName, ss3))
                                {
                                    found = true;
                                    break;
                                }
                            }
                        }

                        if (found)
                        {
                            //List<string> yy = m3;
                            string xx = G.ReplaceTurtle(G.GetListWithCommas(eqVarsGams.equationVariables)).Replace(", residual___", "");

                            string bool1 = "";
                            string bool2 = "";
                            string tt = "tx0";
                            if (eqName == "E_qY_tot")
                            {
                                bool1 = Globals.protectSymbol;
                                bool2 = Globals.protectSymbol;
                            }
                            else if (eqName == "E_vCalvo")
                            {
                                tt = "tx0e";
                            }
                            else if (eqName == "E_vCalvo_tEnd")
                            {
                                tt = "tend";
                            }

                            Globals.itemHandler.Add(new EquationListItem(eqName, counter + " of " + kvp.Value[0].expressionVariablesWithSets.Count, bool1, bool2, tt, xx, "Black", lineCounter == 3));
                            lineCounter++;

                            List<ModelGamsEquation> xx2 = Program.model.modelGams.equationsByEqname[eqName];

                            if (firstText == null)
                            {
                                firstText = xx2[0].lhs + " = " + xx2[0].rhs;                                
                                firstEqName = eqName;
                                firstList.AddRange(eqVarsGams.equationVariables);
                            }
                        }
                    }
                }
            }

            string rv = null;
            WindowEquationBrowser eb = new WindowEquationBrowser();
            eb.Title = variableName + " - " + "Gekko equations";
            eb.EquationBrowserSetEquationButtons(firstEqName, firstText, firstList);
            //eb.EquationBrowserSetLabel(variableName);
            eb._activeEquation = firstEqName;
            eb._activeVariable = null;
            eb._t1 = o.t1;
            eb._t2 = o.t2;
            bool? b = eb.ShowDialog();
            rv = eb._activeEquation;
            if (b != true) rv = null;  //only when OK is pressed (or Enter)
            eb.Close();

            return rv;

        }
        

        private static IEnumerable<T> Concat<T>(this T firstElement, IEnumerable<T> secondSequence)
        {
            yield return firstElement;
            if (secondSequence == null)
            {
                yield break;
            }

            foreach (var item in secondSequence)
            {
                yield return item;
            }
        }

        private static IEnumerable<T> AllExcept<T>(this IEnumerable<T> sequence, int indexToSkip)
        {
            if (sequence == null)
            {
                yield break;
            }

            var index = 0;

            foreach (var item in sequence.Where(item => index++ != indexToSkip))
            {
                yield return item;
            }
        }

        public static void Display(string text)
        {
            if (text.EndsWith(";")) text = text.Substring(0, text.Length - 1);  //Should be DISPLAY 'text'; fixing it here
            G.Writeln(text);
        }

        public static void Hdg(string text)
        {
            if (text.EndsWith(";")) text = text.Substring(0, text.Length - 1);  //Should be HDG 'text'; fixing it here
            Program.databanks.GetFirst().info1 = text;
            G.Writeln2("Databank heading for '" + Program.databanks.GetFirst().name + "' databank set to: '" + text + "'");
        }

        public static void Rename(O.Rename o)
        {

            if (o.type == "ASTPLACEHOLDER") o.type = null;
            EVariableType type = EVariableType.Var;
            if (o.type != null) type = G.GetVariableType(o.type);

            List<ToFrom> outputs = SearchFromTo(o.names0, o.names1, o.opt_frombank, o.opt_tobank, EWildcardSearchType.Rename, null);

            if (G.IsUnitTesting() && Globals.unitTestCopyHelper2)
            {
                Globals.unitTestCopyHelper = outputs;  //for simpler testing of this
                return;
            }

            if (G.Equal(o.opt_print, "yes"))
            {
                G.Writeln2("Renaming the following " + outputs.Count + " variables:");
                G.Writeln();
                foreach (ToFrom two in outputs)
                {
                    G.Writeln(two.s1 + " ---> " + two.s2);
                }
            }

            foreach (ToFrom output in outputs)
            {
                IVariable iv = O.GetIVariableFromString(output.s1, O.ECreatePossibilities.NoneReportError);  //no search
                if (type != EVariableType.Var && type !=  iv.Type()) continue; //skip it                
                O.RemoveIVariableFromString(output.s1, true);  //get it out of dictionary
                Series iv_series = iv as Series;
                if (iv_series != null)
                {
                    //replaces the name, keeps freq. For instance, 
                    iv_series.name = G.Chop_GetName(output.s2) + Globals.freqIndicator + G.GetFreq(iv_series.freq);
                }
                O.AddIVariableWithOverwriteFromString(output.s2, iv); //get it into dictionary
            }

            G.Writeln2("Renamed " + outputs.Count + " variables");
        }

        public static void Copy(O.Copy o)
        {

            if (o.type == "ASTPLACEHOLDER") o.type = null;
            EVariableType type = EVariableType.Var;
            if (o.type != null) type = G.GetVariableType(o.type);

            if (o.names2 == null)
            {
                o.names2 = new Gekko.List();
                o.names2.Add(new ScalarString("First:*"));
            }

            bool ignoreErrors = false; if (G.Equal(o.opt_error, "no")) ignoreErrors = true;
            SearchOptions options = new SearchOptions();
            if (ignoreErrors) options.ignoreErrors = true;
            List<ToFrom> outputs = SearchFromTo(o.names1, o.names2, o.opt_frombank, o.opt_tobank, EWildcardSearchType.Copy, options);

            int nIgnores = 0;
            int nOk = 0;

            if (G.IsUnitTesting() && Globals.unitTestCopyHelper2)
            {
                Globals.unitTestCopyHelper = outputs;  //for simpler testing of this
                return;
            }

            if (G.Equal(o.opt_print, "yes"))
            {
                G.Writeln2("Copying the following " + outputs.Count + " variables:");
                G.Writeln();
                foreach (ToFrom two in outputs)
                {
                    G.Writeln(two.s1 + " ---> " + two.s2);
                }
            }

            GekkoSmplSimple truncate = HandleRespectPeriod(o.t1, o.t2, o.opt_respect, null, "copy");

            foreach (ToFrom output in outputs)
            {
                IVariable iv = O.GetIVariableFromString(output.s1, O.ECreatePossibilities.NoneReturnNull);  //no search here

                if (iv == null)
                {
                    if (ignoreErrors)
                    {
                        G.Writeln2("+++ NOTE: Could not find variable '" + output.s1 + "' for copying");
                        nIgnores++;
                        continue;
                    }
                    else
                    {
                        O.GetIVariableFromString(output.s1, O.ECreatePossibilities.NoneReportError);  //will emit the error message
                    }
                }
                else
                {
                    if (type != EVariableType.Var && type != iv.Type()) continue; //skip it
                }

                nOk++;

                IVariable existing = O.GetIVariableFromString(output.s2, O.ECreatePossibilities.NoneReturnNull);
                bool injectingToExistingSeries = false;
                if (truncate != null && existing != null && iv.Type() == EVariableType.Series && existing.Type() == EVariableType.Series)
                {
                    Series iv_series = iv as Series;
                    Series existing_series = existing as Series;
                    if (iv_series.dimensionsStorage == null)
                    {
                        if (iv_series.freq == existing_series.freq)
                        {
                            injectingToExistingSeries = true;
                            foreach (GekkoTime gt in new GekkoTimeIterator(truncate.t1, truncate.t2))
                            {
                                existing_series.SetData(gt, iv_series.GetDataSimple(gt));
                            }
                        }
                    }
                }

                if (!injectingToExistingSeries)
                {
                    IVariable iv_clone = iv.DeepClone(truncate);
                    O.AddIVariableWithOverwriteFromString(output.s2, iv_clone);
                }
            }

            string si = null;
            if (nIgnores > 0) si = " (ignored " + nIgnores + ")";

            G.Writeln2("Copied data for " + nOk + " variables" + si);

        }

        public static GekkoSmplSimple HandleRespectPeriod(GekkoTime t1, GekkoTime t2, string respect, string all, string type)
        {
            //type = copy, read, import, write, export
            GekkoSmplSimple truncate = null;
            if (t1.IsNull())
            {
                //No time period
                if (G.Equal(respect, "yes"))
                {
                    if (G.Equal(type, "import") || G.Equal(type, "export"))
                    {
                        G.Writeln2("*** ERROR: You cannot use " + type.ToUpper() + "<respect>");
                        throw new GekkoException();
                    }
                    //COPY<respect>, READ<respect>, WRITE<respect>
                    truncate = new GekkoSmplSimple(Globals.globalPeriodStart, Globals.globalPeriodEnd);
                }
                else if (G.Equal(all, "yes"))
                {
                    if (G.Equal(type, "copy") || G.Equal(type, "read") || G.Equal(type, "write"))
                    {
                        G.Writeln2("*** ERROR: You cannot use " + type.ToUpper() + "<all>");
                        throw new GekkoException();
                    }
                    //IMPORT<all> or EXPORT<all>
                    //truncate = new GekkoSmplSimple(true);
                }
                else
                {
                    if (!Program.options.bugfix_import_export)
                    {
                        if (G.Equal(type, "import") || G.Equal(type, "export"))
                        {
                            truncate = new GekkoSmplSimple(Globals.globalPeriodStart, Globals.globalPeriodEnd);
                        }
                    }
                }
            }
            else
            {
                //time period, READ<2010 2020> or IMPORT<2010 2020>                
                if (G.Equal(respect, "yes"))
                {
                    //READ<2010 2020 respect>
                    G.Writeln2("*** ERROR: You cannot mix dates and 'respect' in the option field");
                    throw new GekkoException();                    
                }                
                else if (G.Equal(all, "yes"))
                {
                    //IMPORT<2010 2020 all>
                    G.Writeln2("*** ERROR: You cannot mix dates and 'all' in the option field");
                    throw new GekkoException();
                }
                else
                {
                    truncate = new GekkoSmplSimple(t1, t2);
                }
            }
            return truncate;
        }

        public static void AddIfInRange(string bankname, string freqname, string s, string s1, string s2, List<string> m)
        {
            if (string.Compare(s1, s, true) <= 0 && string.Compare(s, s2, true) <= 0)
            {
                string ss1 = null;
                string ss2 = null;
                if (bankname != null) ss1 = bankname + Globals.symbolBankColon;
                if (freqname != null) ss2 = Globals.freqIndicator + freqname;
                m.Add(ss1 + s + ss2);                
            }
        }

        public static List<string> Search(List names1, string frombank, EVariableType type)
        {
            List<string> names = new List<string>();
            List<ToFrom> matches = Program.SearchFromTo(names1, null, frombank, null, EWildcardSearchType.Search, null);
            //List rv = new List();

            foreach (ToFrom two in matches)
            {
                if (type != EVariableType.Var)
                {
                    //a bit of double work here, but maybe it does not need to be super fast anyway
                    IVariable iv = O.GetIVariableFromString(two.s1, O.ECreatePossibilities.NoneReportError);  //no search here
                    if (type != EVariableType.Var && type != iv.Type()) continue; //skip it
                }
                names.Add(two.s1);
            }
            return names;
        }

        public static List<ToFrom> SearchFromTo(List names0, List names1, string frombank, string tobank, EWildcardSearchType type, SearchOptions options)
        {
            //names0 may contain ranges
            
            //In general, INDEX, DISP and {'...'} are maybe a bit different from 
            //wildcards in COPY, RENAME, WRITE, etc. In principle, the former could 
            //search in all banks, even without a '*:' but better to keep the logic unified.
            //So PRT x and y = x searches for x in all banks (if search is on), whereas the
            //wildcards need '*:' to do that.
            //
            //In essence, math expressions like PRT x and y = x search for 1 item, where
            //INDEX, DISP, {'...'}, COPY, RENAME, WRITE, etc search for many items. Therefore
            //the logic is different.
            //
            //Note that #m = {'...'} returns a list<string>, not list<series>, because 
            //it is understood like #m = item1, item2, ... But PRT {'...'} will still
            //get a list<series>.
            //
            //What if {'a*b'} returns list<series>, and ['a*b'] list<string>. You may
            //use {['a*b']} too. Then #m['a*b'] fits nicely.
                        
            //Used in both COPY ... TO ... and RENAME ... AS ...
            //Also used for INDEX and ... = ... {'a*b'}
            //All the following combinations are tested in unit tests

            //If there is frombank, LHS without bank gets that bank

            //Use of wildcards:
            //
            // === Before TO (lhs): ==============================
            //
            // --- bank ---
            // a: no bank
            // b: given bank
            // c: wildcard bank (can be complicated)
            //
            // --- names ---
            // 01: list of given names
            // 02: wildcard name (can be complicated)
            //
            // === After TO (rhs): ===============================
            //
            // --- bank ---
            // A: no bank (all vars will get 'First:')
            // B: given bank (replaces bank)
            // C: star bank (not really a wildcard, can only be '*', will get same bank as lhs)
            //         
            // --- names ---   
            // 11: list of given names
            // 12: wildcard name (must be simple one-star like 'a*b')
            //  
            // ---------------------------------------------
            //
            // NOTE: If lhs contains an element with a wildcards ('*' or '?' in bank or name), the rhs MUST be a 1-element
            //       list (in practice this item is a wildcard, but collisions are checked anyway)
            //       This is to avoid that names obtained from wildcards are randomly put into a list
            //       of fixed names.
            //
            // =============================================

            bool removeCurrentFirstBankAndCurrentFreq = true;

            string currentFirstBankName = Program.databanks.GetFirst().name;
            string currentRefBankName = Program.databanks.GetRef().name;
            string currentFreq = G.GetFreq(Program.options.freq);

            string command = "COPY";
            string command2 = "copy";
            string command3 = "copied";
            if (type == EWildcardSearchType.Rename)
            {
                command = "RENAME";
                command2 = "rename";
                command2 = "renamed";
            }
            else if (type == EWildcardSearchType.Search)
            {
                command = "Search";
                command2 = "search";
                command2 = "searched";
            }
            else if (type == EWildcardSearchType.Write)
            {
                command = "WRITE";
                command2 = "write";
                command2 = "wrote";
            }
            else if (type == EWildcardSearchType.Delete)
            {
                command = "DELETE";
                command2 = "delete";
                command2 = "deleted";
            }

            List<ToFrom> outputs = new List<ToFrom>();

            List<string> lhs = O.Restrict(names0, true, true, true, true);
            bool allowBankRhs = true;
            if (type == EWildcardSearchType.Write)
            {
                allowBankRhs = true;
                //if (!Globals.UNITTESTFOLLOWUP_important) allowBankRhs = false;  //would be nice if it could be true  
            }
            
            List<string> rhs = O.Restrict(names1, allowBankRhs, true, true, true);
            
            // --------------------------------------------
            //           LHS
            // --------------------------------------------

            List<string> lhsUnfolded = new List<string>();
            List<bool> lhsUnfoldedExplicit = new List<bool>();

            bool lhsHasStarOrQuestionGlobal = false;  //true for LHS, for 'a*', '*:x', 'b?:x?', etc.

            foreach (string wildCardLhs in lhs)
            {               

                string bankLhs = null;
                string nameLhs = null; 
                string freqLhs  = null;
                string[] indexLhs = null;

                string nameLhsRange1 = null;
                string nameLhsRange2 = null;

                string[] ss = wildCardLhs.Split(new string[] { ".." }, StringSplitOptions.None);
                if (ss.Length == 2)
                {
                    //stuff like ['ab'..'f']
                    //['b2:ab'..'b2:f']
                    //['ab!q'..'f!q']

                    if (ss[0].StartsWith(Globals.symbolRefShortcut)) ss[0] = "ref:" + ss[0].Substring(1);
                    if (ss[1].StartsWith(Globals.symbolRefShortcut)) ss[1] = "ref:" + ss[1].Substring(1);

                    string bankLhs1, nameLhs1, freqLhs1; string[] indexLhs1;
                    O.Chop(ss[0], out bankLhs1, out nameLhs1, out freqLhs1, out indexLhs1);

                    string bankLhs2, nameLhs2, freqLhs2; string[] indexLhs2;
                    O.Chop(ss[1], out bankLhs2, out nameLhs2, out freqLhs2, out indexLhs2);

                    if (!G.Equal(bankLhs1, bankLhs2))
                    {
                        G.Writeln2("*** ERROR: You must use the same bankname before and after '..' in a range");
                        throw new GekkoException();
                    }

                    if (!G.Equal(freqLhs1, freqLhs2))
                    {
                        G.Writeln2("*** ERROR: You must use the same freq before and after '..' in a range");
                        throw new GekkoException();
                    }

                    if (nameLhs1[0] == Globals.symbolScalar && nameLhs2[0] != Globals.symbolScalar)
                    {
                        G.Writeln2("*** ERROR: Scalar symbol ('%') should be present both before and after '..'");
                        throw new GekkoException();
                    }

                    if (nameLhs1[0] == Globals.symbolCollection && nameLhs2[0] != Globals.symbolCollection)
                    {
                        G.Writeln2("*** ERROR: Collection symbol ('#') should be present both before and after '..'");
                        throw new GekkoException();
                    }
                    bankLhs = bankLhs1;
                    nameLhsRange1 = nameLhs1;
                    nameLhsRange2 = nameLhs2;
                    freqLhs = freqLhs1;

                }
                else
                {
                    string sss = wildCardLhs;
                    if (sss.StartsWith(Globals.symbolRefShortcut)) sss = "ref:" + sss.Substring(1);
                    O.Chop(sss, out bankLhs, out nameLhs, out freqLhs, out indexLhs);
                    if (nameLhs == "***")
                    {
                        if (bankLhs != null)
                        {
                            G.Writeln2("*** ERROR: You cannot combine '***' with bank, frequency or index.");
                            throw new GekkoException();
                        }
                        bankLhs = "*";
                        nameLhs = "**";
                        //so *** = *:**
                    }
                }

                //Now we have bankLhs and freqLhs (indexLhs does not work...)
                //if nameLhs != null, it is normal wildcard
                //if nameLhsRange1 != null, it is a range

                //any "first" or "ref" is set to their real names. Null will still be null.
                bankLhs = SubstituteFirstRefNames(bankLhs);

                if (bankLhs == null && frombank != null) bankLhs = frombank;  //overwrites "naked" vars, so "COPY <frombank=b> a, b to c, d;" is same as "COPY b:a, b:b to c, d;"

                bool lhsHasStarOrQuestion = false;
                if (bankLhs != null && (bankLhs.Contains("*") || bankLhs.Contains("?"))) lhsHasStarOrQuestion = true;
                if (nameLhs != null && (nameLhs.Contains("*") || nameLhs.Contains("?"))) lhsHasStarOrQuestion = true;
                if (freqLhs != null && (freqLhs.Contains("*") || freqLhs.Contains("?"))) lhsHasStarOrQuestion = true;
                if (nameLhsRange1 != null) lhsHasStarOrQuestion = true;  //range
                if (lhsHasStarOrQuestion) lhsHasStarOrQuestionGlobal = true;  //used outside loop

                if (indexLhs != null)
                {
                    if (lhsHasStarOrQuestion)
                    {
                        G.Writeln2("*** ERROR: " + command + " with wildcard indexes not yet implemented");
                        throw new GekkoException();
                    }
                    else
                    {
                        //could be just DISP x[a] for instance
                    }
                }

                bool hasExplicitBank = bankLhs != null;

                if (!lhsHasStarOrQuestion && type == EWildcardSearchType.Search)
                {
                    //a hack to make DISP x[a] work                    
                    //OR: it is an INDEX command without stars, here we must find out if the single non-wildcard item exists
                    IVariable iv = O.GetIVariableFromString(wildCardLhs, O.ECreatePossibilities.NoneReturnNull);
                    if (iv != null)
                    {
                        lhsUnfolded.Add(wildCardLhs);
                        lhsUnfoldedExplicit.Add(hasExplicitBank);
                    }
                }
                else if (lhsHasStarOrQuestion)
                {
                    //There is a star or question in bank, name or freq, or a range in name                    

                    List<string> listOfAllOpenBanks = GetListOfAllBanks();
                    List<string> db_banks = new List<string>();
                    if (bankLhs == null)
                    {
                        db_banks.Add(currentFirstBankName);
                    }
                    else
                    {
                        db_banks = Search(bankLhs, listOfAllOpenBanks);
                    }

                    foreach (string db_bank in db_banks)
                    {
                        //
                        // This is where the matching takes place
                        //
                        if (nameLhsRange1 != null)
                        {
                            List<string> range = RangeInBank(db_bank, nameLhsRange1, nameLhsRange2, freqLhs);
                            lhsUnfolded.AddRange(range);
                            foreach (string s in range) lhsUnfoldedExplicit.Add(hasExplicitBank);
                        }
                        else
                        {
                            List<string> match = MatchInBank(db_bank, nameLhs, freqLhs);
                            lhsUnfolded.AddRange(match);
                            foreach (string s in match) lhsUnfoldedExplicit.Add(hasExplicitBank);
                        }
                    }
                }
                else
                {
                    //item without * or ? or range
                    string bankTemp = bankLhs;
                    if (bankLhs == null)
                    {
                        LocalGlobal.ELocalGlobalType lg = Program.databanks.localGlobal.GetValue(nameLhs); //should be without freq                                                                                                             
                        bankTemp = O.HandleLocalGlobalBank2(lg);
                    }
                    string freq = null;
                    if (!G.Chop_HasSigil(nameLhs))
                    {
                        freq = freqLhs;
                        if (freqLhs == null) freq = currentFreq;
                    }
                    lhsUnfolded.Add(O.UnChop(bankTemp, nameLhs, freq, indexLhs));
                    lhsUnfoldedExplicit.Add(hasExplicitBank);
                }
            }

            bool reportError = true;
            if (options == null) reportError = false;
            if (options != null && options.ignoreErrors == true) reportError = false;
            if (reportError && lhsUnfolded.Count == 0)
            {
                G.Writeln2("*** ERROR: " + command + " wildcard/range did not match any variables");
                throw new GekkoException();
            }            

            // ------------------------------------------------------------
            // Now the variables have been found
            // Next is which variables they (maybe) are
            // matched with, for instance with COPY or RENAME.
            // ------------------------------------------------------------
            
            if (type == EWildcardSearchType.Search || type == EWildcardSearchType.Delete)
            {
                for (int i = 0; i < lhsUnfolded.Count; i++)
                {
                    outputs.Add(new ToFrom(lhsUnfolded[i], null, lhsUnfoldedExplicit[i]));
                }
                ////No matching with other variables
                //foreach (string s in lhsUnfolded)
                //{
                //    outputs.Add(new ToFrom(s, null, false)); //has no destination
                //}                
            }
            else
            {
                //type with destination
                if (rhs.Count > 1)
                {
                    if (lhsHasStarOrQuestionGlobal)
                    {
                        //Such assignment is too error-prone, like "COPY x* TO a, b, c;"
                        G.Writeln2("*** ERROR: Using wildcards before TO/AS, you must state a single wildcard element after TO/AS");
                        throw new GekkoException();
                    }
                    else
                    {
                        if (lhs.Count != rhs.Count)
                        {
                            G.Writeln2("*** ERROR: Mismatch: there are " + lhs.Count + " elements before TO/AS, and " + rhs.Count + " elements after TO/AS");
                            throw new GekkoException();
                        }
                    }
                }

                for (int i = 0; i < lhsUnfolded.Count; i++)
                {
                    string lhsElement = lhsUnfolded[i];
                    bool lhsElementExplicit = lhsUnfoldedExplicit[i];

                    string rhsElement = null;
                    if (rhs.Count > 1) rhsElement = rhs[i];
                    else rhsElement = rhs[0];

                    //This is (re)chopping of a LHS variable that has already had bankname etc. added
                    string bankLhs, nameLhs, freqLhs; string[] indexLhs;
                    O.Chop(lhsElement, out bankLhs, out nameLhs, out freqLhs, out indexLhs);
                    bankLhs = SubstituteFirstRefNames(bankLhs);

                    //TODO: some superfluous repetitive chopping here, if rhs has only 1 element
                    string bankRhs, nameRhs, freqRhs; string[] indexRhs;
                    O.Chop(rhsElement, out bankRhs, out nameRhs, out freqRhs, out indexRhs);
                    bankRhs = SubstituteFirstRefNames(bankRhs);

                    if (bankRhs == null && tobank != null) bankRhs = tobank;  //overwrites "naked" vars, so "COPY <tobank=b> a, b to c, d;" is same as "COPY a, b to b:c, b:d;"

                    string[] name2split = nameRhs.Split('*');

                    if (name2split.Length - 1 > 1)
                    {
                        G.Writeln2("*** ERROR: More than one '*' not allowed in name in TO/AS part of " + command + "");
                        throw new GekkoException();
                    }

                    if ((bankRhs != null && bankRhs.Contains("?")) || nameRhs.Contains("?"))
                    {
                        G.Writeln2("*** ERROR: '?' not not allowed in TO/AS part of " + command + "");
                        throw new GekkoException();
                    }

                    if (bankRhs == null)
                    {
                        //COPY...to   * --> first, same names
                        //COPY...to   x*y --> first, prefix suffix
                        //COPY...to   x --> first, fixed name

                        string bankTemp = bankRhs;
                        if (bankTemp == null)
                        {
                            LocalGlobal.ELocalGlobalType lg = Program.databanks.localGlobal.GetValue(nameRhs); //should be without freq                                                                                                             
                            bankTemp = O.HandleLocalGlobalBank2(lg);
                        }

                        //no bank given in second part
                        if (name2split.Length == 1)
                        {
                            //no stars
                            outputs.Add(new ToFrom(lhsElement, O.UnChop(bankTemp, nameRhs, freqLhs, indexLhs), lhsElementExplicit));
                        }
                        else
                        {
                            //one star
                            outputs.Add(new ToFrom(lhsElement, O.UnChop(currentFirstBankName, name2split[0] + nameLhs + name2split[1], freqLhs, indexLhs), lhsElementExplicit));
                        }
                    }
                    else if (!bankRhs.Contains("*"))
                    {
                        //COPY...to b:* --> b bank, same names
                        //COPY...to b:x*y --> b bank, prefix suffix
                        //COPY...to b:* --> b bank, same names

                        if (!G.IsSimpleToken(bankRhs))
                        {
                            G.Writeln2("*** ERROR: Illegal bankname in TO/AS part of " + command + "");
                            throw new GekkoException();
                        }

                        //fixed bank given in second part
                        if (name2split.Length == 1)
                        {
                            //no stars
                            outputs.Add(new ToFrom(lhsElement, O.UnChop(bankRhs, nameRhs, freqLhs, indexLhs), lhsElementExplicit));
                        }
                        else
                        {
                            //one star
                            outputs.Add(new ToFrom(lhsElement, O.UnChop(bankRhs, name2split[0] + nameLhs + name2split[1], freqLhs, indexLhs), lhsElementExplicit));
                        }
                    }
                    else
                    {
                        //COPY...to *:*--> fail: copies to itself                
                        //COPY...to *:x*y -- > same bank, prefix suffix
                        //COPY...to *:b  --> same bank, fixed name

                        if (bankRhs != "*")
                        {
                            G.Writeln2("*** ERROR: Only simple '*' allowed in TO/AS part of " + command + "");
                            throw new GekkoException();
                        }

                        //original bank stated in second part
                        if (name2split.Length == 1)
                        {
                            //no stars
                            outputs.Add(new ToFrom(lhsElement, O.UnChop(bankLhs, nameRhs, freqLhs, indexLhs), lhsElementExplicit));
                        }
                        else
                        {
                            //one star
                            outputs.Add(new ToFrom(lhsElement, O.UnChop(bankLhs, name2split[0] + nameLhs + name2split[1], freqLhs, indexLhs), lhsElementExplicit));
                        }
                    }
                }


                //So now, if RHS has > 1 element, LHS has no '*' or '?'
                //And if RHS has > 1 element, LHS has the same number.                

                Dictionary<string, int> lhsCheck = new Dictionary<string, int>(StringComparer.OrdinalIgnoreCase);
                Dictionary<string, int> rhsCheck = new Dictionary<string, int>(StringComparer.OrdinalIgnoreCase);
                                
                int counter = 0;
                //G.Writeln();
                foreach (ToFrom two in outputs)
                {
                    if (type != EWildcardSearchType.Write && G.Equal(two.s1, two.s2)) //blanks are removed in two list, so indexes should compare fine, too.
                    {
                        //Copying to "itself" (that is, the databank) is fine for WRITE
                        G.Writeln2("*** ERROR: You cannot " + command2 + " element '" + two.s1 + "' to itself");
                        throw new GekkoException();
                    }
                    if (lhsCheck.ContainsKey(two.s1))
                    {
                        G.Writeln2("*** ERROR: Dublet: element '" + two.s1 + "' appears several times before TO/AS");
                        throw new GekkoException();
                    }
                    else
                    {
                        lhsCheck.Add(two.s1, 0);
                    }
                    if (rhsCheck.ContainsKey(two.s2))
                    {
                        List<string> temp = new List<string>();
                        foreach (ToFrom two2 in outputs)
                        {
                            if (G.Equal(two2.s2, two.s2))
                            {
                                temp.Add(two2.s1);
                            }
                        }
                        string ss = two.s2;
                        if (type == EWildcardSearchType.Write)
                        {
                            //Remove bank, which is always "First:" anyway
                            ss = G.Chop_RemoveBank(ss);
                        }
                        G.Writeln2("*** ERROR: The variables " + G.GetListWithCommas(temp) + " are all " + command3 + " to " + ss);
                        throw new GekkoException();
                    }
                    else
                    {
                        rhsCheck.Add(two.s2, 0);
                    }


                    if (true)
                    {
                        //must have both bank colon
                        //THIS IF CAN BE REMOVED AFTER SOME TESTING
                        if (!two.s1.Contains(Globals.symbolBankColon) || !two.s2.Contains(Globals.symbolBankColon))
                        {
                            G.Writeln2("*** ERROR: Internal error #08745765398475");
                            throw new GekkoException();
                        }
                        if ((!G.Chop_HasSigil(two.s1) && !two.s1.Contains(Globals.freqIndicator)) || (!G.Chop_HasSigil(two.s2) && !two.s2.Contains(Globals.freqIndicator)))
                        {
                            G.Writeln2("*** ERROR: Internal error #08745765398475");
                            throw new GekkoException();
                        }
                        if (type == EWildcardSearchType.Write)
                        {
                            if (!G.Equal(G.Chop_GetBank(two.s2), currentFirstBankName))
                            {
                                //G.Writeln2("*** ERROR: Internal error #08745765398475");
                                //throw new GekkoException();
                            }
                        }

                        //G.Writeln(two.s1 + " --> " + two.s2);
                        //counter++;
                        //if (counter > 20) break;
                    }

                }  //end of foreach (TwoStrings two in outputs)

            }  //end of if (type == EWildcardSearchType.Search)

            if (removeCurrentFirstBankAndCurrentFreq && type == EWildcardSearchType.Search)
            {               

                foreach (ToFrom two in outputs)
                {
                    two.s1 = G.Chop_RemoveFreq(two.s1, currentFreq);
                    two.s1 = G.Chop_RemoveBank(two.s1, currentFirstBankName);                    
                    if (two.s2 != null)
                    {
                        two.s2 = G.Chop_RemoveFreq(two.s2, currentFreq);
                        two.s2 = G.Chop_RemoveBank(two.s2, currentFirstBankName);
                    }
                }
            }

            return outputs;
        }

        

        private static List<string> GetListOfAllBanks()
        {
            //Sequence: local, first, ref, rest, global
            List<string> temp = new List<string>();
            temp.Add(Globals.Local);
            for (int i = 0; i < Program.databanks.storage.Count; i++)
            {
                //if (i == 1) continue; //skip ref bank
                Databank databank = Program.databanks.storage[i];                
                temp.Add(databank.name);
            }
            temp.Add(Globals.Global);
            //temp.Add(Program.databanks.storage[1].name); //ref bank
            return temp;
        }

        private static string SubstituteFirstRefNames(string bank)
        {
            if (bank == null) return bank;
            if (G.Equal(bank, Globals.First)) bank = Program.databanks.GetFirst().name;
            else if (G.Equal(bank, Globals.Ref)) bank = Program.databanks.GetRef().name;            
            return bank;
        }

        private static List<string> MatchInBank(string bankname, string wildcardName, string wildcardFreq)
        {
            if (wildcardName.Contains("."))
            {
                G.Writeln2("*** ERROR: Wildcards contains a '.' --> please use '!' to indicate frequency");
                throw new GekkoException();
            }
            
            //For each matching databank
            List<string> varsMatched = new List<string>();
            List<string> allVariablesInBank = new List<string>();
            Databank db = Program.databanks.GetDatabank(bankname, true);
            foreach (KeyValuePair<string, IVariable> kvp in db.storage)
            {
                allVariablesInBank.Add(kvp.Key);
            }

            if (wildcardName == "**")
            {
                //take all objects in given bank, corresponds to '*!*' + '%*' + '#*'
                if (wildcardFreq != null)
                {
                    G.Writeln2("*** ERROR: You cannot combine '**' wildcard with frequency");
                    throw new GekkoException();
                }                
                foreach (string s in allVariablesInBank)
                {
                    varsMatched.Add(bankname + Globals.symbolBankColon + s);
                }                
            }
            else
            {

                string name3a = wildcardName;
                if (wildcardFreq == null)
                {
                    if (!G.Chop_HasSigil(wildcardName)) name3a += Globals.freqIndicator + G.GetFreq(Program.options.freq);
                }
                else
                {
                    name3a += Globals.freqIndicator + wildcardFreq;
                }

                List<string> matched = Search(name3a, allVariablesInBank);

                foreach (string match in matched)
                {
                    varsMatched.Add(bankname + Globals.symbolBankColon + match);
                }
            }

            varsMatched.Sort(StringComparer.OrdinalIgnoreCase);  //always sorting here because they stem from dict keys that are in random order

            return varsMatched;
        }

        private static List<string> RangeInBank(string bankname, string name1, string name2, string wildcardFreq)
        {
            if (wildcardFreq == "*")
            {
                G.Writeln2("Frequency '!*' not supported for ranges ('..')");
                throw new GekkoException();
            }
            if (wildcardFreq == null) wildcardFreq = G.GetFreq(Program.options.freq);
            
            //For each matching databank
            List<string> varsMatched = new List<string>();
            List<string> allVariablesInBank = new List<string>();
            Databank db = Program.databanks.GetDatabank(bankname, true);
            foreach (KeyValuePair<string, IVariable> kvp in db.storage)
            {
                if (G.Chop_HasSigil(kvp.Key)) allVariablesInBank.Add(kvp.Key);
                else if (G.Equal(G.Chop_GetFreq(kvp.Key), wildcardFreq)) allVariablesInBank.Add(G.Chop_RemoveFreq(kvp.Key));
            }

            //after this, allVariablesInBank only has the right frequency (which is dropped), or have sigil
                        
            foreach (string s in allVariablesInBank)
            {
                string w = null;
                if (!G.Chop_HasSigil(s)) w = wildcardFreq;
                AddIfInRange(bankname, w, s, name1, name2, varsMatched);
            }

            varsMatched.Sort(StringComparer.OrdinalIgnoreCase);  //always sorting here because they stem from dict keys that are in random order
            return varsMatched;
        }

        public static List<string> Search(string wild1, List<string> stringsThatCanBeMatched)
        {
            //Simple, can replace MatchWilcard() and similar methods, do a search on "IsMatch("
            //Sorted at the end
            List<string> inputs = new List<string>();

            Wildcard wc = new Wildcard(wild1, System.Text.RegularExpressions.RegexOptions.IgnoreCase);
            foreach (string n2 in stringsThatCanBeMatched)
            {
                if (wc.IsMatch(n2)) inputs.Add(n2);
            }

            //if (sort) inputs.Sort(StringComparer.OrdinalIgnoreCase);
            return inputs;
        }

        public static void Checkoff(List<string> vars2, string type)
        {

            if (type == "clear")
            {
                Globals.checkoff.Clear();
                G.Writeln();
                G.Writeln("CHECKOFF variables cleared");
            }            
            else
            {

                if (vars2.Count == 1 && vars2[0] == "?")
                {
                    G.Writeln();
                    if (Globals.checkoff.Count == 0)
                    {
                        G.Writeln();
                        G.Writeln("There are 0 variables not checked for convergence in the Gauss algorithm.");
                    }
                    else
                    {
                        G.Writeln();
                        CheckoffHelper();
                    }
                }
                else
                {

                    List<string> vars3 = vars2;
                    Globals.checkoff.Clear();
                    Globals.checkoff.AddRange(vars3);
                    G.Writeln();
                    CheckoffHelper();
                }
            }
            return;
        }

        private static void CheckoffHelper()
        {
            G.Writeln("The following " + Globals.checkoff.Count + " variables are not checked for convergence in the Gauss algorithm:");
            G.PrintListWithCommas(Globals.checkoff, false);
        }

        public static void Endo(List<string> vars2)
        {
            if (!G.HasModelGekko())
            {
                G.Writeln2("*** ERROR: No model is defined for endogenization");
                throw new GekkoException();
            }

            Globals.hasBeenEndoExoStatementsSinceLastSim = 1;

            if (vars2 == null)
            {
                Program.model.modelGekko.endogenized.Clear();
                return;
            }

            //TODO: check that manipulated vars exist in model -- no: model may be re-read etc.

            List<string> vars = vars2;
            //if (vars.Count == 0) Program.model.modelGekko.endogenized.Clear();  //not accumulating anymore
            Program.model.modelGekko.endogenized.Clear();
            foreach (string var in vars)
            {
                if (Program.model.modelGekko.endogenized.ContainsKey(var))
                {
                    G.Writeln2("*** ERROR: " + var + " is already endogenized");
                    throw new GekkoException();
                }
                else Program.model.modelGekko.endogenized.Add(var, "");

            }
            G.Writeln2("Endogenized " + vars.Count + " variables");
            return;
        }

        public static void PrintEndoExoLists()
        {
            G.Writeln();
            if (!G.HasModelGekko() || Program.model.modelGekko.endogenized == null || Program.model.modelGekko.endogenized.Count == 0) G.Writeln("There are 0 endogenized variables");
            else
            {
                if (Program.model.modelGekko.endogenized.Count == 1) G.Write("There is " + Program.model.modelGekko.endogenized.Count + " endogenized var: ");
                else G.Write("There are " + Program.model.modelGekko.endogenized.Count + " endogenized vars: ");
                List<string> temp1 = new List<string>();
                foreach (string s in Program.model.modelGekko.endogenized.Keys) temp1.Add(s);
                temp1.Sort();
                G.PrintListWithCommas(temp1, false);
            }
            //G.Writeln();
            if (!G.HasModelGekko() || Program.model.modelGekko.exogenized == null || Program.model.modelGekko.exogenized.Count == 0) G.Writeln("There are 0 exogenized variables");
            else
            {
                if (Program.model.modelGekko.exogenized.Count == 1) G.Write("There is " + Program.model.modelGekko.exogenized.Count + " exogenized var: ");
                else G.Write("There are " + Program.model.modelGekko.exogenized.Count + " exogenized vars: ");
                List<string> temp1 = new List<string>();
                foreach (string s in Program.model.modelGekko.exogenized.Keys) temp1.Add(s);
                temp1.Sort();
                G.PrintListWithCommas(temp1, false);
            }
            G.Writeln();
            return;
        }

        public static void Exo(List<string> vars2)
        {
            //TODO: check that manipulated vars exist in model -- no: model may be re-read etc.
            if (!G.HasModelGekko())
            {
                G.Writeln2("*** ERROR: No model is defined for exogenization");
                throw new GekkoException();
            }

            Globals.hasBeenEndoExoStatementsSinceLastSim = 1;

            if (vars2 == null)
            {
                Program.model.modelGekko.exogenized.Clear();
                return;
            }

            List<string> vars = vars2;
            //if (vars.Count == 0) Program.model.modelGekko.exogenized.Clear();  //not accumulating anymore
            Program.model.modelGekko.exogenized.Clear();
            foreach (string var in vars)
            {
                if (Program.model.modelGekko.exogenized.ContainsKey(var))
                {
                    G.Writeln2("*** ERROR: " + var + " is already exogenized");
                    throw new GekkoException();
                }
                else Program.model.modelGekko.exogenized.Add(var, "");
            }
            G.Writeln2("Endogenized " + vars.Count + " variables");
            return;
        }

        

        public static bool Help(string s)
        {

            if (s == null)
            {                
                s = Globals.helpStartPage;             
            }
            string s2 = s;
            if (!s2.EndsWith(".htm", StringComparison.OrdinalIgnoreCase)) s2 += ".htm";  //called from command line
            List<string> folders = new List<string>();
            if (Program.options.interface_help_copylocal) folders.Add(Globals.localTempFilesLocation + "\\"); //try here first, the file is copied from the path below (helpful if StartupPath is on a network drive)
            folders.Add(Program.options.folder_help);  //looks here first, will actually before anything else look in working folder (which should not contain any help files)
            folders.Add(Application.StartupPath + "\\helpfiles\\"); //most often and probably best, the helpfiles are found here, tied to the gekko version

            string path = FindFile("gekko.chm", folders);  //calls CreateFullPathAndFileName()

            if (path == null)
            {
                G.Writeln();
                G.Writeln("Sorry: could not find the help system file ('gekko.chm').");
                return false;
            }

            try
            {
                System.Windows.Forms.Help.ShowHelp(null, path, s2);  //seems to give the same                
            }
            catch (Exception e)
            {
                G.Writeln2("*** ERROR: It seems the help system is blocked -- maybe it is opened in another program?");
                G.Writeln("           file: " + path);
                throw new GekkoException();
            }
            return true;
        }

        public static void Info(GekkoTime tStart, GekkoTime tEnd, List list2)
        {
            if (!G.HasModelGekko())
            {
                G.Writeln2("*** ERROR: DIP<info> command requires a model -- seems no model is defined");
                throw new GekkoException();
            }

            List<string> list = Program.GetListOfStringsFromList(list2);

            //GekkoTime tStart, tEnd; ConvertToGekkoTime(tp, out tStart, out tEnd);
            //List<string> unfoldedList = UnfoldLists(list);
            if (!(tStart.super == tEnd.super && tStart.sub == tEnd.sub))
            {
                G.Writeln2("*** ERROR: DISP<info> must be called with identical start and end date");
                throw new GekkoException();
            }
            foreach (string var2 in list)
            {
                Program.PrintEquationVariables(tStart, var2);
            }
        }


        public static void List(string type, string leftSide, List<string> rightSide)
        {
            List(type, leftSide, rightSide, true);
        }

        public static void List(string type, string leftSideInput, List<string> rightSide, bool hasHashSign)
        {
            if (type.StartsWith("?"))
            {
                if (type != "?" && type != "?_show_all_lists")
                {
                    //is a click on a system list: show it in output tab
                    try
                    {
                        string m = type.Substring(2);
                        List<string> a1 = Program.GetListOfStringsFromList(Program.databanks.GetFirst().GetIVariable(Globals.symbolCollection + m));
                        bool showList = true;
                        if (a1.Count > 5000)
                        {
                            DialogResult result = MessageBox.Show("Note: showing lists with more than 5000 items tends to freeze the \noutput tab. You may use \"list listfile " + m + " = #" + m + ";\" to put the list into an\nexternal file " + m + ".lst. \nProceed anyway?", "Show list", MessageBoxButtons.YesNo, MessageBoxIcon.None, MessageBoxDefaultButton.Button2, MessageBoxOptions.DefaultDesktopOnly);
                            if (result != DialogResult.Yes)
                            {
                                showList = false;
                            }
                        }
                        if (showList)
                        {
                            Gui.gui.tabControl1.SelectedTab = Gui.gui.tabPage2;
                            Program.Cls("output");
                            //run in thread ideally
                            foreach (string s in a1)
                            {
                                G.Writeln(s, ETabs.Output);
                            }
                        }
                    }
                    catch
                    {
                        G.Writeln2("*** ERROR: Failed to show list");
                        throw new GekkoException();
                    }
                }
                else
                {
                    
                }

            }  //end of if startswith("?")
            else
            {
                G.Writeln2("*** ERROR: Internal error #8794372264");
                throw new GekkoException();                
            }
            return;
        }

        public static bool IsLargeModel()
        {
            bool hasLargeModel = false;
            IVariable all = Program.databanks.GetFirst().GetIVariable(Globals.symbolCollection + "all");
            if (all != null && all.Type() == EVariableType.List)
            {
                if ((all as List).list.Count > 100) hasLargeModel = true; //more then 100 vars --> no printing of model lists here
            }            
            return hasLargeModel;
        }

        public static void WriteListItems(string m)
        {
            IVariable iv = null; Program.databanks.GetFirst().GetIVariable(Globals.symbolCollection + m);
            //Program.scalars.TryGetValue(Globals.symbolCollection + m, out iv);
            if (iv == null)
            {
                G.Writeln2("*** ERROR: List " + Globals.symbolCollection + m + " was not found");
                throw new GekkoException();
            }
            List<string> a1 = Program.GetListOfStringsFromList(iv);

            if (a1.Count == 0)
            {
                G.Writeln2("list #" + m + " = [null]");
            }
            else if(a1.Count < 100)
            {
                G.Writeln2("list #" + m + " = " + G.GetListWithCommas(a1) + "  (" + a1.Count + " elements)");
            }
            else
            {
                G.Write2("list #" + m + " = ["); G.WriteLink("show", "list:?_" + m); G.Writeln("]  (" + a1.Count + " elements from '" + a1[0] + "' to '" + a1[a1.Count - 1] + "')");
            }            
        }

        public static void GuiSetModelName()
        {
            if (Globals.workerThread != null)
            {
                //1.4.9 stuff
                string version = G.PrintVersion(Globals.gekkoVersion, false);
                string s1 = "";
                if (Globals.modelFileName == null || Globals.modelFileName == "")
                {
                    s1 = "Gekko " + version;  //this is what Word etc. does too
                }
                else
                {
                    s1 = Globals.modelFileName + " - " + "Gekko " + version;  //this is what Word etc. does too
                }
                Program.WorkerThreadHelper1 wh = new Program.WorkerThreadHelper1();
                wh.titleField = s1;
                Globals.workerThread.gekkoGui.Invoke(Globals.workerThread.gekkoGui.threadDelegateSetTitle, wh);
            }
        }

        public static void Model(O.Model o)
        {
            bool isGms = G.Equal(o.opt_gms, "yes");

            string fileName = o.fileName;
            P p = o.p;

            fileName = G.StripQuotes(fileName);

            //Random random = new Random();
            Globals.modelRandomID = Program.RandomInt(11111111, 99999999);  //used in GetModelInfoPath()

            string type = "frm";
            if (isGms) type = "gms";

            bool cancel = false;
            if (fileName == "*")
            {
                SelectFile(type, ref fileName, ref cancel);
                CrossThreadStuff.SetTextInput(fileName, "model");
            }
            if (cancel) return;

            DateTime dt0 = DateTime.Now;

            //fileName = SubstituteAssignVarsInExpression(fileName);
            fileName = AddExtension(fileName, "." + type);

            string fileNameSimple = fileName;

            List<string> folders = new List<string>();
            folders.Add(Program.options.folder_model); //looks here first, after looking in working folder
            fileName = FindFile(fileName, folders);  //calls CreateFullPathAndFileName()

            Globals.modelPathAndFileName = fileName;  //always contains a path
            Globals.modelFileName = Path.GetFileName(Globals.modelPathAndFileName);

            if (!File.Exists(fileName))
            {
                G.Writeln2("*** ERROR: Could not find file '" + fileNameSimple + "'.");
                throw new GekkoException();
            }

            string textInputRaw = Program.GetTextFromFileWithWait(fileName);  //textInputRaw is without any VARLIST$

            if (isGms)
            {
                GamsModel.ReadGamsModel(textInputRaw, fileName, o);
            }
            else
            {
                ReadGekkoModel(fileName, dt0, textInputRaw);
            }
        }

        private static void ReadGekkoModel(string fileName, DateTime dt0, string textInputRaw)
        {
            //TODO: keep the old version, so model command can be undone (like undo sim)
            Program.model = new Model();
            Program.model.modelGekko = new ModelGekko();
            Program.model.modelGekko.modelInfo.fileName = fileName;
            //this also creates Program.model.modelGekko.varlist if there is a varlist
            ModelCommentsHelper modelCommentsHelper = new ModelCommentsHelper();
            string textInput = Program.HandleModelFiles(textInputRaw, modelCommentsHelper);
            string mdlFileNameAndPath = Globals.localTempFilesLocation + "\\" + Globals.gekkoVersion + "_" + modelCommentsHelper.modelHashTrue + ".mdl";

            if (Program.options.model_cache == true)
            {
                if (File.Exists(mdlFileNameAndPath))
                {
                    ParserFrmGetProtobuf(fileName, mdlFileNameAndPath);
                }
            }
            else
            {
                Program.model.modelGekko.modelInfo.loadedFromMdlFile = false;
            }

            Program.model.modelGekko.modelInfo.date = modelCommentsHelper.dateText;
            Program.model.modelGekko.modelInfo.info = modelCommentsHelper.infoText;
            Program.model.modelGekko.signatureStatus = modelCommentsHelper.signatureStatus;
            Program.model.modelGekko.signatureFoundInFileHeader = modelCommentsHelper.signatureFoundInFileHeader;
            Program.model.modelGekko.modelHashTrue = modelCommentsHelper.modelHashTrue;

            string parsingSeconds = null;
            if (Program.model.modelGekko.modelInfo.loadedFromMdlFile)
            {
                //Needs to load lists into Program.list, and varlist too
                GuiSetModelName();
            }
            else
            {
                DateTime t1 = DateTime.Now;
                //ParseModel() is reasonably fast. But needs only to be run when new model is called.
                //[[1]]
                GekkoDictionary<string, string> vals = Parser.Frm.ParserFrmCreateAST.ParserFrmCreateASTHelper(textInput, fileName);
                //TIMING: the rest of this method takes 0.5 sec on dec09, that is nearly as much as parsing and CreateASTNodesForModel()
                //This loop below alone takes 0.5 seconds on dec09, but it also does all the stuff regarding
                //  formula codes DJZ, dlog() on left and right side, broken lags etc. etc. So maybe fair enough it
                //  takes some time. It also writes out actual C# code to be used later on when compiling.
                Parser.Frm.ParserFrmWalkAST.ParserFrmWalkASTHelper(vals);
                Program.GuiSetModelName();
                if (Program.model.modelGekko.largestLead != Program.model.modelGekko.largestLeadOutsideRevertedPart)
                {
                    G.Writeln2("*** ERROR: There is a lead [+" + Program.model.modelGekko.largestLead + "] in one of the X- or Y-equations that is larger than the largest");
                    G.Writeln("           lead elsewhere in the model [+" + Program.model.modelGekko.largestLeadOutsideRevertedPart + "]. Please use T-equations for such variables", Color.Red);
                    throw new GekkoException();
                }
                parsingSeconds = G.Seconds(t1);
                Parser.Frm.ParserFrmCompileAST.ParserFrmOrderAndCompileAST(ECompiledModelType.Gauss, true, false);  //default.
                Parser.Frm.ParserFrmCompileAST.ParserFrmMakeProtobuf();
            }

            Parser.Frm.ParserFrmCompileAST.ParserFrmHandleVarlist(modelCommentsHelper);

            if (!G.NullOrEmpty(modelCommentsHelper.cutout_runbefore))
            {
                Program.model.modelGekko.runBefore = modelCommentsHelper.cutout_runbefore;
            }

            if (!G.NullOrEmpty(modelCommentsHelper.cutout_runafter))
            {
                Program.model.modelGekko.runAfter = modelCommentsHelper.cutout_runafter;
            }

            Program.model.modelGekko.modelInfo.timeUsedParsing = parsingSeconds;
            Program.model.modelGekko.modelInfo.timeUsedTotal = G.Seconds(dt0);

            Program.model.modelGekko.modelInfo.Print();
        }

        private static void ParserFrmGetProtobuf(string fileName, string mdlFileNameAndPath)
        {
            try
            {
                DateTime dt1 = DateTime.Now;
                //May take a little time to create: so use static serializer if doing serialize on a lot of small objects
                //RuntimeTypeModel serializer = TypeModel.Create();
                //serializer.UseImplicitZeroDefaults = false;  //otherwise an int that has default constructor value -12345 but is set to 0 will reappear as a -12345 (instead of 0). For int, 0 is default, false for bools etc.
                // ----- DESERIALIZE
                //DeleteFolder(outputPath);
                //Directory.CreateDirectory(outputPath);
                //WaitForZipRead(outputPath, mdlFileNameAndPath);
                using (FileStream fs = WaitForFileStream(mdlFileNameAndPath, GekkoFileReadOrWrite.Read))
                {
                    Program.model.modelGekko = Serializer.Deserialize<ModelGekko>(fs);
                }

                GetListsFromModelListHelper();

                //=============================================
                //FOR SAFETY: see mail from TKD 5/3 2013
                Program.model.modelGekko.simulateResults = new double[10];
                //=============================================

                G.WritelnGray("Loaded known model from cache in: " + G.SecondsFormat((DateTime.Now - dt1).TotalMilliseconds));
                Program.model.modelGekko.modelInfo.loadedFromMdlFile = true;
                Program.model.modelGekko.modelInfo.fileName = fileName;  //otherwise the filename will be the file used when the cache-file was made (these are often equal of course, but not always).
            }
            catch (Exception e)
            {
                if (G.IsUnitTesting())
                {
                    throw;
                }
                else
                {
                    //do nothing, we then have to parse the file
                    Program.model.modelGekko.modelInfo.loadedFromMdlFile = false;
                }
            }
        }

        
        
        

        public static string DecompGetNameFromContrib(string s)
        {
            string[] ss = s.Split('¤');
            string ss1 = G.Chop_RemoveBank(ss[0]);
            string ss5 = ss1;
            if (ss.Length > 1) ss5 = ss1 + "¤" + ss[1];
            return ss5;
        }

        public static void CallEval(string conditionals, string statement)
        {
            string c = null;
            if (!G.NullOrEmpty(conditionals))
            {
                c = "$ (" + conditionals + ")";
            }
            string s = c + " = " + statement;
            Program.RunCommandCalledFromGUI("VAR_KDUSJFLQO2 deleteme " + s, new P()); //produces Func<> Globals.expression with the expression 
            
        }

        
        public static void GetLhsVariable(TokenHelper node, ref string lhs)
        {            

            if (lhs != null) return;  //found the lhs
            
            if (node.HasNoChildren())
            {
                //not a sub-node, do nothing             
            }
            else
            {
                //an empty node with children
                string lineText = null;
                for (int ii = 0; ii < node.subnodes.Count(); ii++)
                {
                    string varname = null;

                    bool dollar = false;
                    TokenHelper previous = node.subnodes[ii].SiblingBefore();  //it seems dollars are only in the eq, not set on the lhs variable
                    if (previous != null && previous.s == "$")
                    {
                        dollar = true;
                    }

                    if (!dollar)  //we skip looking at variables, if it is like x $ ... or x $ (...)
                    {

                        if (node.subnodes[ii].HasChildren())
                        {
                            if (node.subnodes[ii].SubnodesType(false) == "(")
                            {
                                //will not look deeper into [...], or later on {...}, only (...)
                                GetLhsVariable(node.subnodes[ii], ref lhs);
                            }
                        }
                        else
                        {

                            if (node.subnodes[ii].type == ETokenType.Word)
                            {
                                varname = node.subnodes[ii].ToStringTrim();
                                lineText = node.subnodes[ii].LineAndPosText();

                                TokenHelper next = node.subnodes[ii].SiblingAfter();
                                if (IsLaggedOrLeaded(node.subnodes[ii]))  //will detect x[#i][-1] + y = ... for instance
                                {
                                    varname = null;
                                }
                                else if (next != null && next.HasChildren() && next.SubnodesType() == "(")  //will detect log(x) + y = ... , not thinking "log" is a variable
                                {
                                    varname = null;  //function name
                                }
                                else if (node.subnodes[ii].leftblanks == 0 && previous != null && (previous.s == "#" || previous.s == "%"))
                                {
                                    //name like #x or %x. This will probably not happen, since from gauss such a var will be a #i,
                                    //and the #i will be inside [...] or $ (...)
                                    varname = null;
                                }
                            }
                        }
                    }

                    if (lhs == null && G.IsSimpleToken(varname))
                    {                        
                        lhs = varname;  //only if lhs is not already found, and if the name is a token
                    }
                }                
            }

        }

        

        private static bool IsLaggedOrLeaded(TokenHelper x)
        {
            bool lagLead = false;
            if (Program.options.model_gams_dep_current) return false;  //even if it is x[-1] or x[+1], a false will be returned.
            TokenHelper next = x.SiblingAfter();
            if (next != null && next.SubnodesType() == "[")
            {
                TokenHelper next2 = next.SiblingAfter();
                if (next2 != null && next2.SubnodesType() == "[")
                {
                    //Something like x[a, #i, b][-1]
                    bool lagLead2 = IsLagOrLeadBracket(next2);
                    if (lagLead2) lagLead = true;
                }
                else
                {
                    //Something like x[-1]
                    bool lagLead2 = IsLagOrLeadBracket(next);
                    if (lagLead2) lagLead = true;
                }
            }
            return lagLead;
        }

        private static bool IsLagOrLeadBracket(TokenHelper next2)
        {
            bool lagLead = false;
            List<TokenHelperComma> split = next2.SplitCommas(true);
            if (split.Count == 1)
            {
                string ss = split[0].list.ToString();
                if ((ss.StartsWith("-") || ss.StartsWith("+")) && G.IsInteger(ss, true, false))  //x[-1] or x[+1]
                {
                    lagLead = true;
                }
            }
            return lagLead;
        }        

        private static void GetListsFromModelListHelper()
        {
            string[] lists = new string[] { "all", "endo", "exo", "exod", "exodjz", "exoj", "exotrue", "exoz" };
            foreach (string s in lists)
            {
                if (Program.databanks.GetGlobal().ContainsIVariable(Globals.symbolCollection + s)) Program.databanks.GetGlobal().RemoveIVariable(Globals.symbolCollection + s);
            }

            if (Program.model.modelGekko.modelInfo.modelListHelper.all != null) Program.databanks.GetGlobal().AddIVariable(Globals.symbolCollection + "all", new List(Program.GetListOfIVariablesFromListOfStrings(Program.model.modelGekko.modelInfo.modelListHelper.all.ToArray())));
            else Program.databanks.GetGlobal().AddIVariable(Globals.symbolCollection + "all", new List());

            if (Program.model.modelGekko.modelInfo.modelListHelper.endo != null) Program.databanks.GetGlobal().AddIVariable(Globals.symbolCollection + "endo", new List(Program.GetListOfIVariablesFromListOfStrings(Program.model.modelGekko.modelInfo.modelListHelper.endo.ToArray())));
            else Program.databanks.GetGlobal().AddIVariable(Globals.symbolCollection + "endo", new List());

            if (Program.model.modelGekko.modelInfo.modelListHelper.exo != null) Program.databanks.GetGlobal().AddIVariable(Globals.symbolCollection + "exo", new List(Program.GetListOfIVariablesFromListOfStrings(Program.model.modelGekko.modelInfo.modelListHelper.exo.ToArray())));
            else Program.databanks.GetGlobal().AddIVariable(Globals.symbolCollection + "exo", new List());

            if (Program.model.modelGekko.modelInfo.modelListHelper.exod != null) Program.databanks.GetGlobal().AddIVariable(Globals.symbolCollection + "exod", new List(Program.GetListOfIVariablesFromListOfStrings(Program.model.modelGekko.modelInfo.modelListHelper.exod.ToArray())));
            else Program.databanks.GetGlobal().AddIVariable(Globals.symbolCollection + "exod", new List());

            if (Program.model.modelGekko.modelInfo.modelListHelper.exodjz != null) Program.databanks.GetGlobal().AddIVariable(Globals.symbolCollection + "exodjz", new List(Program.GetListOfIVariablesFromListOfStrings(Program.model.modelGekko.modelInfo.modelListHelper.exodjz.ToArray())));
            else Program.databanks.GetGlobal().AddIVariable(Globals.symbolCollection + "exodjz", new List());

            if (Program.model.modelGekko.modelInfo.modelListHelper.exoj != null) Program.databanks.GetGlobal().AddIVariable(Globals.symbolCollection + "exoj", new List(Program.GetListOfIVariablesFromListOfStrings(Program.model.modelGekko.modelInfo.modelListHelper.exoj.ToArray())));
            else Program.databanks.GetGlobal().AddIVariable(Globals.symbolCollection + "exoj", new List());

            if (Program.model.modelGekko.modelInfo.modelListHelper.exotrue != null) Program.databanks.GetGlobal().AddIVariable(Globals.symbolCollection + "exotrue", new List(Program.GetListOfIVariablesFromListOfStrings(Program.model.modelGekko.modelInfo.modelListHelper.exotrue.ToArray())));
            else Program.databanks.GetGlobal().AddIVariable(Globals.symbolCollection + "exotrue", new List());

            if (Program.model.modelGekko.modelInfo.modelListHelper.exoz != null) Program.databanks.GetGlobal().AddIVariable(Globals.symbolCollection + "exoz", new List(Program.GetListOfIVariablesFromListOfStrings(Program.model.modelGekko.modelInfo.modelListHelper.exoz.ToArray())));
            else Program.databanks.GetGlobal().AddIVariable(Globals.symbolCollection + "exoz", new List());
                        
            Program.model.modelGekko.modelInfo.modelListHelper = null;  //only used for temporary transfer of these lists
        }

        public static string AddExtension(string fileName, string ending)
        {
            if (Path.GetExtension(fileName) == "") fileName += ending;  //ignore case
            return fileName;
        }

        public static void Pipe(O.Pipe o)
        {
            //This is where we start when issuing a PIPE
            //We call the older version below, the PIPE interface mess should be cleaned up at some point...
            List<string> temp = new List<string>();
            if (G.Equal(o.opt_append, "yes")) temp.Add("append");
            if (G.Equal(o.opt_html, "yes")) temp.Add("html");
            if (G.Equal(o.opt_pause, "yes")) temp.Add("pause");
            if (G.Equal(o.opt_continue, "yes")) temp.Add("continue");
            if (G.Equal(o.opt_stop, "yes")) temp.Add("stop");
            Pipe(o.fileName, temp);
        }

        public static void Pipe(string fileName, List<string> args)
        {
            Pipe(fileName, args, false);
        }

        public static void Pipe(string fileName, List<string> args, bool mute)  //mute used for closeall
        {
            bool append = false;
            bool html = false;
            bool stop = false;
            bool pause = false;
            bool continue2 = false;

            if (args != null)
            {
                foreach (string s in args)
                {
                    if (G.Equal(s, "append")) append = true;
                    else if (G.Equal(s, "html")) html = true;
                    else if (G.Equal(s, "stop")) stop = true;
                    else if (G.Equal(s, "pause")) pause = true;
                    else if (G.Equal(s, "continue")) continue2 = true;
                }
            }

            fileName = G.StripQuotes(fileName);
            //NOTE: If there is an error, Globals.pipeFile will be closed and disposed somewhere else in the
            //      code. So no need to think about using an "using" statement here.    
            
            if(pause && fileName!=null)
            {
                G.Writeln2("*** ERROR: You should use PIPE<pause> without a filename");
                throw new GekkoException();
            }

            if (continue2 && fileName != null)
            {
                G.Writeln2("*** ERROR: You should use PIPE<continue> without a filename");
                throw new GekkoException();
            }

            if (G.Equal(fileName, "con") || stop)   //PIPE con, or PIPE<stop>
            {
                if (Globals.pipe == false)
                {
                    if (!mute)
                    {
                        G.Writeln("+++ WARNING: you are not currently piping output to a file. Command ignored.");
                        if (G.Equal(fileName, "con")) G.Writeln("+++ WARNING: please use PIPE<stop> instead of PIPE con");
                    }
                }
                else
                {
                    if (Globals.pipeFileHelper.pipeFile != null)
                    {
                        Globals.pipeFileHelper.CloseFile();
                    }
                    Globals.pipe = false;
                    Globals.pipeFileHelper.pipeFile = null;
                    Globals.pipeFileHelper.pipeFileFileWithPath = "";
                    if (!mute)
                        G.Writeln2("Directing output to main window");
                    if (G.Equal(fileName, "con"))
                        G.Writeln("+++ WARNING: please use PIPE<stop> instead of PIPE con");
                }
            }
            else if(pause)
            {
                
                Globals.pipe = false;
            }
            else if(continue2)
            {
                
                Globals.pipe = true;
            }
            else
            {
                //piping to a file

                try
                {
                    fileName = CreateFullPathAndFileNameFromFolder(fileName, Program.options.folder_pipe);

                    if (Globals.pipe == true)
                    {
                        if (G.Equal(Globals.pipeFileHelper.pipeFileFileWithPath, fileName))
                        {
                            //already pipe to present pipefile
                            //just ignore it with no message: the message will end up in the pipefile                            
                        }
                        else
                        {
                            if (Globals.pipeFileHelper.pipeFile != null)
                            {
                                Globals.pipeFileHelper.CloseFile();
                            }
                            StartPipingToFile(fileName, append, html, mute);
                        }
                    }
                    else
                    {
                        StartPipingToFile(fileName, append, html, mute);
                    }
                }
                catch (Exception e)
                {
                    Globals.pipe = false;
                    MessageBox.Show("*** ERROR: Could not write to file '" + fileName + "'");
                    throw new GekkoException();
                }
                Globals.pipe = true;

            }
        }

        private static void StartPipingToFile(string fileName, bool append, bool html, bool mute)
        {
            if (!mute && !Globals.pipe) G.Writeln2("Directing output to file: '" + fileName + "'");
            Globals.pipe = true;
            GekkoFileReadOrWrite option = GekkoFileReadOrWrite.Write;

            bool exists = false; if (File.Exists(fileName)) exists = true;

            bool mustDeleteFileFirst = false;
            string s1 = null;
            string s2 = null;
            if (html)
            {
                string css = "";
                //a fresh html file is made
                css = GetHtmlHeaderCssStyles();
                s1 = Globals.htmlFileStart1 + css + Globals.htmlFileStart2;
                s2 = Globals.htmlFileEnd;
                if (append && exists)
                {
                    mustDeleteFileFirst = true;
                    string s = GetTextFromFileWithWait(fileName);
                    if (s.Contains(Globals.htmlGekkoCommentary)) css = "";  //no need to duplicate
                    AddHtmlToExistingHtml(ref s1, ref s2, css, s);
                }
                else
                {
                    //then we will just use the simple empty html, since there is no file to append to.
                    //this behavior is equivalent to txt files.
                }
            }
            if (mustDeleteFileFirst)  //if html && append && exists
            {
                WaitForFileDelete(fileName);
            }

            if (append && exists && !mustDeleteFileFirst) option = GekkoFileReadOrWrite.WriteAppend;  //only for append in text files, html will have will have mustDeleteFileFirst = true. Should be ok if the file does not exist, then it is just created with no warning issued

            FileStream fs = WaitForFileStream(fileName, option);
            Globals.pipeFileHelper.pipeFile = G.GekkoStreamWriter(fs);
            Globals.pipeFileHelper.pipeFileTypeIsHtml = html;
            Globals.pipeFileHelper.pipeFileFileWithPath = fileName;
            if (html)
            {
                Globals.pipeFileHelper.pipeFile.Write(s1);  //this is the case if it is a html file, then we write the original content up until the </body> tag
                Globals.pipeFileHelper.htmlEndingTagsStuff = s2;
            }
        }                

        private static void AddHtmlToExistingHtml(ref string s1, ref string s2, string css, string s)
        {
            int i = s.IndexOf("</body>", StringComparison.OrdinalIgnoreCase);
            if (i == -1)
            {
                G.Writeln2("*** ERROR: Could not find </body> tag in the html file.");
                throw new GekkoException();
            }
            ChopString(out s1, out s2, s, i);
            //new we have:
            //
            //s1 = <html> <body>
            //s2 = </body> </html>
            //
            //or
            //
            //s1 = <html> <head> </head> <body>
            //s2 = </body> </html>
            int j = s1.IndexOf("</head>", StringComparison.OrdinalIgnoreCase);
            if (j == -1)
            {
                //add a <head>...</head> section with css inside
                int k = s1.IndexOf("<body>", StringComparison.OrdinalIgnoreCase);
                if (k == -1)
                {
                    G.Writeln2("*** ERROR: No <body> tag found in html file");
                    throw new GekkoException();
                }
                string s1a, s1b;
                ChopString(out s1a, out s1b, s1, k);
                s1 = s1a + css + s1b;
            }
            else
            {
                //inject css into existing <head>...</head> section
                //multiple <style> sections are allowed in <head>
                string s1a, s1b;
                ChopString(out s1a, out s1b, s1, j);
                s1 = s1a + css + s1b;
            }
        }

        private static void ChopString(out string s1, out string s2, string s, int i)
        {
            s1 = s.Substring(0, i);
            s2 = s.Substring(i, s.Length - i);
        }

        private static string GetHtmlHeaderCssStyles()
        {
            StringBuilder lines = new StringBuilder();
            lines.AppendLine("<style type=\"text/css\">");
            lines.AppendLine("<!-- " + Globals.htmlGekkoCommentary + " -->");
            lines.AppendLine("  td.w {}");  //lines.AppendLine("  td.w {width:4.5em;}");
            lines.AppendLine("  td.c {text-align: center;}");
            lines.AppendLine("  td.ws {white-space:nowrap;}");
            lines.AppendLine("  td.blue {background-color: rgb(174,199,225);}");
            lines.AppendLine("  td.pad {padding:0.1em 0.50em;}");
            lines.AppendLine("  td.top {border-top: 1px solid black;}");
            lines.AppendLine("  td.bottom {border-bottom: 1px solid black;}");
            lines.AppendLine("  td.left {border-left: 1px solid black;}");
            lines.AppendLine("  td.right {border-right: 1px solid black;}");
            lines.AppendLine("  td.rightlg {border-right: 1px solid lightgray;}");
            lines.AppendLine("  .gfsize {font-size: " + Program.options.table_html_fontsize + "%;}");
            lines.AppendLine("  .gfont { font-family: " + Program.options.table_html_font + " }");
            lines.AppendLine("  a { color: #0645AD; text-decoration: none; }");  //Wikipedia link color
            lines.AppendLine("  a:hover { text-decoration: underline; }");
            lines.AppendLine("</style>");
            string s = lines.ToString();
            return s;
        }

        public static void ConvertPrn(string fileName)
        {
            //Maybe merge better with READ/OPEN/MULBK, so READ<prn> is possible.
            //fileName = Program.SubstituteAssignVarsInExpression(fileName);
            fileName = Program.AddExtension(fileName, "." + "prn");
            List<string> folders = new List<string>();
            string fileNameTemp = Program.FindFile(fileName, folders);
            string prnFile = GetTextFromFileWithWait(fileNameTemp);
            List<string> listFile2 = G.ExtractLinesFromText(prnFile);

            if (fileNameTemp.ToLower().EndsWith(".prn"))
            {
                string fileNameCsv = fileNameTemp.Substring(0, fileNameTemp.Length - 4) + ".csv";
                List<string> lines2 = new List<string>();
                bool first = true;
                StringBuilder sb = new StringBuilder();
                foreach (string s in listFile2)
                {
                    if (s.Trim() == "") continue;  //ignore empty lines
                    string[] split = s.Split(new char[] { ' ' }, StringSplitOptions.RemoveEmptyEntries);  //could be variable name with blank such as "ab cd" or something to trim like " abcd", but that is strange/wrong anyway!
                    foreach (string ss in split)
                    {
                        string ss2 = ss.Trim();  //probably superfluous
                        if (ss2.StartsWith("\""))
                        {
                            if (!ss2.EndsWith("\""))
                            {
                                G.Writeln2("*** ERROR: item '" + ss2 + "' seems malformed");
                                throw new GekkoException();
                            }
                            ss2 = ss2.Substring(1, ss2.Length - 2);
                            if (ss2.Contains("\""))
                            {
                                G.Writeln2("*** ERROR: item '\"" + ss2 + "\"' seems malformed");
                                throw new GekkoException();
                            }
                        }
                        string s3 = "";
                        if (first)
                        {
                            if (G.Equal(ss2, "date")) s3 = "";  //remove it
                            if (G.Equal(ss2, "name")) s3 = "";  //remove it
                        }
                        else s3 = ss2;
                        first = false;
                        sb.Append(s3 + ";");
                    }
                    sb.AppendLine();
                }

                using (FileStream fs = Program.WaitForFileStream(fileNameCsv, Program.GekkoFileReadOrWrite.Write))
                using (StreamWriter sw = G.GekkoStreamWriter(fs))
                {
                    sw.Write(sb);
                    sw.Flush();
                    sw.Close();
                }
                G.Writeln2("Converted PRN file '" + fileNameTemp + "' into");
                G.Writeln("CSV file '" + fileNameCsv + "'.");
                G.Writeln("You may use READ<csv cols> or READ<csv cols merge> to read it.");
            }
            else
            {
                G.Writeln2("*** ERROR: Internal error while converting prn file");
                throw new GekkoException();
            }
        }        

        // ===========================
        // qwerty TO HERE
        // ===========================

        private static string ReadHelper(string fileName, ref bool cancel, string extension)
        {
            string rv = null;
            if (fileName == "*")
            {
                SelectFile(extension, ref fileName, ref cancel);
                //string type = "open";
                //if (!open)
                //{
                //    type = "read";
                //    if (isBase) type = "mulbk";
                //}
                CrossThreadStuff.SetTextInput(fileName, null);
            }
            else
            {                
                fileName = AddExtension(fileName, "." + extension);
                List<string> folders = new List<string>();
                folders.Add(Program.options.folder_bank);
                folders.Add(Program.options.folder_bank1);
                folders.Add(Program.options.folder_bank2);
                fileName = FindFile(fileName, folders);
                
            }
            return fileName;
        }

        private static string FileNotFoundErrorMessage(string fileName)
        {
            string s = "*** ERROR: Could not read file '" + fileName + "' -- the file does not seem to exist";
            G.Writeln2(s);

            if (Program.options.folder == false)
            {
                G.Writeln("           Please note that 'option folder' is set to false -- so Gekko does not");
                G.Writeln("           search for the file in other folders than the working folder.");
            }
            return s;
        }

        public static string FindFile(string fileName, List<string> folders)
        {
            return FindFile(fileName, folders, true);
        }

        public static string FindFile(string fileName, List<string> folders, bool includeWorkingFolder)
        {
            string fileNameTemp = null;
            string fileNameWorkingFolder = CreateFullPathAndFileName(fileName);
            if (includeWorkingFolder && File.Exists(fileNameWorkingFolder))
            {
                fileNameTemp = fileNameWorkingFolder;
            }
            else
            {
                if (Program.options.folder)
                {
                    //allowed to search in folders
                    foreach (string folder in folders)
                    {
                        //when folder is "", shouldn't it just skip to next? For "", the result will be the working folder...?
                        //as long as working folder is always king, this is not an issue.
                        string fileNameFolder = CreateFullPathAndFileNameFromFolder(fileName, folder);
                        if (File.Exists(fileNameFolder))
                        {
                            fileNameTemp = fileNameFolder;
                            break; //no more searching
                        }
                    }
                }
                else fileNameTemp = null;  //not allowed to search in folders
            }
            return fileNameTemp;
        }

        public static void SelectFile(string type, ref string fileName, ref bool cancel)
        {
            string dataFile = "";
            System.Windows.Forms.OpenFileDialog openFileDialog1 = new System.Windows.Forms.OpenFileDialog();
            openFileDialog1.InitialDirectory = Program.options.folder_working;
            openFileDialog1.Filter = type + " files (*." + type + ")|*." + type + "|All files (*.*)|*.*";
            openFileDialog1.FilterIndex = 1;
            //openFileDialog1.RestoreDirectory = true;
            if (openFileDialog1.ShowDialog() == DialogResult.OK)
            {
                try
                {
                    if ((openFileDialog1.OpenFile()) != null)
                    {
                        dataFile = openFileDialog1.FileName;
                    }
                }
                catch (Exception ex)
                {
                    MessageBox.Show("Error: Could not read file from disk. Original error: " + ex.Message);
                    throw new GekkoException();
                }
            }
            else
            {
                cancel = true;
            }

            if (!cancel)
            {
                if (dataFile == "")
                {
                    G.Writeln2("*** ERROR while reading " + type + " file");
                    throw new GekkoException();
                }
                //string dir = Path.GetDirectoryName(dataFile);
                //string tsdOutputFile = dir + Path.DirectorySeparatorChar + "output.tsd";
                fileName = dataFile;
            }
        }

        public static void Res(O.Res o)
        {
            //ErrorIfDatabanksSwapped();
            SolveCommon.Res(o.t1, o.t2);
        }

        public static void Trimvars()
        {
            //ErrorIfDatabanksSwapped();
            if (!G.HasModelGekko())
            {
                G.Writeln2("*** ERROR: No model is defined for trimming, cf. MODEL command.");
                throw new GekkoException();
            }

            List<Databank> banks = new List<Databank> { Program.databanks.GetFirst(), Program.databanks.GetRef() };

            G.Writeln();
            foreach (Databank bank in banks)
            {
                List<string> onlyDatabankNotModel = new List<string>();
                foreach (KeyValuePair<string, IVariable> s in bank.storage)
                {
                    if (s.Value.Type() != EVariableType.Series) continue;
                    if (G.GetFreqFromName(s.Key) != Program.options.freq) continue;  //filter out other freqs
                    string s2 = G.Chop_RemoveFreq(s.Key);                    
                    if (!Program.model.modelGekko.varsAType.ContainsKey(s2))
                    {
                        onlyDatabankNotModel.Add(s2);
                    }
                }

                int c = 0;
                foreach (string s in onlyDatabankNotModel)
                {
                    string ss = s + Globals.freqIndicator + G.GetFreq(Program.options.freq);
                    if (bank.ContainsIVariable(ss))
                    {
                        bank.RemoveIVariable(ss);
                        c++;
                    }
                }
                G.Writeln2("Removed " + c + " variable(s) in '" + bank.name + "' databank");
            }
        }

        public static void FindMissingData(O.Findmissingdata o)
        {
            GekkoTime tStart = o.t1;
            GekkoTime tEnd = o.t2;
            
            List vars2 = O.Restrict2(o.names, false, false, false, false);   //only allows plain vars (idents)
            List<ToFrom> vars = null;
            if (vars2 != null) vars = SearchFromTo(vars2, null, null, null, EWildcardSearchType.Search, null);
                        
            //GekkoTime tStart, tEnd; ConvertToGekkoTime(tp, out tStart, out tEnd);

            //vars = UnfoldLists(vars);

            bool replace = true;
            if (double.IsNaN(o.opt_replace)) replace = false;

            bool hasFilter = false;
            bool hasModel = false;

            Databank work = Program.databanks.GetFirst();

            Dictionary<string, string> exod = null;
            Dictionary<string, string> exoj = null;
            Dictionary<string, string> exoz = null;
            Dictionary<string, string> exodjz = null;
            Dictionary<string, string> exo = null;
            Dictionary<string, string> exotrue = null;
            Dictionary<string, string> endo = null;
            Dictionary<string, string> all = null;

            if (!replace)
            {
                exod = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
                exoj = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
                exoz = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
                exodjz = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
                exo = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
                exotrue = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
                endo = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
                all = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
            }

            if (!G.HasModelGekko() || replace)
            {
            }
            else
            {
                hasModel = true;
                try
                {
                    foreach (string s in Program.GetListOfStringsFromListOfIvariables(((List)O.GetIVariableFromString("global:" + Globals.symbolCollection + "exod", O.ECreatePossibilities.NoneReturnNull)).list.ToArray()))
                        exod.Add(s, "");
                    foreach (string s in Program.GetListOfStringsFromListOfIvariables(((List)O.GetIVariableFromString("global:" + Globals.symbolCollection + "exoj", O.ECreatePossibilities.NoneReturnNull)).list.ToArray()))
                        exoj.Add(s, "");
                    foreach (string s in Program.GetListOfStringsFromListOfIvariables(((List)O.GetIVariableFromString("global:" + Globals.symbolCollection + "exoz", O.ECreatePossibilities.NoneReturnNull)).list.ToArray()))
                        exoz.Add(s, "");
                    foreach (string s in Program.GetListOfStringsFromListOfIvariables(((List)O.GetIVariableFromString("global:" + Globals.symbolCollection + "exodjz", O.ECreatePossibilities.NoneReturnNull)).list.ToArray()))
                        exodjz.Add(s, "");
                    foreach (string s in Program.GetListOfStringsFromListOfIvariables(((List)O.GetIVariableFromString("global:" + Globals.symbolCollection + "exo", O.ECreatePossibilities.NoneReturnNull)).list.ToArray()))
                        exo.Add(s, "");
                    foreach (string s in Program.GetListOfStringsFromListOfIvariables(((List)O.GetIVariableFromString("global:" + Globals.symbolCollection + "exotrue", O.ECreatePossibilities.NoneReturnNull)).list.ToArray()))
                        exotrue.Add(s, "");
                    foreach (string s in Program.GetListOfStringsFromListOfIvariables(((List)O.GetIVariableFromString("global:" + Globals.symbolCollection + "endo", O.ECreatePossibilities.NoneReturnNull)).list.ToArray()))
                        endo.Add(s, "");
                    foreach (string s in Program.GetListOfStringsFromListOfIvariables(((List)O.GetIVariableFromString("global:" + Globals.symbolCollection + "all", O.ECreatePossibilities.NoneReturnNull)).list.ToArray()))
                        all.Add(s, "");
                }
                catch { };  //if error, we just ignore it, and the list will be empty.
            }

            Dictionary<string, string> filter = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);

            //exod
            //exoj
            //exoz
            //exodjz
            //exo
            //exotrue
            //endo
            //all
            //work

            List<string> missing_exod = null;
            List<string> missing_exoj = null;
            List<string> missing_exoz = null;
            List<string> missing_exodjz = null;
            List<string> missing_exo = null;
            List<string> missing_exotrue = null;
            List<string> missing_endo = null;
            List<string> missing_all = null;
            List<string> missing_ = null;

            if (!replace)
            {
                missing_exod = new List<string>();
                missing_exoj = new List<string>();
                missing_exoz = new List<string>();
                missing_exodjz = new List<string>();
                missing_exo = new List<string>();
                missing_exotrue = new List<string>();
                missing_endo = new List<string>();
                missing_all = new List<string>();  //every variable in model
                missing_ = new List<string>();   //every model i work databank (this typically includes the "all" set, because the READ statement auto-creates model variables if they are not in the databank)
            }

            if (vars != null)  //if filter is set
            {
                hasFilter = true;
                foreach (ToFrom tf in vars)
                {
                    filter.Add(tf.s1, "");  //we are just using the keys, not values, therefore ""
                }
            }

            foreach(KeyValuePair<string, IVariable>kvp in work.storage) 
            //all variables in work databank
            //foreach (string ss in work.storage.Keys)
            {
                if (kvp.Value.Type() != EVariableType.Series) continue;
                string ss =  kvp.Key;                
                if (G.GetFreqFromName(ss) != Program.options.freq) continue;  //we filter out other freqs
                string s = G.Chop_RemoveFreq(ss);

                if (hasFilter)
                {
                    if (!filter.ContainsKey(s)) continue;  //ignore this
                }
                Series ts = kvp.Value as Series;
                //Series ts = work.GetVariable(s);  //can this not be moved before loop??  //#getvar

                List<Series> l = new List<Series>();
                List<string> n = new List<string>();

                if (ts.type == ESeriesType.ArraySuper)
                {
                    foreach (KeyValuePair<MapMultidimItem, IVariable> kvpsub in ts.dimensionsStorage.storage)
                    {
                        Series sub = kvpsub.Value as Series;
                        l.Add(sub);
                        n.Add(sub.GetNameWithoutCurrentFreq(true));
                    }
                }
                else
                {
                    l.Add(ts);
                    n.Add(s);
                }

                for (int i = 0; i < l.Count; i++)
                {

                    foreach (GekkoTime t in new GekkoTimeIterator(tStart, tEnd))
                    {
                        double value = l[i].GetDataSimple(t);
                        if (G.isNumericalError(value))
                        {
                            if (replace)
                            {
                                l[i].SetData(t, o.opt_replace);
                            }
                            else
                            {
                                missing_.Add(n[i]);  //always put it in this list
                                if (exod.ContainsKey(n[i])) missing_exod.Add(s);
                                if (exoj.ContainsKey(n[i])) missing_exoj.Add(s);
                                if (exoz.ContainsKey(n[i])) missing_exoz.Add(s);
                                if (exodjz.ContainsKey(n[i])) missing_exodjz.Add(s);
                                if (exo.ContainsKey(n[i])) missing_exo.Add(s);
                                if (exotrue.ContainsKey(n[i])) missing_exotrue.Add(s);
                                if (endo.ContainsKey(n[i])) missing_endo.Add(s);
                                if (all.ContainsKey(n[i])) missing_all.Add(s);
                                break;  //one is enough
                            }
                        }
                    }
                }
            }

            if (!replace)
            {

                Dictionary<string, List<string>> names = new Dictionary<string, List<string>>(StringComparer.OrdinalIgnoreCase);
                names.Add("missingdata_", missing_);  //this one is a bit special
                names.Add("missingdata_exod", missing_exod);
                names.Add("missingdata_exoj", missing_exoj);
                names.Add("missingdata_exoz", missing_exoz);
                names.Add("missingdata_exodjz", missing_exodjz);
                names.Add("missingdata_exo", missing_exo);
                names.Add("missingdata_exotrue", missing_exotrue);
                names.Add("missingdata_endo", missing_endo);
                names.Add("missingdata_all", missing_all);

                List<string> names2 = new List<string>();
                names2.Add("missingdata_");
                if (hasModel)
                {
                    names2.Add("missingdata_all");
                    names2.Add("missingdata_endo");
                    names2.Add("missingdata_exotrue");
                    names2.Add("missingdata_exo");
                    names2.Add("missingdata_exodjz");
                    names2.Add("missingdata_exod");
                    names2.Add("missingdata_exoj");
                    names2.Add("missingdata_exoz");
                }

                G.Writeln();
                G.Writeln("------------------------ Report: Find missing data -------------------------------");
                G.Writeln();
                if (!G.HasModelGekko())
                {
                    G.Writeln();
                    G.Writeln("No model seems to be loaded -- result cannot be split into exogenous, endogenous etc. variables");
                    G.Writeln();
                }

                foreach (string n2 in names2)
                {
                    List<string> list = names[n2];
                    string listname = n2;
                    if (listname == "missingdata_") listname = "missingdata";

                    if (true)
                    {
                        //if (Program.databanks.GetFirst().ContainsIVariable(Globals.symbolCollection + listname))
                        //{
                        //    Program.databanks.GetFirst().RemoveIVariable(Globals.symbolCollection + listname);
                        //}

                        //if (Program.scalars.ContainsKey(Globals.symbolCollection+ listname))
                        //{
                        //    Program.scalars.Remove(Globals.symbolCollection + listname);
                        //}
                        list.Sort();
                        Program.databanks.GetFirst().AddIVariableWithOverwrite(Globals.symbolCollection + listname, new List(list));
                        //Program.scalars.Add(Globals.symbolCollection + listname, new List(list));
                        if (list.Count > 0)
                        {
                            string v = "variables";
                            if (list.Count == 1) v = "variable";
                            G.Writeln("List #" + listname + " has " + list.Count + " " + v + ":");
                            G.PrintListWithCommas(list, false);
                            G.Writeln();
                        }
                        else
                        {
                            G.Writeln("List #" + listname + " is empty");
                            G.Writeln();
                        }
                    }
                }
                G.Writeln("------------------------ Report end ----------------------------------------------");
                G.Writeln();
                G.Writeln();
            }
        }        

        

        //See #98745239543
        public static YesNoNull GetYesNoNullLocalOption(string opt)
        {
            YesNoNull rv = YesNoNull.Null;
            if (opt == null) rv = YesNoNull.Null;
            else if (G.Equal(opt, "yes")) rv = YesNoNull.Yes;
            else if (G.Equal(opt, "no")) rv = YesNoNull.No;
            else
            {
                G.Writeln2("*** ERROR: Expected 'yes' or 'no', not '" + opt + "'");
                throw new GekkoException();
            }
            return rv;
        }


        public static void Itershow(List<string> vars, GekkoTime t1, GekkoTime t2)
        {
            if (!G.HasModelGekko())
            {
                G.Writeln2("*** ERROR: No model seems to be defined, see MODEL command.");
                throw new GekkoException();
            }

            //List<string> vars = UnfoldLists(varsInput);

            bool hasContent = false;

            //GekkoTime t1, t2; ConvertToGekkoTime(time, out t1, out t2);

            Table tab = new Table();
            int row = 1;

            List<string> problems = new List<string>();

            foreach (string var in vars)
            {
                bool hasDifference = false;
                foreach (GekkoTime t in new GekkoTimeIterator( t1, t2))
                {
                    int rowYearStart = row;
                    List<IterMemory> iterMemories = null;
                    if (Program.model.modelGekko.bMemory.ContainsKey(t.ToString()))
                    {
                        iterMemories = Program.model.modelGekko.bMemory[t.ToString()];
                    }
                    else
                    {
                        G.Writeln("There were no recorded iterations in memory regarding period " + t.ToString());
                        continue;
                    }

                    hasContent = true;

                    tab.Set(row, 1, t.ToString());
                    tab.Set(row, 2, G.GetUpperLowerCase(var));
                    row++;
                    tab.Set(row, 1, "Iter");
                    tab.Set(row, 2, "Before");
                    tab.Set(row, 3, "After");
                    tab.Set(row, 4, "Hist. var");
                    tab.Set(row, 5, "Difference");
                    tab.Set(row, 6, "Relative1");
                    tab.Set(row, 7, "Relative2");
                    tab.SetAlign(row, 1, row, 7, Align.Right);
                    tab.SetBorder(row, 1, row, 7, BorderType.Top);
                    tab.SetBorder(row, 1, row, 7, BorderType.Bottom);

                    for (int it = 0; it < iterMemories.Count; it++)
                    {
                        IterMemory iterMemory = iterMemories[it];
                        double[] bBefore = iterMemory.bBefore;
                        double[] bAfter = iterMemory.bAfter;

                        EquationHelper found = Program.FindEquationByMeansOfVariableName(var);
                        if (found == null)
                        {
                            G.Writeln();
                            G.Writeln2("*** ERROR: ITERSHOW: Variable " + var + " is not endogenous");
                            throw new GekkoException();
                        }
                        int i = found.bNumberLhs;
                        //G.Writeln("per " + t.ToString() + " it " + it + " bef " + bBefore[i] + " aft " + bAfter[i]);
                        row++;
                        double bOld = bBefore[i];
                        double b = bAfter[i];
                        double bVariance = Program.model.modelGekko.bVariance[i];

                        tab.Set(new Coord(row, 1), "", it + 1, CellType.Number, "f6.0");
                        tab.Set(new Coord(row, 2), "", bOld, CellType.Number, "f13.4");
                        tab.Set(new Coord(row, 3), "", b, CellType.Number, "f13.4");
                        tab.Set(new Coord(row, 4), "", bVariance, CellType.Number, "f13.4");

                        double abs = (b - bOld);
                        double rel = (abs / bOld);
                        double relHist = (abs / bVariance);

                        if (abs != 0d) hasDifference = true;

                        tab.Set(new Coord(row, 5), "", abs, CellType.Number, "f15.6");
                        tab.Set(new Coord(row, 6), "", relHist, CellType.Number, "f12.6");
                        tab.Set(new Coord(row, 7), "", rel, CellType.Number, "f12.6");
                    }
                    tab.SetBorder(row, 1, row, 7, BorderType.Bottom);
                    tab.SetBorder(rowYearStart + 1, 1, row, 1, BorderType.Left);
                    tab.SetBorder(rowYearStart + 1, 7, row, 7, BorderType.Right);
                    row++;
                    row++;

                }//time loop
                if (!hasDifference) problems.Add(var);
            }
            if (hasContent)
            {
                Program.PrintTable(tab, false, null);
                if (problems.Count > 0)
                {
                    G.Writeln();
                    foreach (string s in problems)
                    {
                        G.Writeln("+++ NOTE: Variable '" + s + "' might be part of the prologue or epilogue, and if so it does not change during Gauss iterations. Regarding ordering, see the [model]__info.zip file, inside [model].ordering.");
                    }
                }
                G.Writeln("+++ NOTE: Damped variables have stricter convergence crits than non-damped.");
            }
            else
            {
                G.Writeln();
                G.Writeln("It seems there was no results stored regarding iterations: did you remember to set 'OPTION solve gauss dump = yes' before simulation?");
            }
        }

        

        public static double Lead(double[] b, int i)
        {
            //int x = Program.model.modelGekko.m2.fromBNumberToEqNumber[i];
            //BTypeData data = null; model.varsBType.TryGetValue("y" + Globals.lagIndicator + "1", out data);
            //Program.model.modelGekko.m2.from
            //G.Writeln(x);

            double v = double.NaN;

            int type = 1;  //0 "exo" or "forward method none", 1 const, 2 growth

            if (Program.model.modelGekko.simulateResults[8] == 0d)
            {
                v = b[i];
            }
            else if (Program.model.modelGekko.simulateResults[8] == 1d)  //#375204390457
            {
                if (Program.model.modelGekko.terminalHelper == null)
                {
                    //This will switch off the smart terminal stuff, and perforn NFT
                    //just like in the old days.
                    //That typically means a lot of more iterations for terminal CONST,
                    //whereas terminal EXO is not affected.
                    v = b[i];  //use the normal one
                }
                else
                {
                    int distance = (int)Program.model.modelGekko.simulateResults[7];
                    int newI = -12345;

                    if (Program.model.modelGekko.terminalHelper.Count > distance)
                    {
                        Program.model.modelGekko.terminalHelper[distance].TryGetValue(i, out newI);
                    }

                    if (newI != -12345)
                    {
                        //found pointing to a period outside sim period, so we use another b[i]
                        v = b[newI];
                        //G.Writeln("used b[" + newI + "] " + b[newI] + " instead of real lead b[" + i + "] " + b[i] + ", distance " + distance);
                    }
                    else
                    {
                        //just use the normal one
                        v = b[i];
                    }
                }
            }
            else if (Program.model.modelGekko.simulateResults[8] == 2d)
            {
                G.Writeln2("*** ERROR: terminal 'growth' does not work at the moment");
                throw new GekkoException();
            }
            else throw new GekkoException();
            return v;
        }

        

        
        
        

                

        public static void IterLink(StringBuilder output, string s1, string s2, string s3)
        {
            LinkContainer lc = new LinkContainer(output.ToString());
            Globals.linkContainer.Add(lc.counter, lc);
            G.Write(s1); G.WriteLink(s2, "outputtab:" + lc.counter); G.Write(s3);
        }
        

        
        

        

        
        


        public static void Time(GekkoTime t1, GekkoTime t2)
        {
            Tuple<GekkoTime, GekkoTime> freqs = ConvertFreqs(t1, t2, Program.options.freq);
            
            G.CheckLegalPeriod(freqs.Item1, freqs.Item2);

            Globals.globalPeriodStart = freqs.Item1;
            Globals.globalPeriodEnd = freqs.Item2;
            G.Writeln2("Global time set: " + G.FromDateToString(Globals.globalPeriodStart) + " to " + G.FromDateToString(Globals.globalPeriodEnd) + " (" + GekkoTime.Observations(Globals.globalPeriodStart, Globals.globalPeriodEnd) + " periods)");
            if (t1.freq != Program.options.freq || t2.freq != Program.options.freq)
            {
                G.Writeln("+++ NOTE: The dates have been converted to " + G.GetFreqString(Program.options.freq) + " frequency");
            }

            //if (Globals.runningOnTTComputer)
            //{
            //    object[] oo = new object[1];
            //    oo[0] = 2d;
            //    Try1(oo);
            //    Try2(oo);
            //}
        }        

        private static void Try1(object[] oo)
        {
            CodeDomProvider provider = new CSharpCodeProvider();
            CompilerParameters parameters = new CompilerParameters();


            CompilerResults results = provider.CompileAssemblyFromSource(parameters, @"
            namespace Dynamic
            {
                public static class A
                {
                    public static double fff(double x) { return x*x; }
                }
            }
            ");

            Assembly assem = results.CompiledAssembly;


            CodeDomProvider provider2 = new CSharpCodeProvider();
            CompilerParameters parameters2 = new CompilerParameters();

            parameters2.ReferencedAssemblies.Add(assem.Location);
            //parameters2.GenerateInMemory = true;

            CompilerResults results2 = provider2.CompileAssemblyFromSource(parameters2, @"
            namespace Dynamic
            {
                public static class B
                {
                    public static double ggg(double x) { return A.fff(2.0) + x+1d; }
                }
            }
            ");


            Assembly assem2 = results2.CompiledAssembly;
            Type assembly = assem2.GetType("Dynamic.B");  //the class
            double d = 2;

            Object ret = assembly.InvokeMember("ggg", BindingFlags.InvokeMethod, null, null, oo);  //the method
            G.Writeln2("return: " + ((double)ret));
        }

        private static void Try2(object[] oo)
        {
            CodeDomProvider provider = new CSharpCodeProvider();
            CompilerParameters parameters = new CompilerParameters();


            CompilerResults results = provider.CompileAssemblyFromSource(parameters, @"
            namespace Dynamic
            {
                public static class A
                {
                    public static double fff(double x) { return x*x*x; }
                }
            }
            ");

            Assembly assem = results.CompiledAssembly;


            CodeDomProvider provider2 = new CSharpCodeProvider();
            CompilerParameters parameters2 = new CompilerParameters();
            parameters2.ReferencedAssemblies.Add(assem.Location);
            //parameters2.GenerateInMemory = true;

            CompilerResults results2 = provider2.CompileAssemblyFromSource(parameters2, @"
            namespace Dynamic
            {
                public static class B
                {
                    public static double ggg(double x) { return A.fff(2.0) + x+1d; }
                }
            }
            ");


            Assembly assem2 = results2.CompiledAssembly;
            Type assembly = assem2.GetType("Dynamic.B");  //the class
            double d = 2;

            Object ret = assembly.InvokeMember("ggg", BindingFlags.InvokeMethod, null, null, oo);  //the method
            G.Writeln2("return: " + ((double)ret));
        }

        //private static void Try2(object[] oo)
        //{
        //    CompilerParameters parameters = new CompilerParameters();
        //    CodeDomProvider provider777 = new CSharpCodeProvider();
        //    CompilerResults results777 = provider777.CompileAssemblyFromSource(parameters, @"
        //    namespace Dynamic
        //    {
        //        public static class A
        //        {
        //            public static double fff(double x) { return x*x*x; }
        //        }
        //    }
        //    ");
        //    Assembly assem777 = results777.CompiledAssembly;
        //    //provider2 = new CSharpCodeProvider();
        //    CompilerParameters parameters777 = new CompilerParameters();
        //    parameters777.ReferencedAssemblies.Add(assem777.Location);

        //    Assembly assem777_2 = results777.CompiledAssembly;
        //    Type assembly777_2 = assem777.GetType("Dynamic.B");  //the class                    
        //    Object ret777 = assembly777_2.InvokeMember("ggg", BindingFlags.InvokeMethod, null, null, oo);  //the method
        //    G.Writeln2("return: " + ((double)ret777));
        //}

        public static void TimeFilter(O.TimeFilter o)
        {
            GekkoTimeSpans gtss = new GekkoTimeSpans();
            foreach (O.TimeFilterHelper tfh in o.timeFilterPeriods)
            {
                //This translation is a bit stupid since the two collections are almost identical
                //But never mind: this is not speed critical code.
                if (tfh.to.IsNull())
                {
                    gtss.data.Add(new GekkoTimeSpan(tfh.from, tfh.from, tfh.step));  //duplicating
                }
                else
                {
                    gtss.data.Add(new GekkoTimeSpan(tfh.from, tfh.to, tfh.step));
                }
            }
            Globals.globalPeriodTimeFilters = gtss;

            List<GekkoTime> positiveFilter = new List<GekkoTime>();
            List<GekkoTime> negativeFilter = new List<GekkoTime>();
            foreach (GekkoTimeSpan gts in Globals.globalPeriodTimeFilters.data)
            {
                int counter = 0;
                foreach (GekkoTime t in new GekkoTimeIterator( gts.tStart, gts.tEnd))
                {
                    if (counter % gts.by == 0)
                    {
                        positiveFilter.Add(t);  //dublets will be ok... should be Dictionary in the longer run...
                    }
                    counter++;
                }
            }
            List<string> chosen = new List<string>();
            List<string> filtered = new List<string>();
            GekkoTime gtLag = GekkoTime.tNull;

            foreach (GekkoTime gt in positiveFilter)
            {
                if (!gtLag.IsNull())
                {
                    if (!gt.StrictlyLargerThan(gtLag))
                    {
                        G.Writeln();
                        G.Writeln2("*** ERROR: TIMEFILTER sequence problem: '" + G.FromDateToString(gtLag) + "' should be larger than '" + G.FromDateToString(gt) + "'");
                        G.Writeln("           Please check your TIMEFILTER command", Color.Red);
                        throw new GekkoException();
                    }
                    else
                    {
                        int dif = GekkoTime.Observations(gtLag, gt) - 1;
                        if (dif > 1)  //period 2000:2001 is 2 obs for example (both start and end counting)
                        {
                            //Actually this dif check should not be necessary, but the problem is that the
                            //iterator is ill-defined if start date is > end date. In that case, the start
                            //date will be iterated once... Too dangerous to fix right now, so we do the
                            //explicit check.
                            //For instance, if gtLag = 2000 and gt=2001, we will iterate between 2001 and 2000 to get
                            //the filtered periods, which should not include 2001. The dif check handles this case.
                            foreach (GekkoTime gt2 in new GekkoTimeIterator( gtLag.Add(1), gt.Add(-1)))
                            {
                                negativeFilter.Add(gt2);
                                filtered.Add(G.FromDateToString(gt2));
                            }
                        }
                    }
                }
                chosen.Add(G.FromDateToString(gt));
                gtLag = gt;
            }
            //f.Sort();  is already in sequence
            G.Writeln();
            G.Write("Chosen periods: ");
            if (chosen.Count > 0)
            {
                G.PrintListWithCommas(chosen, false);
            }
            else G.Writeln("[none]");
            G.Write("Hidden periods: ");
            if (filtered.Count > 0)
            {
                G.PrintListWithCommas(filtered, false);
            }
            else
            {
                G.Writeln("[none]");
                G.Writeln("+++ WARNING: Nothing is filtered out, so filter has no effect!");
            }
            Globals.globalPeriodTimeFilters2 = negativeFilter;
            if (Program.options.timefilter == false)
            {
                Program.options.timefilter = true;
                G.Writeln("Time filtering is switched on (OPTION timefilter = yes)");
            }
        }

        public static bool ShouldFilterPeriod(GekkoTime t)
        {
            if (!Program.options.timefilter) return false;
            bool shouldFilter = false;
            if (Globals.globalPeriodTimeFilters2.Count > 0)
            {
                foreach (GekkoTime tFilter in Globals.globalPeriodTimeFilters2)
                {
                    if (t.IsSamePeriod(tFilter))
                    {
                        shouldFilter = true;
                        break;
                    }
                }
            }
            return shouldFilter;
        }


        /// <summary>
        /// Execute a <b style="color:black;background-color:#ff9999">shell</b> command
        /// </summary>
        /// <param name="_CommandLine">Command line parameters to pass</param>        
        public static void ExecuteShellCommand(string _CommandLine, bool mute)
        {
            //To get it dynamically, maybe this?: https://stackoverflow.com/questions/12678407/getting-command-line-output-dynamically

            bool fail = false;
            // Set process variable
            // Provides access to local and remote processes and enables you to start and stop local <b style="color:black;background-color:#99ff99">system</b> processes.
            System.Diagnostics.Process process = null;

            int widthRemember = Program.options.print_width;
            int fileWidthRemember = Program.options.print_filewidth;
            Program.options.print_width = int.MaxValue;
            Program.options.print_filewidth = int.MaxValue;

            try
            {
                process = new System.Diagnostics.Process();
                // invokes the cmd process specifying the command to be executed.
                string _CMDProcess = string.Format(System.Globalization.CultureInfo.InvariantCulture, @"{0}\cmd.exe", new object[] { Environment.SystemDirectory });
                // pass executing file to cmd (Windows command interpreter) as a arguments
                // /C tells cmd that we want it to execute the command that follows, and then exit.
                //string _Arguments = string.Format(System.Globalization.CultureInfo.InvariantCulture, "/C {0}", new object[] { _FileToExecute });
                string _Arguments = "";
                // pass any command line parameters for execution
                if (_CommandLine != null && _CommandLine.Length > 0)
                {
                    _Arguments = string.Format(System.Globalization.CultureInfo.InvariantCulture, "/C {0}", new object[] { _CommandLine, System.Globalization.CultureInfo.InvariantCulture });
                }
                // sets a value indicating not to start the process in a new window.
                process.StartInfo.CreateNoWindow = true;
                // sets a value indicating not to use the operating system shell to start the process.
                process.StartInfo.UseShellExecute = false;
                // sets a value that indicates the output/input/error of an application is written to the Process.
                process.StartInfo.RedirectStandardOutput = true;
                process.StartInfo.RedirectStandardInput = false;
                process.StartInfo.RedirectStandardError = true;
                process.StartInfo.WorkingDirectory = Program.options.folder_working;
                process.StartInfo.Arguments = _Arguments;
                process.StartInfo.FileName = _CMDProcess;
                //process.StartInfo = p;
                // Starts a process resource and associates it with a Process component.

                int timeout = 7 * 24 * 60 * 60 * 1000; //7*24 hours

                //See https://stackoverflow.com/questions/139593/processstartinfo-hanging-on-waitforexit-why?lq=1

                //StringBuilder output = new StringBuilder();
                StringBuilder error = new StringBuilder();
                using (AutoResetEvent outputWaitHandle = new AutoResetEvent(false))
                using (AutoResetEvent errorWaitHandle = new AutoResetEvent(false))
                {
                    process.OutputDataReceived += (sender, e) =>
                    {
                        if (!Globals.threadIsInProcessOfAborting)
                        {
                            if (e.Data == null)
                            {
                                outputWaitHandle.Set();
                            }
                            else
                            {
                                if (!mute) G.Writeln(e.Data);  //write it as a flowing stream                            
                            }
                        }
                    };
                    process.ErrorDataReceived += (sender, e) =>
                    {
                        if (!Globals.threadIsInProcessOfAborting)
                        {
                            if (e.Data == null)
                            {
                                errorWaitHandle.Set();
                            }
                            else
                            {
                                error.AppendLine(e.Data);
                            }
                        }
                    };

                    process.Start();
                    //string output = process.StandardOutput.ReadToEnd();

                    if (!Globals.threadIsInProcessOfAborting)
                    {
                        process.BeginOutputReadLine();
                        process.BeginErrorReadLine();
                    }

                    if (process.WaitForExit(timeout) && outputWaitHandle.WaitOne(timeout) && errorWaitHandle.WaitOne(timeout))                    
                    {
                        // Process completed. Check process.ExitCode here.
                    }
                    else
                    {
                        // Timed out.
                    }
                }

                if (!Globals.threadIsInProcessOfAborting)
                {
                    int exitCode = process.ExitCode;
                    if (exitCode != 0)
                    {
                        G.Writeln2("+++ WARNING: System call exited with code: " + exitCode, Globals.warningColor);
                        G.Writeln("             System command: " + _CommandLine, Globals.warningColor);
                        //fail = true;
                    }
                }

                if (!mute || Globals.threadIsInProcessOfAborting)
                {
                    try
                    {
                        //G.Writeln2(output.ToString());
                        if (error.Length > 0)
                        {
                            G.Writeln2("=================== System error message ===================", Globals.warningColor);
                            G.Writeln2(error.ToString(), Globals.warningColor);
                            //fail = true;
                        }
                    }
                    catch (Exception e)
                    {
                        G.Writeln2("+++ WARNING: Could not write output from system command", Globals.warningColor);
                        //fail = true;
                    }
                }
            }
            catch (Win32Exception _Win32Exception)
            {
                if (!Globals.threadIsInProcessOfAborting)
                {
                    // Error
                    G.Writeln2("*** ERROR: SYS Win32 exception: " + _Win32Exception.ToString());
                    fail = true;
                }
            }
            catch (Exception _Exception)
            {
                if (!Globals.threadIsInProcessOfAborting)
                {
                    // Error
                    G.Writeln2("*** ERROR: SYS exception: " + _Exception.ToString());
                    fail = true;
                }
            }
            finally
            {
                if (!Globals.threadIsInProcessOfAborting)
                {
                }
                else
                {
                    //resetting, also if there is an error
                    Program.options.print_width = widthRemember;
                    Program.options.print_filewidth = fileWidthRemember;
                    // close process and do cleanup
                    if (true)
                    {
                        //like killing it in the task manager, no questions asked
                        if (!process.HasExited)
                        {
                            try
                            {
                                process.Kill();
                            }
                            catch
                            {
                                //in principle, the process could exit just after .HasExited is asked, there the try here
                            }
                        }
                        else
                        {
                            process.Close();
                            process.Dispose();
                        }
                    }
                    else
                    {
                        process.Close();
                        process.Dispose();
                    }
                    //process = null;
                }
            }
            if (!Globals.threadIsInProcessOfAborting && fail) throw new GekkoException();  //we throw it here, after cleanup is performed
        }

        /// <summary>Use this function like string.Split but instead of a character to split on,
        /// use a maximum line width size. This is similar to a Word Wrap where no words will be split.</summary>
        /// Note if the a word is longer than the maxcharactes it will be trimmed from the start.
        /// <param name="initial">The string to parse.</param>
        /// <param name="MaxCharacters">The maximum size.</param>
        /// <remarks>This function will remove some white space at the end of a line, but allow for a blank line.</remarks>
        ///
        /// <returns>An array of strings.</returns>
        public static List<string> SplitOn(string initial, int MaxCharacters)
        {
            List<string> lines = new List<string>();
            if (string.IsNullOrEmpty(initial) == false)
            {
                string targetGroup = "Line";
                string theRegex = string.Format(@"(?<{0}>.{{1,{1}}})(?:\W|$)", targetGroup, MaxCharacters);

                MatchCollection matches = Regex.Matches(initial, theRegex, RegexOptions.IgnoreCase
                                                                          | RegexOptions.Multiline
                                                                          | RegexOptions.ExplicitCapture
                                                                          | RegexOptions.CultureInvariant
                                                                          | RegexOptions.Compiled);
                if (matches != null)
                    if (matches.Count > 0)
                        foreach (Match m in matches)
                            lines.Add(m.Groups[targetGroup].Value);
            }

            return lines;
        }

        public static List<string> SplitOn2(string initial, int MaxCharactersFirstLine, int MaxCharacters)
        {

            List<string> lines = new List<string>();

            if (string.IsNullOrEmpty(initial) == false)
            {
                string targetGroup = "Line";
                string theRegex = string.Format(@"(?<{0}>.{{1,{1}}})(?:\W|$)", targetGroup, MaxCharacters);

                MatchCollection matches = Regex.Matches(initial, theRegex, RegexOptions.IgnoreCase
                                                                          | RegexOptions.Multiline
                                                                          | RegexOptions.ExplicitCapture
                                                                          | RegexOptions.CultureInvariant
                                                                          | RegexOptions.Compiled);
                if (matches != null)
                    if (matches.Count > 0)
                        foreach (Match m in matches)
                            lines.Add(m.Groups[targetGroup].Value);
            }

            return lines;
        }

        public static void UndoSim()
        {
            //ErrorIfDatabanksSwapped();
            if (Globals.undoBank == null)
            {
                G.Writeln2("*** ERROR: Undo databank does not exist");
                throw new GekkoException();
            }
            else
            {
                Databank work = Program.databanks.GetFirst();
                work.Clear();
                G.CloneDatabank(work, Globals.undoBank);
                G.Writeln("Old databank re-established");
            }
        }

        public static void WriteGcm(List<ToFrom> vars, GekkoTime tStart, GekkoTime tEnd, string op, string file)
        {
            if (op == null) op = "n";
            if (op == "#")
            {
                G.Writeln2("*** ERROR: The '#' operator is not supported in EXPORT<series>");
                throw new GekkoException();
            }
            if (G.Equal(op, "mp"))
            {
                G.Writeln2("*** ERROR: The 'mp' operator is not supported in EXPORT<series>");
                throw new GekkoException();
            }

            int type = 0;
            if (op == "=" || op == "^=" || op == "%=" || op == "+=" || op == "*=") type = 1;
            if (G.Equal(op, "n") || G.Equal(op, "d") || G.Equal(op, "p") || G.Equal(op, "m") || G.Equal(op, "q")) type = 2;
            if (type == 0)
            {
                G.Writeln2("*** ERROR: Operator type '" + op + "' not recognized");
                throw new GekkoException();
            }

            //Databank work = Program.databanks.GetFirst();
            Databank base2 = Program.databanks.GetRef();

            file = AddExtension(file, "." + Globals.extensionCommand);
            string pathAndFilename = CreateFullPathAndFileNameFromFolder(file, Program.options.folder_working);
            if (File.Exists(pathAndFilename))
            {
                G.Writeln2("*** ERROR: The ." + Globals.extensionCommand + " file '" + pathAndFilename + "' already exists");
                G.Writeln("           Please remove it, for instance with SYS 'del <filename>';", Color.Red);
                G.Writeln("           This is to avoid overwriting a 'real' ." + Globals.extensionCommand + " command file.", Color.Red);
                throw new GekkoException();
            }
            using (FileStream fs = WaitForFileStream(pathAndFilename, GekkoFileReadOrWrite.Write))
            using (StreamWriter sw = G.GekkoStreamWriter(fs))
            {
                //string var;
                for (int j = 0; j < vars.Count; j++)
                {
                    string var = G.Chop_GetName(vars[j].s1);
                    string baseVar = G.Chop_SetBank(vars[j].s1, Globals.Ref);
                    var = G.GetUpperLowerCase(var);
                    IVariable ivBase = null;
                    Series tsBase = null;

                    if (op == "*=" || op == "+=" || G.Equal(op, "q") || G.Equal(op, "m"))
                    {
                        ivBase = O.GetIVariableFromString(baseVar, O.ECreatePossibilities.NoneReportError);  //no search here
                        tsBase = ivBase as Series;
                    }

                    IVariable iv = O.GetIVariableFromString(var, O.ECreatePossibilities.NoneReportError, true);  //can search!
                    Series ts = iv as Series;

                    string var2 = var;

                    StringBuilder sb = new StringBuilder();
                    if (type == 1)
                    {
                        sb.Append(var + " <" + tStart.ToString() + " " + tEnd.ToString() + "> " + op + " ");
                    }
                    else sb.Append(var + " <" + tStart.ToString() + " " + tEnd.ToString() + " " + op + "> = ");

                    foreach (GekkoTime t in new GekkoTimeIterator(tStart, tEnd))
                    {
                        double val = double.NaN;
                        double w = ts.GetDataSimple(t);
                        double wLag = ts.GetDataSimple(t.Add(-1));

                        double b = double.NaN;
                        double bLag = double.NaN;  //well, not use at the moment

                        if (op == "*=" || op == "+=" || G.Equal(op, "q") || G.Equal(op, "m"))
                        {
                            b = tsBase.GetDataSimple(t);
                            bLag = tsBase.GetDataSimple(t.Add(-1));
                        }

                        if (op == "=" || op == "n")
                        {
                            val = w;
                        }
                        else if (op == "^=" || op == "d")
                        {
                            val = w - wLag;
                        }
                        else if (op == "%=" || op == "p")
                        {
                            val = (w / wLag - 1) * 100d;
                        }
                        else if (op == "+=" || op == "m")
                        {
                            val = w - b;
                        }
                        else if (op == "*=")
                        {
                            val = w / b;
                        }
                        else if (op == "q")
                        {
                            val = (w / b - 1) * 100d;
                        }

                        int decimals = 6;
                        if (op == "*=") decimals = 8;
                        string valstring = G.UpdprtFormat(val, decimals, true); //6 decimals, must be enough also for interest rates etc.

                        valstring = valstring.Trim();  //necesssary?
                        sb.Append(valstring);
                        if (GekkoTime.Observations(t, tEnd) > 1) sb.Append(", ");
                    }
                    sb.Append(";");
                    sw.WriteLine(sb);
                }
            }
            G.Writeln2("Exported " + vars.Count + " variables to file " + pathAndFilename);
        }

        public static void Genr()
        {
            //ErrorIfDatabanksSwapped();
        }



        public static IVariable Laspeyres(string function, IVariable list1, IVariable list2, GekkoTime indexYear, GekkoTime tStart, GekkoTime tEnd)
        {
            //ErrorIfDatabanksSwapped();

            if (!(Program.options.freq == EFreq.A))
            {
                G.Writeln();
                G.Writeln2("*** ERROR: Index functions only work for annual frequency at the moment");
                throw new GekkoException();
            }

            int indexYearI = -12345;
            int counter = -1;
            bool found = false;
            foreach (GekkoTime t in new GekkoTimeIterator(tStart, tEnd))  //fix for other freqs
            {
                counter++;
                if (t.IsSamePeriod(indexYear))
                {
                    found = true;
                    indexYearI = counter;
                    break;
                }
            }

            if (!found)
            {
                G.Writeln();
                G.Writeln("*** ERROR with index year in Laspeyres function: seems outside time period");
                throw new GekkoException();
            }

            List<string> varsP = Program.GetListOfStringsFromList((List)list1);
            List<string> varsX = Program.GetListOfStringsFromList((List)list2);

            if (varsP.Count == 0 || varsX.Count == 0)
            {
                G.Writeln();
                G.Writeln("*** ERROR: list with 0 elements not permitted");
                throw new GekkoException();
            }

            if (varsP.Count != varsX.Count)
            {
                G.Writeln();
                G.Writeln("*** ERROR: the lists should have same number of elements");
                throw new GekkoException();
            }

            foreach (string s in varsP)
            {
                if (s.StartsWith("-"))
                {
                    G.Writeln();
                    G.Writeln("*** ERROR: '" + s + "': Please use subtraction in quantity list only");
                    throw new GekkoException();
                }
            }

            double[,] aX = PutTimeseriesIntoArrayPossiblyNegative(tStart, tEnd, varsX);
            double[,] aP = PutTimeseriesIntoArrayPossiblyNegative(tStart, tEnd, varsP);
            int obs = GekkoTime.Observations(tStart, tEnd);
            int obs2 = GekkoTime.Observations(tStart, indexYear);

            double[,] xx = new double[5, obs];
            //Seems [3, ...] is not used

            if (G.Equal(function, "laspchain"))
            {
                double index = 1d;
                xx[4, 0] = 1d;
                for (int i = 0; i < obs; i++)
                {
                    double sum = 0d;
                    double sum1 = 0d;
                    for (int j = 0; j < varsX.Count; j++)
                    {
                        sum += aX[j, i] * aP[j, i];
                        if (i > 0) sum1 += aX[j, i] * aP[j, i - 1];
                    }
                    xx[0, i] = sum;  //total cost
                    xx[1, i] = sum1;  //total cost at previous period prices
                    if (i > 0)
                    {
                        xx[2, i] = xx[1, i] / xx[0, i - 1];  //lasp.indexet år for år: C(plag) / C(p).lag
                        index = index * xx[2, i];
                        xx[4, i] = index;                    //lasp.indexet ganget op (1 i startperiode)
                                                             //xx[4,...] is the quantity index
                    }
                }
            }
            else if (G.Equal(function, "laspfixed"))
            {
                for (int i = 0; i < obs; i++)
                {
                    double sum = 0d;
                    double sum1 = 0d;
                    for (int j = 0; j < varsX.Count; j++)
                    {
                        sum += aX[j, i] * aP[j, i];
                        sum1 += aX[j, i] * aP[j, indexYearI];
                    }
                    xx[0, i] = sum;  //total cost
                    xx[1, i] = sum1;  //total cost at index period prices
                    xx[4, i] = sum1; //xx[4,...] is the quantity index
                }
            }
            else
            {
                throw new GekkoException();
            }

            Series p = new Series(EFreq.A, "p!a");  //all this should be deleted, but the code will run like this...
            Series q = new Series(EFreq.A, "q!a");

            //List<string> vars = new List<string>();
            //vars.Add(var1);
            //vars.Add(var2);

            //foreach (string var in vars)
            //{
            //    CreateXxVariableOrIssueError(work, var);
            //}

            //Series p = work.GetVariable(var1);
            //Series x = work.GetVariable(var2);

            double priceInIndexYear = xx[0, indexYearI] / xx[4, indexYearI];
            counter = -1;
            foreach (GekkoTime t in new GekkoTimeIterator(tStart, tEnd))
            {
                counter++;

                if (true)  //price = 1 in index year
                {
                    q.SetData(t, xx[4, counter] * priceInIndexYear);
                    p.SetData(t, xx[0, counter] / xx[4, counter] / priceInIndexYear);
                }
                else
                {
                    //FIXME
                    //4 skal være = 0 in index
                    q.SetData(t, xx[4, counter] / xx[4, indexYearI] * xx[0, indexYearI]);
                    p.SetData(t, xx[0, counter] / xx[4, counter] / priceInIndexYear);
                }
            }

            Map m = new Map();
            m.AddIVariable(p.GetName(), p);
            m.AddIVariable(q.GetName(), q);
            return m;
        }

        public static List<string> GetListOfStringsFromList(IVariable a)
        {
            if (a.Type() == EVariableType.String)
            {
                List<string> mm = new List<string>();
                mm.Add(a.ConvertToString());
                return mm;
            }
            else if (a.Type() == EVariableType.List)
            {
                List<IVariable> m = a.ConvertToList();
                List<string> mm = new List<string>();
                foreach (IVariable iv in m)
                {
                    string s = O.ConvertToString(iv);
                    mm.Add(s);
                }
                return mm;
            }
            else
            {
                G.Writeln2("*** ERROR: Input must be a string or list of strings");
                throw new GekkoException();
            }

        }

        private static void CreateXxVariableOrIssueError(Databank work, string var)
        {
            if (!work.ContainsIVariable(var + Globals.freqIndicator + G.GetFreq(Program.options.freq)))
            {
                if (var.ToLower().StartsWith("xx", true, null))
                {
                    //only vars beginning with "xx"
                    Series tsNew = new Series(Program.options.freq, var);
                    work.AddIVariable(tsNew.name, tsNew);
                }
                else
                {
                    IssueCreateWarning(var);
                }
            }
        }

        
        private static double[] UpdEnlargeDataArray(int expectedNumberOfObservations, double[] input)
        {
            if (input.Length > expectedNumberOfObservations)
            {
                //if input.Length == 1, this can never be the case
                //For instance, for TIME 2010 2015, this will fail: "UPD xx = 1,2,3,4,5,6,7 rep *;", whereas "UPD xx = 1,2,3,4,5,6 rep *;" will be ok
                G.Writeln2("*** ERROR: UPD: There were " + input.Length + " numbers given for the period, expected " + expectedNumberOfObservations);
                throw new GekkoException();
            }
            double[] data3 = new double[expectedNumberOfObservations];
            double lastKnown = input[input.Length - 1];
            for (int i = 0; i < expectedNumberOfObservations; i++)
            {
                if (i < input.Length) data3[i] = input[i];  //existing data
                else data3[i] = lastKnown;
            }
            return data3;
        }



        public static int Write(O.Write o)
        {
            //TODO: introduce frombank

            EWriteType writeType = GetWriteType(o);

            List<ToFrom> list = null;
            if (o.list1 != null)
            {
                if (o.list2 == null)
                {
                    o.list2 = new List();
                    for (int i = 0; i < o.list1.list.Count; i++)
                    {
                        o.list2.Add(new ScalarString("First:*"));  //for instance: EXPORT <csv> fx*, fy*, where we will "simulate" an EXPORT <csv> fx*, fy* TO first:*, first:*
                    }
                }
                list = SearchFromTo(o.list1, o.list2, o.opt_frombank, null, EWildcardSearchType.Write, null);
            }            
            
            if (writeType == EWriteType.Tsdx)
            {
                G.Writeln2("*** ERROR: You cannot use <tsdx>. The extension name has changed to ." + Globals.extensionDatabank + ".");
                G.Writeln("           If you really need a .tsdx file, you can WRITE/EXPORT a ." + Globals.extensionDatabank + " file,", Color.Red);
                G.Writeln("           and rename that file to .tsdx afterwards.", Color.Red);
                G.Writeln();
                throw new GekkoException();
            }

            bool isDefault = false;
            if (writeType == EWriteType.Gbk)
            {
                isDefault = true;
            }

            string fileName = o.fileName;
            fileName = G.StripQuotes(fileName);
            bool isCaps = true; if (G.Equal(o.opt_caps, "no")) isCaps = false;
            GekkoTime tStart = o.t1;
            GekkoTime tEnd = o.t2;
            
            bool writeAllVariables = false;
            if (list == null) writeAllVariables = true;

            bool aliasRemember = Program.options.interface_alias;

            EVariablesForWrite variablesType = EVariablesForWrite.Normal;

            try
            {
                
                if (writeAllVariables) Program.options.interface_alias = false;  //is remembered above and reverted

                if (writeType == EWriteType.R)
                {
                    //special treatment for the time being
                    ExportR(o);
                    return o.list1.Count();
                }
                else if (writeType == EWriteType.Python)
                {
                    //special treatment for the time being
                    ExportPython(o);
                    return o.list1.Count();
                }
                else if (writeAllVariables)  //writing the whole first databank
                {                    
                    list = new List<ToFrom>();
                    foreach (string s in Program.databanks.GetFirst().storage.Keys)
                    {
                        if (s == "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0" || s == "")
                        {
                            continue;  //probably some artefact creeping in from PCIM?
                        }
                        list.Add(new ToFrom("First:" + s, "First:" + s, true));                        
                    }                    
                }

                //??? why is EWriteType not used in line below and elsewhere???
                bool isRecordsFormat = isDefault || G.Equal(o.opt_gbk, "yes") || G.Equal(o.opt_tsd, "yes") || G.Equal(o.opt_gdx, "yes") || G.Equal(o.opt_flat, "yes") || G.Equal(o.opt_arrow, "yes");

                //TODO TODO TODO
                //TODO TODO TODO
                //TODO TODO TODO Not sure is this filter stuff works ok for quarters and months...?
                //TODO TODO TODO
                //TODO TODO TODO

                List<ToFrom> listFilteredForCurrentFreq = null;
                if (isRecordsFormat)
                {
                    //can handle multiple frequencies etc.
                    listFilteredForCurrentFreq = list;
                }
                else
                {
                    //2D format, only 1 frequency
                    //listFilteredForCurrentFreq = FilterListForFrequency(list);

                    foreach (ToFrom two in list)
                    {
                        if (G.Equal(G.GetFreq(Program.options.freq), G.Chop_GetFreq(two.s1)))  //.s2 is probably not used here
                        {
                            //good
                            if (listFilteredForCurrentFreq == null) listFilteredForCurrentFreq = new List<ToFrom>();
                            listFilteredForCurrentFreq.Add(two);
                        }
                    }

                    if (listFilteredForCurrentFreq == null)
                    {
                        if (list.Count == 1 && G.Chop_HasSigil(list[0].s1))
                        {
                            variablesType = EVariablesForWrite.OneNonSeries;  //will only be active for 2D format
                            //a %- or #-variable, not a series
                            listFilteredForCurrentFreq = new List<ToFrom>();
                            listFilteredForCurrentFreq.Add(list[0]);                            
                        }
                    }
                }

                if (listFilteredForCurrentFreq == null || listFilteredForCurrentFreq.Count == 0)
                {
                    G.Writeln2("*** ERROR: No variables to write");
                    if (!isRecordsFormat)
                    {
                        G.Writeln("+++ NOTE: Only variables of the current frequency (" + Program.options.freq.ToString() + ") are considered.");
                    }
                    throw new GekkoException();
                }

                if (tStart.IsNull() && tEnd.IsNull())
                {
                    if (isRecordsFormat)
                    {
                        //Do nothing, skip this, we do not need to know the timespan of the bank
                    }
                    else
                    {
                        //will find that largest timespan of the databank series
                        GetDatabankPeriodFilteredForFreq(listFilteredForCurrentFreq, ref tStart, ref tEnd);
                    }
                }

                string writeOption = "" + Globals.extensionDatabank + "";  //default
                if (G.Equal(o.opt_tsd, "yes")) writeOption = "tsd";

                if (G.Equal(o.opt_csv, "yes") || G.Equal(o.opt_prn, "yes"))
                {
                    //2D format
                    ErrorIfMatrix(variablesType);
                    EdataFormat format = EdataFormat.Csv;
                    if (G.Equal(o.opt_csv, "yes")) format = EdataFormat.Csv;
                    else if (G.Equal(o.opt_prn, "yes")) format = EdataFormat.Prn;
                    CheckSomethingToWrite(listFilteredForCurrentFreq);
                    return CsvPrnWrite(listFilteredForCurrentFreq, fileName, tStart, tEnd, format, G.Equal(o.opt_cols, "yes"), o.opt_dateformat);
                }
                else if (G.Equal(o.opt_gnuplot, "yes"))
                {
                    //2D format
                    ErrorIfMatrix(variablesType);
                    CheckSomethingToWrite(listFilteredForCurrentFreq);
                    return GnuplotWrite(listFilteredForCurrentFreq, fileName, tStart, tEnd);
                }
                else if (G.Equal(o.opt_tsp, "yes"))
                {
                    //RECORDS
                    ErrorIfMatrix(variablesType);
                    CheckSomethingToWrite(listFilteredForCurrentFreq);
                    return Tspwrite(listFilteredForCurrentFreq, fileName, tStart, tEnd, isCaps);
                }
                else if (G.Equal(o.opt_xls, "yes") || G.Equal(o.opt_xlsx, "yes"))
                {
                    //2D format
                    CheckSomethingToWrite(listFilteredForCurrentFreq);
                    WriteToExcel(fileName, tStart, tEnd, listFilteredForCurrentFreq, G.Equal(o.opt_cols, "yes"), o.opt_dateformat, o.opt_datetype, variablesType);
                    return 0;
                }
                else if (o.opt_gcm != null)
                {
                    //RECORDS
                    ErrorIfMatrix(variablesType);
                    if (fileName == null || fileName.Trim() == "")
                    {
                        G.Writeln2("*** ERROR: Please indicate a file name for EXPORT<series>");
                        throw new GekkoException();
                    }
                    CheckSomethingToWrite(listFilteredForCurrentFreq);
                    Program.WriteGcm(listFilteredForCurrentFreq, tStart, tEnd, o.opt_op, fileName);
                    return 0;
                }
                else if (o.opt_gdx != null)
                {
                    //RECORDS
                    ErrorIfMatrix(variablesType);
                    if (fileName == null || fileName.Trim() == "")
                    {
                        G.Writeln2("*** ERROR: Please indicate a file name for EXPORT<gdx>");
                        throw new GekkoException();
                    }
                    CheckSomethingToWrite(listFilteredForCurrentFreq);
                    string file = AddExtension(fileName, "." + "gdx");
                    string pathAndFilename = CreateFullPathAndFileName(file);
                    if (Program.options.gams_fast)
                    {
                        GamsData.WriteGdx(Program.databanks.GetFirst(), tStart, tEnd, pathAndFilename, list);
                    }
                    else
                    {
                        GamsData.WriteGdxSlow(Program.databanks.GetFirst(), tStart, tEnd, pathAndFilename, list);
                    }
                    return 0;
                }
                else if (o.opt_arrow != null)
                {
                    //RECORDS
                    ErrorIfMatrix(variablesType);
                    if (fileName == null || fileName.Trim() == "")
                    {
                        G.Writeln2("*** ERROR: Please indicate a file name for EXPORT<arrow>");
                        throw new GekkoException();
                    }
                    CheckSomethingToWrite(listFilteredForCurrentFreq);
                    string file = AddExtension(fileName, "." + "arrow");
                    string pathAndFilename = CreateFullPathAndFileName(file);
                    try
                    {
                        Arrow.WriteArrowDatabank(Program.databanks.GetFirst(), tStart, tEnd, pathAndFilename, list);
                    }
                    catch (Exception e)
                    {
                        if (e.Message.Contains("System.OutOfMemoryException"))
                        {
                            G.Writeln2("Arrow writing ran out of memory. At the moment, the Arrow implementation", Color.Red);
                            G.Writeln("in Gekko is not very fast or memory-efficient, but more of a proof of concept.", Color.Red);
                            G.Writeln("In the longer run, we expect the Arrow interface to run very fast and efficiently", Color.Red);
                            G.Writeln("in Gekko, since speed and efficiency are fundamental to the Arrow project.", Color.Red);
                            G.Writeln();
                            throw;
                        }
                    }
                    return 0;
                }
                else if (isRecordsFormat)
                {
                    //RECORDS
                    //tsd or gbk or unspecified format                
                    CheckSomethingToWrite(list);
                    //first argument (the databank) is only used if list = null
                    if (isDefault)
                    {
                        return WriteGbk(Program.databanks.GetFirst(), tStart, tEnd, fileName, isCaps, list, writeOption, writeAllVariables, false);
                    }
                    if (writeType == EWriteType.Tsd)
                    {
                        return WriteTsd(Program.databanks.GetFirst(), tStart, tEnd, fileName, isCaps, list, writeOption, writeAllVariables, false);
                    }
                    else if (writeType == EWriteType.Flat)
                    {
                        return WriteFlat(Program.databanks.GetFirst(), tStart, tEnd, fileName, isCaps, list, writeOption, writeAllVariables, false);
                    }
                    else
                    {
                        G.Writeln2("*** ERROR: Unknown databank format");
                        throw new GekkoException();
                    }
                }
                else
                {
                    G.Writeln2("*** ERROR: Unknown databank format");
                    throw new GekkoException();
                }
            }
            finally
            {
                Program.options.interface_alias = aliasRemember;
            }
        }

        private static void ErrorIfMatrix(EVariablesForWrite variablesType)
        {
            if (variablesType == EVariablesForWrite.OneNonSeries)
            {
                G.Writeln2("*** ERROR: The format can not be used to EXPORT matrices");
                throw new GekkoException();
            }
        }

        private static EWriteType GetWriteType(O.Write o)
        {
            EWriteType writeType = EWriteType.Gbk;
            if (G.Equal(o.opt_csv, "yes")) writeType = EWriteType.Csv;
            else if (G.Equal(o.opt_gdx, "yes")) writeType = EWriteType.Gdx;
            else if (G.Equal(o.opt_gnuplot, "yes")) writeType = EWriteType.Gnuplot;
            else if (G.Equal(o.opt_prn, "yes")) writeType = EWriteType.Prn;
            else if (G.Equal(o.opt_r, "yes")) writeType = EWriteType.R;
            else if (G.Equal(o.opt_gcm, "yes")) writeType = EWriteType.Gcm;
            else if (G.Equal(o.opt_tsd, "yes")) writeType = EWriteType.Tsd;
            else if (G.Equal(o.opt_tsdx, "yes")) writeType = EWriteType.Tsdx;
            else if (G.Equal(o.opt_tsp, "yes")) writeType = EWriteType.Tsp;
            else if (G.Equal(o.opt_xls, "yes")) writeType = EWriteType.Xls;
            else if (G.Equal(o.opt_xlsx, "yes")) writeType = EWriteType.Xlsx;
            else if (G.Equal(o.opt_flat, "yes")) writeType = EWriteType.Flat;
            else if (G.Equal(o.opt_python, "yes")) writeType = EWriteType.Python;
            else if (G.Equal(o.opt_arrow, "yes")) writeType = EWriteType.Arrow;
            return writeType;
        }

        private static void ExportR(O.Write o)
        {
            //Special treatment, for the time being

            if (o.fileName == null)
            {
                G.Writeln2("*** ERROR: You must state a filename with FILE = ...");
                throw new GekkoException();
            }

            string fullFileName = CreateFullPathAndFileName(o.fileName);

            using (FileStream fs = WaitForFileStream(fullFileName, GekkoFileReadOrWrite.Write))
            using (StreamWriter file = G.GekkoStreamWriter(fs))
            {
                foreach(IVariable iv2 in o.list1.list)                
                {
                    string s = iv2.ConvertToString();
                    if (!s.StartsWith(Globals.symbolCollection.ToString()))
                    {
                        G.Writeln2("*** ERROR: EXPORT<r>: expected all list items to start with '#'");
                        throw new GekkoException();
                    }
                    IVariable iv = null; iv = Program.databanks.GetFirst().GetIVariable(s);
                    if (iv == null)
                    {
                        G.Writeln2("*** ERROR: " + s + " does not exist");
                        throw new GekkoException();
                    }
                    if (iv.Type() != EVariableType.Matrix)
                    {
                        G.Writeln2("*** ERROR: " + s + " is not a matrix");
                        throw new GekkoException();
                    }
                    Matrix m = (Matrix)iv;
                    file.WriteLine(Program.MatrixFromGekkoToROrPython<double>(s.Substring(1), m.data, 0));
                    file.WriteLine();
                }
                file.Flush();
            }
            G.Writeln2("R export of " + o.list1.Count() + " matrices, " + fullFileName);
        }

        private static void ExportPython(O.Write o)
        {
            //Special treatment, for the time being

            if (o.fileName == null)
            {
                G.Writeln2("*** ERROR: You must state a filename with FILE = ...");
                throw new GekkoException();
            }

            string fullFileName = CreateFullPathAndFileName(o.fileName);

            using (FileStream fs = WaitForFileStream(fullFileName, GekkoFileReadOrWrite.Write))
            using (StreamWriter file = G.GekkoStreamWriter(fs))
            {
                foreach (IVariable iv2 in o.list1.list)                
                {
                    string s = iv2.ConvertToString();
                    if (!s.StartsWith(Globals.symbolCollection.ToString()))
                    {
                        G.Writeln2("*** ERROR: EXPORT<python>: expected all list items to start with '#'");
                        throw new GekkoException();
                    }
                    IVariable iv = null; iv = Program.databanks.GetFirst().GetIVariable(s);
                    if (iv == null)
                    {
                        G.Writeln2("*** ERROR: " + s + " does not exist");
                        throw new GekkoException();
                    }
                    if (iv.Type() != EVariableType.Matrix)
                    {
                        G.Writeln2("*** ERROR: " + s + " is not a matrix");
                        throw new GekkoException();
                    }
                    Matrix m = (Matrix)iv;
                    file.WriteLine(Program.MatrixFromGekkoToROrPython<double>(s.Substring(1), m.data, 1));
                    file.WriteLine();
                }
                file.Flush();
            }
            G.Writeln2("Python export of " + o.list1.Count() + " matrices, " + fullFileName);
        }

        private static void CheckSomethingToWrite(List<ToFrom> listFilteredForCurrentFreq)
        {
            if (listFilteredForCurrentFreq == null || listFilteredForCurrentFreq.Count == 0)
            {
                G.Writeln2("*** ERROR: No variables to write");
                throw new GekkoException();
            }
        }

        private static void WriteToExcel(string fileName, GekkoTime tStart, GekkoTime tEnd, List<ToFrom> list, bool isCols, string dateformat, string datetype, EVariablesForWrite variablesType)
        {
            ExcelOptions eo = new ExcelOptions();

            if (variablesType == EVariablesForWrite.Normal)
            {

                G.Writeln2("Writing Excel file for the period " + G.FromDateToString(tStart) + "-" + G.FromDateToString(tEnd));
                //TODO: variables and time                

                int counter = 0;
                int numberOfCols = GekkoTime.Observations(tStart, tEnd);
                int numberOfRows = list.Count;

                eo.excelData = new double[numberOfRows, numberOfCols];
                eo.excelRowLabels = new string[numberOfRows, 1];
                eo.excelColumnLabels = new string[1, numberOfCols];
                eo.excelColumnLabelsGekkoTime = new GekkoTime[1, numberOfCols];
                eo.transpose = "no"; if (isCols) eo.transpose = "yes"; //kind of a workaround

                for (int i = 0; i < list.Count; i++)
                {
                    IVariable iv = O.GetIVariableFromString(list[i].s1, O.ECreatePossibilities.NoneReportError, true);
                    Series ts = iv as Series;
                    string varLabel = G.Chop_GetName(list[i].s2);
                    eo.excelRowLabels[i, 0] = varLabel;

                    if (ts == null)
                    {
                        //TODO: check this beforehand, and do a msgbox with all missing vars (a la when doing sim)
                        //G.Writeln("+++ WARNING: variable '" + newList[i] + "' is of wrong type, skipped");
                        continue;
                    }
                    counter++;
                    int periodCounter = 0;

                    foreach (GekkoTime gt in new GekkoTimeIterator(tStart, tEnd))
                    {
                        eo.excelColumnLabels[0, periodCounter] = gt.ToString();
                        eo.excelColumnLabelsGekkoTime[0, periodCounter] = gt;
                        double var1 = ts.GetDataSimple(gt);
                        if (G.isNumericalError(var1)) var1 = 9.99999e+99;
                        eo.excelData[i, periodCounter] = var1;
                        periodCounter++;
                    }
                }
            }
            else
            {
                int iHere = 0;
                IVariable iv = O.GetIVariableFromString(list[iHere].s1, O.ECreatePossibilities.NoneReportError, true);
                Matrix m = iv as Matrix;
                if (m == null)
                {
                    G.Writeln2("The variable '" + list[iHere].s1 + "' is not a matrix");
                    throw new GekkoException();
                }
                double[,] data = m.data;
                int ni = data.GetLength(0);
                int nj = data.GetLength(1);

                G.Writeln2("Writing Excel file containing matrix");

                eo.excelData = new double[ni, nj];
                eo.colors = "no";

                if (m.rownames != null)
                {                    
                    eo.excelRowLabels = new string[m.rownames.Count, 1];
                    for (int i = 0; i < m.rownames.Count; i++) eo.excelRowLabels[i, 0] = m.rownames[i];
                }

                if (m.colnames != null)
                {
                    eo.excelColumnLabels = new string[1, m.colnames.Count];
                    for (int i = 0; i < m.colnames.Count; i++) eo.excelColumnLabels[0, i] = m.colnames[i];
                }

                for (int i = 0; i < ni; i++)
                {
                    for (int j = 0; j < nj; j++)
                    {                        
                        double var1 = data[i, j];
                        if (G.isNumericalError(var1)) var1 = 9.99999e+99;
                        eo.excelData[i, j] = var1;
                    }
                }
                
            }

            eo.fileName = fileName;

            Program.CreateExcelWorkbook2(eo, null, false, variablesType == EVariablesForWrite.OneNonSeries, dateformat, datetype);
        }

        public static void ArrayTimeseriesTip(string name)
        {
            G.Writeln("           Tip: try 'DISP " + name + ";' to see the dimensions.", Color.Red);
        }
        
        
        public static int WriteGbk(Databank databank, GekkoTime yr1, GekkoTime yr2, string file, bool isCaps, List<ToFrom> list, string writeOption, bool writeAllVariables, bool isCloseCommand)
        {
            if (databank.storage.Count == 0)
            {
                if (isCloseCommand)
                {
                    if (databank.fileHash == Globals.brandNewFile)
                    {
                        G.Writeln2("Databank " + databank.name + " is empty and hence not written");
                        return 0;
                    }
                    else
                    {
                        //write it: it could be an OPEN<edit> on existing file with series. Then CLEAR. Then CLOSE.
                        //in that case, an empty bank should be written.
                    }
                }
                else
                {
                    //nowadays we may have WRITE b2:* file=myfile, not related to Work or first bank at all!
                    //G.Writeln2("*** ERROR: Databank '" + databank.aliasName + "' is empty -- nothing to write");
                    //throw new GekkoException();
                }
            }

            file = G.StripQuotes(file);
            bool isUsingOptionFolderBank = false;
            if (Program.options.folder && Program.options.folder_bank != "") isUsingOptionFolderBank = true;

            string tempTsdxPath = null;

            bool isTsdx = true;
            string extension = Globals.extensionDatabank;

            DateTime t = DateTime.Now;

            file = AddExtension(file, "." + extension);

            string path = null;
            if (isUsingOptionFolderBank)
            {
                path = Program.options.folder_bank;
            }
            string pathAndFilename = CreateFullPathAndFileNameFromFolder(file, path);

            string pathAndFileNameResultingFile = pathAndFilename;

            int count = 0;

            string tsdxVersion = "1.2"; //Gekko 3.0

            //try to zip it to this local folder
            tempTsdxPath = GetTempTsdxFolderPath();
            if (!Directory.Exists(tempTsdxPath))  //should almost never exist, since name is random
            {
                Directory.CreateDirectory(tempTsdxPath);
            }
            else
            {
                //in the very rare case, any files here will be overwritten
            }
            //pathAndFilename = tempTsdxPath + "\\" + "databank" + ".tsd";

            CreateDatabankXmlInfo(tempTsdxPath, tsdxVersion, isCloseCommand);

            //May take a little time to create: so use static serializer if doing serialize on a lot of small objects
            
            string pathAndFilename2 = tempTsdxPath + "\\" + Program.options.databank_file_gbk_internal; //changed from .bin to .data
            databank.Trim();  //to make it smaller, slack removed from each IVariable

            //Note that if writeAllVariables=true, we don't make any list of the variables, the databank
            //object is simply serialized directly. So any timeseries will be written in that case.
            GekkoDictionary<string, IVariable> databankWithFewerVariables = null;
            GekkoDictionary<string, IVariable> storageOriginal = databank.storage;  //for resetting back to this afterwards

            try
            {
                if (writeAllVariables == false)
                {
                    //-----------------------
                    // truncate the variables
                    // here, databank variable is not used (this is actually only used for CLOSEing a bank)
                    //-----------------------
                    databankWithFewerVariables = new GekkoDictionary<string, IVariable>(StringComparer.OrdinalIgnoreCase);
                    foreach (ToFrom var in list)
                    {
                        //Databank db = GetBankFromBankNameVersion(var.bank);
                        //IVariable xx = O.Lookup(null, null, var.bank, var.name, var.freq, null, false, EVariableType.Var, true);

                        IVariable xx = O.GetIVariableFromString(var.s1, O.ECreatePossibilities.NoneReportError, true);

                        //string varnameWithFreq = var.name;
                        string varnameWithFreq = G.Chop_GetNameAndFreq(var.s2);
                        //if (xx.Type() == EVariableType.Series)
                        //{
                        //    //string freq = var.freq;
                        //    //if (freq == null) freq = G.GetFreq(Program.options.freq);
                        //    varnameWithFreq = var.name + Globals.freqIndicator + var.freq;
                        //}

                        if (databankWithFewerVariables.ContainsKey(varnameWithFreq))
                        {
                            G.Writeln();
                            G.Writeln("*** ERROR: Gbk format does not allow duplicate variables, " + G.GetNameAndFreqPretty(varnameWithFreq));
                            G.Writeln("           This is enforced for " + Globals.extensionDatabank + " version 1.1 and later.");
                            throw new GekkoException();
                        }
                        else
                        {
                            databankWithFewerVariables.Add(varnameWithFreq, xx);
                        }
                    }
                }

                if (databankWithFewerVariables != null) databank.storage = databankWithFewerVariables;  //will be reset later on --> to storageOriginal

                if (!yr1.IsNull() || !yr2.IsNull())
                {
                    //----------------------
                    // truncate the periods
                    //----------------------
                    GekkoDictionary<string, IVariable> databankWithFewerPeriods = new GekkoDictionary<string, IVariable>(StringComparer.OrdinalIgnoreCase);
                    foreach (KeyValuePair<string, IVariable> kvp in databank.storage)
                    {
                        Series ts = kvp.Value as Series;
                        if (ts != null)
                        {
                            Series tsClone = ts.DeepClone(null) as Series;
                            tsClone.Truncate(yr1, yr2);
                            databankWithFewerPeriods.Add(kvp.Key, tsClone);
                        }
                    }
                    databank.storage = databankWithFewerPeriods;
                    databank.Trim();  //to make it smaller, slack removed from each Series
                }

                using (FileStream fs = WaitForFileStream(pathAndFilename2, GekkoFileReadOrWrite.Write))
                {

                    try
                    {
                        RuntimeTypeModel serializer = TypeModel.Create();
                        serializer.UseImplicitZeroDefaults = false; //otherwise an int that has default constructor value -12345 but is set to 0 will reappear as a -12345 (instead of 0). For int, 0 is default, false for bools etc.
                        serializer.Serialize(fs, databank);
                        count = databank.storage.Count;
                    }
                    catch (Exception e)
                    {
                        G.Writeln2("*** ERROR: Technical problem while writing databank to " + Globals.extensionDatabank + " (protobuffers)");
                        G.Writeln("           Message: " + e.Message, Color.Red);
                        throw;
                    }

                }
            }
            finally
            {
                //so we are sure it always gets pointed back to its real Dictionary<>!
                databank.storage = storageOriginal;
            }

            DateTime dt0 = DateTime.Now;
                        
            WaitForZipWrite(tempTsdxPath, pathAndFileNameResultingFile);
            
            if (true)
            {
                G.Writeln();
                G.Writeln("Wrote " + count + " variables to " + pathAndFileNameResultingFile + " in " + G.Seconds(t));
                if (isUsingOptionFolderBank)
                {
                    if (!file.Contains(":"))  //Don't write this message if it is a absolute path, for instance c:\mybank\myfile. Relative paths will get the message (that must be ok)
                    {
                        G.Writeln("+++ NOTE: Wrote to user-indicated folder (see 'option folder bank = ...')");
                    }
                }
            }
            return count;
        }

        public static int WriteTsd(Databank databank, GekkoTime yr1, GekkoTime yr2, string file, bool isCaps, List<ToFrom> list, string writeOption, bool writeAllVariables, bool isCloseCommand)
        {            
            if (databank.storage.Count == 0)
            {
                if (isCloseCommand)
                {
                    G.Writeln2("*** ERROR: Closed TSD databank was changed but cannot be written back");
                    throw new GekkoException();
                }                
            }

            file = G.StripQuotes(file);
            bool isUsingOptionFolderBank = false;
            if (Program.options.folder && Program.options.folder_bank != "") isUsingOptionFolderBank = true;

            string tempTsdxPath = null;

            bool isTsdx = false;
            string extension = "tsd";
            
            DateTime t = DateTime.Now;
            
            file = AddExtension(file, "." + extension);

            string path = null;
            if (isUsingOptionFolderBank)
            {
                path = Program.options.folder_bank;
            }
            string pathAndFilename = CreateFullPathAndFileNameFromFolder(file, path);

            string pathAndFileNameResultingFile = pathAndFilename;

            int count = 0;            
            
            DateTime dt0 = DateTime.Now;            
            WriteTsdRecords(ref yr1, ref yr2, isCaps, list, databank, isTsdx, pathAndFilename, ref count);            

            if (true)
            {
                G.Writeln();
                G.Writeln("Wrote " + count + " variables to " + pathAndFileNameResultingFile + " in " + G.Seconds(t));
                if (isUsingOptionFolderBank)
                {
                    if (!file.Contains(":"))  //Don't write this message if it is a absolute path, for instance c:\mybank\myfile. Relative paths will get the message (that must be ok)
                    {
                        G.Writeln("+++ NOTE: Wrote to user-indicated folder (see 'option folder bank = ...')");
                    }
                }
            }
            return count;
        }

        public static int WriteFlat(Databank databank, GekkoTime yr1, GekkoTime yr2, string file, bool isCaps, List<ToFrom> list, string writeOption, bool writeAllVariables, bool isCloseCommand)
        {
            if (databank.storage.Count == 0)
            {
                G.Writeln2("*** ERROR: Databank is empty");
                throw new GekkoException();
            }

            file = G.StripQuotes(file);
            bool isUsingOptionFolderBank = false;
            if (Program.options.folder && Program.options.folder_bank != "") isUsingOptionFolderBank = true;
                        
            string extension = "flat";
            DateTime t = DateTime.Now;
            file = AddExtension(file, "." + extension);

            string path = null;
            if (isUsingOptionFolderBank)
            {
                path = Program.options.folder_bank;
            }
            string pathAndFilename = CreateFullPathAndFileNameFromFolder(file, path);

            string pathAndFileNameResultingFile = pathAndFilename;

            int count = 0;

            DateTime dt0 = DateTime.Now;
            WriteFlatRecords(ref yr1, ref yr2, isCaps, list, databank, pathAndFilename, ref count);

            if (true)
            {
                G.Writeln();
                G.Writeln("Wrote " + count + " variables to " + pathAndFileNameResultingFile + " in " + G.Seconds(t));
                if (isUsingOptionFolderBank)
                {
                    if (!file.Contains(":"))  //Don't write this message if it is a absolute path, for instance c:\mybank\myfile. Relative paths will get the message (that must be ok)
                    {
                        G.Writeln("+++ NOTE: Wrote to user-indicated folder (see 'option folder bank = ...')");
                    }
                }
            }
            return count;
        }

        private static void WriteFlatRecords(ref GekkoTime yr1, ref GekkoTime yr2, bool isCaps, List<ToFrom> list, Databank databank, string pathAndFilename, ref int count)
        {
            StringBuilder sb = new StringBuilder();
            
            using (FileStream fs = WaitForFileStream(pathAndFilename, GekkoFileReadOrWrite.Write))
            using (StreamWriter res = G.GekkoStreamWriter(fs))
            {
                foreach (ToFrom var in list)
                {
                    IVariable iv = O.GetIVariableFromString(var.s1, O.ECreatePossibilities.NoneReportError, true);
                    
                    Series ts = iv as Series;
                    {
                        if (ts == null) continue; //skip  
                        if (ts.type != ESeriesType.Normal) continue; //skip  
                        count++;
                        WriteFlatRecord(yr1, yr2, res, ts, G.Chop_GetName(var.s2), sb);
                    }
                }
                res.Flush();
            }
        }

        public static bool ExistFile(string s)
        {
            string filename = Program.CreateFullPathAndFileName(s);
            bool exist = File.Exists(filename);
            return exist;
        }

        public static void WriteFile(IVariable file2, IVariable x1)
        {
            string file = O.ConvertToString(file2);
            string x = O.ConvertToString(x1);
            string[] xx = x.Split(new string[] { "\\n" }, StringSplitOptions.None);
            using (FileStream fs = WaitForFileStream(file, GekkoFileReadOrWrite.Write))
            using (StreamWriter res = G.GekkoStreamWriter(fs))
            {

                for (int i = 0; i < xx.Length - 1; i++)
                {
                    res.WriteLine(xx[i]);
                }
                res.Write(xx[xx.Length - 1]);

                res.Flush();
            }
        }

        private static void WriteTsdRecords(ref GekkoTime yr1, ref GekkoTime yr2, bool isCaps, List<ToFrom> list, Databank databank, bool isTsdx, string pathAndFilename, ref int count)
        {
            using (FileStream fs = WaitForFileStream(pathAndFilename, GekkoFileReadOrWrite.Write))
            using (StreamWriter res = G.GekkoStreamWriter(fs))
            {
                foreach (ToFrom var in list)
                {
                    IVariable iv = O.GetIVariableFromString(var.s1, O.ECreatePossibilities.NoneReportError, true);

                    Series ts = iv as Series;
                    {
                        if (ts == null) continue;  //skip                            
                        count++;
                        WriteTsdRecord(yr1, yr2, res, ts, G.Chop_GetName(var.s2), isCaps, isTsdx);
                    }
                }
                res.Flush();
            }
        }

        private static void CreateDatabankXmlInfo(string tempTsdxPath, string tsdxVersion, bool isCloseCommand)
        {
            // Create the xml document containe
            XmlDocument doc = new XmlDocument();// Create the XML Declaration, and append it to XML document
            XmlDeclaration dec = doc.CreateXmlDeclaration("1.0", null, null);
            //doc.Attributes.Append(new XmlAttribute
            doc.AppendChild(dec);// Create the root element
            //Using PascalCase for elements, and camelCase for attributes.
            XmlElement root = doc.CreateElement("DatabankInfo");
            root.SetAttribute("databankVersion", tsdxVersion);  //needs to be changed if Databank/Series change
            root.SetAttribute("gekkoVersion", Globals.gekkoVersion);
            doc.AppendChild(root);

            XmlElement comment = doc.CreateElement("Info1");  //HDG
            comment.InnerText = Program.databanks.GetFirst().info1;
            root.AppendChild(comment);

            XmlElement date = doc.CreateElement("Date");
            string now = GetDateTimeStamp();
            date.InnerText = now;
            root.AppendChild(date);

            if (G.HasModelGekko() && !isCloseCommand)
            {
                //We do not want to put model info into XML if it is a CLOSE command triggering the bank write, for
                //instance after a OPEN<edit>, etc. This is mode=data and something else.
                //(Would probably happen very rarely anyhow, since model endogenous and databank variables must match)
                bool ok = true;
                foreach (string s in Program.model.modelGekko.endogenousOriginallyInModel.Keys)
                {
                    if (!Program.databanks.GetFirst().ContainsIVariable(s + Globals.freqIndicator + G.GetFreq(Program.options.freq)))
                    {
                        ok = false;
                        break;
                    }
                }

                if (ok == true)  //all model endogenous are found in the databank. If so, we add the extra model info. If not, only HDG and stamp are written into xml.
                {

                    XmlElement modelName = doc.CreateElement("ModelName");
                    modelName.InnerText = Path.GetFileName(Program.model.modelGekko.modelInfo.fileName);
                    root.AppendChild(modelName);

                    XmlElement modelInfo = doc.CreateElement("ModelInfo");
                    modelInfo.InnerText = Program.model.modelGekko.modelInfo.info;
                    root.AppendChild(modelInfo);

                    XmlElement modelDate = doc.CreateElement("ModelDate");
                    modelDate.InnerText = Program.model.modelGekko.modelInfo.date;
                    root.AppendChild(modelDate);

                    XmlElement modelSignature = doc.CreateElement("ModelSignature");
                    modelSignature.InnerText = Program.model.modelGekko.signatureFoundInFileHeader;
                    root.AppendChild(modelSignature);

                    XmlElement modelHash = doc.CreateElement("ModelHash");
                    modelHash.InnerText = Program.model.modelGekko.modelHashTrue;
                    root.AppendChild(modelHash);

                    XmlElement modelLastSimPeriod = doc.CreateElement("ModelLastSimPeriod");
                    if (Program.model.modelGekko.lastSimPer1.IsNull() || Program.model.modelGekko.lastSimPer2.IsNull()) modelLastSimPeriod.InnerText = "";
                    else modelLastSimPeriod.InnerText = G.FromDateToString(Program.model.modelGekko.lastSimPer1) + "-" + G.FromDateToString(Program.model.modelGekko.lastSimPer2);
                    root.AppendChild(modelLastSimPeriod);

                    XmlElement modelLastSimStamp = doc.CreateElement("ModelLastSimStamp");
                    modelLastSimStamp.InnerText = Program.model.modelGekko.lastSimStamp;
                    root.AppendChild(modelLastSimStamp);

                    XmlElement modelLargestLag = doc.CreateElement("ModelLargestLag");
                    modelLargestLag.InnerText = "" + Program.model.modelGekko.largestLag;
                    root.AppendChild(modelLargestLag);

                    XmlElement modelLargestLead = doc.CreateElement("ModelLargestLead");
                    modelLargestLead.InnerText = "" + Program.model.modelGekko.largestLead;
                    root.AppendChild(modelLargestLead);
                }
            }

            string xmlOutput = doc.OuterXml;
            using (FileStream fs = WaitForFileStream(tempTsdxPath + "\\" + "DatabankInfo.xml", GekkoFileReadOrWrite.Write))
            {
                doc.Save(fs);
            }
        }

        public static string GetDateTimeStamp()
        {
            DateTime date1 = DateTime.Now;
            string now = date1.ToString("G", CultureInfo.CreateSpecificCulture("da-DK"));
            return now;
        }

        public static string GetDateStamp()
        {
            //See also #80927435209843
            DateTime date1 = DateTime.Now;
            string now = date1.ToString("d", CultureInfo.CreateSpecificCulture("da-DK"));
            return now;
        }

        public static string GetTimeStamp()
        {
            DateTime date1 = DateTime.Now;
            string now = date1.ToString("T", CultureInfo.CreateSpecificCulture("da-DK"));
            return now;
        }



        //This is a general method for zipping the contents of a folder
        public static void WaitForZipWrite(string folder, string zipFileName)
        {
            string path_zipFileName = Path.GetDirectoryName(zipFileName);
            if (!Directory.Exists(path_zipFileName))
            {
                G.Writeln2("*** ERROR: The directory '" + path_zipFileName + "' does not seem to exist");
                throw new GekkoException();
            }

            DirectoryInfo folderInfo = new DirectoryInfo(folder);

            if (Globals.threadIsInProcessOfAborting && !Globals.applicationIsInProcessOfAborting) throw new GekkoException();
            try
            {
                if (zipFileName.ToLower().EndsWith("." + Globals.extensionDatabank + "") && Program.options.databank_file_gbk_compress == false)
                {
                    G.Writeln2("+++ WARNING: 'OPTION databank file gbk compress = yes' is deprecated");
                    G.Writeln("             in Gekko 3.1.9 and onwards.", Globals.warningColor);
                    throw new GekkoException();
                }
                if (!System.IO.Directory.Exists(folderInfo.FullName))
                {
                    G.Writeln("+++ WARNING: zip file could not be created");  //should not be possible                        
                }

                int sleepMs = 10;

                using (FileStream fs = Program.WaitForFileStream(zipFileName, Program.GekkoFileReadOrWrite.Write))
                {
                    //fs is not actually used, but this way we wait for blocked files
                    Thread.Sleep(sleepMs);  //to make sure the file is released
                }
                
                File.Delete(zipFileName);
                Thread.Sleep(sleepMs);  //give some time after file is deleted
                ZipFile.CreateFromDirectory(folder, zipFileName);
            }
            catch (Exception e)
            {                
                G.Writeln("*** ERROR: Zip write failed, error: " + e.InnerException + " " + e.Message);
                throw new GekkoException();
            }

            try
            {
                if (System.IO.Directory.Exists(folderInfo.FullName))
                {
                    System.IO.Directory.Delete(folderInfo.FullName, true);
                }
            }
            catch (Exception e)
            {
                //do nothing
            }
        }

        //Only used for reading TSDX files, much more specific than WaitForZipRead()
        public static string WaitForZipRead_TSDX(string folder, string zipFileName, string inside, string originalFileName)
        {
            
            
            //is not actually waiting...
            int gap = Globals.waitFileGap;  //1 second
            int totalTime = Globals.waitFileTotalTime;  //600 seconds
            int repeats = totalTime / gap;
            string tsdFile = "";
            bool isProtobuf = false;
            string ext = Path.GetExtension(zipFileName);
            if (G.Equal(ext, "." + Globals.extensionDatabank)) isProtobuf = true; //with .gbk files, the inside is always protobuf-files.
            DirectoryInfo folderInfo = new DirectoryInfo(folder);
            if (Globals.threadIsInProcessOfAborting && !Globals.applicationIsInProcessOfAborting) throw new GekkoException();
            //try-catch is not used here: normally a zip-file can be read even if blocked by others (not so for writing)                                

            try
            {
                ZipFile.ExtractToDirectory(zipFileName, folder);
            }
            catch (Exception e)
            {
                G.Writeln2("*** ERROR: Zip extraction failed: " + e.InnerException + " " + e.Message);
            }
            
            string xmlFile = "";
            int tsdfilecounter = 0;
            foreach (FileInfo fi in (new DirectoryInfo(folder)).GetFiles())
            {
                string fileName2 = fi.Name;

                if (G.Equal(fileName2, Globals.protobufFileName) || G.Equal(fileName2, Globals.protobufFileName2) || G.Equal(fileName2, Program.options.databank_file_gbk_internal))
                {
                    //this is only relevant for the older .tsdx files, .gbk files always has isProtobuf = true.
                    isProtobuf = true;
                }
                
                if (string.Compare(inside, fileName2, true) == 0)
                {
                    //This is only for legacy reasons: all new tsdx files have databank.tsd as internal file.
                    //Remove this option a some point.
                    tsdFile = fileName2;
                    tsdfilecounter++;
                }
                if (string.Compare("databank.tsd", fileName2, true) == 0)
                {
                    tsdFile = fileName2;
                    tsdfilecounter++;
                }
                if (string.Compare("DatabankInfo.xml", fileName2, true) == 0)
                {
                    xmlFile = fileName2;
                }
            }

            if (xmlFile == "")
            {
                G.Writeln2("*** ERROR: Cannot find xml-file inside zip-file. Expected to find '" + "DatabankInfo.xml" + "' inside '" + originalFileName + "'");
                throw new GekkoException();
            }
            
            if (isProtobuf)
            {                
                tsdFile = Globals.isAProto;  //okay, this is a hacky way to signal back...
            }
            else
            {
                if (tsdfilecounter == 2 && G.Equal(inside, "databank.tsd"))
                {
                    //the rare case where the databank file name is "databank"
                    tsdfilecounter = 1;
                }

                if (tsdfilecounter > 1)
                {
                    G.Writeln2("*** ERROR: Found several tsd-files inside zip-file. Cannot decide which one to use");
                    throw new GekkoException();
                }

                if (tsdFile == "")
                {
                    G.Writeln2("*** ERROR: Cannot find tsd-file inside zip-file. Expected to find '" + inside + "' inside '" + originalFileName + "'");
                    throw new GekkoException();
                }                             
            }

            return tsdFile;
        }

        public static void WaitForZipRead(string folderToUseForOutput, string zipFileNameAndPath)
        {
            //is not actually waiting...
            int gap = Globals.waitFileGap;  //1 second
            int totalTime = Globals.waitFileTotalTime;  //600 seconds
            int repeats = totalTime / gap;
            string tsdFile = "";
            DirectoryInfo folderInfo = new DirectoryInfo(folderToUseForOutput);
            if (Globals.threadIsInProcessOfAborting && !Globals.applicationIsInProcessOfAborting) throw new GekkoException();
            //try-catch is not used here: normally a zip-file can be read even if blocked by others (not so for writing)            

            try
            {
                ZipFile.ExtractToDirectory(zipFileNameAndPath, folderToUseForOutput);
            }
            catch (Exception e)
            {
                G.Writeln2("*** ERROR: Zip extraction failed: " + e.InnerException + " " + e.Message);
            }

            return;
        }

        public static void AbortingReset()
        {
            Globals.threadIsInProcessOfAborting = false;  //clearing this
            Globals.applicationIsInProcessOfAborting = false;  //clearing this
        }

        public static FileStream WaitForFileStream(string pathAndFilename, GekkoFileReadOrWrite type)
        {
            return WaitForFileStream(pathAndFilename, type, false);
        }

        public static FileStream WaitForFileStream(string pathAndFilename, GekkoFileReadOrWrite type, bool printAnyExceptionOnScreen)
        {
            FileStream fs = null;

            int gap = Globals.waitFileGap;  //1 second
            int totalTime = Globals.waitFileTotalTime;  //600 seconds
            int repeats = totalTime / gap;

            FileMode fm = FileMode.Create;  //if writing, -- if the file exists overwrite it, otherwise create it
            if (type == GekkoFileReadOrWrite.WriteAppend) fm = FileMode.Append; //if writing, -- if the file exists append to it, otherwise create it

            FileAccess fa = FileAccess.Write; //if writing
            FileShare fsh = FileShare.None; //if writing, -- don't allow others to read while we write

            if (type == GekkoFileReadOrWrite.Read)
            {
                fm = FileMode.Open; //if reading
                fa = FileAccess.Read; //if reading
                fsh = FileShare.Read; ; //if reading
            }

            for (int i = 0; i < repeats; i++)
            {
                if (Globals.threadIsInProcessOfAborting && !Globals.applicationIsInProcessOfAborting) throw new GekkoException();

                string pathName = Path.GetDirectoryName(pathAndFilename);

                if (type == GekkoFileReadOrWrite.Read)
                {
                    //checking if the file is there at all for reading
                    if (!File.Exists(pathAndFilename))
                    {
                        G.Writeln2("*** ERROR: Could not find file '" + pathAndFilename + "' for reading");
                        if (!Directory.Exists(pathName)) G.Writeln2("*** ERROR: The directory '" + pathName + "' does not seem to exist");
                        throw new GekkoException();
                    }
                }
                else if (type == GekkoFileReadOrWrite.WriteAppend)
                {
                    //checking if the file is there at all for appending
                    if (!File.Exists(pathAndFilename))
                    {
                        G.Writeln2("*** ERROR: Could not find file '" + pathAndFilename + "' for appending");
                        if (!Directory.Exists(pathName)) G.Writeln2("*** ERROR: The directory '" + pathName + "' does not seem to exist");
                        throw new GekkoException();
                    }
                }
                else if (type == GekkoFileReadOrWrite.Write)
                {
                    //checking if the path exists for writing the file
                    //string extension = Path.GetExtension(pathAndFilename);

                    if (Directory.Exists(pathAndFilename))
                    {
                        G.Writeln2("*** ERROR: There exists a folder with the same name: " + pathAndFilename);
                        throw new GekkoException();
                    }

                    if (pathName != "")  //sometimes pathAndFilename may be just the filename??
                    {
                        if (!Directory.Exists(pathName))
                        {
                            G.Writeln2("*** ERROR: Could not find directory '" + pathName + "' for writing");
                            throw new GekkoException();
                        }
                    }
                }

                try
                {
                    fs = File.Open(pathAndFilename, fm, fa, fsh);
                }
                catch (UnauthorizedAccessException e)
                {
                    //G.Writeln2("*** ERROR: It seems the file may be read-only: " + pathAndFilename);
                    //throw;
                    G.Writeln("+++ WARNING: File '" + pathAndFilename + "' seems read-only. Retrying... (" + (i * gap) + " seconds)");
                    System.Threading.Thread.Sleep(gap * 1000);  //1 seconds
                    continue;

                }
                catch (Exception e)
                {                    
                    G.Writeln("+++ WARNING: File '" + pathAndFilename + "' seems blocked. Retrying... (" + (i * gap) + " seconds)");
                    System.Threading.Thread.Sleep(gap * 1000);  //1 seconds
                    continue;
                }
                break;
            }
            if (fs == null)
            {
                G.Writeln2("*** ERROR: Gave up on file '" + pathAndFilename + "'. Is it blocked by another program?");
                throw new GekkoException();
            }
            return fs;
        }

        public static void WaitForFileCopy(string pathAndFilenameSource, string pathAndFilenameDestination)
        {
            WaitForFileCopyDeleteAbstract(pathAndFilenameSource, pathAndFilenameDestination, "copy");
        }

        public static void WaitForFileDelete(string pathAndFilenameSource)
        {
            WaitForFileCopyDeleteAbstract(pathAndFilenameSource, null, "delete");
        }

        private static void WaitForFileCopyDeleteAbstract(string pathAndFilenameSource, string pathAndFilenameDestination, string type)
        {
            if (!(type == "copy" || type == "delete"))
            {
                G.Writeln2("*** ERROR: Sorry, internal Gekko error #837432");
                throw new GekkoException();
            }

            string dir = Path.GetDirectoryName(pathAndFilenameDestination);
            if (type == "copy" && !Directory.Exists(dir))
            {
                G.Writeln2("*** ERROR: The folder " + dir + " does not exist for file copying");
                throw new GekkoException();
            }

            int gap = Globals.waitFileGap;  //2 second
            int totalTime = Globals.waitFileTotalTime;  //600 seconds
            int repeats = totalTime / gap;
            bool success = false;

            for (int i = 0; i < repeats; i++)
            {
                if (Globals.threadIsInProcessOfAborting && !Globals.applicationIsInProcessOfAborting) throw new GekkoException();

                string pathName = Path.GetDirectoryName(pathAndFilenameSource);

                //checking if the file is there at all
                if (!File.Exists(pathAndFilenameSource))
                {
                    G.Writeln2("*** ERROR: Could not find file '" + pathAndFilenameSource + "' (for " + type + ")");
                    if (!Directory.Exists(pathName)) G.Writeln2("*** ERROR: The directory '" + pathName + "' does not seem to exist");
                    throw new GekkoException();
                }

                success = true;
                try
                {
                    if (type == "copy")
                    {
                        File.Copy(pathAndFilenameSource, pathAndFilenameDestination, true);
                    }
                    else if (type == "delete")
                    {
                        File.Delete(pathAndFilenameSource);
                    }
                }
                catch (Exception e)
                {
                    success = false;
                    if (type == "copy")
                    {
                        G.Writeln("+++ WARNING: File '" + pathAndFilenameSource + "' or '" + pathAndFilenameDestination + "'seems blocked. Retrying... (" + (i * gap) + " seconds)");
                    }
                    else if (type == "delete")
                    {
                        G.Writeln("+++ WARNING: File '" + pathAndFilenameSource + "' seems blocked. Retrying... (" + (i * gap) + " seconds)");
                    }
                    System.Threading.Thread.Sleep(gap * 1000);  //2 seconds
                    continue;
                }
                break;
            }
            if (success == false)
            {
                if (type == "copy")
                {
                    G.Writeln2("*** ERROR: Gave up on copying '" + pathAndFilenameSource + "' to '" + pathAndFilenameDestination + "'. Is one of these files opened/blocked by another program?");
                }
                else if (type == "delete")
                {
                    G.Writeln2("*** ERROR: Gave up on deleting file '" + pathAndFilenameSource + "'. Is it opened/blocked by another program?");
                }
                throw new GekkoException();
            }
            return;
        }

        private static int CsvPrnWrite(List<ToFrom> vars, string filename, GekkoTime per1, GekkoTime per2, EdataFormat dateFormat, bool cols, string dateformat)
        {

            bool isFirst = true;
            string format = SplitDateFormatInTwo(dateformat, ref isFirst);

            int prnWidth = 20;            

            int i = 1;
            int j = 1;
            TableLight tab = new TableLight();

            if (dateFormat == EdataFormat.Csv)
            {
                G.Writeln2("Writing csv file for the period " + G.FromDateToString(per1) + "-" + G.FromDateToString(per2));
                filename = AddExtension(filename, ".csv");
            }
            else if (dateFormat == EdataFormat.Prn)
            {
                G.Writeln2("Writing prn file for the period " + G.FromDateToString(per1) + "-" + G.FromDateToString(per2));
                filename = AddExtension(filename, ".prn");
            }

            string pathAndFilename = CreateFullPathAndFileName(filename);
            int counter = 0;
            if (true)
            {
                //Writing to csv/prn file                              

                if (dateFormat == EdataFormat.Prn)
                {
                    //file.Write(G.varFormat("name", prnWidth));

                    if (cols)
                    {
                        tab.Add(i, j, new CellLight(G.varFormat("date", prnWidth))); j++;
                    }
                    else
                    {
                        tab.Add(i, j, new CellLight(G.varFormat("name", prnWidth))); j++;
                    }
                }
                else
                {
                    tab.Add(i, j, new CellLight("")); j++;  //empty cell
                }
                foreach (GekkoTime t in new GekkoTimeIterator(per1, per2))
                {                    

                    if (dateFormat == EdataFormat.Csv)
                    {
                        string dateStringCsv = null;
                        if (IsGekkoDateFormat(format))
                        {
                            dateStringCsv = t.ToString();
                        }
                        else
                        {
                            DateTime dt; string f; GekkoTime.FromGekkoTimeToDifferentFormatsForWriting(t, isFirst, format, out dt, out f, out dateStringCsv);
                        }
                        tab.Add(i, j, new CellLight(dateStringCsv)); j++;
                    }
                    else
                    {                        
                        tab.Add(i, j, new CellLight(G.varFormat(" " + t.ToString(), prnWidth))); j++;
                    }
                }
                
                i++;                

                foreach (ToFrom var in vars)
                {
                    j = 1;
                    string s3 = G.Chop_GetName(var.s2);  //If for instance export <csv> fy* file = test; the .s2 will be varnames with first bank glued on (typically work), and this bank is removed here.

                    IVariable iv = O.GetIVariableFromString(var.s1, O.ECreatePossibilities.NoneReportError, true);
                    Series ts = iv as Series;
                    
                    GekkoTime tsStart = ts.GetPeriodFirst();
                    GekkoTime tsEnd = ts.GetPeriodLast();

                    counter++;
                    if (dateFormat == EdataFormat.Csv)
                    {                        
                        tab.Add(i, j, new CellLight(s3)); j++;
                    }
                    else
                    {                        
                        tab.Add(i, j, new CellLight(G.varFormat(s3, prnWidth))); j++;
                    }
                    foreach (GekkoTime t in new GekkoTimeIterator(per1, per2))
                    {                        
                        double data = ts.GetDataSimple(t);  //no lag or anything here, smpl can be null...?
                        if (G.isNumericalError(data))
                        {
                            if (t.StrictlySmallerThan(tsStart) || t.StrictlyLargerThan(tsEnd))
                            {
                                if (dateFormat == EdataFormat.Csv)
                                {
                                    //write nothing, indicates out-of-sample
                                    tab.Add(i, j, new CellLight("")); j++;
                                }
                                else
                                {
                                    //"", indicates out-of-sample
                                    tab.Add(i, j, new CellLight(G.varFormat(" \"\"", prnWidth))); j++;
                                }
                            }
                            else
                            {
                                string s = HandleFunnyNumbers(dateFormat == EdataFormat.Csv);
                                if (dateFormat == EdataFormat.Csv)
                                {
                                    tab.Add(i, j, new CellLight(s)); j++;                                    
                                }
                                else
                                {                                    
                                    tab.Add(i, j, new CellLight(G.varFormat(s, prnWidth))); j++;
                                }
                            }
                        }
                        else
                        {
                            string s = null;

                            bool fixProblem = true;

                            if (fixProblem)
                            {
                                s = data.ToString();
                                if (Program.options.interface_csv_ndec < 20)
                                {
                                    s = Program.NumberFormat(data, "f" + Program.options.interface_csv_ndec);
                                }
                                if (G.Equal(Program.options.interface_csv_decimalseparator, "period"))
                                {
                                    //ok                                        
                                }
                                else if (G.Equal(Program.options.interface_csv_decimalseparator, "comma"))
                                {
                                    s = s.Replace(".", ",");
                                }
                                else
                                {
                                    G.Writeln2("*** ERROR #8423824: Unknown decimalseparator");
                                    throw new GekkoException();
                                }
                            }
                            else
                            {
                                if (G.Equal(Program.options.interface_csv_decimalseparator, "period"))
                                {

                                    {
                                        //The 0:... is alignment inside a field.
                                        s = string.Format(System.Globalization.CultureInfo.InvariantCulture, "{0:0.0000000000E+00}", data);
                                    }
                                }
                                else if (G.Equal(Program.options.interface_csv_decimalseparator, "comma"))
                                {
                                    NumberFormatInfo nfi = new NumberFormatInfo();
                                    nfi.NumberDecimalSeparator = ",";

                                    {
                                        s = string.Format(nfi, "{0:0.0000000000E+00}", data);
                                    }
                                }
                                else
                                {
                                    G.Writeln2("*** ERROR #8423824: Unknown decimalseparator");
                                    throw new GekkoException();
                                }
                            }


                            if (dateFormat == EdataFormat.Csv)
                            {                                                         
                                tab.Add(i, j, new CellLight(s)); j++;                                
                            }
                            else
                            {
                                //prn and gnuplot
                                if (data < 0)
                                {                                    
                                    tab.Add(i, j, new CellLight(G.varFormat(" " + s, prnWidth))); j++;
                                }
                                else
                                {                                    
                                    tab.Add(i, j, new CellLight(G.varFormat("  " + s, prnWidth))); j++;
                                }
                            }
                        }
                    }
                    
                    i++;
                }
                                
            }

            if (cols)
            {
                tab = tab.Transpose();
            }

            string csvDelimiter = ";";
            if (G.Equal(Program.options.interface_csv_delimiter, "comma")) csvDelimiter = ",";

            if (G.Equal(Program.options.interface_csv_delimiter, "comma") && G.Equal(Program.options.interface_csv_decimalseparator, "comma"))
            {
                G.Writeln2("+++ WARNING: Using comma both as decimal separator and field delimiter is not advised");
            }

            using (FileStream fs = WaitForFileStream(pathAndFilename, GekkoFileReadOrWrite.Write))
            using (StreamWriter file = G.GekkoStreamWriter(fs))
            {
                for (int ii = 1; ii <= tab.GetRowMaxNumber(); ii++)
                {
                    if (ii == 1 && cols && dateFormat == EdataFormat.Prn) file.Write(" ");  //strange that this is necessary
                    for (int jj = 1; jj <= tab.GetColMaxNumber(); jj++)
                    {
                        CellLight c = tab.Get(ii, jj);
                        if (c.type == ECellLightType.None) continue;  //skip
                        if (dateFormat == EdataFormat.Csv)
                        {
                            if (jj > 1) file.Write(csvDelimiter);
                            file.Write(c.text);
                        }
                        else
                        {
                            file.Write(c.text);
                        }
                    }
                    file.WriteLine();
                }
                file.Flush();
            }

            G.Writeln("Wrote " + counter + " variables to " + pathAndFilename);

            return counter;
        }


        private static int CsvPrnWriteOLD(List<ToFrom> vars, string filename, GekkoTime per1, GekkoTime per2, EdataFormat format)
        {
            int prnWidth = 18;
            //Databank first = Program.databanks.GetFirst();
            
            if (format == EdataFormat.Csv)
            {
                G.Writeln2("Writing csv file for the period " + G.FromDateToString(per1) + "-" + G.FromDateToString(per2));
                filename = AddExtension(filename, ".csv");
            }
            else if (format == EdataFormat.Prn)
            {
                G.Writeln2("Writing prn file for the period " + G.FromDateToString(per1) + "-" + G.FromDateToString(per2));
                filename = AddExtension(filename, ".prn");
            }            

            string pathAndFilename = CreateFullPathAndFileName(filename);
            int counter = 0;
            using (FileStream fs = WaitForFileStream(pathAndFilename, GekkoFileReadOrWrite.Write))
            using (StreamWriter file = G.GekkoStreamWriter(fs))
            {
                //Writing to csv/prn file

                if (format == EdataFormat.Prn) file.Write(G.varFormat("name", prnWidth));
                foreach (GekkoTime t in new GekkoTimeIterator( per1, per2))
                {
                    if (format == EdataFormat.Csv) file.Write(";" + t.ToString());
                    else file.Write(G.varFormat(" " + t.ToString(), prnWidth));  //both prn and gnuplot
                }
                file.WriteLine();

                foreach (ToFrom var in vars)
                {
                    //string s3 = var.name;
                    //Databank db = GetBankFromBankNameVersion(var.bank);
                    IVariable iv = O.GetIVariableFromString(var.s1, O.ECreatePossibilities.NoneReportError, true);
                    //Series ts = db.GetVariable(s3);  //#getvar
                    Series ts = iv as Series;
                    if (ts == null)
                    {
                        //TODO: check this beforehand, and do a msgbox with all missing vars (a la when doing sim)
                        G.Writeln2("*** ERROR: Variable " + var.s1 + " of wrong type");
                        throw new GekkoException();
                    }

                    GekkoTime tsStart = ts.GetPeriodFirst();
                    GekkoTime tsEnd = ts.GetPeriodLast();

                    counter++;
                    string temp = G.Chop_GetName(var.s2);
                    if (format == EdataFormat.Csv) file.Write(temp);
                    else file.Write(G.varFormat(temp, prnWidth));  //prn and gnuplot
                    foreach (GekkoTime t in new GekkoTimeIterator( per1, per2))
                    {
                        if (format == EdataFormat.Csv) file.Write(";");
                        double data = ts.GetDataSimple(t);
                        if (G.isNumericalError(data))
                        {
                            if (t.StrictlySmallerThan(tsStart) || t.StrictlyLargerThan(tsEnd))
                            {
                                if (format == EdataFormat.Csv) file.Write(""); //write nothing, indicates out-of-sample
                                else file.Write(G.varFormat(" \"\"", prnWidth)); //write "", indicates out-of-sample
                            }
                            else
                            {
                                string s = HandleFunnyNumbers(format == EdataFormat.Csv);
                                if (format == EdataFormat.Csv) file.Write(s);
                                else file.Write(G.varFormat(s, prnWidth));
                            }
                        }
                        else
                        {
                            string s = null;
                            if (G.Equal(Program.options.interface_csv_decimalseparator, "period"))
                            {
                                s = string.Format(System.Globalization.CultureInfo.InvariantCulture, "{0:0.0000000000E+00}", data);
                            }
                            else if (G.Equal(Program.options.interface_csv_decimalseparator, "comma"))
                            {
                                s = string.Format(System.Globalization.CultureInfo.InvariantCulture, "{0:0,0000000000E+00}", data);
                            }
                            else
                            {
                                G.Writeln2("*** ERROR #8423824: Unknown decimalseparator");
                                throw new GekkoException();
                            }
                            if (format == EdataFormat.Csv)
                            {
                                if (data < 0) file.Write(s);
                                else file.Write(" " + s);
                            }
                            else
                            {
                                //prn and gnuplot
                                if (data < 0) file.Write(G.varFormat(s, prnWidth));
                                else file.Write(G.varFormat(" " + s, prnWidth));
                            }
                        }
                    }
                    file.WriteLine();
                }
                file.Flush();
            }

            G.Writeln("Wrote " + counter + " variables to " + pathAndFilename);

            return counter;
        }

        private static void GetDatabankPeriodFilteredForFreq(List<ToFrom> vars, ref GekkoTime per1, ref GekkoTime per2)
        {
            //Databank first = Program.databanks.GetFirst();
            //vars: annual is fy, quarterly is fy%q, monthly is fy%m, undated is fy%u
            int start = int.MaxValue;
            int end = int.MinValue;
            foreach (ToFrom s in vars)
            {
                IVariable iv = O.GetIVariableFromString(s.s1, O.ECreatePossibilities.NoneReportError, true);
                if (iv.Type() != EVariableType.Series) continue;  //should never happen                
                Series ts = (Series)iv;
                if (ts.type != ESeriesType.Normal) continue;
                
                start = G.GekkoMin(start, ts.GetPeriodFirst().super);
                end = G.GekkoMax(end, ts.GetPeriodLast().super);                
            }
            GetQuartersOrMonthsFromYears(ref per1, ref per2, start, end);
        }

        private static Databank GetBankFromBankNameVersion(string bankName)
        {
            Databank db = null;
            if (bankName == null) db = Program.databanks.GetFirst();
            else db = Program.databanks.GetDatabank(bankName);
            if (db == null)
            {
                G.Writeln2("*** ERROR: Databank '" + bankName + "' not found");
                throw new GekkoException();
            }
            return db;
        }

        private static void GetQuartersOrMonthsFromYears(ref GekkoTime per1, ref GekkoTime per2, int yearStart, int yearEnd)
        {
            //========================================================================================================
            //                          FREQUENCY LOCATION, indicates where to implement more frequencies
            //========================================================================================================

            //see also #980432
            if ((Program.options.freq == EFreq.A))
            {
                per1 = new GekkoTime((Program.options.freq), yearStart, 1);
                per2 = new GekkoTime((Program.options.freq), yearEnd, 1);
            }
            else if ((Program.options.freq == EFreq.Q))
            {
                per1 = new GekkoTime((Program.options.freq), yearStart, 1);
                per2 = new GekkoTime((Program.options.freq), yearEnd, 4);
            }
            else if ((Program.options.freq == EFreq.M))
            {
                per1 = new GekkoTime((Program.options.freq), yearStart, 1);
                per2 = new GekkoTime((Program.options.freq), yearEnd, 12);
            }
            else if ((Program.options.freq == EFreq.D))
            {
                per1 = new GekkoTime((Program.options.freq), yearStart, 1, 1);
                per2 = new GekkoTime((Program.options.freq), yearEnd, 12, 31);
            }
        }

        private static int GnuplotWrite(List<ToFrom> vars, string filename, GekkoTime per1, GekkoTime per2)
        {
            int prnWidth = 18;
            //Databank first = Program.databanks.GetFirst();

            G.Writeln2("Writing gnuplot file for the period " + G.FromDateToString(per1) + "-" + G.FromDateToString(per2));
            filename = AddExtension(filename, ".dat");

            string pathAndFilename = CreateFullPathAndFileName(filename);
            int counter = 0;
            using (FileStream fs = WaitForFileStream(pathAndFilename, GekkoFileReadOrWrite.Write))
            using (StreamWriter file = G.GekkoStreamWriter(fs))
            {
                //Writing to csv/prn file

                file.Write("# " + G.Blanks(prnWidth));  //comment
                foreach (ToFrom var in vars)
                {
                    //string s3 = var.name;
                    //Databank db = GetBankFromBankNameVersion(var.bank);
                    //Series ts = db.GetVariable(s3); //#getvar
                    IVariable iv = O.GetIVariableFromString(var.s1, O.ECreatePossibilities.NoneReportError, true);
                    Series ts= iv as Series;
                    if (ts == null)
                    {
                        G.Writeln2("*** ERROR: Variable '" + var.s1 + "' is of wrong type");
                        throw new GekkoException();
                    }
                    file.Write(G.varFormat(G.Chop_GetName(var.s2), prnWidth));  //prn and gnuplot
                }
                file.WriteLine();

                foreach (GekkoTime t in new GekkoTimeIterator(per1, per2))
                {
                    file.Write(GetDateStringSuitableForGnuplot(t.ToString()) + " ");
                    foreach (ToFrom var in vars)
                    {
                        //string s3 = var.name;
                        //Databank db = GetBankFromBankNameVersion(var.bank);
                        //Series ts = db.GetVariable(s3);  //existence has been checked //#getvar

                        IVariable iv = O.GetIVariableFromString(var.s1, O.ECreatePossibilities.NoneReportError, true);
                        Series ts = iv as Series;

                        double data = ts.GetDataSimple(t);
                        if (G.isNumericalError(data))
                        {
                            file.Write("NaN");
                        }
                        else
                        {
                            string s = string.Format(System.Globalization.CultureInfo.InvariantCulture, "{0:0.0000000000E+00}", data);
                            if (data < 0) file.Write(G.varFormat(s, prnWidth));
                            else file.Write(G.varFormat(" " + s, prnWidth));
                        }
                    }
                    file.WriteLine();
                }
                file.Flush();
            }

            G.Writeln("Wrote " + vars.Count + " variables to " + pathAndFilename);

            return vars.Count;
        }

        private static string HandleFunnyNumbers(bool isCsv)
        {
            string s = "";
            if (isCsv)
            {
                if (G.Equal(Program.options.interface_excel_language, "danish"))
                {
                    s = "#NAVN?";  //missing value indicator (M) -- SHEET uses na()
                }
                else
                {
                    s = "#NAME?";  //missing value indicator (M) -- SHEET uses na()
                }
            }
            else
            {
                s = " 1.0e+15";
            }
            return s;
        }

        private static int Tspwrite(List<ToFrom> vars, string filename, GekkoTime per1, GekkoTime per2, bool isCaps)
        {
            //Databank work = Program.databanks.GetFirst();
            filename = filename;
            filename = AddExtension(filename, ".tsp");
            string pathAndFilename = CreateFullPathAndFileName(filename);
            int counter = 0;
            using (FileStream fs = WaitForFileStream(pathAndFilename, GekkoFileReadOrWrite.Write))
            using (StreamWriter file = G.GekkoStreamWriter(fs))
            {
                string fileName = Path.GetFileName(pathAndFilename);
                file.WriteLine("? This file is produced by Gekko, and contains " + vars.Count + " LOAD-statements with data.");
                file.WriteLine("? You may INPUT this file in your TSP program, but for large datasets it");
                file.WriteLine("? may be better to create a TSP databank (.tlb).");
                file.WriteLine("? To do this, you may try the following statements:");
                file.WriteLine("?");
                file.WriteLine("?   options memory = 1000; ? 1000 MB");
                file.WriteLine("?   out mybankname;");
                file.WriteLine("?   input " + fileName + ";");
                file.WriteLine("?");
                file.WriteLine("? However, there seems to be a limit to the number of lines in a .tsp file,");
                file.WriteLine("? so you may have to split " + fileName + " into several files if it is large.");
                file.WriteLine("? NOTE: if the TSP databank (above: 'mybankname.tlb') already exists, you should delete");
                file.WriteLine("? it first -- otherwise any variables/data in the already existing .tlb file will");
                file.WriteLine("? stay in the file.");
                file.WriteLine();
                file.WriteLine();
                file.WriteLine("freq a;");
                file.WriteLine();
                foreach (ToFrom var in vars)
                {
                    //Databank db = GetBankFromBankNameVersion(var.bank);                    
                    //Series ts = db.GetVariable(var.name);  //#getvar

                    IVariable iv = O.GetIVariableFromString(var.s1, O.ECreatePossibilities.NoneReportError, true);
                    Series ts = iv as Series;

                    if (ts == null)
                    {
                        //TODO: check this beforehand, and do a msgbox with all missing vars (a la when doing sim)
                        G.Writeln2("*** ERROR: Writing tsp file: variable " + var.s1 + " does not exist");
                        throw new GekkoException();
                    }
                    WriteTspRecord(per1, per2, file, ts, var.s2, isCaps);
                    counter++;
                }
                file.Flush();
            }

            if (true) G.Writeln("Wrote " + counter + " variables to " + pathAndFilename);
            return counter;
        }


        //============================================================================================
        //============================================================================================
        //============================================================================================


        /// <summary>
        /// Finds time series in data bank.
        /// </summary>
        /// <param name="databank">The databank</param>
        /// <param name="varName">The variable name</param>
        /// <returns></returns>
        public static Series FindOrCreateTimeSeriesInDataBank(Databank databank, string varName, EFreq frequency)
        {
            //This auto-creates timeseries for use when reading for example tsd or PCIM files
            //Has an overload used for UPD statements etc.
            Series ts = null;

            string varName2 = G.Chop_FreqAdd(varName, frequency);

            //string varName2 = Program.AddFreqAtEndOfVariableName(varName, frequency);

            if (!databank.ContainsIVariable(varName2))
            {
                ts = new Series(frequency, varName2);
                databank.AddIVariable(varName2, ts);
            }
            else
            {
                ts = databank.GetIVariable(varName2) as Series;
            }            
            return ts;
        }

        public static void Exit()
        {
            Globals.applicationIsInProcessOfAborting = true;
            Globals.threadIsInProcessOfAborting = true;
            throw new GekkoException();
        }

        public static void Cut()
        {
            Cut(true);
        }

        public static void Cut(bool print)
        {
            Gui.CloseAllDecompUdvalg(print);
        }

        public static void Pause(string arg)
        {
            arg = HandleNewlines(arg);
            if (arg.Length > 0)
            {
                G.Writeln();
                G.Writeln(arg);
            }
            if (arg.Length > 0) arg += "\n" + "\n";
            arg += "Press [Enter] to continue";
            MessageBox.Show(arg);
        }

        public static string HandleNewlines(string arg)
        {
            return arg.Replace("\\n", "\n");
        }

        public static void Clear(O.Clear o, P p)
        {
            //Take care with filename, when clearing: only wipe it out if it is Work or Ref banks, other banks may be OPENed banks that we would like to write back to when CLOSEing

            List<string> names = O.Restrict(o.names, false, false, false, false);

            if (names == null)
            {
                if (G.Equal(o.opt_first, "yes"))
                {
                    Program.databanks.GetFirst().Clear();
                    if (Program.databanks.GetFirst().name == Globals.Work || Program.databanks.GetFirst().name == Globals.Ref) Program.databanks.GetFirst().FileNameWithPath = null;
                    G.Writeln2("Cleared first databank ('" + Program.databanks.GetFirst().name + "')");
                }
                if (G.Equal(o.opt_ref, "yes"))
                {
                    Program.databanks.GetRef().Clear();
                    if (Program.databanks.GetRef().name == Globals.Work || Program.databanks.GetRef().name == Globals.Ref) Program.databanks.GetRef().FileNameWithPath = null;
                    G.Writeln2("Cleared ref databank ('" + Program.databanks.GetRef().name + "')");
                }

                if (!G.Equal(o.opt_first, "yes") && !G.Equal(o.opt_ref, "yes"))
                {
                    //Before: Cleared 'Work' and 'Ref' regardless of position
                    Program.databanks.GetFirst().Clear();
                    Program.databanks.GetRef().Clear();
                    if (Program.databanks.GetFirst().name == Globals.Work || Program.databanks.GetFirst().name == Globals.Ref) Program.databanks.GetFirst().FileNameWithPath = null;
                    if (Program.databanks.GetRef().name == Globals.Work || Program.databanks.GetRef().name == Globals.Ref) Program.databanks.GetRef().FileNameWithPath = null;
                    G.Writeln2("Cleared first and ref databanks ('" + Program.databanks.GetFirst().name + "' and '" + Program.databanks.GetRef().name + "')");
                }
            }
            else
            {

                foreach (string name in names)
                {

                    if (o.names != null && (o.opt_first != null || o.opt_ref != null))
                    {
                        G.Writeln2("*** ERROR: You should use 'CLEAR<first>;' or  'CLEAR<ref>;'");
                        throw new GekkoException();
                    }

                    if (o.names != null)
                    {
                        if (Program.databanks.GetDatabank(name) == null)
                        {
                            G.Writeln2("*** ERROR: Trying to clear non-existing databank '" + name + "'");
                            throw new GekkoException();
                        }

                        Databank db1 = Program.databanks.GetDatabank(name);
                        db1.Clear();
                        if (db1.name == Globals.Work || db1.name == Globals.Ref) db1.FileNameWithPath = null;
                        G.Writeln2("Cleared databank: " + name);
                    }
                    
                    
                }
            }
        }


        public static void MaybeWriteOpenDatabank(Databank removed)
        {
            //if (Globals.runningOnTTComputer)
            //{
            //    // #matisk
            //    if (removed.storage.ContainsKey("kcf!q"))
            //    {
            //        Series xx = removed.storage["kcf!q"] as Series;
            //        MessageBox.Show("WRITING databank dirty " + Program.IsDatabankDirty(removed) + " --> " + removed.name + " --- " + xx.meta.label + " --- " + xx.meta.source);
            //    }
            //}

            if (Program.IsDatabankDirty(removed))
            {
                if (removed.save == false)
                {
                    G.Writeln2("Databank '" + removed.name + "' closed, changes not written to file");
                }
                else if (!removed.editable)
                {
                    G.Writeln2("*** ERROR: Internal error #872543: a non-editable bank '" + removed.name + "' should not be possible to alter.");
                    throw new GekkoException();
                }                
                else
                {
                    Program.WriteRemovedDatabank(removed);
                }
            }
        }

        //public static IVariable Indexer(IVariable lag, GekkoSmpl smpl, IVariable x)
        //{
        //    return null;
        //}       

        //public static IVariable LagHelper(GekkoSmpl smpl, IVariable lag)
        //{
        //    int d = (int)lag.ConvertToVal();
        //    smpl.t0 = smpl.t0.Add(d);
        //    return lag;
        //}

        //public static GekkoLagFunction IndexerSLET(GekkoLagFunction glf, IVariable lag)
        //{            
        //    int ilag = (int)lag.ConvertToVal();
        //    GekkoLagFunction rv = new GekkoLagFunction(glf.t0.Add(ilag), glf.t3.Add(ilag), glf.func);
        //    return rv;
        //}

        public static void Re(GekkoSmpl smpl, string s, P p)
        {
            
            //s may be "reset" or "restart"
            bool ini = false;
            if (s == "restart") ini = true;
            Pipe("con", null, true);  //silently (mute) sets output to screen (Gekko might be piping)            
            int w = -12345;
            int b = -12345;
            MaybeWriteOpenDatabanks(ref w, ref b);
            Databank w2 = Program.databanks.storage[w]; w2.Clear();
            Databank b2 = Program.databanks.storage[b]; b2.Clear();
            Program.databanks.storage.Clear();
            Program.databanks.storage.Add(w2);
            Program.databanks.storage.Add(b2);
            Program.databanks.local.Clear();
            Program.databanks.global.Clear();
            Program.databanks.localGlobal = new LocalGlobal();     
            w2.FileNameWithPath = null;
            b2.FileNameWithPath = null;
            Globals.createdVariables.Clear();  //these should maybe live inside work databank
            //Program.scalars.Clear();
            //Program.lists.Clear();
            //Program.macros.Clear();
            Globals.commandMemory = new CommandMemory();  //these commands are only remembered up to last clearing of workspace
                                                          //Globals.prtCsSnippets.Clear();  //just to save ram  --> can induce bugs
                                                          //Globals.prtCsSnippetsHeaders.Clear(); //just to save ram --> can induce bugs

            //Globals.uFunctionStorageCs = new GekkoDictionary<string, string>(StringComparer.OrdinalIgnoreCase);  //resetting user functions

            //User functions: more can be added if necessary, or users can use LIST or DICT.
            InitUfunctionsAndArithmeticsAndMore();

            Globals.printCs = new Dictionary<int, Func<GraphHelper, string>>();

            Program.model = new Model();
            Program.unfoldedVariableList = null;

            Globals.modelFileName = "";
            GuiSetModelName();
            
            string workingFolder = Program.options.folder_working;
            Program.options = new Options();  //resetting these, but letting working folder live on.            

            CrossThreadStuff.Mode();  //to show default color

            Program.GetStartingPeriod();
            O.InitSmpl(smpl, p);  //Uses the method above. Just for ultra-safety, so that the smpl does not live on unadjusted after af RESET/RESTART

            Globals.globalPeriodTimeSpans = new GekkoTimeSpans();  //Probably not used anymore
            Globals.globalPeriodTimeFilters = new GekkoTimeSpans();  //nothing in .data yet.
            Globals.globalPeriodTimeFilters2 = new List<GekkoTime>();

            Globals.detectedRPath = null;  //we reset this, too
            Globals.r_fileContent = null;

            Program.alias = null;

            if (workingFolder != null && workingFolder != "")
            {
                Program.options.folder_working = workingFolder;
            }
            Globals.lastPrtOrMulprtTable = null;
            CrossThreadStuff.CopyButtonEnabled(false);
            //Globals.hasBeenTsdTsdxOptionChangeSinceLastClear = false;  //this logic can be removed in a couple of years (maybe in 2015)
            G.Writeln();
            G.Writeln("Clearing options, databanks, models, scalars, lists, collections and procedures/functions");
            if (ini) G.Writeln("INI files ('" + Globals.autoExecCmdFileName + "') will be run");
            else G.Writeln("No INI files ('" + Globals.autoExecCmdFileName + "') will be run");
            G.Writeln("Use CLS to clear the output window, and CUT to close plot/decomp windows.");
            if (ini)
            {
                G.Writeln();
                Program.Ini(p);
            }
            try
            {
                CrossThreadStuff.RestartMenuBrowser();
            }
            catch
            {
                //no need for this to fail badly...
            }
            Globals.guiHomeMainEnabled = false;
            Program.guiBrowseHistory.Clear();
            Program.guiBrowseNumber = 0;
            Globals.guiHomeMenuEnabled = false;

            Globals.expressionText = null;
            Globals.expression = null;
            Globals.expressions = null;
            //Globals.freeIndexedListsDecomp = null;

        //Program.Cut(false);

        RemoteInit();

            StartPulse();
        }

        public static void InitUfunctionsAndArithmeticsAndMore()
        {
            
            Globals.ufunctionsNew0 = new Dictionary<string, Func<GekkoSmpl, P, bool, IVariable>>(StringComparer.OrdinalIgnoreCase);
            Globals.ufunctionsNew1 = new Dictionary<string, Func<GekkoSmpl, P, bool, GekkoArg, IVariable>>(StringComparer.OrdinalIgnoreCase);
            Globals.ufunctionsNew2 = new Dictionary<string, Func<GekkoSmpl, P, bool, GekkoArg, GekkoArg, IVariable>>(StringComparer.OrdinalIgnoreCase);
            Globals.ufunctionsNew3 = new Dictionary<string, Func<GekkoSmpl, P, bool, GekkoArg, GekkoArg, GekkoArg, IVariable>>(StringComparer.OrdinalIgnoreCase);
            Globals.ufunctionsNew4 = new Dictionary<string, Func<GekkoSmpl, P, bool, GekkoArg, GekkoArg, GekkoArg, GekkoArg, IVariable>>(StringComparer.OrdinalIgnoreCase);
            Globals.ufunctionsNew5 = new Dictionary<string, Func<GekkoSmpl, P, bool, GekkoArg, GekkoArg, GekkoArg, GekkoArg, GekkoArg, IVariable>>(StringComparer.OrdinalIgnoreCase);
            Globals.ufunctionsNew6 = new Dictionary<string, Func<GekkoSmpl, P, bool, GekkoArg, GekkoArg, GekkoArg, GekkoArg, GekkoArg, GekkoArg, IVariable>>(StringComparer.OrdinalIgnoreCase);
            Globals.ufunctionsNew7 = new Dictionary<string, Func<GekkoSmpl, P, bool, GekkoArg, GekkoArg, GekkoArg, GekkoArg, GekkoArg, GekkoArg, GekkoArg, IVariable>>(StringComparer.OrdinalIgnoreCase);
            Globals.ufunctionsNew8 = new Dictionary<string, Func<GekkoSmpl, P, bool, GekkoArg, GekkoArg, GekkoArg, GekkoArg, GekkoArg, GekkoArg, GekkoArg, GekkoArg, IVariable>>(StringComparer.OrdinalIgnoreCase);
            Globals.ufunctionsNew9 = new Dictionary<string, Func<GekkoSmpl, P, bool, GekkoArg, GekkoArg, GekkoArg, GekkoArg, GekkoArg, GekkoArg, GekkoArg, GekkoArg, GekkoArg, IVariable>>(StringComparer.OrdinalIgnoreCase);
            Globals.ufunctionsNew10 = new Dictionary<string, Func<GekkoSmpl, P, bool, GekkoArg, GekkoArg, GekkoArg, GekkoArg, GekkoArg, GekkoArg, GekkoArg, GekkoArg, GekkoArg, GekkoArg, IVariable>>(StringComparer.OrdinalIgnoreCase);
            Globals.ufunctionsNew11 = new Dictionary<string, Func<GekkoSmpl, P, bool, GekkoArg, GekkoArg, GekkoArg, GekkoArg, GekkoArg, GekkoArg, GekkoArg, GekkoArg, GekkoArg, GekkoArg, GekkoArg, IVariable>>(StringComparer.OrdinalIgnoreCase);
            Globals.ufunctionsNew12 = new Dictionary<string, Func<GekkoSmpl, P, bool, GekkoArg, GekkoArg, GekkoArg, GekkoArg, GekkoArg, GekkoArg, GekkoArg, GekkoArg, GekkoArg, GekkoArg, GekkoArg, GekkoArg, IVariable>>(StringComparer.OrdinalIgnoreCase);
            Globals.ufunctionsNew13 = new Dictionary<string, Func<GekkoSmpl, P, bool, GekkoArg, GekkoArg, GekkoArg, GekkoArg, GekkoArg, GekkoArg, GekkoArg, GekkoArg, GekkoArg, GekkoArg, GekkoArg, GekkoArg, GekkoArg, IVariable>>(StringComparer.OrdinalIgnoreCase);
            
            Globals.arithmentics[0] = (x1, x2) => x1 + x2;
            Globals.arithmentics[1] = (x1, x2) => x2 + x1;
            Globals.arithmentics[2] = (x1, x2) => x1 - x2;
            Globals.arithmentics[3] = (x1, x2) => x2 - x1;
            Globals.arithmentics[4] = (x1, x2) => x1 * x2;
            Globals.arithmentics[5] = (x1, x2) => x2 * x1;
            Globals.arithmentics[6] = (x1, x2) => x1 / x2;
            Globals.arithmentics[7] = (x1, x2) => x2 / x1;
            Globals.arithmentics[8] = (x1, x2) => Math.Pow(x1, x2);
            Globals.arithmentics[9] = (x1, x2) => Math.Pow(x2, x1);
            Globals.arithmentics[10] = (x1, x2) => (x1 / x2 - 1d) * 100d;
            Globals.arithmentics[11] = (x1, x2) => Math.Log(x1 / x2);
            Globals.arithmentics[12] = (x1, x2) => Math.Round(x1, (int)x2, MidpointRounding.AwayFromZero);

            Globals.arithmentics1[0] = (x1) => -x1;
            Globals.arithmentics1[1] = (x1) => Math.Abs(x1);
            Globals.arithmentics1[2] = (x1) => Math.Log(x1);
            Globals.arithmentics1[3] = (x1) => Math.Exp(x1);
            Globals.arithmentics1[4] = (x1) => Math.Sqrt(x1);
            Globals.arithmentics1[5] = (x1) => Math.Truncate(x1); //same as (int)x1, but handles larger numbers 
            Globals.arithmentics1[6] = (x1) => Math.Floor(x1); //floor(-1.5) = -2, truncate(-1.5) = -1
            Globals.arithmentics1[7] = (x1) => Math.Ceiling(x1); //see above.

            Globals.timeStrings = new string[Globals.timeStringsEnd - Globals.timeStringsStart + 1];
            for (int i = Globals.timeStringsStart; i <= Globals.timeStringsEnd; i++)
            {
                Globals.timeStrings[i - Globals.timeStringsStart] = i.ToString();
            }            
        }

        public static List<string> Add2Lists(List<string> x1, List<string> x2)
        {
            List<string> x = new List<string>();
            x.AddRange(x1);
            x.AddRange(x2);
            return x;
        }

        public static void RemoteInit()
        {
            try
            {
                Globals.remoteFileStamp = new DateTime(0l);  //fresh init of this
                Globals.remoteIsInvestigating = false;  //fresh init of this
                Globals.remoteExists = -12345; //unknown
            }
            catch { }  //kind of ok if it fails
        }

        public static void StartPulse()
        {
            //Pulse (for remote.gcm)
            Globals.guiTimerCounter2 = 0;
            if (Globals.guiTimer2 == null)
            {
                Globals.guiTimer2 = new System.Timers.Timer();
                Globals.guiTimer2.Elapsed += new System.Timers.ElapsedEventHandler(OnTimedEvent2);
                Globals.guiTimer2.Interval = 200;  //every 0.2 s
            }
            Globals.guiTimer2.Stop();
            Globals.guiTimer2.Start();
        }

        private static void OnTimedEvent2(object source, System.Timers.ElapsedEventArgs e)
        {
            CrossThreadStuff.Pulse();
        }

        public static Dictionary<string, string> FindGekkoInbuiltFunctions()
        {
            Dictionary<string, string> gekkoBuiltInFunctions = new Dictionary<string, string>();
            Type myType = (typeof(Functions));
            MethodInfo[] myArrayMethodInfo = myType.GetMethods(BindingFlags.Public | BindingFlags.Static | BindingFlags.DeclaredOnly);
            for (int i = 0; i < myArrayMethodInfo.Length; i++)
            {
                MethodInfo myMethodInfo = (MethodInfo)myArrayMethodInfo[i];

                //foreach(ParameterInfo pi in myMethodInfo.GetParameters())
                //{
                //    if(G.Equal(pi.Name, "xxx") { };
                //}
                
                string name = myMethodInfo.Name.ToLower();  //should be superfluous
                string meta = null;
                object[] metaInfo = myMethodInfo.GetCustomAttributes(false);
                if (metaInfo.Length > 0) meta = ((MyCustomAttribute)(metaInfo[0])).Lag;                
                if (!gekkoBuiltInFunctions.ContainsKey(name))
                {
                    gekkoBuiltInFunctions.Add(name, meta);  //meta contains info on lags etc.         
                }
            }

            gekkoBuiltInFunctions.Add("string", null); //%s = string(1) is translated into tostring() since string() function is not allowed in C#.

            return gekkoBuiltInFunctions;
        }

        public static void MaybeWriteOpenDatabanks(ref int w, ref int b)
        {
            for (int i = 0; i < Program.databanks.storage.Count; i++)
            {
                //The avoids creating new databanks, better to keep the original ones and switch their places.
                if (G.Equal(Program.databanks.storage[i].name, Globals.Work)) w = i;
                else if (G.Equal(Program.databanks.storage[i].name, Globals.Ref)) b = i;
                else
                {
                    MaybeWriteOpenDatabank(Program.databanks.storage[i]);
                }
            }
        }

        public static void WriteRemovedDatabank(Databank removed)
        {            
            if (removed == null) return;  //See TKD mail 6/6 2016, this should not be possible, but just in case
            if (removed.FileNameWithPath == null) return; //See TKD mail 6/6 2016, this should not be possible, but just in case
            bool skipWrite = false;
            GekkoTime tStart = GekkoTime.tNull;
            GekkoTime tEnd = GekkoTime.tNull;            
            if (!removed.FileNameWithPath.EndsWith("." + Globals.extensionDatabank + ""))
            {                
                G.Writeln2("*** ERROR: The databank '" + removed.name + "' was opened with the OPEN command.");
                G.Writeln("           It has been altered, but the changes cannot be written back to the", Color.Red);
                G.Writeln("           underlying databank file, since this file is not a ." + Globals.extensionDatabank + " file.", Color.Red);
                G.Writeln("           (If the databank was opened with OPEN<edit>, you may use WRITE to write the ", Color.Red);
                G.Writeln("           databank to file).", Color.Red);
                G.Writeln();
                throw new GekkoException();
            }
            if (true)
            {
                if (removed.fileHash == null)
                {
                    //do nothing, fileHashing is probably not active
                }
                else if (removed.fileHash == Globals.brandNewFile)
                {
                    if (File.Exists(removed.FileNameWithPath))
                    {                        
                        MessageBox.Show("*** ERROR: The databank file '" + removed.FileNameWithPath + "' did not exist when opening it,\nbut seems to exist as a file now. \nHence, Gekko cannot write the databank to file -- \nplease consider to run your code again.");
                        skipWrite = true;
                    }
                }
                else
                {
                    string trueFileHash = Program.GetMD5Hash(GetTextFromFileWithWait(removed.FileNameWithPath));
                    if (!(trueFileHash == removed.fileHash))
                    {
                        MessageBox.Show("*** ERROR: The databank file '" + removed.FileNameWithPath + "' seems to have changed since opening it. \nHence, Gekko cannot write the databank to file -- \nplease consider to run your code again.");
                        //MessageBox.Show("*** ERROR: The databank '" + removed.name + "' seems to have been altered since opening it. \nHence, Gekko cannot write the databank to file -- \nplease consider to run your code again.");
                        skipWrite = true;
                    }
                }
            }
            int n = 0;
            if (!skipWrite) n = WriteGbk(removed, tStart, tEnd, removed.FileNameWithPath, false, null, "" + Globals.extensionDatabank + "", true, true);
        }
        
        public static string ErrorHandling(string s, P p, bool noWindowShown)
        {
            if (Globals.threadIsInProcessOfAborting)
            {
                p.hasShownErrorHandling = EHasShownErrorHandling.True;  //to make the command files 'Fail' in status window.
                return "stop";
            }
            if (G.IsUnitTesting()) return "stop";

            if (!p.hasBeenCmdFile) return "stop";

            if (s == null) s = "";

            string type = "stop";

            if (p.canShowErrorDialog == true || s == "parser_islooping")  //show only 1 time, unless parsing-looping
            {
                p.hasShownErrorHandling = EHasShownErrorHandling.True;
                Window2 w = new Window2();
                w.p = p;
                if (s == "runtime")
                {
                    int lineNumber5;
                    string fileCalled5;
                    string commandText5;
                    List<string> commandLines5;
                    GetErrorLineAndText(p, p.GetDepth(), out lineNumber5, out fileCalled5, out commandLines5);

                    if (p.hasBeenCompilationError)
                    {
                        //this is shown somewhere else
                        //string text = "*** ERROR: Internal Gekko error regarding file: " + p.lastFileSentToANTLR;
                        //WriteCompileErrorMessage(text);
                    }
                    else
                    {
                        int ln = lineNumber5;

                        commandText5 = "";
                        string text = "";
                        if (ln <= 0)
                        {
                            //this should not happen any more, after fix regarding token line numbers (2/9 2012)
                            text = "*** ERROR: " + "Running file '" + fileCalled5 + "', line [unknown]";
                            commandText5 = "";
                        }
                        else
                        {
                            text = "*** ERROR: " + "Running file '" + fileCalled5 + "', line " + ln;
                            commandText5 = commandLines5[ln - 1];
                        }
                        WriteErrorMessage(ln, commandText5, text, fileCalled5);
                    }

                    WriteCallStack(false, p);

                    w.textBox1.Text = "*** ERROR: Run-time error.";
                    w.textBox1.Text += "\n";
                    w.textBox1.Text += "\n";
                    w.textBox1.Text += "Gekko encountered a run-time error while trying to execute a command line (cf. the Gekko output window). You may stop the program execution ('Stop'), ";
                    w.textBox1.Text += "or try to skip the problematic line ('Skip line')." + "\n" + "\n" + "Skipping a line is usually ok if the line is non-vital for the rest of the program (for instance a print statement), ";
                    w.textBox1.Text += "else you should rerun your program files ('Stop' and run again).";
                    w.textBox1.Text += "\n";
                    w.textBox1.Text += "\n";
                    w.textBox1.Text += "Be warned that skipping these kinds of errors may leave data structures in an inconsistent state, ";
                    w.textBox1.Text += "so when skipping a line, no firm guarantees regarding the results can be issued. (Retrying the file is not ";
                    w.textBox1.Text += "allowed regarding run-time errors, since some of the lines in the file have already been executed).";

                    w.button2.IsEnabled = false;  //retry
                }
                else if (s == "parser" || s == "parser_islooping")
                {
                    w.textBox1.Text = "*** ERROR: Syntax error.";
                    w.textBox1.Text += "\n";
                    w.textBox1.Text += "\n";
                    w.textBox1.Text += "Gekko encountered a syntax error (cf. the Gekko output window). The problematic command file has not been run (since it could not be parsed), so you may try to fix the error and try again. ";
                    w.textBox1.Text += "\n" + "\n" + "If you fix the syntax error now and click 'Retry file', Gekko will continue executing the system of command files as if no error had happened. (If errors persist, the error dialog will show up again).";
                    w.button3.IsEnabled = false;  //skip

                    WriteCallStack(true, p);
                }
                else MessageBox.Show("Error handling: please report this to the developer");
                try
                {
                    CrossThreadStuff.SetReadOnly(true);
                    MaybePlaySound(p);
                    if (!noWindowShown) w.ShowDialog();  //the window is suppressed when debug = "none" (and not "dialog")
                }
                finally
                {
                    CrossThreadStuff.SetReadOnly(false);
                }
                type = w.type;

                if (noWindowShown) type = "stop";  //for some reason, when window not shown, type becomes "close"

                if (type == "stop") p.canShowErrorDialog = false;
                if (type == "retry") p.canShowErrorDialog = true;
                if (type == "skip")
                {
                    p.canShowErrorDialog = true;
                    p.hasShownErrorHandling = EHasShownErrorHandling.TrueAndAlsoSkippedLines;
                }
            }

            if (type == "skip") Globals.numberOfSkippedLines++;

            return type;
        }

        public static void WriteCallStack(bool syntaxError, P p)
        {
            WriteCallStack(true, syntaxError, p);
        }

        public static List<StackHelper> WriteCallStack(bool print, bool syntaxError, P p)
        {

            List<StackHelper> stackLines = new List<StackHelper>();

            int max = p.GetDepth();
            int limit = 1;
            if (syntaxError || p.hasBeenCompilationError) limit = 0;
            if (max > limit)
            {
                //G.Writeln();
                for (int i = 1; i <= max; i++)  //index 0 is not used
                {
                    int lineNumber2;
                    string fileCalled;
                    List<string> commandLines2;
                    GetErrorLineAndText(p, i, out lineNumber2, out fileCalled, out commandLines2);
                    
                    string lineNumber3 = "" + lineNumber2;
                    if (lineNumber2 == 0) lineNumber3 = "[unknown]";

                    if (fileCalled == "")
                    {
                        if (commandLines2.Count == 1)
                        {
                            StackHelper sh = new StackHelper();
                            sh.line = "    " + "Call stack: Command line calling -->";
                            sh.file = "";
                            sh.line2 = lineNumber2;
                            stackLines.Add(sh);
                        }
                        else
                        {
                            StackHelper sh = new StackHelper();
                            sh.line = "    " + "Call stack: Command block line " + lineNumber3 + " calling -->";
                            sh.file = "";
                            sh.line2 = lineNumber2;
                            stackLines.Add(sh);
                        }
                    }
                    else
                    {

                        if (i < max || syntaxError)
                        {
                            StackHelper sh = new StackHelper();
                            sh.line = "    " + fileCalled + " line " + lineNumber3 + " calling -->";
                            sh.file = fileCalled;
                            sh.line2 = lineNumber2;
                            stackLines.Add(sh);
                        }
                        else
                        {
                            StackHelper sh = new StackHelper();

                            string lineNumber4 = lineNumber3;

                            if (p.hasSeenStopCommand > 0)
                            {
                                //
                                // a hack to make STOP line correct
                                //                                
                                int line7 = -12345;
                                int.TryParse(lineNumber3, out line7);
                                if (line7 != -12345)
                                {
                                    line7++;
                                    lineNumber4 = "" + line7;
                                }
                            }                            

                            sh.line = "    " + fileCalled + " (run-time error in line " + lineNumber4 + ")";
                            sh.file = fileCalled;
                            sh.line2 = lineNumber2;
                            stackLines.Add(sh);
                        }
                    }
                }
                if (syntaxError || p.hasBeenCompilationError)
                {
                    StackHelper sh = new StackHelper();
                    sh.line = "    " + p.lastFileSentToANTLR + " (syntax error)";
                    sh.file = p.lastFileSentToANTLR;
                    stackLines.Add(sh);
                }

                string tablefile = null;
                foreach (StackHelper sh in stackLines)
                {
                    if (sh.file.Contains("tablecode." + Globals.defaultCommandFileExtension))
                    {
                        tablefile = GetOriginalTableFileName(sh.file);
                    }
                }

                if (print)
                {
                    if (tablefile != null)
                    {
                        G.Writeln2("*** ERROR: Table file failed: " + tablefile);
                    }

                    G.Writeln();
                    foreach (StackHelper sh in stackLines)
                    {
                        if (sh.file.Contains("tablecode." + Globals.defaultCommandFileExtension))
                        {
                            string tablefile2 = GetOriginalTableFileName(sh.file);
                            G.Writeln("    " + tablefile2 + " calling -->", Color.Gray, true);
                        }
                        G.Writeln(sh.line, Color.Gray, true);
                    }
                    G.Writeln();
                }
            }
            return stackLines;
        }

        public static void GetErrorLineAndText(P p, int i, out int lineNumber2, out string lineText, out List<string> commandLines)
        {
            string command = p.GetStack(i);
            string fileText = p.GetStackCommandFileText(i - 1);
            if (command == null)
            {
                lineText = "[?]";
                lineNumber2 = 0;
            }
            else
            {
                SplitCommandBeingExecuted(out lineText, out lineNumber2, command);
            }
            commandLines = new List<string>();
            commandLines.Add("Unknown file");
            if (fileText != null)
            {
                commandLines = CreateListOfStringsFromString(fileText);
            }
            if (p.hasSeenStopCommand == 1)
            {                
                lineNumber2++;  //else it reports the line before the STOP command                
                p.hasSeenStopCommand = 2;  //no adjustments for callee command files (this is a bit of a hack)
            }
        }

        public static void Flush()
        {
            DeleteFolder(Globals.localTempFilesLocation);
            G.Writeln();
            G.Writeln("Temporary folder was flushed:");
            G.Writeln("  " + Globals.localTempFilesLocation);
        }

        public static void Cls(string tab)
        {
            CrossThreadStuff.Cls(tab);
        }

        public static void XmlTable(string filename, string html, string window, P p)
        {

            string tempfile = Globals.localTempFilesLocation + "\\" + "tablecode." + Globals.defaultCommandFileExtension;
            if (File.Exists(tempfile))
            {
                WaitForFileDelete(tempfile);  //for safety
            }

            if (Globals.runningOnTTComputer && Globals.showTimings) G.Writeln("Parse/translate XML table start: " + G.SecondsFormat((DateTime.Now - p.startingTime).TotalMilliseconds), Color.LightBlue);

            XmlDocument doc = new XmlDocument();

            string xmlText = GetTextFromFileWithWait(filename);

            XmlHelper xh = new XmlHelper();
            //using (FileStream fs = WaitForFileStream(filename, GekkoFileReadOrWrite.Read))
            //{

            //To convert to lower case: http://mel-green.com/2009/04/lowercase-xml-regex-csharp/
            //            Regex.Replace(
            //xml,
            //@"<[^<>]+>",
            //m => { return m.Value.ToLower(); },
            //RegexOptions.Multiline | RegexOptions.Singleline);

            //xmlText = xmlText.Replace("'", "´");
            //xmlText = xmlText.Replace("`", "´");

            try
            {
                doc.LoadXml(xmlText);
            }
            catch (Exception e)
            {
                G.Writeln();
                G.Writeln("*** ERROR: Table file: '" + filename + "'");
                WriteXmlError(e, filename);
                throw new GekkoException();
            }

            VisitChildrenAndPutAssignvarsIntoNodes(doc, 0);

            CountRowsCols(doc, 0, xh);
            VisitChildren(doc, 0, xh);

            XmlNode rows = doc.SelectSingleNode("//rows");
            foreach (XmlNode row in rows.ChildNodes)
            {
                HandleXmlRow(xh, row);
            }

            bool isHtml = false;
            if (G.Equal(Program.options.table_type, "html")) isHtml = true;
            if (G.Equal(html, "yes")) isHtml = true;  //overrides if 'yes'

            StringBuilder s3 = new StringBuilder();
            if (isHtml && !G.Equal(window, "main"))
            {
                s3.AppendLine("TABLE tab.Print('html');");
            }
            else if (isHtml && G.Equal(window, "main"))
            {
                s3.AppendLine("TABLE tab.Print('html_main');");
            }
            else
            {
                //This will catch other cases, that is, txt
                s3.AppendLine("TABLE tab.Print();");
            }

            StringBuilder s2 = new StringBuilder();


            s2.AppendLine(Globals.tableConverterText1);
            s2.AppendLine(Globals.tableConverterText2);
            s2.AppendLine(Globals.tableConverterText3 + filename);
            s2.AppendLine(Globals.tableConverterText4);
            s2.AppendLine(Globals.tableConverterText5);

            s2.AppendLine("DATE %__t1 = %__tabletimestart;");
            s2.AppendLine("DATE %__t2 = %__tabletimeend;");
            s2.AppendLine("TABLE tab = new Table();");
            s2.AppendLine("VAL %__periods = %__t2 - %__t1 + 1 - filteredperiods(%__t1, %__t2);");
            s2.AppendLine("VAL %__c1 = 1;");

            string s = s2.ToString() + xh.s.ToString() + xh.sEnd.ToString() + s3.ToString();

            using (FileStream fs2 = WaitForFileStream(tempfile, GekkoFileReadOrWrite.Write))
            using (StreamWriter tempfile2 = G.GekkoStreamWriter(fs2))
            {
                tempfile2.Write(s);
                tempfile2.Flush();
                tempfile2.Close();
            }

            if (Globals.runningOnTTComputer && Globals.showTimings) G.Writeln("Parse/translate XML table end: " + G.SecondsFormat((DateTime.Now - p.startingTime).TotalMilliseconds), Color.LightBlue);
            //}
        }

        public static void WriteXmlError(Exception e, string file)
        {
            G.Writeln2("*** ERROR: The file seems to be invalid as regards XML syntax:");
            if (e.InnerException != null) G.Writeln("           " + e.InnerException.Message, Color.Red);
            else G.Writeln("           " + e.Message, Color.Red);
        }

        private static void HandleXmlRow(XmlHelper xh, XmlNode row)
        {

            if (row.Name == "row")
            {
                xh.rowCounter++;
                if (xh.rowCounter == xh.totalRows)
                    xh.isLastRow = true;
            }

            if (row.Name == "rowformat")
            {
                Attrib a = new Attrib();
                GetAttributes(row, a);
                MergeAttributes(xh.rowGlobal, a);
            }

            if (row.Name == "colbordershow")
            {
                if (row.ChildNodes.Count > 0)
                {
                    G.Writeln2("*** ERROR: XML table: element '" + row.Name + "' should not have sub-elements");
                    throw new GekkoException();
                }
                if (!xh.isLastRow)
                {
                    xh.s.AppendLine("TABLE tab.CurRow.ShowBorders();");
                }
            }

            if (row.Name == "colborderhide")
            {
                int totalBorders = xh.colLeftBorders.Count + xh.colRightBorderPlusOne.Count;
                string nodeText = row.InnerText;
                List<int> killCols = new List<int>();
                //nodeText="" means all borders
                if (row.ChildNodes.Count > 1)
                {
                    G.Writeln2("*** ERROR: XML table: element '" + row.Name + "' should not have sub-elements");
                    throw new GekkoException();
                }

                if (nodeText != "" && nodeText != "inner" && nodeText != "outer")
                {
                    string[] cols2 = nodeText.Split(',');
                    foreach (string s in cols2)
                    {
                        int col = -12345;
                        if (!int.TryParse(s, out col))
                        {
                            G.Writeln2("*** ERROR: XML table: could not convert '" + s + "' to list of integers");
                        }
                        killCols.Add(col);
                    }
                }

                if (killCols.Count == 0)
                {
                    for (int i = 1; i <= totalBorders; i++)
                    {
                        if (nodeText == "outer" && (i > 1 && i < totalBorders)) continue;
                        if (nodeText == "inner" && (i == 1 || i == totalBorders)) continue;
                        XmlDisableBorder(xh, i);
                    }
                }
                else
                {
                    foreach (int i in killCols)
                    {
                        XmlDisableBorder(xh, i);
                    }
                }



            }

            if (row.Name == "row")
            {
                //G.Writeln("+++ " + row.Name + ":" + row.InnerText);

                Attrib rowA = new Attrib();
                GetAttributes(row, rowA);
                int counter = 0;
                foreach (XmlNode node in row.ChildNodes)
                {
                    string nodeName = node.Name;
                    string nodeText = node.InnerText;

                    if (nodeText.Contains("'"))
                    {
                        //G.Writeln();
                        //G.Writeln("+++ WARNING: XML table should not contain this hyphen: '");
                        //G.Writeln("             The hyphen is changed to this hyphen: ´ (see the key to the left of the backspace key)");
                        //G.Writeln("             Please change the table file, in order for this warning to disappear. The reason the");
                        //G.Writeln("             hyphen is problematic is that it is used to denote strings in Gekko command files.");
                        //G.Writeln("             File: " + filename);
                        //G.Writeln("    " + "[" + G.IntFormat(i + 1, 4) + "]:" + "   " + G.ReplaceGlueNew(line), Color.Blue);
                        nodeText = nodeText.Replace("'", "´");
                    }

                    if (nodeText.Contains("`"))
                    {
                        //G.Writeln();
                        //G.Writeln("+++ WARNING: XML table should not contain this hyphen: `");
                        //G.Writeln("             The hyphen is changed to this hyphen: ´ (see the key to the left of the backspace key)");
                        //G.Writeln("             Please change the table file, in order for this warning to disappear. The reason the");
                        //G.Writeln("             hyphen is problematic is that it is used internally in Gekko for other purposes.");
                        //G.Writeln("             File: " + filename);
                        //G.Writeln("    " + "[" + G.IntFormat(i + 1, 4) + "]:" + "   " + G.ReplaceGlueNew(line), Color.Blue);
                        nodeText = nodeText.Replace("`", "´");
                    }

                    if (nodeText.Contains("\""))
                    {
                        //nodeText = nodeText.Replace("\"", "´");  NO!
                    }

                    //nodeText = nodeText.Trim();  //also removes blank lines if there are any by accident

                    counter++;
                    if (counter > xh.cols.Count)
                    {
                        G.Writeln2("*** ERROR in XML table: there were more elements put into a <row> than defined columns");
                        G.Writeln("    Please note that since Gekko 1.5.7, the behavoior regarding attribute 'colspan' has ");
                        G.Writeln("    been changed so that for instance after '<txt colspan = \"3\">', the next column");
                        G.Writeln("    will be the 4. column (and not the 2. column as in Gekko versions prior to 1.5.7.");
                        G.Writeln("    So if you use 'colspan', you may have to remove some empty <txt> tags...");
                        throw new GekkoException();
                    }
                    Attrib colInfo = xh.cols[counter - 1].attrib;
                    Attrib childA = new Attrib();
                    GetAttributes(node, childA);

                    Attrib a = new Attrib();
                    MergeAttributes(a, xh.table);       //completely global options
                    MergeAttributes(a, colInfo);        //options related to a specific column
                    MergeAttributes(a, xh.rowGlobal);   //options defined in <rowformat>
                    MergeAttributes(a, rowA);           //options defined in particular <row>
                    MergeAttributes(a, childA);         //options defined in particular item in row (i.e., column)

                    string a_vardisplay = a.Get("vardisplay");
                    if (a_vardisplay == null) a_vardisplay = "n";

                    string a_varscale = a.Get("varscale");
                    if (a_varscale == null) a_varscale = "1.0";

                    string a_varformat = a.Get("varformat");
                    if (a_varformat == null) a_varformat = "f12.2";  //we say that is default is nothing is stated at all

                    string a_datealign = a.Get("datealign");
                    if (a_datealign == null) a_datealign = "right";

                    string a_txtalign = a.Get("txtalign");
                    if (a_txtalign == null) a_txtalign = "left";

                    string a_colspan = a.Get("colspan");
                    if (a_colspan == null) a_colspan = "1";
                    int a_colspanint = GetIntFromAttrib(a_colspan);

                    //G.Writeln(nodeName);

                    if (nodeName == "txt")
                    {
                        if (nodeText == "$")
                        {
                            //text taken from next <var> tag
                            XmlNode next = node.NextSibling;
                            if (next != null)
                            {
                                string nextName = next.Name;
                                string nextText = next.InnerText;
                                if (nextName == "var")
                                {
                                    if (nextText != "")
                                    {
                                        nodeText = nextText;

                                        if (nodeText.Contains("'"))
                                        {                                            
                                            nodeText = nodeText.Replace("'", "´");
                                        }

                                        if (nodeText.Contains("`"))
                                        {
                                            nodeText = nodeText.Replace("`", "´");
                                        }
                                    }
                                }
                            }
                        }

                        if ((nodeText == null || nodeText == "") && a_colspanint <= 1)
                        {
                            //#872483274
                            //do nothing, no need to do any MergeCols etc. for an empty <txt/> without span.
                            //and this would also interfere with subcolborder that would become broken.
                        }
                        else
                        {
                            xh.s.AppendLine("TABLE tab.CurRow.SetText(%__c" + counter + ", '" + nodeText + "');");
                            if (a_txtalign == "center")
                            {
                                xh.s.AppendLine("TABLE tab.CurRow.AlignCenter(%__c" + counter + ");");
                            }
                            else if (a_txtalign == "right")
                            {
                                xh.s.AppendLine("TABLE tab.CurRow.AlignRight(%__c" + counter + ");");
                            }
                            //could this not be omitted if a_colspanint is = 1???
                            //NO: THE COLS MIGHT GET SPANNED DUE TO DATES: SO THIS LOGIC IS NEEDED for stuff spanning through dates!!!!
                            xh.s.AppendLine("TABLE tab.CurRow.MergeCols(%__c" + counter + ", %__c" + (counter + a_colspanint) + " - 1);");
                        }

                        //If colspan is 2, this skips one more column to the right than normal
                        //Corresponds to HTML table behavior.
                        //Gekko versions < 1.5.7 did not have this skip.
                        counter += a_colspanint - 1;
                    }
                    else if (nodeName == "var")
                    {
                        string nodeText2 = nodeText.Trim();
                        if (nodeText2.ToLower().StartsWith("genr "))
                            nodeText2 = nodeText2.Substring("genr ".Length);
                        else if (nodeText2.ToLower().StartsWith("ser "))
                            nodeText2 = nodeText2.Substring("ser ".Length);
                        else if (nodeText2.ToLower().StartsWith("series "))
                            nodeText2 = nodeText2.Substring("series ".Length);

                        nodeText2 = nodeText2.Replace("´", "'");

                        if (colInfo.Get("type") == "expand")
                        {
                            xh.s.AppendLine("TABLE tab.CurRow.SetValues(%__c" + counter + ", %__t1, %__t2, " + nodeText2 + ", '" + a_vardisplay + "', " + a_varscale + ", '" + a_varformat + "');");
                        }
                        else if (colInfo.Get("period") != null)
                        {
                            string date = colInfo.Get("period");
                            xh.s.AppendLine("TABLE tab.CurRow.SetValues(%__c" + counter + ", " + date + ", " + date + ", " + nodeText2 + ", '" + a_vardisplay + "', " + a_varscale + ", '" + a_varformat + "');");
                        }
                        else
                        {
                            G.Writeln2("*** ERROR: You are trying to put a variable into a column that is not expandable or of 'period' type");
                            throw new GekkoException();
                        }
                        //G.Writeln(nodeName + ":" + nodeText);
                    }
                    else if (nodeName == "date")
                    {
                        if (colInfo.Get("type") == "expand")
                        {
                            xh.s.AppendLine("TABLE tab.CurRow.SetDates(%__c" + counter + ", %__t1, %__t2);");
                        }
                        else if (colInfo.Get("period") != null)
                        {
                            string date = colInfo.Get("period");
                            xh.s.AppendLine("TABLE tab.CurRow.SetDates(%__c" + counter + ", " + date + ", " + date + ");");
                        }
                        else
                        {
                            G.Writeln2("*** ERROR: You are trying to put a date into a column that is not expandable or of 'period' type");
                            throw new GekkoException();
                        }
                        //G.Writeln(nodeName + ":" + nodeText);
                    }
                }
            }

            if (row.Name == "rowborder")
            {
                if (xh.isLastRow)
                {
                    xh.s.AppendLine("TABLE tab.CurRow.SetBottomBorder(1, %__c" + (xh.cols.Count + 1) + " - 1);");
                }
                else
                {
                    xh.s.AppendLine("TABLE tab.CurRow.SetTopBorder(1, %__c" + (xh.cols.Count + 1) + " - 1);");
                }
            }
            if (row.Name == "row")  //this must be the last part of XML row handling
            {
                if (!xh.isLastRow)
                {
                    xh.s.AppendLine("TABLE tab.CurRow.Next();");
                }
            }
        }

        private static void XmlDisableBorder(XmlHelper xh, int i)
        {
            int totalBorders = xh.colLeftBorders.Count + xh.colRightBorderPlusOne.Count;

            if (i < 1 || i > totalBorders)
            {
                G.Writeln2("*** ERROR: XML table: <colborderhide> should have numbers between 1 and " + totalBorders + " (inclusive)");
                throw new GekkoException();
            }
            if (i < totalBorders)
            {
                //This can maybe fail ([i-1] call)
                if (i - 1 >= 0 && i - 1 < xh.colLeftBorders.Count)
                {
                    xh.s.AppendLine("TABLE tab.CurRow.HideLeftBorder(%__c" + xh.colLeftBorders[i - 1] + ");");
                }

            }
            else
            {
                //This can fail ([0] call)
                if (0 < xh.colRightBorderPlusOne.Count)
                {
                    xh.s.AppendLine("TABLE tab.CurRow.HideRightBorder(%__c" + xh.colRightBorderPlusOne[0] + " - 1);");
                }
            }
        }

        private static int GetIntFromAttrib(string input)
        {
            int parsed = -12345;
            if (!int.TryParse(input, out parsed))
            {
                G.Writeln2("*** ERROR: Could not parse colspan '" + input + "' into an integer");
                throw new GekkoException();
            }
            return parsed;
        }

        static void CountRowsCols(XmlNode node, int level, XmlHelper xh)
        {
            if (node.Name == "col") xh.totalCols++;
            if (node.Name == "row") xh.totalRows++;

            foreach (XmlNode echild in node.ChildNodes)
            {
                CountRowsCols(echild, level + 1, xh);
            }
        }

        static void VisitChildren(XmlNode node, int level, XmlHelper xh)
        {
            //G.Writeln("-".PadLeft(level + 1) + "" + node.Name + ": " + node.Value);

            if (node.Name == "cols")
            {
                Attrib a = new Attrib();
                GetAttributes(node, a);
            }

            if (node.Name == "col")
            {
                xh.cols.Add(new XmlColInfo());
            }

            if (node.Attributes != null)
            {
                Attrib a = null;
                if (node.Name == "table")
                {
                    a = xh.table;
                }
                else if (node.Name == "col")
                {
                    a = xh.cols[xh.cols.Count - 1].attrib;
                }
                if (a != null)
                {
                    GetAttributes(node, a);
                }
            }

            if (node.Name == "col")
            {
                int last = 0;
                if (xh.colB.Count > 0) last = xh.colB[xh.colB.Count - 1];
                xh.colA.Add(last + 1);
                Attrib aa = xh.cols[xh.cols.Count - 1].attrib;
                string add = "1";
                if (aa.Get("type") == "expand")
                {
                    add = "%__periods";
                }
                xh.s.AppendLine("VAL %__c" + (xh.cols.Count + 1) + " = %__c" + (xh.cols.Count) + " + " + add + ";");
            }

            if (node.Name == "colborder")
            {
                if (xh.cols.Count < xh.totalCols)
                {
                    int temp = xh.cols.Count + 1;
                    xh.sEnd.AppendLine("TABLE tab.CurRow.SetLeftBorder(%__c" + temp + ");");
                    xh.colLeftBorders.Add(temp);

                }
                else
                {
                    int temp = xh.cols.Count + 1;
                    xh.sEnd.AppendLine("TABLE tab.CurRow.SetRightBorder(%__c" + temp + " - 1);");
                    xh.colRightBorderPlusOne.Add(temp);
                }
            }

            if (node.Name == "subcolborder")  //must be child of <col>, puts data into this <col> (its parent)
            {
                Attrib a = new Attrib();
                if (node.Attributes != null)
                {
                    GetAttributes(node, a);
                }
                XmlColInfo xci = xh.cols[xh.cols.Count - 1];
                string per = a.Get("period");
                xci.subcolborders.Add(per);

                xh.sEnd.AppendLine("TABLE tab.CurRow.SetRightBorder(%__c" + xh.cols.Count + " + (date(" + per + ") - %__t1) - filteredperiods(%__t1, date(" + per + ")), 'gray');");


            }

            foreach (XmlNode echild in node.ChildNodes)
            {
                VisitChildren(echild, level + 1, xh);
            }
        }

        static void VisitChildrenAndPutAssignvarsIntoNodes(XmlNode node, int level)
        {
            //G.Write(G.Blanks(level) + node.Name + " ");
            if (node.Attributes != null)
            {
                foreach (XmlAttribute achild in node.Attributes)
                {
                    //achild.Value = achild.Value + "_12345";
                    //string name = achild.LocalName;
                    //string value = achild.Value;
                    //achild.Value = SubstituteAssignVarsInExpression(achild.Value);
                    //G.Write("[attrib] " + name + "=\"" + value + "\" ");
                }
            }

            //why isnt .Value used in other places (seems innertext or so)
            //here we could substitute, remember the \\# etc.
            //string text = null;
            if (node.NodeType == XmlNodeType.Text || node.NodeType == XmlNodeType.CDATA)
            {
                node.Value = node.Value;
                //text = node.Value;
            }
            //G.Writeln("[value] \"" + text + "\"");

            foreach (XmlNode echild in node.ChildNodes)
            {
                VisitChildrenAndPutAssignvarsIntoNodes(echild, level + 1);
            }
        }

        private static void GetAttributes(XmlNode node, Attrib a)
        {
            if (node.Attributes == null) return;
            foreach (XmlAttribute achild in node.Attributes)
            {
                string name = achild.LocalName;
                string value = achild.Value;
                if (a.Set(name, value) == false)
                {
                    G.Writeln2("*** ERROR: XML table has duplicate attribute name: " + name);
                }
            }
        }

        private static void MergeAttributes(Attrib result, Attrib newItems)
        {
            foreach (var item in newItems.data)
            {
                result.data[item.Key] = item.Value;
            }
        }

        public static void PrintTable(Table tab)
        {
            PrintTable(tab, true, null);
        }

        public static void PrintTable(Table tab, string type)
        {
            PrintTable(tab, true, type);
        }

        public static void PrintTable(Table tab, bool printDateEtc, string printType)
        {
            Globals.lastPrtOrMulprtTable = tab;
            CrossThreadStuff.CopyButtonEnabled(true);
            //This method does NOT alter the table as a side-effect (because of ObjectCopier.Clone).
            bool printRawCode = false;

            //TODO: table types are a bit messy: clean this up at some point
            if (G.Equal(printType, "html_main"))
            {
                printType = "html";
                printRawCode = true;
            }
            if (printType == null && G.Equal(Program.options.table_type, "html"))
            {
                printType = "html";  //overrides txt, so "TABLE s1" or calling from menu will -> html table
            }

            List<string> ss = tab.Print(printType);

            string fullFileNameAndPath = Globals.localTempFilesLocation + "\\" + "table.html";

            StampTypes type = StampTypes.Normal;
            if (G.Equal(Globals.tableOption, "m")) type = StampTypes.Multiplier;
            else if (G.Equal(Globals.tableOption, Globals.operator_r)) type = StampTypes.Base;
            List<string> lines = GetDatabankInfo(type);
            if (Program.options.table_stamp)
            {
                string printed = "Table printed: " + GetDateTimeStamp();
                lines.Add(printed);
            }

            string pTag = "<p CLASS=\"gfsize gfont\" style=\"color: silver; margin: 2px;\">";

            if (printType == "html")
            {
                //---------------------
                //         HTML
                //---------------------
                if (printRawCode)
                {
                    int widthRemember = Program.options.print_width;
                    int fileWidthRemember = Program.options.print_filewidth;
                    Program.options.print_width = int.MaxValue;
                    Program.options.print_filewidth = int.MaxValue;
                    try
                    {
                        G.Write(pTag);
                        for (int i = 0; i < lines.Count; i++)
                        {
                            G.Write(lines[i]);
                            if (i < lines.Count - 1) G.Writeln("<br>");
                        }
                        G.Writeln("</p>");
                        foreach (string line in ss) G.Writeln(line);
                    }
                    catch (Exception e)
                    {
                        G.Writeln2("*** ERROR: Table (in html format) could not be written");
                        throw new GekkoException();
                    }
                    finally
                    {
                        //resetting, also if there is an error
                        Program.options.print_width = widthRemember;
                        Program.options.print_filewidth = fileWidthRemember;
                    }
                }
                else
                {
                    string s1 = Globals.htmlFileStart1 + GetHtmlHeaderCssStyles() + Globals.htmlFileStart2;
                    string s2 = Globals.htmlFileEnd;

                    using (FileStream fs = Program.WaitForFileStream(fullFileNameAndPath, Program.GekkoFileReadOrWrite.Write))
                    using (StreamWriter sw = G.GekkoStreamWriter(fs))
                    {
                        sw.Write(s1);

                        string s5 = null;

                        s5 += pTag + "<a href=\"#\"   onclick=\"document.getElementById('hiddenText').style.display='block'; return false;\">Transform options</a> " + "</p>";

                        s5 += "<div style=\"display: none;\" id=\"hiddenText\">" + G.NL;
                        string s = "style = \"margin:0; padding:0; opacity : 0.5;\"";                        

                        s5 += "<table CLASS=\"gfsize gfont\"  style=\"color:gray\" >";
                        s5 += " <tr>";
                        s5 += "   <td></td>";
                        s5 += "   <td>First &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </td>";
                        s5 += "   <td>Reference &nbsp; &nbsp; &nbsp; &nbsp; </td>";
                        s5 += "   <td>Multiplier</td>";
                        s5 += " </tr>";
                        s5 += " <tr>";
                        s5 += "   <td>Levels &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  </td>";
                        s5 += "   <td><input title=\"Levels as they are in first databank\" CLASS=\"gfsize gfont\" type=\"radio\" name=\"table\" " + s + " onclick=\"window.location='table.html#n" + "';\"/>n</td>";
                        s5 += "   <td><input title=\"Levels as they are in reference databank\"  CLASS=\"gfsize gfont\" type=\"radio\" name=\"table\" " + s + " onclick=\"window.location='table.html#rn" + "';\"/>r&thinsp;n</td>";
                        s5 += "   <td></td>";
                        s5 += " </tr>";
                        s5 += " <tr>";
                        s5 += "   <td>Abs. diff.</td>";
                        s5 += "   <td><input title=\"Absolute time-change (difference) in first databank\" CLASS=\"gfsize gfont\" type=\"radio\" name=\"table\" " + s + " onclick=\"window.location='table.html#d" + "';\"/>d</td>";
                        s5 += "   <td><input title=\"Absolute time-change (difference) in reference databank\" CLASS=\"gfsize gfont\" type=\"radio\" name=\"table\" " + s + " onclick=\"window.location='table.html#rd" + "';\"/>r&thinsp;d</td>";
                        s5 += "   <td><input title=\"Absolute multiplier difference\" CLASS=\"gfsize gfont\" type=\"radio\" name=\"table\" " + s + " onclick=\"window.location='table.html#m" + "';\"/>m</td>";
                        s5 += " </tr>";
                        s5 += " <tr>";
                        s5 += "   <td>Rel. diff.</td>";
                        s5 += "   <td><input title=\"Percentage time growth rate in first databank\" CLASS=\"gfsize gfont\" type=\"radio\" name=\"table\" " + s + " onclick=\"window.location='table.html#p" + "';\"/>p</td>";
                        s5 += "   <td><input title=\"Percentage time growth rate in reference databank\" CLASS=\"gfsize gfont\" type=\"radio\" name=\"table\" " + s + " onclick=\"window.location='table.html#rp" + "';\"/>r&thinsp;p</td>";
                        s5 += "   <td><input title=\"Percentage multiplier difference\" CLASS=\"gfsize gfont\" type=\"radio\" name=\"table\" " + s + " onclick=\"window.location='table.html#q" + "';\"/>q</td>";
                        s5 += " </tr>";
                        s5 += " <tr>";
                        s5 += " </tr>";
                        s5 += " </table>";


                        s5 += "</div>" + G.NL;

                        if (Program.options.interface_table_operators) sw.Write(s5);
                        sw.Write(pTag);
                        for (int i = 0; i < lines.Count; i++)
                        {
                            sw.Write(lines[i]);
                            if (i < lines.Count - 1) sw.WriteLine("<br>");
                        }
                        sw.WriteLine("</p>");

                        foreach (string line in ss) sw.WriteLine(line);
                        sw.Write(s2);
                        sw.Close();
                    }

                    if (!G.IsUnitTesting())
                    {
                        CrossThreadStuff.SetTab("menu", true);
                        Gui.gui.webBrowser.Url = new Uri("file:///" + Globals.localTempFilesLocation + "\\table.html");
                        CrossThreadStuff.SetTab("menu", true);
                    }
                }
            }
            else
            {
                //---------------------
                //         TXT
                //---------------------
                int widthRemember = Program.options.print_width;
                int fileWidthRemember = Program.options.print_filewidth;
                Program.options.print_width = int.MaxValue;
                Program.options.print_filewidth = int.MaxValue;
                G.Writeln();
                try
                {
                    if (printDateEtc)
                    {
                        foreach (string s in lines) G.Writeln(s);
                        //G.Writeln(printed);
                    }
                    foreach (string s in ss) G.Writeln(s);
                    G.Writeln();
                }
                catch (Exception e)
                {
                    G.Writeln2("*** ERROR: Table (in txt format) could not be written");
                    throw new GekkoException();
                }
                finally
                {
                    //resetting, also if there is an error
                    Program.options.print_width = widthRemember;
                    Program.options.print_filewidth = fileWidthRemember;
                }
            }
        }

        private static List<string> GetDatabankInfo(StampTypes type)
        {
            Databank work = Program.databanks.GetFirst();
            Databank base2 = Program.databanks.GetRef();
            string workInfo = "";
            if (work != null && work.info1 != null) workInfo = work.info1;
            string base2Info = "";
            if (base2 != null && base2.info1 != null) base2Info = base2.info1;
            string workDate = "";
            if (work != null && work.date != null) workDate = work.date;
            string base2Date = "";
            if (base2 != null && base2.date != null) base2Date = base2.date;

            List<string> lines = new List<string>();
            if (type == StampTypes.Multiplier)
            {
                lines.Add("Multiplier");
                if (workInfo != "") lines.Add(workInfo + " [" + workDate + "]");
                if (base2Info != "") lines.Add("Reference: " + base2Info + " [" + base2Date + "]");
            }
            else if (type == StampTypes.Base)
            {
                if (base2Info != "") lines.Add("Reference: " + base2Info + " [" + base2Date + "]");
            }
            else
            {
                if (workInfo != "") lines.Add(workInfo + " [" + workDate + "]");
            }
            return lines;
        }


        // --------------------------------------------------------------------------------------
        // ----------------- used for tables start ----------------------------------------------
        // --------------------------------------------------------------------------------------

        //Used for tables, don't use for other stuff!
        public static double Level(string db2, string s, GekkoTime t)
        {
            Databank db = Program.databanks.GetDatabank(db2);
            if (!db.ContainsIVariable(s + Globals.freqIndicator + G.GetFreq(Program.options.freq)))
            {
                if (Program.options.series_normal_table_missing == ESeriesMissing.M)
                {
                    return Globals.missingVariableArtificialNumber;
                }
                else
                {
                    G.Writeln2("*** ERROR: could not find variable " + s + " in " + db2 + " databank");
                }
            }
            return (db.GetIVariable(s + Globals.freqIndicator + G.GetFreq(Program.options.freq)) as Series).GetDataSimple(t);  //#getvar
        }

        //Used for tables, don't use for other stuff!
        public static double MulLevel(string s, GekkoTime t)
        {
            if (!Program.databanks.GetFirst().ContainsIVariable(s + Globals.freqIndicator + G.GetFreq(Program.options.freq)))
            {
                if (Program.options.series_normal_table_missing == ESeriesMissing.M)
                {
                    return Globals.missingVariableArtificialNumber;
                }
                else
                {
                    G.Writeln2("*** ERROR: could not find variable " + s + " in Work databank");
                }
            }
            if (!Program.databanks.GetRef().ContainsIVariable(s + Globals.freqIndicator + G.GetFreq(Program.options.freq)))
            {
                if (Program.options.series_normal_table_missing == ESeriesMissing.M)
                {
                    return Globals.missingVariableArtificialNumber;
                }
                else
                {
                    G.Writeln2("*** ERROR: could not find variable " + s + " in " + Globals.Ref + " databank");
                }
            }
            return (Program.databanks.GetFirst().GetIVariable(s + Globals.freqIndicator + G.GetFreq(Program.options.freq)) as Series).GetDataSimple(t) - (Program.databanks.GetRef().GetIVariable(s + Globals.freqIndicator + G.GetFreq(Program.options.freq)) as Series).GetDataSimple(t);  //#getvar
        }
        public static void RevertSmpl(GekkoSmpl2 smplRemember, GekkoSmpl smpl)
        {
            if (smplRemember != null)
            {
                smpl.t0 = smplRemember.t0;
                smpl.t3 = smplRemember.t3;
            }
        }

        //Used for tables, don't use for other stuff!
        public static double Pch(string db2, string s, GekkoTime t)
        {
            Databank db = Program.databanks.GetDatabank(db2);
            if (!db.ContainsIVariable(s + Globals.freqIndicator + G.GetFreq(Program.options.freq)))
            {
                if (Program.options.series_normal_table_missing == ESeriesMissing.M)
                {
                    return Globals.missingVariableArtificialNumber;
                }
                else
                {
                    G.Writeln2("*** ERROR: could not find variable " + s + " in " + db2 + " databank");
                }
            }
            return ((db.GetIVariable(s + Globals.freqIndicator + G.GetFreq(Program.options.freq)) as Series).GetDataSimple(t) / (db.GetIVariable(s + Globals.freqIndicator + G.GetFreq(Program.options.freq)) as Series).GetDataSimple(t.Add(-1)) - 1) * 100;  //#getvar
        }

        //Used for tables, don't use for other stuff!
        public static double MulPch(string s, GekkoTime t)
        {
            if (!Program.databanks.GetFirst().ContainsIVariable(s + Globals.freqIndicator + G.GetFreq(Program.options.freq)))
            {
                if (Program.options.series_normal_table_missing == ESeriesMissing.M)
                {
                    return Globals.missingVariableArtificialNumber;
                }
                else
                {
                    G.Writeln2("*** ERROR: could not find variable " + s + " in Work databank");
                }
            }
            if (!Program.databanks.GetRef().ContainsIVariable(s + Globals.freqIndicator + G.GetFreq(Program.options.freq)))
            {
                if (Program.options.series_normal_table_missing == ESeriesMissing.M)
                {
                    return Globals.missingVariableArtificialNumber;
                }
                else
                {
                    G.Writeln2("*** ERROR: could not find variable " + s + " in " + Globals.Ref + " databank");
                }
            }
            double pch_base = ((Program.databanks.GetRef().GetIVariable(s + Globals.freqIndicator + G.GetFreq(Program.options.freq)) as Series).GetDataSimple(t) / (Program.databanks.GetRef().GetIVariable(s + Globals.freqIndicator + G.GetFreq(Program.options.freq)) as Series).GetDataSimple(t.Add(-1)) - 1) * 100;  //#getvar
            double pch_work = ((Program.databanks.GetFirst().GetIVariable(s + Globals.freqIndicator + G.GetFreq(Program.options.freq)) as Series).GetDataSimple(t) / (Program.databanks.GetFirst().GetIVariable(s + Globals.freqIndicator + G.GetFreq(Program.options.freq)) as Series).GetDataSimple(t.Add(-1)) - 1) * 100;  //#getvar
            return pch_work - pch_base;
        }

        public static void GetStartingPeriod()
        {
            //#09350943534
            int year = DateTime.Now.Year;
            if (year < 2015 || year > 2030) year = 2015;
            Globals.globalPeriodStart = new GekkoTime(Program.options.freq, year - 10, 1);
            Globals.globalPeriodEnd = new GekkoTime(Program.options.freq, year + 0, 1);
        }

        public static void Compare(O.Compare o)
        {
            if (o.opt_rel != 0d && o.opt_pch != 0d)
            {
                G.Writeln2("*** ERROR: You cannot use <rel> and <pch> at the same time");
                throw new GekkoException();
            }
            double rel = o.opt_rel;
            if (o.opt_pch != 0d) rel = o.opt_pch / 100d;

            string type2 = o.opt_sort;
            bool order = true;
            List<string> variables = O.Restrict(o.listItems, true, false, false, true);
            
            string variablesType = null;  //"_s" etc.
            bool dlog = false;
            string block = null;
            string file = o.fileName;
            file = G.StripQuotes(file);
            //TODO TODO 
            //TODO TODO file should be path...
            //TODO TODO 

            Sam(o.t1, o.t2, Program.databanks.GetRef(), Program.databanks.GetFirst(), type2, order, variables, variablesType, dlog, block, file, o.fileName, o.opt_dump, o.opt_abs, rel);
                        
        }

        //Used for tables, don't use for other stuff!
        public static double Dif(string db2, string s, GekkoTime t)
        {
            Databank db = Program.databanks.GetDatabank(db2);
            if (!db.ContainsIVariable(s + Globals.freqIndicator + G.GetFreq(Program.options.freq)))
            {
                if (Program.options.series_normal_table_missing == ESeriesMissing.M)
                {
                    return Globals.missingVariableArtificialNumber;
                }
                else
                {
                    G.Writeln2("*** ERROR: could not find variable " + s + " in " + db2 + " databank");
                }
            }
            return (db.GetIVariable(s + Globals.freqIndicator + G.GetFreq(Program.options.freq)) as Series).GetDataSimple(t) - (db.GetIVariable(s + Globals.freqIndicator + G.GetFreq(Program.options.freq)) as Series).GetDataSimple(t.Add(-1));  //#getvar
        }

        //Used for tables, don't use for other stuff!
        public static double MulDif(string s, GekkoTime t)
        {
            if (!Program.databanks.GetFirst().ContainsIVariable(s + Globals.freqIndicator + G.GetFreq(Program.options.freq)))
            {
                if (Program.options.series_normal_table_missing == ESeriesMissing.M)
                {
                    return Globals.missingVariableArtificialNumber;
                }
                else
                {
                    G.Writeln2("*** ERROR: could not find variable " + s + " in Work databank");
                }
            }
            if (!Program.databanks.GetRef().ContainsIVariable(s + Globals.freqIndicator + G.GetFreq(Program.options.freq)))
            {
                if (Program.options.series_normal_table_missing == ESeriesMissing.M)
                {
                    return Globals.missingVariableArtificialNumber;
                }
                else
                {
                    G.Writeln2("*** ERROR: could not find variable " + s + " in " + Globals.Ref + " databank");
                }
            }
            double dif_base = (Program.databanks.GetRef().GetIVariable(s + Globals.freqIndicator + G.GetFreq(Program.options.freq)) as Series).GetDataSimple(t) - (Program.databanks.GetRef().GetIVariable(s + Globals.freqIndicator + G.GetFreq(Program.options.freq)) as Series).GetDataSimple(t.Add(-1)); //#getvar
            double dif_work = (Program.databanks.GetFirst().GetIVariable(s + Globals.freqIndicator + G.GetFreq(Program.options.freq)) as Series).GetDataSimple(t) - (Program.databanks.GetFirst().GetIVariable(s + Globals.freqIndicator + G.GetFreq(Program.options.freq)) as Series).GetDataSimple(t.Add(-1)); //#getvar
            return dif_work - dif_base;
        }

        // --------------------------------------------------------------------------------------
        // ----------------- used for tables end ------------------------------------------------
        // --------------------------------------------------------------------------------------

        public static void RunCommandCalledFromGUI(string s, P p)
        {
            if (Globals.excelDna)
            {
                Globals.excelDnaOutput = new StringBuilder();  //clears, and records everything from now on for use in Excel window
            }
            Program.EmitCodeFromANTLR(s, "", false, 0, p);            
        }

        public static void Create(List varsInput, bool questionMark, O.Create o)
        {
            //ErrorIfDatabanksSwapped();
            if (varsInput == null && questionMark == true)
            {
                int count = Globals.createdVariables.Count;
                if (count == 1) G.Writeln2("There is 1 created variable:");
                else G.Writeln2("There are " + count + " created variables:");
                List<string> a4 = new List<string>();
                foreach (string s in Globals.createdVariables.Keys) a4.Add(s);
                a4.Sort(StringComparer.InvariantCulture);
                foreach (string m in a4)
                {
                    G.Writeln("  " + m);
                }
                G.Writeln();
            }
            else
            {
                List<string> vars = O.Restrict(o.names, true, false, true, false);

                foreach (string s in vars)
                {                                    
                    IVariable iv = O.GetIVariableFromString(s, O.ECreatePossibilities.Can);
                }

                G.Writeln2("Created: " + G.GetListWithCommas(vars));
                   
                
            }
        }

        

        public static void Collapse(List lhs, List rhs, string method, P p)
        {

            if (lhs.list.Count != rhs.list.Count)
            {
                G.Writeln2("*** ERROR: " + lhs.list.Count + " items on left, " + rhs.list.Count + " items on right");
                throw new GekkoException();
            }

            List<string> xlhs = O.Restrict(lhs, true, false, true, true);
            List<string> xrhs = O.Restrict(rhs, true, false, true, true);

            if (xlhs.Count != xrhs.Count)
            {
                G.Writeln2("*** ERROR: Internal error #89353245");
                throw new GekkoException();
            }

            for (int i = 0; i < xlhs.Count; i++)
            {

                string yLhs = xlhs[i];
                string yRhs = xrhs[i];

                Series ts_lhs = O.GetIVariableFromString(yLhs, O.ECreatePossibilities.Must) as Series;
                Series ts_rhs = O.GetIVariableFromString(yRhs, O.ECreatePossibilities.NoneReportError, true) as Series;  //can search

                if (method == null) method = "total";

                EFreq eFreq0 = ts_rhs.freq;
                EFreq eFreq1 = ts_lhs.freq;

                if (eFreq0 == EFreq.U || eFreq1 == EFreq.U)
                {
                    G.Writeln2("*** ERROR: COLLAPSE cannot involve undated timeseries");
                    throw new GekkoException();
                }

                GekkoTime first = ts_rhs.GetPeriodFirst(); //start of high-freq timeseries
                GekkoTime last = ts_rhs.GetPeriodLast(); //end of high-freq timeseries
                
                if (eFreq0 == EFreq.Q && eFreq1 == EFreq.A)
                {
                    //Conversion from Q to A
                    double vsum = double.NaN;
                    foreach (GekkoTime t in new GekkoTimeIterator(first, last))
                    {
                        
                        double value = ts_rhs.GetDataSimple(t);
                        if (t.sub == 1) vsum = 0d;
                        GekkoTime ttemp = new GekkoTime(eFreq1, t.super, 1);
                        if (G.Equal(method, "total"))
                        {
                            vsum += value;
                            if (t.sub == Globals.freqQSubperiods) ts_lhs.SetData(ttemp, vsum);
                        }
                        else if (G.Equal(method, "avg"))
                        {
                            vsum += value;
                            if (t.sub == Globals.freqQSubperiods) ts_lhs.SetData(ttemp, vsum / (double)Globals.freqQSubperiods);
                        }
                        else if (G.Equal(method, "first"))
                        {
                            if (t.sub == 1) ts_lhs.SetData(ttemp, value);
                        }
                        else if (G.Equal(method, "last"))
                        {
                            if (t.sub == Globals.freqQSubperiods) ts_lhs.SetData(ttemp, value);
                        }
                        else
                        {
                            G.Writeln2("*** ERROR: wrong method in COLLAPSE: " + method + "'");
                            throw new GekkoException();
                        }
                    }
                }
                else if (eFreq0 == EFreq.M && eFreq1 == EFreq.A)
                {
                    //Conversion from M to A
                    double vsum = double.NaN;
                    foreach (GekkoTime t in new GekkoTimeIterator(first, last))
                    {
                        
                        double value = ts_rhs.GetDataSimple(t);
                        if (t.sub == 1) vsum = 0d;
                        GekkoTime ttemp = new GekkoTime(eFreq1, t.super, 1);
                        if (G.Equal(method, "total"))
                        {
                            vsum += value;
                            if (t.sub == Globals.freqMSubperiods) ts_lhs.SetData(ttemp, vsum);
                        }
                        else if (G.Equal(method, "avg"))
                        {
                            vsum += value;
                            if (t.sub == Globals.freqMSubperiods) ts_lhs.SetData(ttemp, vsum / (double)Globals.freqMSubperiods);
                        }
                        else if (G.Equal(method, "first"))
                        {
                            if (t.sub == 1) ts_lhs.SetData(ttemp, value);
                        }
                        else if (G.Equal(method, "last"))
                        {
                            if (t.sub == Globals.freqMSubperiods) ts_lhs.SetData(ttemp, value);
                        }
                        else
                        {
                            G.Writeln2("*** ERROR: wrong method in COLLAPSE: " + method + "'");
                            throw new GekkoException();
                        }
                    }
                }
                else if (eFreq0 == EFreq.M && eFreq1 == EFreq.Q)
                {
                    //Conversion from M to Q
                    double vsum = double.NaN;
                    foreach (GekkoTime t in new GekkoTimeIterator(first, last))
                    {
                        double value = ts_rhs.GetDataSimple(t);
                        int mPerQ = Globals.freqMSubperiods / Globals.freqQSubperiods;  //3
                        int quarter = (t.sub - 1) / mPerQ + 1;
                        if (t.sub % mPerQ == 1) vsum = 0d;
                        GekkoTime ttemp = new GekkoTime(eFreq1, t.super, quarter);
                        if (G.Equal(method, "total"))
                        {
                            vsum += value;
                            if (t.sub % mPerQ == 0) ts_lhs.SetData(ttemp, vsum);
                        }
                        else if (G.Equal(method, "avg"))
                        {
                            vsum += value;
                            if (t.sub % mPerQ == 0) ts_lhs.SetData(ttemp, vsum / (double)mPerQ);
                        }
                        else if (G.Equal(method, "first"))
                        {
                            if (t.sub % mPerQ == 1) ts_lhs.SetData(ttemp, value);
                        }
                        else if (G.Equal(method, "last"))
                        {
                            if (t.sub % mPerQ == 0) ts_lhs.SetData(ttemp, value);
                        }
                    }
                }
                else if (eFreq0 == EFreq.D && eFreq1 == EFreq.M)
                {
                    //Conversion from D to M
                    double vsum = 0d;
                    bool ignoreNaN = true;

                    double n = 0d;                                

                    foreach (GekkoTime t in new GekkoTimeIterator(first, last))
                    {
                        //!! BEWARE: if a 'continue' is used, a tLowFreqPrevious = tLowFreq must be issued.
                                                
                        GekkoTime tLowFreq = new GekkoTime(eFreq1, t.super, t.sub);
                        GekkoTime tNext = t.Add(1);
                        GekkoTime tLowFreqNext = new GekkoTime(eFreq1, tNext.super, tNext.sub);

                        bool shouldCollapse = tLowFreqNext.StrictlyLargerThan(tLowFreq) || t.IsSamePeriod(last);

                        double value = ts_rhs.GetDataSimple(t);                                                
                        
                        if (G.Equal(method, "avg") || G.Equal(method, "total"))
                        {
                            if (!(ignoreNaN && G.isNumericalError(value)))
                            {
                                vsum += value;
                                n++;
                            }

                            if (shouldCollapse)
                            {
                                CollapseHelper(method, ts_lhs, vsum, n, tLowFreq);
                                vsum = 0d;
                                n = 0d;
                            }
                        }                        
                        else if (G.Equal(method, "first"))
                        {
                            //TODO: first with data?
                            G.Writeln2("*** ERROR: Option 'first' not yet implemented for daily collapse");
                            throw new GekkoException();
                            if (t.subsub == 1) ts_lhs.SetData(tLowFreq, value);
                        }
                        else if (G.Equal(method, "last"))
                        {
                            //TODO: last with data?
                            G.Writeln2("*** ERROR: Option 'last' not yet implemented for daily collapse");
                            throw new GekkoException();
                            if (t.subsub == G.DaysInMonth(t.super, t.sub)) ts_lhs.SetData(tLowFreq, value);
                        }
                        else
                        {
                            G.Writeln2("*** ERROR: wrong method in COLLAPSE: " + method + "'");
                            throw new GekkoException();
                        }
                     
                    }
                }
                else
                {
                    G.Writeln2("*** ERROR: Cannot COLLAPSE frequency '" + eFreq0 + "' to frequency '" + eFreq1 + "'");
                    throw new GekkoException();
                }

                G.ServiceMessage("Collapsed '" + yLhs + "' (" + eFreq1.ToString() + ") from '" + yRhs + "' (" + eFreq0.ToString() + ")", p);

            }
            return;
        }

        private static void CollapseHelper(string method, Series ts_lhs, double vsum, double n, GekkoTime tLowFreq)
        {
            double y = 1d;
            if (G.Equal(method, "avg")) y = n;
            ts_lhs.SetData(tLowFreq, vsum / y);
        }


        public static void Interpolate(List lhs, List rhs, string method, P p)
        {
            if (lhs.list.Count != rhs.list.Count)
            {
                G.Writeln2("*** ERROR: " + lhs.list.Count + " items on left, " + rhs.list.Count + " items on right");
                throw new GekkoException();
            }

            List<string> xlhs = O.Restrict(lhs, true, false, true, true);
            List<string> xrhs = O.Restrict(rhs, true, false, true, true);

            if (xlhs.Count != xrhs.Count)
            {
                G.Writeln2("*** ERROR: Internal error #89353245");
                throw new GekkoException();
            }

            for (int ii = 0; ii < xlhs.Count; ii++)
            {

                string yLhs = xlhs[ii];
                string yRhs = xrhs[ii];

                Series ts_lhs = O.GetIVariableFromString(yLhs, O.ECreatePossibilities.Must) as Series;
                Series ts_rhs = O.GetIVariableFromString(yRhs, O.ECreatePossibilities.NoneReturnNull, true) as Series;  //can search

                if (ts_lhs == null)
                {
                    G.Writeln2("*** ERROR: Cannot find: " + yRhs);
                }

                if (method == null) method = "repeat";

                EFreq eFreq0 = ts_rhs.freq;
                EFreq eFreq1 = ts_lhs.freq;

                GekkoTime first = ts_rhs.GetPeriodFirst(); //start of high-freq timeseries.
                GekkoTime last = ts_rhs.GetPeriodLast(); //end of high-freq timeseries

                double vsum = double.NaN;
                foreach (GekkoTime t in new GekkoTimeIterator(first, last))
                {
                    double value = ts_rhs.GetDataSimple(t);
                    if (value == double.NaN) continue;
                    if (eFreq1 == EFreq.Q && eFreq0 == EFreq.A)
                    {
                        //Conversion from A to Q                                        
                        if (G.Equal(method, "rep") || G.Equal(method, "repeat"))
                        {
                            for (int i = 1; i < Globals.freqQSubperiods + 1; i++)
                            {
                                GekkoTime gt = new GekkoTime(EFreq.Q, t.super, i);
                                ts_lhs.SetData(gt, value);
                            }
                        }
                        else if (G.Equal(method, "prorate"))
                        {
                            for (int i = 1; i < Globals.freqQSubperiods + 1; i++)
                            {
                                GekkoTime gt = new GekkoTime(EFreq.Q, t.super, i);
                                ts_lhs.SetData(gt, value / (double)Globals.freqQSubperiods);
                            }
                        }
                        else
                        {
                            G.Writeln2("*** ERROR: wrong method in INTERPOLATE: '" + method + "'");
                            throw new GekkoException();
                        }
                    }
                    else if (eFreq1 == EFreq.M && eFreq0 == EFreq.A)
                    {
                        //Conversion from A to M
                        if (G.Equal(method, "repeat"))
                        {
                            for (int i = 1; i < Globals.freqMSubperiods + 1; i++)
                            {
                                GekkoTime gt = new GekkoTime(EFreq.M, t.super, i);
                                ts_lhs.SetData(gt, value);
                            }
                        }
                        else if (G.Equal(method, "prorate"))
                        {
                            for (int i = 1; i < Globals.freqMSubperiods + 1; i++)
                            {
                                GekkoTime gt = new GekkoTime(EFreq.M, t.super, i);
                                ts_lhs.SetData(gt, value / (double)Globals.freqMSubperiods);
                            }
                        }
                        else
                        {
                            G.Writeln2("*** ERROR: wrong method in INTERPOLATE: " + method + "'");
                            throw new GekkoException();
                        }
                    }
                    else if (eFreq1 == EFreq.M && eFreq0 == EFreq.Q)
                    {
                        //Conversion from Q to M
                        int mInQ = Globals.freqMSubperiods / Globals.freqQSubperiods; //3
                        int startSub = (t.sub - 1) * mInQ + 1;  //1->1, 2->4, 3->7, 4->10
                        if (G.Equal(method, "repeat"))
                        {
                            for (int i = startSub; i < startSub + mInQ; i++)
                            {
                                GekkoTime gt = new GekkoTime(EFreq.M, t.super, i);
                                ts_lhs.SetData(gt, value);
                            }
                        }
                        else if (G.Equal(method, "prorate"))
                        {
                            for (int i = startSub; i < startSub + mInQ; i++)
                            {
                                GekkoTime gt = new GekkoTime(EFreq.M, t.super, i);
                                ts_lhs.SetData(gt, value / (double)mInQ);
                            }
                        }
                        else
                        {
                            G.Writeln2("*** ERROR: wrong method in INTERPOLATE: " + method + "'");
                            throw new GekkoException();
                        }

                    }
                    else
                    {
                        G.Writeln2("*** ERROR: Cannot INTERPOLATE frequency '" + eFreq0 + "' to frequency '" + eFreq1 + "'");
                        throw new GekkoException();
                    }
                }
                //G.Writeln("Interpolated '" + yLhs + "' (" + eFreq1.ToString() + ") from '" + yRhs + "' (" + eFreq0.ToString() + ")");
                G.ServiceMessage("Interpolated '" + yLhs + "' (" + eFreq1.ToString() + ") from '" + yRhs + "' (" + eFreq0.ToString() + ")", p);
            }
            return;
        }

        private static void GetFreq(string ss1, out string name1, out EFreq eFreq1)
        {
            List<string> s1 = new List<string>(ss1.Split('.'));            
            name1 = s1[0];
            string extension1 = "";
            if (s1.Count == 2) extension1 = s1[1];
            if (extension1 == "")
            {
                extension1 = G.GetFreq(Program.options.freq);
            }
            eFreq1 = G.GetFreq(extension1);
        }

        private static Databank GetDatabank(string b1)
        {
            Databank databank1 = Program.databanks.GetFirst();
            if (b1 == "@") databank1 = Program.databanks.GetRef();
            else if (b1 != "") databank1 = Program.databanks.GetDatabank(b1);
            if (databank1 == null)
            {
                G.Writeln2("*** ERROR: Databank '" + b1 + "' not found");
                throw new GekkoException();
            }

            return databank1;
        }

        public static void Delete(List vars2)
        {


            List vars = O.Restrict2(vars2, true, true, true, false);

            List<ToFrom> list = SearchFromTo(vars, null, null, null, EWildcardSearchType.Delete, null);
            
            int counter = 0;
            G.Writeln();

            for (int i = 0; i < list.Count; i++)
            {
                string var = list[i].s1;
                IVariable iv = O.RemoveIVariableFromString(var, false); //just warning
                if (iv != null) counter++;
            }
            
            if (counter == 0) G.Writeln("Did not delete any variables");
            else if (counter == 1) G.Writeln("Deleted 1 variable");
            else G.Writeln("Deleted " + counter + " variables");
        }

        public static void Combine(List<IVariable> input, List<List<string>> output, int depth, Stack<string> stack)
        {
            //could have cleaner interface, but never mind it works
            
            //input may be for instance a list: ('a', #i, 'x', #j), where we need to unfold
            //the second element and last

            if (depth == 0)  //use stack?
            {
                //first index                
            }

            if (depth == input.Count)
            {
                //we are beyond the length of input

                List<string> temp = new List<string>(stack.Reverse());
                output.Add(temp);
                stack.Pop();
                return;
            }

            IVariable iv = input[depth];

            if (iv.Type() == EVariableType.String)
            {
                string s = iv.ConvertToString();
                //output[output.Count - 1].Add(s);
                stack.Push(s);
                Combine(input, output, depth + 1, stack);

            }
            else if (iv.Type() == EVariableType.List)
            {
                foreach (IVariable iv2 in ((List)iv).list)
                {
                    string s = iv2.ConvertToString();
                    //output[output.Count - 1].Add(s);
                    stack.Push(s);
                    Combine(input, output, depth + 1, stack);
                }
            }
            else
            {
                G.Writeln2("*** ERROR: Expected indices to be of string or list type");
                throw new GekkoException();
            }
            if(depth > 0) stack.Pop();
            return;
        }

              
        public static double[,] XTransposeX(double[,] x)
        {
            //  1 2
            //  3 4     5 6 7 8       -->   3x2 * 2x4 = 3x4
            //  5 6     8 9 8 5
            //
            int xRows = x.GetLength(1);
            int xCols = x.GetLength(0);
            //int yRows = x.GetLength(0);
            //int yCols = x.GetLength(1);
                        
            double[,] z = new double[xRows, xRows];
            for (int i = 0; i < xRows; i++)
            {
                for (int j = 0; j < xRows; j++)
                {
                    double sum = 0d;
                    for (int k = 0; k < xCols; k++)
                    {
                        sum += x[k, i] * x[k, j];
                    }
                    z[i, j] = sum;
                }
            }
            return z;
            
        }

        public static GekkoAction GetGekkoAction(long n)
        {
            GekkoAction ga = null;
            Globals.linkAction.TryGetValue(n, out ga);
            if (ga == null || ga.action == null)
            {            
                G.Writeln2("+++ WARNING: Link of type '" + ga.type.ToString() + "' has expired");
                if (ga.type == EGekkoActionTypes.Ols)
                {
                    G.Writeln("             You may use different names for your OLS equations to avoid this", Globals.warningColor);
                }
            }
            return Globals.linkAction[n];
        }

        public static void Ols(O.Ols o)
        {
            // ------------------------------------------
            //n = number of obs
            //m = number of params (including trends and constant, so poly and constant are part of this)
            //k = number of restrictions (including Finnish trend restrictions)
            //constant = 0 or 1
            //poly = degree of trend poly
            // ------------------------------------------

            //AREMOS:
            //close*;clear;
            //import<tsd mute>maj11_pcim;
            //set per 50 2079
            //set per 80 2010;
            //equ lna1 = pcp, pcp.1, ul, ul.1;

            // LNA1
            // Ordinary Least Squares
            // ANNUAL data for   31 periods from 1980 to 2010
            // Date: 14 NOV 2013

            // lna1

            //   =    418.171 * pcp - 154.400 * pcp[-1] + 0.00154 * ul
            //       (2.96194)       (1.15821)           (0.03103)

            //      - 0.12668 * ul[-1] - 59.8149
            //       (2.58716)          (3.64875)

            // Sum Sq    1148.51   Std Err    6.6463   LHS Mean  154.294
            // R Sq       0.9876   R Bar Sq   0.9856   F  4, 26  515.654
            // D.W.( 1)   0.4673   D.W.( 2)   0.9352

            //Denne stemmer med Gekko.

            //What about: http://christoph.ruegg.name/blog/linear-regression-mathnet-numerics.html ?
            //Also see: http://christoph.ruegg.name/blog/towards-mathnet-numerics-v3.html

            IVariable lhs = o.expressions[0];
            List<IVariable> rhs = new List<IVariable>();
            for (int i = 1; i < o.expressions.Count; i++) rhs.Add(o.expressions[i]);
            List<Series> rhs_unfolded = UnfoldAsSeries(new GekkoSmpl(o.t1, o.t2), rhs);

            List<int> flatStart = new List<int>();
            List<int> flatEnd = new List<int>();
            int constant = 1; if (G.Equal(o.opt_constant, "no")) constant = 0;
            int poly;  //0 if there is none, else > 1. Cf. also constant.
            OLSGetTrendParameters(O.Restrict(o.opt_xtrend, false, false, false, false), O.Restrict(o.opt_xflat, false, false, false, false), flatStart, flatEnd, out poly);
            int n = GekkoTime.Observations(o.t1, o.t2);
            int m = rhs_unfolded.Count + poly + constant; //explanatory vars including poly and constant = number of params estimated INCLUDING possible poly and constant     
            List<int> trendparams = new List<int>();
            if (poly > 0)
            {
                for (int i = m - poly - constant; i < m - constant; i++)
                {
                    trendparams.Add(i);
                }
            }

            Series lhs_series = lhs as Series;
            if (lhs_series == null)
            {
                G.Writeln2("*** ERROR: Left-hand side should be a SERIES");
                throw new GekkoException();
            }

            //bool useScale = false; //usually true

            string name = o.name;
            if (name == null) name = "ols";

            double[,] tsData2 = null;
            int m2 = 0;

            double[,] x = new double[n, m];  //includes poly and constant if it is there, does not include lhs
            double[,] xOriginal = new double[n, m];  //includes poly and constant if it is there, does not include lhs
            double[] y = new double[n];

            OLSPackData(rhs_unfolded, constant, poly, lhs_series, o.t1, o.t2, n, x, xOriginal, y);

            Matrix name_param = new Matrix(m, 1, double.NaN);
            Matrix name_t = new Matrix(m, 1, double.NaN);
            Matrix name_se = new Matrix(m, 1, double.NaN);
            Matrix name_stats = new Matrix(9, 1, double.NaN);
            Matrix name_covar = new Matrix(m, m, double.NaN);
            Matrix name_corr = new Matrix(m, m, double.NaN);
            Series name_predict = new Series(o.t1.freq, G.Chop_FreqAdd(name + "_predict", lhs_series.freq));
            Series name_residual = new Series(o.t1.freq, G.Chop_FreqAdd(name + "_residual", lhs_series.freq));

            double[] scaling = new double[x.GetLength(1)];
            for (int kk = 0; kk < x.GetLength(1); kk++)
            {
                double sum = 0d;
                for (int tt = 0; tt < x.GetLength(0); tt++)
                {
                    sum += Math.Abs(x[tt, kk]);  //with abs we avoid stupid averages = 0 like -2, -1, 0, 1, 2 etc.
                }
                scaling[kk] = sum / x.GetLength(0);
                if (scaling[kk] == 0d) scaling[kk] = 1d;

                for (int tt = 0; tt < x.GetLength(0); tt++)
                {
                    x[tt, kk] = x[tt, kk] / scaling[kk];
                }
            }

            double[,] restrict_input = new double[0, m + 1];  //array[k, m+1]  c[i,0]*beta[0] + ... + c[i,m-1]*beta[m-1] = c[i,m]            

            int k = 0;

            if (o.impose != null)
            {
                Matrix rr = O.ConvertToMatrix(o.impose); //a row for each of the k restriction, and it has m+1 cols (second-last col is const if present, and last is what the restrict sums up to)
                k = rr.data.GetLength(0);
                int cols = rr.data.GetLength(1);

                if (cols != m + 1)
                {
                    G.Writeln2("*** ERROR: The impose matrix has " + cols + " cols, expected " + (m + 1));
                    throw new GekkoException();
                }

                restrict_input = new double[rr.data.GetLength(0), rr.data.GetLength(1)];  //needs to be cloned, otherwise the IMPOSE matrix will be changed with scaling
                for (int i = 0; i < rr.data.GetLength(0); i++)
                {
                    for (int j = 0; j < rr.data.GetLength(1) - 1; j++)
                    {
                        restrict_input[i, j] = rr.data[i, j] / scaling[j];
                    }
                    restrict_input[i, rr.data.GetLength(1) - 1] = rr.data[i, rr.data.GetLength(1) - 1];
                }
            }

            double[,] restrict = new double[0, m];
            if (flatStart.Count + flatEnd.Count > 0)
            {
                //note: this changes k (number of restrictions, where the trend restrictions are added)
                double vStart = x[0, trendparams[0]] * scaling[trendparams[0]];
                double vEnd = x[x.GetLength(0) - 1, trendparams[0]] * scaling[trendparams[0]];
                restrict = OLSFinnishTrends(flatStart, flatEnd, trendparams, scaling, restrict_input, vStart, vEnd);
                k += flatStart.Count + flatEnd.Count;
            }
            else
            {
                restrict = restrict_input;
            }

            int df = n - m + k; //degrees of freedom: number of obs - estimated coeffs (including const) + impose restrictions

            if (df <= 0)
            {
                string s = null;
                if (constant == 1) s = "(including constant) ";
                G.Writeln2("*** ERROR: There are " + m + " params " + s + "and " + k + " restrictions with only " + n + " observations");
                throw new GekkoException();
            }

            OLSRekurInfo rekurInfo = new OLSRekurInfo();
            rekurInfo.type = "r";

            DeleteGekkoActions(EGekkoActionTypes.Ols, name);

            //!!calling the engine ------------------------------------------------
            //!!calling the engine ------------------------------------------------
            //!!calling the engine ------------------------------------------------
            OLSResults ols = OLSHelper(o.t1, o.t2, y, x, xOriginal, restrict, scaling, n, m, k, df, false);
            //---------------------------------------------------------------------
            //---------------------------------------------------------------------
            //---------------------------------------------------------------------

            //Decomp
            if (true)
            {
                double[] contriby = new double[n];
                double[,] contribx = new double[m, n];
                double[,] contribx_raw = new double[m, n];
                double[] contribtrend = new double[n];
                double[] contribtrend_raw = new double[n];
                double[,] levelx = new double[m, n];
                double[] levely = new double[n];
                double[] sumx = new double[m];
                double sumy = 0d;
                for (int t = 0; t < n; t++) //time
                {
                    double sum = 0d;
                    for (int i = 0; i < m; i++) //variable
                    {
                        contribx[i, t] = ols.coeff[i] * xOriginal[t, i];
                        contribx_raw[i, t] = ols.coeff[i] * xOriginal[t, i];
                    }
                }

                for (int t = 0; t < n; t++) //time
                {
                    for (int i = 0; i < m; i++) //variable
                    {
                        sumx[i] += contribx[i, t];
                    }
                    sumy += ols.ypredict[t];
                }

                for (int t = 0; t < n; t++) //time
                {
                    for (int i = 0; i < m; i++) //variable
                    {
                        contribx[i, t] -= sumx[i] / (double)n;
                    }
                    foreach (int i in trendparams)
                    {
                        contribtrend[t] += contribx[i, t];
                        contribtrend_raw[t] += contribx_raw[i, t];  //used for ols_trend variable
                    }
                    contriby[t] = ols.ypredict[t] - sumy / (double)n;
                }

                for (int i = 0; i < m; i++) //vars
                {
                    string nameWithFreq = G.Chop_AddFreq(name + "_dec" + (i + 1), G.GetFreq(lhs_series.freq));
                    Series z = new Series(lhs_series.freq, nameWithFreq);
                    for (int t = 0; t < n; t++) //time
                    {
                        z.SetData(o.t1.Add(t), contribx[i, t]);
                    }
                    Program.databanks.GetFirst().AddIVariableWithOverwrite(nameWithFreq, z);
                }

                if (true)
                {
                    string nameWithFreq = G.Chop_AddFreq(name + "_dec", G.GetFreq(lhs_series.freq));
                    Series z = new Series(lhs_series.freq, nameWithFreq);
                    for (int t = 0; t < n; t++) //time
                    {
                        z.SetData(o.t1.Add(t), contriby[t]);
                    }
                    Program.databanks.GetFirst().AddIVariableWithOverwrite(nameWithFreq, z);
                    if (poly > 0)
                    {
                        string nameWithFreq2 = G.Chop_AddFreq(name + "_dec_trend", G.GetFreq(lhs_series.freq));
                        Series z2 = new Series(lhs_series.freq, nameWithFreq2);
                        for (int t = 0; t < n; t++) //time
                        {
                            z2.SetData(o.t1.Add(t), contribtrend[t]);
                        }
                        Program.databanks.GetFirst().AddIVariableWithOverwrite(nameWithFreq2, z2);

                        string nameWithFreq3 = G.Chop_AddFreq(name + "_trend", G.GetFreq(lhs_series.freq));
                        Series z3 = new Series(lhs_series.freq, nameWithFreq3);
                        for (int t = 0; t < n; t++) //time
                        {
                            z3.SetData(o.t1.Add(t), contribtrend_raw[t]);
                        }
                        Program.databanks.GetFirst().AddIVariableWithOverwrite(nameWithFreq3, z3);
                    }
                }

            }

            //Recursive estimation
            //Recursive estimation
            //Recursive estimation

            if (OLSRecursiveDfOk(df))
            {
                if (rekurInfo.type != null)
                {
                    foreach (string type in new List<string>() { "l", "e", "r" })
                    {
                        OLSRekurDatas rekur = OLSRecursive(m, x, y, scaling, k, n, restrict_input, df, Program.options.fit_ols_rekur_dfmin, type, trendparams, flatStart, flatEnd);
                        EFreq freq = lhs_series.freq;
                        string type2 = "left";
                        if (type == "e") type2 = "slide";
                        else if (type == "r") type2 = "right";
                        for (int i = 0; i < m; i++)
                        {
                            {
                                string nameWithFreq = G.Chop_AddFreq(name + "_v" + type2 + (i + 1) + "_low", G.GetFreq(freq));
                                Series z = new Series(freq, nameWithFreq);
                                if (type == "l")
                                    z.SetDataSequence(o.t1, o.t1.Add(df - Program.options.fit_ols_rekur_dfmin), rekur.datas[i].coeff_low);
                                else
                                    z.SetDataSequence(o.t2.Add(-df + Program.options.fit_ols_rekur_dfmin), o.t2, rekur.datas[i].coeff_low);
                                Program.databanks.GetFirst().AddIVariableWithOverwrite(nameWithFreq, z);
                            }

                            {
                                string nameWithFreq = G.Chop_AddFreq(name + "_v" + type2 + (i + 1), G.GetFreq(freq));
                                Series z = new Series(freq, nameWithFreq);
                                if (type == "l")
                                    z.SetDataSequence(o.t1, o.t1.Add(df - Program.options.fit_ols_rekur_dfmin), rekur.datas[i].coeff);
                                else
                                    z.SetDataSequence(o.t2.Add(-df + Program.options.fit_ols_rekur_dfmin), o.t2, rekur.datas[i].coeff);
                                Program.databanks.GetFirst().AddIVariableWithOverwrite(nameWithFreq, z);
                            }

                            {
                                string nameWithFreq = G.Chop_AddFreq(name + "_v" + type2 + (i + 1) + "_high", G.GetFreq(freq));
                                Series z = new Series(freq, nameWithFreq);
                                if (type == "l")
                                    z.SetDataSequence(o.t1, o.t1.Add(df - Program.options.fit_ols_rekur_dfmin), rekur.datas[i].coeff_high);
                                else
                                    z.SetDataSequence(o.t2.Add(-df + Program.options.fit_ols_rekur_dfmin), o.t2, rekur.datas[i].coeff_high);
                                Program.databanks.GetFirst().AddIVariableWithOverwrite(nameWithFreq, z);
                            }
                        }

                        {
                            string nameWithFreq = G.Chop_AddFreq(name + "_chow" + "_" + type2, G.GetFreq(freq));
                            Series z = new Series(freq, nameWithFreq);
                            if (type == "l")
                                z.SetDataSequence(o.t1, o.t1.Add(df - Program.options.fit_ols_rekur_dfmin), rekur.data.coeff);
                            else
                                z.SetDataSequence(o.t2.Add(-df + Program.options.fit_ols_rekur_dfmin), o.t2, rekur.data.coeff);
                            Program.databanks.GetFirst().AddIVariableWithOverwrite(nameWithFreq, z);
                        }
                    }
                }
            }
            else
            {
                G.Writeln2("Recursive estimation skipped because df is too low");
            }

            for (int j = 0; j < n; j++)
            {
                name_predict.SetData(o.t1.Add(j), ols.ypredict[j]);
                name_residual.SetData(o.t1.Add(j), ols.residual[j]);
            }

            Table tab = new Table();

            tab.Set(1, 1, "Variable");
            tab.Set(1, 2, "Estimate");
            tab.Set(1, 3, "Std error");
            tab.Set(1, 4, "T-stat");
            tab.Set(1, 5, "     ");  //to create some space between main table and links

            if (OLSRecursiveDfOk(df))
            {
                tab.Set(1, 6, "Recursive"); tab.SetAlign(1, 6, Align.Center);
            }

            tab.Merge(1, 6, 1, 8);
            tab.SetAlign(1, 1, 1, 1, Align.Left);
            tab.SetAlign(1, 2, 1, 4, Align.Right);
            for (int i = 0; i < m; i++)
            {
                string s = null;
                if (i + 1 < o.expressionsText.Count)
                {
                    s = TruncateTextWithDots(25, G.ReplaceGlueNew(o.expressionsText[i + 1]));
                }
                else
                {
                    if (trendparams.Contains(i))
                    {
                        for (int ii = 0; ii < trendparams.Count; ii++)
                        {
                            if (trendparams[ii] == i)
                            {
                                s = "TREND" + (ii + 1);
                            }
                        }
                    }
                    else
                    {
                        s = "CONSTANT";
                    }
                }
                tab.Set(i + 2, 1, s);
                tab.SetAlign(i + 2, 1, Align.Left);

                if (Math.Abs(ols.coeff[i]) > 1e12 || Math.Abs(ols.coeff[i]) < 1e-12)
                {
                    tab.SetNumber(i + 2, 2, ols.coeff[i], "s16.8");
                    tab.SetNumber(i + 2, 3, ols.se[i], "s16.8");
                    tab.SetNumber(i + 2, 4, ols.t[i], "f12.2");
                }
                else
                {
                    int digits = GetDigits(ols.coeff[i], 6);
                    tab.SetNumber(i + 2, 2, ols.coeff[i], "f16." + digits);
                    tab.SetNumber(i + 2, 3, ols.se[i], "f16." + digits);
                    tab.SetNumber(i + 2, 4, ols.t[i], "f12.2");
                }

                if (OLSRecursiveDfOk(df))
                {                    
                    // ---------
                    int ii = i;  //because of closure, else i is wrong, since it is a loop variable                    
                    Action a = () =>
                    {
                        Program.RunCommandCalledFromGUI("plot <" + o.t1.ToString() + " " + o.t2.ToString() + "> " + name + "_vleft" + (ii + 1) + "_low '' <type=lines linecolor='gray'>, " + name + "_vleft" + (ii + 1) + " <linecolor='red'>, " + name + "_vleft" + (ii + 1) + "_high '' <type=lines linecolor='gray'>;", new P());
                    };
                    tab.Set(i + 2, 6, G.GetLinkAction("Left", new GekkoAction(EGekkoActionTypes.Ols, name, a)));
                    // ---------
                }

                if (OLSRecursiveDfOk(df))
                {
                    // ---------
                    int ii = i;  //because of closure, else i is wrong, since it is a loop variable

                    Action a = () =>
                    {
                        Program.RunCommandCalledFromGUI("plot <" + o.t1.ToString() + " " + o.t2.ToString() + "> " + name + "_vslide" + (ii + 1) + "_low '' <type=lines linecolor='gray'>, " + name + "_vslide" + (ii + 1) + " <linecolor='red'>, " + name + "_vslide" + (ii + 1) + "_high '' <type=lines linecolor='gray'>;", new P());
                    };
                    tab.Set(i + 2, 7, G.GetLinkAction("Slide", new GekkoAction(EGekkoActionTypes.Ols, name, a)));
                    // ---------
                }

                if (OLSRecursiveDfOk(df))
                {
                    // ---------
                    int ii = i;  //because of closure, else i is wrong, since it is a loop variable                    
                    Action a = () =>
                    {
                        Program.RunCommandCalledFromGUI("plot <" + o.t1.ToString() + " " + o.t2.ToString() + "> " + name + "_vright" + (ii + 1) + "_low '' <type=lines linecolor='gray'>, " + name + "_vright" + (ii + 1) + " <linecolor='red'>, " + name + "_vright" + (ii + 1) + "_high '' <type=lines linecolor='gray'>;", new P());
                    };
                    tab.Set(i + 2, 8, G.GetLinkAction("Right", new GekkoAction(EGekkoActionTypes.Ols, name, a)));
                    // ---------
                }

                name_param.data[i, 0] = ols.coeff[i];
                name_se.data[i, 0] = ols.se[i];
                name_t.data[i, 0] = ols.t[i];
            }

            tab.SetBorder(1, 1, 1, 4, BorderType.Top);
            tab.SetBorder(1, 1, 1, 4, BorderType.Bottom);
            tab.SetBorder(m + 1, 1, m + 1, 4, BorderType.Bottom);

            string line = null;
            if (true)
            {
                Action a = () =>
                {
                    Program.RunCommandCalledFromGUI("plot <" + o.t1.ToString() + " " + o.t2.ToString() + " separate> " + name + "_predict+" + name + "_residual 'Obs' <linewidth = 6>, " + name + "_predict 'Fit', " + name + "_residual 'Res' <type=boxes>;", new P());
                };
                line += "  " + G.GetLinkAction("Fit", new GekkoAction(EGekkoActionTypes.Ols, name, a));

            }

            if (true)
            {

                Action a = () =>
                {
                    string s = null;

                    if (poly == 0)
                    {
                        for (int i = 0; i < m - constant; i++)
                        {
                            string label = o.expressionsText[i + 1];
                            s += ", " + name + "_dec" + (i + 1) + "'" + label + "'";
                        }
                        Program.RunCommandCalledFromGUI("plot <" + o.t1.ToString() + " " + o.t2.ToString() + "> " + name + "_dec '" + o.expressionsText[0] + "' <linewidth = 6>" + s + ";", new P());
                    }
                    else
                    {
                        //poly > 0
                        for (int i = 0; i < m - poly - constant; i++)
                        {
                            string label = o.expressionsText[i + 1];
                            s += ", " + name + "_dec" + (i + 1) + "'" + label + "'";
                        }
                        s += ", " + name + "_dec_trend 'trend'";
                        Program.RunCommandCalledFromGUI("plot <" + o.t1.ToString() + " " + o.t2.ToString() + "> " + name + "_dec '" + o.expressionsText[0] + "' <linewidth = 6>" + s + ";", new P());
                    }
                };
                line += "  " + G.GetLinkAction("Dec", new GekkoAction(EGekkoActionTypes.Ols, name, a));
            }

            tab.Set(m + 2, 1, OLSFormatHelper(ols)); tab.SetAlign(m + 2, 1, Align.Left); tab.Merge(m + 2, 1, m + 2, 3);
            tab.Set(m + 2, 4, line); tab.SetAlign(m + 2, 4, Align.Right);

            if (OLSRecursiveDfOk(df))
            {
                // ---------                
                Action a = () =>
                {
                    Program.RunCommandCalledFromGUI("plot <" + o.t1.ToString() + " " + o.t2.ToString() + " yline=1> " + name + "_chow_left 'Chow-test (left)' <type=boxes>;", new P());
                };
                tab.Set(m + 2, 6, G.GetLinkAction("Chow", new GekkoAction(EGekkoActionTypes.Ols, name, a)));
                // ---------
            }
            if (OLSRecursiveDfOk(df))
            {
                // ---------                
                Action a = () =>
                {
                    Program.RunCommandCalledFromGUI("plot <" + o.t1.ToString() + " " + o.t2.ToString() + " yline=1> " + name + "_chow_right 'Chow-test (right)' <type=boxes>;", new P());
                };
                tab.Set(m + 2, 8, G.GetLinkAction("Chow", new GekkoAction(EGekkoActionTypes.Ols, name, a)));
                // ---------
            }

            List<string> temp = tab.Print();
            Globals.lastPrtOrMulprtTable = tab;
            CrossThreadStuff.CopyButtonEnabled(true);

            int widthRemember = Program.options.print_width;
            int fileWidthRemember = Program.options.print_filewidth;
            Program.options.print_width = int.MaxValue;
            Program.options.print_filewidth = int.MaxValue;

            string flat = null;
            if (poly > 0) flat = ", poly = " + poly;
            if (flatStart.Count + flatEnd.Count > 0)
            {
                flat += ", polydf = " + (poly - (flatStart.Count + flatEnd.Count));
            }

            G.Writeln2(" " + Globals.ols1 + " " + o.t1 + "-" + o.t2 + ", " + n + " obs, " + m + " params, " + k + " restrictions (df = " + df + ")" + flat);
            G.Writeln(" " + Globals.ols2 + "" + G.ReplaceGlueNew(o.expressionsText[0])); //labels contain the LHS and all the RHS!       
            foreach (string s in temp) G.Writeln(s);


            if (Math.Abs(ols.resMean) > 0.000001d * ols.see)
            {
                G.Writeln2("+++ NOTE: The residuals do not seem to sum to zero. Did you omit a constant term?");
                G.Writeln("          Note that R2 and other statistics may be misleading in this case.");
            }

            name_stats.data[1 - 1, 0] = ols.rss;
            name_stats.data[2 - 1, 0] = ols.see;
            name_stats.data[3 - 1, 0] = ols.resMean;
            name_stats.data[4 - 1, 0] = ols.rmse; // rep.rmserror;
            name_stats.data[5 - 1, 0] = ols.r2;
            name_stats.data[6 - 1, 0] = ols.r2cor;
            name_stats.data[8 - 1, 0] = ols.lhsMean;
            name_stats.data[9 - 1, 0] = ols.dw;
            name_covar.data = ols.usedCovar;
            name_corr.data = ols.usedCorr;

            Program.databanks.GetFirst().AddIVariableWithOverwrite(name_predict);
            Program.databanks.GetFirst().AddIVariableWithOverwrite(name_residual);
            Program.databanks.GetFirst().AddIVariableWithOverwrite(Globals.symbolCollection + name + "_stats", name_stats);
            Program.databanks.GetFirst().AddIVariableWithOverwrite(Globals.symbolCollection + name + "_param", name_param);
            Program.databanks.GetFirst().AddIVariableWithOverwrite(Globals.symbolCollection + name + "_t", name_t);
            Program.databanks.GetFirst().AddIVariableWithOverwrite(Globals.symbolCollection + name + "_se", name_se);
            Program.databanks.GetFirst().AddIVariableWithOverwrite(Globals.symbolCollection + name + "_covar", name_covar);
            Program.databanks.GetFirst().AddIVariableWithOverwrite(Globals.symbolCollection + name + "_corr", name_corr);


            Program.options.print_width = widthRemember;
            Program.options.print_filewidth = fileWidthRemember;

            if (o.opt_dump != null)
            {
                string fileName = "ols.frm";
                if (!G.Equal(o.opt_dump, "yes")) fileName = o.opt_dump;

                bool append = false;
                if (G.Equal(o.opt_dumpoptions, "append")) append = true;

                try
                {
                    string s = null;
                    s += "FRML _i ";
                    s += G.ReplaceGlueNew(o.expressionsText[0]) + " = ";
                    bool hasVariable = false;
                    for (int i = 0; i < m - poly - constant; i++)
                    {
                        hasVariable = true;
                        if (i > 0)
                        {
                            if (name_param.data[i, 0] >= 0) s += " +";
                            else s += " ";
                        }
                        string var = G.ReplaceGlueNew(o.expressionsText[i + 1]);
                        var = var.Replace(" ", "");
                        if (var.Contains("+") || var.Contains("-")) var = "(" + var + ")";
                        s += Program.NumberFormat(name_param.data[i, 0], "f" + GetDigits(name_param.data[i, 0], 6)) + "*" + var;
                    }
                    if (poly > 0)
                    {
                        if (hasVariable) s += " + ";
                        s += name + "_trend ";
                    }
                    if (constant == 1)
                    {
                        int ii = m - 1;
                        if (name_param.data[ii, 0] >= 0) s += " +";
                        else s += " ";
                        s += Program.NumberFormat(name_param.data[ii, 0], "f" + GetDigits(name_param.data[ii, 0], 6));
                    }
                    s += ";";

                    GekkoFileReadOrWrite option = GekkoFileReadOrWrite.Write;
                    if (append) option = GekkoFileReadOrWrite.WriteAppend;

                    using (FileStream fs = WaitForFileStream(Program.CreateFullPathAndFileName(fileName), option))
                    using (StreamWriter sw = G.GekkoStreamWriter(fs))
                    {
                        sw.WriteLine(s);
                    }
                    G.Writeln2("Dumped OLS result as an equation inside the file '" + fileName + "'");
                }
                catch
                {
                    G.Writeln2("*** ERROR: OLS<dump> failed: is the file '" + fileName + "' blocked?");
                    throw new GekkoException();
                }
            }
        }

        private static bool OLSRecursiveDfOk(int df)
        {
            return Program.options.fit_ols_rekur_dfmin < df;
        }

        private static double[,] OLSFinnishTrends(List<int>flatStart, List<int>flatEnd, List<int> trendparams, double[] scaling, double[,] restrict_original, double vStart, double vEnd)
        {
            int extra = flatStart.Count + flatEnd.Count;
                        
            double[,] restrict_rv = new double[restrict_original.GetLength(0) + extra, restrict_original.GetLength(1)];                       

            for (int i = 0; i < restrict_original.GetLength(0); i++)
            {
                for (int j = 0; j < restrict_original.GetLength(1); j++)
                {
                    restrict_rv[i, j] = restrict_original[i, j];
                }
            }

            int counter2 = -1;

            foreach (int d in flatStart)
            {
                counter2++;
                int j = restrict_original.GetLength(0) + counter2;
                OLSHelper2(trendparams, d, "s");
                OLSFinnishTrends2(trendparams, scaling, restrict_rv, j, d, vStart);
            }

            foreach (int d  in flatEnd)
            {
                counter2++;
                int j = restrict_original.GetLength(0) + counter2;
                OLSHelper2(trendparams, d, "e");
                OLSFinnishTrends2(trendparams, scaling, restrict_rv, j, d, vEnd);
            }

            return restrict_rv;
        }

        private static void OLSFinnishTrends2(List<int> trendparams, double[] scaling, double[,] restrict_rv, int j, int d, double v)
        {
            int counter = -1;
            int counterNonZero = -1;
            int degree = trendparams.Count;
            foreach (int i in trendparams)
            {
                counter++;
                double factor = 1d;
                for (int d2 = counter + 2 - d; d2 < counter + 2; d2++)
                {
                    factor *= (double)d2;
                }
                if (factor != 0d)
                {
                    counterNonZero++;
                    factor *= Math.Pow(v, counterNonZero);
                    restrict_rv[j, i] = factor / scaling[i];
                }
            }
        }

        private static void OLSHelper2(List<int> trendparams, int d, string s)
        {            
            if (d > trendparams.Count)
            {
                G.Writeln2("*** ERROR: " + s + "... parameter must be <= " + (trendparams.Count) + " (poly degree)");
                throw new GekkoException();
            }
        }

        private static void OLSPackData(List<Series> rhs_unfolded, int constant, int poly, Series lhs_series, GekkoTime t1, GekkoTime t2, int n, double[,] x, double[,] xOriginal, double[] y)
        {
            int i = 0;
            foreach (GekkoTime t in new GekkoTimeIterator(t1, t2))
            {
                int j = 0;
                foreach (IVariable xx in rhs_unfolded)
                {
                    x[i, j] = xx.GetVal(t);
                    xOriginal[i, j] = x[i, j];
                    j++;
                }
                for (int p = 1; p <= poly; p++)
                {
                    //x[i, j] = Math.Pow(i - n + 1, p);
                    x[i, j] = Math.Pow((double)(i - n + 1) / (double)(n - 1), p);
                    xOriginal[i, j] = x[i, j];
                    j++;
                }
                if (constant == 1)
                {
                    x[i, j] = 1d;
                    xOriginal[i, j] = x[i, j];  //just for symmetry
                    j++;  //just for symmetry
                }
                y[i] = lhs_series.GetVal(t);
                i++;
            }
        }

        private static void OLSGetTrendParameters(List<string> xtrend, List<string> xtrendflat, List<int> flatStart, List<int> flatEnd, out int polydf)
        {   
            if (xtrendflat != null)
            {
                foreach (string s in xtrendflat)
                {
                    if (s.StartsWith("s", StringComparison.Ordinal))
                    {
                        string s2 = s.Substring("s".Length);
                        flatStart.Add(G.ConvertToInt(Functions.HelperValConvertFromString(s2)));
                    }
                    else if (s.StartsWith("e", StringComparison.Ordinal))
                    {
                        string s2 = s.Substring("e".Length);
                        flatEnd.Add(G.ConvertToInt(Functions.HelperValConvertFromString(s2)));
                    }
                    else
                    {
                        G.Writeln2("*** ERROR: xflat: syntax error");
                        throw new GekkoException();
                    }
                }
            }

            polydf = 0;
            if (xtrend != null)
            {
                //xtrend = 0 will just be ignored (will not become a constant if no constant present)
                if (xtrend.Count > 1)
                {
                    G.Writeln2("*** ERROR: xtrend: only 1 element is allowed");
                    throw new GekkoException();
                }
                polydf = G.ConvertToInt(Functions.HelperValConvertFromString(xtrend[0]));
                if ((polydf < 0))
                {
                    G.Writeln2("*** ERROR: xtrend: polynomium cannot be negative");
                    throw new GekkoException();
                }
            }

        }

        public static void DeleteGekkoActions(EGekkoActionTypes type, string name)
        {
            foreach (GekkoAction ga in Globals.linkAction.Values)
            {
                if (ga.type == type)
                {
                    if (name == null || (name != null && G.Equal(ga.name, name)))
                    {
                        //expire all links that match the type and name
                        //if no name given (=null), all links with that type are expired
                        ga.action = null;
                    }
                }
            }
        }

        private static OLSRekurDatas OLSRecursive(int m, double[,] x, double[] y, double[] scaling, int k, int n, double[,] restrict_input, int df_original, int df_start, string type, List<int> trendparams, List<int> flatStart, List<int> flatEnd)
        {
            if (df_start < 1)
            {
                G.Writeln2("*** ERROR: minimum degrees of freedom must be > 0");
                throw new GekkoException();
            }
            
            OLSRekurDatas rekur = new OLSRekurDatas(m, df_original - df_start + 1);  //if df_start == 1, this corresponds to index 0 in arrays

            double rss0 = double.NaN;
            for (int df7 = df_start; df7 <= df_original; df7++)
            {
                int n7; double[] y7; double[,] x7;
                if (type == "r")
                {
                    OLSRecursiveHelperR(m, x, y, k, df7, 0, out n7, out y7, out x7);
                }
                else if (type == "e")
                {
                    OLSRecursiveHelperR(m, x, y, k, df7, df7 - df_start, out n7, out y7, out x7);
                }
                else  //"l"
                {
                    OLSRecursiveHelperL(m, x, y, k, n, df7, out n7, out y7, out x7);
                }

                //Here, we need to adjust the restrict matrix, if there are Finnish trends

                double[,] restrict7 = restrict_input;

                if (trendparams.Count > 0)
                {
                    double vStart7 = x7[0, trendparams[0]] * scaling[trendparams[0]];
                    double vEnd7 = x7[x7.GetLength(0) - 1, trendparams[0]] * scaling[trendparams[0]];
                    restrict7 = OLSFinnishTrends(flatStart, flatEnd, trendparams, scaling, restrict_input, vStart7, vEnd7);
                }

                bool fail = false;
                OLSResults ols7 = null;
                try
                {
                    ols7 = OLSHelper(GekkoTime.tNull, GekkoTime.tNull, y7, x7, null, restrict7, scaling, n7, m, k, df7, true);
                }
                catch
                {
                    fail = true;
                }                

                int index = df7 - df_start;
                if (type == "l") index = rekur.datas[0].coeff.Length - (df7 - df_start) - 1;

                // ---------> df_original - df_start + 1

                if (fail)
                {
                    for (int i = 0; i < m; i++)
                    {
                        rekur.datas[i].coeff_low[index] = double.NaN;
                        rekur.datas[i].coeff[index] = double.NaN;
                        rekur.datas[i].coeff_high[index] = double.NaN;
                    }
                    rekur.data.coeff[index] = double.NaN;
                }
                else
                {
                    for (int i = 0; i < m; i++)
                    {
                        rekur.datas[i].coeff_low[index] = ols7.coeff[i] - 2d * ols7.se[i];
                        rekur.datas[i].coeff[index] = ols7.coeff[i];
                        rekur.datas[i].coeff_high[index] = ols7.coeff[i] + 2d * ols7.se[i];
                    }
                    double t = alglib.studenttdistr.invstudenttdistribution(df7, 0.975);  // limit for df --> inf = 1.960. The AREMOS version subtracts 1, maybe this is an error?
                    double chow = (ols7.rss - rss0) / rss0 * df7 / (t * t);
                    rekur.data.coeff[index] = chow;
                    rss0 = ols7.rss;
                }                
            }           

            return rekur;

        }

        private static void OLSRecursiveHelperR(int m, double[,] x, double[] y, int k, int df7, int offsetLeft, out int n7, out double[] y7, out double[,] x7)
        {
            //handles both right and elv types
            //df = n - m + k, so n = df + m - k
            n7 = df7 + m - k - offsetLeft;
            //cut obs from the right, and also from the left with offsetLeft
            y7 = new double[n7];
            x7 = new double[n7, m];
            for (int i = 0; i < n7; i++)
            {
                y7[i] = y[i + offsetLeft];
                for (int j = 0; j < m; j++)
                {
                    x7[i, j] = x[i + offsetLeft, j];
                }
            }
        }

        private static void OLSRecursiveHelperL(int m, double[,] x, double[] y, int k, int n, int df7, out int n7, out double[] y7, out double[,] x7)
        {
            //handles left types
            //df = n - m + k, so n = df + m - k
            n7 = df7 + m - k;
            //cut obs from the right, and also from the left with offsetLeft
            y7 = new double[n7];
            x7 = new double[n7, m];
            //for (int i = 0; i < n7; i++)
            for (int i = n - n7; i < n; i++)
            {
                y7[i - (n - n7)] = y[i];
                for (int j = 0; j < m; j++)
                {
                    x7[i - (n - n7), j] = x[i, j];
                }
            }
        }

        private static string OLSFormatHelper(OLSResults ols)
        {
            return "R2: " + Math.Round(ols.r2, 6, MidpointRounding.AwayFromZero) + "    " + "SEE: " + RoundToSignificantDigits(ols.see, 6) + "    " + "DW: " + Math.Round(ols.dw, 4, MidpointRounding.AwayFromZero);
        }

        private static OLSResults OLSHelper(GekkoTime t1, GekkoTime t2, double[] y, double[,] x, double[,] xOriginal, double[,] restrict_input, double[] scaling, int n, int m, int k, int df, bool calledFromRecursive)
        {
            OLSResults ols = new OLSResults();

            double[,] r = null;

            r = new double[restrict_input.GetLength(0), restrict_input.GetLength(1) - 1];
            for (int i = 0; i < restrict_input.GetLength(0); i++)
            {
                for (int j = 0; j < restrict_input.GetLength(1) - 1; j++)
                {
                    r[i, j] = restrict_input[i, j];
                }
            }            

            alglib.lsfit.lsfitreport rep = new alglib.lsfit.lsfitreport();
            //http://www.alglib.net/translator/man/manual.csharp.html#sub_lsfitlinearc
            //if it detects k = 0, it just calls same procedure as alglib.lsfit.lsfitlinear()
            ols.beta = null;
            int info2 = -12345;
            try
            {
                alglib.lsfit.lsfitlinearc(y, x, restrict_input, n, m, k, ref info2, ref ols.beta, rep);
            }
            catch (Exception e)
            {
                if (calledFromRecursive == false)
                {
                    int missingsAtStart = OLSHelper_missingsStart(y, xOriginal);
                    int missingsAtEnd = OLSHelper_missingsEnd(y, xOriginal);

                    if (missingsAtStart > 0 || missingsAtEnd > 0)
                    {
                        G.Writeln();
                    }

                    if (missingsAtStart > 0)
                    {
                        G.Writeln("*** ERROR: " + missingsAtStart + " missing values at start of sample");                        
                    }

                    if (missingsAtEnd > 0)
                    {
                        G.Writeln("*** ERROR: " + missingsAtEnd + " missing values at end of sample");
                    }

                    if (missingsAtStart > 0 || missingsAtEnd > 0)
                    {                        
                        t1 = t1.Add(missingsAtStart);
                        t2 = t2.Add(-missingsAtEnd);
                        if (t1.SmallerThanOrEqual(t2))
                        {
                            G.Writeln("           Suggested OLS period: <" + t1.ToString() + " " + t2.ToString() + ">", Color.Red);
                        }
                        throw new GekkoException();
                    }

                    if (e.Message != null && e.Message != "")
                    {
                        G.Writeln2("*** ERROR: " + e.Message);
                        G.Writeln("*** ERROR: OLS does not solve, please check data for missings etc.");
                    }
                    if (e.InnerException != null && e.InnerException.Message != null && e.InnerException.Message != "")
                    {
                        G.Writeln2("*** ERROR: " + e.InnerException.Message);
                        G.Writeln("*** ERROR: OLS does not solve, please check data for missings etc.");
                    }
                }
                throw;
            }
            if (info2 != 1)
            {
                if (calledFromRecursive == false)
                {
                    G.Writeln2("*** ERROR: OLS does not solve.");
                    if (info2 == -2)
                    {
                        G.Writeln("           Internal SVD decomposition subroutine failed (degenerate systems only)");
                    }
                    if (info2 == -3)
                    {
                        G.Writeln("           Either too many constraints (more than # of parameters),");
                        G.Writeln("           degenerate constraints (some constraints are");
                        G.Writeln("           repeated twice) or inconsistent constraints were specified.");
                    }
                }
                throw new GekkoException();
            }

            ols.ypredict = new double[n];
            ols.residual = new double[n];
            double dw1 = 0d;
            ols.rss = 0d;
            ols.resMean = 0d;
            ols.lhsMean = 0d;
            double ySum = 0d;
            for (int i = 0; i < n; i++)
            {
                ySum += y[i];
            }
            double yAvg = ySum / (double)n;

            ols.ssTot = 0d;
            for (int i = 0; i < n; i++)
            {
                ols.ypredict[i] = 0d;
                for (int ik = 0; ik < m; ik++)
                {
                    ols.ypredict[i] += ols.beta[ik] * x[i, ik];
                }
                ols.residual[i] = y[i] - ols.ypredict[i];
                ols.resMean += ols.residual[i];

                ols.lhsMean += y[i];
                ols.rss += ols.residual[i] * ols.residual[i];
                ols.ssTot += (y[i] - yAvg) * (y[i] - yAvg);
                if (i > 0) dw1 += (ols.residual[i] - ols.residual[i - 1]) * (ols.residual[i] - ols.residual[i - 1]);
            }
            ols.resMean = ols.resMean / (double)n;
            ols.lhsMean = ols.lhsMean / (double)n;

            ols.dw = dw1 / ols.rss;
            ols.rmse = Math.Sqrt(ols.rss / (double)n);
            ols.see = Math.Sqrt(ols.rss / (double)df);
            ols.usedCovar = null;
            double[,] ixtx = InvertMatrix(XTransposeX(x), !calledFromRecursive);  //fails with an error, silent
            if (r.GetLength(0) == 0)
            {
                //covar = sigma^2 * inv(X'X)
                ols.usedCovar = O.MultiplyMatrixScalar(ixtx, ols.see * ols.see, ixtx.GetLength(0), ixtx.GetLength(1));
            }
            else
            {
                //covar = sigma^2 *( inv(X'X)  -   inv(X'X) * R' inv( R  inv(X'X) R' ) R  inv(X'X) )                
                double[,] inside = InvertMatrix(MultiplyMatrices(MultiplyMatrices(r, ixtx), Transpose(r)), !calledFromRecursive);  //inv fails with an error, silent
                double[,] temp1 = MultiplyMatrices(MultiplyMatrices(MultiplyMatrices(MultiplyMatrices(ixtx, Transpose(r)), inside), r), ixtx);
                double[,] temp2 = O.SubtractMatrixMatrix(ixtx, temp1, ixtx.GetLength(0), ixtx.GetLength(1));
                ols.usedCovar = O.MultiplyMatrixScalar(temp2, ols.see * ols.see, temp2.GetLength(0), temp2.GetLength(1));
            }

            //usedCovar = rep.covpar; --> this yields the same (without restrictions), also in the case without constant

            //unscale
            for (int i = 0; i < ols.usedCovar.GetLength(0); i++)
            {
                for (int j = 0; j < ols.usedCovar.GetLength(1); j++)
                {
                    ols.usedCovar[i, j] = ols.usedCovar[i, j] / scaling[i] / scaling[j];
                }
            }

            ols.usedCorr = new double[ols.usedCovar.GetLength(0), ols.usedCovar.GetLength(1)];
            for (int i = 0; i < ols.usedCovar.GetLength(0); i++)
            {
                for (int j = 0; j < ols.usedCovar.GetLength(1); j++)
                {
                    ols.usedCorr[i, j] = ols.usedCovar[i, j] / Math.Sqrt(ols.usedCovar[i, i]) / Math.Sqrt(ols.usedCovar[j, j]);
                }
            }

            ols.coeff = new double[m];
            ols.se = new double[m];
            ols.t = new double[m];
            for (int i = 0; i < m; i++)
            {
                ols.coeff[i] = 1d / scaling[i] * ols.beta[i];
                ols.se[i] = Math.Sqrt(ols.usedCovar[i, i]);
                ols.t[i] = Math.Abs(ols.coeff[i] / Math.Sqrt(ols.usedCovar[i, i]));
            }

            ols.r2 = 1d - ols.rss / ols.ssTot;
            //k is number of impose restrictions
            //our m includes the constant term
            //See this page: https://en.wikipedia.org/wiki/Coefficient_of_determination
            //There the correction is (n-1)/(n-p-1), where p is number of regressors not counting the constant term.
            ols.r2cor = 1d - (1 - ols.r2) * (n - 1) / (double)df; //google "r2 adjusted formula". Our m includes the constant, usually regressors do not count the constant -> therefore (m-1). TT added k, must be so.

            return ols;

        }

        private static int OLSHelper_missingsStart(double[] y, double[,] xOriginal)
        {
            int missingsAtStart = 0;
            for (int i = 0; i < y.Length; i++)
            {
                if (G.isNumericalError(y[i]))
                {
                    missingsAtStart++;
                    goto Label1;
                }
                int nn = xOriginal.GetLength(1);
                for (int ii = 0; ii < nn; ii++)
                {
                    if (G.isNumericalError(xOriginal[i, ii]))
                    {
                        missingsAtStart++;
                        goto Label1;
                    }
                }
                break;  //no more missings
            Label1:;
            }

            return missingsAtStart;
        }

        private static int OLSHelper_missingsEnd(double[] y, double[,] xOriginal)
        {
            int missingsAtEnd = 0;
            for (int i = y.Length - 1; i >= 0; i--)
            {
                if (G.isNumericalError(y[i]))
                {
                    missingsAtEnd++;
                    goto Label1;
                }
                int nn = xOriginal.GetLength(1);
                for (int ii = 0; ii < nn; ii++)
                {
                    if (G.isNumericalError(xOriginal[i, ii]))
                    {
                        missingsAtEnd++;
                        goto Label1;
                    }
                }
                break;  //no more missings
            Label1:;
            }

            return missingsAtEnd;
        }

        private static int GetDigits(double coeff, int i)
        {
            int digits = -(int)RoundDecimals1(coeff) + i;  //can be negative
            if (digits < 0) digits = 0;
            return digits;
        }

        public static double StandardDeviation(List<double> valueList)
        {
            double M = 0.0;
            double S = 0.0;
            int k = 1;
            foreach (double value in valueList)
            {
                double tmpM = M;
                M += (value - tmpM) / k;
                S += (value - tmpM) * (value - M);
                k++;
            }
            return Math.Sqrt(S / (k - 2));
        }

        public static double Mean(List<double> valueList)
        {
            double m = 0d;
            foreach (double value in valueList)
            {
                m += value;
            }
            return m/valueList.Count;
        }

        public static void Max(out int maxI, out double max, List<double> list)
        {
            maxI = int.MinValue;
            max = double.MinValue;
            for(int i = 0;i< list.Count ;i++)
            {
                double d = list[i];
                if (d > max)
                {
                    max = d;
                    maxI = i;
                }
            }
        }

        public static void Min(out int minI, out double min, List<double> list)
        {
            minI = int.MaxValue;
            min = double.MaxValue;
            for (int i = 0; i < list.Count; i++)
            {
                double d = list[i];
                if (d < min)
                {
                    min = d;
                    minI = i;
                }
            }
        }        
        
        public static List<IVariable> Unfold(IVariable x)
        {
            return Unfold(new List<IVariable> { x });
        }

        public static List<IVariable> Unfold(List<IVariable> xlist)
        {
            List<IVariable> xlistUnfolded = new List<IVariable>();
            foreach (IVariable x in xlist)
            {
                if (x.Type() == EVariableType.Series)
                {
                    xlistUnfolded.Add(x);                    
                }
                else if (x.Type() == EVariableType.Val)
                {
                    xlistUnfolded.Add(x);
                }
                else if (x.Type() == EVariableType.Matrix && ((Matrix)x).data.Length == 1)  //an 1x1 matrix
                {
                    xlistUnfolded.Add(x);
                }
                else if (x.Type() == EVariableType.List)
                {
                    foreach (IVariable iv in ((List)x).list)
                    {
                        List<IVariable> extraContainerExplode = Unfold(iv);
                        xlistUnfolded.AddRange(extraContainerExplode);
                    }
                }
                else
                {
                    G.Writeln2("*** ERROR: Can only use SERIES, VAL, 1x1 MATRIX, or LISTs with these");
                    throw new GekkoException();
                }
            }
            return xlistUnfolded;
        }

        public static List<Series> UnfoldAsSeries(GekkoSmpl smpl, IVariable x)
        {
            return UnfoldAsSeries(smpl, new List<IVariable> { x });
        }

        public static List<Series> UnfoldAsSeries(GekkoSmpl smpl, List<IVariable> xlist)
        {
            List<Series> xlistUnfolded = new List<Series>();
            foreach (IVariable x in xlist)
            {
                if (x.Type() != EVariableType.List)
                {
                    xlistUnfolded.Add(O.ConvertToSeriesMaybeConstant(smpl, x));
                }                
                else
                {
                    foreach (IVariable iv in ((List)x).list)
                    {
                        List<Series> extraContainerExplode = UnfoldAsSeries(smpl, iv);
                        xlistUnfolded.AddRange(extraContainerExplode);
                    }
                }
            }
            return xlistUnfolded;
        }

        public static void Analyze(O.Analyze o)
        {

            //set per 2001 2010;
            //ser x1 = 1,2,4,5,6,5,6,7,8,6;
            //ser x2 = 5,4,4,5,6,3,6,1,8,6;
            //ser x3 = 7,5,4,1,6,5,9,7,8,9;
            //analyze <matrix>x1,x2,x3 xx;
            //disp<decimals 8> xx;

            //time 2001 2010;
            //create x1, x2, x3;
            //ser x1 = 1,2,4,5,6,5,6,7,8,6;
            //ser x2 = 5,4,4,5,6,3,6,1,8,6;
            //ser x3 = 7,5,4,1,6,5,9,7,8,9;
            //analyze x1,x2,x3;

            //  1 x1
            //    ANNUAL Data for   10 periods from 2001  to 2010
            //     Mean            5.00            Standard deviation         2.16
            //     Maximum         8.00 in  2009
            //     Minimum         1.00 in  2001
            //  2 x2
            //    ANNUAL Data for   10 periods from 2001  to 2010
            //     Mean            4.80            Standard deviation         1.93
            //     Maximum         8.00 in  2009
            //     Minimum         1.00 in  2008
            //  3 x3
            //    ANNUAL Data for   10 periods from 2001  to 2010
            //     Mean            6.10            Standard deviation         2.47
            //     Maximum         9.00 in  2010
            //     Minimum         1.00 in  2004

            //     Cross correlation based on    10 observations
            //      1      2      3
            //  1   1.00
            //  2   0.21   1.00
            //  3   0.31   0.31   1.00

            // => disp<decimals 8> xx

            //MATRIX   XX

            //              1          2          3
            //   1 1.00000000 0.21295885 0.31237800
            //   2 0.21295885 1.00000000 0.30733932
            //   3 0.31237800 0.30733932 1.00000000

            GekkoTime t1 = o.t1;
            GekkoTime t2 = o.t2;

            List<IVariable> input = Unfold(o.x);
            List<string> labels = new List<string>();
            for (int i = 0; i < input.Count; i++)
            {
                labels.Add(G.ReplaceGlueNew(o.expressionsText[i]));
            }
            
            int n = GekkoTime.Observations(t1, t2);
            int k = input.Count;            
            double[,] tsData = new double[n, k];

            int n_i = 0;
            foreach (GekkoTime t in new GekkoTimeIterator(t1, t2))
            {
                int k_i = 0;
                foreach (IVariable x in input)
                {
                    tsData[n_i, k_i] = x.GetVal(t);
                    k_i++;
                }
                n_i++;
            }

            G.Writeln();
            int counter = -1;
            foreach (string s in labels)
            {
                counter++;
                List<double> x = new List<double>(n);
                for (int i = 0; i < n; i++)
                {
                    x.Add(tsData[i, counter]);
                }
                double std = StandardDeviation(x);
                double mean = Mean(x);
                int minI; double min;
                Min(out minI, out min, x);
                int maxI; double max;
                Max(out maxI, out max, x);
                int width = 16;
                G.Writeln(s);
                G.Writeln("  " + n + " observations from " + t1.ToString() + " to " + t2.ToString());
                G.Writeln("  Mean    = " + G.levelFormat(mean, width));
                G.Writeln("  St.dev. = " + G.levelFormat(std, width));
                G.Writeln("  Min     = " + G.levelFormat(min, width) + " in " + t1.Add(minI).ToString());
                G.Writeln("  Max     = " + G.levelFormat(max, width) + " in " + t1.Add(maxI).ToString());
            }

            if (k > 1)
            {

                foreach (double d in tsData)
                {
                    if (G.isNumericalError(d))
                    {
                        G.Writeln2("*** ERROR: Correlation cannot be computed due to missing values");
                        throw new GekkoException();
                    }
                }

                double[,] y = null;
                alglib.pearsoncorrm(tsData, out y);
                Matrix m = new Matrix();
                m.data = y;

                Program.databanks.GetFirst().AddIVariableWithOverwrite("#corr", m);

                G.Writeln2("Cross correlation based on " + k + " variables and " + n + " observations");
                //counter = 0;
                //foreach (string s in labels)
                //{
                //    counter++;
                //    G.Writeln("Variable " + counter + ": " + s);
                //}
                Program.ShowMatrix(m, Globals.symbolCollection + "corr");
            }
        }

        

        public static DialogResult InputBox(string title, string promptText, ref string value)
        {
            Form form = new Form();
            System.Windows.Forms.Label label = new System.Windows.Forms.Label();
            TextBox textBox = new TextBox();
            Button buttonOk = new Button();
            Button buttonCancel = new Button();

            form.Text = title;
            label.Text = promptText;
            //label.Text = "This is the first line\r\nAnd this is the second line.";
            //string s = "This is the first line\r\nAnd this is the second line.";
            textBox.Text = value;

            buttonOk.Text = "OK";
            buttonCancel.Text = "Cancel";
            buttonOk.DialogResult = DialogResult.OK;
            buttonCancel.DialogResult = DialogResult.Cancel;

            label.SetBounds(9, 20 - 5, 372, 13);
            textBox.SetBounds(12, 36, 372, 20);
            buttonOk.SetBounds(228, 72, 75, 23);
            buttonCancel.SetBounds(309, 72, 75, 23);

            label.AutoSize = true;
            textBox.Anchor = textBox.Anchor | AnchorStyles.Right;
            buttonOk.Anchor = AnchorStyles.Bottom | AnchorStyles.Right;
            buttonCancel.Anchor = AnchorStyles.Bottom | AnchorStyles.Right;

            form.ClientSize = new Size(396, 107);
            form.Controls.AddRange(new Control[] { label, textBox, buttonOk, buttonCancel });
            form.ClientSize = new Size(Math.Max(300, label.Right + 10), form.ClientSize.Height);
            form.FormBorderStyle = FormBorderStyle.FixedDialog;
            form.StartPosition = FormStartPosition.CenterScreen;
            form.MinimizeBox = false;
            form.MaximizeBox = false;
            form.AcceptButton = buttonOk;
            form.CancelButton = buttonCancel;

            DialogResult dialogResult = form.ShowDialog();
            value = textBox.Text;
            return dialogResult;
        }

        public static double RoundToSignificantDigits(this double d, int digits)
        {
            if (d == 0)
                return 0;            
            return RoundDecimals2(d, digits);
        }

        private static double RoundDecimals2(double d, int digits)
        {
            double scale = Math.Pow(10, RoundDecimals1(d));
            double scale2 = scale * Math.Round(d / scale, digits, MidpointRounding.AwayFromZero);
            return scale2;
        }

        private static double RoundDecimals1(double d)
        {
            return Math.Floor(Math.Log10(Math.Abs(d))) + 1;
        }

        

        public static void AllSeriesCheckRecursive(IVariable x, ref bool fail, ref int seriesCounter)
        {
            if (x.Type() == EVariableType.List)
            {
                foreach (IVariable iv in (x as List).list)
                {
                    AllSeriesCheckRecursive(iv, ref fail, ref seriesCounter);
                    if (fail) break;  //no need to carry on
                }
            }
            else
            {
                if (!IsSeriesType(x)) fail = true;
                if (x.Type() == EVariableType.Series) seriesCounter++;
            }
        }

        
        private static bool IsSeriesType(IVariable iv)
        {
            //if (iv == null) return false;
            bool b = true;
            if (iv.Type() != EVariableType.Series && iv.Type() != EVariableType.Val)
            {
                b = false;
            }            
            return b;
        }

        public static void OPrint(O.Prt o, List<string> labelsHandmade, List<string> labelOriginal)
        {
            //Note: it is ok for a prtElement in o to be a List containg Series

            //string format = "f14.4";
            //TODO: we could check if there is 1 object printed and it is of type=normal. If so, the label could be printed.
            //  if .meta is augmented with a pointer to the array-series, the label for x[a] could be taken via that pointer.
            
            EPrintTypes type = GetPrintType(o);

            if (IsGmulprt(o, type))
            {

                for (int i = 0; i < o.prtElements.Count; i++)
                {
                    o.prtElements[i].operatorsFinal = new List<string> { "n", "p", "rn", "rp", "m", "q" };
                }
            }

            bool rows = false; if (G.Equal(o.opt_rows, "yes")) rows = true;

            List<O.Prt.Element> containerExplode = new List<O.Prt.Element>();

            //If PRT <m> unfold(#m, {#m}), we will get 1 prtElement (since there are no commas), where 
            //variable[0] and [1] are both lists with two items (if #m has two items).

            //If PRT unfold(#m, {#m}), we will get 1 prtElement (since there are no commas), where 
            //variable[0] is a list with two items (if #m has two items).
            //this must be exploded into <n p>, so from the 1 prtElement, we should take
            //variable[0][0] as n, variable[0][0] as p, variable[0][1] as n, variable[0][1] as p.

            int labelMaxLine = 1;

            //========================================================================================================
            //                          FREQUENCY LOCATION, indicates where to implement more frequencies
            //========================================================================================================
            bool[] freqs = new bool[5];  //0=U, 1=A, 2=Q, 3=M, 4=D

            int numberOfGekkoNullVariables = 0;
            int numberOfOtherVariables = 0;

            int k = -1;

            foreach (O.Prt.Element element in o.prtElements) //for each comma in the prt statement
            {
                k++;
                List xx0 = element.variable[0] as List;
                List xx1 = element.variable[1] as List;
                int prtElementCounter = 1;
                if (xx0 != null && xx1 != null)
                {
                    if (xx0.list.Count != xx1.list.Count)
                    {
                        G.Writeln2("*** ERROR: Lists with different number of items");
                        throw new GekkoException();
                    }
                }
                if (xx0 != null) prtElementCounter = xx0.list.Count;
                else if (xx1 != null) prtElementCounter = xx1.list.Count;

                for (int i = 0; i < prtElementCounter; i++)  //this element may be a #-list with 2 timeseries, x1 and x2
                {
                    int iOperator = -1;
                    foreach (string operator2 in element.operatorsFinal)  //this may be two printcodes <n p>
                    {

                        iOperator++;
                        //after this, it should be x1<n>  x1<p>  x2<n>  x2<p>

                        O.Prt.Element explodeElement = new O.Prt.Element();

                        int width = -12345;
                        int dec = -12345;
                        bool isPchType = false;
                        if (IsLevelOperator(operator2))
                        {
                            isPchType = false;
                            width = options.print_fields_nwidth;
                            dec = options.print_fields_ndec;
                        }
                        else
                        {
                            isPchType = true;
                            width = options.print_fields_pwidth;
                            dec = options.print_fields_pdec;
                            if (operator2 == Globals.operator_dl || operator2 == Globals.operator_rdl) dec = dec + 2;
                        }

                        // ---------------------------------------------
                        // --- Width -----------------------------------
                        // ---------------------------------------------
                        if (o.opt_width != -12345) width = (int)o.opt_width;
                        if (isPchType)
                        {
                            //overrides ph.width if given
                            if (o.opt_pwidth != -12345) width = (int)o.opt_pwidth;
                        }
                        else
                        {
                            //overrides ph.width if given
                            if (o.opt_nwidth != -12345) width = (int)o.opt_nwidth;
                        }

                        //element-specific stuff
                        if (element.width != -12345) width = element.width;   //element-specific width overrides!
                        if (isPchType)
                        {
                            //overrides ph.width if given
                            if (element.pwidth != -12345) width = element.pwidth;
                        }
                        else
                        {
                            //overrides ph.width if given
                            if (element.nwidth != -12345) width = element.nwidth;
                        }


                        // ---------------------------------------------
                        // --- Decimals --------------------------------
                        // ---------------------------------------------
                        if (o.opt_dec != -12345) dec = (int)o.opt_dec;
                        if (isPchType)
                        {
                            //overrides ph.dec if given
                            if (o.opt_pdec != -12345) dec = (int)o.opt_pdec;
                        }
                        else
                        {
                            //overrides ph.dec if given
                            if (o.opt_ndec != -12345) dec = (int)o.opt_ndec;
                        }

                        //element-specific stuff
                        if (element.dec != -12345) dec = element.dec;   //element-specific dec overrides!
                        if (isPchType)
                        {
                            //overrides ph.dec if given
                            if (element.pdec != -12345) dec = element.pdec;
                        }
                        else
                        {
                            //overrides ph.dec if given
                            if (element.ndec != -12345) dec = element.ndec;
                        }

                        if (type == EPrintTypes.Plot)
                        {
                            explodeElement.widthFinal = 25;
                            explodeElement.decFinal = 10;
                        }
                        else
                        {
                            explodeElement.widthFinal = width;
                            explodeElement.decFinal = dec;
                        }

                        explodeElement.linetype = element.linetype;
                        explodeElement.dashtype = element.dashtype;
                        explodeElement.linewidth = element.linewidth;
                        explodeElement.linecolor = element.linecolor;
                        explodeElement.pointtype = element.pointtype;
                        explodeElement.pointsize = element.pointsize;
                        explodeElement.fillstyle = element.fillstyle;
                        explodeElement.y2 = element.y2;

                        if (xx0 != null) explodeElement.variable[0] = xx0.list[i];
                        else explodeElement.variable[0] = element.variable[0];
                        if (xx1 != null) explodeElement.variable[1] = xx1.list[i];
                        else explodeElement.variable[1] = element.variable[1];

                        int bankCombi = GetBankCombi(operator2);

                        bool tjek1 = bankCombi == 0 && SkipSubSeries(explodeElement.variable[0]);
                        bool tjek2 = bankCombi == 1 && SkipSubSeries(explodeElement.variable[1]);
                        bool tjek3 = bankCombi == 2 && (SkipSubSeries(explodeElement.variable[0]) || SkipSubSeries(explodeElement.variable[1]));

                        if (tjek1 || tjek2 || tjek3)
                        {
                            numberOfGekkoNullVariables++;
                            continue;
                        }

                        numberOfOtherVariables++;

                        Series temp0 = explodeElement.variable[0] as Series;
                        Series temp1 = explodeElement.variable[1] as Series;

                        //========================================================================================================
                        //                          FREQUENCY LOCATION, indicates where to implement more frequencies
                        //========================================================================================================

                        if (temp0 != null)
                        {
                            if (temp0.freq == EFreq.U) freqs[0] = true;
                            else if (temp0.freq == EFreq.A) freqs[1] = true;
                            else if (temp0.freq == EFreq.Q) freqs[2] = true;
                            else if (temp0.freq == EFreq.M) freqs[3] = true;
                            else if (temp0.freq == EFreq.D) freqs[4] = true;

                        }
                        else if (temp1 != null)
                        {
                            if (temp1.freq == EFreq.U) freqs[0] = true;
                            else if (temp1.freq == EFreq.A) freqs[1] = true;
                            else if (temp1.freq == EFreq.Q) freqs[2] = true;
                            else if (temp1.freq == EFreq.M) freqs[3] = true;
                            else if (temp1.freq == EFreq.D) freqs[4] = true;
                        }

                        if (explodeElement.variable[0] != null && !G.IsValueType(explodeElement.variable[0]) || explodeElement.variable[1] != null && !G.IsValueType(explodeElement.variable[1]))
                        {
                            G.Writeln2("+++ WARNING: Non-value in PRT");
                            return;
                        }

                        explodeElement.operatorFinal = operator2;

                        // ----------------------------------------------------
                        // Labels start
                        // ----------------------------------------------------

                        List<string> lbl = new List<string>();  //count = 0!

                        try
                        {
                            lbl = OPrintLabels(element.labelGiven, element.labelRecordedPieces, prtElementCounter, i);
                        }
                        catch { lbl = new List<string>(); }

                        if (lbl.Count != prtElementCounter)
                        {
                            Mismatch();
                            string l = G.ReplaceGlueNew(RemoveSplitter(labelOriginal[k]).Split('|')[0]);
                            lbl = new List<string>();
                            for (int ii = 0; ii < prtElementCounter; ii++)
                            {
                                lbl.Add(l);
                            }
                        }

                        // ----------------------------------------------------
                        // Labels end
                        // ----------------------------------------------------

                        int lines = -12345;
                        int widthHere = -12345;

                        if (type == EPrintTypes.Plot || type == EPrintTypes.Sheet || rows)
                        {
                            lines = 1;
                            widthHere = int.MaxValue;
                        }
                        else
                        {
                            lines = 5;
                            widthHere = explodeElement.widthFinal;
                        }

                        int max2 = PrintCreateLabelsArrayNew(lbl[i], widthHere, lines, lines * widthHere, out explodeElement.labelOLD);

                        labelMaxLine = Math.Max(max2, labelMaxLine);

                        //FIXME
                        //FIXME

                        string ee = null;
                        IVariable iv = element.variable[0];
                        if (iv != null && iv as Series != null)
                        {
                            Series ts = iv as Series;
                            if (ts.type == ESeriesType.Normal)
                            {
                                string name = ts.GetName();
                                if (name != null)
                                {
                                    string n2 = G.Chop_RemoveFreq(name);
                                    if (G.IsSimpleToken(n2))
                                    {
                                        EEndoOrExo endoExo = VariableTypeEndoExo(n2);
                                        if (endoExo == EEndoOrExo.Endo) ee = "(E)";
                                        else if (endoExo == EEndoOrExo.Exo) ee = "(X)";
                                    }
                                }
                            }
                        }

                        if (G.Equal(element.operatorsFinal[0], "n") && iOperator > 0 && G.Equal(operator2, "p"))
                        {                            
                            explodeElement.labelOLD = new List<string> { ee + "%" };
                        }
                        else if (G.Equal(element.operatorsFinal[0], "m") && iOperator > 0 && G.Equal(operator2, "q"))
                        {
                            explodeElement.labelOLD = new List<string> { ee + "%" };
                        }
                        else
                        {
                            if (iOperator == 0) ; //c.label = c.label + "  (" + printCode.ToLower() + ")";
                            else if (iOperator > 0) explodeElement.labelOLD = new List<string> { "<" + operator2.ToLower() + ">" };
                        }

                        containerExplode.Add(explodeElement);
                    }
                }
            }

            int n = containerExplode.Count;  //number of printed variables (including percent etc.), think of it as number of "columns"

            GekkoSmpl smpl = new GekkoSmpl(o.t1, o.t2);
            List inputList = null;
            List<IVariable> errorList = new List<IVariable>();

            bool good = true;

            //========================================================================================================
            //                          FREQUENCY LOCATION, indicates where to implement more frequencies
            //========================================================================================================
            // ----------------------- start -------------------------------------------------
            if (freqs[0] && (freqs[1] || freqs[2] || freqs[3] || freqs[4]))
            {
                G.Writeln2("*** ERROR: You cannot mix undated and other frequencies for PRT/PLOT");
                throw new GekkoException();
            }

            EFreq sameFreq = EFreq.None;
            if (freqs[0] && !freqs[1] && !freqs[2] && !freqs[3] && !freqs[4]) sameFreq = EFreq.U;
            else if (!freqs[0] && freqs[1] && !freqs[2] && !freqs[3] && !freqs[4]) sameFreq = EFreq.A;
            else if (!freqs[0] && !freqs[1] && freqs[2] && !freqs[3] && !freqs[4]) sameFreq = EFreq.Q;
            else if (!freqs[0] && !freqs[1] && !freqs[2] && freqs[3] && !freqs[4]) sameFreq = EFreq.M;
            else if (!freqs[0] && !freqs[1] && !freqs[2] && !freqs[3] && freqs[4]) sameFreq = EFreq.D;
            else sameFreq = EFreq.None;  //superflous, just to state the obvious

            if (!freqs[0] && !freqs[1] && !freqs[2] && !freqs[3] && !freqs[4])
            {
                //for instance printing a scalar
                sameFreq = Program.options.freq;
                if (Program.options.freq == EFreq.U) freqs[0] = true;
                else if (Program.options.freq == EFreq.A) freqs[1] = true;
                else if (Program.options.freq == EFreq.Q) freqs[2] = true;
                else if (Program.options.freq == EFreq.M) freqs[3] = true;
                else if (Program.options.freq == EFreq.D) freqs[4] = true;
            }

            // --------------------------- end ---------------------------------------------


            int y1 = smpl.t1.super;
            int y2 = smpl.t2.super;

            if (numberOfOtherVariables == 0 && numberOfGekkoNullVariables > 0)
            {
                G.Writeln2("+++ WARNING: Non-existing array-series (skipped)");
                return;
            }

            //TIMEFILTER!!!!!!! with avg

            //timefilter removes items hitted. If avg/sum timefilter, track the omitted and print them instead of non-hitted
                        
            if (type == EPrintTypes.Plot)
            {
                if (n > Program.options.plot_elements_max)
                {
                    if (!G.Equal(o.opt_nomax, "yes"))
                    {
                        G.Writeln2("*** ERROR: PLOT had " + n + " elements, max is " + Program.options.plot_elements_max);
                        G.Writeln("           You can use PLOT<nomax> or set OPTION plot elements max = ... ;", Color.Red);
                        throw new GekkoException();
                    }
                }
            }
            else if (type == EPrintTypes.Print)
            {
                if (n > Program.options.print_elements_max)
                {
                    if (!G.Equal(o.opt_nomax, "yes"))
                    {
                        G.Writeln2("*** ERROR: PRINT had " + n + " elements, max is " + Program.options.print_elements_max);
                        G.Writeln("           You can use PRT<nomax> or set OPTION print elements max = ... ;", Color.Red);
                        throw new GekkoException();
                    }
                }
            }

            //========================================================================================================
            //                          FREQUENCY LOCATION, indicates where to implement more frequencies
            //========================================================================================================            
            // there is a lot of frequency stuff going on in the following printing
            //--------------------------------------------------------------------------------------------------------

            

            bool showAllFreqsEachYear = true;
            if (type == EPrintTypes.Sheet) showAllFreqsEachYear = false;  //SHEET <2010q2 2010q3> should not show q1 and q3

            bool pretty = false;
            if (type == EPrintTypes.Sheet && G.Equal(Program.options.sheet_freq, "pretty")) pretty = true;
            if (type == EPrintTypes.Print && G.Equal(Program.options.print_freq, "pretty")) pretty = true;


            EPrtCollapseTypes collapse = GetCollapseType(o, type);
            if (pretty == false) collapse = EPrtCollapseTypes.None;  //switched off for non-pretty

            bool showRowWithYear = pretty || (sameFreq == EFreq.U || sameFreq == EFreq.A);

            EPrtPlotSheet tabletype = EPrtPlotSheet.Unknown;
            if (type == EPrintTypes.Plot) tabletype = EPrtPlotSheet.Plot;
            else
            {
                if (freqs[4]) tabletype = EPrtPlotSheet.PrintMixedMDPretty;
            }

            int iPlot = 0;

            EFreq highestFreq = EFreq.A;
            if (freqs[0]) highestFreq = EFreq.U;
            if (freqs[1]) highestFreq = EFreq.A;
            if (freqs[2]) highestFreq = EFreq.Q;
            if (freqs[3]) highestFreq = EFreq.M;
            if (freqs[4]) highestFreq = EFreq.D;

            Table table = null;
            PlotTable plotTable = null; //more lightweight than Table

            if (tabletype == EPrtPlotSheet.Plot)
            {
                plotTable = PlotMixed(smpl, type, containerExplode, n, o, highestFreq);
            }
            else if (freqs[4])  //daily freq, will also accept d + m freq at same time
            {
                table = PrintMixedMD(smpl, type, rows, containerExplode, labelMaxLine, n, pretty, freqs, o);
            }
            else
            {
                table = PrintMixedAQM(smpl, type, rows, containerExplode, labelMaxLine, freqs, n, sameFreq, y1, y2, pretty, collapse, showRowWithYear, iPlot, o);
            }
            
            //bool filter = ShouldFilterPeriod(new GekkoTime());

            if (type == EPrintTypes.Plot)
            {
                //G.Writeln("Calling gnuplot1");
                CallGnuplot(plotTable, o, containerExplode, highestFreq);
            }
            else if (type == EPrintTypes.Sheet)
            {
                bool isStamp = false; if (o != null && G.Equal(o.opt_stamp, "yes")) isStamp = true;
                string title = o.opt_title;                
                
                Table tab2 = table.Transpose();

                if (Globals.excelDna)
                {
                    Program.PrtToExcelDna(tab2, IsMulprt(o), isStamp, title);
                }
                else
                {
                    ExcelOptions eo = PrepareDataForExcel(tab2);
                    CreateExcelWorkbook2(eo, o, IsMulprt(o), false, o.opt_dateformat, o.opt_datetype);
                }
                return;
            }
            else if (type == EPrintTypes.Clip)
            {
                //do not print anything, but put it on clipboard             
                Table tab2 = table.Transpose();
                Program.PrtClipboard(tab2, false);
            }
            else  //is .Print type
            {
                if (rows) table = table.Transpose();

                if (Globals.excelDna)
                {                    
                    Program.PrtToExcelDna(table, false, false, null); //isMulprt only relevant if there is a stamp, just set false here
                }
                else
                {

                    int widthRemember = Program.options.print_width;
                    int fileWidthRemember = Program.options.print_filewidth;
                    Program.options.print_width = int.MaxValue;
                    Program.options.print_filewidth = int.MaxValue;
                    try
                    {
                        G.Writeln("");
                        List<string> ss = table.Print();
                        foreach (string s in ss) G.Writeln(s);
                    }
                    finally
                    {
                        //resetting, also if there is an error
                        Program.options.print_width = widthRemember;
                        Program.options.print_filewidth = fileWidthRemember;
                    }
                    Globals.lastPrtOrMulprtTable = table;  //if CLIP x, y, z, this Globals.lastPrtOrMulprtTable is used later on
                    CrossThreadStuff.CopyButtonEnabled(true);
                }
            }
        }

        private static ExcelOptions PrepareDataForExcel(Table tab2)
        {
            int startRows = 1;
            int startCols = 1;
            ExcelOptions eo = new ExcelOptions();
            eo.excelRowLabels = new string[tab2.GetRowMaxNumber() - startRows, 1];
            eo.excelColumnLabels = new string[1, tab2.GetColMaxNumber() - startCols];
            eo.excelColumnLabelsGekkoTime = new GekkoTime[1, tab2.GetColMaxNumber() - startCols];
            eo.excelData = G.CreateArrayDouble(tab2.GetRowMaxNumber() - startRows, tab2.GetColMaxNumber() - startCols, double.NaN);

            for (int i = 1; i <= tab2.GetRowMaxNumber(); i++)
            {
                for (int j = 1; j <= tab2.GetColMaxNumber(); j++)
                {
                    Cell cell2 = tab2.Get(i, j);
                    string s2 = "";
                    if (cell2 == null)
                    {
                    }
                    else
                    {
                        if (i == 1 && j == 1)
                        {
                            //do nothing
                        }
                        else if (j == 1)
                        {
                            //first row
                            string s = cell2.CellText.TextData[0];
                            if (s == null) s = "";
                            eo.excelRowLabels[i - 1 - startRows, j - 1] = s;
                        }
                        else if (i == 1)
                        {
                            string s = cell2.CellText.TextData[0];
                            if (s == null) s = "";
                            eo.excelColumnLabels[i - 1, j - 1 - startCols] = s;
                            eo.excelColumnLabelsGekkoTime[i - 1, j - 1 - startCols] = cell2.date_hack; //a hack, the cell ought to be date format
                        }
                        else
                        {
                            eo.excelData[i - startRows - 1, j - startCols - 1] = cell2.number;
                            s2 = cell2.date;
                        }
                    }
                }
            }

            return eo;
        }

        private static PlotTable PlotMixed(GekkoSmpl smpl, EPrintTypes type, List<O.Prt.Element> containerExplode, int n, O.Prt o, EFreq highestFreq)
        {            
            PlotTable plotTable = new PlotTable();
            plotTable.dates = new List<List<double>>();
            plotTable.values = new List<List<double>>();
            for (int j = 0; j < n; j++)
            {
                plotTable.dates.Add(new List<double>());
                plotTable.values.Add(new List<double>());
            }

            for (int j = 2; j < n + 2; j++)  //cols/variables starts at j=2. So for 3 variables we have 2, 3, 4.
            {
                int[] skipCounter = new int[4];
                
                O.Prt.Element cc;
                string operator2, format;
                List<string> label;
                EFreq freqColumn;
                double scalarValueWork, scalarValueRef;
                Series tsWork, tsRef;
                PrintPrepareColumn(type, containerExplode, j, out cc, out operator2, out label, out format, out freqColumn, out scalarValueWork, out tsWork, out scalarValueRef, out tsRef);

                bool isScalar = tsWork == null && tsRef == null;

                EFreq freqHere = highestFreq;
                if (isScalar)
                {
                    //will become highestFreq
                }
                else
                {
                    if (tsWork != null) freqHere = tsWork.freq;
                    else if (tsRef != null) freqHere = tsRef.freq;
                }

                int i = 0;
                foreach (GekkoTime t in new GekkoTimeIterator(ConvertFreqs(smpl.t1, smpl.t2, freqHere)))  //handles if the freq given is different from the series freq
                {

                    int sumOver = 0;  //what does this boolean do??
                    double d = double.NaN;
                    if (isScalar)  //not series
                    {                        
                        d = PrintHelperTransformScalar(scalarValueWork, scalarValueRef, operator2, o.guiGraphIsLogTransform, sumOver, skipCounter);
                    }
                    else
                    {
                        d = PrintHelperTransform(smpl, tsWork, tsRef, t, operator2, o.guiGraphIsLogTransform, sumOver, skipCounter);
                    }
                    i++;
                    double tt = ((ScalarVal)Functions.helper_time(t)).val;
                    if (freqHere == EFreq.A) tt += 0.5d;  //annual years should be 2020.5 to be centered correctly

                    //The columns (variables) are counted with j=1 for date column, and variables following for j=2, j=3, ...
                    //We skip the j=1 column, so the following logic applies, if there are n variables
                    //j=1 --> skip
                    //j=2 --> 1 and 1+n
                    //j=3 --> 2 and 2+n

                    plotTable.dates[j - 2].Add(tt);
                    plotTable.values[j - 2].Add(d);
                    
                }
            }

            


            return plotTable;
        }

        private static Table PrintMixedMD(GekkoSmpl smpl, EPrintTypes type, bool rows, List<O.Prt.Element> containerExplode, int labelMaxLine, int n, bool pretty, bool[] freqs, O.Prt o)
        {
            Table table = new Table();
            table.writeOnce = true;

            if (freqs[0] || freqs[1] || freqs[2])
            {
                G.Writeln2("*** ERROR: You cannot mix Daily and Annual/Quarterly/Undated frequencies for PRT/PLOT");
                throw new GekkoException();
            }

            for (int j = 1; j < n + 2; j++)
            {
                int[] skipCounter = new int[4];
                
                O.Prt.Element cc;
                string operator2, format;
                List<string> label;
                EFreq freqColumn;
                double scalarValueWork, scalarValueRef;
                Series tsWork, tsRef;
                PrintPrepareColumn(type, containerExplode, j, out cc, out operator2, out label, out format, out freqColumn, out scalarValueWork, out tsWork, out scalarValueRef, out tsRef);

                int i = 0;

                //              x!d      x!m
                // 2019m1                100
                //     d1        22
                //     d2        23
                //     d3        42
                //    ...
                // 2019m2
                //     d1        43
                //     d2        23
                //     d3        44
                //    ...

                bool isMonthlyFreq = false;
                if (tsWork != null && tsWork.freq == EFreq.M || tsRef != null && tsWork.freq == EFreq.M)
                {
                    isMonthlyFreq = true;
                }

                i++;
                i = PutLabelIntoTable(table, i, j, label, labelMaxLine);  //augments i
                i--; //else a blank line too much at start                    

                if (pretty)  //pretty printing (sheet is non-pretty)
                {
                    foreach (GekkoTime t in new GekkoTimeIterator(ConvertFreqs(smpl.t1, smpl.t2, EFreq.D)))  //handles if the freq given is not daily
                    {
                        //TODO: allow prt x!d, x!m, but not other freqs.

                        if (t.Equals(smpl.t1) || t.subsub == 1)
                        {
                            if (j == 1)
                            {
                                i++;
                                i++;
                                table.Set(i, j, t.super + "m" + t.sub); if (rows) table.SetAlign(i, j, Align.Right);
                            }
                            else
                            {
                                i++;
                                i++;
                                if (t.subsub == 1 && isMonthlyFreq)
                                {
                                    int sumOver = 0;
                                    GekkoTime tMonth = new GekkoTime(EFreq.M, t.super, t.sub);
                                    double d = PrintHelperTransform(smpl, tsWork, tsRef, tMonth, operator2, o.guiGraphIsLogTransform, sumOver, skipCounter);
                                    table.SetNumber(i, j, d, format);
                                }
                            }
                        }

                        i++;

                        if (j == 1)
                        {
                            table.Set(i, j, "d" + t.subsub); if (rows) table.SetAlign(i, j, Align.Right);
                        }
                        else
                        {
                            //j > 1

                            if (!isMonthlyFreq)
                            {
                                int sumOver = 0;
                                double d = double.NaN;
                                if (tsWork == null && tsRef == null)  //not series
                                {
                                    d = PrintHelperTransformScalar(scalarValueWork, scalarValueRef, operator2, o.guiGraphIsLogTransform, sumOver, skipCounter);
                                }
                                else
                                {
                                    d = PrintHelperTransform(smpl, tsWork, tsRef, t, operator2, o.guiGraphIsLogTransform, sumOver, skipCounter);
                                }

                                table.SetNumber(i, j, d, format);
                            }
                        }
                    }
                }
                else
                {
                    //sheet or non-pretty printing
                    if (isMonthlyFreq)
                    {
                        G.Writeln2("*** ERROR: Cannot use D and M freq at the same time");
                        throw new GekkoException();
                    }
                    i++;
                    foreach (GekkoTime t in new GekkoTimeIterator(ConvertFreqs(smpl.t1, smpl.t2, EFreq.D)))  //handles if the freq given is not daily
                    {
                        //TODO: allow prt x!d, x!m, but not other freqs.

                        i++;

                        if (j == 1)
                        {
                            table.Set(i, j, t.ToString()); if (rows) table.SetAlign(i, j, Align.Right);
                            table.Get(i, j).date_hack = t;
                        }
                        else
                        {
                            int sumOver = 0;
                            double d = double.NaN;
                            if (tsWork == null && tsRef == null)  //not series
                            {
                                d = PrintHelperTransformScalar(scalarValueWork, scalarValueRef, operator2, o.guiGraphIsLogTransform, sumOver, skipCounter);
                            }
                            else
                            {
                                d = PrintHelperTransform(smpl, tsWork, tsRef, t, operator2, o.guiGraphIsLogTransform, sumOver, skipCounter);
                            }
                            table.SetNumber(i, j, d, format);
                        }
                    }
                }
            }
            return table;
        }

        private static Table PrintMixedAQM(GekkoSmpl smpl, EPrintTypes type, bool rows, List<O.Prt.Element> containerExplode, int labelMaxLine, bool[] freqs, int n, EFreq sameFreq, int y1, int y2, bool pretty, EPrtCollapseTypes collapse, bool showRowWithYear, int iPlot, O.Prt o)
        {
            Table table = new Table();
            table.writeOnce = true;

            AllFreqsHelper allFreqsDates = G.ConvertDateFreqsToAllFreqs(smpl.t1, smpl.t2);

            for (int j = 1; j < n + 2; j++)
            {
                int[] skipCounter = new int[4];
                
                O.Prt.Element cc;
                string operator2, format;
                List<string> label;
                EFreq freqColumn;
                double scalarValueWork, scalarValueRef;
                Series tsWork, tsRef;
                PrintPrepareColumn(type, containerExplode, j, out cc, out operator2, out label, out format, out freqColumn, out scalarValueWork, out tsWork, out scalarValueRef, out tsRef);

                int i = 0;

                // 1. 2003 (label)       
                // 2. 2003q1            Q         
                // 3. 2003m1                 M
                // 4. 2003m2                 M      
                // 5. 2003m3                 M
                // 6. SUM3M                  Msum (only when 3 M above else empty)
                // 7. 2003q2            Q           
                // 8. 2003m4                 M
                // 9. 2003m5                 M
                //10. 2003m6                 M
                //11. SUM3M                  Msum           
                //12. 2003q3            Q
                //13. 2003m7                 M
                //14. 2003m8                 M                 <--------- if timefilter is 2003m2..2003m7, we consolidate in 2003m8:  "2003m2-2003m8    123.45"
                //15. 2003m9                 M                            Msum is only shown if not touched by timefilter
                //16. SUM3M                  Msum           
                //17. 2003q4            Q          
                //18. 2003m10                M
                //19. 2003m11                M
                //20. 2003m12                M
                //21. SUM3M                  Msum
                //22. SUM12M                 Msum                                 
                //23. SUM4Q             Qsum           
                //24. ANNUAL     A


                //remember there is a label column which gets number 1
                for (int year = y1; year <= y2; year++)
                {
                    string uglyYear = null; if (!pretty) uglyYear = year.ToString();

                    if (type != EPrintTypes.Plot) // ------------------------------------------------------------- (1)
                    {

                        if (pretty || year == y1 || (sameFreq == EFreq.U || sameFreq == EFreq.A))
                        {
                            i++;
                        }
                        if (year == y1)
                        {
                            i = PutLabelIntoTable(table, i, j, label, labelMaxLine);  //will add to i
                        }
                        if (showRowWithYear)
                        {

                            i++;

                            //Non-plots have a first column with dates, plots have such a column for each series
                            //if (j == 1)  //then iv == null
                            {
                                // --------------------------                                
                                // --------------------------
                                if ((sameFreq == EFreq.U || sameFreq == EFreq.A) && Globals.globalPeriodTimeFilters2.Count > 0 && ((Globals.globalPeriodTimeFilters2[0].freq == EFreq.U && Program.ShouldFilterPeriod(new Gekko.GekkoTime(EFreq.U, year, 1))) || (Globals.globalPeriodTimeFilters2[0].freq == EFreq.A && Program.ShouldFilterPeriod(new Gekko.GekkoTime(EFreq.A, year, 1)))))
                                {
                                    //kind of hack for annual to omit year if the year is filtered out
                                    i--;
                                }
                                else
                                {
                                    if (j == 1)
                                    {
                                        table.Set(i, j, year.ToString()); if (rows) table.SetAlign(i, j, Align.Right);
                                        DateHack(table, i, j, sameFreq, year, 1);
                                    }
                                }
                            }

                            if (sameFreq == EFreq.U || sameFreq == EFreq.A) i--; // #98075235874325
                        }
                    }

                    if (true)  // ------------------------------------------------------------- (2)
                    {
                        if ((type != EPrintTypes.Plot && freqs[3]) || (type == EPrintTypes.Plot && freqColumn == EFreq.M))
                        {
                            // --------------------------
                            EFreq freqHere = EFreq.M;
                            int subHere = 1;                            
                            int sumOver = 1;
                            if (PrintShouldKeep(allFreqsDates, freqHere, year, subHere))
                            {
                                i++;
                                // --------------------------
                                if (j == 1)
                                {
                                    table.Set(i, j, uglyYear + "m1"); if (rows) table.SetAlign(i, j, Align.Right);
                                    DateHack(table, i, j, freqHere, year, subHere);
                                }
                                else
                                {
                                    PrintHelper3(smpl, type, sameFreq, table, n, i, j, iPlot, operator2, o.guiGraphIsLogTransform, scalarValueWork, tsWork, scalarValueRef, tsRef, year, freqHere, subHere, sumOver, skipCounter, cc);
                                }
                            }
                        }
                    }
                    if (true)  // ------------------------------------------------------------- (3)
                    {
                        if ((type != EPrintTypes.Plot && freqs[3]) || (type == EPrintTypes.Plot && freqColumn == EFreq.M))
                        {
                            // --------------------------
                            EFreq freqHere = EFreq.M;
                            int subHere = 2;                            
                            int sumOver = 1;
                            if (PrintShouldKeep(allFreqsDates, freqHere, year, subHere))
                            {
                                // --------------------------
                                i++;
                                if (j == 1)
                                {
                                    table.Set(i, j, uglyYear + "m2"); if (rows) table.SetAlign(i, j, Align.Right);
                                    DateHack(table, i, j, freqHere, year, subHere);
                                }
                                else
                                {
                                    PrintHelper3(smpl, type, sameFreq, table, n, i, j, iPlot, operator2, o.guiGraphIsLogTransform, scalarValueWork, tsWork, scalarValueRef, tsRef, year, freqHere, subHere, sumOver, skipCounter, cc);
                                }
                            }
                        }
                    }
                    if (true)  // ------------------------------------------------------------- (4)
                    {
                        if ((type != EPrintTypes.Plot && freqs[3]) || (type == EPrintTypes.Plot && freqColumn == EFreq.M))
                        {
                            // --------------------------
                            EFreq freqHere = EFreq.M;
                            int subHere = 3;                            
                            int sumOver = 1;
                            // --------------------------
                            if (PrintShouldKeep(allFreqsDates, freqHere, year, subHere))
                            {
                                i++;
                                if (j == 1)
                                {
                                    table.Set(i, j, uglyYear + "m3"); if (rows) table.SetAlign(i, j, Align.Right);
                                    DateHack(table, i, j, freqHere, year, subHere);
                                }
                                else
                                {

                                    PrintHelper3(smpl, type, sameFreq, table, n, i, j, iPlot, operator2, o.guiGraphIsLogTransform, scalarValueWork, tsWork, scalarValueRef, tsRef, year, freqHere, subHere, sumOver, skipCounter, cc);
                                }
                            }
                        }
                    }

                    if (collapse != EPrtCollapseTypes.None)  // ------------------------------------------------------------- (5)
                    {
                        if ((type != EPrintTypes.Plot && freqs[3]))
                        {
                            // --------------------------
                            EFreq freqHere = EFreq.M;
                            int subHere = 3;                            
                            int sumOver = 3;
                            // --------------------------
                            if (PrintShouldKeep(allFreqsDates, freqHere, year, subHere))
                            {
                                i++;
                                bool skip = false;
                                GekkoTime t = new GekkoTime(freqHere, year, subHere);
                                foreach (GekkoTime tFilter in Globals.globalPeriodTimeFilters2)
                                {
                                    if (t.freq == tFilter.freq && t.Equals(tFilter))
                                    {
                                        skip = true;
                                        break;
                                    }
                                }

                                if (!skip)
                                {
                                    if (j == 1)
                                    {
                                        table.Set(i, j, uglyYear + "mSUM"); if (rows) table.SetAlign(i, j, Align.Right);
                                        //no date hack
                                    }
                                    else
                                    {
                                        PrintHelper3(smpl, type, sameFreq, table, n, i, j, iPlot, operator2, o.guiGraphIsLogTransform, scalarValueWork, tsWork, scalarValueRef, tsRef, year, freqHere, subHere, sumOver, skipCounter, cc);
                                    }
                                }
                            }
                        }
                    }
                    if (true)  // ------------------------------------------------------------- (6)
                    {
                        if ((type != EPrintTypes.Plot && freqs[2]) || (type == EPrintTypes.Plot && freqColumn == EFreq.Q))
                        {
                            // --------------------------
                            EFreq freqHere = EFreq.Q;
                            int subHere = 1;                            
                            int sumOver = 1;
                            // --------------------------

                            if (PrintShouldKeep(allFreqsDates, freqHere, year, subHere))
                            {
                                i++;
                                if (j == 1)
                                {
                                    table.Set(i, j, uglyYear + "q1"); if (rows) table.SetAlign(i, j, Align.Right);
                                    DateHack(table, i, j, freqHere, year, subHere);
                                }
                                else
                                {
                                    PrintHelper3(smpl, type, sameFreq, table, n, i, j, iPlot, operator2, o.guiGraphIsLogTransform, scalarValueWork, tsWork, scalarValueRef, tsRef, year, freqHere, subHere, sumOver, skipCounter, cc);
                                }
                            }
                        }
                    }









                    if (true)  // ------------------------------------------------------------- (7)
                    {
                        if ((type != EPrintTypes.Plot && freqs[3]) || (type == EPrintTypes.Plot && freqColumn == EFreq.M))
                        {
                            // --------------------------
                            EFreq freqHere = EFreq.M;
                            int subHere = 4;                            
                            int sumOver = 1;
                            // --------------------------
                            if (PrintShouldKeep(allFreqsDates, freqHere, year, subHere))
                            {
                                i++;
                                if (j == 1)
                                {
                                    table.Set(i, j, uglyYear + "m4"); if (rows) table.SetAlign(i, j, Align.Right);
                                    DateHack(table, i, j, freqHere, year, subHere);
                                }
                                else
                                {
                                    PrintHelper3(smpl, type, sameFreq, table, n, i, j, iPlot, operator2, o.guiGraphIsLogTransform, scalarValueWork, tsWork, scalarValueRef, tsRef, year, freqHere, subHere, sumOver, skipCounter, cc);
                                }
                            }
                        }
                    }
                    if (true)  // ------------------------------------------------------------- (8)
                    {
                        if ((type != EPrintTypes.Plot && freqs[3]) || (type == EPrintTypes.Plot && freqColumn == EFreq.M))
                        {
                            // --------------------------
                            EFreq freqHere = EFreq.M;
                            int subHere = 5;                            
                            int sumOver = 1;
                            // --------------------------

                            if (PrintShouldKeep(allFreqsDates, freqHere, year, subHere))
                            {
                                i++;
                                if (j == 1)
                                {
                                    table.Set(i, j, uglyYear + "m5"); if (rows) table.SetAlign(i, j, Align.Right);
                                    DateHack(table, i, j, freqHere, year, subHere);
                                }
                                else
                                {

                                    PrintHelper3(smpl, type, sameFreq, table, n, i, j, iPlot, operator2, o.guiGraphIsLogTransform, scalarValueWork, tsWork, scalarValueRef, tsRef, year, freqHere, subHere, sumOver, skipCounter, cc);
                                }
                            }
                        }
                    }
                    if (true)  // ------------------------------------------------------------- (9)
                    {
                        if ((type != EPrintTypes.Plot && freqs[3]) || (type == EPrintTypes.Plot && freqColumn == EFreq.M))
                        {
                            // --------------------------
                            EFreq freqHere = EFreq.M;
                            int subHere = 6;                            
                            int sumOver = 1;
                            // --------------------------

                            if (PrintShouldKeep(allFreqsDates, freqHere, year, subHere))
                            {
                                i++;
                                if (j == 1)
                                {
                                    table.Set(i, j, uglyYear + "m6"); if (rows) table.SetAlign(i, j, Align.Right);
                                    DateHack(table, i, j, freqHere, year, subHere);
                                }
                                else
                                {

                                    PrintHelper3(smpl, type, sameFreq, table, n, i, j, iPlot, operator2, o.guiGraphIsLogTransform, scalarValueWork, tsWork, scalarValueRef, tsRef, year, freqHere, subHere, sumOver, skipCounter, cc);
                                }
                            }
                        }
                    }

                    if (collapse != EPrtCollapseTypes.None)  // ------------------------------------------------------------- (10)
                    {
                        if ((type != EPrintTypes.Plot && freqs[3]))
                        {
                            // --------------------------
                            EFreq freqHere = EFreq.M;
                            int subHere = 6;                            
                            int sumOver = 3;
                            // --------------------------
                            if (PrintShouldKeep(allFreqsDates, freqHere, year, subHere))
                            {
                                i++;
                                bool skip = false;
                                GekkoTime t = new GekkoTime(freqHere, year, subHere);
                                foreach (GekkoTime tFilter in Globals.globalPeriodTimeFilters2)
                                {
                                    if (t.freq == tFilter.freq && t.Equals(tFilter))
                                    {
                                        skip = true;
                                        break;
                                    }
                                }

                                if (!skip)
                                {
                                    if (j == 1)
                                    {
                                        table.Set(i, j, uglyYear + "mSUM"); if (rows) table.SetAlign(i, j, Align.Right);
                                        //no date hack
                                    }
                                    else
                                    {
                                        PrintHelper3(smpl, type, sameFreq, table, n, i, j, iPlot, operator2, o.guiGraphIsLogTransform, scalarValueWork, tsWork, scalarValueRef, tsRef, year, freqHere, subHere, sumOver, skipCounter, cc);
                                    }
                                }
                            }
                        }
                    }
                    if (true)  // ------------------------------------------------------------- (11)
                    {
                        if ((type != EPrintTypes.Plot && freqs[2]) || (type == EPrintTypes.Plot && freqColumn == EFreq.Q))
                        {
                            // --------------------------
                            EFreq freqHere = EFreq.Q;
                            int subHere = 2;                            
                            int sumOver = 1;
                            // --------------------------

                            if (PrintShouldKeep(allFreqsDates, freqHere, year, subHere))
                            {
                                i++;
                                if (j == 1)
                                {
                                    table.Set(i, j, uglyYear + "q2"); if (rows) table.SetAlign(i, j, Align.Right);
                                    DateHack(table, i, j, freqHere, year, subHere);
                                }
                                else
                                {
                                    PrintHelper3(smpl, type, sameFreq, table, n, i, j, iPlot, operator2, o.guiGraphIsLogTransform, scalarValueWork, tsWork, scalarValueRef, tsRef, year, freqHere, subHere, sumOver, skipCounter, cc);
                                }
                            }
                        }
                    }























                    if (true)  // ------------------------------------------------------------- (12)
                    {
                        if ((type != EPrintTypes.Plot && freqs[3]) || (type == EPrintTypes.Plot && freqColumn == EFreq.M))
                        {
                            // --------------------------
                            EFreq freqHere = EFreq.M;
                            int subHere = 7;                            
                            int sumOver = 1;
                            // --------------------------

                            if (PrintShouldKeep(allFreqsDates, freqHere, year, subHere))
                            {
                                i++;
                                if (j == 1)
                                {
                                    table.Set(i, j, uglyYear + "m7"); if (rows) table.SetAlign(i, j, Align.Right);
                                    DateHack(table, i, j, freqHere, year, subHere);
                                }
                                else
                                {

                                    PrintHelper3(smpl, type, sameFreq, table, n, i, j, iPlot, operator2, o.guiGraphIsLogTransform, scalarValueWork, tsWork, scalarValueRef, tsRef, year, freqHere, subHere, sumOver, skipCounter, cc);
                                }
                            }
                        }
                    }
                    if (true)  // ------------------------------------------------------------- (13)
                    {
                        if ((type != EPrintTypes.Plot && freqs[3]) || (type == EPrintTypes.Plot && freqColumn == EFreq.M))
                        {
                            // --------------------------
                            EFreq freqHere = EFreq.M;
                            int subHere = 8;                            
                            int sumOver = 1;
                            // --------------------------

                            if (PrintShouldKeep(allFreqsDates, freqHere, year, subHere))
                            {
                                i++;
                                if (j == 1)
                                {
                                    table.Set(i, j, uglyYear + "m8"); if (rows) table.SetAlign(i, j, Align.Right);
                                    DateHack(table, i, j, freqHere, year, subHere);
                                }
                                else
                                {

                                    PrintHelper3(smpl, type, sameFreq, table, n, i, j, iPlot, operator2, o.guiGraphIsLogTransform, scalarValueWork, tsWork, scalarValueRef, tsRef, year, freqHere, subHere, sumOver, skipCounter, cc);
                                }
                            }
                        }
                    }
                    if (true)  // ------------------------------------------------------------- (14)
                    {
                        if ((type != EPrintTypes.Plot && freqs[3]) || (type == EPrintTypes.Plot && freqColumn == EFreq.M))
                        {
                            // --------------------------
                            EFreq freqHere = EFreq.M;
                            int subHere = 9;                            
                            int sumOver = 1;
                            // --------------------------

                            if (PrintShouldKeep(allFreqsDates, freqHere, year, subHere))
                            {
                                i++;
                                if (j == 1)
                                {
                                    table.Set(i, j, uglyYear + "m9"); if (rows) table.SetAlign(i, j, Align.Right);
                                    DateHack(table, i, j, freqHere, year, subHere);
                                }
                                else
                                {

                                    PrintHelper3(smpl, type, sameFreq, table, n, i, j, iPlot, operator2, o.guiGraphIsLogTransform, scalarValueWork, tsWork, scalarValueRef, tsRef, year, freqHere, subHere, sumOver, skipCounter, cc);
                                }
                            }
                        }
                    }

                    if (collapse != EPrtCollapseTypes.None)  // ------------------------------------------------------------- (15)
                    {
                        if ((type != EPrintTypes.Plot && freqs[3]))
                        {
                            // --------------------------
                            EFreq freqHere = EFreq.M;
                            int subHere = 9;                            
                            int sumOver = 3;
                            // --------------------------
                            if (PrintShouldKeep(allFreqsDates, freqHere, year, subHere))
                            {
                                i++;
                                bool skip = false;
                                GekkoTime t = new GekkoTime(freqHere, year, subHere);
                                foreach (GekkoTime tFilter in Globals.globalPeriodTimeFilters2)
                                {
                                    if (t.freq == tFilter.freq && t.Equals(tFilter))
                                    {
                                        skip = true;
                                        break;
                                    }
                                }

                                if (!skip)
                                {
                                    if (j == 1)
                                    {
                                        table.Set(i, j, uglyYear + "mSUM"); if (rows) table.SetAlign(i, j, Align.Right);
                                        //no date hack
                                    }
                                    else
                                    {
                                        PrintHelper3(smpl, type, sameFreq, table, n, i, j, iPlot, operator2, o.guiGraphIsLogTransform, scalarValueWork, tsWork, scalarValueRef, tsRef, year, freqHere, subHere, sumOver, skipCounter, cc);
                                    }
                                }
                            }
                        }
                    }

                    if (true)  // ------------------------------------------------------------- (16)
                    {
                        if ((type != EPrintTypes.Plot && freqs[2]) || (type == EPrintTypes.Plot && freqColumn == EFreq.Q))
                        {
                            // --------------------------
                            EFreq freqHere = EFreq.Q;
                            int subHere = 3;                            
                            int sumOver = 1;
                            // --------------------------

                            if (PrintShouldKeep(allFreqsDates, freqHere, year, subHere))
                            {
                                i++;
                                if (j == 1)
                                {
                                    table.Set(i, j, uglyYear + "q3"); if (rows) table.SetAlign(i, j, Align.Right);
                                    DateHack(table, i, j, freqHere, year, subHere);
                                }
                                else
                                {
                                    PrintHelper3(smpl, type, sameFreq, table, n, i, j, iPlot, operator2, o.guiGraphIsLogTransform, scalarValueWork, tsWork, scalarValueRef, tsRef, year, freqHere, subHere, sumOver, skipCounter, cc);
                                }
                            }
                        }
                    }












                    if (true)  // ------------------------------------------------------------- (17)
                    {
                        if ((type != EPrintTypes.Plot && freqs[3]) || (type == EPrintTypes.Plot && freqColumn == EFreq.M))
                        {
                            // --------------------------
                            EFreq freqHere = EFreq.M;
                            int subHere = 10;                            
                            int sumOver = 1;
                            // --------------------------

                            if (PrintShouldKeep(allFreqsDates, freqHere, year, subHere))
                            {
                                i++;
                                if (j == 1)
                                {
                                    table.Set(i, j, uglyYear + "m10"); if (rows) table.SetAlign(i, j, Align.Right);
                                    DateHack(table, i, j, freqHere, year, subHere);
                                }
                                else
                                {

                                    PrintHelper3(smpl, type, sameFreq, table, n, i, j, iPlot, operator2, o.guiGraphIsLogTransform, scalarValueWork, tsWork, scalarValueRef, tsRef, year, freqHere, subHere, sumOver, skipCounter, cc);
                                }
                            }
                        }
                    }
                    if (true)  // ------------------------------------------------------------- (18)
                    {
                        if ((type != EPrintTypes.Plot && freqs[3]) || (type == EPrintTypes.Plot && freqColumn == EFreq.M))
                        {
                            // --------------------------
                            EFreq freqHere = EFreq.M;
                            int subHere = 11;                            
                            int sumOver = 1;
                            // --------------------------
                            if (PrintShouldKeep(allFreqsDates, freqHere, year, subHere))
                            {
                                i++;
                                if (j == 1)
                                {
                                    table.Set(i, j, uglyYear + "m11"); if (rows) table.SetAlign(i, j, Align.Right);
                                    DateHack(table, i, j, freqHere, year, subHere);
                                }
                                else
                                {

                                    PrintHelper3(smpl, type, sameFreq, table, n, i, j, iPlot, operator2, o.guiGraphIsLogTransform, scalarValueWork, tsWork, scalarValueRef, tsRef, year, freqHere, subHere, sumOver, skipCounter, cc);
                                }
                            }
                        }
                    }
                    if (true)  // ------------------------------------------------------------- (19)
                    {
                        if ((type != EPrintTypes.Plot && freqs[3]) || (type == EPrintTypes.Plot && freqColumn == EFreq.M))
                        {
                            // --------------------------
                            EFreq freqHere = EFreq.M;
                            int subHere = 12;                            
                            int sumOver = 1;
                            // --------------------------

                            if (PrintShouldKeep(allFreqsDates, freqHere, year, subHere))
                            {
                                i++;
                                if (j == 1)
                                {
                                    table.Set(i, j, uglyYear + "m12"); if (rows) table.SetAlign(i, j, Align.Right);
                                    DateHack(table, i, j, freqHere, year, subHere);
                                }
                                else
                                {

                                    PrintHelper3(smpl, type, sameFreq, table, n, i, j, iPlot, operator2, o.guiGraphIsLogTransform, scalarValueWork, tsWork, scalarValueRef, tsRef, year, freqHere, subHere, sumOver, skipCounter, cc);
                                }
                            }
                        }
                    }

                    if (collapse != EPrtCollapseTypes.None)  // ------------------------------------------------------------- (20)
                    {
                        if ((type != EPrintTypes.Plot && freqs[3]))
                        {
                            // --------------------------
                            EFreq freqHere = EFreq.M;
                            int subHere = 12;                            
                            int sumOver = 3;
                            // --------------------------

                            if (PrintShouldKeep(allFreqsDates, freqHere, year, subHere))
                            {
                                i++;
                                bool skip = false;
                                GekkoTime t = new GekkoTime(freqHere, year, subHere);
                                foreach (GekkoTime tFilter in Globals.globalPeriodTimeFilters2)
                                {
                                    if (t.freq == tFilter.freq && t.Equals(tFilter))
                                    {
                                        skip = true;
                                        break;
                                    }
                                }

                                if (!skip)
                                {
                                    if (j == 1)
                                    {
                                        table.Set(i, j, uglyYear + "mSUM"); if (rows) table.SetAlign(i, j, Align.Right);
                                        //no date hack
                                    }
                                    else
                                    {
                                        PrintHelper3(smpl, type, sameFreq, table, n, i, j, iPlot, operator2, o.guiGraphIsLogTransform, scalarValueWork, tsWork, scalarValueRef, tsRef, year, freqHere, subHere, sumOver, skipCounter, cc);
                                    }
                                }
                            }
                        }
                    }


                    if (collapse != EPrtCollapseTypes.None)  // ------------------------------------------------------------- (21)
                    {
                        if ((type != EPrintTypes.Plot && freqs[3]))
                        {
                            // --------------------------
                            EFreq freqHere = EFreq.M;
                            int subHere = 12;                            
                            int sumOver = 12;
                            // --------------------------
                            if (PrintShouldKeep(allFreqsDates, freqHere, year, subHere))
                            {
                                i++;
                                bool skip = false;
                                GekkoTime t = new GekkoTime(freqHere, year, subHere);
                                foreach (GekkoTime tFilter in Globals.globalPeriodTimeFilters2)
                                {
                                    if (t.freq == tFilter.freq && t.Equals(tFilter))
                                    {
                                        skip = true;
                                        break;
                                    }
                                }

                                if (!skip)
                                {
                                    if (j == 1)
                                    {
                                        table.Set(i, j, uglyYear + "mSUM12"); if (rows) table.SetAlign(i, j, Align.Right);
                                        //no date hack
                                    }
                                    else
                                    {
                                        PrintHelper3(smpl, type, sameFreq, table, n, i, j, iPlot, operator2, o.guiGraphIsLogTransform, scalarValueWork, tsWork, scalarValueRef, tsRef, year, freqHere, subHere, sumOver, skipCounter, cc);
                                    }
                                }
                            }
                        }
                    }
                    if (true)  // ------------------------------------------------------------- (22)
                    {
                        if ((type != EPrintTypes.Plot && freqs[2]) || (type == EPrintTypes.Plot && freqColumn == EFreq.Q))
                        {// --------------------------
                            EFreq freqHere = EFreq.Q;
                            int subHere = 4;                            
                            int sumOver = 1;
                            // --------------------------

                            if (PrintShouldKeep(allFreqsDates, freqHere, year, subHere))
                            {
                                i++;
                                if (j == 1)
                                {
                                    table.Set(i, j, uglyYear + "q4"); if (rows) table.SetAlign(i, j, Align.Right);
                                    DateHack(table, i, j, freqHere, year, subHere);
                                }
                                else
                                {
                                    PrintHelper3(smpl, type, sameFreq, table, n, i, j, iPlot, operator2, o.guiGraphIsLogTransform, scalarValueWork, tsWork, scalarValueRef, tsRef, year, freqHere, subHere, sumOver, skipCounter, cc);
                                }
                            }
                        }
                    }


                    if (collapse != EPrtCollapseTypes.None)  // ------------------------------------------------------------- (23)
                    {
                        if ((type != EPrintTypes.Plot && freqs[2]))
                        {
                            // --------------------------
                            EFreq freqHere = EFreq.Q;
                            int subHere = 4;                            
                            int sumOver = 4;
                            // --------------------------
                            if (PrintShouldKeep(allFreqsDates, freqHere, year, subHere))
                            {
                                i++;
                                bool skip = false;
                                GekkoTime t = new GekkoTime(freqHere, year, subHere);
                                foreach (GekkoTime tFilter in Globals.globalPeriodTimeFilters2)
                                {
                                    if (t.freq == tFilter.freq && t.Equals(tFilter))
                                    {
                                        skip = true;
                                        break;
                                    }
                                }

                                if (!skip)
                                {
                                    if (j == 1)
                                    {
                                        table.Set(i, j, uglyYear + "qSUM"); if (rows) table.SetAlign(i, j, Align.Right);
                                        //no date hack
                                    }
                                    else
                                    {
                                        PrintHelper3(smpl, type, sameFreq, table, n, i, j, iPlot, operator2, o.guiGraphIsLogTransform, scalarValueWork, tsWork, scalarValueRef, tsRef, year, freqHere, subHere, sumOver, skipCounter, cc);
                                    }
                                }
                            }
                        }
                    }
                    if (true)  // ------------------------------------------------------------- (24)
                    {

                        int isUndatedOrAnnual = -12345;
                        if (type == EPrintTypes.Plot)
                        {
                            if (freqColumn == EFreq.U) isUndatedOrAnnual = 0;
                            else if (freqColumn == EFreq.A) isUndatedOrAnnual = 1;
                        }
                        else
                        {
                            if (freqs[0]) isUndatedOrAnnual = 0;
                            else if (freqs[1]) isUndatedOrAnnual = 1;
                        }

                        if (isUndatedOrAnnual != -12345)
                        {
                            // --------------------------

                            EFreq freqHere = EFreq.U;
                            if (isUndatedOrAnnual == 1) freqHere = EFreq.A;

                            //EFreq freqHere = EFreq.A;  //will also become "annual" if it is undated
                            int subHere = 1;                            
                            int sumOver = 1;
                            // --------------------------

                            if (PrintShouldKeep(allFreqsDates, freqHere, year, subHere))
                            {
                                i++;
                                if (j == 1)
                                {
                                    if (type != EPrintTypes.Plot && (sameFreq == EFreq.U || sameFreq == EFreq.A))
                                    {
                                        // #98075235874325
                                    }
                                    else
                                    {
                                        table.Set(i, j, uglyYear + "a");
                                        if (rows) table.SetAlign(i, j, Align.Right);
                                        DateHack(table, i, j, freqHere, year, subHere);
                                    }
                                }
                                else
                                {
                                    PrintHelper3(smpl, type, sameFreq, table, n, i, j, iPlot, operator2, o.guiGraphIsLogTransform, scalarValueWork, tsWork, scalarValueRef, tsRef, year, freqHere, subHere, sumOver, skipCounter, cc);
                                }
                                if (type != EPrintTypes.Plot && (sameFreq == EFreq.U || sameFreq == EFreq.A)) i = i - 1; // #98075235874325
                            }
                        }
                    }
                }  //end of years                   
            }
            return table;
        }

        private static bool PrintShouldKeep(AllFreqsHelper allFreqs, EFreq freqHere, int year, int subHere)
        {
            GekkoTime tHere = new GekkoTime(freqHere, year, subHere);            
            GekkoSmplSimple smplSimple = allFreqs.GetPeriods(freqHere);
            if (tHere.LargerThanOrEqual(smplSimple.t1) && tHere.SmallerThanOrEqual(smplSimple.t2)) return true;
            return false;
        }        

        private static void PrintPrepareColumn(EPrintTypes type, List<O.Prt.Element> containerExplode, int j, out O.Prt.Element cc, out string operator2, out List<string> label, out string format, out EFreq freqColumn, out double scalarValueWork, out Series tsWork, out double scalarValueRef, out Series tsRef)
        {
            cc = null;
            IVariable ivWork = null;
            IVariable ivRef = null;
            operator2 = null;
            label = new List<string> { "" };
            format = null;
            if (j - 2 >= 0)
            {
                cc = containerExplode[j - 2];
                ivWork = cc.variable[0];
                ivRef = cc.variable[1];
                operator2 = cc.operatorFinal;
                label = cc.labelOLD;
                format = "f" + cc.widthFinal + "." + cc.decFinal;
            }

            int bankCombi = GetBankCombi(operator2);

            freqColumn = EFreq.None;
            if (j > 1)
            {
                if (bankCombi == 0)
                {
                    if (ivWork.Type() == EVariableType.Series)
                    {
                        freqColumn = ((Series)ivWork).freq;
                    }
                    else
                    {
                        freqColumn = Program.options.freq;
                    }
                }
                else if (bankCombi == 1)
                {
                    if (ivRef.Type() == EVariableType.Series)
                    {
                        freqColumn = ((Series)ivRef).freq;
                    }
                    else
                    {
                        freqColumn = Program.options.freq;
                    }
                }
                else if (bankCombi == 2)
                {
                    if (ivWork.Type() == EVariableType.Series)
                    {
                        freqColumn = ((Series)ivWork).freq;
                    }
                    else
                    {
                        freqColumn = Program.options.freq;
                    }
                }
            }

            scalarValueWork = double.NaN;
            tsWork = null;
            if (ivWork != null)
            {
                tsWork = ivWork as Series;  //remember that the first col has phoney null IVariable
                if (tsWork == null) scalarValueWork = ivWork.GetVal(GekkoTime.tNull);
            }
            scalarValueRef = double.NaN;
            tsRef = null;
            if (ivRef != null)
            {
                tsRef = ivRef as Series;  //remember that the first col has phoney null IVariable
                if (tsRef == null) scalarValueRef = ivRef.GetVal(GekkoTime.tNull);
            }
        }

        private static int PutLabelIntoTable(Table table, int i, int j, List<string> label, int labelMaxLine)
        {
            {
                if (j <= 1)
                {
                    i += labelMaxLine - 1;
                }
                else
                {
                    for (int ii = 0; ii < labelMaxLine; ii++)
                    {
                        //G.Writeln2(labelMaxLine + " " + ii);
                        if (labelMaxLine - ii - 1 < 0)
                        {

                        }
                        else if (labelMaxLine - ii - 1 >= label.Count)
                        {

                        }
                        else
                        {
                            if (label[labelMaxLine - ii - 1] != "[[]]")
                            {
                                table.Set(i, j, label[labelMaxLine - ii - 1]);
                                table.SetAlign(i, j, Align.Right);
                            }
                        }
                        if (ii < labelMaxLine - 1) i++;
                    }
                }
            }

            return i;
        }

        private static void DateHack(Table table, int i, int j, EFreq freq, int year, int sub)
        {
            table.Get(i, j).date_hack = new GekkoTime(freq, year, sub);
        }

        public static EPrintTypes GetPrintType(O.Prt o)
        {
            EPrintTypes type = EPrintTypes.Print;
            if (G.Equal(o.prtType, "plot")) type = EPrintTypes.Plot;
            else if (G.Equal(o.prtType, "sheet")) type = EPrintTypes.Sheet;
            else if (G.Equal(o.prtType, "clip")) type = EPrintTypes.Clip;
            return type;
        }

        public static bool IsGmulprt(O.Prt o, EPrintTypes type)
        {
            return type == EPrintTypes.Print && (G.Equal(o.prtType, "gmulprt") || (o.operators.Count == 1 && G.Equal(o.operators[0].s1, "v") && G.Equal(o.operators[0].s2, "yes")));
        }

        private static void Mismatch()
        {
            if (Globals.runningOnTTComputer)
            {
                G.Writeln2("*** ERROR: Mismatch (only TT computer)");
            }
        }

        public static List<string> OPrintLabels(List<string> labelGiven, List<O.RecordedPieces> labelRecordedPieces, int n, int i)
        {
            if (labelGiven.Count > 1)
            {
                //this is the case for an array-series that has been unfolded
                return labelGiven;
            }

            List<string> lbl = new List<string>();  //this must end up with as many strings as the element has subelements (sublist)

            //for prt {#i}{#j} 

            //n is the number of subelements for the prtElement (for example if the item is a list like {#m}).

            string[] w = RemoveSplitter(labelGiven[0]).Split('|');  //raw label   

            if (labelRecordedPieces.Count == 0)
            {
                lbl.Add(G.ReplaceGlueNew(w[0]));
                return lbl;
            }

            // ===========================================================
            
            //n is the number of elements in the prtElements list
            //For PRT x[#i], it would be the number of elements in #i.

            //For each of these, there mayb be a <q m p> option

            //label is only added if --> counter % nn == nn - 1

            int nn = labelRecordedPieces.Count / n;  //how many inserts like <q m p> per column
            if (labelRecordedPieces.Count % n != 0)
            {
                Mismatch(); //only shown on TT computer
            }

            if (Globals.fixWildcardLabel && labelRecordedPieces.Count > 0 && labelRecordedPieces[0].s == Globals.wildcardText)  //just testing first one
            {
                foreach (O.RecordedPieces r in labelRecordedPieces)
                {
                    lbl.Add(r.iv.ConvertToString());
                }
            }
            else
            {

                //
                // for instance PRT <n p> x[#i], #i = a, b, c.
                // 
                // here n = 3, and we expect 3 recorded pieces for simple x[#i], could be 6 if it was x[#i]/y[#i]
                // the option <n p> does not produce more recorded pieces, <n p n p n p> would not require more
                // calculations, just after-processiong. If there is a <m> or <q> only the first one (for First
                // bank) will be run.
                //
                // hence nn will most likely count how many pieces are inserted for each printed variable (may
                // be a array element), for instance 1 for x[#i], 2 for x[#i]/y[#i], etc.
                //
                // counter counts recordedPieces and runs from 0 ... 2 inclusive.
                //
                // 0  'a'      0 % 1 == 0
                // 1  'b'      1 % 1 == 0
                // 2  'c'      2 % 1 == 0

                // 0  'a'      0 % 2 == 0
                // 1  'b'      1 % 2 == 0
                // 2  'c'      2 % 2 == 0
                // 3  'a'      0 % 2 == 0
                // 4  'b'      1 % 2 == 0
                // 5  'c'      2 % 2 == 0

                //
                //

                // ===========================================================


                string[] result = new string[w[0].Length];
                int ci = 0;
                foreach (char c in w[0])
                {
                    result[ci] = c.ToString();
                    ci++;
                }

                string tmp = w[1];
                string[] w2 = tmp.Substring(1, tmp.Length - 2).Split(',');

                string[] w3 = w2[3].Split(':');
                int i1 = int.Parse(w3[0]);
                int i2 = int.Parse(w3[1]);

                //result is the raw label, char by char
                //the indexes i1 and i2 show the line and pos in the input file
                //now we are going to insert items from RecordLabel() into this result string.

                //foreach recorded call of {} or [], via RecordLabel()


                int counter = -1;
                foreach (O.RecordedPieces piece in labelRecordedPieces)  //foreach RecordLabel()
                {
                    counter++;
                    string[] ss = piece.s.Split('|');
                    int length = 0;
                    length = ss[0].Length;

                    string s2 = ss[1].Substring(1, ss[1].Length - 2);  //remove [ and ]                            
                    string[] sss = s2.Split(',');

                    string[] w4 = sss[3].Split(':');
                    int ii1 = int.Parse(w4[0]);
                    int ii2 = int.Parse(w4[1]);


                    bool skip = false;
                    if (i1 != ii1)
                    {
                        //just skip it
                        //TODO: what about multiline PRT expressions??
                        skip = true;
                    }

                    //if (y.iv.Type() == EVariableType.Date || y.iv.Type() == EVariableType.String || y.iv.Type() == EVariableType.Val)
                    if (piece.iv.Type() == EVariableType.String)
                    {
                        //good
                    }
                    else
                    {
                        skip = true;
                    }

                    if (!skip)
                    {

                        int offset = ii2 - i2;
                        string xx = piece.iv.ConvertToString();

                        result[offset] = xx;
                        for (int ii = offset + 1; ii < offset + length; ii++)
                        {
                            result[ii] = null;
                        }
                        if (result[offset - 1] == "{" && result[offset + length] == "}")
                        {
                            result[offset - 1] = null;
                            result[offset + length] = null;
                        }
                    }

                    string u = null;
                    foreach (string s5 in result)
                    {
                        if (s5 == null) continue;
                        string s6 = s5;
                        if (s5.Trim() != "") s6 = s5.Trim();  //just safety
                        u = u + s6;
                    }
                    string result2 = G.ReplaceGlueNew(u);
                    //G.Writeln2("===> " + result2);

                    // ----------------------------------------------
                    // NOTE: The string[] result is outside the loop of recorded pieces
                    //       For each piece in the loop, something is put into the
                    //       result array. If there are 3 pieces for each label,
                    //       piece0, piece1 and piece2 should be put into the label
                    //       and after piece2 is done, it should be added to List<string> lbl.
                    //       That is the reason of counter % nn == nn - 1, in this case nn = 3,
                    //       so we need counter % 3 == 2, that is counter 
                    // ----------------------------------------------

                    if (counter % nn == nn - 1)
                    //if (counter % nn == 0)
                    {
                        lbl.Add(result2);
                    }

                }
            }

            return lbl;
        }

        public static bool SkipSubSeries(IVariable x)
        {
            return (x.Type() == EVariableType.Series && ((Series)x).isNotFoundArraySubSeries == ESeriesMissing.Skip);            
        }

        public static string RemoveSplitter(string s)
        {
            string lbl;
            string[] ss = s.Split(new string[] { Globals.freelists }, StringSplitOptions.RemoveEmptyEntries);
            if (ss.Length > 1)
            {
                lbl = ss[1];
            }
            else
            {
                lbl = s;
            }

            return lbl;
        }

        

        private static int GetBankCombi(string operator2)
        {
            int bankCombi = -12345;
            List<int> bankNumbers = O.Prt.GetBankNumbers(null, new List<string> { operator2 });
            if (bankNumbers.Contains(0) && !bankNumbers.Contains(1)) bankCombi = 0;
            else if (bankNumbers.Contains(1) && !bankNumbers.Contains(0)) bankCombi = 1;
            else bankCombi = 2;
            return bankCombi;
        }

        public static void NonSeriesHandling(O.Prt oPrt)
        {
            string pling = null;
            pling = "'";
            foreach (O.Prt.Element element in oPrt.prtElements)
            {
                string[] w = RemoveSplitter(element.labelGiven[0]).Split('|');  //raw label   
                string labelGiven = G.ReplaceGlueNew(w[0]);

                PrintNonSeries(element.variable[0], labelGiven, 0);
            }
        }        

        private static string PrintNonSeries(IVariable x, string labelGiven, int depth)
        {
            string s = "";
            string pling = "'";
            if (depth == 0)
            {
                if (x.Type() == EVariableType.List)
                {
                    G.Writeln2(labelGiven);
                    List x_list = x as List;
                    for (int i = 0; i < x_list.Count(); i++)
                    {
                        string ss = PrintNonSeries(x_list.list[i], null, depth + 1);
                        s += ss;
                        if (x_list.Count() == 1)
                        {
                            //
                        }
                        else if (i < x_list.Count() - 1)
                        {
                            s += ", ";
                        }
                    }
                    G.Write(s);
                    G.Writeln("   [" + x_list.Count() + " item" + G.S(x_list.Count()) + "]", Color.LightGray);
                }
                else if (x.Type() == EVariableType.Matrix)
                {
                    Program.ShowMatrix((Matrix)x, labelGiven);
                }
                else if (x.Type() == EVariableType.String)
                {
                    PrintLabel(labelGiven);
                    G.Writeln(pling + ((ScalarString)x).string2 + pling);
                }
                else if (x.Type() == EVariableType.Val)
                {
                    PrintLabel(labelGiven);
                    double d = ((ScalarVal)x).val;
                    if (G.isNumericalError(d))
                    {
                        G.Writeln(Globals.printNaNIndicator);
                    }
                    else
                    {
                        G.Writeln(d.ToString());
                    }
                }
                else if (x.Type() == EVariableType.Date)
                {
                    PrintLabel(labelGiven);
                    G.Writeln(((ScalarDate)x).date.ToString());
                }
                else if (x.Type() == EVariableType.Map)
                {
                    PrintLabel(labelGiven);
                    Map map = x as Map;

                    if (map.storage.Count == 0)
                    {
                        G.Writeln("[empty map]");
                    }
                    else
                    {
                        G.Writeln("MAP printing not implemented yet. But individual elements can");
                        G.Writeln("be printed like for instance #m.%s, #m.x, etc.");
                    }
                }
                else if (x.Type() == EVariableType.Null)
                {
                    G.Writeln2("[null]");
                }
                else
                {
                    G.Writeln2("*** ERROR: Unkonwn variable type");
                    //SERIES: should not be possible
                }
            }
            else
            {
                //depth > 0
                if (x.Type() == EVariableType.List)
                {
                    List x_list = x as List;
                    for (int i = 0; i < x_list.Count(); i++)
                    {
                        string ss = PrintNonSeries(x_list.list[i], null, depth + 1);
                        s += ss;
                        if (x_list.Count() == 1)
                        {
                            s += ",";
                        }
                        else if (i < x_list.Count() - 1)
                        {
                            s += ", ";
                        }
                    }
                    s = "(" + s + ")";
                }
                else if (x.Type() == EVariableType.String)
                {
                    s += pling + ((ScalarString)x).string2 + pling;
                }
                else if (x.Type() == EVariableType.Date)
                {
                    s += ((ScalarDate)x).date.ToString();
                }
                else if (x.Type() == EVariableType.Val)
                {
                    ////See also #83490837432, these should be merged/fusioned
                    //We use same format as for normal PRT of series, but the width is truncated regarding blanks
                    double d = ((ScalarVal)x).val;

                    if (G.isNumericalError(d))
                    {
                        s += Globals.printNaNIndicator;
                    }
                    else
                    {
                        //string format = "f" + Program.options.print_fields_nwidth + "." + Program.options.print_fields_ndec + "";
                        //G.FormatNumber(d, format, false, false).Trim();
                        string z = "";
                        for (int i = 0; i < Program.options.print_fields_ndec; i++) z += "#";
                        string format = "0." + z;
                        string s3 = d.ToString("0." + z, CultureInfo.InvariantCulture);
                        s += s3;
                    }                                        
                }
                else
                {
                    s += "[" + x.Type().ToString().ToLower() + "]";  //series, map, matrix
                }


            }
            return s;

        }

        private static void PrintLabel(string labelGiven)
        {
            if (!G.NullOrBlanks(labelGiven)) G.Writeln2(labelGiven);
            else G.Writeln();
        }

        public static bool HandleLabels(TokenList tokenList, int level, List<O.LabelHelperIVariable> iVariableList, string[] uncontrolledSimpleLists, ref int counter)
        {
            //it is checked that the IVariables from iVariableList match in number with the relevant {...} and x{...} in the tokenList.
            //for x[..., ..., ...] they must also match in indexer position
            //if any of this is wrong, the method returns true (= fail), and in that case
            //the labels are not unfolded but just shown as they are.
            //so there will be no catastrophic fail here, just labels that are not very informative.
            //the counting check is quite a good check that the {...} and x[...] match.

            foreach (TokenHelper token in tokenList.storage)
            {
                if (token.HasChildren())
                {
                    if (token.SubnodesType() == "[" || token.SubnodesType() == "{")
                    {
                        List<TokenHelperComma> listOfTokensListsCommaSplit = token.SplitCommas(true);
                        int ii = -1;
                        foreach (TokenHelperComma tokenListCommaSplit in listOfTokensListsCommaSplit)  //does not include start and end parenthesis
                        {
                            counter++;
                            ii++;
                            if (tokenListCommaSplit.list.storage.Count == 2 && tokenListCommaSplit.list[0].s == Globals.symbolCollection.ToString() && tokenListCommaSplit.list[1].type == ETokenType.Word)
                            {
                                string listName = tokenListCommaSplit.list[1].s;
                                TokenHelper parent = tokenListCommaSplit.list[0];
                                bool foundAsSumFunction = false;
                                while (true)
                                {
                                    if (parent == null) break;
                                    if (parent.SubnodesType() == "(")
                                    {
                                        TokenHelper left = parent.Offset(-1);
                                        if (left != null)
                                        {
                                            if (G.Equal(left.s, "sum"))
                                            {
                                                List<TokenHelperComma> split = parent.SplitCommas(true);
                                                if (split.Count > 1)
                                                {
                                                    TokenList firstSplit = split[0].list;
                                                    if (firstSplit.storage.Count == 1)
                                                    {
                                                        if (firstSplit[0].SubnodesType() == "(")
                                                        {
                                                            //handles sum((#i, #j), ...)
                                                            List<TokenHelperComma> splitNew = firstSplit[0].SplitCommas(true);
                                                            foreach (TokenHelperComma splitNewItem in splitNew)
                                                            {
                                                                string listName2 = HandleLabelsIsSimpleListName(splitNewItem.list);
                                                                if (listName2 != null)
                                                                {
                                                                    if (G.Equal(listName, listName2))
                                                                    {
                                                                        foundAsSumFunction = true;
                                                                        break;
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                    else if (firstSplit.storage.Count > 1)
                                                    {
                                                        string listName2 = HandleLabelsIsSimpleListName(firstSplit);
                                                        if (listName2 != null)
                                                        {
                                                            //handles sum(#i, ...)

                                                            if (G.Equal(listName, listName2))
                                                            {
                                                                foundAsSumFunction = true;
                                                                break;
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    parent = parent.parent;
                                }

                                if (!foundAsSumFunction)
                                {
                                    //We have a simple #x as this argument                                    
                                    //a free list has its string value put in
                                    if (counter >= iVariableList.Count)
                                    {
                                        return true;  //out of bounds, do not proceed. It seems we have more tokens found with {...} or x[...] than there are IVariables.
                                    }
                                    O.LabelHelperIVariable helper = iVariableList[counter];
                                    if (helper.index != ii)
                                    {
                                        //does not match the index position
                                        return true;
                                    }
                                    if (helper.iv.Type() == EVariableType.String)
                                    {
                                        HandleLabelsInsertIVariables(token, tokenListCommaSplit.list, O.ConvertToString(helper.iv));
                                    }
                                }
                                else
                                {
                                    //this is a bounded list, like sum(#i, x[#i]).
                                    //in that case, we just keep the #i.
                                }
                            }
                            else
                            {
                                //it is not a simple #x
                                if (counter >= iVariableList.Count)
                                {
                                    return true;  //out of bounds, do not proceed. It seems we have more tokens found with {...} or x[...] than there are IVariables.
                                }
                                O.LabelHelperIVariable helper = iVariableList[counter];
                                if (helper.index != ii)
                                {
                                    //does not match the index position
                                    return true;
                                }

                                if (helper.iv.Type() == EVariableType.String || helper.iv.Type() == EVariableType.Date || helper.iv.Type() == EVariableType.Val)
                                {
                                    HandleLabelsInsertIVariables(token, tokenListCommaSplit.list, ((ScalarString)Functions.tostring(null, null, null, helper.iv)).string2);
                                }
                            }

                        }

                    }
                    else
                    {
                        //The list only contains index values at the uppermost nesting level of [] or {} parentheses.
                        //But we handle sub-nests regarding ()-parentheses.
                        bool problem = HandleLabels(token.subnodes, level + 1, iVariableList, uncontrolledSimpleLists, ref counter);
                        if (problem)
                        {
                            return true;
                        }
                    }
                }
                else
                {
                    //s += th.leftblanks + th.s;
                }
            }
            if (level == 0 && (counter + 1 != iVariableList.Count)) //only when returning from the upmost level, where we can see if the numbers match.
            {
                return true;
            }
            return false;

        }

        private static string HandleLabelsIsSimpleListName(TokenList splitNewItem)
        {
            if (splitNewItem.storage.Count == 2 && splitNewItem[0].s == Globals.symbolCollection.ToString() && splitNewItem[1].type == ETokenType.Word)
            {
                return splitNewItem[1].s;
            }
            else return null;
        }

        private static void HandleLabelsInsertIVariables(TokenHelper th, TokenList temp2, string iv_string)
        {
            temp2[0].s = iv_string;
            temp2[0].type = ETokenType.Word;
            temp2[0].subnodes = null;
            for (int ii = 1; ii < temp2.storage.Count; ii++)
            {
                temp2[ii].s = "";
                temp2[ii].type = ETokenType.Unknown;
                temp2[ii].subnodes = null;
            }
            if (th.SubnodesType() == "{")
            {
                //Removing the '{'and '}'
                th.subnodes[0].s = "";
                th.subnodes[th.subnodes.storage.Count - 1].s = "";
            }
        }
        
        private static void PrintHelper3(GekkoSmpl smpl, EPrintTypes type, EFreq sameFreq, Table table, int count, int i, int j, int iPlot, string operator2, bool isLogTransform, double scalarValueWork, Series tsWork, double scalarValueRef, Series tsRef, int year, EFreq freqColumn, int subHere, int sumOver, int[] skipCounter, O.Prt.Element cc)
        {
            //få den til at returnere "n", måske skal 
            string format = "f" + cc.widthFinal + "." + cc.decFinal;

            GekkoTime t = new GekkoTime(freqColumn, year, subHere);

            foreach (GekkoTime tFilter in Globals.globalPeriodTimeFilters2)
            {
                if (t.freq == tFilter.freq && t.Equals(tFilter))
                {
                    if (t.freq == EFreq.U) skipCounter[0]++;
                    else if (t.freq == EFreq.A) skipCounter[1]++;
                    else if (t.freq == EFreq.Q) skipCounter[2]++;
                    else if (t.freq == EFreq.M) skipCounter[3]++;
                    return;
                }
            }

            double? d = null;
            if (tsWork == null && tsRef == null)  //not series
            {
                if (sameFreq == freqColumn) d = PrintHelperTransformScalar(scalarValueWork, scalarValueRef, operator2, isLogTransform, sumOver, skipCounter);
            }
            else
            {
                if ((tsWork != null && tsWork.freq == freqColumn) || (tsRef != null && tsRef.freq == freqColumn)) d = PrintHelperTransform(smpl, tsWork, tsRef, t, operator2, isLogTransform, sumOver, skipCounter);
            }
            if (d != null)
            {                
                //cc.min = Math.Min(cc.min, (double)d);
                //cc.max = Math.Max(cc.max, (double)d);
                if (type != EPrintTypes.Plot)
                {
                    double dd = dd = (double)d;
                    if (double.IsNaN((double)d))
                    {
                        if ((tsWork != null && tsWork.isNotFoundArraySubSeries == ESeriesMissing.M) || (tsRef != null && tsRef.isNotFoundArraySubSeries == ESeriesMissing.M))
                        {
                            dd = Globals.missingVariableArtificialNumber;
                        }                       
                    }
                    else if ((double)d == 0d)
                    {
                        if ((tsWork != null && tsWork.isNotFoundArraySubSeries == ESeriesMissing.Zero) || (tsRef != null && tsRef.isNotFoundArraySubSeries == ESeriesMissing.Zero))
                        {
                            dd = Globals.missingVariableZero;
                        }
                    }
                    table.SetNumber(i, j, dd, format);
                }
                else
                {
                    double tt = ((ScalarVal)Functions.helper_time(t)).val;
                    if (freqColumn == EFreq.U || freqColumn == EFreq.A) tt += 0.5;
                    //table.SetNumber(i - 1, 2 * (j - 2) + 1, tt, format);  //j=2 -> 1, j=3 -> 3
                    //table.SetNumber(i - 1, 2 * (j - 2) + 2, (double)d, format);  //j=2 -> 2, j=3 -> 4
                    table.SetNumber(i - 1, (j - 2) + 1, tt, format);                 //j=2 -> 1, j=3 -> 2
                    table.SetNumber(i - 1, (j - 2) + 1 + count, (double)d, format);  //j=2 -> 1+count, j=3 -> 2+count
                }

            }

            if (t.freq == EFreq.U) skipCounter[0] = 0;
            else if (t.freq == EFreq.A) skipCounter[1] = 0;
            else if (t.freq == EFreq.Q) skipCounter[2] = 0;
            else if (t.freq == EFreq.M) skipCounter[3] = 0;

        }

        private static double PrintHelperTransform(GekkoSmpl smpl, Series tsWork, Series tsRef, GekkoTime t, string operator2, bool logTransform, int sumOver, int[] skipCounter)
        {
            if (true)
            {
                //TODO filter and skip, see below
                double var1 = double.NaN;
                double varPch = double.NaN;
                Program.ComputeValueForPrintPlotNew(out var1, out varPch, operator2, t, tsWork, tsRef, logTransform, false, sumOver);
                return var1;
            }            
        }

        private static double PrintHelperTransformScalar(double scalarWork, double scalarRef, string operator2, bool logTransform, int sumOver, int[] skipCounter)
        {
            if (logTransform)
            {
                scalarWork = Math.Log(scalarWork);
                scalarRef = Math.Log(scalarRef);
            }

            if (G.Equal(operator2, "n")) return scalarWork;
            else if (G.Equal(operator2, "q")) return (scalarWork / scalarRef - 1d) * 100d;
            else if (G.Equal(operator2, "m")) return scalarWork - scalarRef;
            else if (G.Equal(operator2, "d")) return 0d;
            else if (G.Equal(operator2, "p")) return 0d;
            else if (G.Equal(operator2, "dp")) return 0d;
            else
            {
                G.Writeln2("*** ERROR: Transformation error");
                throw new GekkoException();
            }
        }

        private static void PrintHelper2(List<O.PrtContainer> containerExplode, bool[] freqs, O.PrtContainer container, bool root, bool isRef, List<IVariable> errorList)
        {
            //TODO: what to do with ref, how to merge??? What if MULPRT {#m1}, and #m1 has different elements 
                      

            if (container.variable[0] != null && container.variable[0].Type() == EVariableType.Series)
            {
                containerExplode.Add(container);
                PrintFreqHelper(freqs, container.variable[0]);  //the ref one should be same freq
            }            
            else if (container.variable[0] != null && container.variable[0].Type() == EVariableType.Val)
            {
                containerExplode.Add(container);
            }
            else if (container.variable[0] != null && container.variable[0].Type() == EVariableType.Matrix && ((Matrix)container.variable[0]).data.Length == 1)  //an 1x1 matrix
            {
                containerExplode.Add(container);
            }
            else if (container.variable[0] != null && container.variable[0].Type() == EVariableType.List)
            {
                if (root)
                {
                    for(int i = 0;i< ((List)container.variable[0]).list.Count;i++)
                    {
                        O.PrtContainer c2 = new O.PrtContainer();
                        if (container.variable[0] != null) c2.variable[0] = ((List)container.variable[0]).list[i];
                        if (container.variable[0] != null) c2.variable[0] = ((List)container.variable[0]).list[i];
                        c2.label = container.label;
                        c2.operator2 = container.operator2;
                        PrintHelper2(containerExplode, freqs, c2, false, isRef, errorList);  //the counter is fixed
                    }
                }
            }
            else
            {
                errorList.Add(container.variable[0]);                            
            }
        }

        private static void PrintFreqHelper(bool[] freqs, IVariable iv)
        {
            if (((Series)iv).freq == EFreq.A) freqs[0] = true;
            else if (((Series)iv).freq == EFreq.Q) freqs[1] = true;
            else if (((Series)iv).freq == EFreq.M) freqs[2] = true;
        }

        
        private static bool HasIdenticalCodes(O.Prt o)
        {
            //a bit costly method, and the loop here is looped again later on, but this is not speed critical.
            bool identicalCodes = false;
            GekkoDictionary<string, string> temp = new GekkoDictionary<string, string>(StringComparer.OrdinalIgnoreCase);
            foreach (O.Prt.Element pe in o.prtElements)  //varI 0-based
            {
                List<string> operators = GetElementOperators(o, pe);
                foreach (string s in operators)
                {
                    if (!temp.ContainsKey(s)) temp.Add(s, "");
                }
            }
            if (temp.Count == 1) identicalCodes = true;
            return identicalCodes;
        }
                

        private static double CalculateAveragesForPrint(string operator2, List<double> filterMemoryValues, EPrtCollapseTypes collapse, int n)
        {
            double rv = double.NaN;
            if (IsLevelOperator(operator2))
            {
                if (n == -12345)
                {
                    double start1 = 0d;
                    for (int i = 0; i < filterMemoryValues.Count; i++) start1 += filterMemoryValues[i];
                    rv = start1 / (double)filterMemoryValues.Count;
                }
                else
                {
                    if (filterMemoryValues.Count - n >= 0)
                    {
                        double start1 = 0d;
                        for (int i = filterMemoryValues.Count - n; i < filterMemoryValues.Count; i++) start1 += filterMemoryValues[i];
                        double den = (double)n;
                        if (collapse == EPrtCollapseTypes.Total) den = 1d;
                        rv = start1 / den;
                    }
                }
            }
            else
            {
                //percent print codes
                if (G.Equal(operator2, "p") || G.Equal(operator2, Globals.operator_rp))
                {
                    if (n == -12345)
                    {
                        double start1 = 1d;
                        for (int i = 0; i < filterMemoryValues.Count; i++) start1 *= 1 + filterMemoryValues[i] / 100d;
                        rv = (Math.Pow(start1, 1d / (double)filterMemoryValues.Count) - 1d) * 100d;
                    }
                    else
                    {
                        if (filterMemoryValues.Count - 2 * n >= 0)
                        {
                            int counter = 0;
                            double xa = 0;
                            double xb = 0;
                            double start1 = 1d;
                            for (int i = filterMemoryValues.Count - 2 * n; i < filterMemoryValues.Count; i++)
                            {
                                counter++;
                                start1 *= 1 + filterMemoryValues[i] / 100d;
                                if (counter <= n) xa += start1;
                                else if (counter >= n + 1) xb += start1;
                            }
                            rv = (xb / xa - 1d) * 100d;
                        }
                    }
                }
                else
                {
                    //#89074323455
                    //for instance q printcode, could be in MULPRT
                    rv = double.NaN;
                }

                //double start2 = 1d;
                //for (int i = 0; i < filterMemoryValues.Count; i++)
                //{
                //    start2 *= 1 + filterMemoryValues[i] / 100d;
                //}
                //rv = (Math.Pow(start2, 1d / (double)filterMemoryValues.Count) - 1d) * 100d;
            }
            return rv;
        }

        private static bool IsMulprt(O.Prt o)
        {
            bool isMulprt = false;
            if (G.Equal(o.prtType, "mulprt")) isMulprt = true;
            if (G.Equal(o.prtType, "gmulprt")) isMulprt = true;
            return isMulprt;
        }

        public static List<string> GetElementOperators(O.Prt o, O.Prt.Element ope)
        {
            List<string> operators = new List<string>();
            if (o.guiGraphOperator != null)
            {
                operators.Add(o.guiGraphOperator);
            }
            else
            { 
                bool isGraph = false;
                bool isSheet = false;
                if (G.Equal(o.prtType, "plot")) isGraph = true;
                else if (G.Equal(o.prtType, "sheet")) isSheet = true;
                else if (G.Equal(o.prtType, "clip")) isSheet = true;

                bool isMulprt = IsMulprt(o);
                
                operators.AddRange(GetSuperOperators(o)); //start with a fresh copy of super-printcodes

                if (!isMulprt && operators.Count == 1 && G.Equal(operators[0], "lev"))
                {
                    G.Writeln2("*** ERROR: PRT<lev> is not legal: use PRT<abs> to print absolute levels");
                    throw new GekkoException();
                }

                if (isMulprt && operators.Count == 1 && (G.Equal(operators[0], "dif") || G.Equal(operators[0], "diff")))
                {
                    G.Writeln2("*** ERROR: MULPRT<dif> is not legal: use MULPRT<abs> to print multiplier differences");
                    throw new GekkoException();
                }

                if (ope != null && ope.operators != null && ope.operators.Count > 0)
                {
                    //element-specific printcode overrides!
                    operators = new List<string>();
                    foreach (OptString ts in ope.operators)
                    {
                        //hmmm, what if there is a no after a yes for the same code????
                        if (G.Equal(ts.s2, "yes")) operators.Add(ts.s1);
                        else if (G.Equal(ts.s2, "no"))
                        {
                            //do not add
                        }
                        else
                        {
                            G.Writeln2("*** ERROR: Operator = '" + ts.s2 + "' should be 'yes' or 'no'");
                            throw new GekkoException();
                        }
                    }
                }
                operators = PrintGetOperatorsOLD(isMulprt, operators, isGraph, isSheet);
            }
            return operators;
        }

        private static List<string> GetSuperOperators(O.Prt o)
        {
            List<string> operatorsGlobal = new List<string>();
            foreach (OptString ts in o.operators)
            {
                //hmmm, what if there is a no after a yes for the same code????
                if (G.Equal(ts.s2, "yes"))
                {
                    operatorsGlobal.Add(ts.s1);
                }
                else if (G.Equal(ts.s2, "no"))
                {
                    operatorsGlobal.Add("no" + ts.s1);  //for instance 'nopch'
                }
                else if (G.Equal(ts.s2, "append"))
                {
                    operatorsGlobal.Add("_" + ts.s1);  //for instance '_lev'
                }
                else
                {
                    G.Writeln2("*** ERROR: Operator = '" + ts.s2 + "' should be 'yes' or 'no' or 'append'");
                    throw new GekkoException();
                }
            }
            return operatorsGlobal;
        }

        private static void SetGmulprtOperators(PrtHelper ph)
        {
            ph.operators.Clear();
            ph.operators.Add("n");
            ph.operators.Add("p");
            ph.operators.Add(Globals.operator_r);
            ph.operators.Add(Globals.operator_rp);
            ph.operators.Add("m");
            ph.operators.Add("q");
        }

        private static void ChangeOperatorsToLower(PrtHelper ph)
        {
            if (ph.operators != null) ph.operators = ph.operators.ConvertAll(d => d.ToLower());
            foreach (PrtHelperElement phe in ph.elementOptions)
            {
                if (phe == null) continue;
                if (phe.operators == null) continue;
                phe.operators = phe.operators.ConvertAll(d => d.ToLower());
            }
        }
               

        private static EPrtCollapseTypes GetCollapseType(O.Prt o, EPrintTypes type)
        {
            EPrtCollapseTypes collapse = EPrtCollapseTypes.None;

            if (type == EPrintTypes.Print)
            {
                if (G.Equal(Program.options.print_collapse, "avg")) collapse = EPrtCollapseTypes.Avg;
                else if (G.Equal(Program.options.print_collapse, "total")) collapse = EPrtCollapseTypes.Total;
                if (G.Equal(o.opt_collapse, "avg")) collapse = EPrtCollapseTypes.Avg;  //overrides global options
                else if (G.Equal(o.opt_collapse, "total")) collapse = EPrtCollapseTypes.Total;  //overrides global options
                else if (G.Equal(o.opt_collapse, "yes"))
                {
                    if (G.Equal(Program.options.print_collapse, "none")) collapse = EPrtCollapseTypes.Total;  //default for PRT<collapse>, if no global option
                }
            }
            else if (type == EPrintTypes.Sheet)
            {
                if (G.Equal(Program.options.sheet_collapse, "avg")) collapse = EPrtCollapseTypes.Avg;
                else if (G.Equal(Program.options.sheet_collapse, "total")) collapse = EPrtCollapseTypes.Total;
                if (G.Equal(o.opt_collapse, "avg")) collapse = EPrtCollapseTypes.Avg;  //overrides global options
                else if (G.Equal(o.opt_collapse, "total")) collapse = EPrtCollapseTypes.Total;  //overrides global options
                else if (G.Equal(o.opt_collapse, "yes"))
                {
                    if (G.Equal(Program.options.sheet_collapse, "none")) collapse = EPrtCollapseTypes.Total;  //default for PRT<collapse>, if no global option
                }
            }

            return collapse;
        }

        private static int PrintPrettify(O.Prt o, Table tab, int numberOfLabelsLinesMax, bool transpose, int maxLabelsLinesFound, bool identicalCodes, string oneOperatorLabel, int virtualRowsStart, int virtualRowsMaxSeen)
        {
            if (identicalCodes)  //put in general marker for whole table just over the period column (or left of it if transposed)
            {
                string s = "";
                if (o.operators.Count == 1) s = oneOperatorLabel;
                if (s != "")
                {
                    int ii = numberOfLabelsLinesMax + virtualRowsStart;
                    int jj = 1;
                    if (transpose)
                    {
                        ii = 1;
                        jj = numberOfLabelsLinesMax;
                    }
                    tab.Set(ii, jj, s);
                    if (!transpose)
                    {
                        tab.SetAlign(ii, jj, Align.Right);
                    }
                }
            }

            int difference = numberOfLabelsLinesMax - maxLabelsLinesFound;

            if (!transpose && difference > 0)
            {
                for (int i = 0; i < difference; i++)
                {
                    tab.DeleteRow(1 + virtualRowsStart);
                }
            }

            return virtualRowsMaxSeen - difference;
        }

        private static void NonExistenceError(List<string> nonExistenceErrors, string variableLabel, string variableName, string ss)
        {
            if (variableLabel != null && !G.Equal(variableName, variableLabel)) ss += ":   " + variableLabel;
            if (!nonExistenceErrors.Contains(ss)) nonExistenceErrors.Add(ss);
        }

        
        private static List<string> PrintGetOperatorsOLD(bool isMulprt, List<string> operators, bool isGraph, bool isSheet)
        {
            bool mul_lev = false;
            bool mul_abs = false;
            bool mul_pch = false;
            bool mul_gdif = false;
            bool abs = false;
            bool dif = false;
            bool pch = false;
            bool gdif = false;

            List<string> operatorsNew = null;
            //Range: ShortVersion, LongVersionHasYes, LongVersionHasAppend, LongVersionOnlyNo, None
            EOperatorTypes operatorType = GetOperatorType(operators);  //also performs validation that they are not mixed wrongly

            if (operatorType == EOperatorTypes.None || operatorType == EOperatorTypes.LongVersionHasYes || operatorType == EOperatorTypes.LongVersionHasAppend || operatorType == EOperatorTypes.LongVersionOnlyNo)
            {
                operatorsNew = new List<string>();
                PrintGetOperatorHelper2(isSheet, ref mul_lev, ref mul_abs, ref mul_pch, ref mul_gdif, ref abs, ref dif, ref pch, ref gdif);
                if (isGraph)
                {
                    mul_pch = false;  //probably never relavant, but for symmetry
                    pch = false;
                }

                if (operatorType == EOperatorTypes.LongVersionHasYes)  //then it may contain yes and no elements (but no append). The yes element clears all defaults, so no elements are not really interesting here since they will have no effect
                {
                    //clear them all
                    mul_lev = false;
                    mul_abs = false;
                    mul_pch = false;
                    mul_gdif = false;
                    abs = false;
                    dif = false;
                    pch = false;
                    gdif = false;
                }
                else
                {
                    //keep global option values for None, LongVersionHasAppend or LongVersionOnlyNo
                }
                bool levTest = false;
                bool absTest = false;
                bool difTest = false;
                bool pchTest = false;
                bool gdifTest = false;

                foreach (string operator2 in operators)
                {
                    if (isMulprt)  //MULPRT
                    {
                        if (operator2 == "lev" || operator2 == "_lev")
                        {
                            levTest = TestNoDuplicateDisplayCode(levTest, "lev");
                            mul_lev = true;
                        }
                        else if (operator2 == "nolev")
                        {
                            levTest = TestNoDuplicateDisplayCode(levTest, "lev");
                            mul_lev = false;
                        }
                        else if (operator2 == "abs" || operator2 == "_abs")
                        {
                            absTest = TestNoDuplicateDisplayCode(absTest, "abs");
                            mul_abs = true;
                        }
                        else if (operator2 == "noabs")
                        {
                            absTest = TestNoDuplicateDisplayCode(absTest, "abs");
                            mul_abs = false;
                        }
                        else if (operator2 == "pch" || operator2 == "_pch")
                        {
                            pchTest = TestNoDuplicateDisplayCode(pchTest, "pch");
                            mul_pch = true;
                        }
                        else if (operator2 == "nopch")
                        {
                            pchTest = TestNoDuplicateDisplayCode(pchTest, "pch");
                            mul_pch = false;
                        }
                        else if (operator2 == "gdif" || operator2 == "_gdif")
                        {
                            gdifTest = TestNoDuplicateDisplayCode(gdifTest, "gdif");
                            mul_gdif = true;
                        }
                        else if (operator2 == "nogdif")
                        {
                            gdifTest = TestNoDuplicateDisplayCode(gdifTest, "gdif");
                            mul_gdif = false;
                        }
                    }
                    else  //normal PRT
                    {
                        if (operator2 == "abs" || operator2 == "_abs")
                        {
                            absTest = TestNoDuplicateDisplayCode(absTest, "abs");
                            abs = true;
                        }
                        else if (operator2 == "noabs")
                        {
                            absTest = TestNoDuplicateDisplayCode(absTest, "abs");
                            abs = false;
                        }
                        else if (operator2 == "dif" || operator2 == "_dif")
                        {
                            difTest = TestNoDuplicateDisplayCode(difTest, "dif");
                            dif = true;
                        }
                        else if (operator2 == "nodif")
                        {
                            difTest = TestNoDuplicateDisplayCode(difTest, "dif");
                            dif = false;
                        }
                        else if (operator2 == "pch" || operator2 == "_pch")
                        {
                            pchTest = TestNoDuplicateDisplayCode(pchTest, "pch");
                            pch = true;
                        }
                        else if (operator2 == "nopch")
                        {
                            pchTest = TestNoDuplicateDisplayCode(pchTest, "pch");
                            pch = false;
                        }
                        else if (operator2 == "gdif" || operator2 == "_gdif")
                        {
                            gdifTest = TestNoDuplicateDisplayCode(gdifTest, "gdif");
                            gdif = true;
                        }
                        else if (operator2 == "nogdif")
                        {
                            gdifTest = TestNoDuplicateDisplayCode(gdifTest, "gdif");
                            gdif = false;
                        }
                    }
                }
                if (isMulprt)
                {
                    //will always be in {n,m,q,mp} order
                    if (mul_lev) operatorsNew.Add("n");
                    if (mul_abs) operatorsNew.Add("m");
                    if (mul_pch) operatorsNew.Add("q");
                    if (mul_gdif) operatorsNew.Add("mp");
                }
                else
                {
                    //will always be in {n,d,p,dp} order
                    if (abs) operatorsNew.Add("n");
                    if (dif) operatorsNew.Add("d");
                    if (pch) operatorsNew.Add("p");
                    if (gdif) operatorsNew.Add("dp");
                }
            }
            else
            {
                if (!isMulprt && !isGraph && operators.Count == 1 && G.Equal(operators[0], "r"))
                {
                    //PRT<r> or SHEET/CLIP<r>
                    PrintGetOperatorHelper2(isSheet, ref mul_lev, ref mul_abs, ref mul_pch, ref mul_gdif, ref abs, ref dif, ref pch, ref gdif);
                    operatorsNew = new List<string>();
                    if (abs) operatorsNew.Add("rn");
                    if (dif) operatorsNew.Add("rd");
                    if (pch) operatorsNew.Add("rp");
                    if (gdif) operatorsNew.Add("rdp");
                }
                else
                {
                    operatorsNew = operators;  //point to same object
                }
            }
            return operatorsNew;
        }

        private static void PrintGetOperatorHelper2(bool isSheet, ref bool mul_lev, ref bool mul_abs, ref bool mul_pch, ref bool mul_gdif, ref bool abs, ref bool dif, ref bool pch, ref bool gdif)
        {
            if (isSheet)
            {
                //In this case, the printcodes are transformed to the short format
                mul_lev = Program.options.sheet_mulprt_lev;
                mul_abs = Program.options.sheet_mulprt_abs;
                mul_pch = Program.options.sheet_mulprt_pch;
                mul_gdif = Program.options.sheet_mulprt_gdif;
                abs = Program.options.sheet_prt_abs;
                dif = Program.options.sheet_prt_dif;
                pch = Program.options.sheet_prt_pch;
                gdif = Program.options.sheet_prt_gdif;
            }
            else
            {
                mul_lev = Program.options.print_mulprt_lev;
                mul_abs = Program.options.print_mulprt_abs;
                mul_pch = Program.options.print_mulprt_pch;
                mul_gdif = Program.options.print_mulprt_gdif;
                abs = Program.options.print_prt_abs;
                dif = Program.options.print_prt_dif;
                pch = Program.options.print_prt_pch;
                gdif = Program.options.print_prt_gdif;
            }
        }

        private static void PrintGetWithAndDecimals(O.Prt o, int varI, List<string> operatorsNew, List<int> widths, List<int> decs)
        {
            foreach (string operator2 in operatorsNew)
            {
                int width = -12345;
                int dec = -12345;
                bool isPchType = false;
                if (IsLevelOperator(operator2))
                {
                    isPchType = false;
                    width = options.print_fields_nwidth;
                    dec = options.print_fields_ndec;
                }
                else
                {
                    isPchType = true;
                    width = options.print_fields_pwidth;
                    dec = options.print_fields_pdec;
                    if (operator2 == Globals.operator_dl || operator2 == Globals.operator_rdl) dec = dec + 2;
                }

                // ---------------------------------------------
                // --- Width -----------------------------------
                // ---------------------------------------------
                if (o.opt_width != -12345) width = (int)o.opt_width;
                if (isPchType)
                {
                    //overrides ph.width if given
                    if (o.opt_pwidth != -12345) width = (int)o.opt_pwidth;
                }
                else
                {
                    //overrides ph.width if given
                    if (o.opt_nwidth != -12345) width = (int)o.opt_nwidth;
                }

                //element-specific stuff
                if (o.prtElements[varI] != null && o.prtElements[varI].width != -12345) width = o.prtElements[varI].width;   //element-specific width overrides!
                if (isPchType)
                {
                    //overrides ph.width if given
                    if (o.prtElements[varI] != null && o.prtElements[varI].pwidth != -12345) width = o.prtElements[varI].pwidth;
                }
                else
                {
                    //overrides ph.width if given
                    if (o.prtElements[varI] != null && o.prtElements[varI].nwidth != -12345) width = o.prtElements[varI].nwidth;
                }


                // ---------------------------------------------
                // --- Decimals --------------------------------
                // ---------------------------------------------
                if (o.opt_dec != -12345) dec = (int)o.opt_dec;
                if (isPchType)
                {
                    //overrides ph.dec if given
                    if (o.opt_pdec != -12345) dec = (int)o.opt_pdec;
                }
                else
                {
                    //overrides ph.dec if given
                    if (o.opt_ndec != -12345) dec = (int)o.opt_ndec;
                }

                //element-specific stuff
                if (o.prtElements[varI] != null && o.prtElements[varI].dec != -12345) dec = o.prtElements[varI].dec;   //element-specific dec overrides!
                if (isPchType)
                {
                    //overrides ph.dec if given
                    if (o.prtElements[varI] != null && o.prtElements[varI].pdec != -12345) dec = o.prtElements[varI].pdec;
                }
                else
                {
                    //overrides ph.dec if given
                    if (o.prtElements[varI] != null && o.prtElements[varI].ndec != -12345) dec = o.prtElements[varI].ndec;
                }


                widths.Add(width);
                decs.Add(dec);
            }
        }

        private static bool IsLevelOperator(string operator2)
        {
            return operator2 == "" || operator2 == "n" || operator2 == "d" || operator2 == Globals.operator_r || operator2 == Globals.operator_rn || operator2 == Globals.operator_rd || operator2 == "m" || operator2 == Globals.operator_l || operator2 == Globals.operator_rl;
        }        

        private static bool HasIdenticalCodes(List<string> graphVars, PrtHelper ph)
        {
            bool identicalCodes = true;
            for (int varI = 0; varI < graphVars.Count; varI++)  //varI 0-based
            {
                if (ph.elementOptions[varI] != null)
                {
                    identicalCodes = false;
                    break;
                }
            }
            if (ph.operators.Count > 1) identicalCodes = false;
            if (ph.operators.Count == 1)
            {
                string s = ph.operators[0];
                if (IsOperatorLongAppend(s)) identicalCodes = false;
                if (IsOperatorLongNo(s)) identicalCodes = false;
            }
            return identicalCodes;
        }

        private static bool HasIdenticalCodesNew(List<Series> graphVars, PrtHelper ph)
        {
            bool identicalCodes = true;
            for (int varI = 0; varI < graphVars.Count; varI++)  //varI 0-based
            {
                if (ph.elementOptions[varI] != null)
                {
                    identicalCodes = false;
                    break;
                }
            }
            if (ph.operators.Count > 1) identicalCodes = false;
            if (ph.operators.Count == 1)
            {
                string s = ph.operators[0];
                if (IsOperatorLongAppend(s)) identicalCodes = false;
                if (IsOperatorLongNo(s)) identicalCodes = false;
            }
            return identicalCodes;
        }

        private static bool TestNoDuplicateDisplayCode(bool variable, string name)
        {
            if (variable)
            {
                G.Writeln();
                G.Writeln("*** ERROR: There are more than one '" + name + "' display codes");
                throw new GekkoException();
            }
            variable = true;
            return variable;
        }

        private static EOperatorTypes GetOperatorType(List<string> operators)
        {
            EOperatorTypes operatorType = EOperatorTypes.Null;
            bool isVerbose = false;
            foreach (string operator2 in operators)
            {
                if (IsOperatorLong(operator2))
                {
                    if (operatorType == EOperatorTypes.LongVersionHasAppend)
                    {
                        WriteOperatorMismatchError();
                    }
                    operatorType = EOperatorTypes.LongVersionHasYes;
                }
                else if (IsOperatorLongAppend(operator2))
                {
                    if (operatorType == EOperatorTypes.LongVersionHasYes)
                    {
                        WriteOperatorMismatchError();
                    }
                    operatorType = EOperatorTypes.LongVersionHasAppend;
                }
                else if (IsOperatorLongNo(operator2))
                {
                    if (operatorType == EOperatorTypes.Null)
                    {
                        //do not override if others are found
                        operatorType = EOperatorTypes.LongVersionOnlyNo;
                    }
                }
                else if (IsOperatorShort(operator2))
                {
                    if (operatorType == EOperatorTypes.LongVersionHasAppend || operatorType == EOperatorTypes.LongVersionHasYes || operatorType == EOperatorTypes.LongVersionOnlyNo)
                    {
                        G.Writeln();
                        G.Writeln("*** ERROR: You cannot mix display codes of short and long type, for example");
                        G.Writeln("           PRT<p abs> or PRT<d pch=no> etc. Please consult the help file regarding", Color.Red);
                        G.Writeln("           the PRT and MULPRT commands. Short types are n, d, p, m, q, mp and", Color.Red);
                        G.Writeln("           similar, whereas long types are lev, abs, dif, pch, gdif.", Color.Red);
                        throw new GekkoException();
                    }
                    operatorType = EOperatorTypes.ShortVersion;
                }
                else if (G.Equal(operator2, "v"))
                {
                    //in that case, all other print options are suppressed, so you can write MULPRT<v gdif> and only a MULPRT<v> will be issued (this makes it easier to quickly put a 'v' in the optionfield to get a GMULPRT)
                    isVerbose = true;
                }
                else
                {
                    G.Writeln();
                    G.Writeln("*** ERROR: Sorry, internal Gekko error related to operator");
                    throw new GekkoException();
                }
            }
            if (operators.Count == 0)
            {
                operatorType = EOperatorTypes.None;
            }
            if (isVerbose) operatorType = EOperatorTypes.Verbose;  //overrides everything else
            if (operatorType == EOperatorTypes.Null)
            {
                G.Writeln();
                G.Writeln("*** ERROR: Sorry, internal Gekko error related to display codes");
                throw new GekkoException();
            }
            return operatorType;
        }

        public static bool IsOperatorShort(string operator2)
        {
            return G.Equal(operator2, "n") || G.Equal(operator2, "d") || G.Equal(operator2, "p") || G.Equal(operator2, "dp") || G.Equal(operator2, Globals.operator_r) || G.Equal(operator2, Globals.operator_rn) || G.Equal(operator2, Globals.operator_rd) || G.Equal(operator2, Globals.operator_rp) || G.Equal(operator2, Globals.operator_rdp) || G.Equal(operator2, "m") || G.Equal(operator2, "q") || G.Equal(operator2, "mp") || G.Equal(operator2, Globals.operator_l) || G.Equal(operator2, Globals.operator_dl) || G.Equal(operator2, Globals.operator_rl) || G.Equal(operator2, Globals.operator_rdl);
        }

        public static bool IsOperatorShortMultiplier(string operator2)
        {
            return G.Equal(operator2, "m") || G.Equal(operator2, "q") || G.Equal(operator2, "mp") || G.Equal(operator2, "v");
        }

        public static bool IsOperatorShortBase(string operator2)
        {
            return G.Equal(operator2, Globals.operator_r) || G.Equal(operator2, Globals.operator_rn) || G.Equal(operator2, Globals.operator_rd) || G.Equal(operator2, Globals.operator_rp) || G.Equal(operator2, Globals.operator_rdp) || G.Equal(operator2, Globals.operator_rl) || G.Equal(operator2, Globals.operator_rdl);
        }

        public static bool IsOperatorShortWork(string operator2)
        {
            return operator2 == null || G.Equal(operator2, "") || G.Equal(operator2, "n") || G.Equal(operator2, "d") || G.Equal(operator2, "p") || G.Equal(operator2, "dp") || G.Equal(operator2, Globals.operator_l) || G.Equal(operator2, Globals.operator_dl);
        }

        private static bool IsOperatorLongNo(string operator2)
        {
            return G.Equal(operator2, "nolev") || G.Equal(operator2, "noabs") || G.Equal(operator2, "nodif") || G.Equal(operator2, "nopch") || G.Equal(operator2, "nogdif");
        }

        private static bool IsOperatorLongAppend(string operator2)
        {
            return G.Equal(operator2, "_lev") || G.Equal(operator2, "_abs") || G.Equal(operator2, "_dif") || G.Equal(operator2, "_pch") || G.Equal(operator2, "_gdif");
        }

        private static bool IsOperatorLong(string operator2)
        {
            return G.Equal(operator2, "lev") || G.Equal(operator2, "abs") || G.Equal(operator2, "dif") || G.Equal(operator2, "pch") || G.Equal(operator2, "gdif");
        }

        private static void WriteOperatorMismatchError()
        {
            G.Writeln();
            G.Writeln("*** ERROR: You cannot mix display codes of type 'yes' and 'append', for instance");
            G.Writeln("           PRT<pch=yes gdif=append> or the equivalent PRT<pch _gdif>", Color.Red);
            throw new GekkoException();
        }

        public static void PrtClipboard(Table table, bool calledFromCopyButton)
        {
            if (table == null)
            {
                G.Writeln2("*** ERROR: No print or table recorded to put on clipboard");
                throw new GekkoException();
            }
            StringBuilder s = new StringBuilder();

            for (int i = 1; i <= table.GetRowMaxNumber(); i++)
            {
                if (i > 1) s.Append("\n");
                for (int j = 1; j <= table.GetColMaxNumber(); j++)
                {
                    Cell cell2 = table.Get(i, j);
                    string s2 = "";
                    if (cell2 == null)
                    {
                    }
                    else
                    {
                        if (cell2.cellType == CellType.Number)
                        {
                            s2 = PrepareDataForClipboard(cell2.number);
                        }
                        else if (cell2.cellType == CellType.Date)
                        {
                            s2 = cell2.date;
                        }
                        else if (cell2.cellType == CellType.Text)
                        {
                            s2 = cell2.CellText.TextData[0];
                        }
                    }
                    if (j > 1) s.Append("\t");
                    s.Append(s2);
                }
            }
            string ss = s.ToString();
            if (ss != null && ss != "")
            {
                System.Windows.Forms.Clipboard.SetText(ss, System.Windows.Forms.TextDataFormat.Text);
                G.Writeln2("You may now paste (Ctrl-V) cells into your spreadsheet (e.g. Excel)");
                if (calledFromCopyButton)
                {
                    G.Writeln("These are the cells from your last PRT/MULPRT/SHOW or table.");
                }
            }
        }

        public static void PrtToExcelDna(Table table, bool isMulprt, bool isStamp, string title)
        {            
            int extraRows = 0;
            if (isStamp) extraRows++;
            if (title != null) extraRows++;

            int rowsOffset = 0; //not used yet
            int colOffset = 0; //not used yet
            
            object[,] cells = new object[table.GetRowMaxNumber() + rowsOffset + extraRows, table.GetColMaxNumber() + colOffset];

            int extra = 0;
            if (isStamp)
            {
                cells[extra, 0] = GetStamp(isMulprt);
                extra++;
            }
            if (title != null)
            {
                cells[extra, 0] = title;
            }

            for (int i = 0; i < table.GetRowMaxNumber(); i++)
            {                
                for (int j = 0; j < table.GetColMaxNumber(); j++)
                {
                    Cell cell2 = table.Get(i + 1, j + 1);
                    string s2 = "";
                    if (cell2 == null)
                    {
                        //skip
                    }
                    else
                    {
                        int ii = i + rowsOffset + extraRows;
                        int jj = j + colOffset;
                        if (cell2.cellType == CellType.Number)
                        {
                            cells[ii, jj] = cell2.number;
                        }
                        else if (cell2.cellType == CellType.Date)
                        {
                            cells[ii, jj] = cell2.date;
                        }
                        else if (cell2.cellType == CellType.Text)
                        {
                            cells[ii, jj] =  cell2.CellText.TextData[0];
                        }
                    }                    
                }
            }

            Globals.excelDnaData = new ExcelDnaData { cells = cells };
        }

        public static string PrepareDataForClipboard(double d2)
        {
            string s2 = d2.ToString(CultureInfo.InvariantCulture);  //should always be "." with this locale corresponding to US style (is used also for PRT etc)

            if (s2.Contains(",") && s2.Contains("."))
            {
                if (s2.IndexOf(",") < s2.IndexOf("."))
                {
                    //we have at least one "____,____.____", so at least one "," to the left of "."
                    //then we remove the ",", for instance in 12,345,678.22 --> 12345678.22
                    //(If it should happen to be 12.345.678,22 then we would not be here)
                    s2 = s2.Replace(",", "");
                }
            }

            //now s2 should be with "." if there is a decimal (and no thousand grouping)

            if (G.Equal(Program.options.interface_clipboard_decimalseparator, "comma"))
            {
                s2 = s2.Replace(".", ",");
            }
            if (s2 == "9.99999E+99" || s2 == "9,99999E+99"  //I think this is funny number made in Excel printing routine, to signal missing value
                || G.isNumericalError(d2) || d2 == Globals.missingVariableArtificialNumber)  //NumericalError is 'M', and the number Globals.missingVariableArtificialNumber is a signal from a table that variable is non-existing ('N')
            {
                s2 = "=" + NaForExcelInDifferentLanguages(0);
            }
            return s2;
        }

        private static string NaForExcelInDifferentLanguages(int i)
        {
            string s2 = null;
            if (i == 0)
            {
                s2 = "na()";
                if (G.Equal(Program.options.interface_excel_language, "danish")) s2 = "ikke.tilgængelig()";
                return s2;
            }
            else if(i==1)
            {
                s2 = "na()";
            }
            return s2;
        }               

        private static void GraphThreadFunction(Object o)
        {
            GraphOptions graphOptions = (GraphOptions)o;
            Graph g = new Graph(graphOptions);
            Globals.windowsGraph.Add(g);
            if(true)
            {
                //otherwise, setting them checked = true fires a redraw event
                Globals.disableRationButtons = 1;
                g.radioButton1.Checked = graphOptions.po.isLevel;
                g.radioButton2.Checked = graphOptions.po.isLog;
                g.radioButton5.Checked = graphOptions.po.isDiff;
                g.radioButton3.Checked = graphOptions.po.isPch;
                g.radioButton8.Checked = graphOptions.po.isDlog;
                g.checkBox1.Checked = graphOptions.po.isMultiplier;
                Globals.disableRationButtons = 0;
            }

            g.ShowDialog();
            graphOptions.windowIsShown = true;

            //end of graph window
            g.Close();
            g.Dispose();
            g = null;
        }

        private static void MaybeStartPipe2(string fileName)
        {
            if (fileName != null && fileName != "" && !Globals.pipe2)  //is piped to special pipe-file (pipe2), and not already piping to pipe2 (could be case if called via DIFPRT for example)
            {
                //if exception, these will be reset somewhere else, so no need to have a try-catch-finally regarding the file stream
                Globals.pipe2 = true;
                Globals.pipeFileHelper2.pipeFileFileWithPath = CreateFullPathAndFileName(fileName);
                Globals.pipeFileHelper2.pipeFile = G.GekkoStreamWriter(WaitForFileStream(Globals.pipeFileHelper2.pipeFileFileWithPath, GekkoFileReadOrWrite.Write));
            }
        }


        private static string SubstituteEscapeCharacters(string s, bool fromEscapeToArtificialChars)
        {
            if (false)
            {
                //Problem is for instance: "READ c:\folders\#bankname\scenarion"
                //This will be seen a lot.
                //what about &lbrace;  &rbrace;  &hash;
                //or &lbrace$  &rbrace$  &hash$
                //or &lbrace&  &rbrace&  &hash&
                //or {{  }}  ##

                if (fromEscapeToArtificialChars)
                {
                    s = s.Replace("\\{", "<[LEFTCURLY]>");
                    s = s.Replace("\\}", "<[RIGHTCURLY]>");
                    s = s.Replace("\\#", "<[HASHCHARACTER]>");
                    //s = s.Replace("\\'", "<[QUOTE]>");
                }
                else
                {
                    s = s.Replace("<[LEFTCURLY]>", "{");
                    s = s.Replace("<[RIGHTCURLY]>", "}");
                    s = s.Replace("<[HASHCHARACTER]>", "#");
                    //s = s.Replace("<[QUOTE]>", "'");
                }
            }
            return s;
        }

        private static List<string> ExtractEndoExoIndicators(List<string> variables, List<Dictionary<string, string>> precedents)
        {
            List<string> endoExoIndicators = new List<string>();
            for (int i = 0; i < precedents.Count; i++)
            {
                string var = "";
                string endoExo = "";
                Dictionary<string, string> d = precedents[i];

                bool endo = true;
                bool exo = true;
                foreach (string s in d.Keys)
                {
                    string varWithoutLag = G.ExtractOnlyVariableIgnoreLag(s);
                    if (varWithoutLag.StartsWith("@")) varWithoutLag = varWithoutLag.Substring(1);
                    EEndoOrExo type = VariableTypeEndoExo(varWithoutLag);
                    if (type != EEndoOrExo.Endo) endo = false;
                    if (type != EEndoOrExo.Exo) exo = false;
                }
                if (endo)
                {
                    endoExo = "e";
                }
                else if (exo)
                {
                    endoExo = "x";
                }
                else endoExo = " ";
                endoExoIndicators.Add(endoExo);
            }
            if (endoExoIndicators.Count != variables.Count) throw new GekkoException();  //sanity check
            return endoExoIndicators;
        }



        private static void AddListToPrecedentsEtc(List<string> variables, List<string> variablesLabels, List<Dictionary<string, string>> precedents, List<string> unfolded)
        {
            foreach (string listItem in unfolded)
            {
                variables.Add(listItem);
                variablesLabels.Add(listItem);
                Dictionary<string, string> precedentsTemp = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
                precedentsTemp.Add(listItem + Globals.lagIndicator + "0", "");
                precedents.Add(precedentsTemp);
            }
        }

        public static void CreateLeftSideVariableIfNeeded(List<Dictionary<string, string>> precedentsWithLagIndicator, string variable)
        {
            //variable = SubstituteAssignVars(variable);
            if (Program.databanks.GetFirst().GetIVariable(variable) == null)
            {
                if (!variable.ToLower().StartsWith("xx"))
                {
                    IssueCreateWarning(variable);
                }
                G.Writeln("+++ NOTE: Variable " + variable + " not found in databank -- is created");
                Series tempTs = new Series(Program.options.freq, variable);
                Program.databanks.GetFirst().AddIVariable(tempTs.name, tempTs);

                for (int i = 0; i < precedentsWithLagIndicator.Count; i++)
                {
                    Dictionary<string, string> d = precedentsWithLagIndicator[i];
                    foreach (string prec in d.Keys)
                    {
                        string variable2 = "";
                        int lag = 0;

                        if (prec.Contains(Globals.lagIndicator + Globals.lagIndicator))
                        {
                            //drop to issue this warning if this is the case: genr nyvar = nyvar(2001m1) $
                            //that will give NaN with no warning/explanation given.
                        }
                        else
                        {
                            G.ExtractVariableAndLag(prec, out variable2, out lag);
                            if (G.Equal(variable, variable2) && lag != 0)
                            {
                                G.Writeln("+++ WARNING: The non-existing variable " + variable + " appears with lag or leads on right hand side -- so this will produce missing values");
                                break;
                            }
                        }
                    }
                }
            }
        }

        private static void IssueCreateWarning(string variable)
        {
            G.Writeln();
            G.Writeln("*** ERROR: You are trying to put data into a variable or list ('" + variable + "') that does not exist.");
            G.Writeln("           Please create the variable or list first (CREATE or LIST command), or use a");
            G.Writeln("           name that starts with the characters 'xx'.");
            
        }


        public static EMissingType CheckVariableExistence(List<string> variablesLabelsForPrtCommand, List<Dictionary<string, string>> precedents, bool isMultiplier, bool isCalledFromGenr, bool isBaseline, bool isCalledFromTable)
        {
            if (!(G.Equal(Program.databanks.GetFirst().name, Globals.Work) && G.Equal(Program.databanks.GetRef().name, Globals.Ref)))
            {
                G.Writeln2("*** ERROR: Please use Work and " + Globals.Ref + " as first and reference databanks");
                throw new GekkoException();
            }
            //In the method below, any memory vars of VAL type will be removed
            //if (isCalledFromGenr) SubstituteAssignVarsInPrecedents(precedents);  //a bit slow for GENR maybe... for PRT etc. it has already been called when this method is called
            bool hasIssuedWarning = false;
            Dictionary<string, string> problem = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
            for (int i = 0; i < precedents.Count; i++)
            {
                Dictionary<string, string> d = precedents[i];
                foreach (string s in d.Keys)
                {
                    List<string> banks = new List<string>();

                    string varWithBaseBankIndicator = G.ExtractOnlyVariableIgnoreLag(s);  //TODO: will produce dublets if "p fy/fy(-1)" or "p fy fm/fy" , but never mind now

                    string[] split = null;
                    if (varWithBaseBankIndicator.Contains(":"))
                    {
                        //p<m>adam:fy
                        split = varWithBaseBankIndicator.Split(':');
                        banks.Add(split[0]);
                    }
                    else
                    {

                        if (isMultiplier)
                        {
                            if (varWithBaseBankIndicator.StartsWith("@"))
                            {
                                //p<m>@fy                --------- this is not really meaningful
                                banks.Add(Globals.Ref);
                                if (!hasIssuedWarning) G.Writeln("+++ WARNING: Note that you are using @-variables in combination with the <m> (multiplier) option");
                                hasIssuedWarning = true;
                            }
                            else
                            {
                                //p<m>fy
                                banks.Add(Globals.Work);
                                banks.Add(Globals.Ref);
                            }
                        }
                        else
                        {
                            if (isBaseline)
                            {
                                if (varWithBaseBankIndicator.StartsWith("@"))
                                {
                                    //p<b>@fy                --------- this is not really meaningful
                                    banks.Add(Globals.Ref);
                                    if (!hasIssuedWarning) G.Writeln("+++ WARNING: Note that you are using @-variables in combination with the <r> (reference) option");
                                    hasIssuedWarning = true;
                                }
                                else
                                {
                                    //p<b>fy
                                    banks.Add(Globals.Ref);
                                }
                            }
                            else
                            {
                                if (varWithBaseBankIndicator.StartsWith("@"))
                                {
                                    //p @fy
                                    banks.Add(Globals.Ref);
                                }
                                else
                                {
                                    //p fy
                                    banks.Add(Globals.Work);
                                }
                            }
                        }
                    }

                    string variableName = varWithBaseBankIndicator;
                    if (variableName.StartsWith("@"))
                    {
                        variableName = variableName.Substring(1);
                    }
                    else if (varWithBaseBankIndicator.Contains(":"))
                    {
                        variableName = split[1];
                    }

                    foreach (string bank in banks)
                    {
                        bool noBank = false;
                        if (Program.databanks.GetDatabank(bank) == null) noBank = true;
                        if (noBank || Program.databanks.GetDatabank(bank).GetIVariable(variableName) == null)
                        {
                            if (!problem.ContainsKey(varWithBaseBankIndicator))
                            {
                                problem.Add(varWithBaseBankIndicator, "");
                                string ss = "";
                                if (variablesLabelsForPrtCommand != null && !G.Equal(variableName, variablesLabelsForPrtCommand[i])) ss = " -- " + variablesLabelsForPrtCommand[i];
                                if (isCalledFromTable && Program.options.series_normal_table_missing != ESeriesMissing.Error)
                                {
                                }
                                else
                                {
                                    G.Writeln("*** ERROR: Could not find variable '" + variableName + "' (freq = " + Program.options.freq + ") in '" + bank + "' databank" + ss);
                                    if (noBank)
                                    {
                                        G.Writeln("           The databank '" + bank + "' does not seem to exist", Color.Red);
                                    }
                                }
                            }
                        }
                    }
                }
            }
            if (isCalledFromTable && Program.options.series_normal_table_missing != ESeriesMissing.Error)
            {
                if (problem.Count > 0)
                {
                    return EMissingType.HasMissingVariables;
                }
                else
                {
                    return EMissingType.Ok;
                }
            }
            else
            {
                if (problem.Count > 0)
                {
                    throw new GekkoException();
                }
            }
            return EMissingType.Ok;
        }
        

        private static void PrintFirstLineLabels(List<string> rememberWriteStatements, List<string> graphVarsLabels, PrintHelper ph, int numberOfLabelsRows, string[,] labelsArray, List<string> endoExoIndicators)
        {
            for (int i2 = 0; i2 < numberOfLabelsRows; i2++)
            {
                string line = "";
                int i = numberOfLabelsRows - i2 - 1;  //the labels in labelsArray are in reverted order.
                line += G.Blanks(ph.widthDate);
                for (int j = 0; j < graphVarsLabels.Count; j++)
                {
                    line += "  " + G.Blanks(ph.widthLabel - labelsArray[i, j].Length) + labelsArray[i, j];
                    if (ph.width2 > 0)
                    {
                        if (i == 0)
                        {
                            if (endoExoIndicators[j] == " ")
                            {
                                line += "  %";
                            }
                            else
                            {
                                line += " " + "%" + endoExoIndicators[j].ToUpper();
                            }
                        }
                        else
                        {
                            line += "   ";
                        }
                    }
                }
                rememberWriteStatements.Add(line);
            }
        }

        private static int PrintCreateLabelsArrayNew(string label, int width, int numberOfLabelsRowsMax, int maxLength, out List<string> labelsArray)
        {
            //labelsArray = new string[numberOfLabelsRowsMax];

            labelsArray = new List<string>(new string[numberOfLabelsRowsMax]);            

            int numberOfLabelsRows = -12345;

            //string label = graphVarsLabels[j];
            string ss = label;
            ss = TruncateTextWithDots(maxLength, ss);

            if (numberOfLabelsRowsMax == 1)  //for some reason, this case must be treated specially... (not sure why)
            {
                numberOfLabelsRows = 1;
                labelsArray[0] = ss;
            }
            else
            {
                for (int i = 0; i < numberOfLabelsRowsMax; i++)
                {
                    //chopping off text backwards
                    if (ss == null) continue;
                    int start = ss.Length - width;
                    string s = "";
                    if (start >= 0)
                    {
                        s = ss.Substring(start);
                        ss = ss.Substring(0, ss.Length - s.Length);  //cropping s off
                    }
                    else
                    {
                        if (ss.Length > 0) s = ss;
                        ss = "[[]]";
                    }
                    labelsArray[i] = s;
                    if (labelsArray[i] != "" && labelsArray[i] != "[[]]")
                    {
                        if (i + 1 > numberOfLabelsRows) numberOfLabelsRows = i + 1;
                    }
                }
            }

            return numberOfLabelsRows;
        }

        private static string TruncateTextWithDots(int maxLength, string ss)
        {
            if (ss == null) return ss;
            if (ss.Length > maxLength)
            {
                if (maxLength >= 3)
                {
                    ss = ss.Substring(0, maxLength - 3);
                    ss += "...";
                }
                else ss = ss.Substring(0, maxLength);   //almost absurd... maxlength should always be >= 3 (typically 100)
            }

            return ss;
        }

        private static int PrintCreateLabelsArray(List<string> graphVarsLabels, PrintHelper ph, int numberOfLabelsRowsMax, int numberOfLabelsRows, int maxLength, string[,] labelsArray)
        {
            for (int j = 0; j < graphVarsLabels.Count; j++)
            {
                string label = graphVarsLabels[j];
                string ss = label;
                if (ss.Length > maxLength)
                {
                    if (maxLength >= 3)
                    {
                        ss = ss.Substring(0, maxLength - 3);
                        ss += "...";
                    }
                    else ss = ss.Substring(0, maxLength);   //almost absurd... maxlength should always be >= 3 (typically 100)
                }
                for (int i = 0; i < numberOfLabelsRowsMax; i++)
                {
                    //chopping off text backwards
                    int start = ss.Length - ph.widthLabel;
                    string s = "";
                    if (start >= 0)
                    {
                        s = ss.Substring(start);
                        ss = ss.Substring(0, ss.Length - s.Length);  //cropping s off
                    }
                    else
                    {
                        if (ss.Length > 0) s = ss;
                        ss = "";
                    }
                    labelsArray[i, j] = s;
                    if (labelsArray[i, j] != "")
                    {
                        if (i + 1 > numberOfLabelsRows) numberOfLabelsRows = i + 1;
                    }
                }
            }
            return numberOfLabelsRows;
        }

        
        private static void CallGnuplot(PlotTable plotTable, O.Prt o, List<O.Prt.Element> containerExplode, EFreq highestFreq)
        {
            //Måske en SYS gnuplot til at starte et vindue op.
            //See #23475432985 regarding options that default = no, and are activated with empty node like <boxstack/>

            //========================================================================================================
            //                          FREQUENCY LOCATION, indicates where to implement more frequencies
            //========================================================================================================
            
            string extension = "emf";
            if (o.opt_filename != null)
            {
                extension = Path.GetExtension(o.opt_filename);
                if (extension.StartsWith(".")) extension = extension.Substring(1);
                if (extension == "")
                {
                    o.opt_filename = AddExtension(o.opt_filename, ".emf");
                    extension = "emf";
                }
                if (!G.Equal(extension, "emf") && !G.Equal(extension, "png") && !G.Equal(extension, "svg") && !G.Equal(extension, "pdf"))
                {
                    G.Writeln2("*** ERROR: In PLOT, expected file type is emf, png, svg or pdf");
                    throw new GekkoException();
                }
                extension = extension.ToLower().Trim();  //gnuplot does not like upper-case file types
            }

            //bool isInside = true;
            //bool test2 = false;
            int count = containerExplode.Count;
            bool firstXLabelFix = true;

            bool isInside = false;  //corresponds to at
            if (highestFreq == EFreq.A || highestFreq == EFreq.U)
            {
                //annual
                if (G.Equal(Program.options.plot_xlabels_annual, "between")) isInside = true;
            }
            else
            {
                //nonannual
                if (G.Equal(Program.options.plot_xlabels_nonannual, "between")) isInside = true;
            }

            //https://groups.google.com/forum/#!topic/comp.graphics.apps.gnuplot/csbgSFAbIv4

            double zoom = 1d;
            double fontfactor = 1d;
            
            //make as wpf window, detect dpi on screen at set size accordingly (http://stackoverflow.com/questions/5977445/how-to-get-windows-display-settings)
            
            if (count == 0)
            {
                G.Writeln2("*** ERROR: PLOT called with 0 variables");
                throw new GekkoException();
            }
            int numberOfObs = GekkoTime.Observations(o.t1, o.t2);
            int rr = Program.RandomInt();
            string file1 = "temp" + rr + ".dat";
            string file2 = "temp" + rr + "." + extension;
            string file3 = "temp" + rr + ".gp";
            string heading = "";
            string pplotType = "emf";

            XmlDocument doc = new XmlDocument();
                        
            if (o.opt_using != null || Program.options.plot_using != "")
            {
                XmlDocument doc1 = null;
                XmlDocument doc2 = null;
                
                if (Program.options.plot_using != "")
                {
                    string fileName = Program.options.plot_using;
                    fileName = AddExtension(fileName, ".gpt");
                    fileName = Program.CreateFullPathAndFileNameFromFolder(fileName, null);
                    doc1 = new XmlDocument();
                    string xmlText = GetTextFromFileWithWait(fileName);

                    try
                    {
                        doc1.LoadXml(xmlText);
                    }
                    catch (Exception e)
                    {
                        G.Writeln();
                        G.Writeln("*** ERROR: Plot template file: '" + fileName + "'");
                        WriteXmlError(e, fileName);
                        throw new GekkoException();
                    }
                }

                if (o.opt_using != null)
                {

                    string fileName = o.opt_using;
                    bool cancel = false;
                    if (fileName == "*")
                    {
                        SelectFile("gpt", ref fileName, ref cancel);
                    }
                    if (cancel) return;

                    fileName = AddExtension(fileName, ".gpt");
                    fileName = Program.CreateFullPathAndFileNameFromFolder(fileName, null);
                    doc2 = new XmlDocument();
                    string xmlText = GetTextFromFileWithWait(fileName);

                    try
                    {
                        doc2.LoadXml(xmlText);
                    }
                    catch (Exception e)
                    {
                        G.Writeln();
                        G.Writeln("*** ERROR: Plot template file: '" + fileName + "'");
                        WriteXmlError(e, fileName);
                        throw new GekkoException();
                    }
                }

                if (doc1 != null)
                {
                    //global template
                    
                    if (doc2 != null)
                    {
                        //doc1 = x1, doc2 = x2
                        //XmlNode temp = doc1.ImportNode(doc2, true) as XmlDocument;  --> hmmm does not work, maybe just do it in code, not as a xml merge
                        doc = doc2;
                    }
                    else
                    {
                        //doc1 = x1, doc2 = null
                        doc = doc1;
                    }
                }
                else
                {
                    if (doc2 != null)
                    {
                        //doc1 = null, doc2 = x2
                        doc = doc2;
                    }
                    else
                    {
                        //doc1 = null, doc2 = null
                        //do nothing, doc will be unchanged (empty)
                    }                    
                }
            }

            string currentDir = Directory.GetCurrentDirectory();  //remembered in order to switch back
            string path = System.Windows.Forms.Application.LocalUserAppDataPath + "\\gnuplot\\tempfiles";
            // Determine whether the directory exists.
            if (!Directory.Exists(path))
            {
                Directory.CreateDirectory(path);
            }
            Directory.SetCurrentDirectory(path); //so that gnuplot can access the files

            List<string> labels1 = new List<string>();
            List<string> labels2 = new List<string>();
            string fileGp = path + "\\" + file3;

            string fileData = path + "\\" + file1;
            
            //List<string> tabLines = data.Print();

            //structure of plotTable is (0 has 6 points, 1 has 3, 2 has 4).
            //                dates[0]   dates[1]   dates[2]     values[0]   values[1]   values[2]
            // i = 0             .          .         .              .          .            .
            // i = 1             .          .         .              .          .            .
            // i = 2             .          .         .              .          .            .
            // i = 3             .                    .              .                       .
            // i = 4             .                                   .                        

            int max = int.MinValue;
            for (int j = 0; j < plotTable.dates.Count; j++)
            {
                max = Math.Max(max, plotTable.dates[j].Count);
            }

            using (FileStream fs = WaitForFileStream(fileData, GekkoFileReadOrWrite.Write))
            using (StreamWriter tw = G.GekkoStreamWriter(fs))
            {
                //TODO:
                //In the middle of mixed freq data, there can be a lot of lines like these. Perhaps detect and remove.
                //Perhaps same problem with smpl set too wide on non-mixed freqs.
                //Also, daily data points could be aggregated with min/max for a range on the x axis, if this range corresponds
                //to < 1 pixel on the screen. Still, gnuplot is pretty fast at plotting.
                //1984.44861 M M M M M M M
                //1984.45139 M M M M M M M
                //1984.45417 M M M M M M M
                //1984.45694 M M M M M M M
                //1984.45972 M M M M M M M

                for (int i = 0; i < max; i++)
                {
                    //foreach (string s in tabLines) tw.WriteLine(s);                         
                    for (int j = 0; j < plotTable.dates.Count; j++)
                    {
                        if (i < plotTable.dates[j].Count)
                        {
                            tw.Write(string.Format("{0:0.#####}", plotTable.dates[j][i]) + " "); //width of 1 day is about 0.003 of a year. So 0.00001 is precise compared to that
                        }
                        else
                        {
                            tw.Write("M ");
                        }
                    }
                    for (int j = 0; j < plotTable.values.Count; j++)
                    {
                        if (i < plotTable.values[j].Count && !G.isNumericalError(plotTable.values[j][i]))
                        {
                            tw.Write(plotTable.values[j][i].ToString() + " ");
                        }
                        else
                        {
                            tw.Write("M ");
                        }
                    }
                    tw.WriteLine();
                }
            }
            
            XmlNodeList lines3 = doc.SelectNodes("gekkoplot/lines/line");
                    
            // ---------------------------------------------
            // --------- loading main section start
            // ---------------------------------------------

            string size2 = GetText(null, o.opt_size, null, doc.SelectSingleNode("gekkoplot/size"), null);
            string title = GetText(null, o.opt_title, null, doc.SelectSingleNode("gekkoplot/title"), null);
            string subtitle = GetText(null, o.opt_subtitle, null, doc.SelectSingleNode("gekkoplot/subtitle"), null);
            string font = GetText(null, o.opt_font, null, doc.SelectSingleNode("gekkoplot/font"), "Verdana");
            double fontsize = ParseIntoDouble(GetText(null, G.isNumericalError(o.opt_fontsize) ? null : o.opt_fontsize.ToString(), null, doc.SelectSingleNode("gekkoplot/fontsize"), "12"));
            string bold = GetText(null, o.opt_bold, null, doc.SelectSingleNode("gekkoplot/bold"), null);
            string italic = GetText(null, o.opt_italic, null, doc.SelectSingleNode("gekkoplot/italic"), null);
            string ticsInOut = GetText(null, o.opt_tics, null, doc.SelectSingleNode("gekkoplot/tics"), "out");
            string grid = GetText(null, o.opt_grid, null, doc.SelectSingleNode("gekkoplot/grid"), "yes");  //normally null or "" --> grid. Switch off with <grid>no</grid>                        
            string gridstyle = GetText(null, o.opt_gridstyle, null, doc.SelectSingleNode("gekkoplot/gridstyle"), "linecolor rgb \"#d3d3d3\" dashtype 3 linewidth 1.5");
            string key = GetText(null, o.opt_key, null, doc.SelectSingleNode("gekkoplot/key"), "out horiz bot center Left reverse height 1");  //height 1 givers nicer vertical spacing
            string palette = GetText(null, o.opt_palette, null, doc.SelectSingleNode("gekkoplot/palette"), "red,web-green,web-blue,orange,dark-blue,magenta,brown4,dark-violet,grey50,black");
            string stack = GetText(null, o.opt_stack, null, doc.SelectSingleNode("gekkoplot/stack"), "no");  //default: no, #23475432985    
            double boxwidth = ParseIntoDouble(GetText(null, G.isNumericalError(o.opt_boxwidth) ? null : o.opt_boxwidth.ToString(), null, doc.SelectSingleNode("gekkoplot/boxwidth"), "0.75"));
            string boxgap = GetText(null, G.isNumericalError(o.opt_boxgap) ? null : o.opt_boxgap.ToString(), null, doc.SelectSingleNode("gekkoplot/boxgap"), "2");
            string separate = GetText(null, o.opt_separate, null, doc.SelectSingleNode("gekkoplot/separate"), "no"); //default: no, #23475432985                        

            List<string> xlines = GetText(doc.SelectNodes("gekkoplot/xline"));
            if (!o.opt_xline.IsNull()) xlines.Add(o.opt_xline.ToString());
            List<string> xlinebefores = GetText(doc.SelectNodes("gekkoplot/xlinebefore"));
            if (!o.opt_xlinebefore.IsNull()) xlinebefores.Add(o.opt_xlinebefore.ToString());
            List<string> xlineafters = GetText(doc.SelectNodes("gekkoplot/xlineafter"));
            if (!o.opt_xlineafter.IsNull()) xlineafters.Add(o.opt_xlineafter.ToString());

            string ymirror = GetText(null, o.opt_ymirror, null, doc.SelectSingleNode("gekkoplot/ymirror"), "0"); //y2 mirror could be either no (0), tics (1), tics+labels (2), tics+labels+axislabel (3). With grid set, the mirror is not so important.
            string ytitle = GetText(null, o.opt_ytitle, null, doc.SelectSingleNode("gekkoplot/ytitle"), null);
            string y2title = GetText(null, o.opt_y2title, null, doc.SelectSingleNode("gekkoplot/y2title"), null);
            List<string> ylines = GetText(doc.SelectNodes("gekkoplot/yline"));
            if (!G.isNumericalError(o.opt_yline)) ylines.Add(o.opt_yline.ToString());
            List<string> y2lines = GetText(doc.SelectNodes("gekkoplot/y2line"));
            if (!G.isNumericalError(o.opt_y2line)) y2lines.Add(o.opt_y2line.ToString());

            string ymax = GetText(null, o.opt_ymax.ToString(), null, doc.SelectSingleNode("gekkoplot/ymax"), null);
            string ymaxsoft = GetText(null, o.opt_ymaxsoft.ToString(), null, doc.SelectSingleNode("gekkoplot/ymaxsoft"), null);
            string ymaxhard = GetText(null, o.opt_ymaxhard.ToString(), null, doc.SelectSingleNode("gekkoplot/ymaxhard"), null);
            string y2max = GetText(null, o.opt_y2max.ToString(), null, doc.SelectSingleNode("gekkoplot/y2max"), null);
            string y2maxsoft = GetText(null, o.opt_y2maxsoft.ToString(), null, doc.SelectSingleNode("gekkoplot/y2maxsoft"), null);
            string y2maxhard = GetText(null, o.opt_y2maxhard.ToString(), null, doc.SelectSingleNode("gekkoplot/y2maxhard"), null);

            string ymin = GetText(null, o.opt_ymin.ToString(), null, doc.SelectSingleNode("gekkoplot/ymin"), null);
            string yminsoft = GetText(null, o.opt_yminsoft.ToString(), null, doc.SelectSingleNode("gekkoplot/yminsoft"), null);
            string yminhard = GetText(null, o.opt_yminhard.ToString(), null, doc.SelectSingleNode("gekkoplot/yminhard"), null);
            string y2min = GetText(null, o.opt_y2min.ToString(), null, doc.SelectSingleNode("gekkoplot/y2min"), null);
            string y2minsoft = GetText(null, o.opt_y2minsoft.ToString(), null, doc.SelectSingleNode("gekkoplot/y2minsoft"), null);
            string y2minhard = GetText(null, o.opt_y2minhard.ToString(), null, doc.SelectSingleNode("gekkoplot/y2minhard"), null);

            string xzeroaxis = GetText(null, o.opt_xzeroaxis, null, doc.SelectSingleNode("gekkoplot/xzeroaxis"), "yes");
            string x2zeroaxis = GetText(null, o.opt_x2zeroaxis, null, doc.SelectSingleNode("gekkoplot/x2zeroaxis"), "no"); //default: no, #23475432985 

            //the options in <lines> may override this.
            XmlNode linetypeMain = doc.SelectSingleNode("gekkoplot/type");
            XmlNode dashtypeMain = doc.SelectSingleNode("gekkoplot/dashtype");
            XmlNode linewidthMain = doc.SelectSingleNode("gekkoplot/linewidth");
            XmlNode linecolorMain = doc.SelectSingleNode("gekkoplot/linecolor");
            XmlNode pointtypeMain = doc.SelectSingleNode("gekkoplot/pointtype");
            XmlNode pointsizeMain = doc.SelectSingleNode("gekkoplot/pointsize");
            XmlNode fillstyleMain = doc.SelectSingleNode("gekkoplot/fillstyle");

            List<string> labels = GetText(doc.SelectNodes("gekkoplot/label"));
            List<string> arrows = GetText(doc.SelectNodes("gekkoplot/arrows"));

            // ---------------------------------------------
            // --------- loading main section end
            // ---------------------------------------------

            bool stacked = false;
            if (NotNullAndNotNo(stack)) stacked = true; //#23475432985

            List<string> palette2 = null;
            if (palette != null) palette2 = new List<string>(palette.Split(','));
            if (palette2 == null || palette2.Count == 0)
            {
                //this should not be possible, but in any case...
                G.Writeln2("*** ERROR: PLOT gpt palette is empty");
                throw new GekkoException();
            }
            
            bool isSeparated = NotNullAndNotNo(separate);  //#23475432985
                        
            double linewidthCorrection = 1d;
            double pointsizeCorrection = 1d;
            if (G.Equal(extension, "svg") || G.Equal(extension, "png"))
            {
                linewidthCorrection = 2d / 3d;
                pointsizeCorrection = 0.8d / 0.5d;
            }
            else if (G.Equal(extension, "pdf"))
            {
                linewidthCorrection = 2d / 3d;
                pointsizeCorrection = 2d / 3d;
            }


            List<int> boxesY = new List<int>();
            List<int> boxesY2 = new List<int>();
            List<int> areasY = new List<int>();
            List<int> areasY2 = new List<int>();

            int numberOfY2s = 0; //not used in first pass, but gathered
            double histoGap = double.NaN;  //not used in first pass
            double d_width = double.NaN;  //not used in first pass
            double d_width2 = double.NaN;  //not used in first pass
            double d_width3 = double.NaN;  //not used in first pass
            double left = double.NaN;  //not used in first pass
            double[] minMax = new double[6]; minMax[0] = double.MaxValue; minMax[1] = double.MinValue; minMax[2] = double.MaxValue; minMax[3] = double.MinValue; minMax[4] = double.MaxValue; minMax[5] = double.MinValue;

            // ---------------------------------------
            // ---------------------------------------
            //          FIRST PASS
            //       first pass just counts
            //       boxes, filledcurves, and
            //       a few other things.
            // ---------------------------------------
            // ---------------------------------------

            //double[] dataMin = new double[containerExplode.Count];
            //double[] dataMax = new double[containerExplode.Count];
            List<string> labelsNonBroken = new List<string>();
            for (int j = 0; j < count; j++)
            {                
                string label = "";
                if (containerExplode[j].labelOLD[0] != null) label = containerExplode[j].labelOLD[0];
                labelsNonBroken.Add(label);
            }

            double[] dataMin = new double[containerExplode.Count];
            double[] dataMax = new double[containerExplode.Count];
            //List<string> labelsNonBroken = new List<string>();
            for (int j = 0; j < count; j++)
            {
                double min2 = double.MaxValue;
                double max2 = double.MinValue;
                foreach (double d in plotTable.values[j])
                {
                    if (!G.isNumericalError(d))
                    {
                        min2 = Math.Min(min2, d);
                        max2 = Math.Max(max2, d);
                    }
                }

                dataMin[j] = min2;
                dataMax[j] = max2;
            }

            string discard = PlotHandleLines(true, ref numberOfY2s, minMax, dataMin, dataMax, o, count, labelsNonBroken, file1, lines3, boxesY, boxesY2, areasY, areasY2, linetypeMain, dashtypeMain, linewidthMain, linecolorMain, pointtypeMain, pointsizeMain, fillstyleMain, stacked, palette2, isSeparated, d_width, d_width2, d_width3, left, containerExplode, linewidthCorrection, pointsizeCorrection, isInside, highestFreq);
            
            StringBuilder txt = new StringBuilder();
                        
            txt.AppendLine("set size " + zoom + "," + zoom + "");
            txt.AppendLine("set encoding iso_8859_1");
            txt.AppendLine("set format y " + Globals.QT + "%g" + Globals.QT);  //uses for instance 1.65e+006, not trying to put uppercase exponent which fails in emf terminal
            txt.AppendLine("set format y2 " + Globals.QT + "%g" + Globals.QT);  //uses for instance 1.65e+006, not trying to put uppercase exponent which fails in emf terminal
            txt.AppendLine("set datafile missing \"NaN\"");

            int ii = 0;
            foreach (string s in key.ToLower().Split(' '))
            {
                if (s.StartsWith("out")) ii++;
                if (s.StartsWith("bot")) ii++;
            }            

            string enhanced = null;
            string pdfSize = null;
            if (G.Equal(extension, "emf") || G.Equal(extension, "pdf"))
            {
                enhanced = " enhanced";
                fontsize = 0.95 * fontsize;
                if (G.Equal(extension, "pdf"))
                {
                    pdfSize = " size 4, 3";  //default is 5 x 3 inches, too wide.
                }
            }
            else
            {
                fontsize = 0.75 * fontsize;
            }
            
            txt.AppendLine("set terminal " + extension + enhanced + " font '" + font + "," + (zoom * fontsize) + "'" + pdfSize); ;            

            txt.AppendLine("set output \"" + file2 + "\"");
            txt.AppendLine("set key " + key);            

            if (G.Equal(Program.options.plot_decimalseparator, "comma"))
            {
                txt.AppendLine("set decimalsign ','");
            }
            
            if (G.Equal(extension, "emf"))
            {
                fontfactor = 1.4d / 1.2d;
            }
            else if (G.Equal(extension, "svg"))
            {
                fontfactor = 1.4d / 1.2d;
            }
            else if (G.Equal(extension, "png"))
            {
                fontfactor = 1.0d / 1.2d;
            }
            else if (G.Equal(extension, "pdf"))
            {
                fontfactor = .8d;
            }

            double siz1 = (1.5d * zoom * fontsize * fontfactor);
            double siz2 = (zoom * fontsize * fontfactor);

            string bold2 = "";
            if (bold != null) bold2 = bold.Replace(" ", "").ToLower();
            string[] bold3 = bold2.Split(',');
            foreach (string s in bold3)
            {
                if (s.Trim() == "") continue;  //can contain empty entry
                if (s != "title" && s != "ytitle" && s != "xtics" && s != "ytics" && s != "key")
                {
                    G.Writeln2("*** ERROR: <bold = '...'> must be title, ytitle, xtics, ytics or key");
                    throw new GekkoException();
                }
            }
            string title_bold = null; if (bold3.Contains("title")) title_bold = " Bold";
            string ytitle_bold = null; if (bold3.Contains("ytitle")) ytitle_bold = " Bold";            
            string xtics_bold = null; if (bold3.Contains("xtics")) xtics_bold = " Bold";
            string ytics_bold = null; if (bold3.Contains("ytics")) ytics_bold = " Bold";
            string key_bold = null; if (bold3.Contains("key")) key_bold = " Bold";

            string italic2 = "";
            if (italic != null) italic2 = italic.Replace(" ", "").ToLower();
            string[] italic3 = italic2.Split(',');
            string title_italic = null; if (italic3.Contains("title")) title_italic = " Italic";
            string ytitle_italic = null; if (italic3.Contains("ytitle")) ytitle_italic = " Italic";
            string xtics_italic = null; if (italic3.Contains("xtics")) xtics_italic = " Italic";
            string ytics_italic = null; if (italic3.Contains("ytics")) ytics_italic = " Italic";
            string key_italic = null; if (italic3.Contains("key")) key_italic = " Italic";
            foreach (string s in italic3)
            {
                if (s.Trim() == "") continue;  //can contain empty entry
                if (s != "title" && s != "ytitle" && s != "xtics" && s != "ytics" && s != "key")
                {
                    G.Writeln2("*** ERROR: <italic = '...'> must be title, ytitle, xtics, ytics or key");
                    throw new GekkoException();
                }
            }

            txt.AppendLine("set title font " + "'" + font + title_bold + title_italic + "," + siz1 + "'");
            txt.AppendLine("set ylabel font " + "'" + font + ytitle_bold + ytitle_italic + "," + siz2 + "'");
            txt.AppendLine("set y2label font " + "'" + font + ytitle_bold + ytitle_italic + "," + siz2 + "'");
            txt.AppendLine("set xtics font " + "'" + font + xtics_bold + xtics_italic + "," + siz2 + "'");
            txt.AppendLine("set ytics font " + "'" + font + ytics_bold + ytics_italic + "," + siz2 + "'");
            if (numberOfY2s > 0 || ymirror == "2" || ymirror == "3") txt.AppendLine("set y2tics font " + "'" + font + ytics_bold + ytics_italic + "," + siz2 + "'");
            txt.AppendLine("set key font " + "'" + font + key_bold + key_italic + "," + siz2 + "'");

            string set_yrange = null;
            string set_y2range = null;
            if (isSeparated)
            {
                double alpha1 = 0.05d;
                double alpha2 = 0.05;
                double beta = 0.30d;
                //linesMin=4, linesmMax=5
                //boxesMin=0, boxesMax=1
                set_yrange = (minMax[4] - (alpha1 + alpha2 + beta) * (minMax[5] - minMax[4])) + ":" + minMax[5];
                set_y2range = (minMax[0] - alpha2 / beta * (minMax[1] - minMax[0])) + ":" + (minMax[1] + (1 + alpha1) / beta * (minMax[1] - minMax[0]));
            }
            else
            {
                set_yrange = GnuplotYrange(ymin, yminsoft, yminhard, ymax, ymaxsoft, ymaxhard);
                set_y2range = GnuplotYrange(y2min, y2minsoft, y2minhard, y2max, y2maxsoft, y2maxhard);
            }

            if (set_yrange.Trim() != ":") txt.AppendLine("set yrange [" + set_yrange + "]");
            if (set_y2range.Trim() != ":") txt.AppendLine("set y2range [" + set_y2range + "]");

            
                if ((highestFreq == EFreq.A || highestFreq == EFreq.U))                
                {
                    //annual or undated
                    if (numberOfObs > 140)
                    {
                        txt.AppendLine("set xtics 20");
                        txt.AppendLine("set mxtics 20");
                    }
                    else if (numberOfObs > 70)
                    {
                        txt.AppendLine("set xtics 10");
                        txt.AppendLine("set mxtics 10");
                    }
                    else
                    {
                        txt.AppendLine("set xtics 5");
                        txt.AppendLine("set mxtics 5");
                    }
                }
            

            //txt.AppendLine("set xtic scale 1.7, 0.85");
            txt.AppendLine("set xtic scale 2, 0.7");
            txt.AppendLine("set xtics nomirror " + ticsInOut + "");

            if (NotNullAndNotNo(xzeroaxis)) txt.AppendLine("set xzeroaxis lt -1"); //draws x axis. May get ugly if residuals are present.

            bool setTitlePlaceholder = false;
            if (numberOfY2s == 0 && !isSeparated)
            {
                //the y2 axis is just mirrored
                if (ymirror == "0")  //nothing
                {
                    txt.AppendLine("set ytics nomirror " + ticsInOut);
                    txt.AppendLine("set border 3");                    
                    if (!G.NullOrBlanks(ytitle)) setTitlePlaceholder = SetYAxisText(ytitle, txt, "'" + font + ytitle_bold + ytitle_italic + "," + siz2 + "'", true);
                   
                }
                else if (ymirror == "1")  //y2 axis
                {
                    txt.AppendLine("set ytics " + ticsInOut);
                    txt.AppendLine("set border 11");                    
                    if (!G.NullOrBlanks(ytitle)) setTitlePlaceholder = SetYAxisText(ytitle, txt, "'" + font + ytitle_bold + ytitle_italic + "," + siz2 + "'", true);
                }
                else if (ymirror == "2")  //y2 axis and y2 tics
                {
                    txt.AppendLine("set ytics " + ticsInOut);
                    txt.AppendLine("set y2tics " + ticsInOut);
                    txt.AppendLine("set border 11");                    
                    if (!G.NullOrBlanks(ytitle)) setTitlePlaceholder = SetYAxisText(ytitle, txt, "'" + font + ytitle_bold + ytitle_italic + "," + siz2 + "'", true);                                    
                }
                else if (ymirror == "3")
                {
                    txt.AppendLine("set ytics " + ticsInOut);  //y2 axis and y2 tics and y2 label
                    txt.AppendLine("set y2tics " + ticsInOut);
                    txt.AppendLine("set border 11");                    
                    if (!G.NullOrBlanks(ytitle)) setTitlePlaceholder = SetYAxisText(ytitle, txt, "'" + font + ytitle_bold + ytitle_italic + "," + siz2 + "'", true);                    
                    if (!G.NullOrBlanks(ytitle)) setTitlePlaceholder = SetYAxisText(ytitle, txt, "'" + font + ytitle_bold + ytitle_italic + "," + siz2 + "'", false);
                }
            }
            else
            {
                //there is a series being shown at the y2 axis
                txt.AppendLine("set ytics nomirror " + ticsInOut);
                txt.AppendLine("set y2tics " + ticsInOut);
                txt.AppendLine("set border 11");                
                if (!G.NullOrBlanks(ytitle)) setTitlePlaceholder = SetYAxisText(ytitle, txt, "'" + font + ytitle_bold + ytitle_italic + "," + siz2 + "'", true);                
                if (!G.NullOrBlanks(y2title)) setTitlePlaceholder = SetYAxisText(y2title, txt, "'" + font + ytitle_bold + ytitle_italic + "," + siz2 + "'", false);
                if (NotNullAndNotNo(x2zeroaxis) || isSeparated) txt.AppendLine("set x2zeroaxis lt -1");  //draws x axis for y2=0, #23475432985 
            }

            //must be after labels
            string subtitle2 = null;
            if (!G.NullOrBlanks(subtitle)) subtitle2 = subtitle;
            if (!G.NullOrBlanks(o.opt_subtitle)) subtitle2 = o.opt_subtitle;
            if (!G.NullOrBlanks(subtitle2)) subtitle2 = "\\n{/*0.80 " + subtitle2 + "}";
            string title2 = null;
            if (!G.NullOrBlanks(title)) title2 = title;
            if (!G.NullOrBlanks(o.opt_title)) title2 = o.opt_title;
            if (!G.NullOrBlanks(title2))
            {
                txt.AppendLine("set title " + Globals.QT + EncodeDanish(GnuplotText(title2 + subtitle2, true)) + Globals.QT);
            }
            else
            {
                if (setTitlePlaceholder) txt.AppendLine("set title " + Globals.QT + " " + Globals.QT);
            }            

            foreach (string s in xlines)
            {
                GekkoTime gt = GekkoTime.FromStringToGekkoTime(s);
                double d = G.FromDateToFloating(gt) + 0.5d + GetXAdjustmentForInsideTics(isInside, highestFreq);                
                txt.AppendLine("set arrow from " + d + ", graph 0 to " + d + ", graph 1 nohead");
            }

            foreach (string s in xlinebefores)
            {
                GekkoTime gt = GekkoTime.FromStringToGekkoTime(s);
                double d = (G.FromDateToFloating(gt) + G.FromDateToFloating(gt.Add(-1))) / 2d + 0.5d + GetXAdjustmentForInsideTics(isInside, highestFreq);
                txt.AppendLine("set arrow from " + d + ", graph 0 to " + d + ", graph 1 nohead");
            }

            foreach (string s in xlineafters)
            {
                GekkoTime gt = GekkoTime.FromStringToGekkoTime(s);
                double d = (G.FromDateToFloating(gt) + G.FromDateToFloating(gt.Add(1))) / 2d + 0.5d + GetXAdjustmentForInsideTics(isInside, highestFreq);
                txt.AppendLine("set arrow from " + d + ", graph 0 to " + d + ", graph 1 nohead");
            }

            foreach (string s in ylines)
            {
                double d = ParseIntoDouble(s);
                if (!G.isNumericalError(d)) txt.AppendLine("set arrow from graph 0, first " + d + " to graph 1, first " + d + " nohead");               
            }

            foreach (string s in y2lines)
            {
                if (numberOfY2s > 0)  //theses lines are ignored if there is no y2 axis shown
                {
                    double d = ParseIntoDouble(s);
                    if (!G.isNumericalError(d)) txt.AppendLine("set arrow from graph 0, second " + d + " to graph 1, second " + d + " nohead");
                }
            }

            if (G.Equal(grid, "yes"))  //it can be an empty <grid/>
            {
                //txt.AppendLine("set style line 102 lc rgb '#d3d3d3' dt 3 lw 1.5");  //line width looks ok in Gekko window, with lw 1 it looks bad there.
                txt.AppendLine("set style line 102 " + gridstyle);  //lt 0 or dt 3 gives ugly lines when viewed in Gekko
                txt.AppendLine("set grid back ls 102");                
            }
            else if (G.Equal(grid, "yline"))
            {
                txt.AppendLine("set style line 102 " + gridstyle);  //lt 0 or dt 3 gives ugly lines when viewed in Gekko
                txt.AppendLine("set grid ytics back ls 102");                
            }
            else if (G.Equal(grid, "xline")) 
            {
                txt.AppendLine("set style line 102 " + gridstyle);  //lt 0 or dt 3 gives ugly lines when viewed in Gekko                
                txt.AppendLine("set grid xtics back ls 102");
            }

            if (isInside)
            {
                HandleXTicsInside(o, highestFreq, firstXLabelFix, txt);
            }
            else
            {
                int mxtics = -12345;
                string ticsTxt = null;
                mxtics = HandleXTicsAt(labels1, labels2, ref ticsTxt, mxtics, highestFreq);
                if (ticsTxt != null) txt.AppendLine(ticsTxt);
            }

            if (o.opt_plotcode != null)
            {
                txt.AppendLine("");
                txt.AppendLine(o.opt_plotcode);  //user code
                txt.AppendLine("");
            }

            //string plotline = null;

            //========================================================================================================
            //                          FREQUENCY LOCATION, indicates where to implement more frequencies
            //========================================================================================================

            double widthForBoxes = 1d;
            if (highestFreq == EFreq.Q)
            {
                widthForBoxes = 1d / 4d;
            }
            else if (highestFreq == EFreq.M)
            {
                widthForBoxes = 1d / 12d;
            }
            else if (highestFreq == EFreq.D)
            {
                widthForBoxes = 1d / 366d;
            }

            histoGap = (int)ParseIntoDouble(boxgap);
            if (boxesY.Count + boxesY2.Count == 1) histoGap = 0;
            d_width = widthForBoxes / (double)(boxesY.Count + boxesY2.Count + histoGap);
            d_width2 = boxwidth * d_width;
            d_width3 = boxwidth * widthForBoxes;
            left = d_width * (double)(boxesY.Count + boxesY2.Count - 1) / 2d;

            if (boxesY.Count + boxesY2.Count + areasY.Count + areasY2.Count > 0)
            {
                txt.AppendLine("f(x) = (sgn(x+1.2345e-30) + 1)/2");  //1 if x > 0, else 0. 1.2345e-30 added to avoid 0 becoming 0.5
            }            
            
            // ---------------------------------------
            // ---------------------------------------
            //          SECOND PASS
            // ---------------------------------------
            // ---------------------------------------
            string plotline = PlotHandleLines(false, ref numberOfY2s, minMax, dataMin, dataMax, o, count, labelsNonBroken, file1, lines3, boxesY, boxesY2, areasY, areasY2, linetypeMain, dashtypeMain, linewidthMain, linecolorMain, pointtypeMain, pointsizeMain, fillstyleMain, stacked, palette2, isSeparated, d_width, d_width2, d_width3, left, containerExplode, linewidthCorrection, pointsizeCorrection, isInside, highestFreq);

            txt.AppendLine(plotline);

            using (FileStream fs = WaitForFileStream(fileGp, GekkoFileReadOrWrite.Write))
            using (StreamWriter tw = G.GekkoStreamWriter(fs))
            {
                tw.WriteLine(txt);
                tw.Flush(); //probably not necessary
                tw.Close(); //probably not necessary
            }

            if (G.Equal(o.opt_dump, "yes"))
            {
                try
                {
                    File.Copy(fileGp, Program.options.folder_working + "\\" + "gekkoplot.gp", true);
                    File.Copy(fileData, Program.options.folder_working + "\\" + "gekkoplot.dat", true);
                    string text = null;
                    text = File.ReadAllText(Program.options.folder_working + "\\" + "gekkoplot.gp");
                    text = text.Replace("temp" + rr, "gekkoplot");
                    File.WriteAllText(Program.options.folder_working + "\\" + "gekkoplot.gp", text);
                    text = File.ReadAllText(Program.options.folder_working + "\\" + "gekkoplot.dat");
                    text = text.Replace("temp" + rr, "gekkoplot");
                    File.WriteAllText(Program.options.folder_working + "\\" + "gekkoplot.dat", text);
                    G.Writeln2("Dumped gnuplot files gekkoplot.gp (script) and gekkoplot.dat (data) in the working folder");
                    
                }
                catch
                {
                    G.Writeln2("+++ WARNING: PLOT<dump> failed: are gekkoplot.gp or gekkoplot.dat blocked?");
                }
            }

            string emfName = path + "\\" + file2;
            string exe = "wgnuplot51.exe";

            Process p = new Process();
            if (G.IsUnitTesting())
            {
                p.StartInfo.FileName = Globals.ttPath2 + "\\" + Globals.ttPath3 + @"\Gekko\bin\Debug\gnuplot\" + exe;                
            }
            else
            {
                p.StartInfo.FileName = Application.StartupPath + "\\gnuplot\\" + exe;
            }
            //NOTE: quotes added because this path may contain blanks
            p.StartInfo.Arguments = Globals.QT + path + "\\" + file3 + Globals.QT;
            bool msg = false;
            bool exited = false;
            try
            {
                p.Start();
                exited = p.WaitForExit(1 * 60 * 1000);  //1 minute, has been > 5 sec at DORS
                if (!exited)
                {
                    MessageBox.Show("*** ERROR: The gnuplot call did not respond within 60 seconds, so the " + G.NL + "gnuplot call was aborted.");
                    msg = true;
                    throw new GekkoException();
                }
                else if (p.ExitCode != 0)
                {
                    MessageBox.Show("*** ERROR: The generated gnuplot script file had an unexpected error. If you use PLOT<dump>, Gekko will dump \nthe files gekkoplot.gp and gekkoplot.dat in the working folder. \nThese files can be tried out in gnuplot 5.1, to locate the error \n(by means of 'load gekkoplot.gp' in gnuplot).");
                    msg = true;
                    throw new GekkoException();
                }
            }
            catch (Exception e)
            {
                if (exited && !msg)
                {
                    MessageBox.Show("*** ERROR: There was a internal problem calling gnuplot." + G.NL + "ERROR: " + e.Message);
                }
                throw;
            }

            p.Close();
            //resets current dir to previous location
            Directory.SetCurrentDirectory(currentDir);

            if (o.opt_filename != null && o.opt_filename != "")
            {
                string fileNameWithPath = CreateFullPathAndFileName(o.opt_filename);
                WaitForFileCopy(emfName, fileNameWithPath);
                G.Writeln2("PLOT created file " + fileNameWithPath);
                return;
            }

            o.emfName = emfName;

            if (!o.guiGraphIsRefreshing)
            {
                PrtOptionsHelper po = new PrtOptionsHelper();

                string code = null;
                List<OptString> codes = o.operators;
                if (codes.Count == 1 && G.Equal(codes[0].s2, "yes")) code = codes[0].s1;

                if (code != null)
                {
                    if (G.Equal(code, "m"))
                    {
                        po.isLevel = false;
                        po.isDiff = true;
                        po.isPch = false;
                        po.isMultiplier = true;
                    }
                    else if (G.Equal(code, "q"))
                    {
                        po.isLevel = false;
                        po.isDiff = false;
                        po.isPch = true;
                        po.isMultiplier = true;
                    }
                    else if (G.Equal(code, "d") || G.Equal(code, "rd"))
                    {
                        po.isLevel = false;
                        po.isDiff = true;
                        po.isPch = false;
                        po.isMultiplier = false;
                    }
                    else if (G.Equal(code, "p") || G.Equal(code, "rp"))
                    {
                        po.isLevel = false;
                        po.isDiff = false;
                        po.isPch = true;
                        po.isMultiplier = false;
                    }
                }
                else
                {
                    po.isLevel = true;                    
                    po.isDiff = false;
                    po.isPch = false;                    
                    po.isMultiplier = false;
                }
                po.isLog = false;
                po.isDlog = false;

                GraphOptions graphOptions = new GraphOptions();
                graphOptions.counter = o.counter;
                graphOptions.localBanks = null;
                graphOptions.emfName = emfName;
                graphOptions.po = po;
                graphOptions.pph = null;
                graphOptions.precedents = null;
                graphOptions.tEnd = o.t2;
                graphOptions.tStart = o.t1;
                graphOptions.graphVars = null;
                graphOptions.graphVarsNames = labelsNonBroken;
                graphOptions.title = null;
                graphOptions.printCsCounter = o.printCsCounter;

                //G.Writeln("Calling gnuplot2");

                Thread thread = new Thread(new ParameterizedThreadStart(GraphThreadFunction));
                thread.SetApartmentState(ApartmentState.STA);
                thread.CurrentCulture = CultureInfo.InvariantCulture;
                //thread.CurrentCulture = new System.Globalization.CultureInfo("en-US");  //gets . instead of , in doubles
                thread.Start(graphOptions);

                //Also see #9237532567
                //This stuff makes sure we wait for the window to open, before we move on with the code.
                for (int i = 0; i < 6000; i++)  //up to 60 s, then we move on anyway
                {
                    System.Threading.Thread.Sleep(10);  //0.01s
                    if (graphOptions.windowIsShown)
                    {
                        break;
                    }
                }
            }
            else
            {
                o.guiGraphRefreshingFilename = emfName;
            }
        }

        private static void HandleXTicsInside(O.Prt o, EFreq highestFreq, bool firstXLabelFix, StringBuilder txt)
        {
            //TODO: if there are too many minor tics, turn them off
            //TODO: if years get too cramped, show every second (even)
            //TODO: if years get too cramped, show only 15, 16, 17, not 2015, 2016, 2017
            //TODO: if years are still very cramped, switch to isInside = false!

            //??? what about mixed freqs?? They can either be (a) only annual at-tics, and q and m are without tics
            //                                             or (b) between-tics, showing highest freq if not too many minor, else next-highest.
            //    with mixed freqs we treat is as highest frequency plot, and sneak in the lower freqs.
            //OPTION plot xlabels nonannual = at | between | auto ;  //auto will start with between and then jump to at
            //OPTION plot xlabels annual    = at | between | auto ;  //auto will start with between and then jump to at
            //OPTION plot xlabels between truncate = digits | skip | both | auto ; 

            double extra = 0;

            int t1 = o.t1.super;
            int t2 = o.t2.super;

            //========================================================================================================
            //                          FREQUENCY LOCATION, indicates where to implement more frequencies
            //========================================================================================================

            int numberOfMinorTics = 1;
            if (highestFreq == EFreq.Q)
            {
                numberOfMinorTics = 4;
                extra = (double)o.t2.sub / (double)numberOfMinorTics;
            }
            else if (highestFreq == EFreq.M)
            {
                numberOfMinorTics = 12;
                extra = (double)o.t2.sub / (double)numberOfMinorTics;
            }
            else if (highestFreq == EFreq.D)
            {
                numberOfMinorTics = 12; //we show month minor tics                    
                extra = (double)o.t2.sub / (double)numberOfMinorTics;  //approximate, which is ok (sub will be months here)
            }
            else
            {
                numberOfMinorTics = 1;
                extra = 1;
            }

            bool deduct = false;
            if (extra <= 0.40) deduct = true;

            if (Program.options.plot_xlabels_digits != 4 && Program.options.plot_xlabels_digits != 2)
            {
                G.Writeln2("*** ERROR: 'OPTION plot xlabels digits' should be either 4 or 2");
                throw new GekkoException();
            }

            string ss = null;
            for (int t = t1; t <= t2; t++)
            {
                int years = t2 - t1 + 1;
                bool twoDigits = false;
                if (Program.options.plot_xlabels_digits == 2) twoDigits = true;

                int skip = 1;
                if (twoDigits)
                {
                    if (years > 2 * 48) skip = 10;
                    else if (years > 48) skip = 5;
                    else if (years > 24) skip = 2;
                }
                else
                {
                    //4 digits
                    if (years > 2 * 24) skip = 10;
                    else if (years > 24) skip = 5;
                    else if (years > 12) skip = 2;
                }

                string tx = t.ToString();
                if (twoDigits) tx = (t % 100).ToString().PadLeft(2, '0');

                if (skip > 1 && t % skip != 0) tx = null;  //all uneven are zapped

                if (deduct && t == t2) tx = null;

                string tlabel = "\"" + tx + "\"";

                ss += tlabel + " " + t + " " + "0, ";  //0 is major tic

                //========================================================================================================
                //                          FREQUENCY LOCATION, indicates where to implement more frequencies
                //========================================================================================================

                if ((highestFreq == EFreq.M && years <= 25) || (highestFreq == EFreq.Q && years <= 75) || highestFreq == EFreq.D)
                {
                    for (int tt = 1; tt < numberOfMinorTics; tt++)  //is skipped if sub = 1
                    {
                        double d = (double)tt / (double)numberOfMinorTics;
                        ss += (t + d) + " " + "1, ";  //1 is minor tic
                    }
                }
            }

            txt.AppendLine("set xtics (" + ss + ")");
            txt.AppendLine("set xtics offset first 0.5, first 0");  //moves xtic labels a half year to the right, but not the tic itself
            if (firstXLabelFix)
            {
                if ((highestFreq == EFreq.M && o.t1.freq == EFreq.M && o.t1.sub <= 1) || (highestFreq == EFreq.Q && o.t1.freq == EFreq.Q && o.t1.sub <= 1))  //these could perhaps be <=4 and <=2 respectively. Often the plot starts in first subperiod anyway.
                {
                    //only show whole first year if monthly and m1-m4 or quarterly and q1-q2
                    double tStart = (double)t1 - 0.000000001d;                      //deducts a small number to activate the first x-axis label
                    txt.AppendLine("set xrange [" + tStart.ToString() + ":]");      //see above
                }
            }
        }

        private static bool SetYAxisText(string ytitle, StringBuilder txt, string font, bool isLeft)
        {
            bool setTitlePlaceholder;
            setTitlePlaceholder = true; //to make space
            if (isLeft) txt.AppendLine("set label \"" + GnuplotText(ytitle) + "\" at graph 0, graph 1 offset -3,2.2 left font " + font);
            else txt.AppendLine("set label \"" + GnuplotText(ytitle) + "\" at graph 1, graph 1 offset 3,2.2 right font " + font);
            return setTitlePlaceholder;
        }

        private static string PlotHandleLines(bool firstPass, ref int numberOfY2s, double[] minMax, double[] dataMin, double[] dataMax, O.Prt o, int count, List<string> labelsNonBroken, string file1, XmlNodeList lines3, List<int> boxesY, List<int> boxesY2, List<int> areasY, List<int> areasY2, XmlNode linetypeMain, XmlNode dashtypeMain, XmlNode linewidthMain, XmlNode linecolorMain, XmlNode pointtypeMain, XmlNode pointsizeMain, XmlNode fillstyleMain, bool stacked, List<string> palette2, bool isSeparated, double d_width, double d_width2, double d_width3, double left, List<O.Prt.Element> co, double linewidthCorrection, double pointsizeCorrection, bool isInside, EFreq highestFreq)
        {
            int manyXValues = 0;  //0 or 1            

            string plotline = "plot ";

            int boxesYCounter = 0;
            int boxesY2Counter = 0;
            int areasYCounter = 0;
            int areasY2Counter = 0;
            int iii = 0;
            for (int i = 0; i < count; i++)
            {
                iii = i;
                XmlNode line3 = lines3[i];

                //defaults
                string dlinetype = "lines";
                if (Program.options.plot_lines_points) dlinetype = "linespoints";
                string ddashtype = "1";
                string dlinewidth = "3";
                string dlinecolor = palette2[i % palette2.Count].Trim();
                string dpointtype = "7";
                string dpointsize = "0.5";
                string dfillstyle = "solid";
                string dy2_ = "no";

                string linetype = null;
                string dashtype = null;
                string linewidth = null;
                string linecolor = null;
                string pointtype = null;
                string pointsize = null;
                string fillstyle = null;
                string label = null;
                string y2 = null;

                bool isExplicit = false;
                string labelCleaned = labelsNonBroken[i];
                if (labelCleaned.StartsWith(Globals.labelCheatString))
                {
                    isExplicit = true;
                    labelCleaned = labelCleaned.Substring(Globals.labelCheatString.Length);
                }

                // ---------------------------------------------
                // --------- loading lines section start
                // ---------------------------------------------

                linetype = GetText(co[i].linetype, o.opt_linetype, line3 == null ? null : line3.SelectSingleNode("type"), linetypeMain, dlinetype);
                dashtype = GetText(co[i].dashtype, o.opt_dashtype, line3 == null ? null : line3.SelectSingleNode("dashtype"), dashtypeMain, ddashtype);
                linewidth = GetText(G.isNumericalError(co[i].linewidth) ? null : co[i].linewidth.ToString(), G.isNumericalError(o.opt_linewidth) ? null : o.opt_linewidth.ToString(), line3 == null ? null : line3.SelectSingleNode("linewidth"), linewidthMain, dlinewidth);
                linecolor = GetText(co[i].linecolor, o.opt_linecolor, line3 == null ? null : line3.SelectSingleNode("linecolor"), linecolorMain, dlinecolor);
                pointtype = GetText(co[i].pointtype, o.opt_pointtype, line3 == null ? null : line3.SelectSingleNode("pointtype"), pointtypeMain, dpointtype);
                pointsize = GetText(G.isNumericalError(co[i].pointsize) ? null : co[i].pointsize.ToString(), G.isNumericalError(o.opt_pointsize) ? null : o.opt_pointsize.ToString(), line3 == null ? null : line3.SelectSingleNode("pointsize"), pointsizeMain, dpointsize);
                fillstyle = GetText(co[i].fillstyle, o.opt_fillstyle, line3 == null ? null : line3.SelectSingleNode("fillstyle"), fillstyleMain, dfillstyle);
                y2 = GetText(co[i].y2, null, line3 == null ? null : line3.SelectSingleNode("y2"), null, "no"); //default: no, #23475432985
                label = HandleLabel(line3, isExplicit, labelCleaned);

                if (G.Equal(linetype, "boxes"))
                {
                    if (isSeparated) y2 = "yes";  //set y for all lines, and y2 for all boxes --> this overrides other settings
                }
                else
                {
                    fillstyle = null;  //fillstyle will fail if combined with other line types.
                    if (isSeparated) y2 = "no";  //set y for all lines, and y2 for all boxes --> this overrides other settings
                }



                // ---------------------------------------------
                // --------- loading lines section end
                // ---------------------------------------------


                if (G.Equal(linetype, "boxes") && fillstyle.Contains("solid"))
                {
                    linewidth = "1";  //otherwise the borders of these get blurred
                }

                label = GnuplotText(label);

                string s = null;
                if (!G.NullOrBlanks(linetype))
                {
                    if (G.Equal(linetype, "filledcurve") || G.Equal(linetype, "filledcurves"))
                    {
                        s += " with " + linetype + " y1=0";  //so the area is towards the x-axis
                    }
                    else
                    {
                        s += " with " + linetype;
                    }
                }
                if (NotNullAndNotNo(y2))
                {
                    if (firstPass) numberOfY2s++;
                    s += " axes x1y2";  //#23475432985
                }

                try
                {
                    if(linewidthCorrection!=1d)
                    {
                        double temp = G.ParseIntoDouble(linewidth);
                        linewidth = (temp * linewidthCorrection).ToString();
                    }
                    if (pointsizeCorrection != 1d)
                    {
                        double temp = G.ParseIntoDouble(pointsize);
                        pointsize = (temp * pointsizeCorrection).ToString();
                    }
                }
                catch { };

                if (!G.NullOrBlanks(dashtype)) s += " dashtype " + dashtype;
                if (!G.NullOrBlanks(linewidth)) s += " linewidth " + linewidth;
                if (!G.NullOrBlanks(linecolor)) s += " linecolor rgb \"" + linecolor.ToLower() + "\"";  //in gnuplot, the linecolor must be lower-case
                if (!G.NullOrBlanks(pointtype)) s += " pointtype " + pointtype;
                if (!G.NullOrBlanks(pointtype)) s += " pointsize " + pointsize;
                if (!G.NullOrBlanks(fillstyle)) s += " fillstyle " + fillstyle;

                string label2 = label;
                if (label != null && label != "") label2 = label + "   "; //blanks added to separate items in the legend                    
                s += " title " + Globals.QT + label2 + Globals.QT;
                
                //linestyle is an association of linecolor, linewidth, dashtype, pointtype
                //linetype is the same, just permanent
                //box: fillstyle empty|solid|pattern, border|noborder

                string xAdjustment = null;
                if (G.Equal(linetype, "boxes"))
                {
                    if (firstPass)
                    {
                        minMax[0] = Math.Min(minMax[0], dataMin[i]);
                        minMax[1] = Math.Max(minMax[1], dataMax[i]);
                    }

                    if (line3 == null || line3.SelectSingleNode("y2") == null)
                    {
                        boxesYCounter++;
                        if (firstPass) boxesY.Add(i);
                    }
                    else
                    {
                        boxesY2Counter++;
                        if (firstPass) boxesY2.Add(i);
                    }
                                       

                    if (stacked)
                    {
                        //see also #34252435
                        string ss = null;
                        if (line3 == null || line3.SelectSingleNode("y2") == null)
                        {
                            //the boxes could be i = 0, 2, 4, 5. The first of these is $1+$3+$5+$6 (note 1 added), the second is $3+$5+$6, etc.                            
                            //the f(x) funcion return 1 if positive, else 0.
                            //with the f function, we get: f($1*$6)*$1 + f($3*$6)*$3 + f($5*$6)*$5 + f($6*$6)*$6 --> the last f($6*$6) could be omitted since it will alway return 1
                            for (int k = boxesYCounter - 1; k < boxesY.Count; k++)
                            {
                                //see similar code below
                                ss += "f($" + (boxesY[k] + (count + 1)) + "*$" + (boxesY[boxesYCounter - 1] + (count + 1)) + ")*$" + (boxesY[k] + (count + 1)) + "+";
                            }
                        }
                        else
                        {
                            //the boxes could be i = 0, 2, 4, 5. The first of these is $1+$3+$5+$6 (note 1 added), the second is $3+$5+$6, etc.
                            for (int k = boxesY2Counter - 1; k < boxesY2.Count; k++)
                            {
                                //see similar code above
                                ss += "f($" + (boxesY2[k] + (count + 1)) + "*$" + (boxesY2[boxesYCounter - 1] + (count + 1)) + ")*$" + (boxesY2[k] + (count + 1)) + "+";
                            }
                        }
                        if (ss != null && ss.EndsWith("+")) ss = ss.Substring(0, ss.Length - 1); //remove last '+'                       
                        if (isInside)
                        {
                            xAdjustment = "($" + (iii + 1) + "+(" + GetXAdjustmentForInsideTics(isInside, highestFreq) + ")):(" + ss + ")" + ":(" + d_width3 + ")";
                        }
                        else
                        {
                            if (true)
                            {
                                double d = -0.5;
                                xAdjustment = "($" + (iii + 1) + " +(" + d + "))" + ":(" + ss + ")" + ":(" + d_width3 + ")";
                            }
                            
                        }
                    }
                    else
                    {
                        //adjusting horizontal position for clustered boxes
                        double d = (boxesYCounter + boxesY2Counter - 1) * d_width - left;

                        if (true)
                        {
                            if (!isInside) d = d - 0.5;
                        }

                        if (isInside)
                        {
                            xAdjustment = "($" + (iii + 1) + " +(" + d + ")+(" + GetXAdjustmentForInsideTics(isInside, highestFreq) + ")):" + (i + (count + 1)) + ":(" + d_width2 + ")";
                        }
                        else
                        {
                            xAdjustment = "($" + (iii + 1) + " +(" + d + ")):" + (i + (count + 1)) + ":(" + d_width2 + ")";
                        }                        
                    }
                }
                else if (G.Equal(linetype, "filledcurve") || G.Equal(linetype, "filledcurves"))
                {
                    if (firstPass)
                    {
                        minMax[2] = Math.Min(minMax[2], dataMin[i]);
                        minMax[3] = Math.Max(minMax[3], dataMax[i]);
                    }
                    if (line3 == null || line3.SelectSingleNode("y2") == null)
                    {
                        areasYCounter++;
                        if (firstPass) areasY.Add(i);
                    }
                    else
                    {
                        areasY2Counter++;
                        if (firstPass) areasY2.Add(i);
                    }

                    if (stacked)
                    {
                        //see comments under #34252435
                        string ss = null;
                        if (line3 == null || line3.SelectSingleNode("y2") == null)
                        {
                            for (int k = areasYCounter - 1; k < areasY.Count; k++)
                            {
                                //see similar code below
                                ss += "f($" + (areasY[k] + (count + 1)) + "*$" + (areasY[areasYCounter - 1] + (count + 1)) + ")*$" + (areasY[k] + (count + 1)) + "+";
                            }
                        }
                        else
                        {
                            for (int k = areasY2Counter - 1; k < areasY2.Count; k++)
                            {
                                //see similar code above
                                ss += "f($" + (areasY2[k] + (count + 1)) + "*$" + (areasY2[areasYCounter - 1] + (count + 1)) + ")*$" + (areasY2[k] + (count + 1)) + "+";
                            }
                        }
                        if (ss != null && ss.EndsWith("+")) ss = ss.Substring(0, ss.Length - 1);  //remove last '+'                       
                        if (isInside)
                        {
                            xAdjustment = "($" + (iii + 1) + "+(" + GetXAdjustmentForInsideTics(isInside, highestFreq) + ")):(" + ss + ")";
                        }
                        else
                        {
                            xAdjustment = "" + (iii + 1) + ":(" + ss + ")";
                        }
                    }
                    else
                    {
                        if (isInside)
                        {
                            xAdjustment = "($" + (iii + 1) + "+(" + GetXAdjustmentForInsideTics(isInside, highestFreq) + ")):" + (i + (count + 1));  //just normal positioning
                        }
                        else
                        {
                            xAdjustment = "" + (iii + 1) + ":" + (i + (count + 1));  //just normal positioning
                        }
                    }
                }
                else
                {
                    if (firstPass)
                    {
                        minMax[4] = Math.Min(minMax[4], dataMin[i]);
                        minMax[5] = Math.Max(minMax[5], dataMax[i]);
                    }
                                
                    xAdjustment = "($" + (iii + 1) + "+(" + GetXAdjustmentForInsideTics(isInside, highestFreq) + ")):" + (i + (count + 1));
                    
                }

                //string xlabel = GnuplotText(label);

                plotline += "\"" + file1 + "\" using " + xAdjustment + s;

                if (i < count - 1) plotline += ", ";
            }

            return plotline;
        }

        private static double GetXAdjustmentForInsideTics(bool isInside, EFreq highestFreq)
        {
            if (!isInside && (highestFreq == EFreq.A || highestFreq == EFreq.U)) return -0.5;
            else return 0d;
            //if (!isInside) return 0d;
            //int sub = 1;
            //if (highestFreq == EFreq.Q) sub = 4;
            //else if (highestFreq == EFreq.M) sub = 12;
            //double adj = 1d / sub / 2d;
            //return adj;
        }

        private static bool NotNullAndNotNo(string s)
        {
            //#23475432985
            return s != null && !G.Equal(s, "no");
        }

        private static string HandleLabel(XmlNode line3, bool isExplicit, string labelCleaned)
        {
            string label;
            string labelGpt = line3 == null ? null : GetText(line3.SelectSingleNode("label"));
            if (isExplicit)  //for instance: PLOT x*y 'product';
            {
                label = labelCleaned;  //overrides any xml label                        
            }
            else  //for instance: PLOT x*y;
            {
                label = labelCleaned;
                if (!G.NullOrBlanks(labelGpt)) label = labelGpt;  //xml label overrides variables
            }

            return label;
        }

        private static string GetText(XmlNode x, string def)
        {
            return GetText(null, null, null, x, def);           
        }

        private static string GetText(string y1, string y2, XmlNode y3, XmlNode y4, string y5)
        {
            //it seems the xml reader auto-trims the strings
            string s = y5; //maybe null, "", or a real string

            if(y4 != null)
            {
                if (y4.InnerText.StartsWith("//"))
                {
                    //do nothing, as if the tag does not even exist
                }
                else 
                {
                    s = y4.InnerText;  //if <tag></tag> or <tag/>, s will be = "". We say that this overrides prior settings.                
                }
            }
            else
            {
                //do nothing: the tag does not exist
            }

            if (y3 != null)
            {
                if (y3.InnerText.StartsWith("//"))
                {
                    //do nothing, as if the tag does not even exist
                }
                else
                {
                    s = y3.InnerText;  //if <tag></tag> or <tag/>, s will be = "". We say that this overrides prior settings.                
                }
            }
            else
            {
                //do nothing: the tag does not exist
            }

            if (y2 != null)
            {
                //For instance PLOT <color='red> x1, x2;
                s = y2;
            }

            if (y1 != null)
            {
                //For instance PLOT x1<color='red'>, x2;
                s = y1;
            }            

            return s;
        }

        private static List<string> GetText(XmlNodeList x)
        {
            List<string> ss = new List<string>();
            foreach(XmlNode y in x)
            {
                ss.Add(GetText(y));
            }
            return ss;
        }

        private static string GetText(XmlNode x)
        {
            return GetText(x, null);
        }

        
        private static string GnuplotText(string s)
        {
            return GnuplotText(s, false);
        }


        private static string GnuplotText(string s, bool omitCurly)
        {
            //cf. http://ayapin-film.sakura.ne.jp/Gnuplot/Docs/ps_guide.pdf
            if (s == null) return null;
            string s2 = s;
            s2 = s2.Replace(@"_", @"\\_");
            s2 = s2.Replace(@"@", @"\\@");
            if (!omitCurly)
            {
                s2 = s2.Replace(@"{", @"\\{");
                s2 = s2.Replace(@"}", @"\\}");
            }
            s2 = s2.Replace(@"^", @"\\^");
            s2 = s2.Replace(@"&", @"\\&");
            return s2;            
        }

        private static int HandleXTicsAt(List<string> labels1, List<string> labels2, ref string ticsTxt, int mxtics, EFreq highestFreq)
        {
            if (highestFreq == EFreq.A || highestFreq == EFreq.U)
            {
                //do nothing
                ticsTxt = null;
            }
            else
            {
                List<int> subperiods;
                int onlyYears;
                mxtics = GnuplotHandleXAxisLabelsAt(labels1, mxtics, out subperiods, out onlyYears);

                string s3 = null;
                int c = -1;
                for (int i = 0; i < labels1.Count; i++)
                {
                    c++;
                    //int subper=labels2[i]
                    //if (labels1.Count > 20 && c %  != 0) continue;
                    string[] split = labels2[i].Split(new char[] { '/' });
                    if (onlyYears != -12345 && int.Parse(split[0]) % onlyYears != 0) continue;
                    if (subperiods.Contains(int.Parse(split[1])))
                    {
                        string xx = labels2[i];                        
                        s3 += "\"" + labels1[i] + "\" \"" + xx + "\", ";
                    }
                }
                if (s3 != null)
                {
                    if (s3.EndsWith(", ")) s3 = s3.Substring(0, s3.Length - 2);
                    ticsTxt = "set xtics (" + s3 + ")" + G.NL;
                }
            }

            return mxtics;
        }

        private static string FromGnuplotDateToFloatingValue(string[] split)
        {
            return ((double)int.Parse(split[0]) + ((double)int.Parse(split[1]) - 1d) / 12d).ToString();
        }

        private static int GnuplotHandleXAxisLabelsAt(List<string> labels1, int mxtics, out List<int> subperiods, out int onlyYears)
        {
            subperiods = new List<int>();
            onlyYears = -12345;
            if (Program.options.freq == EFreq.Q)
            {
                if (labels1.Count <= 12)  //for quarterly, 12 corresponds to 3 years with 4 subpers each
                {
                    subperiods.Add(1);  //q1
                    subperiods.Add(4);  //q2
                    subperiods.Add(7);  //q3
                    subperiods.Add(10);  //q4
                }
                else if (labels1.Count <= 24)
                {
                    subperiods.Add(1);  //q1
                    subperiods.Add(7);  //q3
                    mxtics = 2;
                }
                else if (labels1.Count <= 48)
                {
                    subperiods.Add(1);  //q1
                    mxtics = 4;
                }
                else if (labels1.Count <= 5 * 48)
                {
                    onlyYears = 5;
                    subperiods.Add(1);  //q1
                    mxtics = 5;
                }
                else if (labels1.Count <= 10 * 48)
                {
                    onlyYears = 10;
                    subperiods.Add(1);  //q1
                    mxtics = 10;
                }
                else
                {
                    onlyYears = 20;
                    subperiods.Add(1);  //q1
                }
            }
            else  //monthly
            {
                if (labels1.Count <= 12)  //for monthly, 12 corresponds to 1 year with 12 subpers
                {
                    subperiods.Add(1);  //m1
                    subperiods.Add(2);  //m2
                    subperiods.Add(3);  //m3
                    subperiods.Add(4);  //m4
                    subperiods.Add(5);  //m5
                    subperiods.Add(6);  //m6
                    subperiods.Add(7);  //m7
                    subperiods.Add(8);  //m8
                    subperiods.Add(9);  //m9
                    subperiods.Add(10);  //m10
                    subperiods.Add(11);  //m11
                    subperiods.Add(12);  //m12
                }
                else if (labels1.Count <= 24)
                {
                    subperiods.Add(1);  //m1
                    subperiods.Add(3);  //m3
                    subperiods.Add(5);  //m5
                    subperiods.Add(7);  //m7
                    subperiods.Add(9);  //m9
                    subperiods.Add(11);  //m11
                    mxtics = 2;
                }
                else if (labels1.Count <= 36)
                {
                    subperiods.Add(1);  //m1
                    subperiods.Add(4);  //m4
                    subperiods.Add(7);  //m7
                    subperiods.Add(10);  //m10
                    mxtics = 3;
                }
                else if (labels1.Count <= 48)
                {
                    subperiods.Add(1);  //m1
                    subperiods.Add(5);  //m5
                    subperiods.Add(9);  //m9
                    mxtics = 4;
                }
                else if (labels1.Count <= 72)
                {
                    subperiods.Add(1);  //m1
                    subperiods.Add(7);  //m7
                    mxtics = 6;
                }
                else if (labels1.Count <= 144)
                {
                    subperiods.Add(1);  //m1
                }
                else if (labels1.Count <= 15 * 48)
                {
                    onlyYears = 5;
                    subperiods.Add(1);  //m1
                    mxtics = 5;
                }
                else if (labels1.Count <= 30 * 48)
                {
                    onlyYears = 10;
                    subperiods.Add(1);  //m1
                    mxtics = 10;
                }
                else
                {
                    onlyYears = 20;
                    subperiods.Add(1);  //m1
                }
            }

            return mxtics;
        }

        private static string GnuplotYrange(string ymin, string yminsoft, string yminhard, string ymax, string ymaxsoft, string ymaxhard)
        {
            // [  yminhard < * < yminsoft  : ymaxsoft < * < ymaxhard ] 
            // TODO: it would be nice to test the inequalities above, because if they are violated, they have no effect --> free borders, even if ymin/ymax is set.

            if (G.Equal(ymin, "NaN")) ymin = null;
            if (G.Equal(yminsoft, "NaN")) yminsoft = null;
            if (G.Equal(yminhard, "NaN")) yminhard = null;
            if (G.Equal(ymax, "NaN")) ymax = null;
            if (G.Equal(ymaxsoft, "NaN")) ymaxsoft = null;
            if (G.Equal(ymaxhard, "NaN")) ymaxhard = null;

            string left = null;
            string right = null;
            if (!G.NullOrBlanks(ymin))
            {                
                left = ymin;
            }
            else
            {                
                if (!G.NullOrBlanks(yminhard) && !G.NullOrBlanks(yminsoft))
                {
                    left = yminhard + " < * < " + yminsoft;
                }
                else if (!G.NullOrBlanks(yminhard) && G.NullOrBlanks(yminsoft))
                {
                    left = yminhard + " < * ";
                }
                else if (G.NullOrBlanks(yminhard) && !G.NullOrBlanks(yminsoft))
                {
                    left = " * < " + yminsoft;
                }
                else
                {
                    left = "";
                }
            }

            if (!G.NullOrBlanks(ymax))
            {
                double xx = ParseIntoDouble(ymax);  //just testing
                right = ymax;
            }
            else
            {
                if (!G.NullOrBlanks(ymaxhard) && !G.NullOrBlanks(ymaxsoft))
                {
                    right = ymaxsoft + " < * < " + ymaxhard;
                }
                else if (!G.NullOrBlanks(ymaxhard) && G.NullOrBlanks(ymaxsoft))
                {
                    right = " * < " + ymaxhard;
                }
                else if (G.NullOrBlanks(ymaxhard) && !G.NullOrBlanks(ymaxsoft))
                {
                    right = ymaxsoft + " < * ";
                }
                else
                {
                    right = "";
                }
            }
            return left + ":" + right;
        }               

        private static double ParseIntoDouble(string x)
        {
            double y = double.NaN;
            if (x != null)
            {
                if (!G.TryParseIntoDouble(x, out y))
                {
                    G.Writeln2("*** ERROR: Could not parse '" + x + "' as a number");
                    throw new GekkoException();
                }
            }
            return y;
        }

        private static string GetDateStringSuitableForGnuplot(string d)
        {
            if (Program.options.freq == EFreq.Q)
            {
                if (d.EndsWith("q1")) d = d.Substring(0, d.Length - 2) + "/01/01" + "";
                else if (d.EndsWith("q2")) d = d.Substring(0, d.Length - 2) + "/04/01" + "";
                else if (d.EndsWith("q3")) d = d.Substring(0, d.Length - 2) + "/07/01" + "";
                else if (d.EndsWith("q4")) d = d.Substring(0, d.Length - 2) + "/10/01" + "";
                else throw new GekkoException();
            }
            else if (Program.options.freq == EFreq.M)
            {
                if (d.EndsWith("m1")) d = d.Substring(0, d.Length - 2) + "/01/01" + "";
                else if (d.EndsWith("m2")) d = d.Substring(0, d.Length - 2) + "/02/01" + "";
                else if (d.EndsWith("m3")) d = d.Substring(0, d.Length - 2) + "/03/01" + "";
                else if (d.EndsWith("m4")) d = d.Substring(0, d.Length - 2) + "/04/01" + "";
                else if (d.EndsWith("m5")) d = d.Substring(0, d.Length - 2) + "/05/01" + "";
                else if (d.EndsWith("m6")) d = d.Substring(0, d.Length - 2) + "/06/01" + "";
                else if (d.EndsWith("m7")) d = d.Substring(0, d.Length - 2) + "/07/01" + "";
                else if (d.EndsWith("m8")) d = d.Substring(0, d.Length - 2) + "/08/01" + "";
                else if (d.EndsWith("m9")) d = d.Substring(0, d.Length - 2) + "/09/01" + "";
                else if (d.EndsWith("m10")) d = d.Substring(0, d.Length - 3) + "/10/01" + "";
                else if (d.EndsWith("m11")) d = d.Substring(0, d.Length - 3) + "/11/01" + "";
                else if (d.EndsWith("m12")) d = d.Substring(0, d.Length - 3) + "/12/01" + "";
                else throw new GekkoException();
            }
            return d;
        }        

        private static string EncodeDanish(string txt)
        {
            string s = "";
            foreach (char c in txt)
            {
                if (c == 'æ') s += "\\" + (346).ToString();
                else if (c == 'ø') s += "\\" + (370).ToString();
                else if (c == 'å') s += "\\" + (345).ToString();
                else if (c == 'Æ') s += "\\" + (306).ToString();
                else if (c == 'Ø') s += "\\" + (330).ToString();
                else if (c == 'Å') s += "\\" + (305).ToString();
                else s += c.ToString();
            }
            return s;
        }



        private static void ComputeValueForVprt(out double var1, out double varPch, PrtOptionsHelper po, GekkoTime gt0, GekkoTime gt1, Series tsWork, Series tsBase)
        {

            GekkoTime gt0MinusOne = gt0.Add(-1);
            var1 = 0;
            varPch = 0;
            if (po.isLevel == true)
            {
                Series ts = tsWork; if (po.isBaseline) ts = tsBase;

                double sum = 0d;
                double count = 0d;
                foreach (GekkoTime gt in new GekkoTimeIterator( gt0, gt1))
                {
                    double x = ts.GetDataSimple(gt);
                    sum += x;
                    count += 1d;
                }
                double avg = sum / count;

                double x1 = ts.GetDataSimple(gt1);
                double x0MinusOne = ts.GetDataSimple(gt0MinusOne);

                double avgGrowth = (Math.Pow(x1 / x0MinusOne, 1 / count) - 1) * 100d;
                if (x1 == x0MinusOne) avgGrowth = 0d;   //0 and 0 gives 0%

                var1 = avg;
                varPch = avgGrowth;

            }
            else
            {
                G.Writeln2("*** ERROR in VPRT regarding option field, only <r> can be used.");
                throw new GekkoException();
            }
            return;
        }

        public static void ComputeValueForPrintPlotNew(out double var1, out double varPch, string operator2, GekkoTime gt, Series tsWork, Series tsBase, bool isLogTransform, bool isCalledFromTable, int sumOver)
        {
            string operator3 = operator2.Trim();  //when it comes from for instance a table

            if (isCalledFromTable && !G.Equal(Globals.tableOption, "n"))
            {
                if (G.Equal(Globals.tableOption, "d"))
                {
                    if (G.Equal(operator3, "n")) operator3 = "d";
                    else if (G.Equal(operator3, "d")) operator3 = "";
                    else if (G.Equal(operator3, "p")) operator3 = "";
                    else if (G.Equal(operator3, "dp")) operator3 = "";
                    else if (G.Equal(operator3, "r")) operator3 = "rd";
                    else if (G.Equal(operator3, "rn")) operator3 = "rd";
                    else if (G.Equal(operator3, "rd")) operator3 = "";
                    else if (G.Equal(operator3, "rp")) operator3 = "";
                    else if (G.Equal(operator3, "rdp")) operator3 = "";
                    else if (G.Equal(operator3, "m")) operator3 = "";
                    else if (G.Equal(operator3, "q")) operator3 = "";
                    else if (G.Equal(operator3, "mp")) operator3 = "";
                }
                else if (G.Equal(Globals.tableOption, "p"))
                {
                    if (G.Equal(operator3, "n")) operator3 = "p";
                    else if (G.Equal(operator3, "d")) operator3 = "";
                    else if (G.Equal(operator3, "p")) operator3 = "";
                    else if (G.Equal(operator3, "dp")) operator3 = "";
                    else if (G.Equal(operator3, "r")) operator3 = "rp";
                    else if (G.Equal(operator3, "rn")) operator3 = "rp";
                    else if (G.Equal(operator3, "rd")) operator3 = "";
                    else if (G.Equal(operator3, "rp")) operator3 = "";
                    else if (G.Equal(operator3, "rdp")) operator3 = "";
                    else if (G.Equal(operator3, "m")) operator3 = "";
                    else if (G.Equal(operator3, "q")) operator3 = "";
                    else if (G.Equal(operator3, "mp")) operator3 = "";
                }
                else if (G.Equal(Globals.tableOption, "dp"))
                {
                    if (G.Equal(operator3, "n")) operator3 = "dp";
                    else if (G.Equal(operator3, "d")) operator3 = "";
                    else if (G.Equal(operator3, "p")) operator3 = "";
                    else if (G.Equal(operator3, "dp")) operator3 = "";
                    else if (G.Equal(operator3, "r")) operator3 = "rdp";
                    else if (G.Equal(operator3, "rn")) operator3 = "rdp";
                    else if (G.Equal(operator3, "rd")) operator3 = "";
                    else if (G.Equal(operator3, "rp")) operator3 = "";
                    else if (G.Equal(operator3, "rdp")) operator3 = "";
                    else if (G.Equal(operator3, "m")) operator3 = "";
                    else if (G.Equal(operator3, "q")) operator3 = "";
                    else if (G.Equal(operator3, "mp")) operator3 = "";
                }
                else if (G.Equal(Globals.tableOption, "r") || G.Equal(Globals.tableOption, "rn"))
                {
                    if (G.Equal(operator3, "n")) operator3 = "r";
                    else if (G.Equal(operator3, "d")) operator3 = "rd";
                    else if (G.Equal(operator3, "p")) operator3 = "rp";
                    else if (G.Equal(operator3, "dp")) operator3 = "rdp";
                    else if (G.Equal(operator3, "r")) operator3 = "";
                    else if (G.Equal(operator3, "rn")) operator3 = "";
                    else if (G.Equal(operator3, "rd")) operator3 = "";
                    else if (G.Equal(operator3, "rp")) operator3 = "";
                    else if (G.Equal(operator3, "rdp")) operator3 = "";
                    else if (G.Equal(operator3, "m")) operator3 = "";
                    else if (G.Equal(operator3, "q")) operator3 = "";
                    else if (G.Equal(operator3, "mp")) operator3 = "";
                }
                else if (G.Equal(Globals.tableOption, "rd"))
                {
                    if (G.Equal(operator3, "n")) operator3 = "rd";
                    else if (G.Equal(operator3, "d")) operator3 = "";
                    else if (G.Equal(operator3, "p")) operator3 = "";
                    else if (G.Equal(operator3, "dp")) operator3 = "";
                    else if (G.Equal(operator3, "r")) operator3 = "";
                    else if (G.Equal(operator3, "rn")) operator3 = "";
                    else if (G.Equal(operator3, "rd")) operator3 = "";
                    else if (G.Equal(operator3, "rp")) operator3 = "";
                    else if (G.Equal(operator3, "rdp")) operator3 = "";
                    else if (G.Equal(operator3, "m")) operator3 = "";
                    else if (G.Equal(operator3, "q")) operator3 = "";
                    else if (G.Equal(operator3, "mp")) operator3 = "";
                }
                else if (G.Equal(Globals.tableOption, "rp"))
                {
                    if (G.Equal(operator3, "n")) operator3 = "rp";
                    else if (G.Equal(operator3, "d")) operator3 = "";
                    else if (G.Equal(operator3, "p")) operator3 = "";
                    else if (G.Equal(operator3, "dp")) operator3 = "";
                    else if (G.Equal(operator3, "r")) operator3 = "";
                    else if (G.Equal(operator3, "rn")) operator3 = "";
                    else if (G.Equal(operator3, "rd")) operator3 = "";
                    else if (G.Equal(operator3, "rp")) operator3 = "";
                    else if (G.Equal(operator3, "rdp")) operator3 = "";
                    else if (G.Equal(operator3, "m")) operator3 = "";
                    else if (G.Equal(operator3, "q")) operator3 = "";
                    else if (G.Equal(operator3, "mp")) operator3 = "";
                }
                else if (G.Equal(Globals.tableOption, "rdp"))
                {
                    if (G.Equal(operator3, "n")) operator3 = "rdp";
                    else if (G.Equal(operator3, "d")) operator3 = "";
                    else if (G.Equal(operator3, "p")) operator3 = "";
                    else if (G.Equal(operator3, "dp")) operator3 = "";
                    else if (G.Equal(operator3, "r")) operator3 = "";
                    else if (G.Equal(operator3, "rn")) operator3 = "";
                    else if (G.Equal(operator3, "rd")) operator3 = "";
                    else if (G.Equal(operator3, "rp")) operator3 = "";
                    else if (G.Equal(operator3, "rdp")) operator3 = "";
                    else if (G.Equal(operator3, "m")) operator3 = "";
                    else if (G.Equal(operator3, "q")) operator3 = "";
                    else if (G.Equal(operator3, "mp")) operator3 = "";
                }
                else if (G.Equal(Globals.tableOption, "m"))
                {
                    if (G.Equal(operator3, "n")) operator3 = "m";
                    else if (G.Equal(operator3, "d")) operator3 = "";
                    else if (G.Equal(operator3, "p")) operator3 = "mp";
                    else if (G.Equal(operator3, "dp")) operator3 = "";
                    else if (G.Equal(operator3, "r")) operator3 = "";
                    else if (G.Equal(operator3, "rn")) operator3 = "";
                    else if (G.Equal(operator3, "rd")) operator3 = "";
                    else if (G.Equal(operator3, "rp")) operator3 = "";
                    else if (G.Equal(operator3, "rdp")) operator3 = "";
                    else if (G.Equal(operator3, "m")) operator3 = "";
                    else if (G.Equal(operator3, "q")) operator3 = "";
                    else if (G.Equal(operator3, "mp")) operator3 = "";
                }
                else if (G.Equal(Globals.tableOption, "q"))
                {
                    if (G.Equal(operator3, "n")) operator3 = "q";
                    else if (G.Equal(operator3, "d")) operator3 = "";
                    else if (G.Equal(operator3, "p")) operator3 = "";
                    else if (G.Equal(operator3, "dp")) operator3 = "";
                    else if (G.Equal(operator3, "r")) operator3 = "";
                    else if (G.Equal(operator3, "rn")) operator3 = "";
                    else if (G.Equal(operator3, "rd")) operator3 = "";
                    else if (G.Equal(operator3, "rp")) operator3 = "";
                    else if (G.Equal(operator3, "rdp")) operator3 = "";
                    else if (G.Equal(operator3, "m")) operator3 = "";
                    else if (G.Equal(operator3, "q")) operator3 = "";
                    else if (G.Equal(operator3, "mp")) operator3 = "";
                }
                else if (G.Equal(Globals.tableOption, "mp"))
                {
                    if (G.Equal(operator3, "n")) operator3 = "mp";
                    else if (G.Equal(operator3, "d")) operator3 = "";
                    else if (G.Equal(operator3, "p")) operator3 = "";
                    else if (G.Equal(operator3, "dp")) operator3 = "";
                    else if (G.Equal(operator3, "r")) operator3 = "";
                    else if (G.Equal(operator3, "rn")) operator3 = "";
                    else if (G.Equal(operator3, "rd")) operator3 = "";
                    else if (G.Equal(operator3, "rp")) operator3 = "";
                    else if (G.Equal(operator3, "rdp")) operator3 = "";
                    else if (G.Equal(operator3, "m")) operator3 = "";
                    else if (G.Equal(operator3, "q")) operator3 = "";
                    else if (G.Equal(operator3, "mp")) operator3 = "";
                }
                if (operator3 == "")
                {
                    G.Writeln2("*** ERROR: TABLE <" + Globals.tableOption + "> and table-file operator '" + operator2 + "' do not combine");
                    throw new GekkoException();
                }
            }

            GekkoTime tMinusOne = gt.Add(-1);
            var1 = 0;
            varPch = 0;

            double x = double.NaN;
            double xLag = double.NaN;
            double xLag2 = double.NaN;
            double y = double.NaN;
            double yLag = double.NaN;
            double yLag2 = double.NaN;
            if (tsWork != null)
            {
                x = tsWork.GetDataSimple(gt);  //actually quite good that GetData is used here, because for instance "PRT x;" will have the real series x here, where NaN have not optionally been replace with 0 (cf. option series data missing). But the GetData method takes care of that.
                xLag = tsWork.GetDataSimple(gt.Add(-1));
                xLag2 = tsWork.GetDataSimple(gt.Add(-2));
                if (isLogTransform)
                {
                    x = Math.Log(x);
                    xLag = Math.Log(xLag);
                    xLag2 = Math.Log(xLag2);
                }
            }
            if (tsBase != null)
            {
                y = tsBase.GetDataSimple(gt);
                yLag = tsBase.GetDataSimple(gt.Add(-1));
                yLag2 = tsBase.GetDataSimple(gt.Add(-2));
                if (isLogTransform)
                {
                    y = Math.Log(y);
                    yLag = Math.Log(yLag);
                    yLag2 = Math.Log(yLag2);
                }
            }

            if (operator3 == "" || operator3 == "n")
            {
                var1 = x;
                varPch = PchFunction(x, xLag);
            }
            else if (operator3 == "d")
            {
                var1 = x - xLag;
                varPch = PchFunction(x, xLag);
            }
            else if (operator3 == "p")
            {
                var1 = PchFunction(x, xLag);
                varPch = double.PositiveInfinity;
            }
            else if (operator3 == "dp")
            {
                var1 = PchFunction(x, xLag) - PchFunction(xLag, xLag2);
                varPch = double.PositiveInfinity;
            }
            else if (operator3 == Globals.operator_r || operator3 == Globals.operator_rn)  //r or rn
            {
                var1 = y;
                varPch = PchFunction(y, yLag);
            }
            else if (operator3 == Globals.operator_rd)  //rd
            {
                var1 = y - yLag;
                varPch = PchFunction(y, yLag);
            }
            else if (operator3 == Globals.operator_rp)  //rp
            {
                var1 = PchFunction(y, yLag);
                varPch = double.PositiveInfinity;
            }
            else if (operator3 == Globals.operator_rdp)  //rdp
            {
                var1 = PchFunction(y, yLag) - PchFunction(yLag, yLag2);
                varPch = double.PositiveInfinity;
            }
            else if (operator3 == "m")
            {
                var1 = x - y;
                varPch = PchFunction(x, y);
            }
            else if (operator3 == "q")
            {
                var1 = PchFunction(x, y);
                varPch = double.PositiveInfinity;
            }
            else if (operator3 == "mp")
            {
                var1 = PchFunction(x, xLag) - PchFunction(y, yLag);
                varPch = double.PositiveInfinity;
            }
            else if (operator3 == Globals.operator_l)
            {
                var1 = Math.Log(x);
                varPch = double.PositiveInfinity;
            }
            else if (operator3 == Globals.operator_dl)
            {
                var1 = Math.Log(x) - Math.Log(xLag);
                varPch = double.PositiveInfinity;
            }
            else if (operator3 == Globals.operator_rl)
            {
                var1 = Math.Log(y);
                varPch = double.PositiveInfinity;
            }
            else if (operator3 == Globals.operator_rdl)
            {
                var1 = Math.Log(y) - Math.Log(yLag);
                varPch = double.PositiveInfinity;
            }
            else
            {
                G.Writeln2("*** ERROR: Internal error: unrecognized print code: '" + operator3 + "'");
                throw new GekkoException();
            }
            return;
        }

        private static double PchFunction(double x, double x0)
        {
            double z = ((x / x0) - 1d) * 100d;
            if (x == x0) z = 0d;    //0 and 0 gives 0%
            return z;
        }

        private static void ComputeValueForPrintPlot(out double var1, out double varPch, PrtOptionsHelper po, GekkoTime gt, Series tsWork, Series tsBase)
        {
            GekkoTime tMinusOneOrTwo = gt.Add(-1);
            var1 = 0;
            varPch = 0;

            if (po.isDp)
            {
                Series ts = tsWork; if (po.isBaseline) ts = tsBase;
                double var = ts.GetDataSimple(gt);
                double varLag = ts.GetDataSimple(gt.Add(-1));
                double varLag2 = ts.GetDataSimple(gt.Add(-2));
                double pch = (var / varLag - 1) * 100d;
                double pchLag = (varLag / varLag2 - 1) * 100d;
                double dpch = pch - pchLag;
                var1 = dpch;  //TODO: do we get the first year without missing (it uses 2 lags...)?
                varPch = double.NaN;  //TODO: remove this in print
            }
            else if (po.isMp)
            {
                double var = tsWork.GetDataSimple(gt);
                double varLag = tsWork.GetDataSimple(gt.Add(-1));
                double varBase = tsBase.GetDataSimple(gt);
                double varBaseLag = tsBase.GetDataSimple(gt.Add(-1));
                double pch = (var / varLag - 1) * 100d;
                double pchBase = (varBase / varBaseLag - 1) * 100d;
                double dpch = pch - pchBase;
                var1 = dpch;
                varPch = double.NaN;  //TODO: remove this in print
            }
            else if (po.isLevel == true)
            {
                Series ts = tsWork; if (po.isBaseline) ts = tsBase;
                var1 = ts.GetDataSimple(gt);
                varPch = ((ts.GetDataSimple(gt) / ts.GetDataSimple(tMinusOneOrTwo) - 1d) * 100d);
                if (ts.GetDataSimple(gt) == ts.GetDataSimple(tMinusOneOrTwo)) varPch = 0d;    //0 and 0 gives 0%
            }
            else if (po.isLog == true)
            {
                Series ts = tsWork; if (po.isBaseline) ts = tsBase;
                var1 = Math.Log(ts.GetDataSimple(gt));
            }
            else if (po.isPch == true)
            {
                if (po.isMultiplier == true)
                {
                    if (po.isBaseline)
                    {
                        G.Writeln2("*** ERROR: It is not meaningful to use 'pch', 'multiplier' and 'reference' at the same time");
                        throw new GekkoException();
                    }
                    var1 = ((tsWork.GetDataSimple(gt) / tsBase.GetDataSimple(gt) - 1d) * 100d);
                    if (tsWork.GetDataSimple(gt) == tsBase.GetDataSimple(gt)) var1 = 0d;     //0 and 0 gives 0%
                }
                else
                {
                    Series ts = tsWork; if (po.isBaseline) ts = tsBase;
                    var1 = ((ts.GetDataSimple(gt) / ts.GetDataSimple(tMinusOneOrTwo) - 1d) * 100d);
                    if (ts.GetDataSimple(gt) == ts.GetDataSimple(tMinusOneOrTwo)) var1 = 0d;     //0 and 0 gives 0%
                }
            }
            else if (po.isDiff == true)
            {
                if (po.isMultiplier == true)
                {
                    if (po.isBaseline)
                    {
                        G.Writeln2("*** ERROR: It is not meaningful to use 'diff', 'multiplier' and 'reference' at the same time");
                        throw new GekkoException();
                    }
                    var1 = tsWork.GetDataSimple(gt) - tsBase.GetDataSimple(gt);
                    varPch = ((tsWork.GetDataSimple(gt) / tsBase.GetDataSimple(gt) - 1d) * 100d);
                    if (tsWork.GetDataSimple(gt) == tsBase.GetDataSimple(gt)) varPch = 0d;  //0 and 0 gives 0%
                }
                else
                {
                    Series ts = tsWork; if (po.isBaseline) ts = tsBase;
                    var1 = ts.GetDataSimple(gt) - ts.GetDataSimple(tMinusOneOrTwo);
                }
            }
            else if (po.isDlog == true)
            {
                if (po.isMultiplier == true)
                {
                    if (po.isBaseline)
                    {
                        G.Writeln2("*** ERROR: It is not meaningful to use 'dlog', 'multiplier' and 'reference' at the same time");
                        throw new GekkoException();
                    }
                    var1 = Math.Log(tsWork.GetDataSimple(gt) / tsBase.GetDataSimple(gt));
                }
                else
                {
                    Series ts = tsWork; if (po.isBaseline) ts = tsBase;
                    var1 = Math.Log(ts.GetDataSimple(gt) / ts.GetDataSimple(tMinusOneOrTwo));
                }
            }
            return;
        }                

        

        

        public static void Function(double[] arg, ref double func, object obj)
        {
            //Rosenbrock function
            double a = 1; double b = 100;
            double x = arg[0]; double y = arg[1];
            func = (a - x) * (a - x) + b * (y - x * x) * (y - x * x);
        }

        public static double[,] InvertMatrix(double[,] matrix)
        {
            return InvertMatrix(matrix, true);
        }

        public static double[,] InvertMatrix(double[,] matrix, bool printError)
        {
            int success = 0;
            alglib.matinvreport report = new alglib.matinvreport();
            alglib.rmatrixinverse(ref matrix, out success, out report);
            if (success == 3)
            {
                if (printError) G.Writeln2("*** ERROR: Inv(): It seems the matrix is singular");
                throw new GekkoException();
            }
            else if (success != 1)
            {
                if (printError) G.Writeln2("*** ERROR: Inv(): Could not invert matrix");
                throw new GekkoException();
            }
            return matrix;
        }



        public static bool InvertMatrix(IElementalAccessVector residuals, IElementalAccessVector dx)
        {
            if (Program.options.solve_newton_invert == "lu")
            {
                //LU with reuse of factorization
                //Would be nice with sparse parallel LU solver!
                return InvertMatrixLU(residuals, dx);
            }
            else if (Program.options.solve_newton_invert == "iter")
            {
                //Uses an iterative sparse solver (Math.NET), with an LU-solver (alglib) as fallback
                //It seems to be tolerant with respect to equations like "x = x".
                //Problem is that solve of inverted matrix cannot be reused as in InvertMatrixLU(), to
                //use in fast Newton steps. Also, the iterative solver may not converge.
                return InvertMatrixSparseIter(residuals, dx);
            }
            else
            {
                G.Writeln2("*** ERROR: Strange error #793438734");
                throw new GekkoException();
            }
        }

        private static bool InvertMatrixSparseIter(IElementalAccessVector residuals, IElementalAccessVector dx)
        {
            double relCrit = Globals.invertRelativeConvergence;

            for (int i = 0; i < residuals.Length; i++)
            {
                double val = residuals.GetValue(i);
                if (double.IsNaN(val) || double.IsInfinity(val)) return false;
            }

            {
                for (int iter2 = 0; iter2 < 100; iter2++)
                {
                    if (Globals.solveUseOnlyDenseInverse == false)
                    {
                        DefaultLinearIteration iter = null;
                        try
                        {
                            //IElementalAccessVector gradient = new DenseVector(x.Length);
                            //Blas.Default.TransMult(jacobyMatrix, residuals, gradient);  //checked that it MUST be transposed -- else wrong
                            //ILinearSolver solver = new BiCGSolver();  //1.00, BiCG family supposed to be unstable
                            //ILinearSolver solver = new BiCGstabSolver(); //0.47, supposed to be unstable
                            //ILinearSolver solver = new CGSSolver();  //0.46, supposed to be unstable, should have double spped of BiCG, seems unstable
                            //ILinearSolver solver = new IRSolver();  //not conv
                            //ILinearSolver solver = new GMRESSolver();  //1.01, supposed to be stable
                            ILinearSolver solver = new QMRSolver();  //USED: 1.24, more robust versoin of BiCG

                            IPreconditioner M = new IdentityPreconditioner();
                            iter = new DefaultLinearIteration();

                            //playing with conv crits don't change too much regarding steps
                            iter.SetParameters(Globals.invertRelativeConvergence * Math.Pow(10, iter2), Globals.invertAbsoluteConvergence, 1e+5, Globals.invertIterations);  //first param is relative convergence, which is OR'ed with absolute convergence (which we keep pretty strict)

                            M.Setup(Program.model.modelGekko.jacobiMatrix);
                            solver.Preconditioner = M;
                            solver.Iteration = iter;

                            double[] ans = null;

                            ans = Blas.Default.GetArrayCopy(solver.Solve(Program.model.modelGekko.jacobiMatrix, residuals, dx));
                            if (Program.options.solve_print_details) G.Writeln("Matrix inversion took " + iter.IterationCount + " steps");

                            break; //no exception, so we are good to go
                        }
                        catch (Exception e)
                        {
                            if (Program.options.solve_print_details) G.Writeln("Matrix inversion took " + iter.IterationCount + " steps");
                        }
                    }


                    if (Globals.solveUseOnlySparseInverse == false)
                    {
                        {
                            if (Program.options.solve_print_details) G.Writeln("Sparse matrix inversion failed, trying dense matrix inversion (slower)");
                            double[] b = new double[residuals.Length];
                            double[] x = new double[residuals.Length];
                            double[,] a = PutJacobiIntoArray();
                            for (int i = 0; i < residuals.Length; i++)
                            {
                                b[i] = residuals.GetValue(i);
                            }
                            int info = 0;
                            alglib.densesolver.densesolverreport rep = new alglib.densesolver.densesolverreport();
                            //old version below, with some ref
                            //alglib.densesolver.rmatrixsolve(ref a, b.Length, ref b, ref info, ref rep, ref x);
                            //MessageBox.Show("Test that the new alglib method gives the same");
                            alglib.densesolver.rmatrixsolve(a, b.Length, b, ref info, rep, ref x);
                            if (info != 1)
                            {
                                //if (false)  //it seems that rmatrixsolvels can stall completely, never returning from a loop.
                                //{           //providing a timer for it might be a solution, but for now it is switched off. So
                                //    //if the sparse solver does not work, we try the normal alglib solver, but not the
                                //    //least-squares solver. Often the values from the sparse solver are ok to continue
                                //    //with, even though it throws an exception.
                                //    int infols = 0;
                                //    if (Program.options.solve_print_details) G.Writeln("Problem with dense matrix inversion, trying less strict crits");
                                //    alglib.densesolver.densesolverlsreport repls = new alglib.densesolver.densesolverlsreport();
                                //    alglib.densesolver.rmatrixsolvels(ref a, b.Length, b.Length, ref b, 0d, ref infols, ref repls, ref x);
                                //    if (infols != 1)
                                //    {
                                //        if (Program.options.solve_print_details) G.Writeln("Could not perform dense matrix inversion, using result from sparse matrix inversion");
                                //    }
                                //    else
                                //    {
                                //        for (int i = 0; i < x.Length; i++)
                                //        {
                                //            dx.SetValue(i, x[i]);
                                //        }
                                //        break;  //we are good
                                //    }
                                //}
                            }
                            else
                            {
                                for (int i = 0; i < x.Length; i++)
                                {
                                    dx.SetValue(i, x[i]);
                                }
                                break;  //we are good
                            }
                        }
                    }
                }  //iterations
            }

            Blas.Default.Scale(-1d, dx);  //the direction is NEGATIVE!
            //dx is Newton direction
            return true;
        }

        private static bool InvertMatrixLU(IElementalAccessVector residuals, IElementalAccessVector dx)
        {
            int n = residuals.Length;
            for (int i = 0; i < residuals.Length; i++)
            {
                double val = residuals.GetValue(i);
                if (double.IsNaN(val) || double.IsInfinity(val)) return false;
            }

            double[,] lu = null;
            int[] indx;
            if (Program.model.modelGekko.jacobiMatrixInvertedIndex == null)
            {
                //lu = new double[n, n];
                if (Program.model.modelGekko.jacobiMatrixInverted == null) Program.model.modelGekko.jacobiMatrixInverted = new double[n, n];  //The very first time this method is called, the array will be null
                Array.Copy(Program.model.modelGekko.jacobiMatrixDense, Program.model.modelGekko.jacobiMatrixInverted, Program.model.modelGekko.jacobiMatrixDense.Length);
                lu = Program.model.modelGekko.jacobiMatrixInverted;
                indx = new int[n];  //this one is not recycled like jacobiMatrixInverted, to add some security that we are not mistakenly using old stuff from previous periods etc.
                LUDecompose(ref lu, ref indx);
                Program.model.modelGekko.jacobiMatrixInvertedIndex = indx;
            }
            else
            {
                lu = Program.model.modelGekko.jacobiMatrixInverted;
                indx = Program.model.modelGekko.jacobiMatrixInvertedIndex;
            }

            double[] b = new double[residuals.Length];
            for (int i = 0; i < residuals.Length; i++)
            {
                b[i] = residuals.GetValue(i);
            }

            double[] x = new double[residuals.Length];
            Solve(ref b, ref x, indx, lu);

            for (int i = 0; i < x.Length; i++)
            {
                dx.SetValue(i, x[i]);
            }

            Blas.Default.Scale(-1d, dx);  //the direction is NEGATIVE!
            //dx is Newton direction
            return true;
        }        

        public static Table Decompose(DecompOptions o)
        {
            //
            //
            //
            //                 Ref   -- m -->      Work
            //
            //                   ^                    ^
            //                   |                    |
            //                  rd                    d
            //                   |                    |
            //            
            //                 Ref[-1]             Work[-1]
            //
            //

            int funcCounter = 0;

            DateTime dt = DateTime.Now;

            string code1 = o.prtOptionLower;
            string code2 = null;
            if (code1.StartsWith("s"))
            {
                code1 = code1.Substring(1);
                code2 = "s";
            }

            o.decompTablesFormat.isPercentageType = false;
            if (code1.Contains("p") || code1.Contains("q") || code2 == "s")
            {
                o.decompTablesFormat.isPercentageType = true;
            }

            Table tab = new Table();

            GekkoTime per1 = o.t1;
            GekkoTime per2 = o.t2;

            bool isRaw = false;
            if (o.prtOptionLower.StartsWith("x")) isRaw = true;

            GekkoSmpl smpl = new GekkoSmpl(per1, per2);
            IVariable y0a = null;
            IVariable y0aRef = null;

            int perLag = -2;
            string lhs = "Expression value";

            bool usesRef = OperatorUsesRef(code1);
            
            try
            {

                if (o.decompTables == null) o.decompTables = new DecompData();

                if ((!usesRef && !o.hasCalculatedQuo) || (usesRef && !o.hasCalculatedRef))
                {
                    List<int> mm = new List<int>();

                    if (!usesRef)
                    {
                        o.decompTables.cellsGradQuo = new DecompDict();
                        o.decompTables.cellsQuo = new DecompDict();
                        o.decompTables.cellsContribD = new DecompDict();
                        mm.Add(0);
                        o.hasCalculatedQuo = true;
                    }
                    else
                    {
                        o.decompTables.cellsGradRef = new DecompDict();
                        o.decompTables.cellsRef = new DecompDict();
                        o.decompTables.cellsContribDRef = new DecompDict();
                        o.decompTables.cellsContribM = new DecompDict();
                        mm.Add(1);
                        o.hasCalculatedRef = true;
                    }

                    Globals.precedents = new GekkoDictionary<string, int>(StringComparer.OrdinalIgnoreCase);

                    //Function call start --------------
                    O.AdjustSmplForDecomp(smpl, 0);
                    y0a = o.expression(smpl); funcCounter++;  //this call fills Globals.precedents with variables
                    O.AdjustSmplForDecomp(smpl, 1);
                    //Function call end   --------------

                    List<DecompPrecedent> decompPrecedents = new List<DecompPrecedent>();
                    if (true)
                    {
                        List<string> ss = Globals.precedents.Keys.ToList<string>();
                        ss.Sort(StringComparer.OrdinalIgnoreCase);
                        foreach (string s in ss)
                        {
                            IVariable x = O.GetIVariableFromString(s, O.ECreatePossibilities.NoneReportError);

                            if (x.Type() == EVariableType.Series)
                            {
                                Series ivTemp_series = x as Series;
                                if (ivTemp_series.type == ESeriesType.ArraySuper) continue;  //skipped: we are only looking at sub-series                                
                                decompPrecedents.Add(new DecompPrecedent(s, x));
                            }
                            else if (x.Type() == EVariableType.Val)
                            {
                                decompPrecedents.Add(new DecompPrecedent(s, x));
                            }
                        }
                    }

                    Globals.precedents = null;  //!!! This is important: if not set to null, afterwards there will be a lot of superfluous lookup in the dictionary                

                    Series y0a_series = y0a as Series;
                    if (y0a == null)
                    {
                        G.Writeln2("*** ERROR: DECOMP expects the expression to be of series type");
                        throw new GekkoException();
                    }
                    Series y0_series = y0a_series;
                    if (y0a_series.type != ESeriesType.Light)
                    {
                        y0_series = y0a.DeepClone(null) as Series;  //a lag like "DECOMP x[-1]" may just move a pointer to real timeseries x, and x is changed with shocks...
                    }

                    Series y0aRef_series = null;
                    Series y0Ref_series = null;
                    if (usesRef)
                    {
                        //Function call start --------------
                        O.AdjustSmplForDecomp(smpl, 0);
                        smpl.bankNumber = 1;
                        y0aRef = o.expression(smpl); funcCounter++;
                        smpl.bankNumber = 0;
                        O.AdjustSmplForDecomp(smpl, 1);
                        //Function call end   --------------

                        y0aRef_series = y0aRef as Series;
                        if (y0aRef == null)
                        {
                            G.Writeln2("*** ERROR: DECOMP expects the expression to be of series type");
                            throw new GekkoException();
                        }
                        y0Ref_series = y0aRef_series;
                        if (y0aRef_series.type != ESeriesType.Light)
                        {
                            y0Ref_series = y0aRef.DeepClone(null) as Series;  //a lag like "DECOMP x[-1]" may just move a pointer to real timeseries x, and x is changed with shocks...
                        }
                    }

                    foreach (GekkoTime t in new GekkoTimeIterator(per1.Add(perLag), per2))
                    {
                        o.decompTables.cellsQuo[lhs].SetData(t, y0_series.GetData(smpl, t));
                        o.decompTables.cellsContribD[lhs].SetData(t, y0_series.GetData(smpl, t) - y0_series.GetData(smpl, t.Add(-1)));
                        if (usesRef)
                        {
                            o.decompTables.cellsRef[lhs].SetData(t, y0Ref_series.GetData(smpl, t));
                            o.decompTables.cellsContribM[lhs].SetData(t, y0_series.GetData(smpl, t) - y0Ref_series.GetData(smpl, t));
                            o.decompTables.cellsContribDRef[lhs].SetData(t, y0Ref_series.GetData(smpl, t) - y0Ref_series.GetData(smpl, t.Add(-1)));
                        }
                    }

                    double eps = Globals.newtonSmallNumber;

                    if (decompPrecedents.Count > 0)
                    {
                        GekkoDictionary<string, int> vars = new GekkoDictionary<string, int>(StringComparer.OrdinalIgnoreCase);

                        int iVar = -1;

                        foreach (DecompPrecedent dp in decompPrecedents)
                        {
                            iVar++;

                            //G.Writeln("Progress: " + G.pchFormat(100 * (double)iVar / (double)decompPrecedents.Count, 15));

                            Series xRef_series = null;
                            IVariable dpx = O.GetIVariableFromString(dp.s, O.ECreatePossibilities.NoneReportError);

                            if (dpx.Type() == EVariableType.Series)
                            {
                                if ((dpx as Series).type == ESeriesType.Timeless) continue;  //skip timeless series, #2983473298472
                                                                                             //could also use smpl.bankNumber = 1 to do this, but then GetIVariableFromString should use smpl.bankNumbe 
                                if (usesRef)
                                {
                                    xRef_series = O.GetIVariableFromString(G.Chop_SetBank(dp.s, "Ref"), O.ECreatePossibilities.NoneReportError) as Series;
                                }
                            }
                            else
                            {
                                //else what?
                            }

                            foreach (GekkoTime t1 in new GekkoTimeIterator(per1.Add(-O.MaxLag()), per2.Add(O.MaxLead())))
                            {

                                // --------------------------------------------
                                // This is where the decomposition takes place
                                // --------------------------------------------

                                foreach (int j in mm)
                                {
                                    if (dpx.Type() == EVariableType.Series)
                                    {
                                        Series x_series = null;
                                        Series y_series = null;
                                        if (j == 0)
                                        {
                                            x_series = dpx as Series;
                                            y_series = y0_series;
                                        }
                                        else
                                        {
                                            x_series = xRef_series;
                                            y_series = y0Ref_series;
                                        }
                                        double x_before = x_series.GetData(smpl, t1);
                                        try
                                        {
                                            double x_after = x_before + eps;
                                            x_series.SetData(t1, x_after);

                                            //Function call start --------------
                                            O.AdjustSmplForDecomp(smpl, 0);
                                            if (j == 1) smpl.bankNumber = 1;
                                            IVariable y1 = null;
                                            y1 = o.expression(smpl); funcCounter++;
                                            if (j == 1) smpl.bankNumber = 0;
                                            O.AdjustSmplForDecomp(smpl, 1);
                                            //Function call end   --------------

                                            Series y1_series = y1 as Series;

                                            foreach (GekkoTime t2 in new GekkoTimeIterator(per1.Add(perLag), per2.Add(0)))
                                            //foreach (GekkoTime t2 in new GekkoTimeIterator(t1, t1))
                                            {
                                                double y0_double = y_series.GetData(smpl, t2);
                                                double y1_double = y1_series.GetData(smpl, t2);
                                                double grad = (y1_double - y0_double) / eps;
                                                int lag = -(GekkoTime.Observations(t1, t2) - 1);  //x[-1] --> lag = -1                                            
                                                string name = G.Chop_FreqRemove(dp.s, per1.freq);

                                                if (lag != 0)
                                                {
                                                    if (lag < 0) name += "¤[" + lag + "]";
                                                    else name += "¤[+" + lag + "]";
                                                }

                                                if (lag == 0 || (lag < 0 && -lag <= Program.options.decomp_maxlag) || (lag > 0 && lag <= Program.options.decomp_maxlead))
                                                {
                                                    //slack: we get too many variants of name[-x] and name[+x] here
                                                    if (j == 0)
                                                    {
                                                        o.decompTables.cellsQuo[name].SetData(t2, x_before);
                                                        //G.Writeln("quo " + name + " " + t2.ToString() + " " + x_before);
                                                    }
                                                    else
                                                    {
                                                        o.decompTables.cellsRef[name].SetData(t2, x_before);
                                                        //G.Writeln("ref " + name + " " + t2.ToString() + " " + x_before);
                                                    }
                                                }

                                                if (!G.isNumericalError(grad) && grad != 0d)
                                                {
                                                    if (j == 0)
                                                    {
                                                        o.decompTables.cellsGradQuo[name].SetData(t2, grad);
                                                        //G.Writeln("gradquo " + name + " " + t2.ToString() + " " + grad);
                                                    }
                                                    else
                                                    {
                                                        o.decompTables.cellsGradRef[name].SetData(t2, grad);
                                                        //G.Writeln("gradref " + name + " " + t2.ToString() + " " + grad);
                                                    }

                                                    if (!vars.ContainsKey(name))
                                                    {
                                                        vars.Add(name, 0);
                                                        //G.Writeln("--> added var " + name);
                                                    }
                                                    else
                                                    {
                                                        //G.Writeln("checked name");
                                                    }

                                                }
                                            }
                                        }
                                        finally
                                        {
                                            x_series.SetData(t1, x_before);
                                        }
                                    }
                                    else if (dpx.Type() == EVariableType.Val)
                                    {
                                        //TODO
                                    }
                                    else
                                    {
                                        //skip other types, this includes matrices
                                        //so an expression with a matrix that changes from Work to Ref is
                                        //not decomoposed as regards to this matrix
                                        //(we would have to shock each cell in the matrix...)
                                    }

                                    //decompContributions.Add(dh);
                                    //decompHelpers.Add(key + "," + t.ToString(), decompContributions);  //key for instance "Work,2010"
                                }
                            }
                        }

                        if (o.vars2 == null)
                        {
                            o.vars2 = new List<string>(vars.Keys.ToArray());
                            o.vars2.Sort(StringComparer.OrdinalIgnoreCase);
                            o.vars2.Insert(0, lhs);
                        }

                        tab.writeOnce = true;

                        int i = 0;
                        foreach (GekkoTime t2 in new GekkoTimeIterator(per1, per2))
                        {
                            i++;
                            int j = 0;
                            foreach (string s in o.vars2)
                            {
                                if (s == lhs) continue;
                                j++;

                                double vQuo = o.decompTables.cellsQuo[s].GetData(smpl, t2);
                                double vQuoLag = o.decompTables.cellsQuo[s].GetData(smpl, t2.Add(-1));
                                double vGradQuoLag = o.decompTables.cellsGradQuo[s].GetData(smpl, t2.Add(-1));
                                double vGradQuo = o.decompTables.cellsGradQuo[s].GetData(smpl, t2);
                                double dContribD = vGradQuoLag * (vQuo - vQuoLag);
                                o.decompTables.cellsContribD[s].SetData(t2, dContribD);

                                if (usesRef)
                                {
                                    double vRef = o.decompTables.cellsRef[s].GetData(smpl, t2);
                                    double vRefLag = o.decompTables.cellsRef[s].GetData(smpl, t2.Add(-1));
                                    double vGradRef = o.decompTables.cellsGradRef[s].GetData(smpl, t2);
                                    double vGradRefLag = o.decompTables.cellsGradRef[s].GetData(smpl, t2.Add(-1));
                                    double dContribM = vGradRef * (vQuo - vRef);
                                    double dContribDRef = vGradRefLag * (vRef - vRefLag);
                                    o.decompTables.cellsContribM[s].SetData(t2, dContribM);
                                    o.decompTables.cellsContribDRef[s].SetData(t2, dContribDRef);
                                }
                            }
                        }
                    }
                }
            }
            finally
            {
                //Important: makes sure is is *always* nulled after a DECOMP
                Globals.precedents = null;
            }

            if (funcCounter > 0)
            {
                G.Writeln2("DECOMP took " + G.SecondsFormat((DateTime.Now - dt).TotalMilliseconds) + " --> " + funcCounter + " evals");
                G.Writeln("+++ NOTE: DECOMP only works well on simulated values -- a patch for 3.0 will fix this.");
            }

            DecomposePutIntoTable(o, code1, code2, tab, per1, per2, smpl, lhs, o.vars2);

            return tab;

        }

        private static bool OperatorUsesRef(string code1)
        {
            return code1 == "r" || code1 == "xr" || code1 == "xrn" || code1 == "rd" || code1 == "xrd" || code1 == "m" || code1 == "xm" || code1 == "rp" || code1 == "xrp" || code1 == "q" || code1 == "xq" || code1 == "rdp" || code1 == "xrdp" || code1 == "mp" || code1 == "xmp";
        }

        public static string GetDecompResidualName(int counter)
        {
            if (counter == 0) return Program.databanks.GetFirst().name + ":" + Globals.decompResidualName + "¤[0]";
            else return Program.databanks.GetFirst().name + ":" + Globals.decompResidualName + "_link" + counter + "¤[0]";
        }

        private static void DecomposePutIntoTable(DecompOptions o, string code1, string code2, Table tab, GekkoTime per1, GekkoTime per2, GekkoSmpl smpl, string lhs, List<string> vars2)
        {
            int iOffset = 0;
            if (o.decompTablesFormat.showErrors) iOffset = 1;

            if (o.decompTablesFormat.isPercentageType)
            {
                tab.Set(1, 1, "%");                
            }

            int j = 0;
            foreach (GekkoTime t2 in new GekkoTimeIterator(per1, per2))
            {
                j++;
                int i = 0;
                double lhsSum = 0d;
                double rhsSum = 0d;
                foreach (string varname in vars2)
                {
                    i++;
                    if (j == 1)
                    {
                        string varname2 = varname;
                        string lag5 = null;
                        string[] ss = varname.Split('¤');
                        if (ss.Length == 2)
                        {
                            varname2 = ss[0];
                            lag5 = ss[1];
                        }
                        else
                        {
                            //do nothing
                        }
                        tab.Set(i + 1, 1, G.Chop_RemoveBank(varname2, Program.databanks.GetFirst().name) + lag5);                  
                    }

                    if (i == 1)
                    {
                        Cell c = new Cell();
                        c.date = t2.ToString();
                        c.cellType = CellType.Date;
                        tab.Set(new Coord(1, j + 1), c);
                    }
                    double d = double.NaN;
                    if (code1 == "n" || code1 == "xn" || code1 == "x")
                    {
                        d = o.decompTables.cellsQuo[varname].GetData(smpl, t2);  //for instance {"x¤2002", 2.5} or {"x[-1]¤2003", -1.5}
                                                                  //o.cellsGrad.TryGetValue(s + "¤" + t2.ToString(), out d);  //for instance {"x¤2002", 2.5} or {"x[-1]¤2003", -1.5}
                    }
                    else if (code1 == "r" || code1 == "xr" || code1 == "xrn")
                    {
                        d = o.decompTables.cellsRef[varname].GetData(smpl, t2);
                        //o.decompTables.cellsGradRef.TryGetValue(s + "¤" + t2.ToString(), out d);  //for instance {"x¤2002", 2.5} or {"x[-1]¤2003", -1.5}
                    }
                    else if (code1 == "d")
                    {
                        d = o.decompTables.cellsContribD[varname].GetData(smpl, t2);
                    }
                    else if (code1 == "rd")
                    {
                        d = o.decompTables.cellsContribDRef[varname].GetData(smpl, t2);
                    }
                    else if (code1 == "xd")
                    {
                        double d1 = o.decompTables.cellsQuo[varname].GetData(smpl, t2);
                        double d0 = o.decompTables.cellsQuo[varname].GetData(smpl, t2.Add(-1));
                        d = d1 - d0;
                    }
                    else if (code1 == "xrd")
                    {
                        double d1 = o.decompTables.cellsRef[varname].GetData(smpl, t2);
                        double d0 = o.decompTables.cellsRef[varname].GetData(smpl, t2.Add(-1));
                        d = d1 - d0;
                    }
                    else if (code1 == "m")
                    {
                        d = o.decompTables.cellsContribM[varname].GetData(smpl, t2);
                    }
                    else if (code1 == "xm")
                    {
                        double d1 = o.decompTables.cellsQuo[varname].GetData(smpl, t2);
                        double d0 = o.decompTables.cellsRef[varname].GetData(smpl, t2);
                        d = d1 - d0;
                    }
                    else if (code1 == "p")
                    {
                        double dd = o.decompTables.cellsContribD[varname].GetData(smpl, t2);
                        double dLhsLag = o.decompTables.cellsQuo[lhs].GetData(smpl, t2.Add(-1));
                        d = (dd / dLhsLag) * 100d;
                    }
                    else if (code1 == "rp")
                    {
                        double dd = o.decompTables.cellsContribDRef[varname].GetData(smpl, t2);
                        double dLhsLag = o.decompTables.cellsRef[lhs].GetData(smpl, t2.Add(-1));
                        d = (dd / dLhsLag) * 100d;
                    }
                    else if (code1 == "xp")
                    {
                        double d1 = o.decompTables.cellsQuo[varname].GetData(smpl, t2);
                        double d0 = o.decompTables.cellsQuo[varname].GetData(smpl, t2.Add(-1));
                        d = (d1 / d0 - 1d) * 100d;
                    }
                    else if (code1 == "xrp")
                    {
                        double d1 = o.decompTables.cellsRef[varname].GetData(smpl, t2);
                        double d0 = o.decompTables.cellsRef[varname].GetData(smpl, t2.Add(-1));
                        d = (d1 / d0 - 1d) * 100d;
                    }
                    else if (code1 == "q")
                    {
                        double dd = o.decompTables.cellsContribM[varname].GetData(smpl, t2);
                        double dLhsLag = o.decompTables.cellsRef[lhs].GetData(smpl, t2);
                        d = (dd / dLhsLag) * 100d;
                    }
                    else if (code1 == "xq")
                    {
                        double d1 = o.decompTables.cellsQuo[varname].GetData(smpl, t2);
                        double d0 = o.decompTables.cellsRef[varname].GetData(smpl, t2);
                        d = (d1 / d0 - 1d) * 100d;
                    }
                    else if (code1 == "dp")
                    {
                        double dd = o.decompTables.cellsContribD[varname].GetData(smpl, t2);
                        double dd_lag = o.decompTables.cellsContribD[varname].GetData(smpl, t2.Add(-1));
                        double dLhsLag = o.decompTables.cellsQuo[lhs].GetData(smpl, t2.Add(-1));
                        double dLhsLag_lag = o.decompTables.cellsQuo[lhs].GetData(smpl, t2.Add(-1).Add(-1));
                        d = (dd / dLhsLag - dd_lag / dLhsLag_lag) * 100d;
                    }
                    else if (code1 == "rdp")
                    {
                        double dd = o.decompTables.cellsContribDRef[varname].GetData(smpl, t2);
                        double dd_lag = o.decompTables.cellsContribDRef[varname].GetData(smpl, t2.Add(-1));
                        double dLhsLag = o.decompTables.cellsRef[lhs].GetData(smpl, t2.Add(-1));
                        double dLhsLag_lag = o.decompTables.cellsRef[lhs].GetData(smpl, t2.Add(-1).Add(-1));
                        d = (dd / dLhsLag - dd_lag / dLhsLag_lag) * 100d;
                    }
                    else if (code1 == "xdp")
                    {
                        double d1 = o.decompTables.cellsQuo[varname].GetData(smpl, t2);
                        double d1_lag = o.decompTables.cellsQuo[varname].GetData(smpl, t2.Add(-1));
                        double d0 = o.decompTables.cellsQuo[varname].GetData(smpl, t2.Add(-1));
                        double d0_lag = o.decompTables.cellsQuo[varname].GetData(smpl, t2.Add(-1).Add(-1));
                        d = (d1 / d0 - 1d - (d1_lag / d0_lag - 1d)) * 100d;
                    }
                    else if (code1 == "xrdp")
                    {
                        double d1 = o.decompTables.cellsRef[varname].GetData(smpl, t2);
                        double d1_lag = o.decompTables.cellsRef[varname].GetData(smpl, t2.Add(-1));
                        double d0 = o.decompTables.cellsRef[varname].GetData(smpl, t2.Add(-1));
                        double d0_lag = o.decompTables.cellsRef[varname].GetData(smpl, t2.Add(-1).Add(-1));
                        d = (d1 / d0 - 1d - (d1_lag / d0_lag - 1d)) * 100d;
                    }
                    else if (code1 == "mp")  // <p> - <rp>
                    {
                        double dd = o.decompTables.cellsContribD[varname].GetData(smpl, t2);
                        double dLhsLag = o.decompTables.cellsQuo[lhs].GetData(smpl, t2.Add(-1));

                        double dd2 = o.decompTables.cellsContribDRef[varname].GetData(smpl, t2);
                        double dLhsLag2 = o.decompTables.cellsRef[lhs].GetData(smpl, t2.Add(-1));
                        d = (dd / dLhsLag - dd2 / dLhsLag2) * 100d;


                    }
                    else if (code1 == "xmp")
                    {
                        double d1 = o.decompTables.cellsQuo[varname].GetData(smpl, t2);
                        double d0 = o.decompTables.cellsQuo[varname].GetData(smpl, t2.Add(-1));
                        double d1_ref = o.decompTables.cellsRef[varname].GetData(smpl, t2);
                        double d0_ref = o.decompTables.cellsRef[varname].GetData(smpl, t2.Add(-1));
                        d = (d1 / d0 - 1d - (d1_ref / d0_ref - 1d)) * 100d;
                    }
                    else
                    {
                        MessageBox.Show("*** ERROR: Wrong operator: " + o.prtOptionLower);
                        throw new GekkoException();
                    }

                    if (i == 1)
                    {
                        lhsSum = d;
                    }
                    else
                    {
                        rhsSum += d;
                    }

                    DecomposeInsertValue(tab, j, i, d, o.decompTablesFormat);

                    if (i == 1 && o.decompTablesFormat.showErrors)
                    {
                        i = i + iOffset;
                        //skip a line, to make room for error showing (at i = 2, or row 3 in the table)
                        if (j == 1 && DecomposePutIntoTableIsError(o.decompTablesFormat.showErrors, i))
                        {
                            tab.Set(i + 1, 1, Globals.decompText2);
                            tab.Get(i + 1, 1).backgroundColor = "LightRed";
                        }
                    }

                }
                if (code1 == "d" || code1 == "rd" || code1 == "m" || code1 == "p" || code1 == "rp" || code1 == "q" || code1 == "dp" || code1 == "rdp" || code1 == "mp")
                {
                    double error = lhsSum - rhsSum;
                    double factor = lhsSum / rhsSum;
                    int end = vars2.Count;
                    if (o.decompTablesFormat.showErrors)
                    {
                        factor = 1d;  //resetting
                        end = end + iOffset;
                    }
                    for (i = 2; i <= end; i++)  //note: the real rows of the table are i+1
                    {
                        if (DecomposePutIntoTableIsError(o.decompTablesFormat.showErrors, i)) //real table row 3
                        {
                            DecomposeInsertValue(tab, j, i, error, o.decompTablesFormat);
                            tab.Get(i + 1, j + 1).backgroundColor = "LightRed";
                        }
                        else
                        {
                            tab.Get(i + 1, j + 1).number *= factor;
                        }
                    }
                    if (code2 == "s")
                    {
                        //just take raw cell numbers and make them sum to 100
                        tab.Get(1 + 1, j + 1).number *= 100d / tab.Get(1 + 1, j + 1).number;  //variable 1, table row 2
                        double sum = 0d;
                        for (i = 2; i <= end; i++)  //note: the real rows of the table are i+1
                        {
                            sum += tab.Get(i + 1, j + 1).number;
                        }
                        for (i = 2; i <= end; i++)  //note: the real rows of the table are i+1
                        {
                            tab.Get(i + 1, j + 1).number *= 100d / sum;
                        }                        
                    }
                }
            }
        }

        public static List<string> DecompGetVars(DecompData decompData, string varname, string expressionText, GekkoDictionary<string, bool>ignore)
        {
            List<string> vars = new List<string>(decompData.cellsContribD.storage.Keys);
            vars.Sort(StringComparer.OrdinalIgnoreCase);
            List<string> vars2 = new List<string>();
            if (varname == null)
            {
                vars2 = new List<string>(vars);                
            }
            else
            {                   
                foreach (string var in vars)
                {
                    //making sure that the variable we are going to decompose is shown at top
                    string[] ss = var.Split('¤');
                    string varnameWithoutFirstBank = G.Chop_RemoveBank(ss[0], Program.databanks.GetFirst().name);
                    if (ss[1] == "[0]" && G.Equal(varname, varnameWithoutFirstBank)) vars2.Add(var);
                }
                if (vars2.Count == 0)
                {
                    G.Writeln2("*** ERROR: Did not find variable '" + varname + "' in the equation " + expressionText);
                    throw new GekkoException();
                }
                foreach (string var in vars)
                {
                    //adding the rest of the variables, except the variable we are going to decompose
                    if (G.Equal(vars2[0], var)) continue;
                    if (ignore.ContainsKey(var)) continue;  //variables that are eliminated via links
                    vars2.Add(var);
                }
            }            
            return vars2;
        }        

        private static void DecomposeAddToRow(DataRow dr, string col_variable, string varName)
        {
            //string s = varName;
            //if (string.IsNullOrEmpty(varName)) varName = "gekko_empty";
            dr[col_variable] = varName;
        }

        public static Table DecomposePutIntoTableHelper2(DataTable tab2, string col_value, bool isValues)
        {
            Table tab = new Table();
            for (int jj = 1; jj < tab2.Columns.Count; jj++)  //1: skip (1, 1) element
            {
                tab.Set(1, jj + 1, tab2.Columns[jj].ToString());
            }
        
            int i = 1; int j = 0;
            foreach (DataRow row in tab2.Rows)
            {
                i++; j = 0;
                foreach (DataColumn col in tab2.Columns)
                {                    
                    j++;
                    //starts at i = 2, j = 1
                    if (i > 1 && j > 1)
                    {
                        if (isValues)
                        {
                            DecomposePutIntoTableHelper2Cast(tab, i, j, row, col);
                        }
                        else
                        {
                            if (col.ColumnName == col_value)
                            {
                                DecomposePutIntoTableHelper2Cast(tab, i, j, row, col);
                            }
                            else
                            {
                                string s = row[col].ToString();                                
                                tab.Set(i, j, s);
                            }
                        }
                    }
                    else
                    {
                        string s = row[col].ToString();                        
                        tab.Set(i, j, s);
                    }
                }
            }
            return tab;
        }

        private static void DecomposePutIntoTableHelper2Cast(Table tab, int i, int j, DataRow row, DataColumn col)
        {
            double d = double.NaN;
            Object o = row[col];
            if (o.GetType() == typeof(double)) d = (double)row[col];
            else
            {
                string s = o as string;
                double.TryParse(s, out d);
            }
            tab.Set(new Coord(i, j), null, d, CellType.Number, "f13.4");
        }
        
        public static DataTable GetInversedDataTableOLD(DataTable table, string rowVariable, string colVariable, string valuesVariable, string nullValue, bool sumValues)
        {
            //https://www.codeproject.com/Articles/22008/C-Pivot-Table

            //Create a DataTable to Return
            DataTable returnTable = new DataTable();

            if (colVariable == "") colVariable = table.Columns[0].ColumnName;

            //Add a Column at the beginning of the table
            returnTable.Columns.Add(rowVariable);

            //Read all DISTINCT values from columnX Column in the provided DataTale
            List<string> columnXValues = new List<string>();

            foreach (DataRow dr in table.Rows)
            {
                //colVariable could be several, columnXTemp = s1, s2, s3, ... 
                string columnXTemp = dr[colVariable].ToString();
                if (!columnXValues.Contains(columnXTemp))
                {
                    //Read each row value, if it's different from others provided, add to 
                    //the list of values and creates a new Column with its value.
                    columnXValues.Add(columnXTemp);
                    returnTable.Columns.Add(columnXTemp);
                }
            }

            //Verify if Y and Z Axis columns re provided
            if (rowVariable != "" && valuesVariable != "")
            {
                //Read DISTINCT Values for Y Axis Column
                List<string> columnYValues = new List<string>();

                foreach (DataRow dr in table.Rows)
                {
                    if (!columnYValues.Contains(dr[rowVariable].ToString()))
                        columnYValues.Add(dr[rowVariable].ToString());
                }

                //Loop all Column Y Distinct Value
                foreach (string columnYValue in columnYValues)
                {
                    //Creates a new Row
                    DataRow drReturn = returnTable.NewRow();
                    drReturn[0] = columnYValue;
                    //foreach column Y value, The rows are selected distincted
                    DataRow[] rows = table.Select(rowVariable + "='" + columnYValue + "'");

                    //Read each row to fill the DataTable
                    foreach (DataRow dr in rows)
                    {
                        string rowColumnTitle = dr[colVariable].ToString();

                        //Read each column to fill the DataTable
                        foreach (DataColumn dc in returnTable.Columns)
                        {
                            if (dc.ColumnName == rowColumnTitle)
                            {
                                //If Sum of Values is True it try to perform a Sum
                                //If sum is not possible due to value types, the value 
                                // displayed is the last one read
                                if (sumValues)
                                {
                                    try
                                    {
                                        Object o1 = drReturn[rowColumnTitle];
                                        Object o2 = dr[valuesVariable];
                                        decimal d1 = Convert.ToDecimal(o1);
                                        decimal d2 = Convert.ToDecimal(o2);                                        
                                        drReturn[rowColumnTitle] = d1 + d2;

                                     //   drReturn[rowColumnTitle] =
                                     //Convert.ToDecimal(drReturn[rowColumnTitle]) +
                                     //Convert.ToDecimal(dr[columnZ]);
                                    }
                                    catch
                                    {
                                        drReturn[rowColumnTitle] = dr[valuesVariable];
                                    }
                                }
                                else
                                {
                                    drReturn[rowColumnTitle] = dr[valuesVariable];
                                }
                            }
                        }
                    }
                    returnTable.Rows.Add(drReturn);
                }
            }
            else
            {
                throw new Exception("The columns to perform inversion are not provided");
            }

            //if a nullValue is provided, fill the datable with it
            if (nullValue != "")
            {
                foreach (DataRow dr in returnTable.Rows)
                {
                    foreach (DataColumn dc in returnTable.Columns)
                    {
                        if (dr[dc.ColumnName].ToString() == "")
                            dr[dc.ColumnName] = nullValue;
                    }
                }
            }

            return returnTable;
        }       

        
        
        private static bool DecomposePutIntoTableIsError(bool showErrors, int i)
        {
            return showErrors && i == 2;
        }

        private static void DecomposeInsertValue(Table tab, int j, int i, double d, DecompTablesFormat o)
        {
            Cell c = new Cell();
            c.number = d;
            c.cellType = CellType.Number;
            int decimals = 0;
            if (o.isPercentageType) decimals = o.decimalsPch;
            else decimals = o.decimalsLevel;
            string format2 = "f16." + decimals.ToString();
            c.numberFormat = format2;
            tab.Set(new Coord(i + 1, j + 1), c);
        }

        private static void DecomposeInsertValue2(Table tab, string code1, string code2, int j, int i, double d, DecompTablesFormat format)
        {
            Cell c = new Cell();
            c.number = d;
            c.cellType = CellType.Number;
            int decimals = 0;
            if (format.isPercentageType) decimals = format.decimalsPch;
            else decimals = format.decimalsLevel;
            string format2 = "f16." + decimals.ToString();
            c.numberFormat = format2;
            tab.Set(new Coord(i + 1, j + 1), c);
        }
        
        private static void DecomposeInsertValue(Table tab, string code1, string code2, int j, int i, double d, DecompOptions2 decompOptions)
        {
            Cell c = new Cell();
            c.number = d;
            c.cellType = CellType.Number;
            int decimals = 0;
            if (decompOptions.decompTablesFormat.isPercentageType) decimals = decompOptions.decompTablesFormat.decimalsPch;
            else decimals = decompOptions.decompTablesFormat.decimalsLevel;
            string format = "f16." + decimals.ToString();
            c.numberFormat = format;
            tab.Set(new Coord(i + 1, j + 1), c);
        }

        public static double[,] PutJacobiIntoArray()
        {
            double[,] a = new double[Program.model.modelGekko.jacobiMatrix.RowCount, Program.model.modelGekko.jacobiMatrix.ColumnCount];
            for (int i = 0; i < Program.model.modelGekko.jacobiMatrix.RowCount; i++)
            {
                for (int j = 0; j < Program.model.modelGekko.jacobiMatrix.ColumnCount; j++)
                {
                    a[i, j] = Program.model.modelGekko.jacobiMatrix.GetValue(i, j);
                }
            }
            return a;
        }        

        
        

        

        
        
        private static void PrintIterationVariables(double[] b, string[] vars, int iterCounter)
        {
            if (vars == null) return;
            if (vars.Length == 0) return;
            if (true)
            {
                G.Writeln();
                foreach (string var5 in vars)
                {
                    BTypeData temp = (BTypeData)Program.model.modelGekko.varsBType[var5 + Globals.lagIndicator + "0"];
                    int tem2 = temp.bNumber;
                    double num = b[tem2];
                    G.Writeln(iterCounter + "  " + var5 + " = " + num);
                }
                G.Writeln();
            }
        }
                

        

        public static double[,] MultiplyMatrices(double[,] x, double[,] y)
        {
            //  1 2
            //  3 4     5 6 7 8       -->   3x2 * 2x4 = 3x4
            //  5 6     8 9 8 5
            //
            int xRows = x.GetLength(0);
            int xCols = x.GetLength(1);
            int yRows = y.GetLength(0);
            int yCols = y.GetLength(1);
            if (xCols != yRows)
            {
                G.Writeln2("*** ERROR: Matrices do not conform for multiplication");
                throw new GekkoException();
            }
            double[,] z = new double[xRows, yCols];
            for (int i = 0; i < xRows; i++)
            {
                for (int j = 0; j < yCols; j++)
                {
                    double sum = 0d;
                    for (int k = 0; k < xCols; k++)
                    {
                        sum += x[i, k] * y[k, j];
                    }
                    z[i, j] = sum;
                }
            }
            return z;
        }

        

        private static void EigenValues()
        {
            if (true)
            {
                //http://mathdl.maa.org/mathDL/4/?pa=content&sa=viewDocument&nodeId=607&bodyId=967
                // 0.78  -0.33    A matrix         --> G =    0     0.33/0.78                     [0.423]     lambda1=0, lambda2=-0.33*0.44/(0.78*0.45)=-0.414.
                //-0.44   0.45                                0     0.33*0.44/(0.78*0.45)         [0.414]
                //frml _i x1 = 0.22*x1 + 0.33*x2 + 1;
                //frml _i x2 = 0.44*x1 + 0.55*x2 + 1;

                //Program.model.modelGekko.jacobiMatrixDense = new double[3, 3];
                //Program.model.modelGekko.jacobiMatrixDense[0, 0] = 9;
                //Program.model.modelGekko.jacobiMatrixDense[0, 1] = -1;
                //Program.model.modelGekko.jacobiMatrixDense[0, 2] = 2;
                //Program.model.modelGekko.jacobiMatrixDense[1, 0] = -2;
                //Program.model.modelGekko.jacobiMatrixDense[1, 1] = 8;
                //Program.model.modelGekko.jacobiMatrixDense[1, 2] = 4;
                //Program.model.modelGekko.jacobiMatrixDense[2, 0] = 1;
                //Program.model.modelGekko.jacobiMatrixDense[2, 1] = 1;
                //Program.model.modelGekko.jacobiMatrixDense[2, 2] = 8;



                int n = Program.model.modelGekko.jacobiMatrixDense.GetLength(0);
                double[,] ja = Program.model.modelGekko.jacobiMatrixDense;

                double[,] minusU = new double[n, n];
                double[,] DL = new double[n, n];
                //double[,] d = new double[n, n];

                for (int i = 0; i < n; i++)
                {
                    for (int j = 0; j < n; j++)
                    {
                        if (i >= j) DL[i, j] = ja[i, j];
                        //else if (i > j) l[i, j] = ja[i, j];
                        else if (i < j) minusU[i, j] = -ja[i, j];
                    }
                }

                //alglib.inv.rmatrixinverse(ref DL, n);
                //double[,] g = MultiplyMatrix(DL, minusU);

                ////Array.Copy(Program.model.modelGekko.jacobiMatrixDense, j, Program.model.modelGekko.jacobiMatrixDense.Length);
                //double[] lambda = new double[n];
                //double[] lambdai = new double[n];
                //double[,] vl = new double[n, n];
                //double[,] vr = new double[n, n];

                //bool xx = alglib.nsevd.rmatrixevd(g, n, 0, ref lambda, ref lambdai, ref vl, ref vr);
                //double largest = 0d;
                //for (int i = 0; i < lambda.Length; i++)
                //{
                //    double modulus = Math.Sqrt(lambda[i] * lambda[i] + lambdai[i] * lambdai[i]);
                //    G.Writeln(G.levelFormat(modulus, 10) + " " + G.levelFormat(lambda[i], 10) + " " + G.levelFormat(lambdai[i], 10));
                //    largest = Math.Max(largest, modulus);
                //}
                //G.Writeln("LARGEST LAMBDA = " + largest);
                //G.Writeln();
            }
        }

        private static void ClearMatrix(IElementalAccessMatrix dy)
        {
            for (int c1 = 0; c1 < dy.ColumnCount; c1++)
            {
                for (int c2 = 0; c2 < dy.RowCount; c2++)
                {
                    if (dy.GetValue(c2, c1) != 0)
                    {
                        dy.SetValue(c2, c1, 0d);
                    }
                }
            }
        }

        

        private static bool IsSimultaneousPrologueVariable(int endo)
        {
            bool flagSimulProlo = false;
            //slack: should create array with feedb vars first
            for (int i3 = 0; i3 < Program.model.modelGekko.m2.simulRecursive.Count; i3++)
            {
                int simProloEndo = Program.model.modelGekko.m2.sparseInfo[(int)Program.model.modelGekko.m2.simulRecursive[i3]][0];  //could be 0,4,5,7
                if (endo == simProloEndo) flagSimulProlo = true;  //the var is a feedback var
            }
            return flagSimulProlo;
        }
        private static bool IsSimultaneousPrologueVariable1(int endo, Hashtable ht)
        {
            return ht.Contains(endo);
        }

        private static bool isFeedbackVariable(int endo)
        {
            bool flagFeedback = false;
            //slack: should create array with feedb vars first
            for (int i3 = 0; i3 < Program.model.modelGekko.m2.simulFeedback.Count; i3++)
            {
                int feedbEndo = Program.model.modelGekko.m2.sparseInfo[(int)Program.model.modelGekko.m2.simulFeedback[i3]][0];  //could be 0,4,5,7
                if (endo == feedbEndo) flagFeedback = true;  //the var is a feedback var
            }
            return flagFeedback;
        }
        private static bool isFeedbackVariable1(int endo, Hashtable ht)
        {
            return ht.Contains(endo);
        }

        public static void CreateNewTable(string name)
        {
            if (Program.tables.ContainsKey(name))
            {
                Program.tables.Remove(name);
            }
            Table temp = new Table();
            temp.type = "table"; //not a "print" type table -- relevant regarding formatting
            Program.tables.Add(name, temp);
        }

        public static Table GetTable(string name)
        {
            Table xx = null;
            if (Program.tables.TryGetValue(name, out xx))
            {
            }
            else
            {
                G.Writeln2("*** ERROR: Table '" + name + "' does not seem to exist");
            }
            return xx;
        }

        public static string Add1ToFileName(string input, string inputLast, string workingFolder)
        {
            DirectoryInfo di = new DirectoryInfo(workingFolder);
            FileInfo[] rgFiles = di.GetFiles(input + "*." + inputLast);
            int high = -1;
            foreach (FileInfo fi in rgFiles)
            {
                string name = fi.Name;
                int idx = name.IndexOf("." + inputLast);
                if (idx > input.Length && idx < name.Length)
                {
                    string name1 = name.Substring(input.Length, name.Length - input.Length - inputLast.Length - 1);
                    int result;
                    if (int.TryParse(name1, out result))
                    {
                        high = Math.Max(result, high);
                    }
                    else
                    {
                        //ignore
                    }
                }
            }
            string name2 = input + (high + 1) + "." + inputLast;
            return name2;
        }

        static public string UnfoldVariableList(StringReader file)
        {
            // var line can be delimited by spaces or ";", spacing is irrelevant
            // description lines are all following lines (typically 4)
            // a record MUST end with "---" at least, and first line MUST be var line
            // "()" and "//" are ignored all over
            // the index name inside {} must be 1 char only wide
            // file must be in utf-8
            bool firstRealLineFound = false;
            List<Item> shortList = new List<Item>();
            List<Item> longList = new List<Item>();
            int counter = 0;
            int state = 1; //read var
            Item item = new Item();
            bool varlistFound = false;
            while (true)
            {
                //================== read and parse variable line ==============================
                if (file.Peek() < 0) break;
                string line = file.ReadLine();
                line = line.Trim();  //removes all blanks at start or end
                if (G.Equal(line, "varlist$") || G.Equal(line, "varlist;"))
                {
                    varlistFound = true;
                    continue;
                }
                if (varlistFound == false) continue;
                if (line.Length >= 2 && line.Substring(0, 2) == "()") continue;
                if (line.Length >= 2 && line.Substring(0, 2) == "//") continue;
                //if we get here, varlist$ has been found, and the line is not a ()-line or //-line
                if (firstRealLineFound == false && line == "")
                {
                    continue;
                }
                else
                {
                    firstRealLineFound = true;
                }

                if (line.StartsWith("---"))  //at least three '-' ends a block
                {
                    if (true)
                    {
                        counter++;
                        state = 1;
                        shortList.Add(item);
                        item = new Item();
                        continue;
                    }
                }
                if (state == 1)
                {
                    //expects variable
                    EquationBrowserExtractVariableNameEtc(line, item);
                    state = 2;  //expects description
                    continue;
                }
                if (state == 2)
                {
                    //expects description
                    item.explanation.Add(line);
                    state = 2;  //expects more description
                    continue;
                }
            }
            file.Close();

            foreach (Item shortItem in shortList)
            {
                if (shortItem.listOfLists == null)
                {
                    Item temp = new Item();
                    temp.variable = shortItem.variable;
                    temp.explanation = shortItem.explanation;
                    longList.Add(temp);
                    continue;
                }
                List<Item>[] dimensions = new List<Item>[shortItem.listOfLists.Count + 1];
                dimensions[0] = new List<Item>();
                dimensions[0].Add(shortItem);
                for (int d = 0 + 1; d < dimensions.Length; d++)  //for each list {i}->1, {j}->2 etc.
                {
                    dimensions[d] = new List<Item>();
                    foreach (Item original in dimensions[d - 1])
                    {
                        OneList thisList = shortItem.listOfLists[d - 1];
                        foreach (string element in thisList.indexItems)  //for each element in {i] etc.
                        {
                            Item temp = new Item();
                            string variable = original.variable;
                            variable = variable.Replace("{" + thisList.indexName + "}", element);
                            temp.variable = variable;
                            foreach (string line in original.explanation)
                            {
                                string line2 = line;
                                line2 = line2.Replace("{" + thisList.indexName + "}", element);
                                temp.explanation.Add(line2);
                            }
                            dimensions[d].Add(temp);
                        }
                    }
                }
                List<Item> result = dimensions[dimensions.Length - 1];
                longList.AddRange(result);
            }
            string s = null;
            if (counter > 0)
            {
                s = longList.Count + " var labels read";
            }
            Program.unfoldedVariableList = longList;
            return s;
        }

        private static void EquationBrowserExtractVariableNameEtc(string line, Item itemFolded)
        {
            int sep = line.IndexOfAny(new char[] { ' ', ';' }, 0);  //search for blank or ';' to separate var name and list, starting at pos 0
            if (sep == -1)  //no separation found, so listOfList if just null
            {
                itemFolded.variable = line;
            }
            else
            {
                //it is a list of items, {i}
                //e.g. "dp{i}{j} i=1,2,3,4,5 j=wb,wm,wt"
                string var = line.Substring(0, sep - 0);
                string var3 = var.Trim();
                itemFolded.variable = var3;
                List<OneList> listOfLists = new List<OneList>();
                bool error = false;
                for (int i = 0; i < var3.Length; i++)
                {
                    if (var3[i] == '{')
                    {
                        if (var3.Length > i + 2)
                        {
                            if (var3[i + 2] == '}')
                            {
                                OneList oneList = new OneList();
                                oneList.indexName = var3.Substring(i + 1, 1);
                                listOfLists.Add(oneList);
                            }
                            else
                            {
                                error = true;
                            }
                        }
                        else
                        {
                            error = true;
                        }
                    }
                    if (error)
                    {
                        G.Writeln2("*** ERROR: could not parse indices in '" + var3 + "'");
                        G.Writeln(line);
                        G.Writeln();
                    }
                }

                string restOfLine = line.Substring(sep);
                restOfLine.Replace(';', ' ');  // ';' can be used as delimiter instead of space
                restOfLine.Trim();  //now restOfLine is "i=1,2,3,4,5 j=wb,wm,wt" or "i=1,2,3,4,5;j=wb,wm,wt"

                StringTokenizer2 tok = new StringTokenizer2(restOfLine, false, true);
                tok.IgnoreWhiteSpace = true;
                tok.SymbolChars = new char[] { '=', ';', ',' };
                Token token;
                List<string> al = new List<string>();
                List<string> alType = new List<string>();
                do
                {
                    token = tok.Next();
                    al.Add(token.Value); alType.Add(token.Kind.ToString());
                } while (token.Kind != ETokenType.EOF);
                //below is a very innocent hack that makes stopping easier
                //like this, our tokens will end with these 3: {""/"EOF"}  {""/""}  {""/""}
                al.Add("");
                alType.Add("");
                al.Add("");
                alType.Add("");

                for (int i = 0; i < al.Count; i++)
                {
                    if (i + 1 < al.Count && al[i + 1] == "=")  //we have a new list
                    {
                        string name = al[i];
                        List<string> items = new List<string>();
                        for (int j = i + 2; j < al.Count; j += 2)
                        {
                            if (al[j - 1] == "=" || al[j - 1] == ",")
                            {
                                items.Add(al[j]);
                            }
                            else
                            {
                                //presume we are out of listed items
                                bool success = false;
                                foreach (OneList list in listOfLists)
                                {
                                    if (name == list.indexName)
                                    {
                                        success = true;
                                        list.indexItems = items;
                                        break;  //break out of foreach loop
                                    }
                                }
                                if (success == false)
                                {
                                    G.Writeln2("*** ERROR: indices do not match");
                                    G.Writeln(line);
                                    G.Writeln();
                                }
                                break;  //break out of j loop, continue i loop
                            }
                        }
                    }
                }
                itemFolded.listOfLists = listOfLists;
            }
        }



        public static Excel.Workbook OpenBook(Excel.Workbooks workbooks, string fileName, bool readOnly, bool editable,
        bool updateLinks)
        {
            Excel.Workbook book = workbooks.Open(
                fileName, updateLinks, readOnly,
                Type.Missing, Type.Missing, Type.Missing, Type.Missing, Type.Missing,
                Type.Missing, editable, Type.Missing, Type.Missing, Type.Missing,
                Type.Missing, Type.Missing);
            return book;
        }        

        public static string GetExcelColumnName(int columnNumber)
        {
            int dividend = columnNumber;
            string columnName = String.Empty;
            int modulo;

            while (dividend > 0)
            {
                modulo = (dividend - 1) % 26;
                columnName = Convert.ToChar(65 + modulo).ToString() + columnName;
                dividend = (int)((dividend - modulo) / 26);
            }

            return columnName;
        }        

        public static TableLight ReadExcelWorkbook(string file, string sheetName)
        {
            if (Program.options.sheet_engine == "internal")
            {
                return ReadExcelWorkbookEPPlus(file, sheetName);
            }
            else
            {
                return ReadExcelWorkbookPIA(file, sheetName);
            }
        }

        private static void WriteXlsError(string fileNameWithPath)
        {
            if (fileNameWithPath != null && G.Equal(Path.GetExtension(fileNameWithPath), ".xls"))
            {
                G.Writeln2("*** ERROR: With 'OPTION sheet engine = internal;', only xlsx files are allowed.");
                G.Writeln("           Please use 'OPTION sheet engine = excel;' for xls files.", Color.Red);
                G.Writeln("           Note that option 'engine = excel' requires that Excel is installed on your machine.", Color.Red);
                throw new GekkoException();
            }
        }

        public static TableLight ReadExcelWorkbookEPPlus(string file, string sheetName)
        {
            TableLight matrix = new TableLight();
            
            if (!File.Exists(file))
            {
                G.Writeln2("*** ERROR: File " + file + " does not seem to exist");
                throw new GekkoException();
            }

            WriteXlsError(file);
            
            try
            {

                using (ExcelPackage excel2 = new ExcelPackage(new FileInfo(file)))
                {
                    ExcelWorksheet ws = null;
                    if (sheetName != null)
                    {
                        ws = excel2.Workbook.Worksheets[sheetName];
                        if (ws == null)
                        {
                            G.Writeln2("*** ERROR: Could not find sheet '" + sheetName + "' inside " + file);
                            throw new GekkoException();
                        }
                    }
                    else
                    {
                        ws = excel2.Workbook.Worksheets.First<ExcelWorksheet>();
                    }

                    var start = ws.Dimension.Start;
                    var end = ws.Dimension.End;
                    
                    object[,] intput = (object[,])ws.Cells[1, 1, end.Row, end.Column].Value;
                    int rows2 = intput.GetLength(0);
                    int cols2 = intput.GetLength(1);

                    //beware, this array is 0-based
                    for (int i = 0; i < end.Row; i++)
                    { // Row by row...
                        for (int j = 0; j < end.Column; j++)
                        { // ... Cell by cell...
                            
                            Object temp = intput[i, j];
                            if (temp == null) continue;
                            CellLight cell;
                            Type t = temp.GetType();
                            if (t == typeof(double))
                            {
                                cell = new CellLight((double)temp);
                            }
                            else if (t == typeof(DateTime))
                            {
                                cell = new CellLight((DateTime)temp);
                            }
                            else if (t == typeof(int))
                            {
                                int iData = (int)temp;

                                //-2146826281 = #Div/0!
                                //-2146826246 = #N/A
                                //-2146826259 = #Name?
                                //-2146826288 = #Null!
                                //-2146826252 = #Num!
                                //-2146826265 = #Ref!
                                //-2146826273 = #Value!

                                if (iData == -2146826246)
                                {
                                    //just like it is in a csv file. The -2146826246 is really a hexadecimal error code from Excel, stating that the number is N/A.
                                    cell = new CellLight("#N/A");
                                }
                                else if (iData == -2146826259)
                                {
                                    cell = new CellLight("#Name?");
                                }
                                else if (iData == -2146826281)
                                {
                                    cell = new CellLight("#Div/0");
                                }
                                else
                                {
                                    cell = new CellLight((double)iData);
                                }
                            }
                            else if (temp.GetType() == typeof(string))
                            {
                                cell = new CellLight((string)temp);
                            }
                            else if (temp.GetType() == typeof(OfficeOpenXml.ExcelErrorValue))
                            {
                                cell = new CellLight(double.NaN);
                            }
                            else
                            {
                                Type tt = temp.GetType();
                                string ttt = temp.GetType().ToString();

                                //G.Writeln2("+++ WARNING: Cell " + GetExcelCell(i, j, false) + " seems to be neither text or number.");
                                //G.Writeln("           It has type " + temp.GetType().ToString(), Color.Red);
                                //throw new GekkoException();
                                cell = new CellLight("[data not recognized error]");
                            }
                            matrix.Add(i + 1, j + 1, cell);  //i and j are 0-based, matrix needs to be 1-based.

                        }
                    }
                }
            }
            catch (Exception e)
            {
                if (!(e is GekkoException))
                {
                    if (e.Message != null && e.Message != "")
                    {
                        G.Writeln2("*** ERROR: " + e.Message);
                        WriteExcelError();
                    }
                }
                throw;
            }

            return matrix;
        }

        private static void WriteExcelError()
        {
            G.Writeln("+++ NOTE: You may set 'OPTION sheet engine = excel;' to use the Excel engine from Gekko 2.2.");
            G.Writeln("          Gekko 3.0 and on uses 'engine = internal' instead of 'engine = excel'. The new engine is");
            G.Writeln("          faster and more robust, but only supports .xslx, and not .xls files. In order to");
            G.Writeln("          use .xls files, you must use 'engine = excel'. If you encounter unexpected errors, please");
            G.Writeln("          try to see if 'engine = excel' solves them (requires Excel).");
        }

        private static TableLight ReadExcelWorkbookPIA(string file, string sheetName)
        {
            int threadID = (int)AppDomain.GetCurrentThreadId();  //should be ok, just not for "fibre" threads (on SQL server)... never mind
            if (!File.Exists(file))
            {
                G.Writeln2("*** ERROR: File " + file + " does not seem to exist");
                throw new GekkoException();
            }

            //DateTime t00 = DateTime.Now;
            TableLight matrix = new TableLight();
            //using file: this may be a copied file is copylocal is active. Else it is identical to oRead.fileName.

            Excel.Application excel = null;
            Excel.Workbooks workbooks = null;
            Excel.Workbook wkb = null;
            Excel.Sheets objSheets = null;
            Excel.Worksheet sheet = null;
            Excel.Range range = null;
            Excel.Range temprange = null;
            Excel.Range last = null;
            Object value2 = null;
            Object[,] input = null;

            try
            {                
                if (true)
                {
                    //THIS SEEMS TO WORK, cf also #5298375235                    
                    //Starts up faster this way
                    if (Globals.objApp == null)
                    {
                        Globals.objApp = new Excel.Application();
                    }
                    else if (Globals.excelLastThreadID != threadID)
                    {
                        //#5298375235
                        Globals.excelLastThreadID = threadID;
                        System.Runtime.InteropServices.Marshal.FinalReleaseComObject(Globals.objApp);
                        Globals.objApp = null;
                        GC.Collect();
                        GC.WaitForPendingFinalizers();
                        // GC needs to be called twice in order to get the Finalizers called
                        // - the first time in, it simply makes a list of what is to be
                        // finalized, the second time in, it actually is finalizing. Only
                        // then will the object do its automatic ReleaseComObject.
                        GC.Collect();
                        GC.WaitForPendingFinalizers();
                        Globals.objApp = new Excel.Application();
                    }
                    excel = Globals.objApp;
                }                

                workbooks = excel.Workbooks;

                wkb = OpenBook(workbooks, file, true, false, false);

                objSheets = wkb.Worksheets;

                if (sheetName == null)
                {
                    //do nothing, [1] is al
                    sheet = wkb.Sheets[1] as Excel.Worksheet;
                }
                else
                {
                    bool match = ExcelSheetCheckMatch(objSheets, sheetName);
                    if (match)
                    {
                        sheet = ExcelSheetTryGetSheet(objSheets, sheetName);
                    }
                    else
                    {
                        G.Writeln2("*** ERROR: The sheet '" + sheetName + "' does not seem to exist");
                    }
                }

                //G.Writeln("open excel " + G.Seconds(d3));

                if (sheet != null)
                {
                    temprange = sheet.Cells;
                    last = temprange.SpecialCells(Excel.XlCellType.xlCellTypeLastCell, Type.Missing);
                    range = sheet.get_Range("A1", last);
                    //DateTime t2 = DateTime.Now;
                    value2 = range.Value2;
                    input = (Object[,])value2;
                    //G.Writeln("interop " + G.Seconds(t2));

                    //This is faster regarding the data, but problem is we will not get an error
                    //that points to the problematic cell. Could be implemented at a later point,
                    //if Excel reading becomes a bottleneck.
                    //  double[,] dst = new double[input.GetLength(0), input.GetLength(1)];
                    //  Array.Copy(input, dst, input.Length);

                    int rows = input.GetLength(0);
                    int cols = input.GetLength(1);

                    //DateTime t0 = DateTime.Now;

                    for (int i = 0 + 1; i < rows + 1; i++)
                    {
                        for (int j = 0 + 1; j < cols + 1; j++)
                        {
                            Object temp = input[i, j];
                            if (temp == null) continue;
                            CellLight cell;
                            if (temp.GetType() == typeof(double))
                            {
                                cell = new CellLight((double)temp);
                            }
                            else if (temp.GetType() == typeof(int))
                            {
                                int iData = (int)temp;

                                //-2146826281 = #Div/0!
                                //-2146826246 = #N/A
                                //-2146826259 = #Name?
                                //-2146826288 = #Null!
                                //-2146826252 = #Num!
                                //-2146826265 = #Ref!  
                                //-2146826273 = #Value!

                                if (iData == -2146826246)
                                {
                                    //just like it is in a csv file. The -2146826246 is really a hexadecimal error code from Excel, stating that the number is N/A.
                                    cell = new CellLight("#N/A");
                                }
                                else if (iData == -2146826259)
                                {
                                    cell = new CellLight("#Name?");
                                }
                                else if (iData == -2146826281)
                                {
                                    cell = new CellLight("#Div/0");
                                }
                                else
                                {
                                    cell = new CellLight((double)iData);
                                }
                            }
                            else if (temp.GetType() == typeof(string))
                            {
                                cell = new CellLight((string)temp);
                            }
                            else
                            {
                                G.Writeln2("*** ERROR: Cell " + GetExcelCell(i, j, false) + " seems to be neither text or number.");
                                G.Writeln("           It has type " + temp.GetType().ToString(), Color.Red);
                                throw new GekkoException();
                            }
                            matrix.Add(i, j, cell);
                        }
                    }

                    //G.Writeln("loop excel " + G.Seconds(t0));
                }
            }
            catch (Exception ex)
            {
                //if you need to handle stuff
                G.Writeln2("*** ERROR: Get data from Excel failed with the following message:");
                G.Writeln(ex.Message, Color.Red);

                ErrorMessageExcelInterop();
            }
            finally
            {
                //not sure how much of this is absolutely necessary
                //see //#5298375235 and fusion it
                GC.Collect();
                GC.WaitForPendingFinalizers();
                GC.Collect();
                GC.WaitForPendingFinalizers();
                value2 = null;
                input = null;
                Marshal.ReleaseComObject(range);
                Marshal.ReleaseComObject(temprange);
                Marshal.ReleaseComObject(last);
                Marshal.ReleaseComObject(sheet);
                Marshal.ReleaseComObject(objSheets);
                wkb.Close(false);
                Marshal.ReleaseComObject(wkb);
                workbooks.Close();
                Marshal.ReleaseComObject(workbooks);
                excel.Quit();
                // Marshal.ReleaseComObject(excel);
            }
            //G.Writeln("full excel " + G.Seconds(t00));
            return matrix;
        }                

        public static ExcelDataForClip CreateExcelWorkbook2(ExcelOptions eo, O.Prt oPrt, bool isMulprt, bool isMatrix, string dateformat, string datetype)
        {
            if (G.Equal(Program.options.sheet_engine, "internal"))
            {
                return CreateExcelWorkbookEPPlus(eo, oPrt, isMulprt, isMatrix, dateformat, datetype);
            }
            else
            {
                if (isMatrix)
                {
                    G.Writeln2("*** ERROR: Matrix export only supported for OPTION sheet engine = internal");
                    throw new GekkoException();
                }
                return CreateExcelWorkbookPIA(eo, oPrt, isMulprt);
            }
        }


        //This basically transfers for instance the double[,] array eo.excelData to Excel via Epplus.
        //Just before this method, regarding SHEET, eo.excelData has been made from a Table containing
        //the SHEET output.
        private static ExcelDataForClip CreateExcelWorkbookEPPlus(ExcelOptions eo, O.Prt oPrt, bool isMulprt, bool isMatrix, string dateformat, string datetype)
        {

            //
            // NOTE: IsClipOrDna() is always false, these are not done here
            //       clip stuff and dna could be removed here
            //

            //1. append-     filename-     sheet-            show fakefilename sheet='Data'
            //2. append-     filename-     sheet+            show fakefilename sheet=sheetname
            //3. append-     filename+     sheet-            store filename sheet='Data'                        ...as above just silent
            //4. append-     filename+     sheet+            store filename sheet=sheetname                     ...as above just silent
            //5. append+     filename-     sheet-            FAIL
            //6. append+     filename-     sheet+            FAIL
            //7. append+     filename+     sheet-            append to filename, 'Sheet1' (first sheet)         ...use existing file
            //8. append+     filename+     sheet+            append to filename, sheetname                      ...use existing file

            bool useExcelDates = false;  //default
            bool isFirst = true;  //default
            string format = SplitDateFormatInTwo(dateformat, ref isFirst);

            if (G.Equal(datetype, "text")) useExcelDates = false;
            else if (G.Equal(datetype, "excel")) useExcelDates = true;

            try
            {

                bool copyLocal = true;  //always true                
                string fileNameWithPath = null;  //may be pointed to temp file
                string fileNameWithPathOriginal = null;  //may be null, for SHEET
                int blue = System.Drawing.ColorTranslator.ToOle(Globals.LightBlueWord);

                string ext = "xlsx";
                if (oPrt != null && oPrt.opt_filename != null) fileNameWithPath = oPrt.opt_filename;
                else if (eo.fileName != null) fileNameWithPath = eo.fileName;

                WriteXlsError(fileNameWithPath);

                if (fileNameWithPath != null)
                {
                    fileNameWithPath = AddExtension(CreateFullPathAndFileName(fileNameWithPath), ".xlsx");
                }
                fileNameWithPathOriginal = fileNameWithPath;
                
                EAppend append = EAppend.No;
                if (oPrt != null && oPrt.opt_append != null)
                {
                    if (G.Equal(oPrt.opt_append, "yes"))
                    {
                        append = EAppend.Yes;
                    }
                    else if (G.Equal(oPrt.opt_append, "no"))
                    {
                        //already set
                    }
                    else if (G.Equal(oPrt.opt_append, "ifexist"))
                    {
                        append = EAppend.Ifexist;
                    }
                    else
                    {
                        G.Writeln2("*** ERROR: Append option must be either yes, no or ifexist");
                        throw new GekkoException();
                    }
                }

                bool isAppend = false;
                if (append == EAppend.Yes) isAppend = true;
                if (append == EAppend.Ifexist)
                {
                    //only activate append if the file is already there
                    if (File.Exists(fileNameWithPathOriginal)) isAppend = true;
                }

                //bool isAppend = false; if (oPrt != null && G.Equal(oPrt.opt_append, "yes")) isAppend = true;

                //Deal with non-existing files
                if (isAppend)
                {
                    if (fileNameWithPathOriginal == null)
                    {
                        //(5) and (6)
                        G.Writeln2("*** ERROR: You cannot use SHEET<append> without indicating a xlsx filename.");
                        throw new GekkoException();
                    }

                    if (!File.Exists(fileNameWithPathOriginal))
                    {
                        G.Writeln2("*** ERROR: You cannot use SHEET<append> on a non-existing file: " + fileNameWithPathOriginal);
                        throw new GekkoException();
                    }
                }

                //Creates a blank workbook. Use the using statment, so the package is disposed when we are done.
                using (ExcelPackage excel = isAppend ? new ExcelPackage(new FileInfo(fileNameWithPathOriginal)) : new ExcelPackage())
                {
                    if (G.Equal(Path.GetExtension(fileNameWithPath), ".xlsm"))
                    {
                        //this injects some empty VBA code, and the file will then be of .xlsm type.
                        if (excel.Workbook.VbaProject == null) excel.Workbook.CreateVBAProject();
                    }

                    if (copyLocal)
                    {
                        fileNameWithPath = GetTempTsdFilePath(ext); //points to temp file now                     
                    }

                    bool isStamp = false; if (oPrt != null && G.Equal(oPrt.opt_stamp, "yes")) isStamp = true;
                    bool isDates = true; if (oPrt != null && G.Equal(oPrt.opt_dates, "no")) isDates = false;
                    bool isNames = true; if (oPrt != null && G.Equal(oPrt.opt_names, "no")) isNames = false;
                    bool isColors = true; if (oPrt != null && G.Equal(oPrt.opt_colors, "no")) isColors = false;

                    if (isMatrix)
                    {
                        isStamp = false;
                        isColors = false;
                        isNames = false;
                        isDates = false;
                        if (eo.excelRowLabels != null)
                        {
                            isNames = true;
                        }
                        if (eo.excelColumnLabels != null)
                        {
                            isDates = true;  //not really dates for matrices... but oh well                            
                        }
                    }

                    string sheet = null; if (oPrt != null) sheet = oPrt.opt_sheet;

                    bool isRows;
                    bool isCols;
                    HandleRowsCols(oPrt, out isRows, out isCols);

                    bool isTranspose = false;
                    if (isCols) isTranspose = true;  //Normally, SHEET has timeseries running in rows, unlike PRT default. So isTranspose means running in rows.
                    if (G.Equal(eo.transpose, "yes")) isTranspose = true;  //for WRITE<xlsx cols>

                    //string startCell = "a1"; if (oPrt != null && oPrt.opt_cell != null) startCell = oPrt.opt_cell;
                    int datesInt = 0; if (isDates) datesInt++;
                    int namesInt = 0; if (isNames) namesInt++;                    

                    ExcelWorksheet ws = null;

                    if (isAppend)
                    {
                        if (sheet != null)
                        {
                            //(8)
                            //try to locate the sheet, fail if it is not there
                            ws = excel.Workbook.Worksheets[sheet];
                            if (ws == null)
                            {
                                //we create it if it is not already there
                                ws = excel.Workbook.Worksheets.Add(sheet);
                            }
                        }
                        else
                        {
                            //(7)
                            //no sheet given, we take the one in the first position
                            ws = excel.Workbook.Worksheets.First<ExcelWorksheet>();
                        }
                    }
                    else
                    {
                        if (sheet != null)
                        {
                            //(2) and (4)
                            ws = excel.Workbook.Worksheets.Add(sheet);  //fresh workbook, add fresh sheet with the given name
                        }
                        else
                        {
                            //(1) and (3)
                            ws = excel.Workbook.Worksheets.Add("Data");  //fresh workbook with no sheet name given, we use default name
                        }
                    }

                    int rowcounter = 1;  //1-based
                    int colcounter = 1;  //1-based

                    if (true)
                    {
                        //See identical #98oiwu543w
                        string s2 = "a1";
                        if (oPrt != null && oPrt.opt_cell != null) s2 = oPrt.opt_cell;
                        int index = s2.IndexOfAny(new char[] { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9' });
                        string chars = s2.Substring(0, index);
                        int num = Int32.Parse(s2.Substring(index));
                        int rowOffset = num - 1;
                        int colOffset = ExcelColumnNameToNumber(chars) - 1;

                        rowcounter += rowOffset;
                        colcounter += colOffset;
                    }

                    if (isStamp)
                    {                        
                        string stamp = GetStamp(isMulprt);

                        if (true)
                        {
                            WorkBookHelper.WorkBookSetData_1(stamp, ws, rowcounter, colcounter);
                            ExcelRange range = ws.Cells[rowcounter, colcounter, rowcounter, colcounter];
                            range.Style.Font.Color.SetColor(System.Drawing.Color.Gray);
                            rowcounter++;
                        }
                    }

                    if (oPrt != null && oPrt.opt_title != null)
                    {
                        string heading = oPrt.opt_title;

                        if (true)
                        {
                            WorkBookHelper.WorkBookSetData_2(heading, ws, rowcounter, colcounter);
                            ExcelRange range = ws.Cells[rowcounter, colcounter, rowcounter, colcounter];
                            range.Style.Font.Bold = true;
                            rowcounter++;
                        }
                    }

                    // ======================== DATA MATRIX ===================================

                    //Get the range where the starting cell has the address
                    //m_sStartingCell and its dimensions are m_iNumRows x m_iNumCols.
                    int dataRows = eo.excelData.GetLength(0);
                    int dataCols = eo.excelData.GetLength(1);

                    int[,] excelColumnLabelsAnnual = new int[1, dataCols];

                    if (!isMatrix && eo.excelColumnLabels != null && options.freq == EFreq.A)
                    {
                        for (int i = 0; i < eo.excelColumnLabels.Length; i++)
                        {
                            //should never give an error
                            excelColumnLabelsAnnual[0, i] = int.Parse(eo.excelColumnLabels[0, i]);
                        }
                    }

                    double[,] data = eo.excelData;

                    int d1 = rowcounter + datesInt;
                    int d2 = colcounter + namesInt;

                    if (isTranspose)
                    {
                        d1 = rowcounter + namesInt;
                        d2 = colcounter + datesInt;
                        data = Transpose(eo.excelData);
                    }

                    if (true)
                    {
                        WorkBookHelper.WorkBookSetData_3(ws, data, d1, d2);

                        if (isColors)
                        {
                            int minus = 0;
                            if (!isTranspose && isNames) minus = 1;
                            if (isTranspose && isDates) minus = 1;
                            ExcelRange range = ws.Cells[d1, d2 - minus, d1 + data.GetLength(0) - 1, d2 + data.GetLength(1) - 1];
                            range.Style.Border.BorderAround(OfficeOpenXml.Style.ExcelBorderStyle.Medium, Globals.LightBlueWord);
                        }
                    }

                    string na = NaForExcelInDifferentLanguages(1);

                    for (int i = 0; i < data.GetLength(0); i++)
                    {
                        for (int j = 0; j < data.GetLength(1); j++)
                        {
                            if (data[i, j] == 9.99999e99d || G.isNumericalError(data[i, j]))
                            {
                                ws.Cells[d1 + i, d2 + j].Formula = "=" + na;
                            }
                        }
                    }

                    //DATES ROW ---------------------------------------------------------------------
                    //DATES ROW ---------------------------------------------------------------------
                    //DATES ROW ---------------------------------------------------------------------

                    if (isDates)
                    {

                        object[,] data2 = null;
                        object[][] datesData = null;

                        if (useExcelDates)
                        {
                            //cf. DateTime.FromOADate(excelvalue);

                            if (isTranspose)
                            {
                                for (int i = d1; i <= d1 + eo.excelColumnLabelsGekkoTime.GetLength(1) - 1; i++)
                                {
                                    for (int j = d2 - 1; j <= d2 - 1 + eo.excelColumnLabelsGekkoTime.GetLength(0) - 1; j++)
                                    {
                                        GekkoTime gt = eo.excelColumnLabelsGekkoTime[j - (d2 - 1), i - d1];
                                        DateTime dt; string f; string discard; GekkoTime.FromGekkoTimeToDifferentFormatsForWriting(gt, isFirst, format, out dt, out f, out discard);
                                        WorkBookHelper.WorkBookSetData_4(ws, i, j, dt, f);
                                    }
                                }
                            }
                            else
                            {
                                for (int i = d1 - 1; i <= d1 - 1 + eo.excelColumnLabelsGekkoTime.GetLength(0) - 1; i++)
                                {
                                    for (int j = d2; j <= d2 + eo.excelColumnLabelsGekkoTime.GetLength(1) - 1; j++)
                                    {
                                        GekkoTime gt = eo.excelColumnLabelsGekkoTime[i - (d1 - 1), j - d2];
                                        DateTime dt; string f; string discard; GekkoTime.FromGekkoTimeToDifferentFormatsForWriting(gt, isFirst, format, out dt, out f, out discard);
                                        WorkBookHelper.WorkBookSetData_5(ws, i, j, dt, f);
                                    }
                                }
                            }
                        }
                        else
                        {
                            //text based dates

                            if (IsGekkoDateFormat(format))
                            {
                                //text based without format --> 2010, 2010q3, 2010m3

                                if (!isMatrix && options.freq == EFreq.A)
                                {
                                    //else the cells are left-justified and with a green triangle (warning)
                                    int[,] datesData2 = null;
                                    if (isTranspose)
                                    {
                                        datesData2 = Transpose(excelColumnLabelsAnnual);
                                    }
                                    else
                                    {
                                        datesData2 = excelColumnLabelsAnnual;
                                    }
                                    datesData = ToJaggedArray(datesData2);
                                }
                                else
                                {
                                    object[,] data3 = null;
                                    if (isTranspose) data3 = Transpose(eo.excelColumnLabels);
                                    else data3 = eo.excelColumnLabels;
                                    datesData = ToJaggedArray(data3);
                                }
                            }
                            else
                            {
                                string[,] tmp = new string[eo.excelColumnLabelsGekkoTime.GetLength(0), eo.excelColumnLabelsGekkoTime.GetLength(1)];
                                for (int i = 0; i < eo.excelColumnLabelsGekkoTime.GetLength(0); i++)
                                {
                                    for (int j = 0; j < eo.excelColumnLabelsGekkoTime.GetLength(1); j++)
                                    {
                                        DateTime dt; string f; string date_as_string;
                                        GekkoTime.FromGekkoTimeToDifferentFormatsForWriting(eo.excelColumnLabelsGekkoTime[i, j], isFirst, format, out dt, out f, out date_as_string);
                                        tmp[i, j] = date_as_string;
                                    }
                                }
                                object[,] data3 = null;
                                if (isTranspose) data3 = Transpose(tmp);
                                else data3 = tmp;
                                datesData = ToJaggedArray(data3);
                            }

                            if (isTranspose)
                            {
                                WorkBookHelper.WorkBookSetData_6(ws, d1, d2, datesData);
                            }
                            else
                            {
                                WorkBookHelper.WorkBookSetData_7(ws, d1, d2, datesData);
                            }
                        }

                        if (!isTranspose && isColors)
                        {
                            int minus = 0;
                            if (isNames) minus = 1;
                            ExcelRange range = ws.Cells[d1 - 1, d2 - minus, d1 - 1 + eo.excelColumnLabels.GetLength(0) - 1, d2 + eo.excelColumnLabels.GetLength(1) - 1];
                            range.Style.Fill.PatternType = OfficeOpenXml.Style.ExcelFillStyle.Solid;
                            range.Style.Fill.BackgroundColor.SetColor(Globals.LightBlueWord);
                            range.Style.Font.Color.SetColor(Color.White);
                        }                        
                    }

                    //====================== VARIABLE NAMES COLUMN -----------------------------------------------------------------

                    if (isNames)
                    {
                        string[,] labels = null;
                        if (isTranspose)
                        {
                            labels = Transpose(eo.excelRowLabels);
                            WorkBookHelper.WorkBookSetData_8(ws, d1, d2, labels);

                            if (isColors)
                            {
                                int minus = 0;
                                if (isDates) minus = 1;
                                ExcelRange range = ws.Cells[d1 - 1, d2 - minus, d1 - 1 + labels.GetLength(0) - 1, d2 + labels.GetLength(1) - 1];
                                range.Style.Fill.PatternType = OfficeOpenXml.Style.ExcelFillStyle.Solid;
                                range.Style.Fill.BackgroundColor.SetColor(Globals.LightBlueWord);
                                range.Style.Font.Color.SetColor(Color.White);
                            }
                        }
                        else
                        {
                            labels = eo.excelRowLabels;
                            WorkBookHelper.WorkBookSetData_9(ws, d1, d2, labels);
                        }                        
                    }                                     

                    //Save the new workbook. We haven't specified the filename so use the Save as method.
                    excel.SaveAs(new FileInfo(fileNameWithPath));

                    if (copyLocal)
                    {
                        if (fileNameWithPathOriginal != null)
                        {
                            try
                            {
                                if (File.Exists(fileNameWithPathOriginal)) WaitForFileDelete(fileNameWithPathOriginal);  //probably not necessary
                                WaitForFileCopy(fileNameWithPath, fileNameWithPathOriginal);
                                if (true) G.Writeln2("Wrote dataset with " + dataRows + " rows and " + dataCols + " cols to " + fileNameWithPathOriginal);
                            }
                            catch (Exception e)
                            {
                                G.Writeln();
                                G.Writeln("*** ERROR: Could not write Excel file -- is it open/blocked?: " + fileNameWithPathOriginal);
                                throw new GekkoException();
                            }
                        }
                    }
                }

                if (fileNameWithPathOriginal == null)
                {
                    try
                    {
                        System.Diagnostics.Process.Start(fileNameWithPath);  //seems faster than below
                                                                             //System.Diagnostics.Process.Start("excel.exe", fileNameWithPath);                 
                    }
                    catch (Exception e)
                    {
                        G.Writeln2("*** ERROR: Opening the produced .xlsx file with an external program associated with .xlsx");
                        G.Writeln("    files (such as for example Microsoft Excel) failed.", Color.Red);
                        G.Writeln("*** ERROR: " + e.Message);
                    }
                }
            }
            catch (Exception e)
            {
                if (!(e is GekkoException))
                {
                    if (e.Message != null && e.Message != "")
                    {
                        G.Writeln2("*** ERROR: " + e.Message);
                        WriteExcelError();
                    }
                }
                throw;
            }

            return null;
        }

        private static string GetStamp(bool isMulprt)
        {
            StampTypes type = StampTypes.Normal;
            if (isMulprt) type = StampTypes.Multiplier; //we drop .Base for now...

            List<string> lines = GetDatabankInfo(type);
            string ss = GetDateTimeStamp() + ". ";
            foreach (string s in lines)
            {
                ss = ss + s + ". ";
            }
            if (ss.EndsWith(". ")) ss = ss.Substring(0, ss.Length - 2);
            return ss;
        }        

        private static string SplitDateFormatInTwo(string dateformat, ref bool isFirst)
        {
            string format = null;
            if (dateformat != null)
            {
                format = dateformat;

                if (dateformat.Trim().EndsWith(" first", StringComparison.OrdinalIgnoreCase))
                {
                    format = dateformat.Trim().Substring(0, dateformat.Trim().Length - " first".Length);
                    isFirst = true;
                }
                else if (dateformat.Trim().EndsWith(" last", StringComparison.OrdinalIgnoreCase))
                {
                    format = dateformat.Trim().Substring(0, dateformat.Trim().Length - " last".Length);
                    isFirst = false;
                }
            }

            return format;
        }


        public static object[][] ToJaggedArray<T>(T[,] twoDimensionalArray)
        {
            int rowsFirstIndex = twoDimensionalArray.GetLowerBound(0);
            int rowsLastIndex = twoDimensionalArray.GetUpperBound(0);
            int numberOfRows = rowsLastIndex + 1;

            int columnsFirstIndex = twoDimensionalArray.GetLowerBound(1);
            int columnsLastIndex = twoDimensionalArray.GetUpperBound(1);
            int numberOfColumns = columnsLastIndex + 1;


            object[][] jaggedArray = new object[numberOfRows][];
            //List<object[]> xx = new List<object[]>(numberOfRows);
            object[][] xx = new object[numberOfRows][];

            for (int i = rowsFirstIndex; i <= rowsLastIndex; i++)
            {
                //jaggedArray[i] = (object[])new T[numberOfColumns];

                xx[i] = new object[numberOfColumns];


                for (int j = columnsFirstIndex; j <= columnsLastIndex; j++)
                {
                    //jaggedArray[i][j] = twoDimensionalArray[i, j];
                    xx[i][j] = twoDimensionalArray[i, j];
                }
            }
            return xx;
        }



        private static ExcelDataForClip CreateExcelWorkbookPIA(ExcelOptions eo, O.Prt oPrt, bool isMulprt)
        {
            Excel.Workbook objBook = null;

            //TODO: #89073253245
            //this method transposes the input-table itself, which is a bit stupid since the table
            //is easy to transpose when it is constructed (with option rows/cols)

            string stampText = null;
            //TODO: think about extensions. If no extension given, it seems append=yes does not work properly.
            ExcelDataForClip cplotData = new ExcelDataForClip();  //only used if called from CSHEET, data are fetched and returned, but not used for normal WPLOT use.
            bool copyLocal = true;
            int threadID = (int)AppDomain.GetCurrentThreadId();  //should be ok, just not for "fibre" threads (on SQL server)... never mind
            //int managedThreadId = Thread.CurrentThread.ManagedThreadId;  //duer ikke, er ikke distinkt nok
            int blue = System.Drawing.ColorTranslator.ToOle(Globals.LightBlueWord);
            bool blueColors = Program.options.interface_excel_modernlook;
            string version = GetExcelVersion(eOfficeApp.eOfficeApp_Excel);
            if (eo.fileName != null) G.Write("Calling Excel " + version + " ... ");
            //see MS bug 320369
            //without, there was a bug on Excel 2003 (english version), where the language was set to
            //something different that english.
            System.Globalization.CultureInfo oldCI = System.Threading.Thread.CurrentThread.CurrentCulture;
            System.Threading.Thread.CurrentThread.CurrentCulture = new System.Globalization.CultureInfo("en-US");

            try  //this try makes ture the thread currentculture is set back to what it was
            {

                Excel.Workbooks objBooks = null;
                Excel.Sheets objSheets = null;
                Excel.Worksheet objSheet = null;
                Excel.Range range = null;
                Excel.Worksheet newSheet = null;

                bool isStamp = false; if (oPrt != null && G.Equal(oPrt.opt_stamp, "yes")) isStamp = true;
                bool isDates = true; if (oPrt != null && G.Equal(oPrt.opt_dates, "no")) isDates = false;
                bool isNames = true; if (oPrt != null && G.Equal(oPrt.opt_names, "no")) isNames = false;
                bool isColors = true; if (oPrt != null && G.Equal(oPrt.opt_colors, "no")) isColors = false;
                bool isAppend = false; if (oPrt != null && G.Equal(oPrt.opt_append, "yes")) isAppend = true;
                string sheet = null; if (oPrt != null) sheet = oPrt.opt_sheet;


                bool isRows;
                bool isCols;
                HandleRowsCols(oPrt, out isRows, out isCols);

                bool isTranspose = false;
                if (isCols) isTranspose = true;  //Normally, SHEET has timeseries running in rows, unlike PRT default. So isTranspose means running in rows.
                if (G.Equal(eo.transpose, "yes")) isTranspose = true;  //for WRITE<xlsx cols>

                string startCell = "a1"; if (oPrt != null && oPrt.opt_cell != null) startCell = oPrt.opt_cell;

                int datesInt = 0; if (isDates) datesInt++;
                int namesInt = 0; if (isNames) namesInt++;

                string fileNameWithPath = null;
                string fileName3 = null;
                string fileNameOriginalFile = null;
                string fileNameTempLocalFile = null;

                string ext = null;

                string fileName = null;
                if (oPrt != null && oPrt.opt_filename != null) fileName = oPrt.opt_filename;
                else if (eo.fileName != null) fileName = eo.fileName;

                if (fileName != null)
                {
                    fileNameWithPath = CreateFullPathAndFileName(fileName);
                    fileName3 = fileNameWithPath;
                    if (fileName3.ToLower().EndsWith(".xls")) fileName3 = fileName3.Substring(0, fileName3.Length - 4);
                    if (fileName3.ToLower().EndsWith(".xlsx")) fileName3 = fileName3.Substring(0, fileName3.Length - 5);
                    //fileName3 is stripped of .xls or .xlsx
                    fileNameOriginalFile = "";

                    //A bit hacky...........
                    if (version == "2000" || version == "2003" || version == "95" || version == "97" || version == "XP")
                    {
                        ext = "xls";
                    }
                    else
                    {
                        //"2007"
                        //"2010"
                        //"Unrecognized version", including successor to 2010
                        ext = "xlsx";
                    }
                    fileNameOriginalFile = fileName3 + "." + ext;
                }

                fileNameTempLocalFile = fileNameOriginalFile;  //3a is original file, 4 may become a local copy below

                if (copyLocal)
                {
                    fileNameTempLocalFile = GetTempTsdFilePath(ext);
                    if (isAppend)
                    {
                        try
                        {
                            WaitForFileCopy(fileNameOriginalFile, fileNameTempLocalFile);
                        }
                        catch (Exception e)
                        {
                            G.Writeln();
                            G.Writeln("*** ERROR: Could not find file: " + fileNameOriginalFile);
                            throw new GekkoException();
                        }
                    }
                }

                try
                {
                    if (!eo.isClip)
                    {
                        if (isAppend)
                        {
                            //TODO, BUG: there is a problem here, if fileNameWithPath has no extension

                            if (Globals.objApp == null)
                            {
                                Globals.objApp = new Excel.Application();
                            }
                            else if (Globals.excelLastThreadID != threadID)
                            {
                                //#5298375235
                                Globals.excelLastThreadID = threadID;
                                System.Runtime.InteropServices.Marshal.FinalReleaseComObject(Globals.objApp);
                                Globals.objApp = null;
                                GC.Collect();
                                GC.WaitForPendingFinalizers();
                                // GC needs to be called twice in order to get the Finalizers called
                                // - the first time in, it simply makes a list of what is to be
                                // finalized, the second time in, it actually is finalizing. Only
                                // then will the object do its automatic ReleaseComObject.
                                GC.Collect();
                                GC.WaitForPendingFinalizers();
                                Globals.objApp = new Excel.Application();
                            }

                            objBooks = Globals.objApp.Workbooks;
                            objBook = objBooks.Open(fileNameTempLocalFile,
                                Type.Missing, Type.Missing, Type.Missing, Type.Missing,
                                Type.Missing, Type.Missing, Type.Missing, Type.Missing,
                                Type.Missing, Type.Missing, Type.Missing, Type.Missing,
                                Type.Missing, Type.Missing);
                            objSheets = objBook.Worksheets;
                            if (sheet == null)
                            {
                                objSheet = (Excel.Worksheet)objSheets.get_Item(1);
                            }
                            else
                            {
                                bool match = ExcelSheetCheckMatch(objSheets, sheet);
                                if (match)
                                {
                                    objSheet = ExcelSheetTryGetSheet(objSheets, sheet);

                                }
                                else
                                {
                                    //creating a new one
                                    objSheet = (Excel.Worksheet)objSheets.Add(objSheets[1], Type.Missing, Type.Missing, Type.Missing);
                                    objSheet.Name = sheet;
                                }
                                // The first argument below inserts the new worksheet as the first one
                            }
                        }
                        else
                        {
                            // Instantiate Excel and start a new workbook.
                            Globals.objApp = new Excel.Application();
                            objBooks = Globals.objApp.Workbooks;
                            objBook = objBooks.Add(Missing.Value);
                            objSheets = objBook.Worksheets;
                            objSheet = (Excel.Worksheet)objSheets.get_Item(1);
                            if (sheet != null)
                            {
                                objSheet.Name = sheet;
                            }
                        }
                    }

                    Excel.Range range0 = null;

                    if (!eo.isClip) range0 = objSheet.get_Range(startCell, Missing.Value);

                    if (isStamp)
                    {
                        StampTypes type = StampTypes.Normal;
                        if (isMulprt) type = StampTypes.Multiplier; //we drop .Base for now...

                        List<string> lines = GetDatabankInfo(type);
                        string ss = GetDateTimeStamp() + ". ";
                        foreach (string s in lines)
                        {
                            ss = ss + s + ". ";
                        }
                        if (ss.EndsWith(". ")) ss = ss.Substring(0, ss.Length - 2);
                        cplotData.stamp = ss;
                        if (!eo.isClip) if (isColors) range0.Font.Color = System.Drawing.ColorTranslator.ToOle(System.Drawing.Color.Gray);
                        if (!eo.isClip) range0.set_Value(Missing.Value, cplotData.stamp);
                        if (!eo.isClip) range0 = range0.get_Offset(1, 0);
                    }

                    if (oPrt != null && oPrt.opt_title != null)
                    {
                        cplotData.heading = oPrt.opt_title;
                        if (!eo.isClip) if (isColors) range0.Font.Bold = true;
                        if (!eo.isClip) range0.set_Value(Missing.Value, cplotData.heading);
                        if (!eo.isClip) range0 = range0.get_Offset(1, 0);
                    }


                    // ======================== DATA MATRIX ===================================

                    //Get the range where the starting cell has the address
                    //m_sStartingCell and its dimensions are m_iNumRows x m_iNumCols.
                    int dataRows = eo.excelData.GetLength(0);
                    int dataCols = eo.excelData.GetLength(1);

                    int[,] excelColumnLabelsAnnual = new int[1, dataCols];
                    if (options.freq == EFreq.A)
                    {
                        for (int i = 0; i < eo.excelColumnLabels.Length; i++)
                        {
                            //should never give an error
                            excelColumnLabelsAnnual[0, i] = int.Parse(eo.excelColumnLabels[0, i]);
                        }
                    }

                    if (isTranspose)
                    {
                        if (!eo.isClip) range = range0.get_Offset(namesInt, datesInt);
                        if (!eo.isClip) range = range.get_Resize(dataCols, dataRows);
                        double[,] data = Transpose(eo.excelData);
                        if (!eo.isClip) range.set_Value(Missing.Value, data);
                        cplotData.data = data;
                    }
                    else
                    {
                        if (!eo.isClip) range = range0.get_Offset(datesInt, namesInt);
                        if (!eo.isClip) range = range.get_Resize(dataRows, dataCols);
                        double[,] data = eo.excelData;
                        if (!eo.isClip) range.set_Value(Missing.Value, data);
                        cplotData.data = data;
                    }

                    string na = NaForExcelInDifferentLanguages(0);

                    if (!eo.isClip)
                    {
                        Globals.objApp.DisplayAlerts = false;
                        bool success = (bool)range.Replace(
                            "9,99999E+99",
                            "=" + na,
                            1, //XlLookAt.xlWhole,
                            1, //XlSearchOrder.xlByRows,
                            true, Type.Missing, Type.Missing, Type.Missing);
                        success = (bool)range.Replace(
                            "9.99999E+99",
                            "=" + na,
                            1, //XlLookAt.xlWhole,
                            1, //XlSearchOrder.xlByRows,
                            true, Type.Missing, Type.Missing, Type.Missing);
                        success = (bool)range.Replace(  //309827520439857
                            "65535",
                            "=" + na,
                            1, //XlLookAt.xlWhole,
                            1, //XlSearchOrder.xlByRows,
                            true, Type.Missing, Type.Missing, Type.Missing);
                        Globals.objApp.DisplayAlerts = true;
                    }

                    //DATES ROW ---------------------------------------------------------------------
                    //range = objSheet.get_Range("B2", Missing.Value);

                    if (isDates)
                    {

                        if (!eo.isClip)
                        {
                            if (isTranspose)
                            {
                                range = range0.get_Offset(namesInt, 0);
                                range = range.get_Resize(dataCols, 1);
                            }
                            else
                            {
                                range = range0.get_Offset(0, namesInt);
                                range = range.get_Resize(1, dataCols);
                            }
                        }

                        string[,] data2 = null;

                        if (options.freq == EFreq.A)
                        {
                            //else the cells are left-justified and with a green triangle (warning)

                            int[,] data = null;
                            if (isTranspose)
                            {
                                data = Transpose(excelColumnLabelsAnnual);
                                if (!eo.isClip) range.set_Value(Missing.Value, data);
                            }
                            else
                            {
                                data = excelColumnLabelsAnnual;
                                if (!eo.isClip) range.set_Value(Missing.Value, data);
                            }
                            data2 = ConvertToString(data);
                        }
                        else
                        {
                            string[,] data3 = null;
                            if (isTranspose)
                            {
                                data3 = Transpose(eo.excelColumnLabels);
                                if (!eo.isClip) range.set_Value(Missing.Value, data3);
                            }
                            else
                            {
                                data3 = eo.excelColumnLabels;
                                if (!eo.isClip) range.set_Value(Missing.Value, data3);
                            }
                            data2 = data3;
                        }
                        cplotData.dates = data2;
                    }

                    //====================== VARIABLE NAMES COLUMN -----------------------------------------------------------------

                    if (isNames)
                    {
                        string[,] labels = null;
                        if (isTranspose)
                        {
                            if (!eo.isClip) range = range0.get_Offset(0, datesInt);
                            if (!eo.isClip) range = range.get_Resize(1, dataRows);
                            labels = Transpose(eo.excelRowLabels);
                            if (!eo.isClip) range.set_Value(Missing.Value, labels);
                        }
                        else
                        {
                            if (!eo.isClip) range = range0.get_Offset(datesInt, 0);
                            if (!eo.isClip) range = range.get_Resize(dataRows, 1);
                            labels = eo.excelRowLabels;
                            if (!eo.isClip) range.set_Value(Missing.Value, labels);
                        }
                        cplotData.varnames = labels;
                    }

                    cplotData.transpose = isTranspose;
                    if (eo.isClip) return cplotData;

                    //====================== coloring ==============================

                    if (isColors)
                    {
                        if (isTranspose)  //dates running downwards
                        {
                            if (isNames)
                            {
                                //Names row
                                range = range0.get_Offset(0, 0);
                                range = range.get_Resize(1, dataRows + datesInt);
                                if (blueColors)
                                {
                                    range.Interior.Color = blue;
                                    range.Font.Color = System.Drawing.ColorTranslator.ToOle(System.Drawing.Color.White);
                                }
                                else
                                {
                                    range.Borders[Excel.XlBordersIndex.xlEdgeTop].Weight = Excel.XlBorderWeight.xlMedium;
                                    range.Borders[Excel.XlBordersIndex.xlEdgeBottom].Weight = Excel.XlBorderWeight.xlMedium;
                                }
                            }
                        }
                        else
                        {
                            if (isDates)
                            {
                                //Dates row
                                range = range0.get_Offset(0, 0);
                                range = range.get_Resize(1, dataCols + namesInt);
                                if (blueColors)
                                {
                                    range.Interior.Color = blue;
                                    range.Font.Color = System.Drawing.ColorTranslator.ToOle(System.Drawing.Color.White);
                                }
                                else
                                {
                                    range.Borders[Excel.XlBordersIndex.xlEdgeTop].Weight = Excel.XlBorderWeight.xlMedium;
                                    range.Borders[Excel.XlBordersIndex.xlEdgeBottom].Weight = Excel.XlBorderWeight.xlMedium;
                                }
                            }
                        }

                        //Data border
                        if (isTranspose)
                        {
                            range = range0.get_Offset(0, 0);
                            range = range.get_Resize(dataCols + namesInt, dataRows + datesInt);
                        }
                        else
                        {
                            range = range0.get_Offset(0, 0);
                            range = range.get_Resize(dataRows + datesInt, dataCols + namesInt);
                        }
                        if (blueColors)
                        {
                            range.Borders[Excel.XlBordersIndex.xlEdgeTop].Weight = Excel.XlBorderWeight.xlMedium;
                            range.Borders[Excel.XlBordersIndex.xlEdgeTop].Color = blue;
                            range.Borders[Excel.XlBordersIndex.xlEdgeBottom].Weight = Excel.XlBorderWeight.xlMedium;
                            range.Borders[Excel.XlBordersIndex.xlEdgeBottom].Color = blue;
                            range.Borders[Excel.XlBordersIndex.xlEdgeLeft].Weight = Excel.XlBorderWeight.xlMedium;
                            range.Borders[Excel.XlBordersIndex.xlEdgeLeft].Color = blue;
                            range.Borders[Excel.XlBordersIndex.xlEdgeRight].Weight = Excel.XlBorderWeight.xlMedium;
                            range.Borders[Excel.XlBordersIndex.xlEdgeRight].Color = blue;
                        }
                        else
                        {
                            range.Borders[Excel.XlBordersIndex.xlEdgeTop].Weight = Excel.XlBorderWeight.xlMedium;
                            range.Borders[Excel.XlBordersIndex.xlEdgeBottom].Weight = Excel.XlBorderWeight.xlMedium;
                        }

                    }

                    // ===================== put cursor =========================

                    if (fileName == null)
                    {
                        //Return control of Excel to the user.
                        Globals.objApp.Visible = true;
                        Globals.objApp.UserControl = true;
                    }
                    else
                    {
                        // Save the Workbook and quit Excel.
                        Globals.objApp.DisplayAlerts = false;
                        if (isAppend == false)
                        {
                            if (File.Exists(fileNameTempLocalFile)) WaitForFileDelete(fileNameTempLocalFile);  //probably not necessary
                        }
                        if (isAppend)
                        {
                            objBook.Save();
                        }
                        else
                        {
                            //This may just file without error, and without producing a file -- BAD!
                            objBook.SaveCopyAs(fileNameTempLocalFile);
                            //objBook.SaveAs(fileName4, Missing.Value, Missing.Value,
                            //    Missing.Value, false, false, Excel.XlSaveAsAccessMode.xlNoChange,
                            //    false, false, Missing.Value, Missing.Value, Missing.Value);
                        }

                        if (copyLocal)
                        {
                            try
                            {
                                //Maybe use WaitForFileCopy() here at some point.
                                //Not sure why fileNameOriginalFile is deleted first (safety?)
                                WaitForFileCopy(fileNameTempLocalFile, fileNameOriginalFile);
                            }
                            catch (Exception e)
                            {
                                G.Writeln();
                                G.Writeln("*** ERROR: Could not write Excel file -- is it open/blocked?: " + fileNameOriginalFile);
                                throw new GekkoException();
                            }
                        }

                        ExcelCleanup(ref objBook, ref objBooks, ref objSheets, ref objSheet, ref range, ref newSheet, ref range0);
                        if (true) G.Writeln2("Wrote dataset with " + dataRows + " rows and " + dataCols + " cols to " + fileNameOriginalFile);
                    }
                    return null;
                }
                catch (Exception theException)
                {
                    //G.Writeln(" ...did not finish");
                    String errorMessage;
                    errorMessage = "*** ERROR: Excel failed with the following error: ";
                    errorMessage = String.Concat(errorMessage, theException.Message);
                    errorMessage = String.Concat(errorMessage, " Line: ");
                    errorMessage = String.Concat(errorMessage, theException.Source);
                    G.Writeln(errorMessage);
                    //see MS bug 320369

                    ErrorMessageExcelInterop();

                    System.Threading.Thread.CurrentThread.CurrentCulture = oldCI;
                    throw new GekkoException();
                }
            }
            finally
            {
                //see MS bug 320369
                System.Threading.Thread.CurrentThread.CurrentCulture = oldCI;
            }
        }

        private static void ErrorMessageExcelInterop()
        {
            G.Writeln2("+++ NOTE: The Excel engine for import/export of Excel sheets is slow and unstable.");
            G.Writeln("          Consider setting OPTION sheet engine = internal, using a better in-built engine for this.");
            G.Writeln("          However, this only works for the newer .xlsx file format, not for .xls files.");
            G.Writeln();
        }

        private static void ExcelCleanup(ref Excel.Workbook objBook, ref Excel.Workbooks objBooks, ref Excel.Sheets objSheets, ref Excel.Worksheet objSheet, ref Excel.Range range, ref Excel.Worksheet newSheet, ref Excel.Range range0)
        {
            objBook.Close(false, Missing.Value, Missing.Value);

            Globals.objApp.DisplayAlerts = true;

            if (newSheet != null)
            {
                System.Runtime.InteropServices.Marshal.FinalReleaseComObject(newSheet);
                newSheet = null;
            }
            if (range != null)
            {
                System.Runtime.InteropServices.Marshal.FinalReleaseComObject(range);
                range = null;
            }
            if (range0 != null)
            {
                System.Runtime.InteropServices.Marshal.FinalReleaseComObject(range0);
                range0 = null;
            }
            if (objSheet != null)
            {
                System.Runtime.InteropServices.Marshal.FinalReleaseComObject(objSheet);
                objSheet = null;
            }
            if (objSheets != null)
            {
                System.Runtime.InteropServices.Marshal.FinalReleaseComObject(objSheets);
                objSheets = null;
            }
            if (objBook != null)
            {
                System.Runtime.InteropServices.Marshal.FinalReleaseComObject(objBook);
                objBook = null;
            }
            if (objBooks != null)
            {
                System.Runtime.InteropServices.Marshal.FinalReleaseComObject(objBooks);
                objBooks = null;
            }
            //see also id7372367
            //Globals.objApp = null;  --> dealt with when Gekko exits.
            GC.Collect();
            GC.WaitForPendingFinalizers();
            // GC needs to be called twice in order to get the Finalizers called
            // - the first time in, it simply makes a list of what is to be
            // finalized, the second time in, it actually is finalizing. Only
            // then will the object do its automatic ReleaseComObject.
            GC.Collect();
            GC.WaitForPendingFinalizers();
        }

        private static Excel.Worksheet ExcelSheetTryGetSheet(Excel.Sheets objSheets, string sheet)
        {
            Excel.Worksheet objSheet;
            try
            {
                objSheet = (Excel.Worksheet)objSheets[sheet];  //seems it is not case sensitive
            }
            catch (Exception e)
            {
                G.Writeln2("*** ERROR: problem while trying to access to existing sheet '" + sheet + "'");
                throw new GekkoException();
            }

            return objSheet;
        }

        private static bool ExcelSheetCheckMatch(Excel.Sheets objSheets, string sheet)
        {
            bool match = false;
            foreach (Excel.Worksheet xx in objSheets)
            {
                if (G.Equal(xx.Name.Trim(), sheet.Trim()))
                {
                    match = true;
                }
            }

            return match;
        }

        private static void HandleRowsCols(O.Prt oPrt, out bool isRows, out bool isCols)
        {
            isRows = false;
            isCols = false;
            if (oPrt != null)
            {
                if (G.Equal(oPrt.prtType, "sheet") || G.Equal(oPrt.prtType, "clip"))
                {
                    isRows = Program.options.sheet_rows;
                    isCols = Program.options.sheet_cols;
                }
                else
                {
                    isRows = false;
                    isCols = true;
                }

                if (isRows && isCols)
                {
                    G.Writeln2("*** ERROR: It seems that OPTION sheet rows/cols are both set to 'yes'");
                    throw new GekkoException();
                }
                if (G.Equal(oPrt.opt_rows, "yes") && G.Equal(oPrt.opt_cols, "yes"))
                {
                    G.Writeln2("*** ERROR: It seems that options <rows> and <cols> are used at the same time");
                    throw new GekkoException();
                }
                if (G.Equal(oPrt.opt_rows, "yes"))
                {
                    isRows = true;
                    isCols = false;
                }
                else if (G.Equal(oPrt.opt_cols, "yes"))
                {
                    isRows = false;
                    isCols = true;
                }
            }
            else
            {
                isRows = true;
                isCols = false;
            }
        }

        public static string GetExcelVersion(Program.eOfficeApp app)
        {
            return Program.GetExcelVersion2(Program.GetApplicationVersion(app));
        }

        public static double[,] Transpose(double[,] x)
        {
            double[,] y = new double[x.GetLength(1), x.GetLength(0)];
            for (int i = 0; i < x.GetLength(0); i++)
            {
                for (int j = 0; j < x.GetLength(1); j++)
                {
                    y[j, i] = x[i, j];
                }
            }
            return y;
        }

        public static GekkoTime[,] Transpose(GekkoTime[,] x)
        {
            GekkoTime[,] y = new GekkoTime[x.GetLength(1), x.GetLength(0)];
            for (int i = 0; i < x.GetLength(0); i++)
            {
                for (int j = 0; j < x.GetLength(1); j++)
                {
                    y[j, i] = x[i, j];
                }
            }
            return y;
        }

        public static void Rungenr(int i)
        {
            if (i == 1)
            {
                if (Globals.lastDynamicCsCode != null && Globals.lastDynamicCsCode.Contains("TranslatedCode"))
                {
                    string s = Application.ExecutablePath;
                    string s2 = Path.GetDirectoryName(s);
                    string s3 = s2.Replace("\\Debug", "");
                    string s4 = s3.Replace("\\bin", "");
                    StreamWriter sw = new StreamWriter(s4 + "\\Genr.cs");
                    sw.Write(Globals.lastDynamicCsCode);
                    sw.Flush();
                    sw.Close();
                }
                else
                {
                    G.Writeln2("---> empty CS code... --> fail");
                }
            }
            else if (i == 2)
            {
                //Gekko.TranslatedCode.CodeLines(new P());
                TranslatedCode xx = new TranslatedCode();
                TranslatedCode.CodeLines(new P());
            }
        }


        public delegate object FastInvokeHandler(object _target, object[] _params);

        /// <summary>
        /// A class to invoke methods using System.Reflection.Emit.DynamicMethod (.NET 2.0).
        /// </summary>
        public sealed class FastMethodInvoker
        {
            private FastMethodInvoker() { }

            /// <summary>
            /// Returns DynamicMethod.
            /// </summary>
            /// <param name="_methodInfo">MethodInfo.</param>
            /// <returns>Delegate</returns>
            public static FastInvokeHandler GetMethodInvoker(MethodInfo _methodInfo)
            {
                DynamicMethod dynamicMethod = new DynamicMethod(string.Empty, typeof(object), new Type[] { typeof(object), typeof(object[]) }, _methodInfo.DeclaringType.Module);
                ILGenerator il = dynamicMethod.GetILGenerator();
                ParameterInfo[] ps = _methodInfo.GetParameters();
                Type[] paramTypes = new Type[ps.Length];
                for (int ii = 0; ii < paramTypes.Length; ii++)
                {
                    if (ps[ii].ParameterType.IsByRef)
                        paramTypes[ii] = ps[ii].ParameterType.GetElementType();
                    else
                        paramTypes[ii] = ps[ii].ParameterType;
                }
                LocalBuilder[] locals = new LocalBuilder[paramTypes.Length];

                for (int ii = 0; ii < paramTypes.Length; ii++)
                {
                    locals[ii] = il.DeclareLocal(paramTypes[ii], true);
                }

                for (int ii = 0; ii < paramTypes.Length; ii++)
                {
                    il.Emit(OpCodes.Ldarg_1);
                    EmitFastInt(il, ii);
                    il.Emit(OpCodes.Ldelem_Ref);
                    EmitCastToReference(il, paramTypes[ii]);
                    il.Emit(OpCodes.Stloc, locals[ii]);
                }
                il.Emit(OpCodes.Ldarg_0);
                for (int ii = 0; ii < paramTypes.Length; ii++)
                {
                    if (ps[ii].ParameterType.IsByRef)
                        il.Emit(OpCodes.Ldloca_S, locals[ii]);
                    else
                        il.Emit(OpCodes.Ldloc, locals[ii]);
                }
                il.EmitCall(OpCodes.Callvirt, _methodInfo, null);
                if (_methodInfo.ReturnType == typeof(void))
                    il.Emit(OpCodes.Ldnull);
                else
                    EmitBoxIfNeeded(il, _methodInfo.ReturnType);

                for (int ii = 0; ii < paramTypes.Length; ii++)
                {
                    if (ps[ii].ParameterType.IsByRef)
                    {
                        il.Emit(OpCodes.Ldarg_1);
                        EmitFastInt(il, ii);
                        il.Emit(OpCodes.Ldloc, locals[ii]);
                        if (locals[ii].LocalType.IsValueType)
                            il.Emit(OpCodes.Box, locals[ii].LocalType);
                        il.Emit(OpCodes.Stelem_Ref);
                    }
                }

                il.Emit(OpCodes.Ret);
                FastInvokeHandler invoker = (FastInvokeHandler)dynamicMethod.CreateDelegate(typeof(FastInvokeHandler));
                return invoker;
            }

            /// <summary>
            /// Emits the cast to reference.
            /// </summary>
            /// <param name="il">The il.</param>
            /// <param name="type">The type.</param>
            private static void EmitCastToReference(ILGenerator il, System.Type type)
            {
                if (type.IsValueType)
                {
                    il.Emit(OpCodes.Unbox_Any, type);
                }
                else
                {
                    il.Emit(OpCodes.Castclass, type);
                }
            }

            /// <summary>
            /// Emits the box if needed.
            /// </summary>
            /// <param name="il">The il.</param>
            /// <param name="type">The type.</param>
            private static void EmitBoxIfNeeded(ILGenerator il, System.Type type)
            {
                if (type.IsValueType)
                {
                    il.Emit(OpCodes.Box, type);
                }
            }

            /// <summary>
            /// Emits the fast int.
            /// </summary>
            /// <param name="il">The il.</param>
            /// <param name="value">The value.</param>
            private static void EmitFastInt(ILGenerator il, int value)
            {
                switch (value)
                {
                    case -1:
                        il.Emit(OpCodes.Ldc_I4_M1);
                        return;
                    case 0:
                        il.Emit(OpCodes.Ldc_I4_0);
                        return;
                    case 1:
                        il.Emit(OpCodes.Ldc_I4_1);
                        return;
                    case 2:
                        il.Emit(OpCodes.Ldc_I4_2);
                        return;
                    case 3:
                        il.Emit(OpCodes.Ldc_I4_3);
                        return;
                    case 4:
                        il.Emit(OpCodes.Ldc_I4_4);
                        return;
                    case 5:
                        il.Emit(OpCodes.Ldc_I4_5);
                        return;
                    case 6:
                        il.Emit(OpCodes.Ldc_I4_6);
                        return;
                    case 7:
                        il.Emit(OpCodes.Ldc_I4_7);
                        return;
                    case 8:
                        il.Emit(OpCodes.Ldc_I4_8);
                        return;
                }

                if (value > -129 && value < 128)
                {
                    il.Emit(OpCodes.Ldc_I4_S, (SByte)value);
                }
                else
                {
                    il.Emit(OpCodes.Ldc_I4, value);
                }
            }
        }


        public static int[,] Transpose(int[,] x)
        {
            int[,] y = new int[x.GetLength(1), x.GetLength(0)];
            for (int i = 0; i < x.GetLength(0); i++)
            {
                for (int j = 0; j < x.GetLength(1); j++)
                {
                    y[j, i] = x[i, j];
                }
            }
            return y;
        }

        public static string[,] ConvertToString(int[,] x)
        {
            string[,] y = new string[x.GetLength(0), x.GetLength(1)];
            for (int i = 0; i < x.GetLength(0); i++)
            {
                for (int j = 0; j < x.GetLength(1); j++)
                {
                    y[i, j] = x[i, j].ToString();
                }
            }
            return y;
        }

        public static string[,] Transpose(string[,] x)
        {
            string[,] y = new string[x.GetLength(1), x.GetLength(0)];
            for (int i = 0; i < x.GetLength(0); i++)
            {
                for (int j = 0; j < x.GetLength(1); j++)
                {
                    y[j, i] = x[i, j];
                }
            }
            return y;
        }

        public static DateTime[,] Transpose(DateTime[,] x)
        {
            DateTime[,] y = new DateTime[x.GetLength(1), x.GetLength(0)];
            for (int i = 0; i < x.GetLength(0); i++)
            {
                for (int j = 0; j < x.GetLength(1); j++)
                {
                    y[j, i] = x[i, j];
                }
            }
            return y;
        }

        public static DateTime[,] Transform(GekkoTime[,] x)
        {
            DateTime[,] y = new DateTime[x.GetLength(0), x.GetLength(1)];
            for (int i = 0; i < x.GetLength(0); i++)
            {
                for (int j = 0; j < x.GetLength(1); j++)
                {
                    //y[j, i] = x[i, j];
                    y[i, j] = DateTime.Now;
                }
            }
            return y;
        }





        public static string GetExcelVersion2(eOfficeVersion input)
        {
            if (input == eOfficeVersion.eOfficeVersion_95) return "95";
            if (input == eOfficeVersion.eOfficeVersion_97) return "97";
            if (input == eOfficeVersion.eOfficeVersion_XP) return "XP";
            if (input == eOfficeVersion.eOfficeVersion_2000) return "2000";
            if (input == eOfficeVersion.eOfficeVersion_2003) return "2003";
            if (input == eOfficeVersion.eOfficeVersion_2007) return "2007";
            if (input == eOfficeVersion.eOfficeVersion_2010) return "2010";
            if (input == eOfficeVersion.eOfficeVersion_2013) return "2013";
            if (input == eOfficeVersion.eOfficeVersion_2016) return "2016";
            if (input == eOfficeVersion.eOfficeVersion_2019) return "2019?";
            if (input == eOfficeVersion.eOfficeVersion_Unrecognized) return "[Unrecognized version]";
            return "[Unrecognized version]";
        }        

        public enum eOfficeVersion
        {
            eOfficeVersion_Unrecognized, // error return value
            eOfficeVersion_95,
            eOfficeVersion_97,
            eOfficeVersion_2000,
            eOfficeVersion_XP,   // XP = 2002 + marketing
            eOfficeVersion_2003,
            eOfficeVersion_2007,
            eOfficeVersion_2010,
            eOfficeVersion_2013,
            eOfficeVersion_2016,
            eOfficeVersion_2019  //???
        };

        public enum GekkoFileReadOrWrite
        {
            Read,
            Write,
            WriteAppend
        };

        public enum eOfficeApp // in case you are looking for a particular app
        {
            eOfficeApp_Word,
            eOfficeApp_Excel,
            eOfficeApp_Outlook,
            eOfficeApp_Access,
            eOfficeApp_PowerPoint,
        };
        public static eOfficeVersion GetApplicationVersion(eOfficeApp appToCheck)
        {
            // some of this function is based on the code in the article at: http://support.microsoft.com/kb/q247985/
            string progID = GetProgID(appToCheck);

            RegistryKey hKey = Registry.ClassesRoot.OpenSubKey(progID, RegistryKeyPermissionCheck.ReadSubTree, System.Security.AccessControl.RegistryRights.ReadKey);
            if (hKey == null)
                return eOfficeVersion.eOfficeVersion_Unrecognized;

            RegistryKey hKey1 = hKey.OpenSubKey("CurVer", RegistryKeyPermissionCheck.ReadSubTree, System.Security.AccessControl.RegistryRights.ReadKey);
            if (hKey1 == null)
            {
                hKey1.Close();
                hKey.Close();
                return eOfficeVersion.eOfficeVersion_Unrecognized;
            }

            // Get the Version information
            string progAndVersion = (string)hKey1.GetValue("");

            // Close the registry keys
            hKey1.Close();
            hKey.Close();

            // Error while querying for value
            if (progAndVersion == null)
                return eOfficeVersion.eOfficeVersion_Unrecognized;

            // At this point progAndVersion contains the ProgID followed by a number.
            // For example, Word 97 will return Word.Application.8 and Word 2000 will return Word.Application.9

            int lastDot = progAndVersion.LastIndexOf('.');
            int firstCharOfVersion = lastDot + 1; // + 1 to get rid of the dot at the front
            string versionString = progAndVersion.Substring(firstCharOfVersion, progAndVersion.Length - firstCharOfVersion);

            return StringToVersion(versionString);
        }

        public static string GetApplicationAsString(eOfficeApp officeApp)
        {
            switch (officeApp)
            {
                case eOfficeApp.eOfficeApp_Word: { return "Word"; } break;
                case eOfficeApp.eOfficeApp_Excel: { return "Excel"; } break;
                case eOfficeApp.eOfficeApp_Outlook: { return "Outlook"; } break;
                case eOfficeApp.eOfficeApp_Access: { return "Access"; } break;
                case eOfficeApp.eOfficeApp_PowerPoint: { return "Powerpoint"; } break;
                default: { /*ASSERT(false);*/
                        return string.Empty; } break; // added another ???
            }
        }

        public static string GetProgID(eOfficeApp officeApp)
        {
            // ProgIDs from http://support.microsoft.com/kb/240794/EN-US/
            switch (officeApp)
            {
                case eOfficeApp.eOfficeApp_Word: { return "Word.Application"; } break;
                case eOfficeApp.eOfficeApp_Excel: { return "Excel.Application"; } break;
                case eOfficeApp.eOfficeApp_Outlook: { return "Outlook.Application"; } break;
                case eOfficeApp.eOfficeApp_Access: { return "Access.Application"; } break;
                case eOfficeApp.eOfficeApp_PowerPoint: { return "Powerpoint.Application"; } break;
                default: { /*ASSERT(false);*/ return string.Empty; } break; // added another ???
            }
        }

        public static eOfficeVersion StringToVersion(string versionString)
        {
            // mapping between the marketing version (e.g. 2003) and the behind-the-scenes version
            if ("7" == versionString)
            {
                return eOfficeVersion.eOfficeVersion_95;
            }
            else if ("8" == versionString)
            {
                return eOfficeVersion.eOfficeVersion_97;
            }
            else if ("9" == versionString)
            {
                return eOfficeVersion.eOfficeVersion_2000;
            }
            else if ("10" == versionString)
            {
                return eOfficeVersion.eOfficeVersion_XP;
            }
            else if ("11" == versionString)
            {
                return eOfficeVersion.eOfficeVersion_2003;
            }
            else if ("12" == versionString)
            {
                return eOfficeVersion.eOfficeVersion_2007;
            }
            else if ("13" == versionString || "14" == versionString)  //apparently 13 is not used because of superstition
            {
                return eOfficeVersion.eOfficeVersion_2010;
            }
            else if ("15" == versionString)  //this seems to be 2013 internal number
            {
                return eOfficeVersion.eOfficeVersion_2013;
            }
            else if ("16" == versionString) 
            {
                return eOfficeVersion.eOfficeVersion_2016;
            }
            else if ("17" == versionString)
            {
                return eOfficeVersion.eOfficeVersion_2019;
            }
            else
            {
                return eOfficeVersion.eOfficeVersion_Unrecognized; // added another ???
            }
        }

        public static void CreateBVariance(Series[] timeSeriesPointers, GekkoTime t0)
        {
            foreach (int i in Program.model.modelGekko.endogenousBNumbersOriginalInModelList)
            {
                Series ts = timeSeriesPointers[i];
                //string variable = varNamePointers[i];
                double d = CalculateHistoricalVarianceForVariable(ts, t0);
                Program.model.modelGekko.bVariance[i] = d;
            }
        }

        public static double CalculateHistoricalVarianceForVariable(Series ts, GekkoTime year0)
        {
            //only abs calc is used
            if (ts == null) return double.NaN;
            double v3 = ts.GetDataSimple(year0.Add(-2));  //TODO: what about freq?
            double v2 = ts.GetDataSimple(year0.Add(-1));
            double v1 = ts.GetDataSimple(year0);

            double v = ((Math.Abs(v3) + Math.Abs(v2) + Math.Abs(v1)) / 3d);  //abs mean, not used it seems
            double dLag = Math.Abs(v2 - v3);  //diff for x(-1)-x(-2)
            double dNonlag = Math.Abs(v1 - v2);  //diff for x-x(-1)
            double d = (dLag + dNonlag) / 2d;  //mean diff
            double rel = d / v;

            if (double.IsInfinity(d))
            {
                //seems there are none of these, how could there?
                d = double.NaN;  //for simplicity later on
            }

            if (d == 0)
            {
                //there are some of these, most with all values = 0
            }

            if (G.isNumericalError(d))
            {
                //seems there are none of these
            }

            return d;
        }

        public static void tokensFromFileToArrayList(String dataFile, bool ignoreWhiteSpace, bool addWorkingFolder, List<string> al, List<string> alType)
        {
            //Only used in TSP utilities

            String all;
            String all2;
            String temp1 = "";
            String temp2 = "";

            //content is read from a .frm file
            string fileName = null;
            if (addWorkingFolder)
            {
                fileName = Program.options.folder_working + "\\" + dataFile;
            }
            else
            {
                fileName = dataFile;
            }

            all = GetTextFromFileWithWait(fileName);

            all2 = G.oddX0000Hack(all);
            StringTokenizer2 tok = new StringTokenizer2(all2, false, true);
            tok.IgnoreWhiteSpace = ignoreWhiteSpace;
            tok.SymbolChars = new char[] { '?', '(', ')', '=', '+', '-', '*', '/', '$' };
            Token token;

            //----------------------------------------------------
            //read into ArrayList alStart and alStartType
            do
            {
                token = tok.Next(); temp1 = token.Kind.ToString(); temp2 = token.Value;
                al.Add(temp2); alType.Add(temp1);
            } while (token.Kind != ETokenType.EOF);
            //adding extra blanks, to avoid problems with overrun when probing alStart[i+x]
            for (int i = 1; i < Globals.extra; i++)
            {
                al.Add(""); alType.Add("");
            }
        }


        
        public static void CompareModelDatabankVarlist()
        {
            if (!G.HasModelGekko())
            {
                G.Writeln2("*** ERROR: No model seems to be loaded, cf. the MODEL statement.");
                G.Writeln("*** ERROR: The comparison could not be performed.");
                return;
            }
            int dublets = 0;
            Dictionary<string, int> varlistDublets = new Dictionary<string, int>();
            CaseInsensitiveHashtable varlist = new CaseInsensitiveHashtable();
            if (Program.unfoldedVariableList != null)
            {
                foreach (Program.Item item in Program.unfoldedVariableList)
                {
                    string varName = item.variable;
                    if (varlist.ContainsKey(varName))
                    {
                        dublets++;
                        if (varlistDublets.ContainsKey(varName))
                        {
                            varlistDublets[varName]++;
                        }
                        else
                        {
                            varlistDublets.Add(varName, 2);
                        }
                    }
                    else
                    {
                        varlist.Add(varName, "");
                    }
                }
            }
            else
            {
                G.Writeln("+++ NOTE: a variable list was not found inside model file");
            }

            List<string> bothModelAndVarlist = new List<string>();
            List<string> onlyModelNotVarlist = new List<string>();
            List<string> onlyVarlistNotModel = new List<string>();
            List<string> bothModelAndDatabank = new List<string>();
            List<string> onlyModelNotDatabank = new List<string>();
            List<string> onlyDatabankNotModel = new List<string>();
            List<string> bothDatabankAndVarlist = new List<string>();
            List<string> onlyDatabankNotVarlist = new List<string>();
            List<string> onlyVarlistNotDatabank = new List<string>();

            foreach (string ss in Program.databanks.GetFirst().storage.Keys)
            {
                if (G.GetFreqFromName(ss) != Program.options.freq) continue;  //filter other freqs
                string s = G.Chop_RemoveFreq(ss);
                if (Program.model.modelGekko.varsDTypeAutoGenerated.ContainsKey(s) || Program.model.modelGekko.varsJTypeAutoGenerated.ContainsKey(s) || Program.model.modelGekko.varsZTypeAutoGenerated.ContainsKey(s)) continue;
                if (Program.model.modelGekko.varsAType.ContainsKey(s))
                {
                    bothModelAndDatabank.Add(s);
                }
                else
                {
                    onlyDatabankNotModel.Add(s);
                }

                if (varlist.ContainsKey(s))
                {
                    bothDatabankAndVarlist.Add(s);
                }
                else
                {
                    onlyDatabankNotVarlist.Add(s);
                }
            }

            foreach (string s in Program.model.modelGekko.varsAType.Keys)
            {
                if (Program.model.modelGekko.varsDTypeAutoGenerated.ContainsKey(s) || Program.model.modelGekko.varsJTypeAutoGenerated.ContainsKey(s) || Program.model.modelGekko.varsZTypeAutoGenerated.ContainsKey(s)) continue;
                if (Program.databanks.GetFirst().ContainsIVariable(s + Globals.freqIndicator + G.GetFreq(Program.options.freq)))
                {
                }
                else
                {
                    onlyModelNotDatabank.Add(s);
                }
                if (varlist.ContainsKey(s))
                {
                    bothModelAndVarlist.Add(s);
                }
                else
                {
                    onlyModelNotVarlist.Add(s);
                }
            }


            foreach (string s in varlist.Keys)
            {
                if (Program.databanks.GetFirst().ContainsIVariable(s + Globals.freqIndicator + G.GetFreq(Program.options.freq)))
                {
                }
                else
                {
                    onlyVarlistNotDatabank.Add(s);
                }
                if (Program.model.modelGekko.varsAType.ContainsKey(s))
                {
                }
                else
                {
                    onlyVarlistNotModel.Add(s);
                }
            }

            bothModelAndVarlist.Sort(StringComparer.InvariantCulture);
            onlyModelNotVarlist.Sort(StringComparer.InvariantCulture);
            onlyVarlistNotModel.Sort(StringComparer.InvariantCulture);
            bothModelAndDatabank.Sort(StringComparer.InvariantCulture);
            onlyModelNotDatabank.Sort(StringComparer.InvariantCulture);
            onlyDatabankNotModel.Sort(StringComparer.InvariantCulture);
            bothDatabankAndVarlist.Sort(StringComparer.InvariantCulture);
            onlyDatabankNotVarlist.Sort(StringComparer.InvariantCulture);
            onlyVarlistNotDatabank.Sort(StringComparer.InvariantCulture);

            string fullFileNameAndPath = CreateFullPathAndFileName("compare.txt");

            using (FileStream fs = WaitForFileStream(fullFileNameAndPath, GekkoFileReadOrWrite.Write))
            using (StreamWriter compareFile = G.GekkoStreamWriter(fs))
            {

                if (dublets > 0)
                {
                    compareFile.WriteLine("NOTE: there were " + dublets + " dublets in the varlist.");
                    compareFile.WriteLine("These dublets are ignored in the following comparisons.");
                    compareFile.WriteLine("The dublets are listed at the bottom of this file.");
                    compareFile.WriteLine();
                }
                compareFile.WriteLine("When comparing, auto-generated DJZ-type exogenous variables are ignored.");
                compareFile.WriteLine("Such variables appear in the model, sometimes in the databank");
                compareFile.WriteLine("(for instance when writing after a simulation), but in general");
                compareFile.WriteLine("not in the varlist. So comparing these kinds of variables does not");
                compareFile.WriteLine("make much sense and would just pollute the comparison.");
                compareFile.WriteLine();
                compareFile.WriteLine("----------------------------------------------------------");
                compareFile.WriteLine("--------------------- Model/databank ---------------------");
                compareFile.WriteLine("----------------------------------------------------------");
                compareFile.WriteLine("Both model and databank:     " + G.IntFormat(bothModelAndDatabank.Count, 7) + " variables");
                compareFile.WriteLine("In databank, not in model:   " + G.IntFormat(onlyDatabankNotModel.Count, 7) + " variables");
                compareFile.WriteLine("In model, not in databank:   " + G.IntFormat(onlyModelNotDatabank.Count, 7) + " variables");
                compareFile.WriteLine();
                compareFile.WriteLine("----------------------------------------------------------");
                compareFile.WriteLine("--------------------- Model/varlist  ---------------------");
                compareFile.WriteLine("----------------------------------------------------------");
                compareFile.WriteLine("Both model and varlist:      " + G.IntFormat(bothModelAndVarlist.Count, 7) + " variables");
                compareFile.WriteLine("In model, not in varlist:    " + G.IntFormat(onlyModelNotVarlist.Count, 7) + " variables");
                compareFile.WriteLine("In varlist, not in model:    " + G.IntFormat(onlyVarlistNotModel.Count, 7) + " variables");
                compareFile.WriteLine();
                compareFile.WriteLine("----------------------------------------------------------");
                compareFile.WriteLine("--------------------- Databank/varlist  ------------------");
                compareFile.WriteLine("----------------------------------------------------------");
                compareFile.WriteLine("Both databank and varlist:   " + G.IntFormat(bothDatabankAndVarlist.Count, 7) + " variables");
                compareFile.WriteLine("In varlist, not in databank: " + G.IntFormat(onlyVarlistNotDatabank.Count, 7) + " variables");
                compareFile.WriteLine("In databank, not in varlist: " + G.IntFormat(onlyDatabankNotVarlist.Count, 7) + " variables");
                compareFile.WriteLine();
                compareFile.WriteLine();
                compareFile.WriteLine("Below, missing variables are listed");
                compareFile.WriteLine();
                compareFile.WriteLine("In databank, not in model:   " + G.IntFormat(onlyDatabankNotModel.Count, 7) + " variables");
                compareFile.WriteLine("----------------------------------------------------------");
                G.PrintListWithCommasToFile(compareFile, onlyDatabankNotModel);
                compareFile.WriteLine();
                compareFile.WriteLine();
                compareFile.WriteLine("In model, not in databank:   " + G.IntFormat(onlyModelNotDatabank.Count, 7) + " variables");
                compareFile.WriteLine("----------------------------------------------------------");
                G.PrintListWithCommasToFile(compareFile, onlyModelNotDatabank);
                compareFile.WriteLine();
                compareFile.WriteLine();
                compareFile.WriteLine("In model, not in varlist:    " + G.IntFormat(onlyModelNotVarlist.Count, 7) + " variables");
                compareFile.WriteLine("----------------------------------------------------------");
                G.PrintListWithCommasToFile(compareFile, onlyModelNotVarlist);
                compareFile.WriteLine();
                compareFile.WriteLine();
                compareFile.WriteLine("In varlist, not in model:    " + G.IntFormat(onlyVarlistNotModel.Count, 7) + " variables");
                compareFile.WriteLine("----------------------------------------------------------");
                G.PrintListWithCommasToFile(compareFile, onlyVarlistNotModel);
                compareFile.WriteLine();
                compareFile.WriteLine();
                compareFile.WriteLine("In varlist, not in databank: " + G.IntFormat(onlyVarlistNotDatabank.Count, 7) + " variables");
                compareFile.WriteLine("----------------------------------------------------------");
                G.PrintListWithCommasToFile(compareFile, onlyVarlistNotDatabank);
                compareFile.WriteLine();
                compareFile.WriteLine();
                compareFile.WriteLine("In databank, not in varlist: " + G.IntFormat(onlyDatabankNotVarlist.Count, 7) + " variables");
                compareFile.WriteLine("----------------------------------------------------------");
                G.PrintListWithCommasToFile(compareFile, onlyDatabankNotVarlist);
                compareFile.WriteLine();
                compareFile.WriteLine();
                compareFile.WriteLine();
                compareFile.WriteLine("-----------------------------------------------------------");
                compareFile.WriteLine("The following variables are dublets in the varlist");
                foreach (KeyValuePair<string, int> x in varlistDublets)
                {
                    compareFile.WriteLine(G.varFormat(x.Key) + " --> " + x.Value + " times");
                }
                if (varlistDublets.Count == 0) compareFile.WriteLine("<none>");
                compareFile.Flush();
            }
        }

        public static void CompareModelDatabank()
        {
            //IS THIS OBSOLETE??

            GekkoTime tStart = Globals.globalPeriodStart;
            GekkoTime tEnd = Globals.globalPeriodEnd;

            if (!G.HasModelGekko())
            {
                G.Writeln2("*** ERROR: No model seems to be loaded, cf. the MODEL statement.");
                G.Writeln("*** ERROR: The comparison could not be performed.");
                return;
            }

            List<string> bothModelAndDatabank = new List<string>();
            List<string> onlyModelNotDatabank = new List<string>();
            List<string> onlyDatabankNotModel = new List<string>();

            foreach (string s in Program.databanks.GetFirst().storage.Keys)
            {
                if (Program.model.modelGekko.varsDTypeAutoGenerated.ContainsKey(s) || Program.model.modelGekko.varsJTypeAutoGenerated.ContainsKey(s) || Program.model.modelGekko.varsZTypeAutoGenerated.ContainsKey(s)) continue;
                if (Program.model.modelGekko.varsAType.ContainsKey(s))
                {
                    bothModelAndDatabank.Add(s);
                }
                else
                {
                    onlyDatabankNotModel.Add(s);
                }
            }

            foreach (string s in Program.model.modelGekko.varsAType.Keys)
            {
                if (Program.model.modelGekko.varsDTypeAutoGenerated.ContainsKey(s) || Program.model.modelGekko.varsJTypeAutoGenerated.ContainsKey(s) || Program.model.modelGekko.varsZTypeAutoGenerated.ContainsKey(s)) continue;
                if (Program.databanks.GetFirst().storage.ContainsKey(s))
                {
                }
                else
                {
                    onlyModelNotDatabank.Add(s);
                }
            }

            bothModelAndDatabank.Sort(StringComparer.InvariantCulture);
            onlyModelNotDatabank.Sort(StringComparer.InvariantCulture);
            onlyDatabankNotModel.Sort(StringComparer.InvariantCulture);

            List<string> varsWithMissingValues = new List<string>();

            Databank work = Program.databanks.GetFirst();
            foreach (string s in bothModelAndDatabank)
            {
                foreach (GekkoTime t in new GekkoTimeIterator( tStart, tEnd))
                {
                    double value = (work.GetIVariable(s + Globals.freqIndicator + G.GetFreq(Program.options.freq)) as Series).GetDataSimple(t);
                    if (G.isNumericalError(value))
                    {
                        varsWithMissingValues.Add(s);
                        break;
                    }
                }
            }
            varsWithMissingValues.Sort();  //probably not necessary, but oh well

            string fullFileNameAndPath = CreateFullPathAndFileName("compare.txt");

            using (FileStream fs = WaitForFileStream(fullFileNameAndPath, GekkoFileReadOrWrite.Write))
            using (StreamWriter compareFile = G.GekkoStreamWriter(fs))
            {
                compareFile.WriteLine("When comparing, auto-generated DJZ-type exogenous variables are ignored.");
                compareFile.WriteLine("Such variables appear in the model and sometimes in the databank");
                compareFile.WriteLine("(for instance when writing a databank after a simulation).");
                compareFile.WriteLine("So comparing these kinds of variables does not");
                compareFile.WriteLine("make much sense and would just pollute the comparison.");
                compareFile.WriteLine();
                compareFile.WriteLine("----------------------------------------------------------");
                compareFile.WriteLine("-------------- Compare model and databank ----------------");
                compareFile.WriteLine("----------------------------------------------------------");
                compareFile.WriteLine();
                compareFile.WriteLine("Both model and databank:   " + G.IntFormat(bothModelAndDatabank.Count, 7) + " variables");
                compareFile.WriteLine("In databank, not in model: " + G.IntFormat(onlyDatabankNotModel.Count, 7) + " variables");
                compareFile.WriteLine("In model, not in databank: " + G.IntFormat(onlyModelNotDatabank.Count, 7) + " variables");
                compareFile.WriteLine();
                compareFile.WriteLine("Below, missing variables are listed");
                compareFile.WriteLine();
                compareFile.WriteLine("In model, not in databank:   " + G.IntFormat(onlyModelNotDatabank.Count, 7) + " variables");
                compareFile.WriteLine("----------------------------------------------------------");
                G.PrintListWithCommasToFile(compareFile, onlyModelNotDatabank);
                compareFile.WriteLine();
                compareFile.WriteLine();
                compareFile.WriteLine("From the " + G.IntFormat(bothModelAndDatabank.Count, 7) + " variables in both model and databank,");
                compareFile.WriteLine("there are missing values in " + varsWithMissingValues.Count + " of these, for the given period " + tStart.ToString() + " to " + tEnd.ToString() + ":");
                compareFile.WriteLine("----------------------------------------------------------");
                G.PrintListWithCommasToFile(compareFile, varsWithMissingValues);
                compareFile.WriteLine();
                compareFile.WriteLine();
                compareFile.WriteLine("The following " + G.IntFormat(onlyDatabankNotModel.Count, 7) + " variables are in the databank, but not in the model:");
                compareFile.WriteLine("----------------------------------------------------------");
                G.PrintListWithCommasToFile(compareFile, onlyDatabankNotModel);
                compareFile.WriteLine();
                compareFile.WriteLine();

                compareFile.Flush();
            }
        }

        private static void ResidualCheck(string checkType, bool dlog, bool split)
        {
            string outputPath = Globals.localTempFilesLocation + "\\" + "residualcheck";
            DeleteFolder(outputPath);
            Directory.CreateDirectory(outputPath);

            //This code is not high-performant, but oh well...
            if (split)
            {
                List<string> d = new List<string>();
                foreach (EquationHelper eh in Program.model.modelGekko.equations)
                {
                    string block = eh.modelBlock;
                    if (!d.Contains(block)) d.Add(block);
                }
                d.Sort();
                foreach (string s in d)
                {
                    ResidualCheckHelper(checkType, dlog, s, outputPath);
                }
            }
            else ResidualCheckHelper(checkType, dlog, null, outputPath);

            G.Writeln();
            G.Write("Zipping residual check files... ");
            string zipfile = Program.options.folder_working + "\\residual_check.zip";
            string zipFileNameInput = Program.CreateFullPathAndFileName(zipfile);
            Program.WaitForZipWrite(outputPath, zipFileNameInput);
            G.Writeln("... ended");
            G.Writeln("See 'residual_check.zip'");
            G.Writeln();
        }

        private static void ResidualCheckHelper(string checkType, bool dlog, string block, string path)
        {
            Databank work = Program.databanks.GetFirst();
            List<string> d_type = new List<string>();
            List<string> g_type = new List<string>();
            List<string> i_type = new List<string>();
            List<string> k_type = new List<string>();
            List<string> s_type = new List<string>();
            List<string> after_i_type = new List<string>();
            List<string> after_d_type = new List<string>();

            foreach (EquationHelper eh in Program.model.modelGekko.equations)
            {
                if (block != null && !G.Equal(block, eh.modelBlock)) continue; //out-filtering those that are not in chosen block
                string var = eh.lhs;
                string code = eh.equationCode;

                if (true)
                {
                    if (G.Equal(code.Substring(0, 1), "i"))
                    {
                        after_i_type.Add(var);
                    }
                    else if (G.Equal(code.Substring(0, 1), "d"))  //in frml file, it starts with "y" and typically var name (yEnly)
                    {
                        after_d_type.Add(var);
                    }
                    else
                    {
                        if (code.Length <= 1)
                        {
                            G.Writeln("+++ WARNING: formula code regarding '" + var + "' seems problematic: " + code);
                        }
                        if (code.Length >= 2)
                        {
                            if (code.Substring(0, 1) != "_")
                            {
                                G.Writeln("+++ WARNING: formula code regarding '" + var + "' does not start with '_' or 'i' or 'y': " + code);
                            }
                            else
                            {
                                string type = code.Substring(1, 1).ToLower();
                                if (type == "d")
                                {
                                    d_type.Add(var);
                                }
                                else if (type == "g")
                                {
                                    g_type.Add(var);
                                }
                                else if (type == "i")
                                {
                                    i_type.Add(var);
                                }
                                else if (type == "k")
                                {
                                    k_type.Add(var);
                                }
                                else if (type == "s")
                                {
                                    s_type.Add(var);
                                }
                                else
                                {
                                    G.Writeln("+++ WARNING: there was a unknown formula code type (i.e. not _d, _g, _i, _k or _s) regarding '" + var + "': " + code);
                                }
                            }
                        }
                        else
                        {
                            G.Writeln("+++ WARNING: there was a unknown formula code type (i.e. not _d, _g, _i, _k or _s) regarding '" + var + "': " + code);
                        }
                    }
                }
            }

            int t1 = Globals.globalPeriodStart.super;
            int t2 = Globals.globalPeriodEnd.super;

            string type2 = "";
            bool order = false;
            if (checkType == "absolute")
            {
                type2 = "absolute";
                order = true;
            }
            else if (checkType == "relative")
            {
                type2 = "relative";
                order = true;
            }
            else if (checkType == "alphabetical")
            {
                type2 = "alphabetical";
                order = false;
            }
            else
            {
                //hmmmm
            }

            GekkoTime gt1 = new GekkoTime((Program.options.freq), t1, 1);
            GekkoTime gt2 = new GekkoTime((Program.options.freq), t2, 1);

            Sam(gt1, gt2, Program.databanks.GetRef(), Program.databanks.GetFirst(), type2, order, d_type, "_d", dlog, block, path, null, null, double.NaN, double.NaN);
            Sam(gt1, gt2, Program.databanks.GetRef(), Program.databanks.GetFirst(), type2, order, g_type, "_g", dlog, block, path, null, null, double.NaN, double.NaN);
            Sam(gt1, gt2, Program.databanks.GetRef(), Program.databanks.GetFirst(), type2, order, i_type, "_i", dlog, block, path, null, null, double.NaN, double.NaN);
            Sam(gt1, gt2, Program.databanks.GetRef(), Program.databanks.GetFirst(), type2, order, k_type, "_k", dlog, block, path, null, null, double.NaN, double.NaN);
            Sam(gt1, gt2, Program.databanks.GetRef(), Program.databanks.GetFirst(), type2, order, s_type, "_s", dlog, block, path, null, null, double.NaN, double.NaN);
            Sam(gt1, gt2, Program.databanks.GetRef(), Program.databanks.GetFirst(), type2, order, after_i_type, "_after_i", dlog, block, path, null, null, double.NaN, double.NaN);
            Sam(gt1, gt2, Program.databanks.GetRef(), Program.databanks.GetFirst(), type2, order, after_d_type, "_after_d", dlog, block, path, null, null, double.NaN, double.NaN);
        }

        public static string GetModelInfoPath()
        {
            //put in local files on user pc
            int random = Globals.modelRandomID;
            string path = Globals.localTempFilesLocation + "\\" + Globals.modelFileName.Replace(".frm", "") + "__info" + "_" + random;
            return path;
        }

        public static void CreateTempFilesFolder()
        {
            if (!Directory.Exists(Globals.localTempFilesLocation))
            {
                Directory.CreateDirectory(Globals.localTempFilesLocation);
            }
        }

        public static void CreateLocalCopyHelpChm()
        {
            if (Program.options.interface_help_copylocal)
            {
                try
                {
                    string file = "";
                    if (Program.options.folder_help != "")
                    {
                        file = Program.options.folder_help + "\\gekko.chm";
                    }
                    else file = Application.StartupPath + "\\helpfiles\\gekko.chm";
                    if (File.Exists(file))
                    {
                        string tempPath = Globals.localTempFilesLocation + "\\" + "gekko.chm";
                        if (File.Exists(tempPath))
                        {
                            File.SetAttributes(tempPath, FileAttributes.Normal);  //it may be read-only if original file is so
                            File.Delete(tempPath);
                        }

                        File.Copy(file, tempPath, true);

                        G.WritelnGray("Local copying: gekko.chm");
                    }
                }
                catch
                {
                    //do nothing, we will survive this!
                }
            }
        }

        public static string GetTempTsdFilePath(string type)
        {
            string tempPath = null;
            for (int i = 0; i < 100; i++)
            {
                int random = Program.RandomInt(11111111, 99999999);
                tempPath = Globals.localTempFilesLocation + "\\" + "temp" + type + "file" + "_" + random + "." + type;
                if (!File.Exists(tempPath)) break; //should normally be the case
                tempPath = null;  //very rare case probably: try with new random name
            }
            if (tempPath == null)
            {
                //tried random name 100 times, this should never happen... 100 blocked files at one time not very realistic...
                G.Writeln2("*** ERROR: Could not make local copy of tsd file (filename problem)");
                throw new GekkoException();
            }
            return tempPath;
        }

        public static string GetTempTsdxFolderPath()
        {
            //put in local files on user pc
            //Random r = new Random();
            int random = Program.RandomInt(11111111, 99999999);
            string path = Globals.localTempFilesLocation + "\\" + "temptsdxfolder" + "_" + random;
            return path;
        }

        public static void Sam1()
        {
            Sam(Globals.globalPeriodStart, Globals.globalPeriodEnd, Program.databanks.GetRef(), Program.databanks.GetFirst(), "", false);
        }
        public static void Sam2()
        {
            Sam(Globals.globalPeriodStart, Globals.globalPeriodEnd, Program.databanks.GetRef(), Program.databanks.GetFirst(), "absolute", true);
        }
        public static void Sam3()
        {
            Sam(Globals.globalPeriodStart, Globals.globalPeriodEnd, Program.databanks.GetRef(), Program.databanks.GetFirst(), "relative", true);
        }
        public static void SamE1(bool dlog, bool split)
        {
            ResidualCheck("alphabetical", dlog, split);
        }
        public static void SamE2(bool dlog, bool split)
        {
            ResidualCheck("absolute", dlog, split);
        }
        public static void SamE3(bool dlog, bool split)
        {
            ResidualCheck("relative", dlog, split);
        }

        public static void Sam(GekkoTime tStart, GekkoTime tEnd, Databank base2, Databank work, string type, bool order)
        {
            //Called in order to compare databanks, 5 last args inactive
            Sam(tStart, tEnd, base2, work, type, order, null, null, false, null, null, null, null, double.NaN, double.NaN);
        }

        public static void Sam(GekkoTime tStart, GekkoTime tEnd, Databank base2, Databank work, string compareType, bool order, List<string> variables, string variablesType, bool dlog, string block, string path, string fileName, string dump, double crit_abs, double crit_rel)
        {
            //TODO: could be more clearly coded, with 6 compareTypes (3 databank and 3 residuals), doing a 'variables == null' is not too pretty
            //TODO: error handling if var not found in one of the banks in residual check
            //TODO: option to use CalculateHistoricalVarianceForVariable() and CheckRelativeDifferenceSmart()

            if (compareType != null) compareType = compareType.ToLower();
            int seriesShown = 0;

            List<string> dif = new List<string>();

            // =======================================
            bool removeCurrentFreqFromNames = true;
            double crit = double.NaN;
            string type = "smart...";
            bool plot = true;
            int plotExtraPeriods = 0;
            bool residuals = false;
            // =======================================

            if (compareType == "abs" || compareType == "absolute")
            {
                compareType = "absolute";
                order = true;
            }
            else if (compareType == "rel" || compareType == "relative")
            {
                compareType = "relative";
                order = true;
            }
            else if (compareType == "alpha" || compareType == null)
            {
                compareType = "alphabetical";
                order = false;
            }
            else
            {
                G.Writeln2("*** ERROR: Expected SORT to be alpha, abs or rel.");
                throw new GekkoException();
            }

            if (variables != null && variables.Count == 0)
            {
                return;  //to avoid empty files, especially when dividing into blocks
            }

            //List<string> both = variables;  //may be null            

            SortedList ordered = new SortedList();

            string samFileName = "";

            if (!residuals)
            {
                //i.e. we are doing a databank compare, not a residual compare
                samFileName = "compare_databanks.txt";
                if (fileName != null) samFileName = fileName;
                if (!Path.HasExtension(samFileName)) samFileName = samFileName + ".txt";
                path = Program.options.folder_working;
            }
            else
            {
                string s = "";
                if (block != null)
                {
                    s = "_" + block;
                }
                samFileName = "residuals" + s + variablesType + ".txt";
            }

            List<string> onlyWork2 = new List<string>();
            List<string> onlyRef2 = new List<string>();
            List<string> both2 = new List<string>();
            List<string> differentTypeSeries2 = new List<string>();
            List<string> notFoundBoth2 = new List<string>();  //only when a list is given. Such a series is not found in either bank

            List<SamHelper> items = new List<SamHelper>();
            if (variables == null)
            {
                // --------------------------------------------
                //looping over vars in Work and Ref banks
                // --------------------------------------------

                foreach (KeyValuePair<string, IVariable> kvp in work.storage)
                {
                    string tsNameWithFreq = kvp.Key;
                    Series ts = kvp.Value as Series;
                    if (ts == null) continue;  //non-series
                    //if (ts.freq != Program.options.freq) continue;
                    Series tsGrund = base2.GetIVariable(kvp.Key) as Series;
                    if (tsGrund == null)
                    {
                        onlyWork2.Add(MaybeRemoveFreq(tsNameWithFreq, removeCurrentFreqFromNames));
                    }
                    else
                    {
                        //the series exists in both banks
                        SamHandleTwoExistingSeries(onlyWork2, onlyRef2, both2, differentTypeSeries2, items, tsNameWithFreq, ts, tsGrund, removeCurrentFreqFromNames);
                    }
                }

                foreach (KeyValuePair<string, IVariable> kvp in base2.storage)  //7737
                {
                    string tsNameWithFreq = kvp.Key;
                    Series ts = kvp.Value as Series;
                    if (ts == null) continue;  //non-series
                    //if (ts.freq != Program.options.freq) continue;
                    Series tsWork = work.GetIVariable(kvp.Key) as Series;
                    if (tsWork == null)  //otherwise we get dublets
                    {
                        onlyRef2.Add(MaybeRemoveFreq(tsNameWithFreq, removeCurrentFreqFromNames));
                    }
                }
            }
            else
            {
                // --------------------------------------------
                //looping over a given list of variables
                // --------------------------------------------

                foreach (string tsString in variables)
                {

                    IVariable iv = O.GetIVariableFromString(tsString, O.ECreatePossibilities.NoneReportError);  //no search
                    IVariable ivGrund = O.GetIVariableFromString(G.Chop_SetBank(tsString, Globals.Ref), O.ECreatePossibilities.NoneReportError);

                    //string dbName, varName, freq; string[] indexes;
                    //O.Chop(tsString, out dbName, out varName, out freq, out indexes);
                    //if (G.Chop_HasSigil(varName)) continue;  //filter out non-series, like %s or #m
                    //IVariable iv = O.GetIVariableFromString(dbName, varName, freq, indexes, O.ECreatePossibilities.NoneReturnNull);
                    //IVariable ivGrund = O.GetIVariableFromString(Globals.Ref, varName, freq, indexes, O.ECreatePossibilities.NoneReturnNull);
                                                            
                    //string tsNameWithFreq = varName;
                    //if (freq != null) tsNameWithFreq = Globals.freqIndicator + freq;
                    string tsNameWithFreq = tsString;                    

                    if (iv == null && ivGrund == null)
                    {
                        notFoundBoth2.Add(MaybeRemoveFreq(tsNameWithFreq, removeCurrentFreqFromNames));
                        continue;
                    }

                    //at this point, the series exists in at least one of the banks (we know it is a series, since non-series with sigils are filtered out by name above)

                    Series ts = null;
                    Series tsGrund = null;
                    if (iv != null) ts = iv as Series;
                    if (ivGrund != null) tsGrund = ivGrund as Series;

                    if (ts == null && tsGrund == null) continue;  //this should not happen, just for safety

                    if (ts == null) onlyRef2.Add(MaybeRemoveFreq(tsNameWithFreq, removeCurrentFreqFromNames));
                    else if (tsGrund == null) onlyWork2.Add(MaybeRemoveFreq(tsNameWithFreq, removeCurrentFreqFromNames));
                    else
                    {
                        //both exist and are of series type
                        SamHandleTwoExistingSeries(onlyWork2, onlyRef2, both2, differentTypeSeries2, items, tsNameWithFreq, ts, tsGrund, removeCurrentFreqFromNames);
                    }
                }
            }

            onlyWork2.Sort(StringComparer.OrdinalIgnoreCase);
            onlyRef2.Sort(StringComparer.OrdinalIgnoreCase);
            both2.Sort(StringComparer.OrdinalIgnoreCase);
            differentTypeSeries2.Sort(StringComparer.OrdinalIgnoreCase);
            notFoundBoth2.Sort(StringComparer.OrdinalIgnoreCase);

            bool dumpList = false;


            int pcounter = 0;
            //string fullPathAndFileName = CreateFullPathAndFileName(samFileName);
            string fullPathAndFileName = path;
            using (FileStream fs = WaitForFileStream(fullPathAndFileName + "\\" + samFileName, GekkoFileReadOrWrite.Write))
            using (StreamWriter samFile = G.GekkoStreamWriter(fs))
            {

                samFile.WriteLine("Comparing first-position (" + GetDatabankFileNameWithPath(Program.databanks.GetFirst()) + ") and reference (" + GetDatabankFileNameWithPath(Program.databanks.GetRef()) + ") databanks");
                samFile.WriteLine();
                samFile.WriteLine("There are the following " + both2.Count + " series in both databanks:");
                G.PrintListWithCommasToFile(samFile, both2);
                samFile.WriteLine();
                samFile.WriteLine();
                samFile.WriteLine("There are the following " + onlyWork2.Count + " series in the first-position databank, but not in " + Globals.Ref + " databank:");
                G.PrintListWithCommasToFile(samFile, onlyWork2);
                if (onlyWork2.Count == 0) samFile.WriteLine("[none]");
                samFile.WriteLine();
                samFile.WriteLine();
                samFile.WriteLine("There are the following " + onlyRef2.Count + " series in " + Globals.Ref + " databank, but not in the first-position databank:");
                G.PrintListWithCommasToFile(samFile, onlyRef2);
                if (onlyRef2.Count == 0) samFile.WriteLine("[none]");

                if (differentTypeSeries2.Count > 0)
                {
                    samFile.WriteLine();
                    samFile.WriteLine();
                    samFile.WriteLine("The following " + differentTypeSeries2.Count + " series were of different type (array-and non-array-series):");
                    G.PrintListWithCommasToFile(samFile, differentTypeSeries2);
                    if (differentTypeSeries2.Count == 0) samFile.WriteLine("[none]");
                }

                if (notFoundBoth2.Count > 0)
                {
                    samFile.WriteLine();
                    samFile.WriteLine();
                    samFile.WriteLine("The following " + notFoundBoth2.Count + " series were not found in Work or Ref:");
                    G.PrintListWithCommasToFile(samFile, notFoundBoth2);
                    if (notFoundBoth2.Count == 0) samFile.WriteLine("[none]");
                }

                samFile.WriteLine();
                samFile.WriteLine();

                List<string> differentType = new List<string>();

                int count = 0;
                //There is a little bit unnecessary overhead here, if compareType is "alphabetical". But never mind.
                foreach (SamHelper sh in items)
                {                    
                    count++;
                    Series ts = sh.series1;
                    Series tsGrund = sh.series2;

                    double max = 0d;
                    double maxAbs = 0d;
                    double maxRel = 0d;
                    
                    foreach (GekkoTime t in new GekkoTimeIterator(ConvertFreqs(tStart, tEnd, ts.freq)))
                    {
                        double varDelta = 0;
                        double varPch = 0;

                        double var1 = ts.GetDataSimple(t);
                        double var2 = tsGrund.GetDataSimple(t);

                        //we check first both 0, both M, one non-M && one M.

                        if (var1 == 0 && var2 == 0d)
                        {
                            varPch = 0d;
                            varDelta = var1 - var2;
                        }
                        else if (G.IsBothNumericalError(var1, var2)) //see also #87342543534
                        {
                            //this is considered okay
                            varPch = 0d;
                            varDelta = 0d;
                        }
                        else if ((G.isNumericalError(var1) && !G.isNumericalError(var2)) || (!G.isNumericalError(var1) && G.isNumericalError(var2)))
                        {
                            //this is considered a problem
                            varPch = 1e+100d;
                            varDelta = 1e+100;
                        }
                        else if (var2 == 0)
                        {
                            varPch = 1e+100d;
                            varDelta = var1 - var2;
                        }
                        else
                        {
                            varPch = ((var1 / var2 - 1d) * 100d);
                            varDelta = var1 - var2;
                        }

                        if (compareType == "absolute" || compareType == "alphabetical")
                        {
                            max = Math.Max(Math.Abs(varDelta), max);
                        }
                        else if (compareType == "relative")
                        {
                            max = Math.Max(Math.Abs(varPch), max);
                        }
                        maxAbs = Math.Max(Math.Abs(varDelta), maxAbs);
                        maxRel = Math.Max(Math.Abs(varPch / 100d), maxRel);

                        if (G.isNumericalError(max))
                        {
                            //this is igonred
                        }
                    }


                    if (G.isNumericalError(max))
                    {
                        //This probably never happens... for safety...
                        max = 1e+100d;
                        maxAbs = 1e+100d;
                        maxRel = 1e+100d;
                    }

                    //if (max == 0) continue;  //don't show vars if they are identical
                    //if no <abs=...> or <rel=...> are given, crit_abs and crit_rel are = 0.

                    if (crit_abs < 0) crit_abs = 0;
                    if (crit_rel < 0) crit_rel = 0;

                    if (maxRel > crit_rel && maxAbs > crit_abs)
                    {
                        seriesShown++;
                        //show this one
                    }
                    else
                    {
                        //not shown
                        continue;
                    }


                    double max1 = max * (1d + count / 12345678912d) + count / 12345678912d;
                    if (order)
                    {
                        while (true)
                        {
                            if (ordered.ContainsKey(-max1))
                            {
                                //this is very seldom, multiply with something small and add something small
                                //Random r = new Random();
                                double r2 = Program.RandomDouble();
                                max = max * (1 + r2 / 1000000d) + r2 / 1000000d;
                            }
                            else break;
                        }
                    }

                    if (order)
                    {
                        ordered.Add(-max1, sh);
                    }
                    else
                    {
                        string key = sh.series1.GetNameWithoutCurrentFreq(true);
                        if (!ordered.ContainsKey(key)) ordered.Add(key, sh);  //skip dublets here when printing
                    }
                }


                //databank compare
                samFile.WriteLine("Out of the " + both2.Count + " common series, there are differences regarding " + ordered.Count + " of them:");
                if (ordered.Count == 0) samFile.WriteLine("[none]");
                samFile.WriteLine();



                int counter = 0;
                foreach (DictionaryEntry de in ordered)
                {
                    counter++;

                    SamHelper sh = (SamHelper)de.Value;

                    string tsString = sh.series1.name;

                    double number = 0;
                    if (order)
                    {
                        number = (double)de.Key;
                    }

                    Series ts = sh.series1;
                    Series tsGrund = sh.series2;

                    string name = null;

                    if (removeCurrentFreqFromNames)
                    {
                        name = ts.GetNameWithoutCurrentFreq(true);
                    }
                    else
                    {
                        name = ts.GetName();
                    }

                    dif.Add(name);

                    if (variables == null)
                    {
                        samFile.Write(G.varFormat(name) + "   WORK       REFERENCE             ABS DIFF      % DIFF");
                    }
                    else
                    {
                        samFile.Write(G.varFormat(name) + "   FRML       DATABANK              ABS DIFF      % DIFF");
                    }
                    if (dlog)
                    {
                        samFile.Write("       DLOG");
                    }

                    if (order)
                    {
                        if (compareType == "relative")
                        {

                            samFile.WriteLine("         max = " + G.pchFormatOld(-number));
                        }
                        else
                        {
                            samFile.WriteLine("         max = " + G.levelFormatOld(-number));
                        }
                    }
                    else
                    {
                        samFile.WriteLine();
                    }

                    samFile.Write("-------------------------------------------------------------------");
                    if (dlog) samFile.WriteLine("------------");
                    samFile.WriteLine();

                    foreach (GekkoTime t in new GekkoTimeIterator(ConvertFreqs(tStart, tEnd, ts.freq)))
                    {
                        double varLevel = 0;
                        double varLevel2 = 0;
                        double varDelta = 0;
                        double varPch = 0;
                        double varDlog = double.NaN;
                        samFile.Write(t + " ");

                        {
                            varLevel = ts.GetDataSimple(t);
                            varLevel2 = tsGrund.GetDataSimple(t);
                            varDelta = ts.GetDataSimple(t) - tsGrund.GetDataSimple(t);
                            varPch = ((ts.GetDataSimple(t) / tsGrund.GetDataSimple(t) - 1d) * 100d);
                            if (dlog)
                            {
                                varDlog = Math.Log(tsGrund.GetDataSimple(t) / ts.GetDataSimple(t));
                            }

                            samFile.Write(G.levelFormatOld(varLevel));
                            samFile.Write(" ");
                            samFile.Write(G.levelFormatOld(varLevel2));
                            samFile.Write("       ");
                            samFile.Write(G.levelFormatOld(varDelta));
                            samFile.Write("    ");
                            if (varDelta == 0d) varPch = 0d; //this way, two clean 0's get 0% difference
                            samFile.Write(G.pchFormatOld(varPch));
                            if (dlog)
                            {
                                samFile.Write("    ");
                                samFile.Write(G.levelFormatOld(varDlog, 8));
                            }
                        }
                        samFile.WriteLine();
                    }
                    samFile.WriteLine();
                }
                samFile.Flush();
                if (G.Equal(dump, "yes"))
                {
                    List m = new Gekko.List(dif);
                    Program.databanks.GetFirst().AddIVariableWithOverwrite(Globals.symbolCollection + "dif", m);
                    dumpList = true;
                }
            }
            G.Writeln2("Databank compare on " + both2.Count + " common series, " + ordered.Count + " differences shown in file '" + samFileName + "'");
            if (dumpList) G.Writeln2("List " + Globals.symbolCollection + "dif contains the " + dif.Count + " different variables");
            if (notFoundBoth2.Count > 0)
            {
                G.Writeln("+++ NOTE: " + notFoundBoth2.Count + " series not found");
            }
        }

        public static Tuple<GekkoTime, GekkoTime> ConvertFreqs(GekkoTime tStart, GekkoTime tEnd, EFreq tsFreq)
        {
            //========================================================================================================
            //                          FREQUENCY LOCATION, indicates where to implement more frequencies
            //========================================================================================================

            AllFreqsHelper dates = G.ConvertDateFreqsToAllFreqs(tStart, tEnd);
            GekkoTime tStart2 = GekkoTime.tNull;
            GekkoTime tEnd2 = GekkoTime.tNull;
            if (tsFreq == EFreq.A)
            {
                tStart2 = dates.t1Annual;
                tEnd2 = dates.t2Annual;
            }
            else if (tsFreq == EFreq.Q)
            {
                tStart2 = dates.t1Quarterly;
                tEnd2 = dates.t2Quarterly;
            }
            else if (tsFreq == EFreq.M)
            {
                tStart2 = dates.t1Monthly;
                tEnd2 = dates.t2Monthly;
            }
            else if (tsFreq == EFreq.D)
            {
                tStart2 = dates.t1Daily;
                tEnd2 = dates.t2Daily;
            }
            else if (tsFreq == EFreq.U)
            {
                tStart2 = dates.t1Undated;
                tEnd2 = dates.t2Undated;
            }
            return new Tuple<GekkoTime, GekkoTime>(tStart2, tEnd2);
        }

        public static GekkoTime ConvertFreq(GekkoTime t, EFreq tsFreq, string startEnd)
        {            
            if (G.Equal(startEnd, "start"))
            {
                return GekkoTime.ConvertFreqsFirst(tsFreq, t, null);
            }
            else if (G.Equal(startEnd, "end"))
            {
                return GekkoTime.ConvertFreqsLast(tsFreq, t);
            }
            else
            {
                G.Writeln2("*** ERROR: Expected 'start' or 'end' argument, not '" + startEnd + "'");
                throw new GekkoException();
            }            
        }

        private static string MaybeRemoveFreq(string s1, bool removeCurrentFreqFromNames)
        {            
            if (removeCurrentFreqFromNames) return G.Chop_RemoveFreq(s1, G.GetFreq(Program.options.freq));
            else return s1;
        }

        private static void SamHandleTwoExistingSeries(List<string> onlyWork2, List<string> onlyRef2, List<string> both2, List<string> differentTypeSeries2, List<SamHelper> items, string tsNameWithFreq, Series ts, Series tsGrund, bool removeCurrentFreqFromNames)
        {
            if (ts.type != tsGrund.type)
            {
                differentTypeSeries2.Add(MaybeRemoveFreq(tsNameWithFreq, removeCurrentFreqFromNames));
            }
            else
            {
                if (ts.type == ESeriesType.ArraySuper)
                {
                    //both series are array-series, compare the subseries
                    if (ts.dimensions != tsGrund.dimensions)
                    {
                        //different number of dimensions
                        differentTypeSeries2.Add(MaybeRemoveFreq(tsNameWithFreq, removeCurrentFreqFromNames));
                    }
                    else
                    {
                        foreach (KeyValuePair<MapMultidimItem, IVariable> kvpsub in ts.dimensionsStorage.storage)
                        {
                            if (tsGrund.dimensionsStorage.storage.ContainsKey(kvpsub.Key))
                            {
                                //present both places, for instance x['a', 'b'] both places
                                //these two are going to be checked
                                both2.Add(MaybeRemoveFreq(tsNameWithFreq, removeCurrentFreqFromNames) + "[" + kvpsub.Key.ToString() + "]");
                                items.Add(new SamHelper() { series1 = kvpsub.Value as Series, series2 = tsGrund.dimensionsStorage.storage[kvpsub.Key] as Series });                                
                            }
                            else
                            {
                                onlyWork2.Add(MaybeRemoveFreq(tsNameWithFreq, removeCurrentFreqFromNames) + "[" + kvpsub.Key.ToString() + "]");
                            }
                        }

                        foreach (KeyValuePair<MapMultidimItem, IVariable> kvpsub in tsGrund.dimensionsStorage.storage)
                        {
                            if (ts.dimensionsStorage.storage.ContainsKey(kvpsub.Key))
                            {
                                //ignore, has been dealt with above
                            }
                            else
                            {
                                onlyRef2.Add(MaybeRemoveFreq(tsNameWithFreq, removeCurrentFreqFromNames) + "[" + kvpsub.Key.ToString() + "]");
                            }
                        }
                    }
                }
                else
                {
                    both2.Add(MaybeRemoveFreq(tsNameWithFreq, removeCurrentFreqFromNames));
                    items.Add(new SamHelper() { series1 = ts, series2 = tsGrund });
                }
            }
            //SamHelper sh = items[items.Count - 1];
            //if(sh.series1==null || sh.series2==null)
            //{

            //}
        }

        public static void ReleasePipe()
        {
            //In order to release any current piping to file, so it does not block other users
            if (Globals.pipeFileHelper.pipeFile != null)
            {
                Globals.pipeFileHelper.CloseFile();
            }
            Globals.pipeFileHelper.pipeFile = null;
            Globals.pipeFileHelper.pipeFileFileWithPath = "";
            Globals.pipe = false;
        }

        public static void ReleasePipe2()
        {
            //Release piping to file when doing stuff like "prt fy file=output.txt"
            if (Globals.pipeFileHelper2.pipeFile != null)
            {
                Globals.pipeFileHelper2.CloseFile();
            }
            Globals.pipeFileHelper2.pipeFile = null;
            Globals.pipeFileHelper2.pipeFileFileWithPath = "";
            Globals.pipe2 = false;
        }

        public static string MaybeAddPointAndZero(string s)
        {
            bool isInt = true;
            foreach (char c in s)
            {
                if (!Char.IsDigit(c)) isInt = false;
            }
            if (isInt) s = s + ".0";  //so it does not look like an integer -- user can see it is float
            return s;
        }

        public static string GetDatabankFilename(Databank databank)
        {
            return System.IO.Path.GetFileName(databank.FileNameWithPath);
        }

        private static List<Dictionary<string, string>> CreateSimplePrecedentsForPrtPplot(List<string> variables)
        {
            //just done to use PrtPplot(),
            List<Dictionary<string, string>> ll3 = new List<Dictionary<string, string>>();
            Dictionary<string, string> temp = new Dictionary<string, string>();
            foreach (string v in variables)
            {
                Dictionary<string, string> temp2 = new Dictionary<string, string>();
                temp2.Add(v, "");
                ll3.Add(temp);
            }
            return ll3;
        }

        public static string TableHelper(string inputFileName, bool menuTable)
        {
            //!! used in dynamic code
            //This is called from "TABLE filename.tab" command, including calls from menus which
            //will issue such a command in a thread (is so, menuTable is true).

            //inputFileName = Program.SubstituteAssignVarsInExpression(inputFileName);
            inputFileName = Program.AddExtension(inputFileName, "." + Globals.extensionTable);

            List<string> folders = new List<string>();

            folders.Add(Program.options.folder_table);
            folders.Add(Program.options.folder_table1);
            folders.Add(Program.options.folder_table2);
            if (menuTable)  //never done for normal table call
            {
                folders.Add(Path.GetDirectoryName(inputFileName));
                //Called from menus, a .tab file will always be with a full path.
                //But we want it to look in other folders too, so we strip the
                //path (added to folders above) and keep the filename.
                inputFileName = Path.GetFileName(inputFileName);
            }

            string fileNameTemp = FindFile(inputFileName, folders);
            if (fileNameTemp == null)
            {
                string s = FileNotFoundErrorMessage(inputFileName);
                MessageBox.Show(s);
                throw new GekkoException();
            }
            else inputFileName = fileNameTemp;
            return inputFileName;
        }

        public static void MulbkClone()
        {
            Databank first = Program.databanks.GetFirst();
            //DateTime dt3 = DateTime.Now;
            Databank secondary = Program.databanks.GetRef();
            secondary.Clear();
            G.CloneDatabank(secondary, first);
            secondary.FileNameWithPath = first.FileNameWithPath;
        }

        public static void CreateEndoNoLagBNumbers(int[] endoNoLagPointers)
        {
            Program.model.modelGekko.endogenousBNumbersOriginalInModelList = new List<int>();
            for (int i = 0; i < Program.model.modelGekko.varsBType.Count; i++)
            {
                if (endoNoLagPointers[i] != 1)
                {
                    continue;
                }
                Program.model.modelGekko.endogenousBNumbersOriginalInModelList.Add(i);
            }
        }

        /// <summary>
        /// For an endogenous variable, prints the ingoing variables and
        /// values of these.
        /// </summary>
        /// <param name="t">Time period</param>
        /// <param name="var1">Variable name</param>
        public static void PrintEquationVariables(GekkoTime t, string var1)
        {
            bool success = false;
            foreach (EquationHelper eh in Program.model.modelGekko.equations)
            {
                if (G.Equal(eh.lhs, var1))
                {
                    PrintEquationVariables(t, eh);
                    success = true;
                }
            }
            if (!success) G.Writeln2("*** ERROR: Variable " + var1 + " was not found as left-hand side variable in model");
        }

        /// <summary>
        /// For an equation number, prints the ingoing variables and
        /// values of these.
        /// </summary>
        /// <param name="t">Time period</param>
        /// <param name="eqNumber">Equation number</param>
        public static void PrintEquationVariables(GekkoTime t, EquationHelper eh)
        {
            int widthRemember = Program.options.print_width;
            int fileWidthRemember = Program.options.print_filewidth;
            Program.options.print_width = int.MaxValue;
            Program.options.print_filewidth = int.MaxValue;

            try
            {
                G.Writeln(eh.equationText);
            }
            finally
            {
                //resetting, also if there is an error
                Program.options.print_width = widthRemember;
                Program.options.print_filewidth = fileWidthRemember;
            }

            string lhs = eh.lhs;
            Dictionary<string, string> precedents = eh.precedentsWithLagIndicator;
            string period = t.ToString();

            Series tsls = Program.databanks.GetFirst().GetIVariable(lhs + Globals.freqIndicator + G.GetFreq(Program.options.freq)) as Series;  //#getvar

            if (tsls == null)
            {
                G.Writeln2("*** ERROR: Variable '" + lhs + "' does not exist in Work databank");
                throw new GekkoException();
            }

            G.Writeln();
            string period2 = "period " + period;
            //G.Writeln("Time period = " + period);
            G.Writeln("              " + (G.Blanks(14 - period2.Length) + period2) + "       %");

            G.Writeln("----------------------------------------");
            G.Write(lhs + G.Blanks(14 - lhs.Length));
            double t1 = tsls.GetDataSimple(t.Add(0));
            double t0 = tsls.GetDataSimple(t.Add(0 - 1));
            double pch = (t1 / t0 - 1) * 100d;
            if (t1 - t0 == 0d) pch = 0d;  //this way, two clean 0's get 0% difference
            string pch1 = G.pchFormatOld(pch);
            G.Writeln(G.levelFormatOld(t1) + " " + pch1);
            G.Writeln("----------------------------------------");
            foreach (string var in precedents.Keys)
            {
                string variable; int lag;
                G.ExtractVariableAndLag(var, out variable, out lag);
                string var2 = "";
                if (lag != 0)
                {
                    var2 = variable + "[" + lag + "]";
                }
                else
                {
                    var2 = variable;
                }
                G.Write(var2 + G.Blanks(14 - var2.Length));
                Series ts = Program.databanks.GetFirst().GetIVariable(variable + Globals.freqIndicator + G.GetFreq(Program.options.freq)) as Series;

                if (variable == null)
                {
                    G.Writeln2("*** ERROR: Variable '" + variable + "' does not exist in Work databank");
                    throw new GekkoException();
                }

                t1 = ts.GetDataSimple(t.Add(lag));
                t0 = ts.GetDataSimple(t.Add(lag - 1));
                pch = (t1 / t0 - 1) * 100d;
                if (t1 - t0 == 0d) pch = 0d;  //this way, two clean 0's get 0% difference
                pch1 = G.pchFormatOld(pch);
                G.Writeln(G.levelFormatOld(t1) + " " + pch1);
            }
            //G.Writeln();
            G.Writeln("----------------------------------------");
            G.Writeln("Use 'DISP <" + G.FromDateToString(t) + " " + G.FromDateToString(t) + " info> variable;' or 'DECOMP <" + G.FromDateToString(t) + " " + G.FromDateToString(t) + "> variable;' to trace further.");
            G.Writeln();
        }
        

        public static string AddFreqAtEndOfVariableName(string var)  //used most of the time, uses global freq
        {
            return AddFreqAtEndOfVariableName(var, Program.options.freq);
        }

        public static string AddFreqAtEndOfVariableName(string var, string freq)
        {
            return AddFreqAtEndOfVariableName(var, G.GetFreq(freq));
        }

        public static string AddFreqAtEndOfVariableName(string var, EFreq freq)
        {            
            if (freq == EFreq.A) return var;
            string var2 = var;
            if (freq == EFreq.Q || freq == EFreq.M || freq == EFreq.U)
            {
                if (var2.EndsWith(Globals.freqIndicator + "q") || var2.EndsWith(Globals.freqIndicator + "m") || var2.EndsWith(Globals.freqIndicator + "u"))
                {
                    //this is just a safety measure, to be deleted sometime
                    G.Writeln2("*** ERROR: strange behavior regarding freq indicator");
                    throw new GekkoException();
                }
                else
                {
                    if (freq == EFreq.Q)
                    {
                        var2 = var + Globals.freqIndicator + "q";
                    }
                    else if (freq == EFreq.M)
                    {
                        var2 = var + Globals.freqIndicator + "m";
                    }
                    else if (freq == EFreq.U)
                    {
                        var2 = var + Globals.freqIndicator + "u";
                    }
                    else
                    {
                        G.Writeln2("*** ERROR #745387463");
                        throw new GekkoException();
                    }
                    //for instance fy%q for fY in quarters
                }
            }
            else
            {
                G.Writeln2("*** ERROR: Internal error #74389642");
                throw new GekkoException();
            }
            //nothing done for "a" type
            return var2;
        }



        public static FileStream CheckIfFileIsBeingUsed(string fileName)
        {
            FileStream fs = null;
            try
            {
                //fs = File.Open(fileName, FileMode.Open, FileAccess.Read, FileShare.None);
                fs = File.Open(fileName, FileMode.Open, FileAccess.ReadWrite, FileShare.None);
            }
            catch (Exception e)
            {
                return null;
            }
            return fs;
        }



        public static string DoStuffWithDoubleUnderline(string text)
        {
            //In the long run, using RTF will be replaced by HTML. Double underlines and invisible text is just
            //not funny to write documentation with.
            //identifies double underline (code "\uldb").
            char[] t = text.ToCharArray();
            StringBuilder t2 = new StringBuilder();
            int max = t.Length - 10;  //make room for [i + x]
            for (int i = 0; i < max; i++)
            {
                if (t[i] == '\\' && t[i + 1] == 'u' && t[i + 2] == 'l' && t[i + 3] == 'd' && t[i + 4] == 'b' && t[i + 5] == '\\')
                {
                    t2.Append(t[i]);
                    t2.Append(t[i + 1]);
                    t2.Append(t[i + 2]);
                    t2.Append(t[i + 3]);
                    t2.Append(t[i + 4]);
                    t2.Append(t[i + 5]);
                    for (int j = i + 6; j < max; j++)
                    {
                        if (t[j] == ' ' && t[j + 1] != '\\')
                        {
                            t2.Append(t[j]);
                            t2.Append(" SIMPLELINK0 ");
                            //start of words
                            for (int k = j + 1; k < max; k++)
                            {
                                if (t[k] == '}')
                                {
                                    t2.Append(" SIMPLELINK1 ");

                                    if (true)
                                    {
                                        //find hidden text if any
                                        bool flag2 = false;  //met opening bracket
                                        bool flag3 = false;  //invisible code ("\v " or "\v\")
                                        for (int k2 = k + 1; k2 < max; k2++)
                                        {

                                            if (t[k2] == '\\' && t[k2 + 1] == 'u' && t[k2 + 2] == 'l' && t[k2 + 3] == 'd' && t[k2 + 4] == 'b' && t[k2 + 5] == '\\')
                                            {
                                                //not allowed to pass another underline -- probably something wrong: break out.
                                                t2.Append("<null>");
                                                t2.Append(" SIMPLELINK2 ");
                                                goto Flag2;
                                            }

                                            if (t[k2] == '\\' && t[k2 + 1] == 'v' && (t[k2 + 2] == '\\' || t[k2 + 2] == ' '))
                                            {
                                                flag3 = true;
                                            }
                                            if (t[k2] == '{')
                                            {
                                                flag2 = true;
                                            }
                                            if (t[k2] == '}')
                                            {
                                                if (flag2 && flag3)
                                                {
                                                    //backtrack to find a space to delimit the word
                                                    for (int k3 = k2 - 1; k3 > k; k3--)
                                                    {
                                                        if (t[k3] == ' ')
                                                        {
                                                            string word = new string(t, k3 + 1, k2 - k3 - 1);
                                                            t2.Append(word);
                                                            t2.Append(" SIMPLELINK2 ");
                                                            goto Flag2;
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                Flag2: ;


                                    t2.Append(t[k]);
                                    i = k;

                                    goto Flag1;
                                }
                                else
                                {
                                    t2.Append(t[k]);
                                }
                            }
                        }
                        else t2.Append(t[j]);
                    }
                }
                else
                {
                    t2.Append(t[i]);
                }
            Flag1: ;
            }
            text = t2.ToString();
            return text;
        }

        public static void makeBatFileForAremos()
        {
            GuiDialogMakeBatfile xx = new GuiDialogMakeBatfile(true);
            xx.ShowDialog();
            xx.Close();
        }

        // ================================================
        // CES stuff, perhaps make available in Function.cs
        // ================================================
        
        // with theta

        static double CES_XL(double yrel, double p1rel, double p2rel, double theta, double sigma)
        {
            double uc = CES_UC(p1rel, p2rel, theta, sigma);
            return yrel * Math.Pow(uc / p1rel, sigma);
        }

        static double CES_XR(double yrel, double p1rel, double p2rel, double theta, double sigma)
        {
            double uc = CES_UC(p1rel, p2rel, theta, sigma);
            return yrel * Math.Pow(uc / p2rel, sigma);
        }

        static double C(double ca, double p1, double p2, double p1a, double p2a, double theta, double sigma)
        {
            double c = ca * CES_UC(p1 / p1a, p2 / p2a, theta, sigma);
            return c;
        }

        static double CES_UC(double p1rel, double p2rel, double theta, double sigma)
        {
            double c = Math.Pow(theta * Math.Pow(p1rel, 1 - sigma) + (1 - theta) * Math.Pow(p2rel, 1 - sigma), 1 / (1 - sigma));
            return c;
        }

        static double Y(double x1, double x2, double ya, double x1a, double x2a, double theta, double sigma)
        {
            double rho = (sigma - 1) / sigma;
            double y_cal = ya * Math.Pow((theta * Math.Pow(x1 / x1a, rho) + (1 - theta) * Math.Pow(x2 / x2a, rho)), 1 / rho);
            return y_cal;
        }
        
        // -------

        // with delta

        static double Y_orig(double x1, double x2, double kappa, double delta, double sigma)
        {
            double rho = (sigma - 1) / sigma;
            double y = kappa * Math.Pow(delta * Math.Pow(x1, rho) + (1 - delta) * Math.Pow(x2, rho), 1 / rho);
            return y;
        }

        static double X1_orig(double y, double p1, double p2, double kappa, double delta, double sigma)
        {
            double x1 = y / kappa * Math.Pow((delta * kappa * AC_orig(p1, p2, kappa, delta, sigma)) / p1, sigma);
            return x1;
        }

        static double X2_orig(double y, double p1, double p2, double kappa, double delta, double sigma)
        {
            double x2 = y / kappa * Math.Pow(((1 - delta) * kappa * AC_orig(p1, p2, kappa, delta, sigma)) / p2, sigma);
            return x2;
        }

        static double C_orig(double y, double p1, double p2, double kappa, double delta, double sigma)
        {
            double c = y * AC_orig(p1, p2, kappa, delta, sigma);
            return c;
        }

        static double AC_orig(double p1, double p2, double kappa, double delta, double sigma)
        {
            double ac = 1 / kappa * Math.Pow(Math.Pow(delta, sigma) * Math.Pow(p1, 1 - sigma) + Math.Pow(1 - delta, sigma) * Math.Pow(p2, 1 - sigma), 1 / (1 - sigma));
            return ac;
        }

        // ================================================
        // CES stuff end
        // ================================================
                          
        [ProtoContract]
        public class ReadInfo
        {
            public static GekkoTime tStart = GekkoTime.tNull;
            public static GekkoTime tEnd = GekkoTime.tNull;
            //public EReadInfoTypes type = EReadInfoTypes.Normal;
            public string fileName = null;
            //public bool copiedIntoBaseMessage = false;
            public int variables;
            public int startPerInFile = -12345;
            public int endPerInFile = -12345;
            public int startPerResultingBank = -12345;
            public int endPerResultingBank = -12345;
            public int createdVars;
            public int nanCounter;
            public string dbName = null; //internal name for the RAM databank (key in hashtable of databanks)
            public double time = 0d;
            public Databank databank = null;
            public bool conversionMessage = false;
            public bool abortedStar = false;
            public bool open = false;
            public bool shouldMerge = false;
            public string pcim = "";  //only used for PCIM databanks.

            // ------- from XML
            public string databankVersion = "";
            public string info1 = null;  //from XML
            public string date;  //from XML
            public string modelName;  //from XML
            public string modelInfo;  //from XML
            public string modelDate;  //from XML
            public string modelSignature;  //from XML
            public string modelHash;  //from XML
            public string modelLastSimPeriod;  //from XML
            public string modelLastSimStamp;  //from XML
            public string modelLargestLag;  //from XML
            public string modelLargestLead;  //from XML

            public void Print()
            {
                string fileNameWithPath = null;
                string fileNameWithoutPath = null;
                string fileNameName = null;
                string fileNameExtension = null;
                if (this.fileName != null)
                {
                    fileNameWithPath = this.fileName;
                    fileNameWithoutPath = Path.GetFileNameWithoutExtension(this.fileName);
                    fileNameName = Path.GetFileName(this.fileName);
                    fileNameExtension = Path.GetExtension(this.fileName);                    
                }
                else
                {
                    if (Globals.excelDna)
                    {
                        fileNameWithPath = "[Gekcel]";
                        fileNameWithoutPath = "[Gekcel]";
                        fileNameName = "[Gekcel]";
                        fileNameExtension = "[xlsx]";
                    }
                }

                if (this.databank == null || this.databank.storage.Count == 0) return;  //no printing of these
                Table tab = new Table();
                tab.CurRow.SetTopBorder(1, 1);
                //this strange stuff is sometimes read from PCIM databanks
                string strange = "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0";
                string info = this.info1;
                if (info == null || info == "" || info == strange) info = "[empty]";
                string date = this.date;
                if (date == null || date == "" || date == strange) date = "[empty]";
                string ext = "";
                if (fileNameExtension.ToLower() == "bnk") ext = ".bnk";
                tab.CurRow.SetText(1, "DATABANK " + fileNameWithoutPath);                
                tab.CurRow.SetBottomBorder(1, 1);
                tab.CurRow.Next();
                tab.CurRow.SetText(1, "Info     : " + info);
                tab.CurRow.Next();
                tab.CurRow.SetText(1, "Date     : " + date);
                tab.CurRow.Next();
                if (open)
                {
                    tab.CurRow.SetText(1, "Open     : Opened " + fileNameName + " as '" + this.dbName + "'");
                    tab.CurRow.Next();
                }
                tab.CurRow.SetText(1, "File     : " + fileNameWithPath + " " + this.databankVersion);
                tab.CurRow.Next();

                string i1, i2; GetYearPeriod(this.startPerInFile, this.endPerInFile, out i1, out i2);

                tab.CurRow.SetText(1, "Period   : The file contains data from " + i1 + "-" + i2);
                tab.CurRow.Next();
                //#8572309572439
                int total = Program.databanks.GetDatabank(this.dbName).storage.Count;
                if (this.shouldMerge)
                {
                    tab.CurRow.SetText(1, "Size     : Merged " + this.variables + " variables from file into " + this.dbName + " databank (" + G.SecondsFormat(time) + ")");
                }
                else
                {
                    if (this.open) tab.CurRow.SetText(1, "Size     : Read " + this.variables + " variables from file (" + G.SecondsFormat(time) + ")");
                    else tab.CurRow.SetText(1, "Size     : Read " + this.variables + " variables from file into cleared " + this.dbName + " databank (" + G.SecondsFormat(time) + ")");
                }

                if (!this.open && this.createdVars > 0)
                {
                    tab.CurRow.Next();
                    tab.CurRow.SetText(1, "         : Created " + this.createdVars + " model variables (filled with missing values) in " + this.dbName + " databank");
                }
                if (!this.open)
                {
                    tab.CurRow.Next();
                    tab.CurRow.SetText(1, "           " + this.dbName + " databank now contains " + total + " variables (" + this.startPerResultingBank + "-" + this.endPerResultingBank + ")");
                }
                tab.CurRow.SetText(1, "Note     : Press F2 for info on databanks");

                tab.CurRow.SetBottomBorder(1, 1);
                tab.CurRow.SetLeftBorder(1);
                tab.CurRow.SetRightBorder(1);

                int widthRemember = Program.options.print_width;
                int fileWidthRemember = Program.options.print_filewidth;
                Program.options.print_width = int.MaxValue;
                Program.options.print_filewidth = int.MaxValue;
                try
                {

                    List<string> ss = tab.Print();
                    foreach (string s in ss) G.Writeln(s);

                    if (this.modelName != null)
                    {
                        StringBuilder sb = new StringBuilder();
                        sb.AppendLine("The databank contains the following information regarding its corresponding model:");
                        sb.AppendLine("Model file name: " + this.modelName);
                        sb.AppendLine("Model info: " + this.modelInfo);
                        sb.AppendLine("Model date: " + this.modelDate);
                        sb.AppendLine("Model signature: " + this.modelSignature);
                        sb.AppendLine("Model hash code: " + this.modelHash);
                        sb.AppendLine("Model last SIM period: " + this.modelLastSimPeriod);
                        sb.AppendLine("Model last SIM stamp: " + this.modelLastSimStamp);
                        sb.AppendLine("Model largest lag/lead: " + this.modelLargestLag + "/" + this.modelLargestLead);
                        LinkContainer lc = new LinkContainer(sb.ToString());
                        Globals.linkContainer.Add(lc.counter, lc);
                        G.Write("+++ NOTE: The databank contains MODEL/SIM info ("); G.WriteLink("more", "outputtab:" + lc.counter); G.Writeln(")");
                    }
                }
                finally
                {
                    //resetting, also if there is an error
                    Program.options.print_width = widthRemember;
                    Program.options.print_filewidth = fileWidthRemember;
                }

                if (this.pcim != null && this.pcim != "")
                {
                    G.Writeln("PCIM name/model when the PCIM databank was written: " + this.pcim);
                }

                if (this.nanCounter > 0)
                {
                    G.Writeln();
                    G.Writeln("+++ WARNING: Encountered " + this.nanCounter + " instances of 'NaN' in the file.");
                    G.Writeln("             These are set to missing -- proper .tsd syntax is to use '1.000000E+15'");
                    G.Writeln("             to indicate a missing value");
                    G.Writeln();
                }

                if (this.conversionMessage)
                {
                    LinkContainer lc = new LinkContainer("The databank is a ." + Globals.extensionDatabank + " file version 1.0. Newer ." + Globals.extensionDatabank + " files load around three times faster, so please consider converting the " + Globals.extensionDatabank + " file. Converting from 'oldfile." + Globals.extensionDatabank + "' to 'newfile." + Globals.extensionDatabank + "' is very simple:" + G.NL + G.NL + "  READ <" + Globals.extensionDatabank + "> oldfile;" + G.NL + "  WRITE <" + Globals.extensionDatabank + "> newfile;" + G.NL + G.NL + "There is no loss of data or data quality in this process, so the new ." + Globals.extensionDatabank + " file is a perfect substitute for the old one. The difference is that these old ." + Globals.extensionDatabank + " files are not using a binary format (as the newer ones do).");
                    Globals.linkContainer.Add(lc.counter, lc);
                    G.Write("+++ NOTE: You may convert the databank file for speedier reading (", Color.Gray); G.WriteLink("more", "outputtab:" + lc.counter); G.Writeln(")", Color.Gray);
                }

            }

            
        }

        public static void GetYearPeriod(int startPerInFile, int endPerInFile, out string i1, out string i2)
        {
            i1 = "[year?]";
            i2 = "[year?]";
            if (startPerInFile != int.MaxValue) i1 = startPerInFile.ToString();
            if (endPerInFile != int.MinValue) i2 = endPerInFile.ToString();
        }

        public class OneList
        {
            public string indexName;
            public List<string> indexItems;
        }

        public class Item
        {
            public string variable = "";
            public List<OneList> listOfLists;
            public List<string> explanation = new List<string>();
        }

        public class CompileErrorHelper
        {
            public List<string> text = new List<string>();
            public List<int> col = new List<int>();
            public int line = -1;
            public string file = "";
        }

        public class CompiledGenrStatements
        {
            //best to keep this stuff in one place, for safety
            public Dictionary<string, int> list = new Dictionary<string, int>(StringComparer.OrdinalIgnoreCase);
            public Assembly assembly = null;
            public string inputCode = null;
            public string generatedCsCode = null;
            public int checkNumberOfLines = -12345;
        }

        public class PrintHelper
        {
            public int widthDate = 0;
            public int width1 = 0;
            public int width2 = 0;
            public int widthLabel = 0;

        }

        public class WorkerThreadHelper1
        {
            //Titles, arrows
            public string titleField = "NULL";
            public string statusField = "NULL";
            public string leftArrow = "NULL";
            public string rightArrow = "NULL";
            public string homeButton = "NULL";
        }

        public class WorkerThreadHelper2
        {
            //For printing
            public string s;
            public string linktype;            
            public bool newline;
            public Color color;
            public bool link;
            public ETabs tab;
            public bool mustScrollToEnd;
            public bool mustAlsoPrintToScreen = false;

            public WorkerThreadHelper2 Clone()
            {
                WorkerThreadHelper2 wh = new WorkerThreadHelper2();
                wh.s = this.s;
                wh.linktype = this.linktype;
                wh.newline = this.newline;
                wh.color = this.color;
                wh.link = this.link;
                wh.tab = this.tab;
                wh.mustScrollToEnd = this.mustScrollToEnd;
                wh.mustAlsoPrintToScreen = this.mustAlsoPrintToScreen;
                return wh;
            }
        }

        public class DecompHelper
        {
            public string variableWithLag = null;
            //public double contribution = double.NaN;
            public double x0 = double.NaN;
            public double x1 = double.NaN;  //plus epsilon
            public double z = double.NaN;
            public double y0 = double.NaN;
            public double y1 = double.NaN;  //change when x is altered from x0 to x1
            public double slope = double.NaN;
            //public double x1 = double.NaN;
            //public double d_contribution = double.NaN;
            //public double d_x0 = double.NaN;
            //public double d_x1 = double.NaN;
        }

        public class ErrorContainer
        {
            public long counter;
            public List<string> simInitEndoMissingValue = null; //a
            public List<string> simNonExistingVariable = null; //b
            public List<string> simMissingValueExoOrLaggedEndo = null;  //c
            //-----
            public List<string> simInitEndoMissingValueHelper = null; //a
            public ErrorContainer()
            {
                Globals.outputTabTextCounter += 1;
                counter = Globals.outputTabTextCounter;
            }
        }

        public class LinkContainer
        {
            public long counter;
            public string s = null;

            public LinkContainer(string si)
            {
                Globals.linkContainerCounter += 1;
                counter = Globals.linkContainerCounter;
                s = si;
            }
        }


        public class RememberWriteStatementsHelper
        {
            public List<string> linesVariables = new List<string>();
            public List<string> linesData = new List<string>();
        }

        public class Cache
        {
            Dictionary<object, object> cache = new Dictionary<object, object>();

            /// <summary>
            /// Keeps up with the most recently read items.
            /// Items at the end of the list were read last.
            /// Items at the front of the list have been the most idle.
            /// Items at the front are removed if the cache capacity is reached.
            /// </summary>
            public List<object> priority = new List<object>();
            public Type Type { get; set; }
            public Cache(Type type)
            {
                this.Type = type;
                //TODO: register this cache with the manager
            }
            public object this[object key]
            {
                get
                {
                    lock (this)
                    {
                        if (!cache.ContainsKey(key)) return null;
                        //move the item to the end of the list
                        priority.Remove(key);
                        priority.Add(key);
                        return cache[key];
                    }
                }
                set
                {
                    lock (this)
                    {
                        if (Capacity > 0 && cache.Count == Capacity)
                        {
                            cache.Remove(priority[0]);
                            priority.RemoveAt(0);
                        }
                        cache[key] = value;
                        priority.Remove(key);
                        priority.Add(key);

                        if (priority.Count != cache.Count)
                            throw new Exception("Capacity mismatch.");
                    }
                }
            }
            public int Count { get { return cache.Count; } }
            public int Capacity { get; set; }

            public void Clear()
            {
                lock (this)
                {
                    priority.Clear();
                    cache.Clear();
                }
            }
        }
    }

    public class LocalGlobal
    {
        public enum ELocalGlobalType
        {
            Local,
            Global,
            None
        }

        private ELocalGlobalType all = ELocalGlobalType.None;
        private GekkoDictionary<string, ELocalGlobalType> storage = null;

        public void SetAllLocal()
        {
            if (this.Count() > 0 || all != ELocalGlobalType.None)
            {
                G.Writeln2("*** ERROR: LOCAL<all> must be the only LOCAL/GLOBAL statement");
                throw new GekkoException();
            }
            this.all = ELocalGlobalType.Local;
        }

        public void SetAllGlobal()
        {
            if (this.Count() > 0 || all != ELocalGlobalType.None)
            {
                G.Writeln2("*** ERROR: GLOBAL<all> must be the only LOCAL/GLOBAL statement");
                throw new GekkoException();
            }
            this.all = ELocalGlobalType.Global;
        }

        public int Count()
        {
            if (this.storage == null) return 0;
            return this.storage.Count;
        }

        public ELocalGlobalType GetValue(string s)
        {
            if (this.all != ELocalGlobalType.None) return this.all;
            if (this.storage == null) return ELocalGlobalType.None;            
            ELocalGlobalType rv;
            if (storage.TryGetValue(s, out rv))  //cannot be out rv, because if TryGetValue() fails, it returns the default value of the enum, and that is brittle
            {
                return rv;
            }
            return ELocalGlobalType.None;
        }
               

        public void Add(string s, ELocalGlobalType type)
        {
            if (this.all != ELocalGlobalType.None)
            {
                G.Writeln2("*** ERROR: Failed because " + this.all.ToString().ToUpper() + "<all> been set previously");
                throw new GekkoException();
            }
            if (this.storage == null) this.storage = new GekkoDictionary<string, ELocalGlobalType>(StringComparer.OrdinalIgnoreCase);
            if (this.storage.ContainsKey(s))
            {
                G.Writeln2("*** ERROR: The variable '" + s + "' is already set as " + this.storage[s].ToString().ToUpper());
                throw new GekkoException();
            }
            this.storage.Add(s, type);
        }
    }


    public class LocalBanks
    {
        public Databank localWork = null;
        public Databank localBase = null;
    }

    public class PrtHelperElement
    {
        //public string printCode = null;  //will be OBSOLETE
        public List<string> operators = new List<string>();
        public int width = -12345;
        public int dec = -12345;
        public int nwidth = -12345;
        public int ndec = -12345;
        public int pwidth = -12345;
        public int pdec = -12345;
    }

    public class PrtHelper
    {
        public string prtType = null;  //prt, mulprt, pctprt etc.
        public List<PrtHelperElement> elementOptions = null;
        public List<string> operators = new List<string>();
        //public string printCode = null; // m, d, p, q, etc. --> will be OBSOLETE
        public string printType = null; //PRT, SHEET, CSHEET, PLOT, etc.
        public bool rows = false;
        public int width = -12345;
        public int dec = -12345;
        public int nwidth = -12345;
        public int ndec = -12345;
        public int pwidth = -12345;
        public int pdec = -12345;
        //stuff for VPRT ------------------------
        public bool timeSpanShouldBeSetGlobally = false;
        //stuff mostly for Excel ----------------
        public string title = null;
        public string heading = null;
        public string stamp = null;
        public string fileName = null;
        public string sheet = null;
        public string cell = null;
        public string transpose = null;
        public string dates = null;
        public string labels = null;
        public string colors = null;
        public string append = null;
        public string timefilter = null;
        //general stuff -------------------------
        public bool isGmulprt = false;  //overrules a lot of the others
        public bool isVprt = false;  //overrules a lot of the others
        public bool isCalledFromGraphWindow = false;
    }

    public class PrtPplotHelper
    {
        public bool isDecomp = false;
        public bool isDecompToExcel = false;
        public bool onlyDoTimeseriesCheck = false;
        public bool isGmulprt = false;
        public bool isVprt = false;
        public bool timeSpanShouldBeSetGlobally = false;

        public string prtCsSnippet;

    }



    public class PrtOptionsHelper
    {
        public bool isLevel = false;
        public bool isLog = false;
        public bool isPch = false;
        public bool isDiff = false;
        public bool isDlog = false;
        public bool isMultiplier = false;
        public bool isBaseline = false;
        public bool printPeriod = true;
        public string title = "";
        public string heading = "";
        public bool isGmulprt = false;  //overrules a lot of the others
        public bool isVprt = false;  //overrules a lot of the others
        public bool isDp = false;  //code "dp"
        public bool isMp = false;  //code "mp"
        public bool timeSpanShouldBeSetGlobally = false;  //only used for VPRT, PRT etc. puts it inside ConvertToGekkoTiIme()
        public bool isCalledFromGraphWindow = false;
        public string pplotType = "emf";
    }

    public class IterMemory
    {
        public double[] bBefore;
        public double[] bAfter;
    }

    public class ExcelOptions
    {
        public string printOptions = null;
        public string title = null;
        public string heading = null;
        public string stamp = null;
        public string fileName = null;
        public string sheet = null;
        public string cell = null;
        public string transpose = null;
        public string dates = null;
        public string labels = null;
        public string colors = null;
        public string append = null;
        public bool isClip = false;
        public string[,] excelRowLabels = null;
        public string[,] excelColumnLabels = null;
        public GekkoTime[,] excelColumnLabelsGekkoTime = null;
        public double[,] excelData = null;
    }

    public class Wildcard : Regex
    {
        /// <summary>
        /// Initializes a wildcard with the given search pattern.
        /// </summary>
        /// <param name="pattern">The wildcard pattern to match.</param>
        public Wildcard(string pattern)
            : base(WildcardToRegex(pattern))
        {
        }

        /// <summary>
        /// Initializes a wildcard with the given search pattern and options.
        /// </summary>
        /// <param name="pattern">The wildcard pattern to match.</param>
        /// <param name="options">A combination of one or more
        /// <see cref="System.Text.RegexOptions"/>.</param>
        public Wildcard(string pattern, RegexOptions options)
            : base(WildcardToRegex(pattern), options)
        {
        }

        /// <summary>
        /// Converts a wildcard to a regex.
        /// </summary>
        /// <param name="pattern">The wildcard pattern to convert.</param>
        /// <returns>A regex equivalent of the given wildcard.</returns>
        public static string WildcardToRegex(string pattern)
        {
            return "^" + Regex.Escape(pattern).
             Replace("\\*", ".*").
             Replace("\\?", ".") + "$";
        }
    }

    public class ExcelDataForClip
    {
        public bool transpose = false;
        public double[,] data;
        public string[,] varnames;
        public string[,] dates;
        public string stamp = null;
        public string heading = null;
    }

    public enum EHasShownErrorHandling
    {
        True,
        TrueAndAlsoSkippedLines,
        False
    }

    public enum EDataFormat
    {
        None,
        Tsd,
        Tsdx,
        Gbk,
        Tsp,
        Csv,
        Prn,
        Pcim,
        Px,
        Flat,
        Xls,
        Xlsx,
        Gdx,
        Aremos
    }

    public enum EOpenType
    {
        Normal,
        Edit, //OPEN<edit>, not used elsewhere
        First, //READ<first>, CLEAR<first>, etc. 
        Sec,  
        Last,
        Pos,
        Ref //READ<ref>, CLEAR<ref>, etc.
    }

    public class ReadOpenMulbkHelper: O_OLD
    {
        public GekkoTime t1 = GekkoTime.tNull;
        public GekkoTime t2 = GekkoTime.tNull;
        public List<List<string>> openFileNames = null;
        private string fileName = null;
        private EDataFormat type = EDataFormat.None;  //type of data(bank)
        private bool merge = false;  //merge or not.
        private string as2 = null; //for OPEN AS.
        private string orientation = null;  //rows or cols
        public EOpenType openType = EOpenType.Normal;
        public int openTypePosition = -12345;
        public bool editable = false;
        public string gdxopt = null;
        public string array = null;
        public string dateformat = null;
        public string datetype = null;
        public string sheet = null;

        public string FileName
        {
            get { return fileName; }
            set { FailIfImmutable(); fileName = value; }
        }

        public EDataFormat Type
        {
            get { return type; }
            set { FailIfImmutable(); type = value; }
        }

        public bool Merge
        {
            get { return merge; }
            set { FailIfImmutable(); merge = value; }
        }

        public string As
        {
            get { return as2; }
            set { FailIfImmutable(); as2 = value; }
        }

        public string Orientation
        {
            get { return orientation; }
            set { FailIfImmutable(); orientation = value; }
        }

    }

    public class O_OLD //arguments to methods
    {
        private int id = -12345;
        private bool immutable = false;

        public void SetId(Q q)  //This method should only be used in .Add() in Q class and not elsewhere!!
        {
            FailIfImmutable();  //for safety, so we are sure the .id is only set once
            this.id = q.Count();
        }

        public int GetId()
        {
            return this.id;
        }

        public bool IsReadOnly
        {
            get { return immutable; }
        }

        public virtual void MakeReadOnly()
        {
            immutable = true;
        }

        protected virtual void FailIfImmutable()
        {
            if (immutable)
            {
                G.Writeln2("*** ERROR: Internal error #46374843");
                throw new GekkoException();
            }
        }

    }

    public class Q  //essentially just a container to store method objects
    {
        private List<O_OLD> storage = new List<O_OLD>();

        public O_OLD this[int i]
        {
            get
            {
                //O o = q[117]
                return storage[i];
            }
            //set --> not allowed
        }

        public void Add(O_OLD o)
        {
            o.SetId(this); //This method should only be used in .Add() in Q class and not elsewhere!! Will set id to storage.Count (ok since item has not been added yet)
            o.MakeReadOnly();  //So the field do not get altered when the object is used later on. The object might be used many time, for instance the statement is inside a loop.
            storage.Add(o);
        }

        public int Count()
        {
            return this.storage.Count;
        }
    }

        public class P
    {
        public bool hasWrittenRunTimeErrorOnce = false;  //bit hacky
        public EHasShownErrorHandling hasShownErrorHandling = EHasShownErrorHandling.False;
        private int counter = 0;  //1 gets added soon enough
        //private Q[] stackQ = new Q[200]; //contains arguments to different methods, new object put in here every time a new .cmd file is run.
        private string[] stack = new string[200];  //2000 nested cmd files -- should be enough
        private string[] stackCommandFileText = new string[200];
        private string[] stackFileSentToAntlr = new string[200];
        public string lastFileSentToANTLR = null;
        public bool isOneLinerFromGui = false;
        public bool hasBeenCmdFile = false;
        //public bool hasBeenIsstartCmdFile = false;
        public bool hasBeenClosebanks = false;
        public bool canShowErrorDialog = true;
        public DateTime timeAtLastUserInteraction = DateTime.Now;
        public DateTime startingTime = DateTime.Now;
        public bool hasBeenCompilationError = false;
        public int hasSeenStopCommand = 0; //if 0, no STOP is encountered. Can also be 1 or 2.
        private GekkoDictionary<string, int> commandFileCounter = new GekkoDictionary<string, int>(StringComparer.OrdinalIgnoreCase);
        private GekkoDictionary<string, string> commandFileCounterTainted = new GekkoDictionary<string, string>(StringComparer.OrdinalIgnoreCase);
        public int numberOfServiceMessages = 0;

        public string GetStack(int i)
        {
            return stack[i];
        }

        public string GetLastFileSentToANTLR(int i)
        {
            return stackFileSentToAntlr[i];
        }
        

        public bool IsSimple() {
            if (this.isOneLinerFromGui && this.counter <= 1)
            {
                return true;
            }
            return false;
        }

        public string GetStackCommandFileText(int i)
        {
            return stackCommandFileText[i];
        }

        public int GetDepth()
        {
            return counter;
        }

        public void SetLastFileSentToANTLR(string s)
        {
            //This method is called in translated code, for each line (that is not "simple", ie. FOR, IF etc.)
            this.stackFileSentToAntlr[counter] = s;            
        }        

        public void SetText(string s)
        {
            //This method is called in translated code, for each line (that is not "simple", ie. FOR, IF etc.)

            string file = "";
            if (counter > 0) file = this.stackFileSentToAntlr[counter - 1];  //counter will probably always be 1 or larger when this method is called
            this.stack[counter] =  file + s;
            ReportToRunStatus(false);
        }

        public void SetCommandFileText(string s)
        {
            this.stackCommandFileText[counter] = s;
        }

        public void Deeper()
        {
            //if (Globals.runningOnTTComputer) G.Writeln2("DEEPER " + this.counter, Color.Green);
            this.counter++;            
        }

        public void RemoveLast()
        {
            //if (Globals.runningOnTTComputer) G.Writeln2("REMOVELAST " + this.counter, Color.Green);
            if (this.counter > 0)
            {
                string temp = this.stack[counter];
                if (temp != null)
                {
                    if (this.commandFileCounter.ContainsKey(temp))
                    {
                        this.commandFileCounter[temp]++;
                    }
                    else
                    {
                        this.commandFileCounter.Add(temp, 1);
                    }

                    if (this.hasShownErrorHandling == EHasShownErrorHandling.True)
                    {
                        //Such a file will be given status "Failed" instead of "Ok".
                        //files with omitted lines will keep "Ok" status, it is up to
                        //the user to remember that he or she is skipping stuff (the number
                        //of skipped lines will be reported at the end, though).
                        //A file with syntax problems is considered unseen, until
                        //it can be parsed, compiled and run.
                        if (!this.commandFileCounterTainted.ContainsKey(temp))
                        {
                            this.commandFileCounterTainted.Add(temp, "");
                        }
                    }
                }
                this.stack[counter] = null;
                this.stackCommandFileText[counter - 1] = null;
                this.stackFileSentToAntlr[counter - 1] = null;

            }
            this.counter--;
        }

        public void ReportToRunStatus(bool enforce)  //enforce forces update, even if little time has elaspsed
        {
            if (Globals.windowRunStatus == null) return;

            DateTime d = DateTime.Now;
            if (!enforce && (d - Globals.windowRunStatusLastCall).TotalMilliseconds < 250) return;
            Globals.windowRunStatusLastCall = d;

            bool stackTab = false;
            bool runTab = false;
            if (Globals.windowRunStatusIsStackTab) stackTab = true;
            else runTab = true;
            if (enforce)
            {
                stackTab = true;
                runTab = true;
            }

            if (stackTab)
            {
                ObservableCollection<RunStatusData> items = new ObservableCollection<RunStatusData>();
                int max = this.GetDepth();
                int start = 1;
                if (this.isOneLinerFromGui) start = 2;  //do not show the 1 user input line starting it all (will be a run statement anyway, if starting a job)
                for (int i = start; i <= max; i++)  //index 0 is not used
                {
                    int lineNumber2;
                    string fileCalled;
                    List<string> commandLines2;
                    //Note: may return '[?]' as file
                    Program.GetErrorLineAndText(this, i, out lineNumber2, out fileCalled, out commandLines2);
                    string line = "?";
                    if (lineNumber2 > 0) line = lineNumber2.ToString();
                    if (lineNumber2 == 0)
                    {
                        continue;  //most of these null-nodes are filtered out, seems a few are left...
                    }
                    if (fileCalled == "[?]")
                    {
                        continue; //filtered out, seems it does not happen anymore...
                    }
                    string calling = "";
                    if (i - start > 0) calling = "...calling:";

                    string fileName = Path.GetFileName(fileCalled);
                    string fileNameAndPath = fileCalled;
                    if (i - start == 0 && fileCalled == "")
                    {
                        fileName = "[User input lines]";
                        fileNameAndPath = "[Multiple lines marked in Main window]";
                    }
                    RunStatusData data = new RunStatusData(fileName, line, fileNameAndPath, calling, null);
                    items.Add(data);
                }
                Gekko.CrossThreadStuff.StackTrace(items);
            }

            if (runTab)
            {
                List<RunStatusData> items = new List<RunStatusData>();
                //ObservableCollection<RunStatusData> items = new ObservableCollection<RunStatusData>();

                foreach (KeyValuePair<string, int> kvp in this.commandFileCounter)
                {
                    string lineText;
                    int lineNumber2;
                    Program.SplitCommandBeingExecuted(out lineText, out lineNumber2, kvp.Key);
                    if (lineText != null && lineText != "")
                    {
                        string status = "OK";
                        if (this.commandFileCounterTainted.ContainsKey(kvp.Key)) status = "Failed";
                        RunStatusData data = new RunStatusData(Path.GetFileName(lineText), kvp.Value.ToString(), lineText, null, status);
                        items.Add(data);
                    }
                }
                items.Sort();
                ObservableCollection<RunStatusData> items2 = new ObservableCollection<RunStatusData>();
                foreach (RunStatusData r in items) items2.Add(r);
                Gekko.CrossThreadStuff.RunStatus(items2);
            }
        }
    }

    class XmlColInfo
    {
        public Attrib attrib = new Attrib();
        public List<string> subcolborders = new List<string>();  //for now this is not really used, but will be later on
    }

    class Attrib
    {
        public Dictionary<string, string> data = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
        public string Get(string s)
        {
            string t = null; data.TryGetValue(s, out t);
            return t;
        }
        public bool Set(string s, string t)
        {
            if (data.ContainsKey(s)) return false;
            data[s] = t;
            return true;
        }
    }

    class XmlHelper
    {
        public StringBuilder s = new StringBuilder();
        public StringBuilder sEnd = new StringBuilder();
        public List<int> colLeftBorders = new List<int>();
        public List<int> colRightBorderPlusOne = new List<int>();
        public int totalCols = 0;
        public int totalRows = 0;
        public bool probe = true;
        public Attrib table = new Attrib();
        public List<XmlColInfo> cols = new List<XmlColInfo>();
        public Attrib rowGlobal = new Attrib();
        public List<int> colA = new List<int>();  //not sure what this is... seems not used at all: nothing is ever added to it
        public List<int> colB = new List<int>();  //not sure what this is... seems not used at all: nothing is ever added to it
        public int rowCounter = 0;
        public bool isLastRow = false;
    }

    public class Utf8Checker
    {
        public static bool Check(string fileName)
        {
            using (BufferedStream fstream = new BufferedStream(File.OpenRead(fileName)))
            {
                return IsUtf8(fstream);
            }
        }

        /// <summary>
        /// Check if stream is utf8 encoded.
        /// Notice: stream is read completely in memory!
        /// </summary>
        /// <param name="stream">Stream to read from.</param>
        /// <returns>True if the whole stream is utf8 encoded.</returns>
        public static bool IsUtf8(Stream stream)
        {
            int count = 4 * 1024;
            byte[] buffer;
            int read;
            while (true)
            {
                buffer = new byte[count];
                stream.Seek(0, SeekOrigin.Begin);
                read = stream.Read(buffer, 0, count);
                if (read < count)
                {
                    break;
                }
                buffer = null;
                count *= 2;
            }
            return IsUtf8(buffer, read);
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="buffer"></param>
        /// <param name="length"></param>
        /// <returns></returns>
        public static bool IsUtf8(byte[] buffer, int length)
        {
            int position = 0;
            int bytes = 0;
            while (position < length)
            {
                if (!IsValid(buffer, position, length, ref bytes))
                {
                    return false;
                }
                position += bytes;
            }
            return true;
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="buffer"></param>
        /// <param name="position"></param>
        /// <param name="length"></param>
        /// <param name="bytes"></param>
        /// <returns></returns>
        public static bool IsValid(byte[] buffer, int position, int length, ref int bytes)
        {
            if (length > buffer.Length)
            {
                throw new ArgumentException("Invalid length");
            }

            if (position > length - 1)
            {
                bytes = 0;
                return true;
            }

            byte ch = buffer[position];

            if (ch <= 0x7F)
            {
                bytes = 1;
                return true;
            }

            if (ch >= 0xc2 && ch <= 0xdf)
            {
                if (position >= length - 2)
                {
                    bytes = 0;
                    return false;
                }
                if (buffer[position + 1] < 0x80 || buffer[position + 1] > 0xbf)
                {
                    bytes = 0;
                    return false;
                }
                bytes = 2;
                return true;
            }

            if (ch == 0xe0)
            {
                if (position >= length - 3)
                {
                    bytes = 0;
                    return false;
                }

                if (buffer[position + 1] < 0xa0 || buffer[position + 1] > 0xbf ||
                    buffer[position + 2] < 0x80 || buffer[position + 2] > 0xbf)
                {
                    bytes = 0;
                    return false;
                }
                bytes = 3;
                return true;
            }


            if (ch >= 0xe1 && ch <= 0xef)
            {
                if (position >= length - 3)
                {
                    bytes = 0;
                    return false;
                }

                if (buffer[position + 1] < 0x80 || buffer[position + 1] > 0xbf ||
                    buffer[position + 2] < 0x80 || buffer[position + 2] > 0xbf)
                {
                    bytes = 0;
                    return false;
                }

                bytes = 3;
                return true;
            }

            if (ch == 0xf0)
            {
                if (position >= length - 4)
                {
                    bytes = 0;
                    return false;
                }

                if (buffer[position + 1] < 0x90 || buffer[position + 1] > 0xbf ||
                    buffer[position + 2] < 0x80 || buffer[position + 2] > 0xbf ||
                    buffer[position + 3] < 0x80 || buffer[position + 3] > 0xbf)
                {
                    bytes = 0;
                    return false;
                }

                bytes = 4;
                return true;
            }

            if (ch == 0xf4)
            {
                if (position >= length - 4)
                {
                    bytes = 0;
                    return false;
                }

                if (buffer[position + 1] < 0x80 || buffer[position + 1] > 0x8f ||
                    buffer[position + 2] < 0x80 || buffer[position + 2] > 0xbf ||
                    buffer[position + 3] < 0x80 || buffer[position + 3] > 0xbf)
                {
                    bytes = 0;
                    return false;
                }

                bytes = 4;
                return true;
            }

            if (ch >= 0xf1 && ch <= 0xf3)
            {
                if (position >= length - 4)
                {
                    bytes = 0;
                    return false;
                }

                if (buffer[position + 1] < 0x80 || buffer[position + 1] > 0xbf ||
                    buffer[position + 2] < 0x80 || buffer[position + 2] > 0xbf ||
                    buffer[position + 3] < 0x80 || buffer[position + 3] > 0xbf)
                {
                    bytes = 0;
                    return false;
                }

                bytes = 4;
                return true;
            }

            return false;
        }
    }


    public class CompareHelper
    {
        public CompareHelper(GekkoTime g1, GekkoTime g2)
        {
            t1 = g1;
            t2 = g2;
        }
        public GekkoTime t1;
        public GekkoTime t2;
    }

    class Person
    {
        private int id;
        private int milesTraveled;
        public int Id
        {
            get { return id; }
            set { id = value; }
        }
        public string Name { get; private set; }
        private static int InstanceCount;

        public Person() : this(0) { }

        public Person(int id) : this(id, string.Empty) { }

        public Person(int id, string name)
        {
            Id = id;
            Name = name;
            InstanceCount++;
        }

        public char this[int index]
        {
            get { return Name[index]; }
        }

        private void Walk(int miles)
        {
            milesTraveled += miles;
        }

        private static void IncreaseInstanceCount()
        {
            InstanceCount++;
        }

        private static int GetInstanceCount()
        {
            return InstanceCount;
        }

        public static void Swap(ref int i, ref int j)
        {
            int tmp = i;
            i = j;
            j = tmp;
        }
    }

    [Serializable]
    [ProtoContract]
    public class Proto
    {
        [ProtoMember(1)]
        public int xx1;
        int xx2;
        private int xx3;
        [ProtoMember(2)]
        public List<int> yy1;
        List<int> yy2;
        private List<int> yy3;
        [ProtoMember(3)]
        public List<int> zz1;
        [ProtoMember(4, AsReference = true)]
        public ProtoHelper hh1;
        [ProtoMember(5, AsReference = true)]
        public ProtoHelper hh2;
        public Proto()
        {
        }
        public Proto(string input)
        {
            G.Writeln(input);
        }
    }

    [ProtoContract]
    public class ProtoHelper
    {
        [ProtoMember(1)]
        public List<int> hh;
    }

    public class PipeFileHelper
    {
        public string pipeFileFileWithPath = "";
        public StreamWriter pipeFile = null;
        public bool pipeFileTypeIsHtml = false;
        public string htmlEndingTagsStuff = "";  //this is going to be appended to a html file when the pipe stops.
        //public bool isPiping = true;
        
        public void CloseFile()
        {
            if (pipeFileTypeIsHtml)
            {
                pipeFile.Write(htmlEndingTagsStuff);
            }
            this.pipeFile.Flush();
            this.pipeFile.Close();
            this.pipeFile.Dispose();

            //this.pipeFile.BaseStream.Flush();  --> does not work
            //this.pipeFile.BaseStream.Close();
            //this.pipeFile.BaseStream.Dispose();
        }
    }

    public class HPfilter
    {
        public double[] HPFilter(double[] data, double lambda)
        {
            {
                {
                    int N = data.Length;
                    int K;
                    double[] a = new double[N];
                    double[] b = new double[N];
                    double[] c = new double[N];

                    // Elemente der Haupt- und Nebendiagonalen

                    a[0] = 1 + lambda;
                    b[0] = -2 * lambda;
                    c[0] = lambda;
                    for (K = 1; K < N - 2; K++)
                    {
                        a[K] = 6 * lambda + 1;
                        b[K] = -4 * lambda;
                        c[K] = lambda;
                    }
                    a[1] = 5 * lambda + 1;
                    a[N - 1] = 1 + lambda;
                    a[N - 2] = 5 * lambda + 1;
                    b[0] = -2 * lambda;
                    b[N - 2] = -2 * lambda;
                    b[N - 1] = 0;
                    c[N - 2] = 0;
                    c[N - 1] = 0;

                    data = pentas(a, b, c, data, N);

                    return data;


                }
            }
        }

        static double[] pentas(double[] a, double[] b, double[] c, double[] data, int N)
        {
            /*
             *  Schneller Algorithmus zur Lösung des LGS BxX=Y
             * unter Berücksichtigung, dass B eine pentadiagonale Matrix ist
             * siehe z.B. Helmut Späth "Numerik, Eine Einführung für
             * Mathematiker und Informatiker", S. 110 ff, Braunschweig &
             * Wiesbaden, 1994
             *
            */

            int K;
            double H1 = 0;
            double H2 = 0;
            double H3 = 0;
            double H4 = 0;
            double H5 = 0;
            double HH1 = 0;
            double HH2 = 0;
            double HH3 = 0;
            double HH4 = 0;
            double HH5 = 0;
            double Z;
            double HB;
            double HC;

            // Vorwärts
            for (K = 0; K < N; K++)
            {
                Z = a[K] - H4 * H1 - HH5 * HH2;
                HB = b[K];
                HH1 = H1;
                H1 = (HB - H4 * H2) / Z;
                b[K] = H1;
                HC = c[K];
                HH2 = H2;
                H2 = HC / Z;
                c[K] = H2;
                a[K] = (data[K] - HH3 * HH5 - H3 * H4) / Z;
                HH3 = H3;
                H3 = a[K];
                H4 = HB - H5 * HH1;
                HH5 = H5;
                H5 = HC;
            }

            // Rückwärts
            H2 = 0;
            H1 = a[N - 1];
            data[N - 1] = H1;

            for (K = N - 2; K > -1; K--)
            {

                data[K] = a[K] - b[K] * H1 - c[K] * H2;
                H2 = H1;
                H1 = data[K];
            }
            return data;
        }
    }
    

    public enum ECellLightType
    {
        None,
        String,
        Double,
        DateTime
    }

    public struct CellLight
    {
        public double data;
        public string text;
        public DateTime dateTime;
        public ECellLightType type;
        public bool hasQuotes;

        public CellLight(double input)
        {
            text = null;
            data = input;
            dateTime = DateTime.MinValue;
            type = ECellLightType.Double;
            hasQuotes = false;
        }

        public CellLight(DateTime input)
        {
            text = null;
            data = double.NaN;
            dateTime = input;
            type = ECellLightType.DateTime;
            hasQuotes = false;
        }

        public CellLight(string input)
        {
            text = input;
            data = double.NaN;
            dateTime = DateTime.MinValue;
            type = ECellLightType.String;
            hasQuotes = false;
        }

        public CellLight(string input, bool hasQuotes2)
        {
            text = input;
            data = double.NaN;
            dateTime = DateTime.MinValue;
            type = ECellLightType.String;
            hasQuotes = hasQuotes2;
        }

        public string ToString()
        {
            string rv = "---null---";
            if (this.type==ECellLightType.DateTime)
            {
                rv = "a date";
            }
            else if (this.type == ECellLightType.Double)
            {
                rv = this.data.ToString();
            }
            else if (this.type == ECellLightType.String)
            {
                rv = this.text;
            }
            return rv;
        }
    }

    public class FrameLightRow
    {
        public List<CellLight> storage = null;

        public FrameLightRow(FrameLight frame)
        {
            this.storage = new List<CellLight>(new CellLight[frame.colnames.Count]); //fills it with "null"-objects  t);            
        }

        public void Set(FrameLight frame, string colname, CellLight cell)
        {
            int i = FindColumn(frame, colname);
            this.storage[i] = cell;
        }

        public CellLight Get(FrameLight frame, string colname)
        {
            int i = FindColumn(frame, colname);
            return this.storage[i];
        }

        public static bool HasColumn(FrameLight frame, string colname)
        {
            for (int i = 0; i < frame.colnames.Count; i++)
            {
                if (G.Equal(frame.colnames[i], colname)) return true;
            }
            return false;
        }

        public static int FindColumn(FrameLight frame, string colname)
        {            
            int j = -12345;
            for (int i = 0; i < frame.colnames.Count; i++)
            {
                if (G.Equal(frame.colnames[i], colname)) j = i;
            }
            if (j == -12345)
            {
                G.Writeln2("*** ERROR: Could not find name '" + colname + "'");
            }
            return j;
        }
    }

    public class FrameFilter
    {
        public string name = null;
        public List<string> selected = null;
        public bool active = false;
    }

    public class FrameLight
    {
        public List<FrameLightRow> rows = new List<FrameLightRow>();
        public List<string> colnames = new List<string>(); //must be lowercase
        
        public void AddColName(string colname)
        {            
            if (!this.colnames.Contains(colname, StringComparer.OrdinalIgnoreCase))
            {
                this.colnames.Add(colname);
                for (int i = 0; i < this.rows.Count; i++)
                {
                    this.rows[i].storage.Add(new CellLight());
                }
            }
        }                
    }

    public class TableLight
    {
        Dictionary<long, CellLight> storage = new Dictionary<long, CellLight>();
        private int rowMax = int.MinValue;
        private int colMax = int.MinValue;
        public string prnOrientation = null;

        private long GetKey(int row, int col)
        {
            //seems we can safely assume number of rows and cols < 2.147.483.647!
            return (long)row + (long)int.MaxValue * (long)col;
        }

        public int GetRowMaxNumber()
        {
            return rowMax;
        }

        public int GetColMaxNumber()
        {
            return colMax;
        }

        public void Add(int row, int col, CellLight value)
        {
            if (row > rowMax) rowMax = row;
            if (col > colMax) colMax = col;
            long key = GetKey(row, col);
            storage.Add(key, value);
        }

        public CellLight Get(int row, int col)
        {
            long key = GetKey(row, col);
            CellLight cell = new CellLight(); storage.TryGetValue(key, out cell);
            //if it does not exist, the cell will have .type = None.
            return cell;
        }

        public bool ContainsKey(int row, int col)
        {
            long key = GetKey(row, col);
            return storage.ContainsKey(key);
        }

        public TableLight Transpose()
        {
            TableLight ttable = new TableLight();
            foreach (KeyValuePair<long, CellLight> kvp in this.storage)
            {
                int row = (int)(kvp.Key % int.MaxValue);
                int col = (int)(kvp.Key / int.MaxValue);
                ttable.Add(col, row, kvp.Value);
            }
            return ttable;
        }
    }


    public class ModelCommentsHelper
    {
        public string infoText = null;
        public string dateText = null;
        public ESignatureStatus signatureStatus;
        public string signatureFoundInFileHeader = null;
        public int infoCounter = 0;
        public int dateCounter = 0;
        public int signatureCounter = 0;
        public string modelHashTrue = null;
        public string cutout_varlist;
        public string cutout_runbefore;
        public string cutout_runafter;        

    }

    public class RunStatusData : INotifyPropertyChanged, IComparable<RunStatusData>
    {
        private string name;
        private string value;
        private string fullName;
        private string calling;
        private string status;
        public event PropertyChangedEventHandler PropertyChanged;

        //public int Compare(RunStatusData x, RunStatusData y)
        //{
        //    return string.Compare(x.Name, y.Name);
        //}

        public int CompareTo(RunStatusData other)
        {
            return string.Compare(this.Name, other.Name);
        }

        public string Name
        {
            get { return this.name; }
            set
            {
                this.name = value;
                OnPropertyChanged("Name");
            }
        }
        public string Value
        {
            get { return this.value; }
            set
            {
                this.value = value;
                OnPropertyChanged("Value");
            }
        }
        public string FullName
        {
            get { return this.fullName; }
            set
            {
                this.fullName = value;
                OnPropertyChanged("FullName");
            }
        }
        public string Calling
        {
            get { return this.calling; }
            set
            {
                this.calling = value;
                OnPropertyChanged("Calling");
            }
        }
        public string Status
        {
            get { return this.status; }
            set
            {
                this.status = value;
                OnPropertyChanged("Status");
            }
        }

        public RunStatusData(string s1, string s2, string s3, string s4, string s5)
        {
            this.Name = s1;
            this.Value = s2;
            this.FullName = s3;
            this.Calling = s4;
            this.Status = s5;
        }

        // Create the OnPropertyChanged method to raise the event
        protected void OnPropertyChanged(string name)
        {
            PropertyChangedEventHandler handler = PropertyChanged;
            if (handler != null)
            {
                handler(this, new PropertyChangedEventArgs(name));
            }
        }
    }

    public class SimOptions
    {
        public string method = "";
        public bool isEigen = false;
        public bool isFix = false;
        public YesNoNull isStatic = YesNoNull.Null;
    }

    public class GekkoDictionary<TKey, TValue> : Dictionary<TKey, TValue>
    {
        public GekkoDictionary()
            : base()
        {
            if (typeof(TKey) == typeof(string))
            {
                //string keys should be called with ignorecase
                G.Writeln2("*** ERROR: Technical error 437834873");
                throw new GekkoException();
            }
        }
        //public GekkoDictionary(int capacity) : base(capacity) { }  //not used
        public GekkoDictionary(IEqualityComparer<TKey> comparer)
            : base(comparer)
        {
            if (typeof(TKey) == typeof(string))
            {
                if (comparer != StringComparer.OrdinalIgnoreCase)
                {
                    //string keys should be called with ignorecase
                    G.Writeln2("*** ERROR: Technical error 437834874");
                    throw new GekkoException();
                }
            }
        }

        //Would be nice to be able override the indexer, but this does not seem possible...
        //Anyway, nice to have a special wrapper for Dictionaries
    }

    public enum EExtrackBankAndRest
    {
        OnlyStrings,
        OnlyStringNoFirstName,
        GetDatabank,
        GetDatabankAndTimeSeries
    }

    public class ExtractBankAndRestHelper
    {
        //public bool simpleNameWithoutAtOrBank = false;
        public string bank;
        public string name;
        public Databank databank;
        public Series ts;
        public bool hasColon = false;
    }
}
