/*
    Gekko Timeseries Software (www.t-t.dk/gekko)..
    Copyright (C) 2021, Thomas Thomsen, T-T Analyse.

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful, 
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program (see the file COPYING in the root folder).
    Else, see <http://www.gnu.org/licenses/>.

*/

using System.Text.RegularExpressions;
using System;
using System.Drawing;
using System.Windows.Forms;
using System.IO;
using System.Text;
using System.Collections.Generic;
using System.Collections;
using System.Globalization;
using System.Windows.Forms;
using System.Threading;
using MathNet.Numerics.LinearAlgebra.Sparse.Linear;
using MathNet.Numerics.LinearAlgebra.Sparse;
using MathNet.Numerics.LinearAlgebra.Sparse.Tests;
using System.Diagnostics;
using System.ComponentModel;
using System.Drawing;
using System.Data;
using Microsoft.CSharp;
using System.CodeDom;
using System.CodeDom.Compiler;
using System.Runtime.Serialization;
using System.Reflection;
using System.Xml;
using System.Xml.Serialization;
using Office = Microsoft.Office.Core;
using Excel = Microsoft.Office.Interop.Excel;
using System.Runtime.InteropServices;
using System.Security.Permissions;
using Microsoft.Win32;
using System.Security.Cryptography;
using System.Reflection.Emit;
using System.Runtime.Serialization.Formatters.Binary;
using ProtoBuf;
using ProtoBuf.Meta;
using System.Diagnostics;
using System.Collections.ObjectModel;
using System.Linq;
using OfficeOpenXml;
using System.Data;
using System.IO.Compression;
//for Parallel.ForEach(...)
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Threading.Tasks;

namespace Gekko
{

    public enum EWrapType
    {
        Writeln,  //normal
        Error,
        Warning,
        Note
    }

    public enum EModelType
    {
        Unknown,           //No MODEL command
        Gekko,             //normal
        GAMSRaw,           //rough translating
        GAMSScalar    //excact scalar model
    }

    public enum EEquationType
    {
        D,
        G,
        K,
        I,
        S,
        RevertedT,  //table variables that are run after simulation (same as RevertedY, but not technical and shown in doc systems)        
        RevertedY,  //technical, typically manual reverted J-factors               
        RevertedP,  //these equations are ignored -- only for use in PREDICT
        RevertedAutoGenerated
    }

    public enum EArrowType
    {
        Ver1_0,
        Ver1_0__with_time_int_and_underscore_name
    }

    public enum EAppend
    {
        Yes,
        No,
        Ifexist
    }

    public enum EVariablesForWrite
    {
        Normal,  //series
        OneNonSeries
    }

    public enum EPrtPlotSheet
    {
        Unknown,
        PrintMixedAQMPretty,
        PrintMixedMDPretty, //if there are days
        PrintMixedWDPretty, //if there are weeks (and maybe days)
        PrintNonmixedUgly,  //also for sheet
        Plot
    }

    /// <summary>
    /// Type of decomp. You may often understand Work/Ref as temporal difference in these banks.
    /// </summary>
    public enum EDecompBanks
    {
        Unknown,
        Work,        //in some contexts this is understood as "TemporalDifferenceWork"
        Ref,         //in some contexts this is understood as "TemporalDifferenceRef"
        Multiplier   //both banks used
    }

    public enum assignmantTypeLhs
    {
        Inactive,
        Active,
        Series,
        Nonseries
    }

    public enum EGekkoArg
    {
        Normal,
        Special
    }

    public enum EGekkoActionTypes
    {
        Unknown,
        Ols
    }

    public enum EDecompFindNavigation
    {
        Decomp,
        Find,
        Unknown
    }

    public class Flood
    {
        public int color = -12345;
        public PeriodAndVariable pv = null; 
        public int eq = -12345;
        public Flood parent = null;
    }

    public class DecompFind
    {        
        public int depth = 0;
        public EDecompFindNavigation type = EDecompFindNavigation.Unknown;
        public DecompOptions2 decompOptions2 = null;
        public DecompOptions2 decompOptions2Previous = null;
        public object window = null;
        public DecompFind parent = null;
        public List<DecompFind> children = new List<DecompFind>();
        public Model model = null;
        public bool closed = false;
        public bool hasException = false;

        public DecompFind(EDecompFindNavigation type, int depth, DecompOptions2 decompOptions2, object window, Model model)
        {
            this.type = type;
            this.depth = depth;
            this.decompOptions2 = decompOptions2;
            this.window = window;  //either WindowDecomp or WindowFind
            this.model = model;
        }

        public DecompFind CreateChild(DecompOptions2 decompOptions2, EDecompFindNavigation type, object window, Model model)
        {
            DecompFind child = new DecompFind(type, this.depth + 1, decompOptions2, window, model);
            child.parent = this;
            this.children.Add(child);
            return child;
        }

        public void SetWindow(object window)
        {
            this.window = window;
        }     

        /// <summary>
        /// Finds parent window by type. May return null.
        /// </summary>
        /// <param name="type"></param>
        /// <returns></returns>
        public DecompFind SearchUpwards(EDecompFindNavigation type)
        {
            DecompFind parent = this.parent;
            if (parent == null) return null;
            while (true)
            {
                if (parent.type == type) return parent;
                parent = parent.parent;
                if (parent == null) return null;
            }
        }        
    }

    public class Count
    {
        public int n = 0;
    }

    public class StringDouble
    {
        public string s = null;
        public double d = double.NaN;
        public StringDouble(string s, double d)
        {
            this.s = s;
            this.d = d;
        }
    }

    public class NonSeriesHelper
    {
        public int depth = 0;
        public int rows = 0;
        public void Message()
        {
            if (this.depth > 0 && this.rows > 20)
            {
                new Note("PRT<view> is convenient for nested lists.");
            }
        }
    }

    public class CountHelper
    {
        public KeyValuePair<string, IVariable> kvp;
        public int n = 0;
    }

    public class CollapseHelper
    {
        public string method = "total";
        public string collapse_missing = null; // corresponds to collapse <strict|flex> = x!m = x!d;        
    }

    /// <summary>
    /// Stores information regarding variable tracing
    /// </summary>
    public class Trace
    {

    }

    /// <summary>
    /// Helper for FindFile(). Note: realPathAndFileName --> the real file that may be an unzipped file put in a temp folder. May be same as prettyPathAndFileName.
    /// Note: prettyPathAndFileName --> the pretty path that may "go through" a zip file. May be same as realPathAndFileName.      
    /// </summary>
    public class FindFileHelper
    {
        public string realPathAndFileName = null;    //the real file
        public string prettyPathAndFileName = null;  //a pretty path 
    }

    /// <summary>
	/// Class emulates long process which runs in worker thread
	/// and makes synchronous user UI operations.
	/// </summary>
	public class LongProcess
    {
        // Main thread sets this event to stop worker thread:
        ManualResetEvent eventStop2;
        // Worker thread sets this event when it is stopped:
        ManualResetEvent eventStopped2;
        // Reference to main form used to make syncronous user interface calls:
        public Gui gekkoGui;

        public LongProcess(ManualResetEvent eventStop, ManualResetEvent eventStopped, Gui form)
        {
            eventStop2 = eventStop;
            eventStopped2 = eventStopped;
            gekkoGui = form;
            Globals.workerThread = this;
        }

        // Function runs in worker thread and emulates long process.
        public void Run(P p)
        {
            Program.RunGekkoCommands(gekkoGui.threadInput, "", 0, p);

            // check if thread is cancelled (do this inside loops in e.g. "sim" etc.)
            if (eventStop2.WaitOne(0, true))
            {
                // clean-up operations may be placed here
                // ...
                // inform main thread that this thread stopped
                eventStopped2.Set();
                return;
            }

            // Make asynchronous call to main form
            // to inform it that thread finished
            //if (!Globals.applicationIsInProcessOfAborting)
            {
                gekkoGui.Invoke(gekkoGui.threadDelegateThreadFinished, null);
            }
        }
    }


    public class ExcelDnaData
    {
        public object[,] cells = null; //when transferring from Gekko databank to current sheet
        public TableLight tableLight = null; //when transferring from current sheet to Gekko databank
    }

    /// <summary>
    /// A class that contains info on combinations regarding controlled sets. For instance, sum(i, x[i] + sum(j, y[i, j]))
    /// runs over combinations of i and j (in that case, .names would be "i" and "j" when inside the innermost sum(...)).
    /// </summary>
    public class Controlled
    {
        public List<string> names = new List<string>();
        public List<string> elements = new List<string>();

        public int Count()
        {
            return names.Count;
        }

        public Controlled Clone()
        {
            Controlled clone = new Controlled();
            clone.names = new List<string>();
            clone.elements = new List<string>();
            clone.names.AddRange(this.names);
            clone.elements.AddRange(this.elements);
            return clone;
        }
    }

    public class Conditions
    {
        public List<Condition> conditions = new List<Condition>();
    }

    public enum EConditionType
    {
        None,
        Set,  //special
        SmallerThan,
        SmallerThanOrEqual,
        Equal,
        NonEqual,
        LargerThanOrEqual,
        LargerThan
    }

    public class Condition
    {
        public bool invert = false;
        public string setOrVarname = null;
        public IVariable setOrVarObject = null;
        public List<string> indexes = new List<string>();
        public double xDouble = double.NaN;
        public string xString = null;
        public EConditionType conditionType = EConditionType.None;
    }

    public class WalkTokensHelper
    {
        public string t = "t";
        public string tBase = "tBase";
        public bool checkIfVariableIsASet = false;
        public bool replaceSuitableIntInLastPositionWithFixedYear = false;
        public GekkoDictionary<string, List<int>> lagsLeads = new GekkoDictionary<string, List<int>>(StringComparer.OrdinalIgnoreCase);
    }

    /// <summary>
    /// Used for links, if the links need to transfer some information (like a string).
    /// </summary>
    public class GAO
    {
        public string s1 = null;
    }

    /// <summary>
    /// Used for links that do stuff.
    /// </summary>
    public class GekkoAction
    {
        public GAO gao = null;
        public Action<GAO> action = null;
        public EGekkoActionTypes type = EGekkoActionTypes.Unknown;
        public string name = null;  //for instance the OLS name given, so that for type == ols, we can expire links with a certain name. If name = null, the link will always expire.

        public GekkoAction(EGekkoActionTypes type, string name, Action<GAO> action, GAO gao)
        {
            this.type = type;  //can be .Unknown
            this.name = name;  //can be null, used for OLS link expiry
            this.action = action;
            this.gao = gao;    //can be null, used if we need to call an Action with arguments.
        }

        public GekkoAction(EGekkoActionTypes type, string name, Action<GAO> action)
        {
            this.type = type;  //can be .Unknown
            this.name = name;  //can be null, used for OLS link expiry
            this.action = action;
            this.gao = null;
        }
    }

    public class LinkAction
    {
        public int start = -12345;
        public int end = -12345;
        public string chop1 = null;
        public string chop2 = null;
        public string chop3 = null;
        public string[] ss2 = null;
    }

    public class PlotTable
    {
        public List<List<double>> dates = null;
        public List<List<double>> values = null;
    }

    public class OLSRekurInfo
    {
        public string type = null;  // 'r' (right), 'l' (left), 'e' (elevator)
        public bool chow = true;
        public bool grahphs = true;
        public int df_min = 1;  //can be larger
    }

    public class OLSRekurDatas
    {
        public List<OLSRekurData> datas = new List<OLSRekurData>();
        public OLSRekurData data = null;

        public OLSRekurDatas(int m, int n)
        {
            for (int i = 0; i < m; i++)
            {
                this.datas.Add(new OLSRekurData(n));
            }

            this.data = new OLSRekurData(n);
        }
    }


    public class GekkoError
    {
        public int t1Problem = 0; //always 0 or positive
        public int t2Problem = 0; //always 0 or positive

        public GekkoError(int t1Problem, int t2Problem)
        {
            G.WritelnGray("*** ERROR: TooSmallTooLarge: " + t1Problem + " " + t2Problem);

            using (Error e = new Error())
            {
                e.MainAdd("Unfortunately, you ran into a lag problem in Gekko 3.0.");
                e.MainAdd("This typically arises in expressions like x1[-1] + x2, where timeseries with lags are");
                e.MainAdd("involved. You may try to use an intermediate variable which will often provide a work-around");
                e.MainAdd("for the problem, for instance defining y = x1[-1] + x2, and then use y instead of the ");
                e.MainAdd("expression. For more on this problem, see this page: https://t-t.dk/gekko/the-lag-problem");
            }

            this.t1Problem = t1Problem;
            this.t2Problem = t2Problem;
        }
    }

    public class OLSRekurData
    {
        public double[] coeff = null;
        public double[] coeff_low = null;
        public double[] coeff_high = null;
        public OLSRekurData(int n)
        {
            this.coeff = new double[n];
            this.coeff_low = new double[n];
            this.coeff_high = new double[n];
        }
    }

    public class OLSResults
    {
        public double[] beta, ypredict, residual, coeff, se, t;
        public double rss, resMean, lhsMean, ssTot, dw, rmse, see, r2, r2cor;
        public double[,] usedCovar, usedCorr;
    }

    public class CellOffset
    {
        public string cell = null;
        public string datecell = null;
        public string namecell = null;
    }

    public class CGSolverOutput
    {
        public int iterations = -12345;
        public double f = double.NaN;
        public double[] x = null;
        public int evals = 0;
    }

    public class GMRESSolverOutput
    {
        public int iterations = -12345;
        public double f = double.NaN;
        public DenseVector x = null;
        public int evals = 0;
    }

    public class GMRESSolverInput
    {
        public double krit = Program.options.solve_newton_conv_abs * Program.options.solve_newton_conv_abs;  //0.0001^2 <=> no residual can be > 0.0001, for in that case RSS would be > krit = 0.0001^2        
        public double delta = Globals.jacobiDeltaProbe;
        // -------------
        public int evals = 0;  //!!!!!!! do not change
    }

    public class CGSolverInput
    {
        public double deltaGradient = 1e-8;
        public double deltaGolden = 1e-8;
        public double krit = Program.options.solve_newton_conv_abs * Program.options.solve_newton_conv_abs;  //0.0001^2 <=> no residual can be > 0.0001, for in that case RSS would be > krit = 0.0001^2
        public bool limitBeta = false;  //does not have any effect on the unit tests (until now)
        public int restartInterval = -12345; //if -12345 --> will use n, setting to 1 --> basic steepest gradient, setting to n is normal conjugate gradient
        // -------------
        public int evals = 0;  //!!!!!!! do not change
    }

    public class GekkoArg
    {
        public Func<GekkoSmpl, IVariable> f1 = null;
        public Func<GekkoSmpl, IVariable> f2 = null;
        public EGekkoArg type = EGekkoArg.Normal;  //Special: inside <...>        

        public GekkoArg(Func<GekkoSmpl, IVariable> f1, Func<GekkoSmpl, IVariable> f2)
        {
            this.f1 = f1; //original, for instance f('y')
            this.f2 = f2; //alternative code, used for name type, for instance f(y), where y is treated like 'y'
            this.type = EGekkoArg.Normal;
        }
        public GekkoArg(Func<GekkoSmpl, IVariable> f1, Func<GekkoSmpl, IVariable> f2, EGekkoArg type)
        {
            this.f1 = f1; //original, for instance f('y')
            this.f2 = f2; //alternative code, used for name type, for instance f(y), where y is treated like 'y'
            this.type = type;
        }
    }

    public class GekkoTimes
    {
        public GekkoTime t1;
        public GekkoTime t2;
    }

    public class SamHelper
    {
        public Series series1;
        public Series series2;
    }

    public class DecompHelper3
    {
        public Series[] vars = new Series[1];
    }

    public class DecompDict
    {
        public GekkoDictionary<string, Series> storage = new GekkoDictionary<string, Series>(StringComparer.OrdinalIgnoreCase);


        /// <summary>
        /// Queries DecompDict. If series not there, it is created.
        /// </summary>
        /// <param name="s"></param>
        /// <returns></returns>
        public Series this[string s]
        {
            get
            {
                Series ts = null; storage.TryGetValue(s, out ts);
                if (ts == null)
                {                    
                    ts = new Series(Program.options.freq, G.Chop_AddFreq("decomptemp", G.ConvertFreq(Program.options.freq)));
                    storage.Add(s, ts);
                }
                return ts;
            }
        }

        /// <summary>
        /// Adds a series to the DecompDict.
        /// </summary>
        /// <param name="s"></param>
        /// <param name="ts"></param>
        public void Add(string s, Series ts)
        {
            this.storage.Add(s, ts);
        }

        public bool Remove(string s)
        {
            return storage.Remove(s);
        }

        public bool ContainsKey(string s)
        {
            return storage.ContainsKey(s);
        }

        public DecompDict DeepClone()
        {
            DecompDict dd = new DecompDict();
            foreach (KeyValuePair<string, Series> kvp in this.storage)
            {
                dd.storage.Add(kvp.Key, kvp.Value.DeepClone(null) as Series);
            }
            return dd;
        }
    }

    public class MyCustomAttribute : Attribute
    {
        public string Lag { get; set; }
    }

    public class GekkoSmplSimple
    {
        //public bool allObservations = false;
        public GekkoTime t1 = GekkoTime.tNull;
        public GekkoTime t2 = GekkoTime.tNull;
        public GekkoSmplSimple(GekkoTime t1, GekkoTime t2)
        {
            this.t1 = t1;
            this.t2 = t2;
        }
    }

    public class GekkoSmpl2
    {
        public GekkoTime t0 = GekkoTime.tNull;
        public GekkoTime t3 = GekkoTime.tNull;
    }

    public class GekkoSmpl
    {
        public GekkoTime t0 = GekkoTime.tNull;  //start of the period for which the expressions are calculated (<= t1)
        public GekkoTime t1 = GekkoTime.tNull;  //start of real sample, should normally not be lagged (then sumt() etc. will be wrong)
        public GekkoTime t2 = GekkoTime.tNull;  //end of real sample, should normally not be leaded (then sumt() etc. will be wrong)
        public GekkoTime t3 = GekkoTime.tNull;  //end of the period for which the expressions are calculated (>= t2)         
        public int bankNumber = 0;  //0 is inactive, 1 is Ref databank, will only apply to series (vars without sigils)
        public GekkoSmplCommand command = GekkoSmplCommand.Unknown;
        public List<O.RecordedPieces> labelRecordedPieces = new List<O.RecordedPieces>();
        public assignmantTypeLhs lhsAssignmentType = assignmantTypeLhs.Inactive;
        public GekkoError gekkoError = null; //only set to something, if the sample .t0 to .t3 is too tight 
        public P p = null;

        public GekkoSmpl()
        {

        }

        public GekkoSmpl(GekkoTime t1, GekkoTime t2)
        {
            //FIXME
            //FIXME
            //FIXME
            //FIXME
            //FIXME
            this.t0 = t1;
            this.t1 = t1;
            this.t2 = t2;
            this.t3 = t2;
        }

        public bool HasError()
        {
            return this.gekkoError != null;
        }

        public GekkoTimeIterator Iterate03()
        {
            return new GekkoTimeIterator(this.t0, this.t3);
        }

        public GekkoTimeIterator Iterate12()
        {
            return new GekkoTimeIterator(this.t1, this.t2);
        }

        public GekkoTimeIterator Iterate12(EFreq convertToThisFreq)
        {
            return new GekkoTimeIterator(convertToThisFreq, this.t1, this.t2);
        }

        public static GekkoSmpl Global()
        {
            GekkoSmpl smpl = new GekkoSmpl(Globals.globalPeriodStart, Globals.globalPeriodEnd);
            return smpl;
        }

        public int Observations03()
        {
            return GekkoTime.Observations(this.t0, this.t3);
        }

        public int Observations12()
        {
            return GekkoTime.Observations(this.t1, this.t2);
        }

    }

    public class GekkoList<T>
    {
        private List<T> container = new List<T>();

        public static GekkoList<T> Construct()
        {
            return new GekkoList<T>();
        }
        public GekkoList()
        {
            //default constructor
        }

        public GekkoList(T s)
        {
            this.container.Add(s);
        }

        public GekkoList(GekkoList<T> x)
        {
            this.container.AddRange(x.container);
        }

        public GekkoList(List<T> x)
        {
            this.container.AddRange(x);
        }

        public GekkoList<T> AddRange(GekkoList<T> x)
        {
            this.container.AddRange(x.container);
            return this;
        }

        public GekkoList<T> AddRange(List<T> x)
        {
            this.container.AddRange(x);
            return this;
        }

        public GekkoList<T> Add(T x)
        {
            this.container.Add(x);
            return this;
        }
    }

    public class DateTimeHelper
    {
        public DateTime dt;
        public string s;
        public long size;
    }

    public class BankNameVersion
    {
        public string bank = null;
        public string name = null;
        public string freq = null;
    }

    public class WorkBookHelper
    {
        public static void WorkBookSetData_1(string stamp, ExcelWorksheet ws, int rowcounter, int colcounter)
        {
            //See #087923584975: Strange null setting, but otherwise formulas are kept, including na() values
            ws.Cells[rowcounter, colcounter].Formula = null;
            ws.Cells[rowcounter, colcounter].Value = stamp;
        }

        public static void WorkBookSetData_2(string heading, ExcelWorksheet ws, int rowcounter, int colcounter)
        {
            //See #087923584975: Strange null setting, but otherwise formulas are kept, including na() values
            ws.Cells[rowcounter, colcounter].Formula = null;
            ws.Cells[rowcounter, colcounter].Value = heading;
        }

        //This is the data matrix
        public static void WorkBookSetData_3(ExcelWorksheet ws, double[,] data, int d1, int d2)
        {
            //See #087923584975: Strange null setting, but otherwise formulas are kept, including na() values
            ws.Cells[d1, d2, d1 + data.GetLength(0) - 1, d2 + data.GetLength(1) - 1].Formula = null;
            ws.Cells[d1, d2, d1 + data.GetLength(0) - 1, d2 + data.GetLength(1) - 1].LoadFromArrays(Program.ToJaggedArray(data));
        }

        public static void WorkBookSetData_4(ExcelWorksheet ws, int i, int j, DateTime dt, string f)
        {
            //See #087923584975: Strange null setting, but otherwise formulas are kept, including na() values
            ws.Cells[i, j].Formula = null;
            ws.SetValue(i, j, dt);
            ws.Cells[i, j].Style.Numberformat.Format = f;
        }

        public static void WorkBookSetData_5(ExcelWorksheet ws, int i, int j, DateTime dt, string f)
        {
            //See #087923584975: Strange null setting, but otherwise formulas are kept, including na() values
            ws.Cells[i, j].Formula = null;
            ws.SetValue(i, j, dt);
            ws.Cells[i, j].Style.Numberformat.Format = f;
        }

        public static void WorkBookSetData_6(ExcelWorksheet ws, int d1, int d2, object[][] datesData)
        {
            //See #087923584975: Strange null setting, but otherwise formulas are kept, including na() values
            ws.Cells[d1, d2 - 1, d1 + datesData.Length - 1, d2 - 1 + datesData[0].Length - 1].Formula = null;
            ws.Cells[d1, d2 - 1, d1 + datesData.Length - 1, d2 - 1 + datesData[0].Length - 1].LoadFromArrays(datesData);
        }

        public static void WorkBookSetData_7(ExcelWorksheet ws, int d1, int d2, object[][] datesData)
        {
            //See #087923584975: Strange null setting, but otherwise formulas are kept, including na() values
            ws.Cells[d1 - 1, d2, d1 - 1 + datesData.Length - 1, d2 + datesData[0].Length - 1].Formula = null;
            ws.Cells[d1 - 1, d2, d1 - 1 + datesData.Length - 1, d2 + datesData[0].Length - 1].LoadFromArrays(datesData);
        }

        public static void WorkBookSetData_8(ExcelWorksheet ws, int d1, int d2, string[,] labels)
        {
            //See #087923584975: Strange null setting, but otherwise formulas are kept, including na() values
            ws.Cells[d1 - 1, d2, d1 - 1 + labels.GetLength(0) - 1, d2 + labels.GetLength(1) - 1].Formula = null;
            ws.Cells[d1 - 1, d2, d1 - 1 + labels.GetLength(0) - 1, d2 + labels.GetLength(1) - 1].LoadFromArrays(Program.ToJaggedArray(labels));
        }

        public static void WorkBookSetData_9(ExcelWorksheet ws, int d1, int d2, string[,] labels)
        {
            //See #087923584975: Strange null setting, but otherwise formulas are kept, including na() values
            ws.Cells[d1, d2 - 1, d1 + labels.GetLength(0) - 1, d2 - 1 + labels.GetLength(1) - 1].Formula = null;
            ws.Cells[d1, d2 - 1, d1 + labels.GetLength(0) - 1, d2 - 1 + labels.GetLength(1) - 1].LoadFromArrays(Program.ToJaggedArray(labels));
        }
    }

    public class Zipper
    {
        //this zipper should make sure temp folder always gets deleted, also in case of exceptions etc.
        //alternatively: have Gekko delete all gekkotempfilesxxxxx at program start.

        public string tempFolder = null;
        public string zipFileAndFolder = null;  //may omit path, then it will land in working folder

        public Zipper(string zipFileName)
        {
            this.tempFolder = Globals.localTempFilesLocation + "\\" + "gekkotempfiles_" + Program.RandomInt(11111111, 99999999);
            if (Directory.Exists(this.tempFolder))
            {
                G.DeleteFolder(this.tempFolder, true);
            }
            Directory.CreateDirectory(this.tempFolder);
            this.zipFileAndFolder = Program.CreateFullPathAndFileName(zipFileName);
        }

        public void ZipAndCleanup()
        {
            Program.WaitForZipWrite(this.tempFolder, this.zipFileAndFolder);
            G.DeleteFolder(this.tempFolder, true);
        }
    }

    public enum ECollapseMethod
    {
        Total,
        Avg,
        First,
        Last,
        Count
    }

    public enum EPrintTypes
    {
        Print,
        Plot,
        Sheet,
        Clip
    }

    public enum EWildcardSearchType
    {
        Copy,
        Delete,
        Rename,
        Write,
        Search
    }

    public enum GekkoSmplCommand
    {
        Unfold,
        Sum,
        Unknown
    }

    public enum EDatabankWriteType
    {
        Tsdx,
        Flat,
        Gbk,
        Gdx,
        Gnuplot,
        Tsd,
        Prn,
        Xlsx,
        Xls,
        Csv,
        R,
        Gcm,
        Tsp,
        Python,
        Arrow
    }

    public enum EPrtCollapseTypes
    {
        Avg,
        Total,
        None
    }

    public enum EReadInfoTypes
    {
        Normal,
        NonExistingGbkFileOpened,
        //OpenedFirstOrRefAlreadyOpenBank
    }

    public enum EdataFormat
    {
        Csv,
        Prn
        //Gnuplot
    }

    public enum ESeriesUpdTypes
    {
        none,
        d,
        p,
        m,
        q,
        mp,
        dl,  //dlog()
        l,   //log()
        n
    }

    //See #98745239543
    public enum YesNoNull
    {
        Yes,
        No,
        Null
    }

    public enum ESmoothTypes
    {
        Spline,
        Linear,
        Geometric,
        Repeat,
        Overlay
    }

    public enum EOperatorTypes
    {
        ShortVersion,
        LongVersionHasYes,
        LongVersionHasAppend,
        LongVersionOnlyNo,
        Verbose,
        None,
        Null
    }

    public enum ESignatureStatus
    {
        Ok,
        SignatureNotFoundInModelFile,
        SignaturesDoNotMatch
    }

    public enum ETerminalCondition
    {
        Exogenous,
        ConstantLevel,
        ConstantGrowthRate
    }

    public enum EMissingType
    {
        Ok,
        //HasMissingData,  //NaN, M in tables
        HasMissingVariables  //MV in tables
    }

    public enum StampTypes
    {
        Normal,
        Base,
        Multiplier
    }

    public enum EEndoOrExo
    {
        Endo,
        Exo,
        Unknown
    }

    public enum ETabs
    {
        Main,
        Output,
        Menu
    }

    public enum ECompiledModelType  //corresponds to Model.cs --> public Type assemblyGauss etc.
    {
        Gauss,
        GaussFailSafe,
        Res,  //single equation forecast
        Newton,
        After,
        //Eigen,  //for eigenvalue analysis
        Unknown
    }

    public class UndoSim
    {
        public long id = 0L;
        public double[,] a = null;
        public GekkoTime tStart0;
        public GekkoTime tStart;
        public GekkoTime tEnd;
        public int obsWithLags;
        public int obsSimPeriod;
    }

    public class PackSim
    {
        public long id = 0L;
        public double[,] a = null;
        public GekkoTime tStart0;
        public GekkoTime tStart;
        public GekkoTime tEnd;
        public int obsWithLags;
        public int obsSimPeriod;
    }

    public class DatabankTimeseriesNotFoundException : Exception
    {
        //only used for 1 thing
        public DatabankTimeseriesNotFoundException()
        {
        }
    }

    public class GekkoException : System.Exception
    {
        public List<Wrap> wraps = new List<Wrap>();

        public GekkoException() { }
        public GekkoException(string s) : base(s) { }
        public GekkoException(Wrap wrap)
        {
            this.wraps.Add(wrap);
        }

    }

    /// <summary>
    /// A storage implementation where the key "example7" and the key "ExAmpLe7" are treated as equal.
    /// Used to contain variables in a model. Such variable names are not case-sensitive.
    /// </summary>
    ///
    [Serializable]
    public class CaseInsensitiveHashtable : Hashtable
    {

        public CaseInsensitiveHashtable(SerializationInfo info, StreamingContext context)
            : base(info, context)
        {
        }

        /// <summary>
        /// Constructor
        /// </summary>
        public CaseInsensitiveHashtable()
            : base()
        {
            this.hcp = new CaseInsensitiveHashCodeProvider();
            this.comparer = new CaseInsensitiveComparer();
        }
        /// <summary>
        /// Constructor
        /// </summary>
        /// <param name="capacity"></param>
        public CaseInsensitiveHashtable(int capacity)
            : base(capacity)
        {
            this.hcp = new CaseInsensitiveHashCodeProvider();
            this.comparer = new CaseInsensitiveComparer();
        }
    }

    public class OptString
    {
        public string s1;
        public string s2;
        public OptString(string s1, string s2)
        {
            this.s1 = s1;
            this.s2 = s2;
        }
    }

    public class OptVal
    {
        public string s;
        public double val;
        public OptVal(string s, double val)
        {
            this.s = s;
            this.val = val;
        }
    }

    public class OptDate
    {
        public string s;
        public GekkoTime date;
        public OptDate(string s, GekkoTime date)
        {
            this.s = s;
            this.date = date;
        }
    }

    public class SearchOptions
    {
        public bool ignoreErrors = false;
    }

    public class ToFrom
    {
        public string s1 = null;
        public string s2 = null;
        public bool b1Explicit = false;
        public ToFrom(string s1, string s2, bool b1Explicit)
        {
            this.s1 = s1;
            this.s2 = s2;
            this.b1Explicit = b1Explicit;
        }
    }

    public class EqHelper
    {
        public string eqName = null;
        public string eqNameWithLag = null;
        public int eqNumber = -12345;
        public bool best = false;
    }

    public class Rich
    {
        private List<StringAndColor> storage = new List<StringAndColor>();

        /// <summary>
        /// Make the object, and afterwards use .Add etc.
        /// </summary>
        public Rich() { }        

        /// <summary>
        /// Add new black block.
        /// </summary>
        /// <param name="s"></param>
        public void Add(string s)
        {
            Add(s, System.Windows.Media.Colors.Black);
        }

        /// <summary>
        /// Add something that does not persist. Returns new cloned + augmented object.
        /// </summary>
        /// <param name="s"></param>
        public Rich AddTemporarily(string s)
        {
            Rich r = this.Clone();
            r.Add(s);
            return r;            
        }

        /// <summary>
        /// Add new colored block.
        /// </summary>
        /// <param name="s"></param>
        /// <param name="color"></param>
        public void Add(string s, System.Windows.Media.Color color)
        {
            this.storage.Add(new StringAndColor(s, color));
        }

        /// <summary>
        /// Get internal object.
        /// </summary>
        /// <returns></returns>
        public List<StringAndColor> Get()
        {
            return this.storage;
        }

        /// <summary>
        /// Cloned copy.
        /// </summary>
        /// <returns></returns>
        public Rich Clone()
        {
            Rich r = new Rich();
            r.storage = new List<StringAndColor>();
            r.storage.AddRange(this.storage);
            return r;
        }

        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            foreach (StringAndColor sac in this.storage)
            {
                sb.Append(sac.s);
            }
            return sb.ToString();
        }
    }

    /// <summary>
    /// Used in RichTextBox
    /// </summary>
    public class StringAndColor
    {
        public string s = null;
        public System.Windows.Media.Color color = System.Windows.Media.Colors.Black;
        public StringAndColor(string s, System.Windows.Media.Color color)
        {
            this.s = s;
            this.color = color;
        }
    }

    // <summary>
    // Simple helper class
    // </summary>
    public class TwoStrings
    {
        public string s1 = null;
        public string s2 = null;
        public string s2Type = null;
        public TwoStrings(string s1, string s2)
        {
            this.s1 = s1;
            this.s2 = s2;
        }
        public TwoStrings(string s1, string s2, bool noblanks)
        {
            if (noblanks)
            {
                this.s1 = s1.Replace(" ", "");
                this.s2 = s2.Replace(" ", "");
            }
            else
            {
                this.s1 = s1;
                this.s2 = s2;
            }
        }
    }

    public class StackHelper
    {
        public string line;  //has a lot of text added
        public string file;
        public int line2;  //as a simple int
    }



    /// <summary>
    /// Simple helper class
    /// </summary>
    public class CompilerOptions
    {
        public bool gauss;
        public bool jacobi;
        public bool newtonNonFeedBack;
        public bool newton;
        public bool gaussFailSafe;
        public long compilerOptionsHash;
    }

    /// <summary>
    /// Helper class
    /// </summary>
    ///
    [Serializable]
    [ProtoContract]
    public class EquationHelper
    {
        [ProtoMember(1)]
        public string lhsWithLagIndicator;  //left hand side with lag indicator (e.g. "fy¤-1").
        [ProtoMember(2)]
        public string lhs;
        [ProtoMember(3)]
        public GekkoDictionary<string, string> precedentsWithLagIndicator = new GekkoDictionary<string, string>(StringComparer.OrdinalIgnoreCase);
        [ProtoMember(5)]
        public int equationNumber = -12345;
        [ProtoMember(6)]
        public string equationText = "";
        [ProtoMember(7)]
        public double typicalVariance = double.NaN;
        [ProtoMember(8)]
        public string equationCode = "";
        [ProtoMember(9)]
        public string csCodeRhs = "";
        [ProtoMember(10)]
        public string csCodeRhsLongVersion = "";
        [ProtoMember(11)]
        public string codeRhsHumanVersion = "";
        [ProtoMember(12)]
        public string csCodeLhsGauss = "";
        [ProtoMember(13)]
        public string csCodeLhsJacobi = "";
        [ProtoMember(14)]
        public string codeLhsHumanVersion = "";
        [ProtoMember(15)]
        public int bNumberLhs = -12345;
        [ProtoMember(16)]
        public string equationCodeJ = "";
        [ProtoMember(17)]
        public string equationCodeD = "";
        [ProtoMember(18)]
        public string equationCodeZ = "";
        [ProtoMember(19)]
        public bool equationCodeJadditive = false;
        [ProtoMember(20)]
        public bool equationCodeJmultiplicative = false;
        [ProtoMember(21)]
        public EEquationType equationType;
        [ProtoMember(22)]
        public string Jname = "";
        [ProtoMember(23)]
        public string Dname = "";
        [ProtoMember(24)]
        public string Zname = "";
        //[ProtoMember()] !!!!!!!! ignore this!
        public Gekko.Parser.ASTNodeSimple equationsNodeRoot = null;
        [ProtoMember(25)]
        public bool isAfterModel = false;  //if equation is after 
        [ProtoMember(26)]
        public bool isAfter2Model = false; //if equation is after AFTER2$ Here, both isAfterModel and isAfter2Model are true at same time
        [ProtoMember(27)]
        public string modelBlock = "";
        [ProtoMember(28)]
        public int largestLag = 0; //always 0 or positive        
        [ProtoMember(29)]
        public int largestLead = 0; //always 0 or positive   

        [ProtoMember(30)]
        public string scalar_csCodeLhs = "";
        [ProtoMember(31)]
        public string scalar_csCodeRhs = "";

        public List<Func<GekkoSmpl, IVariable>> expressions = null; //do not protobuf this
        public Action<string, GekkoTime> predictAction = null; //do not protobuf this

    }

    /// <summary>
    /// Helper class
    /// </summary>
    public class UserFunctionsHelper
    {
        public ArrayList arguments;
        public List<string> rhs;
        public List<string> rhsType;
    }

    /// <summary>
    /// Used in getSpecialDay() function
    /// </summary>
    public class HolidayNames
    {
        public EHolidayName name = EHolidayName.Null;
        public string en = null;
        public string da = null;
        public HolidayNames(EHolidayName name, string eng, string dan)
        {
            this.name = name;
            this.en = eng;
            this.da = dan;
        }
    }

    public class WeekDayNames
    {
        public int number = 1;  //default: monday, but default not used anyway...
        public string en = null;
        public string da = null;
        public WeekDayNames(int number, string eng, string dan)
        {
            this.number = number;
            this.en = eng;
            this.da = dan;
        }
    }

    /// <summary>
    /// Helper class
    /// </summary>
    public class UserFunctionsHelper1
    {
        public List<string> al;
        public List<string> alType;
    }


    /// <summary>
    /// Helper class
    /// </summary>
    public class ReadFrmHelper
    {
        public bool fatalErrorRegardingModelFrmls = false;
    }

    /// <summary>
    /// Simple helper class
    /// </summary>
    public class BnkReader
    {
        public int lastRecordRead;
        public String varName;
        public int startPeriod;
        public int endPeriod;
    }

    /// <summary>
    /// Simple helper class
    /// </summary>
    public class ThreeStrings
    {
        public String s1;
        public String s2;
        public String s3;
    }

    /// <summary>
    /// Simple helper class
    /// </summary>
    ///
    [Serializable]
    [ProtoContract]
    public class BTypeData
    {
        [ProtoMember(1)]
        public string variable;
        [ProtoMember(2)]
        public int bNumber;
        [ProtoMember(3)]
        public int aNumber;
        [ProtoMember(4)]
        public int lag;
        //public ArrayList equations;
        [ProtoMember(5)]
        public int leftHandSideEquation;
    }

    /// <summary>
    /// Simple helper class
    /// </summary>
    ///
    [Serializable]
    [ProtoContract]
    public class ATypeData
    {
        [ProtoMember(1)]
        public string varName;
        [ProtoMember(2)]
        public int aNumber;
    }


    /// <summary>
    /// Simple helper class
    /// </summary>
    public class FourInts
    {
        public int start1;
        public int end1;
        public int start2;
        public int end2;

    }

    public class SingletonHelper
    {
        public int line;
        public string s = null;
    }

    /// <summary>
    /// Simple helper class
    /// </summary>
    public class TwoInts
    {
        public int int1;
        public int int2;

        public TwoInts(int int1, int int2)
        {
            this.int1 = int1;
            this.int2 = int2;
        }
    }

    public class NewtonFairTaylorHelper
    {
        public List<NewtonFairTaylorHelper1> shocks = null;
        public double[,] jacobi = null;
    }

    public class NewtonFairTaylorHelper1
    {
        public bool isFirstBaseline = false;
        public GekkoTime gt;
        public int varNumber;
        public int varCounter;
    }

    /// <summary>
    /// Simple helper class
    /// </summary>
    public class TranslateVarData
    {
        public int w;
        public int s;
        public int sForA;
    }


    /// <summary>
    /// A large class containing a "mixed bag" of all sorts of code.
    /// </summary>
    public static class Program
    {
        /// <summary>
        /// Container for all user options
        /// </summary>
        public static Options options = new Options();

        /// <summary>
        /// User-defined functions/procedures.
        /// </summary>
        public static Libraries libraries = null;  //is initialized somewhere else, no need to do it here.

        /// <summary>
        /// Helper for name aliases
        /// </summary>
        public static GekkoDictionary<string, string> alias = null;

        /// <summary>
        /// Container for all the stuff related to the current model
        /// </summary>
        public static Model model = new Gekko.Model();

        //these should be cleared with closeall
        /// <summary>
        /// Contains names of the open databanks. Not case-sensitive. The name of any bank points to a
        /// storage with variable names. Which again points to a double[] array with data for each period.
        /// </summary>
        public static Databanks databanks = new Databanks();

        /// <summary>
        /// Storage of Gekko tables.
        /// </summary>
        public static Dictionary<string, Table> tables = new Dictionary<string, Table>(StringComparer.OrdinalIgnoreCase);

        ///// <summary>
        ///// The Gekko variable list for models.
        ///// </summary>
        //public static List<Item> unfoldedVariableList = null;  //the unfolded variable list

        /// <summary>
        /// Helper for the GUI browser (DISP command)
        /// </summary>
        public static int guiBrowseNumber = 0;

        /// <summary>
        /// Helper for the GUI browser (DISP command)
        /// </summary>
        public static List<string> guiBrowseHistory = new List<string>();

        public enum eOfficeVersion
        {
            eOfficeVersion_Unrecognized, // error return value
            eOfficeVersion_95,
            eOfficeVersion_97,
            eOfficeVersion_2000,
            eOfficeVersion_XP,   // XP = 2002 + marketing
            eOfficeVersion_2003,
            eOfficeVersion_2007,
            eOfficeVersion_2010,
            eOfficeVersion_2013,
            eOfficeVersion_2016,
            eOfficeVersion_2019  //???
        };

        public enum GekkoFileReadOrWrite
        {
            Read,
            Write,
            WriteAppend
        };

        public enum eOfficeApp // in case you are looking for a particular app
        {
            eOfficeApp_Word,
            eOfficeApp_Excel,
            eOfficeApp_Outlook,
            eOfficeApp_Access,
            eOfficeApp_PowerPoint,
        };


        /// <summary>
        /// Random number
        /// </summary>
        /// <param name="min"></param>
        /// <param name="max"></param>
        /// <returns></returns>
        public static int RandomInt(int min, int max)
        {
            lock (Globals.randomSyncLock)
            {
                return Globals.random777.Next(min, max);
            }
        }

        /// <summary>
        /// Overload
        /// </summary>
        /// <returns></returns>
        public static int RandomInt()
        {
            lock (Globals.randomSyncLock)
            {
                return Globals.random777.Next();
            }
        }

        /// <summary>
        /// Random number
        /// </summary>
        /// <returns></returns>
        public static double RandomDouble()
        {
            lock (Globals.randomSyncLock)
            {
                return Globals.random777.NextDouble();
            }
        }

        /// <summary>
        /// Helper for threads and exceptions
        /// </summary>
        /// <param name="e2"></param>
        /// <param name="p"></param>
        public static void PrintExceptionAndFinishThread(Exception e2, P p)
        {
            if (!Globals.threadIsInProcessOfAborting && !(p.hasSeenStopCommand > 0))  //STOP should not show errors
            {

                string eType = e2.GetType().Name;

                if (FindException(e2, "lexer error"))
                {
                    Parser.ParseHelper ph = new Parser.ParseHelper();
                    string s2 = p.GetStackCommandFileText(p.GetDepth());
                    string s3 = "";
                    if (s2 != null) s3 = s2;
                    Gekko.Parser.Frm.ParserFrmCreateAST.HandleModelParserErrors(Stringlist.CreateListOfStringsFromFile(e2.Message), Stringlist.CreateListOfStringsFromFile(s3), ph);
                }
                if (FindException(e2, "***") || FindException(e2, "+++"))
                {
                    G.Writeln("    " + e2.Message);
                }
                string ramProblem = "";
                if (FindException(e2, "System.OutOfMemoryException"))
                {
                    new Error("Out of memory (RAM). Please close some unnessecary programs if possible.", false);
                    Process[] processlist = Process.GetProcesses();
                    int counter = 0;
                    foreach (Process theprocess in processlist)
                    {
                        counter++;
                        ramProblem += "#" + counter;
                        try
                        {
                            ramProblem += " name:" + theprocess.ProcessName;
                        }
                        catch { };
                        try
                        {
                            ramProblem += " id:" + theprocess.Id;
                        }
                        catch { };
                        try
                        {
                            ramProblem += " ram:" + theprocess.WorkingSet64 / 1024;
                        }
                        catch { };
                        try
                        {
                            ramProblem += " maxram:" + theprocess.PeakWorkingSet64 / 1024;
                        }
                        catch { };
                        try
                        {
                            ramProblem += " created:" + theprocess.StartTime.ToString().Replace(" ", "_");
                        }
                        catch { };
                        ramProblem += G.NL;
                    }
                }

                if (FindException(e2, "GekkoException"))
                {
                    G.Write("*** ERROR: The command failed");
                }
                else
                {
                    G.Write("*** ERROR: The command failed due to internal Gekko error");
                }
                string s = "";

                if (ramProblem != "")
                {
                    s += "NOTE: Since this is a RAM problem, the error report contains information on the active processes";
                    s += "running on the computer. If you do not wish this information to be contained in the error report,";
                    s += "please delete the section below 'The following is a list of active processes' before sending";
                    s += "the report to the Gekko editor (active processes are usually not sensitive information, and";
                    s += "no content of these processes is used (only their RAM usage etc.)" + G.NL + G.NL;
                    s += e2.ToString() + G.NL;
                    s += G.NL + "The following is a list of active processes:" + G.NL + ramProblem;
                }
                else
                {
                    s += G.NL + e2.ToString();
                }

                if (Globals.errorMemory != null)
                {
                    s += G.NL + G.NL + "---------------------------------------------------------------------" + G.NL;
                    List<string> xx = Stringlist.ExtractLinesFromText(Globals.errorMemory.ToString());
                    for (int i = 0; i < xx.Count; i++)
                    {
                        if (i > 30) continue;  //so that we don't accidentally get 100's of lines from user output pasted in. The intention is to only get a copy of messages since last error message.
                        s += xx[i] + G.NL;
                    }
                }

                if (Globals.lastDynamicCsCode != null)
                {
                    //this is nice to have to trace the error if this sort of problem appears!
                    s += G.NL + G.NL + "----------------------------- Non-compiling cs code: ----------------------------------" + G.NL;
                    s += Globals.lastDynamicCsCode;
                    s += G.NL;
                }

                LinkContainer lc = new LinkContainer(s);
                Globals.linkContainer.Add(lc.counter, lc);
                G.Write(" ("); G.WriteLink("more", "stacktrace:" + lc.counter); G.Write(")"); G.Writeln();


            }
            Gui.gui.ThreadFinished();  //removes the job from the stack of jobs, otherwise we will wait for this halted job forever. Could use thread stop instead??
        }

        /// <summary>
        /// An error that is printed if a user tries to change data in a protected (read-only) databank
        /// </summary>
        /// <param name="s"></param>
        public static void ProtectError(string s)
        {
            new Error(s);
        }

        /// <summary>
        /// Helper for exceptions
        /// </summary>
        /// <param name="p"></param>
        public static void GekkoExceptionCleanup(P p)
        {
            //This method is also called when exceptions arise in unit testing (FAIL() method)
            StopPipeAndMute(1);
            Program.options.series_dyn = null;  //this is because if there is a runtime error inside af BLOCK series dyn = ... ; ... ; END; it is best to have dyn switched off afterwards. If the program has a RESET/RESTART, this does not matter, but if not, setting = null guards agains <dyn> surprises after the runtime error. This option is special in that it can only be set in a BLOCK, not in an OPTION.

            if (Globals.threadIsInProcessOfAborting)
            {
                G.Writeln();
                G.Writeln("-------------------------------------------------------------", Color.Red);
                G.Writeln("------------ The job was stopped by the user ----------------", Color.Red);
                G.Writeln("---------------- (Red stop button) --------------------------", Color.Red);
                G.Writeln("-------------------------------------------------------------", Color.Red);
                G.Writeln();
            }
            if (Globals.applicationIsInProcessOfAborting)
            {
                Application.Exit();  //will go to #3452345523 after
            }
        }

        /// <summary>
        /// Helper for the PIPE command
        /// </summary>
        /// <param name="i"></param>
        public static void StopPipeAndMute(int i)
        {
            if (i == 1)
            {
                Program.ReleasePipe();
                Program.ReleasePipe2();

            }
            else if (i == 2)
            {
                if (Globals.pipe == true) Program.Pipe("con", null);
            }

            //in both cases:
            if (G.Equal(Program.options.interface_mute, "yes"))
            {
                Program.options.interface_mute = "no";
                new Note("Because of errors, OPTION interface mute = 'no'");
            }
        }

        /// <summary>
        /// Helper for exceptions printing
        /// </summary>
        /// <param name="ex"></param>
        /// <param name="s"></param>
        /// <returns></returns>
        public static bool FindException(Exception ex, string s)
        {
            if (ex == null) return false;
            if (ex.Message != null && ex.Message.Contains(s)) return true;
            Exception temp = ex;
            for (int i = 0; i < 1000; i++)  //1000 nested levels should be enough...
            {
                temp = temp.InnerException;
                if (temp == null) return false;
                if (temp.Message != null && temp.Message.Contains(s)) return true;
            }
            return false;
        }

        /// <summary>
        /// Helper regarding stack trace, to see how commands/functions/procedures call each other
        /// </summary>
        /// <param name="e2"></param>
        /// <returns></returns>
        public static string GetStackTraceWithOffset(Exception e2)
        {
            StackTrace st = new System.Diagnostics.StackTrace(e2);
            string stackTrace = "";
            foreach (StackFrame frame in st.GetFrames())
            {
                stackTrace = "           " + "at " + frame.GetMethod().Module.Name + "." +
                    frame.GetMethod().ReflectedType.Name + "."
                    + frame.GetMethod().Name
                    + "  (IL offset: 0x" + frame.GetILOffset().ToString("x") + ")\n" + stackTrace;
            }
            return stackTrace;
        }

        /// <summary>
        /// TELL command.
        /// </summary>
        /// <param name="text"></param>
        /// <param name="nocr"></param>
        public static void Tell(string text, bool nocr)
        {

            if (false && Globals.runningOnTTComputer)
            {
                //string ss = "100\t2\t3.3\t4\t3\t123456.78\t1234567.89\t12345678.91\t123456789.12\t1234567891.23\tabc\t4\r\n2\t3234234.2342343243\t123456.7811\t1234567.8911\t12345678.9111\t123456789.1211\t1234567891.2311\tdef\t3\t2.345\t3\t4";
                string ss = "100\t2\t3.3\t4\t3\t1234567.89\t12345678.91\t123456789.12\t1234567891.23\tabc\t4\r\n2\t3234234.2342343243\tNB\t777777.7777e-13\t1234567.891\t12345678.911\t123456789.121\t1234567891.231\tdef\t3\t2.345\t3\t4";
                Clipboard.SetText(ss, TextDataFormat.Text);
            }

            if (false && Globals.runningOnTTComputer)
            {
                DateTime dt0 = DateTime.Now;
                long j = 1;
                for (int i = 0; i < 1e6; i++)
                {
                    //DateTime dt = DateTime.Now;  //0.3
                    //DateTime dt = DateTime.UtcNow;  //0.08
                    //ScalarVal v = new ScalarVal(123d); //0.01...
                    j++;  //0.002
                }
                new Writeln(G.Seconds(dt0));
            }

            if (false && Globals.runningOnTTComputer)
            {
                SplitVars();
            }

            if (false && Globals.runningOnTTComputer)
            {
                Speed.Run();
            }

            if (false && Globals.runningOnTTComputer)
            {
                DateTime t0 = DateTime.Now;
                new Writeln("Start");
                double x = 0;
                for (double i = 1; i <= 1e10; i++)
                {
                    x += i;
                }
                new Writeln("" + x + "   " + G.Seconds(t0));
            }

            if (false && Globals.runningOnTTComputer)
            {
                G.Writeln("");
                G.Writeln("==========================================================================================");
                G.Writeln("SERIES Work: e");
                G.Writeln("Annual data from 2021 to 2023 (updated: 06-06-2022)");
                G.Writeln("Source: Statistics Denmark");
                G.Write("Calc: read bank1; "); G.WriteLink("(trace)", ""); G.Writeln();
                G.Writeln("------------------------------------------------------------------------------------------");
                G.Writeln("Period           value         %");
                G.Writeln("2021           28.0000    ******");
                G.Writeln("2022           32.0000     14.29");
                G.Writeln("2023           36.0000     12.50");
                G.Writeln("==========================================================================================");
                G.Writeln("");
                G.Writeln("------------------------------------------------------------------------------------------");
                G.Writeln(@"Work:e!a");
                G.Writeln("------------------------------------------------------------------------------------------");
                G.Write(@"read bank1; --- "); G.Write(@"bank: c:\Gekko\bank1.gbk 06-06-2022 9:45:24 --- trace: "); G.WriteLink("Work:e!a", ""); G.Writeln();
                G.Writeln("------------------------------------------------------------------------------------------");
                G.Writeln();
                G.Writeln("------------------------------------------------------------------------------------------");
                G.Writeln(@"Work:e!a --> Work:e!a");
                G.Writeln("------------------------------------------------------------------------------------------");
                G.Write(@"copy d to e; --- copied Work:e!a from Work:d!a --- trace: "); G.WriteLink("Work:d!a", ""); G.Writeln();
                G.Writeln(@"2024-2025: e <2024 2025> = 22, 23;");
                G.Writeln("------------------------------------------------------------------------------------------");
                G.Writeln();
                G.Writeln("------------------------------------------------------------------------------------------");
                G.Writeln(@"Work:d!a --> Work:e!a --> Work:e!a");
                G.Writeln("------------------------------------------------------------------------------------------");
                G.Write(@"2021-2023: d = a + b + c; --- trace: "); G.WriteLink("Work:a!a", ""); G.Write(", "); G.WriteLink("Work:b!a", ""); G.Write(", "); G.WriteLink("Work:c!a", ""); G.Writeln();
                G.Writeln("------------------------------------------------------------------------------------------");
                G.Writeln();
                G.Writeln("------------------------------------------------------------------------------------------");
                G.Writeln(@"Work:c!a --> Work:d!a --> Work:e!a --> Work:e!a");
                G.Writeln("------------------------------------------------------------------------------------------");
                G.Write(@"2021-2023: c = a + b; --- trace: "); G.WriteLink("Work:a!a", ""); G.Write(", "); G.WriteLink("Work:b!a", ""); G.Writeln();
                G.Writeln("------------------------------------------------------------------------------------------");
                G.Writeln();
                G.Writeln("------------------------------------------------------------------------------------------");
                G.Writeln(@"Work:a!a --> Work:c!a --> Work:d!a --> Work:e!a --> Work:e!a");
                G.Writeln("------------------------------------------------------------------------------------------");
                G.Writeln(@"2021-2023:  a = 2, 3, 4;");
                G.Writeln("------------------------------------------------------------------------------------------");

            }

            if (false && Globals.runningOnTTComputer)
            {
                string file = @"c:\Thomas\Desktop\gekko\testing\skabelon.xlsx";
                string sheetName = "Ark2";
                TableLight matrix = new TableLight();

                if (!File.Exists(file))
                {
                    new Error("File " + file + " does not seem to exist");
                    //throw new GekkoException();
                }

                WriteXlsError(file);

                try
                {

                    using (ExcelPackage excel2 = new ExcelPackage(new FileInfo(file)))
                    {
                        ExcelWorksheet ws = null;
                        if (sheetName != null)
                        {
                            ws = excel2.Workbook.Worksheets[sheetName];
                            if (ws == null)
                            {
                                new Error("Could not find sheet '" + sheetName + "' inside " + file);
                                //throw new GekkoException();
                            }
                        }
                        else
                        {
                            ws = excel2.Workbook.Worksheets.First<ExcelWorksheet>();
                        }

                        if (ws.Dimension == null)
                        {
                            new Error("It seems the sheet is empty.");
                        }
                        ExcelCellAddress start = ws.Dimension.Start;
                        ExcelCellAddress end = ws.Dimension.End;

                        object[,] intput = (object[,])ws.Cells[1, 1, end.Row, end.Column].Value;

                        ExcelRange zz = ws.Cells[3, 3];
                        string s = zz.Style.Border.Left.Style.ToString() + " " + zz.Style.Border.Right.Style.ToString() + " " + zz.Style.Border.Top.Style.ToString() + " " + zz.Style.Border.Bottom.Style.ToString();
                        s = zz.Text;

                        zz = ws.Cells[7, 3];
                        s = zz.Style.Border.Left.Style.ToString() + " " + zz.Style.Border.Right.Style.ToString() + " " + zz.Style.Border.Top.Style.ToString() + " " + zz.Style.Border.Bottom.Style.ToString();

                        zz = ws.Cells[2, 2];
                        s = zz.Comment.Text;

                        int rows2 = intput.GetLength(0);
                        int cols2 = intput.GetLength(1);

                        //beware, this array is 0-based
                        for (int i = 0; i < end.Row; i++)
                        { // Row by row...
                            for (int j = 0; j < end.Column; j++)
                            { // ... Cell by cell...

                                Object temp = intput[i, j];
                                if (temp == null) continue;
                                CellLight cell;
                                Type t = temp.GetType();
                                if (t == typeof(double))
                                {
                                    cell = new CellLight((double)temp);
                                }
                                else if (t == typeof(DateTime))
                                {
                                    cell = new CellLight((DateTime)temp);
                                }
                                else if (t == typeof(int))
                                {
                                    int iData = (int)temp;

                                    //-2146826281 = #Div/0!
                                    //-2146826246 = #N/A
                                    //-2146826259 = #Name?
                                    //-2146826288 = #Null!
                                    //-2146826252 = #Num!
                                    //-2146826265 = #Ref!
                                    //-2146826273 = #Value!

                                    if (iData == -2146826246)
                                    {
                                        //just like it is in a csv file. The -2146826246 is really a hexadecimal error code from Excel, stating that the number is N/A.
                                        cell = new CellLight("#N/A");
                                    }
                                    else if (iData == -2146826259)
                                    {
                                        cell = new CellLight("#Name?");
                                    }
                                    else if (iData == -2146826281)
                                    {
                                        cell = new CellLight("#Div/0");
                                    }
                                    else
                                    {
                                        cell = new CellLight((double)iData);
                                    }
                                }
                                else if (temp.GetType() == typeof(string))
                                {
                                    cell = new CellLight((string)temp);
                                }
                                else if (temp.GetType() == typeof(OfficeOpenXml.ExcelErrorValue))
                                {
                                    cell = new CellLight(double.NaN);
                                }
                                else
                                {
                                    Type tt = temp.GetType();
                                    string ttt = temp.GetType().ToString();
                                    cell = new CellLight("[data not recognized error]");
                                }
                                matrix.Add(i + 1, j + 1, cell);  //i and j are 0-based, matrix needs to be 1-based.

                            }
                        }
                    }
                }
                catch (Exception e)
                {
                    if (!(e is GekkoException))
                    {
                        if (e.Message != null && e.Message != "")
                        {
                            new Error(e.Message, false);
                            WriteExcelError();
                        }
                    }
                    throw;
                }
            }


            if (false && Globals.runningOnTTComputer)
            {

                //maybe buffer not larger then 1 mio.

                int i = 0;

                if (text.EndsWith("i1")) i = 1;
                else if (text.EndsWith("i2")) i = 2;
                else if (text.EndsWith("i3")) i = 3;
                else if (text.EndsWith("i4")) i = 4;
                else if (text.EndsWith("i5")) i = 5;
                else if (text.EndsWith("i6")) i = 6;
                else if (text.EndsWith("i7")) i = 7;
                else if (text.EndsWith("i8")) i = 8;
                else if (text.EndsWith("i9")) i = 9;
                else if (text.EndsWith("i10")) i = 10;
                else if (text.EndsWith("i11")) i = 11;
                else if (text.EndsWith("i12")) i = 12;
                else if (text.EndsWith("i13")) i = 13;
                else if (text.EndsWith("i14")) i = 14;
                else if (text.EndsWith("i15")) i = 15;
                else if (text.EndsWith("i16")) i = 16;

                string file1 = @"c:\Tools\test\makro0.gdx";
                string file2 = @"c:\Tools\test\makro0.zip";
                string file2a = @"c:\Tools\test\makro0a.zip";  //uncompressed
                string file3 = @"c:\Tools\test\makro0.gbk";    //gbk version
                string file4 = @"c:\Tools\test\makro0a.gbk";    //gbk version uncompressed
                string file5 = @"c:\Tools\test\makro0.data";   //data protobuf file
                string fileFolder = @"c:\Tools\test\file";
                DateTime dt0 = DateTime.Now;

                //int buf = 4096;
                //buf = int.Parse(text);

                if (true && Globals.runningOnTTComputer)
                {

                    //   debug rel64      gdx is 127 mb, zipped 27 mb with compression. 
                    //-------------------------------------------------------------------------------
                    //i1   1800           normal sha
                    //i2   1450           sha with 1.2 mb chunks
                    //i3   1650           sha with 1.2 mb chunks and read access
                    //i4   2900           md5 on text
                    //i5   9000           md5 on text utf8
                    //i6    200    180    file copy
                    //i7           700    md5 directly on file
                    //i8   1750   1600    sha with optimal mb chunks and read access
                    //i9   4600   4450    zip with normal compression
                    //i10  1000    900    zip with zero compression
                    //i11  1100   1000    unzip with normal compression
                    //i12   300    300    unzip with zero compression
                    //i13  2500   2400    read<first> gbk with normal compression
                    //i14  2200   2100    read<first> gbk with zero compression
                    //i15  1400   1400    deflate directly from protobuf 
                    //i16 11000   5600    read<first> gdx
                    //-------------------------------------------------------------------------------
                    //could be 10-20% faster if arrays used instead of ts.SetData().
                    //caching would be around "file copy" + "md5" + "deflate" = 180+700+1400 = 2500. 
                    //  Faster if gdx is zipped and hash, maybe 1900 = 3 x faster.
                    //  Then read<gdx> first time would go from 2400 to 3400 = 40% worse.
                    //reading gbk directly would be 2400.


                    //-------------------------------------------------------------------------------

                    if (i == 1)
                    {
                        //almost as fast as 3 (fastest)
                        using (FileStream stream = File.OpenRead(file1))
                        {
                            SHA256Managed sha = new SHA256Managed();
                            byte[] checksum = sha.ComputeHash(stream);
                            string s = BitConverter.ToString(checksum).Replace("-", String.Empty);
                        }
                    }
                    else if (i == 2)
                    {
                        //almost as fast as 3 (fastest)
                        using (var stream = new BufferedStream(File.OpenRead(file1), 1200000))
                        {
                            SHA256Managed sha = new SHA256Managed();
                            byte[] checksum = sha.ComputeHash(stream);
                            string s = BitConverter.ToString(checksum).Replace("-", String.Empty);
                        }
                    }
                    else if (i == 3)
                    {
                        //seems fastest, but i ==1 and i == 2 are almost as fast
                        using (var stream = new FileStream(file1, FileMode.Open, FileAccess.Read, FileShare.ReadWrite, 1200000))
                        {
                            SHA256Managed sha = new SHA256Managed();
                            byte[] checksum = sha.ComputeHash(stream);
                            string s = BitConverter.ToString(checksum).Replace("-", String.Empty);
                        }
                    }
                    else if (i == 4)
                    {
                        //2.5 x time for i == 3
                        string s = Program.GetMD5Hash(GetTextFromFileWithWait(file1, false), null, null);
                    }
                    else if (i == 5)
                    {
                        //7 x time for i == 3
                        string s = Program.GetMD5Hash(GetTextFromFileWithWait(file1, true), null, null);
                    }
                    else if (i == 6)
                    {
                        //really fast
                        WaitForFileCopy(file1, "c:\\tools\\slet\\sletmig.data");
                    }
                    else if (i == 7)
                    {
                        string s = Program.GetMD5Hash(null, file1, null);
                    }
                    else if (i == 8)
                    {
                        using (var stream = Program.WaitForFileStream(file1, null, GekkoFileReadOrWrite.Read, Globals.goodBufferSizeForShaHashCode))  //50000
                        {
                            SHA256Managed sha = new SHA256Managed();
                            byte[] checksum = sha.ComputeHash(stream);
                            string s = BitConverter.ToString(checksum).Replace("-", String.Empty);
                        }
                    }
                    else if (i == 9)
                    {
                        File.Delete(file2);
                        ZipFile.CreateFromDirectory(fileFolder, file2);
                    }
                    else if (i == 10)
                    {
                        File.Delete(file2a);
                        ZipFile.CreateFromDirectory(fileFolder, file2a, System.IO.Compression.CompressionLevel.NoCompression, false);
                    }
                    else if (i == 11)
                    {
                        string folder = CreateTempFolderPath("temptsdxfolder");
                        if (!Directory.Exists(folder)) Directory.CreateDirectory(folder);
                        ZipFile.ExtractToDirectory(file2, folder);
                    }
                    else if (i == 12)
                    {
                        string folder = CreateTempFolderPath("temptsdxfolder");
                        if (!Directory.Exists(folder)) Directory.CreateDirectory(folder);
                        ZipFile.ExtractToDirectory(file2a, folder);
                    }
                    else if (i == 13)
                    {
                        Program.RunGekkoCommands("read <first> " + file3 + ";", "", 0, new P());
                    }
                    else if (i == 14)
                    {
                        Program.RunGekkoCommands("read <first> " + file4 + ";", "", 0, new P());
                    }
                    else if (i == 15)
                    {
                        Databank deserializedDatabank = ProtobufRead<Databank>(file5);
                    }
                    else if (i == 16)
                    {
                        Program.RunGekkoCommands("read <first gdx> " + file1 + ";", "", 0, new P());
                    }
                    else if (i == 17)
                    {
                        //This probably needs protobuf.NET >= 3.0
                        //var list = new List<byte[]>();
                        //var output = new Databank[list.Count];
                        //Parallel.ForEach(list, () => 0, (x, pls, index, s) =>
                        //{
                        //    output[(int)index] = Serializer.Deserialize<Databank>(x);
                        //    return 0;
                        //}, _ => { });
                    }
                }
                else
                {
                    using (var stream = Program.WaitForFileStream(file1, null, GekkoFileReadOrWrite.Read, Globals.goodBufferSizeForShaHashCode))  //1200000
                    {
                        SHA256Managed sha = new SHA256Managed();
                        byte[] checksum = sha.ComputeHash(stream);
                        string s = BitConverter.ToString(checksum).Replace("-", String.Empty);
                    }
                }

                new Writeln("Alternative " + i + ", time ms = " + (DateTime.Now - dt0).TotalMilliseconds);


                if (text == "arrow")
                {
                    //while (true)
                    //{
                    //    var codeToEval = Console.ReadLine();
                    //    var result = await CSharpScript.EvaluateAsync(codeToEval);
                    //    Console.WriteLine(result);
                    //}

                    //Arrow.Run();
                    return;
                }
                else if (text == "test")
                {
                    Translate_2_4_to_3_0.TestTranslation();
                    return;
                }

            }
            if (text.Trim().ToLower() == "datopgek3_agh7xvslke3jfhqp")
            {
                Translate_2_4_to_3_0.Insert();
                return;
            }
            else if (text.Trim().ToLower() == "clone gbk files lkjsf7akljaf7ds")
            {
                Translate_2_4_to_3_0.Insert2();
                return;
            }
            else if (text.Trim().ToLower() == "clone data files ksf66adadjk34j")
            {
                Translate_2_4_to_3_0.Insert3();
                return;
            }
            if (nocr) G.Write(text);
            else G.Writeln(text);
        }

        /// <summary>
        /// From the variable pv, flood the adjacent variables with color color.
        /// </summary>
        /// <param name="flood"></param>
        /// <param name="color"></param>
        /// <param name="colors"></param>
        public static List<Flood> Flood1Color(Flood flood, Flood floodEnd, Dictionary<PeriodAndVariable, Flood> colors, out bool done, ModelGamsScalar model)
        {
            done = false;
            List<Flood> rv = new List<Flood>();
            List<int> eqs = model.dependents[flood.pv];
            foreach (int eq in eqs)
            {                
                ModelScalarEquation eqs2 = model.precedents[eq];
                foreach (PeriodAndVariable pv2 in eqs2.vars)
                {   
                    //new Writeln("equation " + eqName + " containing variable " + pv.GetVariableAndPeriod().Item1 + " in " + pv.GetVariableAndPeriod().Item2.ToString());
                    Flood found = null; colors.TryGetValue(pv2, out found);
                    if (found != null)
                    {
                        //skip, must have <= color
                    }
                    else
                    {
                        Flood f = new Flood();
                        f.color = flood.color + 1;
                        f.parent = flood;
                        f.pv = pv2;
                        f.eq = eq;
                        colors.Add(pv2, f);
                        rv.Add(f);
                    }
                    if (floodEnd.pv.Equals(pv2))
                    {
                        done = true;
                        break;
                    }
                }
            }
            return rv;
        }

        /// <summary>
        /// Splits a Dictionary of string/IVariable by size into a nested list for parallel use.
        /// Imagine splitteing the numbers 3, 6, 4, 9, 3, 10, 3, 1, 2 into three equal-size lists.
        /// This method tries to do its best. See also #78auyfioauif8a9s.
        /// </summary>
        /// <param name="storage"></param>
        /// <param name="k"></param>
        /// <param name="print"></param>
        /// <returns></returns>
        private static List<List<KeyValuePair<string, IVariable>>> SplitVarsInSameSizeParts(Dictionary<string, IVariable> storage, int k, bool print)
        {
            if (k == 1)
            {
                List<KeyValuePair<string, IVariable>> list = new List<KeyValuePair<string, IVariable>>();
                foreach (KeyValuePair<string, IVariable> kvp in storage)
                {
                    list.Add(kvp);
                }
                List<List<KeyValuePair<string, IVariable>>> lists = new List<List<KeyValuePair<string, IVariable>>>();
                lists.Add(list);
                return lists;
            }

            int sum = 0;
            List<CountHelper> x = new List<CountHelper>();
            Count count = new Count();
            foreach (KeyValuePair<string, IVariable> kvp in storage)
            {
                count.n = 0;
                kvp.Value.DeepCount(count);
                CountHelper ch = new CountHelper();
                ch.kvp = kvp;
                ch.n = count.n;
                x.Add(ch);
                sum += ch.n;
            }
            var sorted = x.OrderByDescending(o => o.n);  //how fast is this? Around O(n*log(n)). So close to proportional to #elements, which is ok.
            List<List<KeyValuePair<string, IVariable>>> rv = new List<List<KeyValuePair<string, IVariable>>>();
            List<int> sums = new List<int>();
            for (int i = 0; i < k; i++)
            {
                rv.Add(new List<KeyValuePair<string, IVariable>>());
                sums.Add(0);
            }

            foreach (CountHelper ch in sorted)
            {
                //new Writeln(ch.name + " --> " + ch.n);
                int imin = -12345;
                int min = int.MaxValue;
                for (int i = 0; i < k; i++)
                {
                    //BEWARE
                    //BEWARE
                    //BEWARE Is this loop fast enough? Can perhaps be sped up a bit?
                    //BEWARE
                    //BEWARE
                    if (sums[i] < min)
                    {
                        min = sums[i];
                        imin = i;
                    }
                }
                rv[imin].Add(ch.kvp);
                sums[imin] += ch.n;
            }
            if (Globals.runningOnTTComputer)
            {
                if (print)
                {
                    List<string> shares = new List<string>();
                    for (int i = 0; i < k; i++)
                    {
                        shares.Add("" + G.UpdprtFormat((double)sums[i] / (double)sum * 100d, 2, false));
                    }
                    new Writeln("TTH: Proxy " + sum / 1000000 + " MB -- " + Stringlist.GetListWithCommas(shares));
                }
            }

            return rv;
        }

        /// <summary>
        /// BEWARE: as a side-effect, storage input is sorted by double size.
        /// Splits a Dictionary of string/double by size into k sub-lists for parallel use.
        /// Imagine splitting the numbers 3, 6, 4, 9, 3, 10, 3, 1, 2 into three equal-size lists.
        /// This method tries to do its best. See also #78auyfioauif8a9s.
        /// </summary>
        /// <param name="storage"></param>
        /// <param name="k"></param>
        /// <param name="print"></param>
        /// <returns></returns>
        private static List<List<StringDouble>> SplitVarsInSameSizeParts(List<StringDouble> storage, int k, bool print)
        {
            if (k == 1)
            {
                List<StringDouble> list = new List<StringDouble>();
                foreach (StringDouble kvp in storage)
                {
                    list.Add(kvp);
                }
                List<List<StringDouble>> lists = new List<List<StringDouble>>();
                lists.Add(list);
                return lists;
            }

            double sum = 0;
            List<CountHelper> x = new List<CountHelper>();
            Count count = new Count();
            foreach (StringDouble kvp in storage)
            {
                sum += kvp.d;
            }
            var sorted = storage.OrderByDescending(o => o.d);  //how fast is this? Around O(n*log(n)). So close to proportional to #elements, which is ok.
            List<List<StringDouble>> rv = new List<List<StringDouble>>();
            List<double> sums = new List<double>();
            for (int i = 0; i < k; i++)
            {
                rv.Add(new List<StringDouble>());
                sums.Add(0d);
            }

            foreach (StringDouble ch in sorted)
            {
                //new Writeln(ch.name + " --> " + ch.n);
                int imin = -12345;
                double min = double.MaxValue;
                for (int i = 0; i < k; i++)
                {
                    //BEWARE
                    //BEWARE
                    //BEWARE Is this loop fast enough? Can perhaps be sped up a bit?
                    //BEWARE
                    //BEWARE
                    if (sums[i] < min)
                    {
                        min = sums[i];
                        imin = i;
                    }
                }
                rv[imin].Add(ch);
                sums[imin] += ch.d;
            }
            if (Globals.runningOnTTComputer)
            {
                if (print)
                {
                    List<string> shares = new List<string>();
                    for (int i = 0; i < k; i++)
                    {
                        shares.Add("" + G.UpdprtFormat(sums[i] / sum * 100d, 2, false));
                    }
                    new Writeln("TTH: Sum is " + G.UpdprtFormat(sum, 2, false) + " MB , " + k + " %shares " + Stringlist.GetListWithCommas(shares) + ", goal = " + G.UpdprtFormat(100d / k, 2, false));
                }
            }

            return rv;
        }

        public static void SplitVars()
        {
            List<StringDouble> a = new List<StringDouble>();
            //x means 1 mio elements, (x) has them in two dimensions
            //
            //These data are obtained manually. Could use reflection on the top-most objects in modelGamsScalar,
            //and try to switch off the objects one by one and measure difference in written protobuf.
            //When doing this, just read an existing full protobuf (faster than reading gdx).
            //Small objects are pruned here. All the C# code, for all thread numbers ought to be generated
            //automatically, but here we just generate for threads=5. On top, there is the modelGamsScalar object
            //itself, so we get 6 chunks (but this object is small when the sub-objects below are removed).
            a.Add(new StringDouble("csCodeLines", 1.7));
            a.Add(new StringDouble("cc", 2.4));
            a.Add(new StringDouble("ee", 3.2)); //x
            a.Add(new StringDouble("dict_FromEqNumberToEqChunkNumber", 4.1)); //x
            a.Add(new StringDouble("aTemp", 9.6)); //(x)
            a.Add(new StringDouble("ddTemp", 11.0)); //x
            a.Add(new StringDouble("dict_FromVarNumberToVarName", 22.8)); //x
            a.Add(new StringDouble("dict_FromEqNumberToEqName", 25.4)); //x
            a.Add(new StringDouble("bbTemp", 26.5)); //x
            a.Add(new StringDouble("dependents", 26.8)); //x
            a.Add(new StringDouble("dict_FromVarNameToVarNumber", 29.2)); //x
            a.Add(new StringDouble("dict_FromEqNameToEqNumber", 31.8)); //x
            a.Add(new StringDouble("precedents", 36.1)); //x  

            int n = 5;

            List<List<StringDouble>> aa = SplitVarsInSameSizeParts(a, n, true);

            StringBuilder sb = new StringBuilder();
            sb.AppendLine("public static List<string> ProtobufModelGamsScalar5a(int n, ModelGamsScalar modelGamsScalar){");
            sb.AppendLine("if(n != " + n + ") new Error(\"Hov\");");
            sb.AppendLine("List<ModelGamsScalar> m = new List<ModelGamsScalar>();");
            sb.AppendLine("for(int i = 1; i <= n + 1; i++) {");
            sb.AppendLine("  m.Add(null);");
            sb.AppendLine("}");
            sb.AppendLine("m[0] = modelGamsScalar;");
            int i = 0;
            foreach (List<StringDouble> x1 in aa)
            {
                i++;  //starts with 1
                sb.AppendLine("m[" + i + "] = new ModelGamsScalar();");
                foreach (StringDouble x2 in x1)
                {
                    sb.AppendLine("m[" + i + "]." + x2.s + " = m[0]" + "." + x2.s + ";");
                    sb.AppendLine("m[0]" + "." + x2.s + " = null;");
                }
            }
            sb.AppendLine("for(int i = 0;i <= n; i++) {");
            sb.AppendLine("  Program.ProtobufWrite(m[i], files[i]);");
            sb.AppendLine("}");
            sb.AppendLine("return m;");
            sb.AppendLine("}");
            File.WriteAllText("c:\\tools\\Model1.cs", sb.ToString());

            // ---------------------------------------
            // ---------------------------------------
            // ---------------------------------------

            sb = new StringBuilder();
            sb.AppendLine("public static ModelGamsScalar ProtobufModelGamsScalar5b(List<ModelGamsScalar>m){");            
            i = 0;
            foreach (List<StringDouble> x1 in aa)
            {
                i++;  //starts with 1
                foreach (StringDouble x2 in x1)
                {
                    sb.AppendLine("m[0]." + x2.s + " = m[" + i + "]" + "." + x2.s + ";");
                }
            }
            sb.AppendLine("return m[0];");
            sb.AppendLine("}");
            File.WriteAllText("c:\\tools\\Model2.cs", sb.ToString());

            new Writeln("See c:\\tools\\Model1.cs/Model2.cs for code");

        }

        public static List<object> ProtobufModelGamsScalar5a(int k, Model model)
        {            
            if (k != 5) new Error("Hov");            

            List<ModelGamsScalar> m = new List<ModelGamsScalar>();
            List<object> mm = new List<object>();

            for (int i = 0; i <= k + Globals.systemTthreadsExtra; i++)  //0..8 inclusive
            {
                m.Add(null);
                mm.Add(null);
            }            

            if (model.modelGamsScalar == null)
            {
                //keep the nulls
            }            
            else 
            {
                //In these, [1]-[5] are large, [0] is small. Later on, [6]-[8] are small, too.
                m[0] = model.modelGamsScalar;
                m[1] = new ModelGamsScalar(null);
                m[1].precedents = m[0].precedents;
                m[0].precedents = null;
                m[1].dict_FromEqNumberToEqChunkNumber = m[0].dict_FromEqNumberToEqChunkNumber;
                m[0].dict_FromEqNumberToEqChunkNumber = null;
                m[1].ee = m[0].ee;
                m[0].ee = null;
                m[2] = new ModelGamsScalar(null);
                m[2].dict_FromEqNameToEqNumber = m[0].dict_FromEqNameToEqNumber;
                m[0].dict_FromEqNameToEqNumber = null;
                m[2].aTemp = m[0].aTemp;
                m[0].aTemp = null;
                m[2].csCodeLines = m[0].csCodeLines;
                m[0].csCodeLines = null;
                m[3] = new ModelGamsScalar(null);
                m[3].dict_FromVarNameToVarNumber = m[0].dict_FromVarNameToVarNumber;
                m[0].dict_FromVarNameToVarNumber = null;
                m[3].ddTemp = m[0].ddTemp;
                m[0].ddTemp = null;
                m[3].cc = m[0].cc;
                m[0].cc = null;
                m[4] = new ModelGamsScalar(null);
                m[4].dependents = m[0].dependents;
                m[0].dependents = null;
                m[4].dict_FromVarNumberToVarName = m[0].dict_FromVarNumberToVarName;
                m[0].dict_FromVarNumberToVarName = null;
                m[5] = new ModelGamsScalar(null);
                m[5].bbTemp = m[0].bbTemp;
                m[0].bbTemp = null;
                m[5].dict_FromEqNumberToEqName = m[0].dict_FromEqNumberToEqName;
                m[0].dict_FromEqNumberToEqName = null;
            }

            for (int i = 0; i <= k + Globals.systemTthreadsExtra; i++)
            {
                if (m[i] != null) mm[i] = m[i];
                else mm[i] = new ModelNull();
            }

            mm[6] = model.modelCommon;  //can never be null
            if (model.modelGams != null) mm[7] = model.modelGams;
            if (model.modelGekko != null) mm[8] = model.modelGekko;

            if (mm.Count != k + Globals.systemTthreadsExtra + 1) new Error("Hov");

            return mm;
        }        

        public static Model ProtobufModelGamsScalar5b(int k, List<object>mm)
        {
            if (k != 5) new Error("Hov");
            if (mm.Count != k + Globals.systemTthreadsExtra + 1) new Error("Hov");
            Model model = new Model();
            List<ModelGamsScalar> m = new List<ModelGamsScalar>();
            for (int i = 0; i <= k; i++) m.Add(mm[i] as ModelGamsScalar);

            if (m[0] != null)
            {
                m[0].precedents = m[1].precedents;
                m[0].dict_FromEqNumberToEqChunkNumber = m[1].dict_FromEqNumberToEqChunkNumber;
                m[0].ee = m[1].ee;
                m[0].dict_FromEqNameToEqNumber = m[2].dict_FromEqNameToEqNumber;
                m[0].aTemp = m[2].aTemp;
                m[0].csCodeLines = m[2].csCodeLines;
                m[0].dict_FromVarNameToVarNumber = m[3].dict_FromVarNameToVarNumber;
                m[0].ddTemp = m[3].ddTemp;
                m[0].cc = m[3].cc;
                m[0].dependents = m[4].dependents;
                m[0].dict_FromVarNumberToVarName = m[4].dict_FromVarNumberToVarName;
                m[0].bbTemp = m[5].bbTemp;
                m[0].dict_FromEqNumberToEqName = m[5].dict_FromEqNumberToEqName;
            }

            model.modelGamsScalar = mm[0] as ModelGamsScalar; //becomes = null if ModelNull object
            model.modelCommon = mm[k + 1] as ModelCommon;  //used for .type only
            model.modelGams = mm[k + 2] as ModelGams; //becomes = null if ModelNull object            
            model.modelGekko = mm[k + 3] as ModelGekko; //becomes = null if ModelNull object              

            //these .parent fields are probably always = null, 
            //and even if not, this is safe to do:
            if (model.modelGamsScalar != null) model.modelGamsScalar.parent = model;
            if (model.modelGams != null) model.modelGams.parent = model;
            if (model.modelGekko != null) model.modelGekko.parent = model;

            return model;
        }


        //public static void ProtobufModelGamsScalar1(List<string> files)
        //{
        //    int n = 5;
        //    List<ModelGamsScalar> m = new List<ModelGamsScalar>();
        //    for (int i = 1; i <= n; i++)
        //    {
        //        m.Add(new ModelGamsScalar());
        //    }
        //    m[0] = Program.model.modelGamsScalar;
        //    m[1] = new ModelGamsScalar();
        //    m[1].precedents = m[0].precedents;
        //    m[0].precedents = null;
        //    m[1].dict_FromEqNumberToEqChunkNumber = m[0].dict_FromEqNumberToEqChunkNumber;
        //    m[0].dict_FromEqNumberToEqChunkNumber = null;
        //    m[1].ee = m[0].ee;
        //    m[0].ee = null;
        //    m[2] = new ModelGamsScalar();
        //    m[2].dict_FromEqNameToEqNumber = m[0].dict_FromEqNameToEqNumber;
        //    m[0].dict_FromEqNameToEqNumber = null;
        //    m[2].aTemp = m[0].aTemp;
        //    m[0].aTemp = null;
        //    m[2].csCodeLines = m[0].csCodeLines;
        //    m[0].csCodeLines = null;
        //    m[3] = new ModelGamsScalar();
        //    m[3].dict_FromVarNameToVarNumber = m[0].dict_FromVarNameToVarNumber;
        //    m[0].dict_FromVarNameToVarNumber = null;
        //    m[3].ddTemp = m[0].ddTemp;
        //    m[0].ddTemp = null;
        //    m[3].cc = m[0].cc;
        //    m[0].cc = null;
        //    m[4] = new ModelGamsScalar();
        //    m[4].dependents = m[0].dependents;
        //    m[0].dependents = null;
        //    m[4].dict_FromVarNumberToVarName = m[0].dict_FromVarNumberToVarName;
        //    m[0].dict_FromVarNumberToVarName = null;
        //    m[5] = new ModelGamsScalar();
        //    m[5].bbTemp = m[0].bbTemp;
        //    m[0].bbTemp = null;
        //    m[5].dict_FromEqNumberToEqName = m[0].dict_FromEqNumberToEqName;
        //    m[0].dict_FromEqNumberToEqName = null;
        //    for (int i = 0; i <= n; i++)
        //    {
        //        Program.ProtobufWrite(m[i], files[i]);
        //    }

        //    // --- after protobuf write

        //    for (int i = 0; i <= n; i++)
        //    {
        //        m[i] = Program.ProtobufRead<ModelGamsScalar>(files[i]);
        //    }
        //    m[0].precedents = m[1].precedents;
        //    m[0].dict_FromEqNumberToEqChunkNumber = m[1].dict_FromEqNumberToEqChunkNumber;
        //    m[0].ee = m[1].ee;
        //    m[0].dict_FromEqNameToEqNumber = m[2].dict_FromEqNameToEqNumber;
        //    m[0].aTemp = m[2].aTemp;
        //    m[0].csCodeLines = m[2].csCodeLines;
        //    m[0].dict_FromVarNameToVarNumber = m[3].dict_FromVarNameToVarNumber;
        //    m[0].ddTemp = m[3].ddTemp;
        //    m[0].cc = m[3].cc;
        //    m[0].dependents = m[4].dependents;
        //    m[0].dict_FromVarNumberToVarName = m[4].dict_FromVarNumberToVarName;
        //    m[0].bbTemp = m[5].bbTemp;
        //    m[0].dict_FromEqNumberToEqName = m[5].dict_FromEqNumberToEqName;
        //    Program.model.modelGamsScalar = m[0];
        //}

        public static void WriteParallelModel(int k, string inputFileName, string hash, double hashMs, Model model)
        {
            DateTime t = DateTime.Now;

            bool print = false; if (Globals.runningOnTTComputer) print = true;
            //Note: k+1 because the first list[0] object is very tiny
            string salt = O.CurrentSubperiods().ToString();
            List<string> files = GetSplitCacheFileNames(k + Globals.systemTthreadsExtra + 1, inputFileName, "model", salt, ref hash);  //1 because 1-based, 2 for modelGams and modelGekko
            List<object> lists = ProtobufModelGamsScalar5a(k, model);

            try
            {
                lists.AsParallel().WithExecutionMode(ParallelExecutionMode.ForceParallelism).Select((x, i) =>
                {
                    try
                    {
                        if (File.Exists(files[i])) File.Delete(files[i]);
                    }
                    catch (Exception e)
                    {
                        new Error("Protobuf cache problem (protobuffers). Message: " + e.Message);
                    }
                    try
                    {
                        ProtobufWrite(x, files[i]);
                    }
                    catch (Exception e)
                    {
                        throw;
                    }
                    return true;
                }).All(_ => _);
            }
            catch (Exception e)
            {
                throw;
            }
            finally
            {
                //makes sure stuff is always reverted into model in slot m[0], even if protobuf write fails.
                ProtobufModelGamsScalar5b(Program.options.system_threads, lists);
            }

            List<string> sfiles = new List<string>();
            foreach (string file in files)
            {
                sfiles.Add(G.UpdprtFormat((double)(new FileInfo(file)).Length / 1e6d, 0, false));
            }
            if (print) new Writeln("TTH: Sizes (MB): " + Stringlist.GetListWithCommas(sfiles));

            double milliseconds = (DateTime.Now - t).TotalMilliseconds;
            milliseconds += hashMs;  //else it seems too easy: ReadParallel has already computed MD5
            string s = G.SecondsFormat(milliseconds);
            if (print) new Writeln("TTH: WriteParallelModel: " + s);
        }
        
        /// <summary>
        /// Reads model protobuf files in parallel. Will return null if there is nothing found in cache.
        /// </summary>
        public static Model ReadParallelModelMaybe(string hash)
        {
            bool print = false;
            if (Globals.runningOnTTComputer) print = true;
            DateTime t = DateTime.Now;

            List<string> files = new List<string>();
            List<object> lists = new List<object>();

            string part2 = Globals.gekkoVersion + "_" + "model" + "_" + hash + "_";
            int k = ValidateFileNames(part2);
            if (k == -12345) return null;  //could not find anything useful in cache

            for (int i = 0; i < k; i++)
            {
                files.Add(Globals.localTempFilesLocation + "\\" + Globals.gekkoVersion + "_" + "model" + "_" + hash + "_" + (i + 1) + "of" + k + Globals.cacheExtension);
                lists.Add(new ModelGamsScalar(null));
            }

            //if (print) new Writeln("Serialize (" + k + "): " + G.Seconds(t) + "      hashtime: " + hashTime);
            t = DateTime.Now;

            if (Globals.test_runParallelAsSequential)
            {
                for (int i = 0; i < lists.Count; i++)
                {
                    DateTime t0 = DateTime.Now;
                    string fileName2 = files[i];
                    ModelGamsScalar o = ProtobufRead<ModelGamsScalar>(fileName2);
                    lists[i] = o;
                    new Writeln("Seq" + i + ": " + G.Seconds(t0));
                }
            }
            else
            {
                Parallel.ForEach(lists, () => 0, (x, pls, index, s) =>
                {
                    //See https://github.com/protobuf-net/protobuf-net/issues/668
                    //About double speed on TT pc, compared to no parallel  
                    int i = (int)index;                    
                    object o = null;
                    if (new FileInfo(files[i]).Length == 0)
                    {
                        //happens when the slot is occupied with a ModelNull() object, which has zero contents.
                        o = new ModelNull();
                    }
                    else
                    {
                        if (i <= Program.options.system_threads) o = ProtobufRead<ModelGamsScalar>(files[i]);
                        else if (i == Program.options.system_threads + 1) o = ProtobufRead<ModelCommon>(files[i]);
                        else if (i == Program.options.system_threads + 2) o = ProtobufRead<ModelGams>(files[i]);
                        else if (i == Program.options.system_threads + 3) o = ProtobufRead<ModelGekko>(files[i]);
                    }
                    lists[i] = o;
                    return 0;
                }, _ => { });
            }
            
            return ProtobufModelGamsScalar5b(Program.options.system_threads, lists);
        }

        public static void WriteParallelDatabank(int k, Databank source, string fileName, string hash, double hashMs, ReadInfo readInfo)
        {
            DateTime t = DateTime.Now;
            bool print = false; if (Globals.runningOnTTComputer) print = true;
            
            List<string> files = GetSplitCacheFileNames(k, fileName, "data", null, ref hash);

            List<List<KeyValuePair<string, IVariable>>> lists = new List<List<KeyValuePair<string, IVariable>>>();
            List<TwoInts> twoIntss = new List<TwoInts>();
            for (int i = 0; i < k; i++)
            {
                lists.Add(new List<KeyValuePair<string, IVariable>>());
                twoIntss.Add(new TwoInts(int.MaxValue, int.MinValue));
            }

            lists = SplitVarsInSameSizeParts(source.storage, k, print);

            lists.AsParallel().WithExecutionMode(ParallelExecutionMode.ForceParallelism).Select((x, i) =>
            {
                try
                {
                    if (File.Exists(files[i])) File.Delete(files[i]);
                }
                catch (Exception e)
                {
                    new Error("Protobuf cache problem (protobuffers). Message: " + e.Message);
                }
                ProtobufWrite(x, files[i]);
                return true;
            }).All(_ => _);

            List<string> sfiles = new List<string>();
            foreach (string file in files)
            {
                sfiles.Add(G.UpdprtFormat((double)(new FileInfo(file)).Length / 1e6d, 0, false));
            }

            if (print) new Writeln("TTH: Sizes (MB): " + Stringlist.GetListWithCommas(sfiles));
            //if (print) new Writeln("TTH: Serialize (" + k + "): " + G.Seconds(t) + "      hashtime: " + hashTime);            

            double milliseconds = (DateTime.Now - t).TotalMilliseconds;
            milliseconds += hashMs;  //else it seems too easy: ReadParallel has already computed MD5
            string s = G.SecondsFormat(milliseconds);
            readInfo.note += "Cache write time: " + s + ". ";

        }

        /// <summary>
        /// Makes k files with names [hash]...1of5, ...2of5, etc. If hash==null, it will be calculated and returned.
        /// Type is "data" or "model". If something containg the hash name is present, these files are deleted first.
        /// 
        /// </summary>
        /// <param name="k"></param>
        /// <param name="inputFileNameUsedForHash"></param>
        /// <param name="type"></param>
        /// <param name="hash"></param>
        /// <returns></returns>
        private static List<string> GetSplitCacheFileNames(int k, string inputFileNameUsedForHash, string type, string salt, ref string hash)
        {
            if (hash == null)
            {
                //never happens? When an unseen file is encountered, ReadParallel will have computed the hash to see if it is known.
                //so this is just for double safety.
                hash = Program.GetMD5Hash(null, inputFileNameUsedForHash, salt);
            }

            List<string> files = new List<string>();

            string part2 = Globals.gekkoVersion + "_" + type + "_" + hash + "_";
            string[] hits = Directory.GetFiles(Globals.localTempFilesLocation, part2 + "*" + Globals.cacheExtension);
            foreach (string hit in hits)
            {
                //Clean sheet for this hash
                File.Delete(hit);
            }

            for (int i = 0; i < k; i++)
            {
                files.Add(Globals.localTempFilesLocation + "\\" + part2 + (i + 1) + "of" + k + Globals.cacheExtension);
            }

            return files;
        }

        public static Databank ReadParallelDatabank(string fileName, out int year1, out int year2, out string hash, out double hashMs, ReadInfo readInfo)
        {
            // Test of read of large calib.gdx (176 MB) with different number of splitfiles.
            //
            // 1    6.40
            // 2    4.30
            // 3    3.90
            // 4    3.70
            // 5    3.70
            // ... after this about the same
            //
            // Perhaps with many splitfiles, the lower bound is 3.70 s, but with larger variability.
            // Seems that split = 3 at least. Perhaps the processors+1 rule is ok, therefore 5?
            //
            // When we have a 1of1, just read it without parallel.foreach (same for write).

            bool print = false;
            if (Globals.runningOnTTComputer) print = true;

            year1 = int.MaxValue;
            year2 = int.MinValue;
            DateTime t = DateTime.Now;
            hash = Program.GetMD5Hash(null, fileName, null);
            hashMs = (DateTime.Now - t).TotalMilliseconds;

            List<string> files = new List<string>();
            List<List<KeyValuePair<string, IVariable>>> lists = new List<List<KeyValuePair<string, IVariable>>>();
            List<TwoInts> twoIntss = new List<TwoInts>();

            string part2 = Globals.gekkoVersion + "_" + "data" + "_" + hash + "_";
            int k = ValidateFileNames(part2);
            if (k == -12345) return null;  //could not find anything useful in cache

            for (int i = 0; i < k; i++)
            {
                files.Add(Globals.localTempFilesLocation + "\\" + Globals.gekkoVersion + "_" + "data" + "_" + hash + "_" + (i + 1) + "of" + k + Globals.cacheExtension);
                lists.Add(new List<KeyValuePair<string, IVariable>>());
                twoIntss.Add(new TwoInts(int.MaxValue, int.MinValue));
            }

            //if (print) new Writeln("Serialize (" + k + "): " + G.Seconds(t) + "      hashtime: " + hashTime);
            t = DateTime.Now;

            Parallel.ForEach(lists, () => 0, (x, pls, index, s) =>
            {
                //See https://github.com/protobuf-net/protobuf-net/issues/668
                //About double speed on TT pc, compared to no parallel  

                int i = (int)index;
                string fileName2 = files[i];
                List<KeyValuePair<string, IVariable>> o = ProtobufRead<List<KeyValuePair<string, IVariable>>>(fileName2);
                lists[i] = o;
                TwoInts yearMinMax = twoIntss[i];
                foreach (KeyValuePair<string, IVariable> kvp in lists[i])
                {
                    kvp.Value.DeepCleanup(yearMinMax);  //fixes maps and lists with 0 elements, also binds MultiDim.parent                            
                }
                return 0;
            }, _ => { });

            Databank db = new Databank("temporary");
            DateTime t2 = DateTime.Now;
            foreach (List<KeyValuePair<string, IVariable>> list in lists)
            {
                foreach (KeyValuePair<string, IVariable> kvp in list)
                {
                    db.storage.Add(kvp.Key, kvp.Value);
                }
            }
            lists = null;  //free for GC

            for (int i = 0; i < k; i++)
            {
                if (twoIntss[i].int1 < year1) year1 = twoIntss[i].int1;
                if (twoIntss[i].int2 > year2) year2 = twoIntss[i].int2;
            }

            //if (print) new Writeln("TTH: Deserialize (" + k + "): " + G.Seconds(t) + "     cleanup: " + G.Seconds(t2));
            readInfo.note += "Cache read time: " + G.Seconds(t) + ". ";
            return db;
        }

        public static T ProtobufRead<T>(string fileName2)
        {
            T o;
            using (FileStream fs = WaitForFileStream(fileName2, null, GekkoFileReadOrWrite.Read))
            {
                RuntimeTypeModel serializer = RuntimeTypeModel.Create();
                try
                {
                    o = Serializer.Deserialize<T>(fs);
                }
                catch (Exception e)
                {
                    //Hmmm: this will not abort if Error()
                    new Warning("Technical problem while reading protobuffer file '" + fileName2 + "'. Message: " + e.Message);
                    throw;
                }
            }
            return o;
        }

        private static int ValidateFileNames(string part2)
        {            
            string[] hits = Directory.GetFiles(Globals.localTempFilesLocation, part2 + "*" + Globals.cacheExtension);            
            int k = ValidateFileNames2(part2, hits);
            if (k == -12345)
            {
                //clean up
                foreach (string hit in hits)
                {
                    File.Delete(hit);
                }
            }
            return k;
        }

        private static int ValidateFileNames2(string part2, string[] hits)
        {             
            int i2 = -12345;
            try
            {
                string s = hits[0].Replace(Globals.localTempFilesLocation + "\\" + part2, "").Replace(Globals.cacheExtension, "").Trim();
                int idx = s.IndexOf("of");
                string s2 = s.Substring("of".Length + idx);
                i2 = int.Parse(s2);
            }
            catch
            {
                return -12345;
            }
            if (i2 <= 0) return -12345;
            if (i2 != hits.Length) return -12345;

            for (int i = 0; i < i2; i++)
            {
                if (!hits.Contains(Globals.localTempFilesLocation + "\\" + part2 + (i + 1) + "of" + i2 + Globals.cacheExtension)) return -12345;
            }            
            return i2;  //is -12345 if something is wrong
        }

        /// <summary>
        /// Helper method (hook) for Gekcel. BEWARE: Do not change name or signature without changing in 
        /// Gekcel solution, too!!
        /// </summary>
        /// <param name="xllPath">Note: must be real path, not a path+filename</param>
        //ok that it is not referenced to, is used in Gekcel
        public static void PrepareExcelDna(string xllPath)
        {
            //if (Globals.runningOnTTComputer && File.Exists(@"c:\tools\dnb.txt")) MessageBox.Show("PrepareExcelDna() called with: " + xllPath);
            Globals.excelDna = true;
            Globals.excelDnaPath = xllPath;
        }

        /// <summary>
        /// Helper method (hook) for Gekcel. BEWARE: Do not change name or signature without changing in 
        /// Gekcel solution, too!!
        /// </summary>
        /// <param name="xllPath">Note: must be real path, not a path+filename</param>
        //ok that it is not referenced to, is used in Gekcel
        public static void PrepareExcelDna2(string xllPath, string xlsmPath)
        {
            if (Globals.runningOnTTComputer && File.Exists(@"c:\tools\dnb.txt")) MessageBox.Show("PrepareExcelDna2() called with: " + xllPath + "  -----  " + xlsmPath);

            PrepareExcelDna(xllPath); //necessary for it to run ANTLR etc.          

            string note = null;

            //See similar code used in in GuiStuff(), see: #09785932405
            string desktop = Environment.GetFolderPath(Environment.SpecialFolder.Desktop);
            if (string.IsNullOrEmpty(Program.options.folder_working))
            {
                if (string.IsNullOrEmpty(xlsmPath))
                {
                    //probably happens very rarely
                    Program.options.folder_working = desktop;
                    note = "Gekcel working folder set to desktop folder, because Excel workbook folder could not be located.";
                }
                else
                {
                    try
                    {
                        //Do not use 'using' and G.GekkoStreamWriter() here -- it is just a quick test, and will be caught if it fails!
                        //detects if xlsm file is in read-only folder.
                        Globals.screenOutput = new StreamWriter(xlsmPath + "\\" + Globals.funnyFileName);
                        Program.options.folder_working = xlsmPath;  //seems ok
                    }
                    catch (Exception e)
                    {
                        Program.options.folder_working = desktop;
                        note = "Gekcel working folder set to desktop folder, because Excel workbook folder seems to be read-only.";
                    }
                    Gui.GuiReadOnlyHelper(false);  //delete any funny file
                }
            }

            SetupGekkoForNonGuiUse();

            //The stuff below does not get printed in Gekcel: wonder why?
            if (true)
            {
                if (note != null)
                {
                    //if working folder is set to desktop
                    new Note(note);
                }
                new Writeln(G.GekkoInfo("short4"));
            }
        }

        /// <summary>
        /// Sets some objects up that are necessary when running Gekko without a GUI
        /// </summary>
        private static void SetupGekkoForNonGuiUse()
        {
            //See also #89aos8dbjdfjkdsf
            Program.GetVersionAndGekkoExeLocationFromAssembly();  //goes into Globals.gekkoVersion
            Program.databanks.storage.Clear();
            Program.databanks.storage.Add(new Databank(Globals.Work));
            Program.databanks.storage.Add(new Databank(Globals.Ref));
            Program.databanks.local.Clear();
            Program.databanks.global.Clear();
            Program.databanks.localGlobal = new LocalGlobal();
            Globals.commandMemory = new CommandMemory();
            Globals.gekkoInbuiltFunctions = Program.FindGekkoInbuiltFunctions();
            Program.InitUfunctionsAndArithmeticsAndMore();
            Program.model = new Gekko.Model();
            Program.GetStartingPeriod();
        }

        /// <summary>
        /// s must be of form "var¤-1", multiple Globals.lagIndicator not allowed.
        /// if "var¤-1¤-1", .s1 is ok but .s2 not.
        /// if no Globals.lagIndicator the raw input is returned.
        /// </summary>
        /// <param name="s"></param>
        /// <returns></returns>
        static TwoStrings GetVariableAndLag(String s)
        {
            String var = "";
            String lag = "";
            int find = s.IndexOf(Globals.lagIndicator, 0);
            if (find != -1)
            {
                var = s.Substring(0, find);
                lag = s.Substring(find + 1);
            }
            else
            {
                var = s;
                lag = "0";
            }
            TwoStrings ts = new TwoStrings(var, lag);
            return ts;
        }

        /// <summary>
        /// Reads .csv or .prn format into a TableLight "matrix" of cells.
        /// </summary>
        /// <param name="type"></param>
        /// <param name="file"></param>
        /// <returns></returns>
        public static TableLight ReadCsvPrn(EDataFormat type, string file)
        {
            //everything is stored as strings, no parsing into values... (probably because it is not that simple, comma vs. dot, NaN, etc.)
            //will remove quotes on cells
            //does not handle ';' inside a quoted string

            char delimiter = ';';
            if (G.Equal(Program.options.interface_csv_delimiter, "comma")) delimiter = ',';

            string freqHere = G.ConvertFreq(Program.options.freq);

            FindFileHelper ffh = Program.FindFile(file, null, true, false, null);
            string fullFileNameAndPath = ffh.realPathAndFileName;

            if (fullFileNameAndPath == null)
            {
                if (type == EDataFormat.Csv) new Error("Csv file does not exist");
                else if (type == EDataFormat.Prn) new Error("Prn file does not exist");
            }

            string input = GetTextFromFileWithWait(fullFileNameAndPath);
            List<string> lines = Stringlist.ExtractLinesFromText(input);

            //#98045298375
            TableLight matrix = new TableLight();  //1-based coords. Could perhaps design a more lightweight version of cells for this if memory or speed becomes an issue. Perhaps with basic cell stuff, and then a field pointing to object with alignment etc. Or use inheritance.

            if (type == EDataFormat.Prn)
            {
                string orientation = null;
                List<string> lines2 = new List<string>();
                bool first = true;
                foreach (string s in lines)
                {
                    if (s.Trim() == "") continue;  //ignore empty lines
                    if (s.StartsWith("//")) continue;  //ignore //
                    string[] split = s.Split(new char[] { ' ' }, StringSplitOptions.RemoveEmptyEntries);  //could be variable name with blank such as "ab cd" or something to trim like " abcd", but that is strange/wrong anyway!
                    string line2 = null;
                    foreach (string ss in split)
                    {
                        string ss2 = ss.Trim();  //probably superfluous
                        if (ss2.StartsWith("\""))
                        {
                            if (!ss2.EndsWith("\""))
                            {
                                new Error("Item '" + ss2 + "' seems malformed");
                            }
                            ss2 = ss2.Substring(1, ss2.Length - 2);
                            if (ss2.Contains("\""))
                            {
                                new Error("Item '\"" + ss2 + "\"' seems malformed");
                            }
                        }
                        string s3 = ss2;
                        first = false;
                        line2 += s3 + ";";
                    }
                    lines2.Add(line2);
                }
                lines = lines2;
            }

            int row = 0;
            foreach (string line in lines)
            {
                if (line.Trim() == "") continue;  //ignore blank line
                if (line.StartsWith("//")) continue;  //ignore //
                row++;
                string[] chunks = line.Split(delimiter);
                int col = 0;
                foreach (string s2 in chunks)
                {
                    bool hasQuotes = false;
                    string s = s2.Trim();
                    if (s.StartsWith("'") && s.EndsWith("'"))
                    {
                        s = s.Substring(1, s.Length - 2);
                        hasQuotes = true;
                    }
                    if (s.StartsWith("\"") && s.EndsWith("\""))
                    {
                        s = s.Substring(1, s.Length - 2);
                        hasQuotes = true;
                    }
                    col++;
                    CellLight cell = new CellLight(s, hasQuotes);
                    if (s != "") matrix.Add(row, col, cell);  //no need to keep empty cells in matrix (there can be many such)
                }
            }

            return matrix;
        }

        /// <summary>
        /// This methods uses a TableLight "matrix" of cells, and imports data from it (typically timeseries). The TableLight is obtained either
        /// from a Microsoft Office component (interop, PIA, demaiding Excel to be installed), or from the EPPlus component (that reads any
        /// xlsx file). The data is read as if the rows are names and the cols are dates, and if a transposed sheet is read, the row/cells
        /// of the TableLight matrix are first transposed in the TableLight object itself. There is a lot of functionality related to date
        /// formats, especially if the dates are Excel dates.
        /// </summary>
        /// <param name="data"></param>
        /// <param name="offset"></param>
        /// <param name="oRead"></param>
        /// <param name="databank"></param>
        /// <param name="readInfo"></param>
        /// <param name="dateformat"></param>
        /// <param name="datetype"></param>
        public static void ExtractTimeseriesFromTableLight(TableLight data, CellOffset offset, ReadOpenMulbkHelper oRead, Databank databank, ReadInfo readInfo, string dateformat, string datetype)
        {

            //We could 'taste' the file, but how to distinguish A and U for instance?
            //Perhaps augment READ/IMPORT with freq indication for such files?
            EFreq freqHere = Program.options.freq;

            int rowOffset = 0;  //tested, not implemented in ANTLR yet.
            int colOffset = 0;
            string sheetName = null; //not implemented yet: takes first sheet it finds.

            bool transpose = ShouldTranspose(oRead, data, rowOffset, colOffset);
            TableLight matrix = data;
            if (transpose)
            {
                matrix = data.Transpose();
            }

            bool isFirst = false;
            string format = SplitDateFormatInTwo(dateformat, ref isFirst);

            GekkoTime per1 = GekkoTime.tNull;
            GekkoTime per2 = GekkoTime.tNull;

            int variableCounter = 0;
            string annualIndicator1 = "Y";
            string annualIndicator2 = "A1";

            string[] start = new string[2];
            string[] end = new string[2];

            int i_data, j_data, i_names, j_names, i_dates, j_dates;
            HandleRectangularFileFormatCellOffset(offset, transpose, out i_data, out j_data, out i_names, out j_names, out i_dates, out j_dates);

            int matrixMaxRow = matrix.GetRowMaxNumber();
            int matrixMaxCol = matrix.GetColMaxNumber();

            //Series are running in rows per default, else data is transposed
            //There may be gaps, like this:
            // ..   ..  ..   2001   2002   2003
            // ..   ..  ..    ..     ..     ..
            // ..   x1  ..   100     200    161
            // ..   x2  ..   200     100    132

            // Here, datecell=d1, namecell=b3, cell=d3

            List<GekkoTime> datesInMatrix = new List<GekkoTime>();

            for (int col = j_dates; col <= matrixMaxCol; col++)
            {
                int row = i_dates;

                CellLight cell = matrix.Get(row, col);

                //---------------------
                //DATES ROW
                //---------------------

                //========================================================================================================
                //                          FREQUENCY LOCATION, indicates where to implement more frequencies
                //========================================================================================================
                // There is a lot of date stuff below

                string cellText = null;

                if (cell.type == ECellLightType.String) cellText = cell.text;
                else if (cell.type == ECellLightType.Double) cellText = cell.data.ToString();
                else if (cell.type == ECellLightType.DateTime) cellText = cell.dateTime.ToString();

                if (cellText == null)
                {
                    new Error("In cell " + GetExcelCell(row, col, transpose) + ". This cell should contain a date and not be empty.");
                }

                //The below is only for error messages
                if (col == j_dates)
                {
                    start[0] = cellText;
                    start[1] = GetExcelCell(row, col, transpose);
                }
                if (true)  //made for each date
                {
                    end[0] = cellText;
                    end[1] = GetExcelCell(row, col, transpose);
                }

                string date = cellText;
                date = date.Trim();  //removes blanks at start and end
                date = date.ToLower();  //if q or m (or y)

                GekkoTime gt = new GekkoTime(0, 0, 0); //will not activate .IsNull() == true

                if (G.Equal(datetype, "excel"))
                {
                    if (oRead.Type == EDataFormat.Csv || oRead.Type == EDataFormat.Prn)
                    {
                        //Excel-dates are converted to yyyy-mm-dd when a xlsx is exported to csv.
                        //So this restriction seems sensibl.
                        new Error("You cannot use <datetype='excel'> for .csv or .prn file types");
                    }

                    //this is quite easy, since there is no formatting to worry about.
                    //any dateformat is just ignored, is not relevant since the internal number is exact

                    //must indicate frequency below, since DateTime has no frequency (is a point).
                    if (cell.type == ECellLightType.Double)
                    {
                        gt = GekkoTime.FromDateTimeToGekkoTime(freqHere, GekkoTime.FromExcelDateToDateTime(cell.data));
                    }
                    else if (cell.type == ECellLightType.DateTime)
                    {
                        gt = GekkoTime.FromDateTimeToGekkoTime(freqHere, cell.dateTime);
                    }
                    else
                    {
                        new Error("Cell " + GetExcelCell(row, col, transpose) + ". Could not interpret this date: '" + cell.text + "'. It is supposed to be an Excel date, counting days since January 1, 1900. But Gekko cannot convert it to a value.");
                    }
                }
                else
                {
                    //datetype = text

                    if (IsGekkoDateFormat(format))
                    {
                        //no format given, Gekko date format expected

                        //if freq=a and 2001y, this is treated as integer 2001
                        //if freq=a and 98, this is treated as 1998 (logic of GekkoTime.FromStringToGekkoTime()).
                        //if freq=q and 200102, this is treated as 2001q2
                        //if freq=m and 200102, this is treated as 2001m2
                        //if 20010230, this is always treated as 2001m2d30 (we do not expect undated freq with 8 digits)
                        //data with freq U MUST have "option freq u" set.

                        bool error = false;
                        bool done = false;

                        if ((freqHere == EFreq.A))
                        {
                            if (date.Length == 5 && date.EndsWith(annualIndicator1, true, null))
                            {
                                //remove 'Y' if it is there
                                date = date.Remove(date.Length - 1);
                            }
                        }

                        if (G.IsInteger(date))
                        {
                            // 200102 --> q or m (if Q or M is set)
                            // 20010230 --> daily (always)
                            // undated must have freq U
                            //

                            if (freqHere == EFreq.U)
                            {
                                gt = new GekkoTime(freqHere, int.Parse(date), 1);
                                done = true;
                            }
                            else if (date.Length == 6 && (freqHere == EFreq.Q || freqHere == EFreq.M || freqHere == EFreq.W))
                            {
                                //It might be a date like 199503, that is, 1995q3 or 1995m3 or 1995w3
                                //We have to use the global freq here, how else to know the freq??
                                //Only with freq Q or M
                                gt = new GekkoTime(freqHere, int.Parse(date.Substring(0, 4)), int.Parse(date.Substring(4, 2)), 1);
                                done = true;
                            }
                            else if (date.Length == 8)
                            {
                                //It might be a date like 19950302, that is, 1995m3d2
                                //Always, regardless of global freq, we do not expect U freq data this large
                                gt = new GekkoTime(EFreq.D, int.Parse(date.Substring(0, 4)), int.Parse(date.Substring(4, 2)), int.Parse(date.Substring(6, 2)));
                                done = true;
                            }
                        }

                        if (done)
                        {
                            error = false;
                        }
                        else
                        {
                            gt = GekkoTime.FromStringToGekkoTime(date, true, false);
                            if (gt.IsNull()) error = true;
                        }

                        if (error)
                        {
                            new Error("Cell " + GetExcelCell(row, col, transpose) + ". Could not interpret this date: '" + date + "'. You may want to change the frequency: OPTION freq = ...");
                        }
                    }
                    else
                    {
                        //non-Gekko date format
                        //we have a yyyy-mm-dd-like format that we need to look into
                        DateTime dt = GekkoTime.FromYYYYMMDDToDateTime(format, date);
                        gt = GekkoTime.FromDateTimeToGekkoTime(freqHere, dt);
                    }
                }

                if (readInfo.startPerInFile == -12345) readInfo.startPerInFile = gt.super;
                if (readInfo.endPerInFile == -12345) readInfo.endPerInFile = gt.super;
                else
                {
                    if (gt.super > readInfo.endPerInFile) readInfo.endPerInFile = gt.super;
                }

                if (col == j_dates)
                {
                    per1 = gt;
                }

                if (gt.freq == EFreq.D)  //just test succession
                {
                    if (col > j_dates)
                    {
                        if (!gt.StrictlyLargerThan(per2))
                        {
                            new Error("The date " + gt.ToString() + " is not larger than the previous: " + per2.ToString());
                        }
                    }
                    per2 = gt;
                }
                else //tested for each observation, except for daily obs
                {
                    per2 = gt;
                    int expectedPeriods = GekkoTime.Observations(per1, gt);
                    if (expectedPeriods != (col - j_dates + 1))
                    {
                        new Error("Expected to find " + expectedPeriods + " observations between the periods '" + start[0] + "' (cell " + start[1] + ")" + " and '" + end[0] + "' (cell " + end[1] + ").");
                    }
                }
                datesInMatrix.Add(gt);
            }

            for (int row = i_data; row <= matrixMaxRow; row++)
            //for (int row = 1 + rowOffset; row <= matrixMaxRow; row++)
            {

                Series ts = null;

                for (int col = j_data; col <= matrixMaxCol; col++)
                {

                    CellLight cell = matrix.Get(row, col);


                    if (true)  //data row
                    {
                        //---------------------
                        //DATA ROW
                        //---------------------
                        //`do this only for first data column


                        if (col == j_data)
                        {
                            //-----------------------
                            //VARIABLE NAME
                            //-----------------------

                            ts = GetTimeseriesFromWorkbookMatrixHelper(matrix, databank, freqHere, transpose, ref variableCounter, row, col, j_names);
                        }

                        if (true)
                        {
                            //-----------------------
                            //NUMERIC DATA (rest of row)
                            //-----------------------
                            //Second column and on (data)
                            double d = double.NaN;
                            bool shouldSkip = false;

                            if (cell.type != ECellLightType.None)
                            {
                                if (cell.type == ECellLightType.Double) d = cell.data;
                                else if (cell.type == ECellLightType.String)
                                {
                                    if (IsNonAvailableText(cell.text))
                                    {
                                        d = double.NaN;
                                    }
                                    else if (oRead.Type == EDataFormat.Csv || oRead.Type == EDataFormat.Prn)
                                    {
                                        string s3 = cell.text;
                                        if (G.Equal(Program.options.interface_csv_decimalseparator, "comma"))
                                        {
                                            s3 = s3.Replace(",", ".");  //bit of a hack, will not handle 1.500,75   (--> 1500.75)
                                        }
                                        try
                                        {
                                            d = G.ParseIntoDouble(s3);
                                        }
                                        catch
                                        {
                                            using (Error e = new Error())
                                            {
                                                e.MainAdd("Cell " + GetExcelCell(row, col, transpose) + ". Could not parse '" + s3 + "' as a number");
                                                e.MainNewLine();
                                                e.MainAdd("Note: You may change separator: OPTION interface csv decimalseparator");
                                                if (s3.Trim() == ".")
                                                {
                                                    e.MainAdd("Note: You cannot use dot ('.') to indicate missing value, use M or NA instead");
                                                }
                                            }
                                        }
                                    }
                                    else
                                    {
                                        //must be xls or xlsx, and not #n/a or the like
                                        using (Error txt = new Error())
                                        {
                                            txt.MainAdd("In spreadsheet cell " + GetExcelCell(row, col, transpose) + ", content: '" + cell.text + "'. ");
                                            txt.MoreAdd(ExcelTypeError());
                                        }
                                    }
                                }
                            }
                            else
                            {
                                shouldSkip = true;  //empty cell
                            }

                            if (!shouldSkip)
                            {
                                if (d == 1e+15d)  //we use this as code for missing, as in AREMOS.
                                {
                                    d = double.NaN;
                                }
                                ts.SetData(datesInMatrix[col - j_data], d);
                            }
                        }
                        if (ts != null) ts.Trim(); //to save ram
                    }

                }
            }
            //See almost identical code in readTsd and readPcim and readTsp...
            readInfo.variables = variableCounter;
            if (oRead.Merge)
            {
                readInfo.startPerResultingBank = G.GekkoMin(readInfo.startPerInFile, databank.yearStart);
                readInfo.endPerResultingBank = G.GekkoMax(readInfo.endPerInFile, databank.yearEnd);
            }
            else
            {
                readInfo.startPerResultingBank = readInfo.startPerInFile;
                readInfo.endPerResultingBank = readInfo.endPerInFile;
            }
        }

        /// <summary>
        /// Helper method for GetTimeseriesFromWorkbookMatrix() that reads one timeseries from a TableLight.
        /// </summary>
        /// <param name="data"></param>
        /// <param name="databank"></param>
        /// <param name="freqHere"></param>
        /// <param name="transpose"></param>
        /// <param name="variableCounter"></param>
        /// <param name="row"></param>
        /// <param name="col"></param>
        /// <param name="j_cellnames"></param>
        /// <returns></returns>
        private static Series GetTimeseriesFromWorkbookMatrixHelper(TableLight data, Databank databank, EFreq freqHere, bool transpose, ref int variableCounter, int row, int col, int j_cellnames)
        {
            Series ts;

            CellLight cell = data.Get(row, j_cellnames);

            string cellText = null;

            if (cell.type != ECellLightType.None)
            {
                if (cell.type == ECellLightType.String) cellText = cell.text;
                else if (cell.type == ECellLightType.Double)
                {
                    new Error("In spreadsheet cell " + GetExcelCell(row, col, transpose) + ". This cell is a value: expected a variable name.");
                }
            }

            if (cellText == null)
            {
                new Error("In spreadsheet cell " + GetExcelCell(row, col, transpose) + ". This cell should contain a variable name and not be empty.");
            }

            string varName = cellText.Trim();  //the name may contain blanks like 'elveff '
            varName = G.Chop_AddFreq(varName, Program.options.freq);
            variableCounter++;
            if (!databank.ContainsIVariable(varName))
            {
                Series data2 = new Series(freqHere, varName);
                databank.AddIVariable(varName, data2);
                ts = data2;
            }
            else
            {
                ts = databank.GetIVariable(varName, true) as Series;
            }

            return ts;
        }

        /// <summary>
        /// Helper method
        /// </summary>
        /// <param name="format"></param>
        /// <returns></returns>
        private static bool IsGekkoDateFormat(string format)
        {
            return format == null || G.Equal(format, "gekko");
        }

        /// <summary>
        /// Overload
        /// </summary>
        /// <param name="text"></param>
        /// <returns></returns>
        private static bool IsNonAvailableText(string text)
        {
            return IsNonAvailableText(text, true);
        }

        /// <summary>
        /// For Excel cells, checks it these have "missing values"
        /// </summary>
        /// <param name="text"></param>
        /// <param name="alsoMAndNa"></param>
        /// <returns></returns>
        private static bool IsNonAvailableText(string text, bool alsoMAndNa)
        {
            //the last ones are the Danish codes
            //the M is Gekko standard for missing value, NA is also allowed, both also with "".
            bool isNonAvailableText = false;
            if (alsoMAndNa)
            {
                if (G.Equal(text, "M") || G.Equal(text, "\"M\"") || G.Equal(text, "NA") || G.Equal(text, "\"NA\"")) isNonAvailableText = true;
            }
            if (G.Equal(text, "#N/A") || G.Equal(text, "#NAME?") || G.Equal(text, "#I/T") || G.Equal(text, "#NAVN?")) isNonAvailableText = true;
            return isNonAvailableText;
        }

        /// <summary>
        /// Whether the data should be transposed
        /// </summary>
        /// <param name="oRead"></param>
        /// <param name="matrix2"></param>
        /// <param name="rowOffset"></param>
        /// <param name="colOffset"></param>
        /// <returns></returns>
        private static bool ShouldTranspose(ReadOpenMulbkHelper oRead, TableLight matrix2, int rowOffset, int colOffset)
        {
            bool transpose = false;
            if (G.Equal(oRead.Orientation, "cols")) transpose = true;  //we assume ROWS is default (logical for databanks with more series than observations)
            if (oRead.Type == EDataFormat.Prn)
            {
                CellLight cellA1 = matrix2.Get(1 + rowOffset, 1 + colOffset);
                if (cellA1.type == ECellLightType.None)
                {
                    new Error("No data in position A1");
                    //throw new GekkoException();
                }
                transpose = HandlePrnFirstElement(cellA1, rowOffset, colOffset, matrix2);
            }
            return transpose;
        }

        /// <summary>
        /// Special handling for .prn files
        /// </summary>
        /// <param name="cell"></param>
        /// <param name="rowOffset"></param>
        /// <param name="colOffset"></param>
        /// <param name="matrix"></param>
        /// <returns></returns>
        private static bool HandlePrnFirstElement(CellLight cell, int rowOffset, int colOffset, TableLight matrix)
        {
            bool transpose = false;
            if (cell.type != ECellLightType.String)
            {
                new Error("Expected 'date' or 'name' as first element in prn file");
                //throw new GekkoException();
            }
            if (G.Equal(cell.text.Trim(), "date")) transpose = true; //corresponds to READ<csv cols>, timeseries are in columns.
            else if (G.Equal(cell.text.Trim(), "name")) transpose = false; //corresponds to READ<csv>, timeseries are in rows.
            else
            {
                new Error("Expected 'date' or 'name' as first element in prn file");
                //throw new GekkoException();
            }

            return transpose;
        }

        /// <summary>
        /// Helper for Excel coordinates
        /// </summary>
        /// <param name="row"></param>
        /// <param name="col"></param>
        /// <param name="transpose"></param>
        /// <returns></returns>
        private static string GetExcelCell(int row, int col, bool transpose)
        {
            string coord = null;
            if (!transpose)
            {
                coord = GetExcelColumnName(col) + row.ToString();
            }
            else
            {
                coord = GetExcelColumnName(row) + col.ToString();
            }
            return coord;
        }

        /// <summary>
        /// This is the main entry method for both READ/IMPORT and OPEN. A lot of the internals of READ versus OPEN is the same. Note that the READ and
        /// IMPORT commands are really 99% identical, it is mostly a name difference. The method will transfer data from an external file into a 
        /// Gekko databank. To do this, all data is first read into the databankTemp, and subsequently it may be merged in differnt ways, if it is 
        /// a READ/IMPORT command.
        /// </summary>
        /// <param name="offset"></param>
        /// <param name="wipeDatabankBeforeInsertingData"></param>
        /// <param name="oRead"></param>
        /// <param name="open"></param>
        /// <param name="readInfos"></param>
        /// <param name="create"></param>
        public static void OpenOrRead(CellOffset offset, bool wipeDatabankBeforeInsertingData, ReadOpenMulbkHelper oRead, bool open, List<ReadInfo> readInfos, bool create, P p)
        {
            //open = true if called with OPEN command              


            int n = 1;
            List<int> list = new List<int>();
            if (open)
            {
                CheckOpenSyntax(oRead);  //checks for * etc.
                n = oRead.openFileNames.Count;
                if (n > 1)
                {
                    if (oRead.openType == EOpenType.Edit)
                    {
                        new Error("OPEN<edit> must be used with 1 databank");
                        //throw new GekkoException();
                    }
                    else if (oRead.openType == EOpenType.Ref)
                    {
                        new Error("OPEN<ref> must be used with 1 databank");
                        //throw new GekkoException();
                    }
                }
                if (Program.databanks.ShouldPutBankLast(oRead.openType, oRead.openTypePosition))
                {
                    for (int i = 0; i < n; i++)
                    {
                        list.Add(i);
                    }
                }
                else
                {
                    for (int i = n - 1; i >= 0; i--)
                    {
                        list.Add(i);
                    }
                }
            }
            else
            {
                //READ or IMPORT has only 1 bank
                list.Add(1);
            }

            foreach (int i in list)
            {
                ReadInfo readInfo = new ReadInfo();

                string localFileThatShouldBeDeletedPathAndFilename = null;

                string file = null;
                string as2 = null;
                if (open)
                {
                    file = G.StripQuotes(oRead.openFileNames[i][0]);
                    as2 = oRead.openFileNames[i][1];
                    if (as2 == "") as2 = null;
                }
                else
                {
                    file = G.StripQuotes(oRead.FileName);
                    as2 = oRead.As;
                }

                string originalFileName = file;

                if (Globals.pink && originalFileName != null && (originalFileName.ToLower().Contains("g:\\datopgek\\") || originalFileName.ToLower().Contains("g:/datopgek/")))
                {
                    Globals.datopgek_errors.Add("OPEN/READ/IMPORT of this file: " + originalFileName);
                }

                bool isGbk = true;
                //bool isProtobuf = false;
                string extension = "" + Globals.extensionDatabank + "";

                if (oRead.Type == EDataFormat.Tsd)  //overrules any global settings
                {
                    isGbk = false;
                    extension = "tsd";
                }
                if (oRead.Type == EDataFormat.Gbk)  //overrules any global settings
                {
                    isGbk = true;
                    extension = "" + Globals.extensionDatabank + "";
                }
                if (oRead.Type == EDataFormat.Tsdx)  //overrules any global settings
                {
                    isGbk = true;
                    extension = "tsdx";
                }
                if (oRead.Type == EDataFormat.Tsp)  //overrules any global settings
                {
                    isGbk = false;
                    extension = "tsp";
                }
                if (oRead.Type == EDataFormat.Csv)
                {
                    extension = "csv";
                    isGbk = false;
                }
                if (oRead.Type == EDataFormat.Prn)
                {
                    extension = "prn";
                    isGbk = false;
                }
                if (oRead.Type == EDataFormat.Flat)
                {
                    extension = "flat";
                    isGbk = false;
                }
                if (oRead.Type == EDataFormat.Aremos)
                {
                    extension = "aremos";
                    isGbk = false;
                }
                if (oRead.Type == EDataFormat.Xls)
                {
                    extension = "xls";
                    isGbk = false;
                }
                if (oRead.Type == EDataFormat.Xlsx)
                {
                    extension = "xlsx";
                    isGbk = false;
                }
                if (oRead.Type == EDataFormat.Pcim)
                {
                    extension = "bnk";
                    isGbk = false;
                }
                if (oRead.Type == EDataFormat.Gdx)
                {
                    extension = "gdx";
                    isGbk = false;
                }
                if (oRead.Type == EDataFormat.Px)
                {
                    extension = "px";
                    isGbk = false;
                }

                string originalFileNameWithExtension = G.AddExtension(originalFileName, "." + extension);  //just for error messages

                // ---------------------------------------------------------------------------------
                //                  Start of categories
                // ---------------------------------------------------------------------------------

                //                   +---------------------------+---------------------------------+                
                //                   |       fileExists          |         file does not exist     |
                // ------------------+---------------------------+---------------------------------+
                //                   |                                                             |
                //  alreadyOpen      |              move existing bank around                      |
                //                   |                                                             |
                // ----------------------------------------------+---------------------------------+
                //                   |                           |                                 |
                //  not already open |  read into position       |  fail unless OPEN<edit/create>  |
                //                   |   maybe editable          |      createBrandNew             |
                // ------------------+---------------------------+---------------------------------+
                //
                // Note: regarding databank name there is the complication that this may given as '*'
                //       and also that ... AS ... may be used. In general, the resulting 'real' databank
                //       name (not file name) as shown in the F2 window is readInfo.dbName

                bool cancel = false;
                FindFileHelper ffh = ReadHelper(file, ref cancel, extension, p);
                file = ffh.realPathAndFileName;

                if (cancel)
                {
                    readInfo.abortedStar = true;
                    return;  //from READ * cancelling
                }
                bool category2_fileExists = false;
                if (file == null)
                {
                    readInfo.dbName = Path.GetFileNameWithoutExtension(originalFileName);
                }
                else
                {
                    readInfo.dbName = Path.GetFileNameWithoutExtension(ffh.prettyPathAndFileName);
                    category2_fileExists = true;
                }
                if (as2 != null && as2.Trim() != "*")
                {
                    //overrides in all cases (except OPEN a AS *), if the name is explicitly given with AS                  
                    readInfo.dbName = as2;
                }

                // -----
                // -----

                int existI; int workI; int refI;
                Databanks.FindBanksI(readInfo.dbName, out existI, out workI, out refI);
                bool category1_alreadyOpen = false;
                if (existI != -12345)
                {
                    category1_alreadyOpen = true;
                }

                // -----
                // -----

                bool category3_createBrandNew = false;
                if (open && !category2_fileExists && !category1_alreadyOpen)
                {
                    if (oRead.editable)
                    {
                        category3_createBrandNew = true;
                    }
                    else
                    {
                        if (create)
                        {
                            category3_createBrandNew = true;
                        }
                        else
                        {
                            new Error("OPEN: The databank '" + originalFileNameWithExtension + "' could not be found (see OPEN<create> if this is intentional).");
                            //throw new GekkoException();
                        }
                    }
                }

                // ---------------------------------------------------------------------------------
                //                  End of categories
                // ---------------------------------------------------------------------------------

                if (file == null)
                {
                    if (!Globals.excelDna)  //because we Gekcel-cheat with IMPORT<xlsx>, so file == null, but should not report an error here
                    {
                        if (!open)
                        {
                            new Error("OPEN: The databank '" + originalFileNameWithExtension + "' could not be found");
                        }
                    }
                }

                if (as2 != null && as2 == "*") as2 = readInfo.dbName;    //With READ * TO *, as2 will be '*'. In that case, we use the filename. This will only happen regarding READ, we do not have an OPEN * AS * (would not be useful, OPEN * would do exactly the same)
                if (as2 != null) readInfo.dbName = as2;

                DateTime dt1 = DateTime.Now;

                string originalFilePath = file;

                string tsdxFile = null;
                string tempTsdxPath = null;

                int NaNCounter = 0;

                bool copyLocal = Program.options.databank_file_copylocal;

                readInfo.fileName = file; readInfo.fileNamePretty = ffh.prettyPathAndFileName;

                Databank databank = null;

                //if (nonExistingGbkFileOpened) readInfo.type = EReadInfoTypes.NonExistingGbkFileOpened;

                Databank databankTemp = null;  //temp bank where the external file is read into

                // ---------------------------------------------------------------------------------
                //                  Read the file into databankTemp
                // ---------------------------------------------------------------------------------

                string hash = null;

                if (!open || (open && !category1_alreadyOpen && category2_fileExists))
                {
                    if (copyLocal && !Globals.excelDna)
                    {
                        //TODO
                        //TODO
                        //TODO copying is a waste of time if we have a zip path, no?
                        //TODO
                        //TODO

                        DateTime t0 = DateTime.Now;
                        localFileThatShouldBeDeletedPathAndFilename = GetTempTsdFilePath(extension);
                        WaitForFileCopy(file, localFileThatShouldBeDeletedPathAndFilename);
                        G.WritelnGray("Local copying: " + G.SecondsFormat((DateTime.Now - t0).TotalMilliseconds));
                        file = localFileThatShouldBeDeletedPathAndFilename;
                    }

                    databankTemp = GetDatabankFromFile(offset, oRead, readInfo, file, originalFilePath, ffh.prettyPathAndFileName, oRead.dateformat, oRead.datetype, ref tsdxFile, ref tempTsdxPath, ref NaNCounter);
                    if (open)
                    {
                        if (!file.Contains(Globals.isAProto))  //probably does not happen anymore
                        {
                            hash = Program.GetMD5Hash(GetTextFromFileWithWait(file), null, null);
                        }
                    }
                }
                else
                {
                    //open && readInfo.type != EReadInfoTypes.Normal
                    databankTemp = null; //already so, but just to state it here
                }

                // ---------------------------------------------------------------------------------
                //                  Now handle READ/IMPORT or OPEN
                // ---------------------------------------------------------------------------------

                if (open)
                {
                    // -----------------------
                    //OPEN or READ...TO...
                    // -----------------------

                    databank = Program.databanks.OpenDatabankNew(readInfo.dbName, databankTemp, oRead.openType, oRead.openTypePosition, existI, workI, refI, create); //puts it in storage[2], returns bool that says if it is just moved around in databank list, or freshly read from file                                                                
                    databank.editable = false;
                    if (oRead.openType == EOpenType.Edit) databank.editable = true;
                    databank.name = readInfo.dbName;
                }
                else
                {
                    // -----------------------
                    //READ/IMPORT
                    // -----------------------

                    // ----------------------
                    //READ or IMPORT, puts data into First or Ref
                    // ----------------------
                    AllFreqsHelper dates = null;
                    if (!oRead.t1.IsNull() && oRead.t1.freq == EFreq.U)
                    {
                        new Error("Date-truncation not yet implemented for undated frequency.");
                    }
                    else
                    {
                        dates = G.ConvertDateFreqsToAllFreqs(oRead.t1, oRead.t2);  //returns null if no truncation
                    }

                    //READ or READ<first>
                    databank = Program.databanks.GetFirst();
                    if (oRead.openType == EOpenType.Ref) databank = Program.databanks.GetRef();

                    //TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO 
                    //TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO 
                    //TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO 
                    //
                    // when it is a simple read or import into an empty bank
                    // and there is not time-truncation, just set dataBank = dataBankTemp
                    //
                    //TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO 
                    //TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO 
                    //TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO 

                    if (wipeDatabankBeforeInsertingData)
                    {
                        databank.Clear();
                    }

                    if (false && dates == null)
                    {
                        //foreach (KeyValuePair<string, IVariable> kvp in databankTemp.storage)
                        //{
                        //    if (databank.ContainsIVariable(kvp.Key)) databank.RemoveIVariable(kvp.Key);
                        //    IVariable iv = kvp.Value;
                        //    databank.AddIVariable(kvp.Key, iv); //no need to deep clone kvp.Value
                        //}
                    }
                    else
                    {
                        //Cannot do a simple deflate in this case: has to move stuff from deflated file into existing first databank

                        //
                        // ------ WORK ----------            ------ FILE ---------
                        //
                        //           x1     x2                  x1      x3
                        //
                        // 2000       2                                1000
                        // 2001       3     100                 10     2000
                        // 2002       4     200                 11
                        // 2003             300                 12
                        //                    
                        // We merge in the two dimensions:
                        //
                        // ------ WORK ----------        
                        //
                        //           x1     x2     x3       
                        //
                        // 2000       2            1000     
                        // 2001      10     100    2000  
                        // 2002      11     200          
                        // 2003      12     300          
                        //
                        // If non-series or array-series, just replace any File object already in Work (never mind time truncation)
                        // SERIES: Easy copy if series is not in Work (x3)
                        // SERIES: If in Work, only inject over the overlap of date period and series data period)
                        // ARRAYSERIES: do as above, just for these subseries
                        //            

                        int maxYearInProtobufFile = -12345;
                        int minYearInProtobufFile = -12345;

                        foreach (KeyValuePair<string, IVariable> kvp in databankTemp.storage)  //for each ivar in temp databank 
                        {
                            string name = kvp.Key;
                            IVariable iv = kvp.Value;

                            if (iv.Type() == EVariableType.Series)
                            {
                                //NOTE: we only time-truncate series and array-series at the direct level, not series inside lists, maps etc.

                                Series tsExisting = GetTsExisting(databank, name);  //may be null
                                Series tsProtobuf = iv as Series;  //cannot be null

                                if (tsProtobuf.type == ESeriesType.ArraySuper)
                                {
                                    //---------------------------
                                    // handle array-timeseries
                                    //---------------------------

                                    if (tsExisting == null)
                                    {
                                        databank.AddIVariable(name, tsProtobuf); //the sub-timeseries will follow automatically!
                                    }
                                    else
                                    {
                                        if (tsExisting.dimensions == tsProtobuf.dimensions)
                                        {
                                            //now, we have same-name and same-dim array-timeseries in both Work and protobuf file.
                                            Multidim gmapExisting = tsExisting.dimensionsStorage;
                                            Multidim gmapProtobuf = tsProtobuf.dimensionsStorage;

                                            foreach (KeyValuePair<MultidimItem, IVariable> kvpGmap in gmapProtobuf.storage)
                                            {
                                                MultidimItem nameDimProtobuf = kvpGmap.Key;
                                                Series tsDimProtobuf = kvp.Value as Series;  //must be timeseries, no need to check that the type is so

                                                IVariable ivDimExisting = null; gmapExisting.TryGetValue(nameDimProtobuf, out ivDimExisting);
                                                Series tsDimExisting = null; if (ivDimExisting != null) tsDimExisting = ivDimExisting as Series;

                                                //now we have a tsDimProtobuf, and if tsDimExisting != null, we merge the data

                                                if (tsDimExisting == null)
                                                {
                                                    //add this sub-series to the array-timeseries                                   
                                                    tsProtobuf.Truncate(dates);
                                                    gmapProtobuf.AddIVariableWithOverwrite(nameDimProtobuf, tsProtobuf);
                                                }
                                                else
                                                {
                                                    //now we need to merge the two series
                                                    //also see #98520983
                                                    bool shouldOverwriteLaterOn = false;
                                                    MergeTwoTimeseriesWithDateWindow(dates, tsExisting, tsProtobuf, ref maxYearInProtobufFile, ref minYearInProtobufFile, ref shouldOverwriteLaterOn);
                                                    MergeTwoTimeseriesWithDateWindowHelper(dates, gmapExisting, nameDimProtobuf, tsProtobuf, shouldOverwriteLaterOn);
                                                }
                                            }
                                        }
                                        else
                                        {
                                            //dimensions do not match, wipt existing out!
                                            databank.AddIVariableWithOverwrite(name, tsProtobuf);  //the sub-timeseries will follow automatically!
                                        }
                                    }
                                }
                                else
                                {
                                    //---------------------------
                                    // handle normal timeseries
                                    //---------------------------

                                    //also see #98520983
                                    bool wipeExistingOut = false;
                                    MergeTwoTimeseriesWithDateWindow(dates, tsExisting, tsProtobuf, ref maxYearInProtobufFile, ref minYearInProtobufFile, ref wipeExistingOut);
                                    MergeTwoTimeseriesWithDateWindowHelper(dates, databank, name, tsProtobuf, wipeExistingOut);
                                }
                            }
                            else
                            {
                                //Non-series
                                //Easy: string, val, date, list, map, matrix
                                databank.AddIVariableWithOverwrite(name, iv);
                            }
                        }

                    }
                    databank.FileNameWithPath = databankTemp.FileNameWithPath; databank.FileNameWithPathPretty = databankTemp.FileNameWithPathPretty;

                }

                HandleCleanAndParentForTimeseries(databank, oRead.Merge);  //otherwise it will look dirty                    

                if (Program.options.solve_data_create_auto == true)
                {
                    string freq = G.ConvertFreq(Program.options.freq);

                    if (!open && (oRead.openType == EOpenType.First || oRead.openType == EOpenType.Normal))  //READ or READ<first>
                    {
                        IVariable all = Program.databanks.GetGlobal().GetIVariable("#all");
                        if (all != null)
                        {
                            List all_list = all as List;
                            if (all_list != null)
                            {
                                foreach (IVariable iv in all_list.list)
                                {
                                    ScalarString ss = iv as ScalarString;
                                    if (ss == null) continue;
                                    string s = ss.string2;
                                    string s2 = G.Chop_GetName(s);
                                    //This will create them if no already there
                                    IVariable iv2 = O.GetIVariableFromString(O.UnChop(Globals.First.ToLower(), s2, freq, null), O.ECreatePossibilities.Can);
                                    IVariable iv3 = O.GetIVariableFromString(O.UnChop(Globals.Ref.ToLower(), s2, freq, null), O.ECreatePossibilities.Can);
                                }
                            }
                        }
                    }
                }

                //Cleanup of local files
                if (copyLocal && !Globals.excelDna)
                {
                    if (true)
                    {
                        try
                        {
                            File.SetAttributes(localFileThatShouldBeDeletedPathAndFilename, FileAttributes.Normal);  //it may be read-only if original file is so
                            File.Delete(localFileThatShouldBeDeletedPathAndFilename);  //hmm probably best not to use WaitForFileDelete() here, since it seems it is ok if delete fails here
                        }
                        catch (Exception e)
                        {
                            //do nothing
                        }
                    }

                    if (isGbk)
                    {

                        try
                        {
                            File.SetAttributes(tsdxFile, FileAttributes.Normal);  //it may be read-only if original file is so
                            File.Delete(tsdxFile);  //hmm probably best not to use WaitForFileDelete() here, since it seems it is ok if delete fails here
                        }
                        catch (Exception e)
                        {
                            //do nothing
                        }

                        try
                        {
                            DirectoryInfo folderInfo = new DirectoryInfo(tempTsdxPath);
                            if (System.IO.Directory.Exists(folderInfo.FullName))
                            {
                                System.IO.Directory.Delete(folderInfo.FullName, true);
                            }
                        }
                        catch (Exception e)
                        {
                            //do nothing
                        }
                    }
                }

                readInfo.time = (DateTime.Now - dt1).TotalMilliseconds;

                databank.info1 = readInfo.info1;
                databank.date = readInfo.date;
                databank.FileNameWithPath = readInfo.fileName; databank.FileNameWithPathPretty = readInfo.fileNamePretty;

                if (open)
                {
                    if (!oRead.editable)
                    {
                        databank.editable = false;
                    }
                    else
                    {
                        if (!isGbk)
                        {
                            if (databank.editable == true)
                            {
                                G.Writeln2("The file is opened as non-editable, since it is not a ." + Globals.extensionDatabank + " file");
                                databank.editable = false;
                            }
                        }
                    }
                }
                readInfo.databank = databank;
                readInfos.Add(readInfo);

                //databank.Trim();  //This way, the bank is not too bulky in RAM. The operation takes almost no time, and if it is a .tsdx file, the timeseries are already trimmed and trimming is hence skipped.
                //databank.readInfo = readInfo;  //Not really used at the moment, but practical to have a pointer to this information!                

                if (open)
                {
                    if (category3_createBrandNew)
                    {
                        databank.fileHash = Globals.brandNewFile; //signifies that the bank is brand new
                        databank.FileNameWithPath = Program.CreateFullPathAndFileName(originalFileNameWithExtension); databank.FileNameWithPathPretty = ffh.prettyPathAndFileName;
                    }
                    else
                    {
                        if (category2_fileExists && !category1_alreadyOpen)
                        {
                            if (hash != null) databank.fileHash = hash; //typically the MD5 has already been done on the copylocal temp file
                            else databank.fileHash = Program.GetMD5Hash(GetTextFromFileWithWait(databank.FileNameWithPath), null, null);
                        }
                    }
                }
            }  //for each bank in list

            return;
        }

        /// <summary>
        /// Used in OpenOrRead() to get a databankTemp. This is where the actual reading of the external databank file takes place.
        /// </summary>
        /// <param name="offset"></param>
        /// <param name="oRead"></param>
        /// <param name="readInfo"></param>
        /// <param name="file">The "real" system path and filename</param>
        /// <param name="originalFilePath">Often "funny", if the file is fetched inside a zip file. Do not use.</param>
        /// <param name="originalFilePathPretty">This is the file name used for reporting to the user</param>
        /// <param name="dateformat"></param>
        /// <param name="datetype"></param>
        /// <param name="tsdxFile"></param>
        /// <param name="tempTsdxPath"></param>
        /// <param name="NaNCounter"></param>
        /// <returns></returns>
        public static Databank GetDatabankFromFile(CellOffset offset, ReadOpenMulbkHelper oRead, ReadInfo readInfo, string file, string originalFilePath, string originalFilePathPretty, string dateformat, string datetype, ref string tsdxFile, ref string tempTsdxPath, ref int NaNCounter)
        {
            string fileRemember = file;  //because file may change when reading
            long fileRememberSize = new FileInfo(fileRemember).Length;
            
            //note: file is altered below, not sure why
            //file is the "real" system filepath and filename.
            //When we get here, the file is typically already copied (copylocal option)

            //
            //
            // !!!!!!!!!!! what about the xml file inside a gbk??
            // !!!!!!!!!!! maybe store it separately in cache as a normal file
            //
            //

            Databank databankTemp = new Databank("temporary"); //doing it like this, merging is much easier

            //first we (may) look in the protobuffer cache, to see if there is a hit.

            string hash = null;  //may be set via ReadParallel, to be reused by WriteParallel to avoid double work
            double hashMs = double.NaN;

            bool cache_loadedFromProtobuf = false;            
            if (MayUseDatabankCache(oRead.Type, fileRememberSize))
            {
                int year1, year2;
                Databank databankTemp2 = ReadParallelDatabank(fileRemember, out year1, out year2, out hash, out hashMs, readInfo);
                if (year1 == int.MaxValue) year1 = -12345;
                if (year2 == int.MinValue) year2 = -12345;

                if (databankTemp2 == null)
                {
                    //do nothing, we then have to parse the file
                }
                else
                {
                    cache_loadedFromProtobuf = true;
                    databankTemp = databankTemp2;  //also has the name "temporary" but this is not important
                    readInfo.startPerInFile = year1;
                    readInfo.endPerInFile = year2;
                    readInfo.variables = databankTemp2.storage.Count;
                }
            }

            if (cache_loadedFromProtobuf)
            {
                //do nothing, also no writing of cache file of course
            }
            else
            {
                if (true)  //read it the hard way
                {
                    if (oRead.Type == EDataFormat.Pcim)
                    {
                        Program.ReadPCIM(databankTemp, readInfo, file);
                    }
                    else if (oRead.Type == EDataFormat.Csv || oRead.Type == EDataFormat.Prn || oRead.Type == EDataFormat.Xls || oRead.Type == EDataFormat.Xlsx)
                    {
                        Read2DCells_csv_prn_xlsx(offset, oRead, readInfo, file, databankTemp, originalFilePath, originalFilePathPretty, dateformat, datetype);
                    }
                    else if (oRead.Type == EDataFormat.Tsd)
                    {
                        ReadTsd(oRead, readInfo, ref file, ref databankTemp, originalFilePath, originalFilePathPretty, ref NaNCounter);
                    }
                    else if (oRead.Type == EDataFormat.Tsd || oRead.Type == EDataFormat.Tsdx || oRead.Type == EDataFormat.Gbk || oRead.Type == EDataFormat.None)
                    {
                        ReadGbk(oRead, readInfo, ref file, ref databankTemp, originalFilePath, originalFilePathPretty, ref tsdxFile, ref tempTsdxPath);
                    }
                    else if (oRead.Type == EDataFormat.Tsp)
                    {
                        TspUtilities.tspDataUtility(file, databankTemp, oRead, readInfo);
                    }
                    else if (oRead.Type == EDataFormat.Gdx)
                    {
                        GamsData.ReadGdx(databankTemp, readInfo, file);
                    }
                    else if (oRead.Type == EDataFormat.Px)
                    {
                        Program.ReadPxHelper(databankTemp, oRead, readInfo, file);
                    }
                    else if (oRead.Type == EDataFormat.Flat)
                    {
                        Program.ReadFlat(databankTemp, readInfo, file);
                    }
                    else if (oRead.Type == EDataFormat.Aremos)
                    {
                        Program.ReadAremos(databankTemp, readInfo, file);
                    }
                    else
                    {
                        new Error("#78632432");
                    }
                }

                if (MayUseDatabankCache(oRead.Type, fileRememberSize))
                {
                    try //not the end of world if it fails
                    {                        
                        WriteParallelDatabank(Program.options.system_threads, databankTemp, fileRemember, hash, hashMs, readInfo);
                    }
                    catch (Exception e)
                    {
                        //do nothing, not the end of the world if it fails
                    }
                }
            }
                                                                    
            return databankTemp;
        }

        /// <summary>
        /// True if options.databank_file_cache == "all", or if file type is != gbk and 
        /// options.databank_file_cache == "nongbk"
        /// </summary>
        /// <param name="oRead"></param>
        /// <returns></returns>
        private static bool MayUseDatabankCache(EDataFormat type, long bytes)
        {
            //Only allows the typical "bulk" formats. The 2D formats are fishy: what about 
            //offset and transpose?

            bool gbk = type == EDataFormat.Gbk || type == EDataFormat.None;
            bool nonGbk = type == EDataFormat.Tsd || type == EDataFormat.Tsdx || type == EDataFormat.Gdx || type == EDataFormat.Px || type == EDataFormat.Flat;

            if (Program.options.databank_file_cache == "all")
            {
                if ((gbk && bytes > Globals.cacheSize2) || (nonGbk && bytes > Globals.cacheSize1)) return true;
            }
            else if (Program.options.databank_file_cache == "nongbk")
            {
                if (nonGbk && bytes > Globals.cacheSize1) return true;
            }            
            return false;
        }

        /// <summary>
        /// Helper for OPEN command
        /// </summary>
        /// <param name="oRead"></param>
        private static void CheckOpenSyntax(ReadOpenMulbkHelper oRead)
        {
            int counter = 0;
            foreach (List<string> ss in oRead.openFileNames)
            {
                if (ss[0] == "*") counter++;
            }
            if (counter >= 1)
            {
                //there is at least one *
                if (counter == 1 && oRead.openFileNames.Count == 1)
                {
                    //ok
                }
                else
                {
                    new Error("The '*' cannot be used in a list of filenames");
                    //throw new GekkoException();
                }
            }

            if (counter >= 1 && oRead.openFileNames.Count > 1)
            {
                if (oRead.openFileNames[0][0] != "*")
                {

                }
            }
            else if (counter > 1)
            {
                new Error("The '*' filename should not be stated in a list of files to open");
                //throw new GekkoException();
            }
        }

        /// <summary>
        /// Check if something has changed in a databank since it was read. Relevant for CLOSE (after an OPEN), to see if something needs
        /// to be written back to the file.
        /// </summary>
        /// <param name="removed"></param>
        /// <returns></returns>
        public static bool IsDatabankDirty(Databank removed)
        {
            bool isDirty = false;
            if (removed.isDirty) isDirty = true;
            else
            {
                foreach (IVariable iv in removed.storage.Values)
                {
                    Series ts = iv as Series;
                    if (ts == null) continue;
                    if (ts.IsDirty())
                    {
                        isDirty = true;
                        break;
                    }
                }
            }
            return isDirty;
        }

        /// <summary>
        /// Technical helper method for reading databanks with array-series.
        /// </summary>
        /// <param name="db"></param>
        /// <param name="merge"></param>
        public static void HandleCleanAndParentForTimeseries(Databank db, bool merge)
        {
            db.isDirty = false;
            foreach (IVariable iv in db.storage.Values)
            {
                Series ts = iv as Series;
                if (ts == null) continue;
                if (ts.type == ESeriesType.ArraySuper)
                {
                    foreach (Series tsSub in ts.dimensionsStorage.storage.Values)
                    {
                        if (tsSub.type == ESeriesType.Light) tsSub.meta = new Gekko.SeriesMetaInformation();
                        tsSub.meta.parentDatabank = db;
                        if (!merge) tsSub.SetDirty(false);
                    }
                }
                if (!merge) ts.SetDirty(false);  //if we are not merging, the bank is comletely new, and the timeseries are all considered clean. When merging, dirt is all over.
                ts.meta.parentDatabank = db;
            }
        }

        /// <summary>
        /// Read a two-dimensional data file containg "cells" of data. Supports .csv, .prn, and xls(x). The timeseries data is read into a Gekko databank.
        /// </summary>
        /// <param name="offset"></param>
        /// <param name="oRead"></param>
        /// <param name="readInfo"></param>
        /// <param name="file"></param>
        /// <param name="databank"></param>
        /// <param name="originalFilePath"></param>
        /// <param name="dateformat"></param>
        /// <param name="datetype"></param>
        private static void Read2DCells_csv_prn_xlsx(CellOffset offset, ReadOpenMulbkHelper oRead, ReadInfo readInfo, string file, Databank databank, string originalFilePath, string originalFilePathPretty, string dateformat, string datetype)
        {
            //TODO:
            //For speedup:
            //Use simpler Dictionary<long,helper>, where long is row + 2^32*col, and counting maxrow and
            //maxcol. Optionally inputkeys and maxrow/col can be transposed. Helper is a struct with
            //string+double fields. If string==null and double.NaN, the values is simply not put in.
            //if string==null, it is assumed to be a double field.

            //DateTime t000 = DateTime.Now;
            readInfo.fileName = originalFilePath;
            readInfo.fileNamePretty = originalFilePathPretty;
            TableLight matrix = null;
            string prnType = null;
            if (oRead.Type == EDataFormat.Csv || oRead.Type == EDataFormat.Prn)
            {
                if (!oRead.Merge)
                {
                    databank.Clear();
                }
                matrix = ReadCsvPrn(oRead.Type, file);
            }
            else
            {
                if (Globals.excelDna)
                {
                    matrix = Globals.excelDnaData.tableLight;
                }
                else
                {
                    matrix = ReadExcel(file, oRead.sheet);
                }
            }
            ExtractTimeseriesFromTableLight(matrix, offset, oRead, databank, readInfo, dateformat, datetype);
        }

        /// <summary>
        /// Helper for Excel coordinate names.
        /// </summary>
        /// <param name="columnName"></param>
        /// <returns></returns>
        public static int ExcelColumnNameToNumber(string columnName)
        {
            if (string.IsNullOrEmpty(columnName)) throw new GekkoException();
            columnName = columnName.ToUpperInvariant();
            int sum = 0;
            for (int i = 0; i < columnName.Length; i++)
            {
                sum *= 26;
                sum += (columnName[i] - 'A' + 1);
            }
            return sum;
        }

        public enum ESheetCollection
        {
            Matrix,
            List,
            Map,
            None
        }

        /// <summary>
        /// This is a method for SHEET&lt;import&gt;, where data can be extracted more precisely from individual cells. The file format may
        /// be .csv, .prn, or xls(x), and you may import into a series, matrix, list or map.
        /// </summary>
        /// <param name="o"></param>
        public static void SheetImport(O.SheetImport o)
        {
            List<string> listItems = null;

            ESheetCollection type = ESheetCollection.None;
            if (G.Equal(o.opt_matrix, "yes")) type = ESheetCollection.Matrix;
            else if (G.Equal(o.opt_list, "yes")) type = ESheetCollection.List;
            else if (G.Equal(o.opt_map, "yes")) type = ESheetCollection.Map;

            if (type != ESheetCollection.None)
            {
                listItems = O.Restrict(o.names, true, true, false, false);
            }
            else
            {
                listItems = O.Restrict(o.names, true, false, true, false);
            }

            string collectionName = null;

            if (type != ESheetCollection.None)
            {
                if (listItems.Count == 0 || listItems.Count > 1)
                {
                    new Error("For SHEET<import " + type.ToString().ToLower() + ">, only 1 name must be provided");
                    //throw new GekkoException();
                }
                collectionName = listItems[0];
            }

            bool isMissing = false;
            if (G.Equal(o.opt_missing, "yes"))
            {
                isMissing = true;
            }

            //do copylocal
            string fileName = o.fileName;
            fileName = G.AddExtension(fileName, ".xlsx");
            FindFileHelper ffh = Program.FindFile(fileName, null, true, true, o.p);
            fileName = ffh.realPathAndFileName;

            if (Globals.pink && fileName != null && (fileName.ToLower().Contains("g:\\datopgek\\") || fileName.ToLower().Contains("g:/datopgek/")))
            {
                Globals.datopgek_errors.Add("SHEET<import> used this file: " + o.fileName);
            }

            EDataFormat fileType = EDataFormat.Xlsx;
            if (G.Equal(o.opt_xls, "yes")) fileType = EDataFormat.Xls;
            else if (G.Equal(o.opt_xlsx, "yes")) fileType = EDataFormat.Xlsx;
            else if (G.Equal(o.opt_csv, "yes")) fileType = EDataFormat.Csv;
            else if (G.Equal(o.opt_prn, "yes")) fileType = EDataFormat.Prn;

            TableLight inputTable = null;
            if (fileType == EDataFormat.Csv || fileType == EDataFormat.Prn)
            {
                inputTable = ReadCsvPrn(fileType, fileName);
            }
            else if (fileType == EDataFormat.Xls || fileType == EDataFormat.Xlsx)
            {
                inputTable = ReadExcel(fileName, o.opt_sheet);
            }

            bool transpose = false;  //corresponding to row-wise reading
            if (G.Equal(o.opt_cols, "yes"))
            {
                transpose = true;
                if (type != ESheetCollection.None) new Note("Because of <cols> option, the resulting " + type.ToString().ToLower() + " is transposed");
            }

            if (transpose)
            {
                //reading downwards by cols
                inputTable = inputTable.Transpose();
            }

            int obs = GekkoTime.Observations(o.t1, o.t2);
            int n = listItems.Count;

            string s = "a1";
            if (o.opt_cell != null) s = o.opt_cell;
            int index = s.IndexOfAny(new char[] { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9' });
            string chars = s.Substring(0, index);
            int num = Int32.Parse(s.Substring(index));
            int rowOffset = num - 1;
            int colOffset = ExcelColumnNameToNumber(chars) - 1;

            if (transpose)
            {
                //switch them
                int temp = rowOffset;
                rowOffset = colOffset;
                colOffset = temp;
            }

            //check between 1... large number

            if (type == ESheetCollection.None)
            {
                for (int row = 1 + rowOffset; row < 1 + rowOffset + n; row++)
                {
                    Series ts = O.GetIVariableFromString(listItems[row - 1 - rowOffset], O.ECreatePossibilities.Must, false) as Series;
                    for (int col = 1 + colOffset; col < 1 + colOffset + obs; col++)
                    {
                        CellLight cell = inputTable.Get(row, col);
                        if (cell.type == ECellLightType.None) continue;
                        double v = GetValueFromSpreadsheetCell(transpose, row, col, cell);
                        ts.SetData(o.t1.Add(col - 1 - colOffset), v);
                    }
                }
            }
            else
            {
                Matrix outputMatrix = null;
                List outputList = null;
                Map outputMap = null;

                int rr = inputTable.GetRowMaxNumber() - rowOffset;
                int cc = inputTable.GetColMaxNumber() - colOffset;
                if (rr <= 0 || cc <= 0)
                {
                    new Error("There is not data in the sheet area");
                }

                if (type == ESheetCollection.Matrix)
                {
                    if (isMissing) outputMatrix = new Matrix(rr, cc, double.NaN);
                    else outputMatrix = new Matrix(rr, cc);
                }
                else if (type == ESheetCollection.List) outputList = new List();
                else if (type == ESheetCollection.Map) outputMap = new Map();

                for (int row = 1 + rowOffset; row <= inputTable.GetRowMaxNumber(); row++)
                {
                    if (type == ESheetCollection.List)
                    {
                        outputList.Add(new List());  //adding a new row
                    }
                    for (int col = 1 + colOffset; col <= inputTable.GetColMaxNumber(); col++)
                    {

                        CellLight cell = inputTable.Get(row, col);
                        if (cell.type == ECellLightType.None)
                        {
                            if (type == ESheetCollection.List)
                            {
                                (outputList.list[row - 1 - rowOffset] as List).Add(GekkoNull.gekkoNull);
                            }
                            continue;
                        }

                        if (type == ESheetCollection.Matrix)
                        {
                            double v = GetValueFromSpreadsheetCell(transpose, row, col, cell);
                            outputMatrix.data[row - 1 - rowOffset, col - 1 - colOffset] = v;
                        }
                        else if (type == ESheetCollection.List || type == ESheetCollection.Map)
                        {

                            bool isNaNText = false;
                            if (cell.type == ECellLightType.String)
                            {
                                if (IsNonAvailableText(cell.text, false)) isNaNText = true;  //will not be true if M or NA
                            }

                            IVariable iv = null;
                            if (isNaNText)
                            {
                                iv = new ScalarVal(double.NaN);
                            }
                            else if (cell.type == ECellLightType.DateTime)
                            {
                                int sub = -12345;
                                EFreq freq = Program.options.freq;
                                //uses current freq 
                                GekkoTime gt5 = GekkoTime.FromDateTimeToGekkoTime(freq, cell.dateTime);
                                int super = gt5.super;
                                sub = gt5.sub;

                                iv = new ScalarDate(new GekkoTime(freq, super, sub));
                            }
                            else if (cell.type == ECellLightType.Double)
                            {
                                //will not try to interpret a string like M or NA or #I/T as a missing,
                                //since it IS not a string here
                                iv = new ScalarVal(GetValueFromSpreadsheetCell(transpose, row, col, cell));
                            }
                            else if (cell.type == ECellLightType.String)
                            {
                                //A string like #I/T has isNaNText = true and is handled above
                                //but we may have a M or NA here, which will just become a string
                                //later on: maybe option for M and NA strings...?
                                iv = new ScalarString(cell.text.Trim());
                            }
                            else if (cell.type == ECellLightType.None)
                            {
                                iv = GekkoNull.gekkoNull;
                            }
                            else
                            {
                                throw new GekkoException();
                            }

                            if (type == ESheetCollection.List)
                            {
                                (outputList.list[row - 1 - rowOffset] as List).Add(iv);
                            }
                            else
                            {
                                string coord = Globals.symbolScalar + GetExcelCell(row - 1 - rowOffset + 1, col - 1 - colOffset + 1, transpose);  //1 is added, so that first coord is called with i = 1, j = 1, not i = 0, j = 0.
                                outputMap.Add(coord, iv); //topleft will always be "%a1"
                            }
                        }
                    }
                }
                IVariable output = null;
                if (type == ESheetCollection.Matrix) output = outputMatrix;
                else if (type == ESheetCollection.List) output = outputList;
                else if (type == ESheetCollection.Map) output = outputMap;
                O.AddIVariableWithOverwriteFromString(collectionName, output);
                G.Writeln2("Imported " + type.ToString().ToLower() + " " + collectionName + " (" + rr + "x" + cc + " elements)");
            }
        }

        /// <summary>
        /// Special rules to get a cell value (from a TableLight cell) transformed into a C# double.
        /// </summary>
        /// <param name="transpose"></param>
        /// <param name="row"></param>
        /// <param name="col"></param>
        /// <param name="cell"></param>
        /// <returns></returns>
        public static double GetValueFromSpreadsheetCell(bool transpose, int row, int col, CellLight cell)
        {
            double v = double.NaN;
            if (cell.type == ECellLightType.String)
            {
                if (IsNonAvailableText(cell.text))
                {
                    //keep NaN
                }
                else
                {
                    using (Error txt = new Error())
                    {
                        txt.MainAdd("In spreadsheet cell " + GetExcelCell(row, col, transpose) + ", content: '" + cell.text + "'. ");
                        txt.MoreAdd(ExcelTypeError());
                    }
                }
            }
            else if (cell.type == ECellLightType.Double)
            {
                v = cell.data;
            }
            else
            {
                new Error("Could not understand spreadsheet cell " + GetExcelCell(row, col, transpose) + " as a number");
            }
            return v;
        }

        private static string ExcelTypeError()
        {
            return "The cell type is text/string, expected a numerical value. Such problems can typically be fixed by changing the type/format of the cell(s) in Excel. Gekko does not try to autoconvert a string like for instance '1.2345' into a value, because this could introduce hard-to find bugs. Note: when the cell type is correctly set as a numerical value, Gekko does not care about the layout choice of decimal separator symbols etc. (the value is acquired from a binary Excel representation).";
        }


        /// <summary>
        /// Read a .gbk Gekko databank file into a Gekko databank (in memory). The .gbk file is unzipped, and the xml metadata file inside is
        /// read, too (DatabankInfo.xml). After that, the unzipped protobuffer file is transformed into an in-memory databank. To to this,
        /// the protobuf-net is used.
        /// </summary>
        /// <param name="oRead"></param>
        /// <param name="readInfo"></param>
        /// <param name="file"></param>
        /// <param name="databank"></param>
        /// <param name="originalFilePath"></param>
        /// <param name="tsdxFile"></param>
        /// <param name="tempTsdxPath"></param>
        public static void ReadGbk(ReadOpenMulbkHelper oRead, ReadInfo readInfo, ref string file, ref Databank databank, string originalFilePath, string originalFilePathPretty, ref string tsdxFile, ref string tempTsdxPath)
        {

            //Note: file is altered below in several places, including is_a_protobuffer_file stuff

            //NOTE: time-truncation is only done at the uppermost level: series or array-series. Stuff inside LIST or MAP is not time-truncated.

            //bool mergeOrTimeLimit = oRead.Merge || dates != null;

            readInfo.databankVersion = "";
            //try to unzip it here
            tempTsdxPath = CreateTempFolderPath("temptsdxfolder");
            if (!Directory.Exists(tempTsdxPath))  //should almost never exist, since name is random
            {
                //See also #87f897aiosduf
                Directory.CreateDirectory(tempTsdxPath);
            }
            else
            {
                //in the very rare case, any files here will be overwritten
            }
            string unzippedFile = Path.GetFileNameWithoutExtension(originalFilePath) + ".tsd";

            DateTime dt2 = DateTime.Now;
            string foundTsdFile = WaitForZipRead_TSDX(tempTsdxPath, file, unzippedFile, originalFilePath);
            G.WritelnGray("Unzipping took: " + G.Seconds(dt2));

            //both protobuffers and tsd files

            tsdxFile = file;
            //file = tempTsdxPath + "\\" + unzippedFile;
            file = tempTsdxPath + "\\" + foundTsdFile;
            string databankVersion = null;

            XmlDocument doc = new XmlDocument();
            //We can presume that DatabankInfo.xml is in UTF-8, since it is typically written by Gekko
            //So no need to use GetTextFromFile()
            string fileXml = tempTsdxPath + "\\" + "DatabankInfo.xml";
            using (FileStream fs = WaitForFileStream(fileXml, null, GekkoFileReadOrWrite.Read))
            {
                try
                {
                    doc.Load(fs);
                }
                catch (Exception e)
                {
                    new Error("XML file 'DatabankInfo.xml' inside " + Globals.extensionDatabank + " file. " + Program.GetXmlError(e, fileXml));
                }

                XmlElement root = doc.DocumentElement; //"DatabankInfo"

                databankVersion = root.GetAttribute("databankVersion").Trim();
                if (databankVersion == "") databankVersion = "1.0";
                string gekkoVersion = root.GetAttribute("gekkoVersion").Trim();
                if (databankVersion != "") readInfo.databankVersion = "(vers: " + databankVersion + ")";

                if (!Globals.tsdxVersions.Contains(databankVersion))
                {
                    using (Error e = new Error())
                    {
                        e.MainAdd("The databank version " + databankVersion + " is unknown to this Gekko version (" + Globals.gekkoVersion + ").");
                        e.MainAdd("Known databank versions: " + Stringlist.GetListWithCommas(Globals.tsdxVersions) + ".");
                        e.MainAdd("The databank seems to have been written by Gekko version " + gekkoVersion + ".");
                        e.MainAdd("Troubleshooting, try this page: " + Globals.databankformatUrl + ".");
                    }
                }

                XmlNodeList descriptions = doc.GetElementsByTagName("Info1");
                foreach (XmlNode description in descriptions)  //should be only 1 in this loop
                {
                    readInfo.info1 = description.InnerText.Trim();
                }

                XmlNodeList dates5 = doc.GetElementsByTagName("Date");
                foreach (XmlNode date in dates5) //should be only 1 in this loop
                {
                    readInfo.date = date.InnerText.Trim();
                }

                XmlNodeList modelNames = doc.GetElementsByTagName("ModelName");
                foreach (XmlNode modelName in modelNames) //should be only 1 in this loop
                {
                    readInfo.modelName = modelName.InnerText.Trim();
                }

                XmlNodeList modelInfos = doc.GetElementsByTagName("ModelInfo");
                foreach (XmlNode modelInfo in modelInfos) //should be only 1 in this loop
                {
                    readInfo.modelInfo = modelInfo.InnerText.Trim();
                }

                XmlNodeList modelDates = doc.GetElementsByTagName("ModelDate");
                foreach (XmlNode modelDate in modelDates) //should be only 1 in this loop
                {
                    readInfo.modelDate = modelDate.InnerText.Trim();
                }

                XmlNodeList modelSignatures = doc.GetElementsByTagName("ModelSignature");
                foreach (XmlNode modelSignature in modelSignatures) //should be only 1 in this loop
                {
                    readInfo.modelSignature = modelSignature.InnerText.Trim();
                }

                XmlNodeList modelHashs = doc.GetElementsByTagName("ModelHash");
                foreach (XmlNode modelHash in modelHashs) //should be only 1 in this loop
                {
                    readInfo.modelHash = modelHash.InnerText.Trim();
                }

                XmlNodeList modelLastSimPeriods = doc.GetElementsByTagName("ModelLastSimPeriod");
                foreach (XmlNode modelLastSimPeriod in modelLastSimPeriods) //should be only 1 in this loop
                {
                    readInfo.modelLastSimPeriod = modelLastSimPeriod.InnerText.Trim();
                }

                XmlNodeList modelLastSimStamps = doc.GetElementsByTagName("ModelLastSimStamp");
                foreach (XmlNode modelLastSimStamp in modelLastSimStamps) //should be only 1 in this loop
                {
                    readInfo.modelLastSimStamp = modelLastSimStamp.InnerText.Trim();
                }

                XmlNodeList modelLargestLags = doc.GetElementsByTagName("ModelLargestLag");
                foreach (XmlNode modelLargestLag in modelLargestLags) //should be only 1 in this loop
                {
                    readInfo.modelLargestLag = modelLargestLag.InnerText.Trim();
                }

                XmlNodeList modelLargestLeads = doc.GetElementsByTagName("ModelLargestLead");
                foreach (XmlNode modelLargestLead in modelLargestLeads) //should be only 1 in this loop
                {
                    readInfo.modelLargestLead = modelLargestLead.InnerText.Trim();
                }
            }

            Databank deserializedDatabank = null;
            readInfo.fileName = originalFilePath;
            readInfo.fileNamePretty = originalFilePathPretty;

            if (databankVersion == "1.0" || databankVersion == "1.1")
            {
                deserializedDatabank = ReadGbk_1_1(oRead, readInfo, ref file, databank, originalFilePath, originalFilePathPretty, ref tsdxFile, ref tempTsdxPath, databankVersion);
            }
            else
            {
                string fileName = null;
                if (File.Exists(tempTsdxPath + "\\" + Globals.protobufFileName)) fileName = tempTsdxPath + "\\" + Globals.protobufFileName;  //legacy
                else if (File.Exists(tempTsdxPath + "\\" + Globals.protobufFileName2)) fileName = tempTsdxPath + "\\" + Globals.protobufFileName2;  //usual name
                else if (File.Exists(tempTsdxPath + "\\" + Program.options.databank_file_gbk_internal)) fileName = tempTsdxPath + "\\" + Program.options.databank_file_gbk_internal;  //IF the usual name is changed
                else
                {
                    new Error("Could not find data storage file inside zipped databank file. Troubleshooting, try this page: " + Globals.databankformatUrl);
                }


                ////May take a little time to create: so use static serializer if doing serialize on a lot of small objects
                //RuntimeTypeModel serializer = TypeModel.Create();
                //serializer.UseImplicitZeroDefaults = false;  //otherwise an int that has default constructor value -12345 but is set to 0 will reappear as a -12345 (instead of 0). For int, 0 is default, false for bools etc.
                try
                {
                    DateTime dt3 = DateTime.Now;
                    deserializedDatabank = ProtobufRead<Databank>(fileName);
                    TwoInts yearMinMax = new TwoInts(int.MaxValue, int.MinValue);
                    foreach (IVariable iv in deserializedDatabank.storage.Values)
                    {
                        iv.DeepCleanup(yearMinMax);  //fixes maps and lists with 0 elements, also binds MultiDim.parent
                    }
                    readInfo.variables = deserializedDatabank.storage.Count;
                    readInfo.startPerInFile = yearMinMax.int1;
                    readInfo.endPerInFile = yearMinMax.int2;
                    G.WritelnGray("Protobuf deserialize took: " + G.Seconds(dt3));
                }
                catch (Exception e)
                {
                    new Error("Unexpected technical error when reading " + Globals.extensionDatabank + " databank in version " + Globals.currentGbkVersion + " format (protobuffers). Message: " + e.Message + ". Troubleshooting, try this page: " + Globals.databankformatUrl + ".");
                }
            }

            if (true)
            {
                //Can do it fast, just swapping the deserialized bank instead of the current, with no copying around
                try
                {
                    //discarding the old bank completely, and replacing with the new one
                    deserializedDatabank.name = databank.name;
                    Program.databanks.ReplaceDatabank(databank, deserializedDatabank);
                    //readInfo.databank = deserializedDatabank;  //since this pointer is altered
                    databank = deserializedDatabank;  //since this pointer is altered
                    databank.FileNameWithPath = originalFilePath;
                    databank.FileNameWithPathPretty = originalFilePathPretty;
                }
                catch (Exception e)
                {
                    new Error("Unexpected technical error while reading " + Globals.extensionDatabank + " databank");
                    //throw new GekkoException();
                }

                readInfo.startPerResultingBank = readInfo.startPerInFile;
                readInfo.endPerResultingBank = readInfo.endPerInFile;
            }
        }

        /// <summary>
        /// Read the older .gbk databank format corresponding to Gekko 2.x.x.
        /// </summary>
        /// <param name="oRead"></param>
        /// <param name="readInfo"></param>
        /// <param name="file"></param>
        /// <param name="databank"></param>
        /// <param name="originalFilePath"></param>
        /// <param name="tsdxFile"></param>
        /// <param name="tempTsdxPath"></param>
        /// <param name="databankVersion"></param>
        /// <returns></returns>
        private static Databank ReadGbk_1_1(ReadOpenMulbkHelper oRead, ReadInfo readInfo, ref string file, Databank databank, string originalFilePath, string originalFilePathPretty, ref string tsdxFile, ref string tempTsdxPath, string databankVersion)
        {
            /// <summary>
            /// Only used for ReadGbk_1_1()
            /// </summary>
            /// <param name="s"></param>
            /// <returns></returns>
            string[] GetArrayTimeseriesName_1_1(string s)
            {
                return s.Split(new string[] { Globals.symbolTurtle }, StringSplitOptions.None);
            }            

            Databank deserializedDatabank;
            int nanCounter = 0;
            ReadInfo readInfo_oldbank = new ReadInfo();
            Databank_1_1 databank_1_1 = null;
            Utilities_1_1.ReadGbkOld_1_1(databank.name, databankVersion, oRead, readInfo_oldbank, ref file, ref databank_1_1, originalFilePath, originalFilePathPretty, ref tsdxFile, ref tempTsdxPath, ref nanCounter);
            if (databank_1_1.storage.Count == 0)
            {
                new Error("Old databank in " + readInfo.databankVersion + " format has 0 variables");
                //throw new GekkoException();
            }
            deserializedDatabank = new Databank(databank.name);

            readInfo.startPerInFile = readInfo_oldbank.startPerInFile;
            readInfo.endPerInFile = readInfo_oldbank.endPerInFile;
            readInfo.variables = readInfo_oldbank.variables;

            foreach (KeyValuePair<string, TimeSeries_1_1> kvp in databank_1_1.storage)
            {
                TimeSeries_1_1 ts1 = kvp.Value;
                string name = ts1.variableName;

                if (ts1.IsGhost()) continue;
                if (name.Contains(Globals.symbolTurtle))
                {
                    //array-timeseries
                    string[] ss = GetArrayTimeseriesName_1_1(name);
                    string[] ss2 = new string[ss.Length - 1];
                    for (int i = 1; i < ss.Length; i++)
                    {
                        ss2[i - 1] = ss[i];
                    }
                    //string ghostName = ss[0];

                    string ghostName = ss[0] + Globals.freqIndicator + G.ConvertFreq(ts1.freqEnum);
                    Series tsGhost = deserializedDatabank.GetIVariable(ghostName, true) as Series;
                    if (tsGhost == null)
                    {
                        tsGhost = new Series(ts1.freqEnum, ghostName);
                        tsGhost.meta.label = ts1.label;
                        tsGhost.SetArrayTimeseries(ss2.Length + 1, !ts1.IsTimeless());
                        deserializedDatabank.AddIVariableWithOverwrite(tsGhost);
                    }

                    Series tsSub = null;

                    if (ts1.IsTimeless())
                    {
                        tsSub = new Series(ESeriesType.Timeless, ts1.freqEnum, null);
                        tsSub.SetTimelessData(double.NaN);
                        if (ts1.dataArray != null && ts1.dataArray.Length > 0) tsSub.SetTimelessData(ts1.dataArray[0]);
                    }
                    else
                    {
                        tsSub = new Series(ESeriesType.Normal, ts1.freqEnum, null);
                        GekkoTime t1 = ts1.GetRealDataPeriodFirst();
                        GekkoTime t2 = ts1.GetRealDataPeriodLast();
                        foreach (GekkoTime t in new GekkoTimeIterator(t1, t2))
                        {
                            tsSub.SetData(t, ts1.GetData(t));  //could be sped up with arrays, but never mind
                        }
                    }

                    tsGhost.dimensionsStorage.AddIVariableWithOverwrite(new MultidimItem(ss2, tsGhost), tsSub);

                }
                else
                {
                    //normal timeseries

                    Series ts2 = null;

                    if (ts1.IsTimeless())
                    {
                        ts2 = new Series(ESeriesType.Timeless, ts1.freqEnum, name + Globals.freqIndicator + G.ConvertFreq(ts1.freqEnum));
                        ts2.SetTimelessData(double.NaN);
                        if (ts1.dataArray != null && ts1.dataArray.Length > 0) ts2.SetTimelessData(ts1.dataArray[0]);
                    }
                    else
                    {
                        ts2 = new Series(ESeriesType.Normal, ts1.freqEnum, name + Globals.freqIndicator + G.ConvertFreq(ts1.freqEnum));

                        GekkoTime t1 = ts1.GetRealDataPeriodFirst();
                        GekkoTime t2 = ts1.GetRealDataPeriodLast();
                        if (t1.super != -12345)
                        {
                            foreach (GekkoTime t in new GekkoTimeIterator(t1, t2))
                            {
                                ts2.SetData(t, ts1.GetData(t));  //could be sped up with arrays, but never mind
                            }
                        }
                    }
                    ts2.meta.label = ts1.label;
                    ts2.meta.stamp = ts1.stamp;
                    ts2.meta.source = ts1.source;

                    deserializedDatabank.AddIVariableWithOverwrite(ts2);
                }
            }

            return deserializedDatabank;
        }

        /// <summary>
        /// Small helper method to help finding first and last year of a timeseries. Used when for instance reading/opening
        /// a .gbk databank, so the period of the databank can be shown.
        /// </summary>
        /// <param name="ts">The series to find min-max for</param>
        /// <param name="yearMinMax">Helper object to store the years</param>
        public static void GetYearMinMax(Series ts, TwoInts yearMinMax)
        {
            //We do not use GetRealPeriodFirst() etc. -- only for showing dates when reading a bank, does not
            //need to be 100% correct.
            if (ts.type != ESeriesType.Timeless)
            {
                if (!ts.GetPeriodFirst().IsNull()) yearMinMax.int1 = Math.Min(yearMinMax.int1, ts.GetPeriodFirst().super);
                if (!ts.GetPeriodLast().IsNull()) yearMinMax.int2 = Math.Max(yearMinMax.int2, ts.GetPeriodLast().super);
            }
        }

        /// <summary>
        /// Small helper method.
        /// </summary>
        /// <param name="dates"></param>
        /// <param name="databank"></param>
        /// <param name="name"></param>
        /// <param name="tsProtobuf"></param>
        /// <param name="wipeExistingOut"></param>
        private static void MergeTwoTimeseriesWithDateWindowHelper(AllFreqsHelper dates, Databank databank, string name, Series tsProtobuf, bool wipeExistingOut)
        {
            if (wipeExistingOut)
            {
                //better to keep this outside of MergeTwoTimeseriesWithDateWindow()                                     
                tsProtobuf.Truncate(dates);
                databank.AddIVariableWithOverwrite(name, tsProtobuf);
            }
        }

        /// <summary>
        /// Small helper method.
        /// </summary>
        /// <param name="dates"></param>
        /// <param name="gmap"></param>
        /// <param name="gmapItem"></param>
        /// <param name="tsProtobuf"></param>
        /// <param name="shouldOverwriteLaterOn"></param>
        private static void MergeTwoTimeseriesWithDateWindowHelper(AllFreqsHelper dates, Multidim gmap, MultidimItem gmapItem, Series tsProtobuf, bool shouldOverwriteLaterOn)
        {
            if (shouldOverwriteLaterOn)
            {
                //better to keep this outside of MergeTwoTimeseriesWithDateWindow()                                     
                tsProtobuf.Truncate(dates);
                gmap.AddIVariableWithOverwrite(gmapItem, tsProtobuf);
            }
        }

        /// <summary>
        /// When reading a timeseries from a databank, this timeseries has a date "window" (observations over which it is defined). In addition,
        /// if the timeseries already exists in the memory databank, the existing timeseries also has a window. To make matters even worse, there
        /// may be a time indication in the command, for instance IMPORT&lt;2000 2020&gt;. This method handles the logic of these three 
        /// overlapping date "windows".
        /// </summary>
        /// <param name="dates"></param>
        /// <param name="tsExisting"></param>
        /// <param name="tsSource"></param>
        /// <param name="maxYearInProtobufFile"></param>
        /// <param name="minYearInProtobufFile"></param>
        /// <param name="shouldOverwriteLaterOn"></param>
        public static void MergeTwoTimeseriesWithDateWindow(AllFreqsHelper dates, Series tsExisting, Series tsSource, ref int maxYearInProtobufFile, ref int minYearInProtobufFile, ref bool shouldOverwriteLaterOn)
        {
            if (tsSource.type == ESeriesType.Timeless || (tsExisting != null && tsExisting.type == ESeriesType.Timeless))
            {
                //!!! BEWARE: remember to truncate and add it to container outside of this method
                //if either is timeless, just wipe existing out
                //handle it like non-series
                shouldOverwriteLaterOn = true;
            }
            else
            {
                //non-timeless

                if (tsExisting == null)
                {
                    //!!! BEWARE: remember to truncate and add it to container outside of this method
                    //Does not exist already: just put it in, but remember to truncate dates                    
                    shouldOverwriteLaterOn = true;
                }
                else
                {
                    //already exists: now we must merge the observations
                    //There are 3 time-windows in play: Work bank window, file window and dates window:
                    //  - Existing: the window of the existing timeseries (will not have any effect on the merging)
                    //  - Source: the window of the series from the deflated protobuf file
                    //  - Dates window: time-truncation of the file window
                    //So we find the overlap of the source window and the date window (if it is active at all)
                    //Then we put that overlap into the existing timeseries

                    //  --> useRealDataPeriodForSource = true
                    //       source       existing          dates (2002-6)    Result
                    //2001                 
                    //2002                    M              x                    M
                    //2003      M           100              x                  100
                    //2004      M           200              x                  200
                    //2005      1           300              x                    1
                    //2006      2           400              x                    2
                    //2007      3             M                                   M                 
                    //2008      M
                    //2009 
                    //2010 
                    //
                    // Here, firstSource is 2005, lastSource is 2007
                    // Common window will be 2005-2006        
                    // This funcionality is good for merging databanks

                    GekkoTime firstSource = GekkoTime.tNull;
                    GekkoTime lastSource = GekkoTime.tNull;

                    //takes a bit of time but not that much
                    firstSource = tsSource.GetRealDataPeriodFirst(); //takes a bit of time, but then we get the real period 
                    lastSource = tsSource.GetRealDataPeriodLast(); //takes a bit of time, but then we get the real period                                        

                    //only for printing out the period
                    maxYearInProtobufFile = G.GekkoMax(maxYearInProtobufFile, lastSource.super);
                    minYearInProtobufFile = G.GekkoMin(minYearInProtobufFile, firstSource.super);

                    if (firstSource.IsNull())
                    {
                        //no real data at all (lastSource will be null, too)
                        //do not write anything, no matter if dates = null or not.
                    }
                    else
                    {
                        //We have a data window in tsSource. Truncate the window with dates window (if it exists)
                        if (dates != null)
                        {
                            //this will adjust first and last to comply with the dates window
                            var tuple = GetFirstLastDates(dates, firstSource, lastSource);
                            GekkoTime firstTruncated = tuple.Item1;
                            GekkoTime lastTruncated = tuple.Item2;
                            //offset is not used

                            int nob = GekkoTime.Observations(firstTruncated, lastTruncated);
                            if (nob > 0)  //can be 0 or negative, if the windows do not overlap at all
                            {

                                int index1;
                                int index2;
                                try
                                {
                                    double[] data_beware_do_not_alter = tsSource.GetDataSequenceUnsafePointerReadOnlyBEWARE(out index1, out index2, firstTruncated, lastTruncated);  //should not optionally replace NaN with 0
                                    tsExisting.SetDataSequence(firstTruncated, lastTruncated, data_beware_do_not_alter, index1);
                                }
                                catch (Exception e)
                                {
                                    new Error("Unexpected technical error while merging databanks");
                                    //throw new GekkoException();
                                }
                            }
                            else
                            {
                                //does not get written, since there is no window overlap
                            }
                        }
                        else
                        {
                            //firstExisting is guaranteed to be != tNull, so lastExisting is so too
                            int index1;
                            int index2;
                            double[] data_beware_do_not_change = tsSource.GetDataSequenceUnsafePointerReadOnlyBEWARE(out index1, out index2, firstSource, lastSource);  //should not optionally replace NaN with 0
                            tsExisting.SetDataSequence(firstSource, lastSource, data_beware_do_not_change, index1);
                        }
                    }
                }
            }

        }

        /// <summary>
        /// Get a timeries from a databank, may return null.
        /// </summary>
        /// <param name="databank"></param>
        /// <param name="name"></param>
        /// <returns></returns>
        private static Series GetTsExisting(Databank databank, string name)
        {
            IVariable ivExisting = databank.GetIVariable(name);
            Series tsExisting = null;
            if (ivExisting != null)
            {
                tsExisting = ivExisting as Series;
                if (tsExisting == null)
                {
                    //should not be possible since the name has no sigil
                    new Error("Internal error #8974325235");
                    //throw new GekkoException();
                }
            }

            return tsExisting;
        }

        /// <summary>
        /// Read a .tsd file with timeseries data into a Gekko memory databank.
        /// </summary>
        /// <param name="oRead"></param>
        /// <param name="readInfo"></param>
        /// <param name="file"></param>
        /// <param name="databank"></param>
        /// <param name="originalFilePath"></param>
        /// <param name="NaNCounter"></param>
        private static void ReadTsd(ReadOpenMulbkHelper oRead, ReadInfo readInfo, ref string file, ref Databank databank, string originalFilePath, string originalFilePathPretty, ref int NaNCounter)
        {
            bool isTsdx = false;
            //bool mergeOrTimeLimit = oRead.Merge || dates != null;
            readInfo.fileName = originalFilePath;
            readInfo.fileNamePretty = originalFilePathPretty;
            //also deals with merging (not clearing the databank first if merging)
            ReadAllTsdRecords(file, oRead.Merge, isTsdx, databank, ref NaNCounter, readInfo);
            readInfo.nanCounter = NaNCounter;
            readInfo.startPerResultingBank = readInfo.startPerInFile;
            readInfo.endPerResultingBank = readInfo.endPerInFile;
        }

        /// <summary>
        /// Helper method for MergeTwoTimeseriesWithDateWindow(). These date window are particularly tricky if the date windows have different
        /// frequencies (for instance IMPORT&lt;2000q2 2020q3&gt; on an annual timeseries).
        /// </summary>
        /// <param name="dates"></param>
        /// <param name="first"></param>
        /// <param name="last"></param>
        /// <returns></returns>
        public static Tuple<GekkoTime, GekkoTime, int> GetFirstLastDates(AllFreqsHelper dates, GekkoTime first, GekkoTime last)
        {
            //offset is the distance from first to dates.t1. If dates.t1 < first, offset will be 0.
            //So offset tells us when to start taking data in the array of the existing timeseries, as counted from the first date.
            //BEWARE: offset is the distance counted from the INPUT of first, not the OUTPUT of first
            //All in all, offset is a bit dangerous

            //If the dates window and the first/last window do not overlap, we will get a timeperiod returned
            //where first > last. This means that GekkoTime.Observations(first, last) will be <= 0. So test
            //that GekkoTime.Observations(first, last) > 0 before putting any data in.
            //

            GekkoTime firstRv = first;
            GekkoTime lastRv = last;

            int offset = 0;
            if (first.freq == EFreq.A)
            {
                if (dates.t1Annual.StrictlyLargerThan(first))
                {
                    offset = dates.t1Annual.Subtract(first);
                    firstRv = dates.t1Annual;
                }
                if (dates.t2Annual.StrictlySmallerThan(last))
                {
                    lastRv = dates.t2Annual;
                }
            }
            else if (first.freq == EFreq.Q)
            {
                if (dates.t1Quarterly.StrictlyLargerThan(first))
                {
                    offset = dates.t1Quarterly.Subtract(first);
                    firstRv = dates.t1Quarterly;
                }
                if (dates.t2Quarterly.StrictlySmallerThan(last))
                {
                    lastRv = dates.t2Quarterly;
                }
            }
            else if (first.freq == EFreq.M)
            {
                if (dates.t1Monthly.StrictlyLargerThan(first))
                {
                    offset = dates.t1Monthly.Subtract(first);
                    firstRv = dates.t1Monthly;
                }
                if (dates.t2Monthly.StrictlySmallerThan(last))
                {
                    lastRv = dates.t2Monthly;
                }
            }
            return new Tuple<GekkoTime, GekkoTime, int>(firstRv, lastRv, offset);
        }

        /// <summary>
        /// Read all "records" (timeseries) from a .tsd file. A .tsd file may contain mixed frequencies.
        /// </summary>
        /// <param name="file"></param>
        /// <param name="merge"></param>
        /// <param name="isTsdx"></param>
        /// <param name="databank"></param>
        /// <param name="NaNCounter"></param>
        /// <param name="readInfo"></param>
        public static void ReadAllTsdRecords(string file, bool merge, bool isTsdx, Databank databank, ref int NaNCounter, ReadInfo readInfo)
        {
            int smallWarnings = 0;
            int emptyWarnings = 0;
            if (!merge)
            {
                databank.Clear();
            }

            if (Globals.threadIsInProcessOfAborting) throw new GekkoException();
            double[] tempArray = new double[100000]; //we don't expect series with more than 100000 obs.
            int counter = 0;
            using (FileStream fs = WaitForFileStream(file, null, GekkoFileReadOrWrite.Read))
            using (StreamReader sr = new StreamReader(fs))
            {
                //file should not contain æøå, so no need to use GetTextFromFileWithWait()

                string line = null;
                int nextState = 1;
                string varName = null;
                string frequency = null;
                EFreq freq = EFreq.A;

                DateTime t0 = DateTime.Now;
                DateTime t1 = DateTime.Now;
                DateTime t2 = DateTime.Now;
                int ii = 0;
                int d1min = int.MaxValue;
                int d2max = int.MinValue;
                int d1 = 0, d1sub = 0, d2 = 0, d2sub = 0; int d1subsub = 0; int d2subsub = 0;
                int countdata = 0;
                int obs = 0;
                int obsLeft = 0;
                //int datalines = 0;
                Series ts = null;

                int lineCounter = 0;

                while ((line = sr.ReadLine()) != null)
                {
                    lineCounter++;

                    try
                    {

                        line = line.Replace("\0", " ");
                        string lineTrim = line.Trim();
                        if (lineTrim == "") continue;

                        if (nextState == 1)
                        {
                            varName = lineTrim;
                            nextState = 2;
                        }

                        else if (nextState == 2)
                        {
                            //read expression
                            string expr = line.Substring(0, 32).Trim();

                            //read stamp
                            string stamp = line.Substring(32, 8).Trim();

                            //========================================================================================================
                            //                          FREQUENCY LOCATION, indicates where to implement more frequencies
                            //                          quite a lot in rest of method
                            //========================================================================================================
                            //read date
                            int iiStart = 37;
                            string date1 = line.Substring(iiStart + 7, 4);
                            string date1sub = line.Substring(iiStart + 11, 2);
                            string date1subsub = line.Substring(iiStart + 13, 2);
                            string date2 = line.Substring(iiStart + 15, 4);
                            string date2sub = line.Substring(iiStart + 19, 2);
                            string date2subsub = line.Substring(iiStart + 21, 2);
                            frequency = line.Substring(iiStart + 23, 1).ToLower(); //a or q or m or d
                            try
                            {
                                d1 = int.Parse(date1);
                            }
                            catch
                            {
                                new Error("" + varName + ": could not parse '" + date1 + "' as an int (start year)");
                                //throw new GekkoException();
                            }
                            try
                            {
                                d1sub = int.Parse(date1sub);
                            }
                            catch
                            {
                                new Error("" + varName + ": could not parse '" + date1sub + "' as an int (start sub-period)");
                            }
                            if (frequency == "w" || frequency == "d")
                            {
                                try
                                {
                                    d1subsub = int.Parse(date1subsub);
                                }
                                catch
                                {
                                    new Error("" + varName + ": could not parse '" + date1subsub + "' as an int (start day)");
                                }
                            }
                            try
                            {
                                d2 = int.Parse(date2);
                            }
                            catch
                            {
                                new Error("" + varName + ": could not parse '" + date2 + "' as an int (end year)");
                            }
                            try
                            {
                                d2sub = int.Parse(date2sub);
                            }
                            catch
                            {
                                new Error("" + varName + ": could not parse '" + date2sub + "' as an int (end sub-period)");
                            }
                            if (frequency == "w" || frequency == "d")
                            {
                                try
                                {
                                    d2subsub = int.Parse(date2subsub);
                                }
                                catch
                                {
                                    new Error("" + varName + ": could not parse '" + date2subsub + "' as an int (end day)");
                                }
                            }

                            d1min = G.GekkoMin(d1, d1min);  //finding min and max years
                            d2max = G.GekkoMax(d2, d2max);

                            //preparing nextState = 3
                            {

                                bool ok = G.IsSimpleToken(varName);
                                string label = null;
                                if (!ok)
                                {
                                    if (varName.Length >= 17)
                                    {
                                        //Of this type, where the first 16 chars is the name, and the rest is the label
                                        //gdp2            GDP in version 2, mia. DKK
                                        string v1 = varName.Substring(0, 16).Trim();
                                        string v2 = varName.Substring(16, varName.Length - 16).Trim();

                                        if (!G.IsSimpleToken(v1))
                                        {
                                            new Error("Tsd read: the following name is malformed: " + v1 + ". The name should contain letters, digits or underscore only (it seems there is a label starting in position 17, this is ok).");
                                        }

                                        varName = v1;
                                        label = v2;
                                    }
                                    else
                                    {
                                        new Error("Tsd read: the following name is malformed: " + varName + ". The name should contain letters, digits or underscore only");
                                    }
                                }

                                countdata = 0;
                                freq = G.ConvertFreq(frequency);

                                if (freq == EFreq.W)
                                {
                                    GekkoTime gtw1 = ISOWeek.ToGekkoTime(new DateTime(d1, d1sub, d1subsub));
                                    GekkoTime gtw2 = ISOWeek.ToGekkoTime(new DateTime(d2, d2sub, d2subsub));
                                    obs = GekkoTime.Observations(gtw1, gtw2);
                                }
                                else
                                {
                                    obs = GekkoTime.Observations(new GekkoTime(freq, d1, d1sub, d1subsub), new GekkoTime(freq, d2, d2sub, d2subsub));
                                }

                                obsLeft = obs;
                                ts = null;
                                if (IsNonsenseVariableName(varName))
                                {
                                    emptyWarnings++;
                                    ts = new Series(freq, varName);  //completely phoney, will not live after exit of this method: just so that we can continue
                                }
                                else
                                {
                                    ts = FindOrCreateTimeSeriesInDataBank(databank, varName, freq);
                                }
                                if (label != null && label != "") ts.meta.label = label;
                                if (expr != null && expr != "") ts.meta.source = expr;
                                if (stamp != null && stamp != "") ts.meta.stamp = stamp;
                                //datalines = 0;
                                nextState = 3;
                            }

                        }
                        else if (nextState == 3)
                        {
                            int n = Math.Min(5, obsLeft);
                            for (int i5 = 0; i5 < n; i5++)
                            {
                                double ss = double.NaN;
                                bool success = false;
                                int width = 0;
                                if (isTsdx)
                                {
                                    width = 21;
                                }
                                else
                                {
                                    width = 15;
                                }
                                success = G.TryParseIntoDouble(line.Substring(ii + i5 * width, width), out ss);
                                if (!success)
                                {
                                    string toParse = line.Substring(ii + i5 * width, width).Trim();
                                    if (G.Equal(toParse, "NaN") || G.Equal(toParse, "-NaN"))
                                    {
                                        ss = 1e+15;  //signals missing value
                                        NaNCounter++;
                                    }
                                    else
                                    {
                                        new Error("" + varName + ": could not parse '" + toParse + "' as a number");
                                    }
                                }

                                if (ss == 1e+15)
                                {
                                    ss = double.NaN;
                                }
                                else
                                {
                                    if (Math.Abs(ss) < 1e-37 && ss != 0d)
                                    {
                                        smallWarnings++;
                                        ss = 0d;  //numbers smaller than this become imprecise when imported from AREMOS
                                                  //AREMOS sets all numbers > 1e+15 to 1e+15 when exporting, so no need to do this for large numbers
                                    }
                                }
                                tempArray[countdata] = ss;
                                countdata++;
                                obsLeft--;
                            }

                            if (obsLeft == 0)
                            {
                                GekkoTime gt1 = GekkoTime.tNull;
                                GekkoTime gt2 = GekkoTime.tNull;
                                if (freq == EFreq.W)
                                {
                                    gt1 = ISOWeek.ToGekkoTime(new DateTime(d1, d1sub, d1subsub));
                                    gt2 = ISOWeek.ToGekkoTime(new DateTime(d2, d2sub, d2subsub));
                                }
                                else
                                {
                                    gt1 = new GekkoTime(freq, d1, d1sub, d1subsub);
                                    gt2 = new GekkoTime(freq, d2, d2sub, d2subsub);
                                }

                                int offset = 0;

                                int nob = GekkoTime.Observations(gt1, gt2);
                                if (nob > 0)
                                {
                                    ts.SetDataSequence(gt1, gt2, tempArray, offset);
                                    ts.Trim(); //to save ram                                                             
                                }
                                counter++;
                                nextState = 1;
                            }
                        }
                    }
                    catch
                    {
                        new Error("TSD import failed on line: " + lineCounter);  //#0984252438
                    }
                }  //end of readline from file
                readInfo.startPerInFile = d1min;
                readInfo.endPerInFile = d2max;
                readInfo.variables = counter;
                if (emptyWarnings > 0) new Warning(emptyWarnings + " variables with empty string as name in .tsd file (skipped)");
                if (smallWarnings > 0) new Warning(smallWarnings + " numbers numerically smaller than 1.0e-37 were set to 0");

            }
        }

        /// <summary>
        /// Read the Gekko-specific "flat" databank format. For instance, a line could be: x1 2001 2004 10 m -20 30.0, meaning that x1 is the
        /// series name, 2001-2004 are the dates, and 10, m, -20, 30.0 are the data (m is missing). The format resembles Gekko series assignment
        /// statements, but is much faster to parser and read. Often used when such data lines are produced from other software packages.
        /// </summary>
        /// <param name="databank"></param>
        /// <param name="readInfo"></param>
        /// <param name="fileLocal"></param>
        public static void ReadFlat(Databank databank, ReadInfo readInfo, string fileLocal)
        {
            // x1 2001 2004 10 m -20 30.0

            DateTime dt1 = DateTime.Now;

            int variableCounter = 0;

            char[] c = new char[] { ' ' };
            double[] tempArray = new double[10000];

            int n = 0;

            int year1 = int.MaxValue;
            int year2 = int.MinValue;

            //Is all code without æøå, so no need to use GetTextFromFile() to handle ANSI
            using (FileStream fs = WaitForFileStream(fileLocal, null, GekkoFileReadOrWrite.Read))
            using (StreamReader sr = new StreamReader(fs))
            {
                while (sr.Peek() >= 0)
                {
                    string line = sr.ReadLine().Trim();
                    n++;
                    if (line == "" || line.StartsWith("//")) continue;
                    string[] linesplit = line.Split(c, StringSplitOptions.RemoveEmptyEntries);
                    string varname = linesplit[0];
                    if (linesplit.Length < 3)
                    {
                        new Error("IMPORT<flat>: Expected two dates for series '" + varname + "' (line " + n + ")");
                    }

                    string per1 = linesplit[1];
                    GekkoTime gt1 = GekkoTime.FromStringToGekkoTime(per1, true);
                    year1 = Math.Min(year1, gt1.super);

                    string per2 = linesplit[2];
                    GekkoTime gt2 = GekkoTime.FromStringToGekkoTime(per2, true);
                    year2 = Math.Max(year2, gt2.super);

                    if (gt1.freq != gt2.freq)
                    {
                        new Error("IMPORT<flat>: Dates for series '" + varname + "' have different frequencies (line " + n + ")");
                    }

                    int obs = GekkoTime.Observations(gt1, gt2);
                    int obs2 = linesplit.Length - 3;

                    if (obs < 1)
                    {
                        new Error("IMPORT<flat>: Invalid time period for series '" + varname + "' (line " + n + ")");
                    }

                    if (obs > 10000)
                    {
                        new Error("IMPORT<flat>: More then 10000 periods for series '" + varname + "' (line " + n + ")");
                    }

                    if (obs2 == 0)
                    {
                        new Error("IMPORT<flat>: Expected > 0 observations for series '" + varname + "' (line " + n + ")");
                    }

                    if (obs != obs2 && obs2 > 1)  //for obs2 = 1, any timeperiod is ok.
                    {
                        new Error("IMPORT<flat>: Expected " + obs + " observations for for series '" + varname + "', got " + obs2 + " (line " + n + ")");
                    }

                    Series ts = FindOrCreateTimeSeriesInDataBank(databank, varname, gt1.freq);

                    for (int i = 3; i < linesplit.Length; i++)
                    {
                        int ii = i - 3;  //starts with 0
                        string s = linesplit[i];

                        double ss = double.NaN;

                        if (G.Equal(s, "m") || G.Equal(s, "m()"))
                        {
                            //do nothing, it is a missing value.
                        }
                        else
                        {
                            try
                            {
                                ss = G.ParseIntoDouble(s, true);
                            }
                            catch
                            {
                                new Error("Could not understand '" + s + "' as a number for series '" + varname + "' (line " + n + ")");
                            }
                        }

                        tempArray[ii] = ss;
                    }

                    if (obs2 == 1)
                    {
                        for (int i = 1; i < obs; i++)
                        {
                            tempArray[i] = tempArray[0];  //copy the first value to the rest
                        }
                    }

                    ts.SetDataSequence(gt1, gt2, tempArray);
                    ts.Trim();  //to save RAM
                }
            }

            readInfo.startPerInFile = year1;
            readInfo.endPerInFile = year2;
            readInfo.nanCounter = 0;
            readInfo.variables = n;
            readInfo.time = (DateTime.Now - dt1).TotalMilliseconds;
            readInfo.startPerResultingBank = readInfo.startPerInFile;
            readInfo.endPerResultingBank = readInfo.endPerInFile;

        }

        /// <summary>
        /// Reads AREMOS "dump" files.
        /// </summary>
        /// <param name="databank"></param>
        /// <param name="readInfo"></param>
        /// <param name="fileLocal"></param>
        public static void ReadAremos(Databank databank, ReadInfo readInfo, string fileLocal)
        {

            // AREMOS dump format


            /*
            
            The following is an AREMOS procedure to dump all banks listed (here: abase, arsbased, ...)
            
            -------------------------------------------------------------------
            procedure dump1 list m;                    !navne uden .bnk extension
              set report columns 35 decimals 20;
              set databank limit 25000;                !hold øje med at der ikke er nogen 'Search truncated by limit'
              for i = #m;
                close *; clear;
                open #i;
                dump * #i|.dmp;
                close *; clear;
              end;
            end;

            list banker = abase, arsbased, dbase, dbasemd, justbyt, KADAM, kadamaar, kadamk, kadamkaar, knrsup, matis, matisk, t5, testdump;
            dump1 #banker; 
            -------------------------------------------------------------------

            In Gekko:

            -------------------------------------------------------------------
            reset;

            global:#i = abase, arsbased, dbase, dbasemd, justbyt, KADAM, kadamaar, kadamk, kadamkaar, matis, matisk, t5;

            time 1900 2500;
            for string %i = #i;
              clear work;
              import<aremos>{%i}.dmp;
              write {%i};
            end;
            -------------------------------------------------------------------

            The format looks like this from AREMOS:
             
             SERIES<ANNUAL
             90 120 > X.A
              =              1.00000000000000000000, ...
                             1.00000000000000000000;

             SERIES<QUARTERLY
             90Q1 120Q4 > X.Q
              =              4.00000000000000000000, ...
                             4.00000000000000000000;

             SERIES<MONTHLY
             90M1 120M12 > X.M
              =             12.00000000000000000000, ...
                            12.00000000000000000000;

             MATRIX M1.NULL  =
                [              1.00000000000000000000,
                               2.00000000000000000000 ] ||
                [              3.00000000000000000000,
                               4.00000000000000000000 ];
             
             LIST M2.NULL
              = A,B,C
             ;

             * 
             * 
             * */

            int emptyWarnings = 0;
            int firstYearWarnings = 0;

            int matrixError = 0;

            DateTime dt1 = DateTime.Now;

            int variableCounter = 0;


            char[] c = new char[] { ' ' };
            double[] tempArray = new double[10000];

            int n = 0;

            int year1 = int.MaxValue;
            int year2 = int.MinValue;

            string txt = Program.GetTextFromFileWithWait(fileLocal);
            TokenList tokens = StringTokenizer.GetTokensWithLeftBlanksSkipNewlines(txt, 10, null, null, null, null);

            int nSeries = 0;
            int nList = 0;

            for (int i = 0; i < tokens.storage.Count; i++)
            {

                if (G.Equal(tokens[i].s, "matrix"))
                {
                    matrixError++;
                }
                else if (G.Equal(tokens[i].s, "series"))
                {
                    nSeries++;

                    if (tokens[i + 1].s != "<")
                    {
                        new Error("Expected '<', " + tokens[i + 1].LineAndPosText());
                        //throw new GekkoException();
                    }

                    string freq2 = tokens[i + 2].s;
                    EFreq freq = EFreq.A;
                    if (G.Equal(freq2, "annual")) freq = EFreq.A;
                    else if (G.Equal(freq2, "quarterly")) freq = EFreq.Q;
                    else if (G.Equal(freq2, "monthly")) freq = EFreq.M;
                    else
                    {
                        new Error("Expected 'ANNUAL', 'QUARTERLY' or 'MONTHLY', " + tokens[i + 2].LineAndPosText());
                        //throw new GekkoException();
                    }

                    GekkoTime gt1 = GekkoTime.tNull;
                    GekkoTime gt2 = GekkoTime.tNull;
                    int offset = 0;
                    if (tokens[i + 4].leftblanks == 0 && tokens[i + 6].leftblanks == 0)
                    {
                        offset = 2;
                        string t1 = tokens[i + 3].s + tokens[i + 4].s;
                        gt1 = GekkoTime.FromStringToGekkoTime(t1);
                        string t2 = tokens[i + 5].s + tokens[i + 6].s;
                        gt2 = GekkoTime.FromStringToGekkoTime(t2);
                    }
                    else
                    {
                        string t1 = tokens[i + 3].s;
                        gt1 = GekkoTime.FromStringToGekkoTime(t1);
                        string t2 = tokens[i + 4].s;
                        gt2 = GekkoTime.FromStringToGekkoTime(t2);
                    }

                    year1 = Math.Min(year1, gt1.super);
                    year2 = Math.Max(year2, gt2.super);

                    if (tokens[i + 5 + offset].s != ">")
                    {
                        new Error("Expected '>', " + tokens[i + 5 + offset].LineAndPosText());
                        //throw new GekkoException();
                    }

                    string name1 = tokens[i + 6 + offset].s;

                    if (tokens[i + 7 + offset].s != ".")
                    {
                        new Error("Expected '.', " + tokens[i + 7 + offset].LineAndPosText());
                        //throw new GekkoException();
                    }
                    string name2 = tokens[i + 8 + offset].s;

                    string name = name1;
                    if (!G.Equal(name2, "null"))
                    {
                        if (!G.Equal(name2, G.ConvertFreq(freq)))
                        {
                            //for instance quarterly x.sol (not x.q)
                            new Warning("Changed " + name1 + "." + name2 + " into " + name1 + "_" + name2 + "!" + G.ConvertFreq(freq));
                            name += "_" + name2;
                        }
                    }
                    name = name + Globals.freqIndicator + G.ConvertFreq(freq);
                    Series ts = new Series(freq, name);
                    if (databank.ContainsIVariable(name))
                    {
                        new Error("Dublet series name ('" + name + "')");
                        //throw new GekkoException();
                    }
                    databank.AddIVariable(name, ts);

                    if (tokens[i + 9 + offset].type == ETokenType.QuotedString)
                    {
                        ts.meta.label = G.StripQuotes(tokens[i + 9 + offset].s);
                        offset++;
                    }

                    if (tokens[i + 9 + offset].type == ETokenType.QuotedString)
                    {
                        ts.meta.source = G.StripQuotes(tokens[i + 9 + offset].s);
                        offset++;
                    }

                    if (tokens[i + 9 + offset].s != "=")
                    {
                        new Error("Expected '=', " + tokens[i + 9 + offset].LineAndPosText());
                        //throw new GekkoException();
                    }

                    int counter = -1;

                    int state = 0;
                    for (int j = i + 10 + offset; j < tokens.storage.Count; j++)
                    {
                        if (state == 0)
                        {
                            bool minus = false;
                            if (G.Equal(tokens[j].s, "-"))
                            {
                                minus = true;
                                j++;
                            }

                            double d = double.NaN;
                            if (G.Equal(tokens[j].s, "m"))
                            {
                                //do nothing, it is a missing value.
                                counter++;
                                ts.SetData(gt1.Add(counter), d);
                            }
                            else
                            {
                                try
                                {
                                    d = G.ParseIntoDouble(tokens[j].s);
                                    counter++;
                                    if (minus) d = -d;
                                    ts.SetData(gt1.Add(counter), d);
                                }
                                catch
                                {
                                    new Error("Could not understand '" + tokens[j].s + "' as a number, " + tokens[j].LineAndPosText());
                                    //throw new GekkoException();
                                }
                            }
                            state = 1;
                        }
                        else
                        {
                            if (tokens[j].s == ";")
                            {
                                i = j;
                                break;
                            }
                            else if (tokens[j].s != ",")
                            {
                                new Error("Expected ',', " + tokens[j].LineAndPosText());
                                //throw new GekkoException();
                            }
                            state = 0;
                        }
                    }
                }
                else if (G.Equal(tokens[i].s, "list"))
                {
                    nList++;

                    int offset = 0;

                    string name1 = tokens[i + 1 + offset].s;
                    if (tokens[i + 2 + offset].s != ".")
                    {
                        new Error("Expected '.', " + tokens[i + 2 + offset].LineAndPosText());
                        //throw new GekkoException();
                    }
                    string name2 = tokens[i + 3 + offset].s;

                    string name = name1;
                    if (!G.Equal(name2, "null"))
                    {
                        new Error("Expected '.', " + tokens[i + 7 + offset].LineAndPosText());
                    }
                    name = Globals.symbolCollection + name;

                    List lst = new List();

                    if (databank.ContainsIVariable(name))
                    {
                        new Error("Dublet list name ('" + name + "')");
                        //throw new GekkoException();
                    }
                    databank.AddIVariable(name, lst);

                    if (tokens[i + 4 + offset].s != "=")
                    {
                        new Error("Expected '=', " + tokens[i + 4 + offset].LineAndPosText());
                        //throw new GekkoException();
                    }

                    int counter = -1;

                    int state = 0;
                    for (int j = i + 5 + offset; j < tokens.storage.Count; j++)
                    {
                        if (state == 0)
                        {
                            counter++;
                            lst.list.Add(new ScalarString(tokens[j].s));
                            state = 1;
                        }
                        else
                        {
                            if (tokens[j].s == ";")
                            {
                                i = j;
                                break;
                            }
                            else if (tokens[j].s != ",")
                            {
                                new Error("Expected ',', " + tokens[j].LineAndPosText());
                                //throw new GekkoException();
                            }
                            state = 0;
                        }
                    }
                }
            }

            G.Writeln();
            if (nSeries > 0) G.Writeln(nSeries + " series imported");
            if (nList > 0) G.Writeln(nList + " lists imported");

            if (matrixError > 0)
            {
                new Note("Matrix not yet implemented (" + matrixError + " statements ignored)");
            }

            n = nSeries + nList;

            readInfo.startPerInFile = year1;
            readInfo.endPerInFile = year2;
            readInfo.nanCounter = 0;

            readInfo.variables = n;  //does not count emptyWarnings
            readInfo.time = (DateTime.Now - dt1).TotalMilliseconds;

            readInfo.startPerResultingBank = readInfo.startPerInFile;
            readInfo.endPerResultingBank = readInfo.endPerInFile;

        }        

        /// <summary>
        /// Helper method for the ReadPx() method
        /// </summary>
        /// <param name="databank"></param>
        /// <param name="oRead"></param>
        /// <param name="readInfo"></param>
        /// <param name="fileLocal"></param>
        public static void ReadPxHelper(Databank databank, ReadOpenMulbkHelper oRead, ReadInfo readInfo, string fileLocal)
        {
            //merge and date truncation:
            //do this by first reading into a Gekko databank, and then merge that with the merge facilities from gbk read

            DateTime dt1 = DateTime.Now;

            string pxLinesText = Program.GetTextFromFileWithWait(fileLocal);  //also removes some kinds of funny characters

            int vars = -12345;
            GekkoTime startYear;
            GekkoTime endYear;
            string warning = null;
            ReadPx(databank, oRead.array, false, null, null, null, pxLinesText, oRead.isVariablecode, out vars, out warning, out startYear, out endYear);
            if (warning != null) new Warning(warning);

            readInfo.startPerInFile = startYear.super;
            readInfo.endPerInFile = endYear.super;
            readInfo.variables = vars;
            readInfo.time = (DateTime.Now - dt1).TotalMilliseconds;

            readInfo.startPerResultingBank = readInfo.startPerInFile;
            readInfo.endPerResultingBank = readInfo.endPerInFile;

            return;

        }

        /// <summary>
        /// Read the PCIM data file format
        /// </summary>
        /// <param name="databank"></param>
        /// <param name="readInfo"></param>
        /// <param name="fileLocal"></param>
        public static void ReadPCIM(Databank databank, ReadInfo readInfo, string fileLocal)
        {

            //try
            {
                //Databank databank = readInfo.databank;

                int emptyWarnings = 0;
                int firstYearWarnings = 0;

                DateTime dt1 = DateTime.Now;
                int variableCounter = 0;

                //Is all code without æøå, so no need to use GetTextFromFile() to handle ANSI
                using (FileStream fs = WaitForFileStream(fileLocal, null, GekkoFileReadOrWrite.Read))
                using (BinaryReader binreader = new BinaryReader(fs))
                {
                    float ver = binreader.ReadSingle();
                    G.WritelnGray("Version: " + ver);
                    Int16 fmaxa = binreader.ReadInt16();  //number of variables+1
                    Int16 ffil = binreader.ReadInt16();
                    char[] fmodel = new char[12];
                    fmodel = binreader.ReadChars(12);
                    string model = new string(fmodel);
                    Int16 fsmpl1 = binreader.ReadInt16();
                    Int16 fsmpl2 = binreader.ReadInt16();
                    Int16 fant = binreader.ReadInt16();
                    Int16 fmsta = binreader.ReadInt16();
                    Int16 fcre = binreader.ReadInt16();
                    Int16 fmaxl = binreader.ReadInt16();
                    char[] fhdg = new char[80];
                    fhdg = binreader.ReadChars(80);
                    string sfhdg = new string(fhdg);
                    char[] fdato = new char[8];
                    fdato = binreader.ReadChars(8);
                    string sfdato = new string(fdato);
                    char[] ftid = new char[5];
                    ftid = binreader.ReadChars(5);
                    string sftid = new string(ftid);
                    readInfo.info1 = sfhdg.Trim();
                    string date = sfdato + " " + sftid;
                    string date2 = sfdato;
                    date2 = date2.Replace(" ", "");
                    string[] date3 = date2.Split('/');
                    if (date3.Length == 3)
                    {
                        string d0 = date3[0].Trim();
                        string d1 = date3[1].Trim();
                        string d2 = date3[2].Trim();
                        string date4 = date3[2];
                        int date5 = 0;
                        if (int.TryParse(date4, out date5))
                        {
                            if (date5 <= 20)
                            {
                                int date6 = date5 + 2000;
                                //date += " (the '" + date5 + "' probably means " + date6 + ")";
                                d2 = date6.ToString();
                            }
                            else if (date5 >= 70 && date5 <= 99)
                            {
                                int date6 = date5 + 1900;
                                //date += " (the '" + date5 + "' probably means " + date6 + ")";
                                d2 = date6.ToString();
                            }
                        }
                        date = d0 + "-" + d1 + "-" + d2 + " " + sftid;
                    }

                    readInfo.date = date.Trim();
                    readInfo.pcim = model.Trim();
                    Int16[] fid = new Int16[ffil];   //year
                    for (int i = 0; i < ffil; i++)
                    {
                        fid[i] = binreader.ReadInt16();
                    }

                    int varnamelength = 16;
                    if (Math.Abs(ver - 3.1d) < 0.00001) varnamelength = 8;

                    binreader.BaseStream.Position = 0;
                    binreader.BaseStream.Position = fmaxa * 4;
                    string[] navne = new string[fmaxa];  //variable names
                    char[] temp = new char[varnamelength];
                    for (int i = 0; i < fmaxa; i++)
                    {
                        temp = binreader.ReadChars(varnamelength);
                        navne[i] = new string(temp);
                        if (navne[i].Trim() == "")
                        {
                            G.Writeln();
                        }
                    }
                    int antalper = fsmpl2 - fsmpl1 + 1;  //antal perioder

                    float[,] gigant = new float[fmaxa, antalper + 1];  //per 0 is empty
                    for (int per = 0; per < antalper + 1; per++)
                    {
                        for (int var = 0; var < fmaxa; var++)
                        {
                            float val = binreader.ReadSingle();  //it seems that for per=0, all val er always 0. Maybe something to do with Fortran arrays starting at index 1??
                            gigant[var, per] = val;
                            if (per == 0 && val != 0)
                            {
                                firstYearWarnings++; //for almost all banks this is never so, but some banks may contain a number in this slot. This number will be ignored, but the issue will be reported.
                            }
                        }
                    }

                    binreader.Close();

                    //turning the loop around, so we can use tempArray speedup
                    double[] tempArray = new double[10000]; //we don't expect series with more than 10000 obs.
                    int year1 = fid[0];
                    int year2 = year1 + antalper - 1;

                    if (fid[antalper - 1] != year1 + antalper - 1)
                    {
                        new Error("Strange error while reading PCIM databank file");
                        //throw new GekkoException();
                    }

                    for (int var = 0; var < fmaxa - 1; var++)  //There are really only fmaxa-1 variables, the last one in navne[] is fake
                    {
                        string varName = navne[var];
                        varName = varName.Trim();

                        if (IsNonsenseVariableName(varName))  //empty or "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
                        {
                            emptyWarnings++; //probably some artefact creeping in???
                            continue;
                        }

                        Series ts = FindOrCreateTimeSeriesInDataBank(databank, varName, EFreq.A);

                        if (true)
                        {
                            //faster
                            for (int per = 0; per < antalper; per++)
                            {
                                short year = fid[per];
                                float ss = gigant[var, per + 1];  //<==== because gigant[] is 1-based, not 0-based
                                tempArray[per] = ss;
                            }
                            GekkoTime gt1 = new GekkoTime(EFreq.A, year1, 1);
                            GekkoTime gt2 = new GekkoTime(EFreq.A, year2, 1);
                            ts.SetDataSequence(gt1, gt2, tempArray);
                            ts.Trim();  //to save RAM
                            variableCounter++;
                            //G.Writeln(varName + " var# " + var);
                        }

                    }

                    readInfo.startPerInFile = year1;
                    readInfo.endPerInFile = year2;
                    readInfo.nanCounter = 0;
                    readInfo.databankVersion = "(vers: PCIM " + ver + ")";

                    readInfo.variables = variableCounter;  //does not count emptyWarnings
                    readInfo.time = (DateTime.Now - dt1).TotalMilliseconds;

                    readInfo.startPerResultingBank = readInfo.startPerInFile;
                    readInfo.endPerResultingBank = readInfo.endPerInFile;


                    if (firstYearWarnings > 0) new Warning(firstYearWarnings + " variables had data before databank time period (data skipped)");

                    //readInfo.databank.info1 = readInfo.info1;
                    //readInfo.databank.date = readInfo.date;
                    //readInfo.databank.FileNameWithPath = readInfo.fileName;

                    return;
                }
            }
        }

        /// <summary>
        /// Read the .px data file format (used by Statistics Denmark and others)
        /// </summary>
        public static void ReadPx(Databank databank, string array, bool isDownload, string source, string tableName, List<string> codesHeaderJson, string pxLinesText, bool isVariablecode, out int vars, out string numberOfDataPointsWarning, out GekkoTime perStart, out GekkoTime perEnd)
        {
            string variablecodeNote = null;

            bool pxAllowAnyTimeDimensionIndex = false;  //starts out false. May become true if time dimension is not last

            bool isArray = false; if (G.Equal(array, "yes")) isArray = true;

            bool hyphenFound = false;
            bool underscoreFound = false;

            List<int> holes = null;  //!! important that it starts out as null !!
            List<int> holesForWarningMessage = null;
            int totalDatesIncludingHoles = -12345;  //including holes

            GekkoTime gt_start = GekkoTime.tNull;
            GekkoTime gt_end = GekkoTime.tNull;
            string freq = "a";
            int obs = -12345; //number of observations
            int expectedNumberOfDataInPxFile = -12345;
            int foundNumberOfDataInPxFile = 0;
            numberOfDataPointsWarning = null;
            bool hasSeenTimeDefinition = false;

            List<string> dates = new List<string>();

            List<string> lines2 = Stringlist.ExtractLinesFromText(pxLinesText);
            pxLinesText = null;  //clearing it

            List<string> codesHeader = new List<string>();
            List<List<string>> codes = new List<List<string>>();
            List<List<string>> codesIncludingTime = new List<List<string>>();
            List<List<string>> values = new List<List<string>>();
            GekkoDictionary<string, string> variablecodes = new GekkoDictionary<string, string>(StringComparer.OrdinalIgnoreCase);

            int timeDimensionIncodesIncludingTime = -12345;
            int[] indexes = null;

            //int counter = 0;
            string codeTimeString = "CODES(\"tid\")=";
            string codeTimeString2 = "CODES(\"time\")=";
            string codeString = "CODES(";
            string valueString = "VALUES(";
            string matrixString = "MATRIX=";
            string variableCodeString = "VARIABLECODE(";

            List<string> codesCombi = null;
            List<string> valuesCombi = null;

            StringBuilder lineHelper = new StringBuilder();
            double[] data = null;
            int ii = 0;
            int jj = 0;

            List<int> fractions = new List<int>();
            List<double> fractions2 = new List<double>();
            for (double dd = 0.1; dd <= 1.0; dd = dd + 0.1)
            {
                fractions.Add((int)(dd * (double)lines2.Count));
                fractions2.Add(dd);
            }

            int lineCounter = 0;

            G.Writeln2("Starting to read " + lines2.Count + " data lines from data file");

            GekkoTime gt0 = GekkoTime.tNull;
            GekkoTime gt1 = GekkoTime.tNull;

            int state = 0;  //DATA=1, CODES("tid")=2, CODES(...)=3, VALUES(...)=4, VARIABLECODE(...)=5
            foreach (string line2 in lines2)
            {
                lineCounter++;
                if (lines2.Count >= 10000)
                {
                    for (int i = 0; i < fractions.Count; i++)
                    {
                        if (fractions[i] == lineCounter)
                        {
                            G.Writeln("    Progress: " + (int)(Math.Round(100 * fractions2[i])) + "% of " + lines2.Count + " data lines");
                        }
                    }
                }

                string line = line2.Trim();
                bool semi = false;
                bool firstLine = false;

                if (line.StartsWith("DATA=", StringComparison.OrdinalIgnoreCase))
                {
                    lineHelper = null; //not used 
                    state = 1;
                    firstLine = true;
                    line = line.Substring("DATA=".Length);
                    line = line.Trim();  //may have blank after =
                }
                else if (line.StartsWith(codeTimeString, StringComparison.OrdinalIgnoreCase) || line.StartsWith(codeTimeString2, StringComparison.OrdinalIgnoreCase))
                {
                    lineHelper = new StringBuilder();
                    firstLine = true;
                    state = 2;
                }
                else if (line.StartsWith(codeString, StringComparison.OrdinalIgnoreCase))
                {
                    lineHelper = new StringBuilder();
                    firstLine = true;
                    state = 3;
                }
                else if (line.StartsWith(valueString, StringComparison.OrdinalIgnoreCase))
                {
                    lineHelper = new StringBuilder();
                    firstLine = true;
                    state = 4;
                }
                else if (line.StartsWith(variableCodeString, StringComparison.OrdinalIgnoreCase))
                {
                    lineHelper = new StringBuilder();
                    firstLine = true;
                    state = 5;
                }
                else if (line.StartsWith(matrixString, StringComparison.OrdinalIgnoreCase))
                {
                    if (tableName == null)
                    {
                        tableName = line.Substring(matrixString.Length).Replace("\"", "").Replace(";", "").Trim();
                    }
                }
                else
                {
                    firstLine = false;
                }

                if (line.EndsWith(";"))
                {
                    line = line.Substring(0, line.Length - 1);
                    semi = true;
                }

                if (state == 1)
                {
                    //special treatment
                }
                else
                {
                    lineHelper.Append(line);
                    if (!semi) continue;
                }

                if (state == 1)
                {
                    //state=1, handle the data and convert it from strings to real numbers (double)   

                    if (!hasSeenTimeDefinition)
                    {
                        new Error("It does not seem that the px file contains a time dimension, since CODES(\"tid\") or CODES(\"time\") does not seem to be present. If the px file originates from a {a{DOWNLOAD¤download.htm}a}, make sure to include a \"code\": \"tid\" or \"code\": \"time\" field last in your .json file.");
                    }

                    if (firstLine)
                    {
                        indexes = new int[codesIncludingTime.Count];

                        int totalHoles = 0;
                        if (holes != null) totalHoles = holes[holes.Count - 1];
                        totalDatesIncludingHoles = dates.Count + totalHoles;

                        codesCombi = new List<string>();
                        valuesCombi = new List<string>();

                        List<string> codesHeader2 = codesHeaderJson;
                        if (codesHeader2 == null)
                        {
                            codesHeader2 = codesHeader;
                            codesHeader2.Add("TID");  //will be removed again below!
                        }

                        if (pxAllowAnyTimeDimensionIndex)
                        {
                            List<string> temp = new List<string>();
                            foreach (string s5 in codesHeader2)
                            {
                                if (G.Equal(s5, "tid") || G.Equal(s5, "time"))
                                {
                                    //skip
                                }
                                else
                                {
                                    temp.Add(s5);
                                }
                            }
                            temp.Insert(timeDimensionIncodesIncludingTime, "tid");
                            codesHeader2 = temp;
                            codes.Insert(timeDimensionIncodesIncludingTime, null);
                        }

                        //we may use codesHeaderJson instead of codesHeader (these are more verbose)
                        //also we may use alias for these headers, if we have import<px variablecode>.
                        List<string> codesHeader3 = null;
                        if (isVariablecode)
                        {
                            codesHeader3 = new List<string>();
                            foreach (string s7 in codesHeader2)
                            {
                                string s2 = null; variablecodes.TryGetValue(s7, out s2);
                                if (s2 != null) codesHeader3.Add(s2);
                                else codesHeader3.Add(s7);
                            }
                        }
                        else
                        {
                            if (variablecodes.Count > 0 && !isArray)
                            {
                                variablecodeNote = "The .px file contains variable codes. You may try the <variablecode> option to obtain shorter timeseries names.";
                            }
                            codesHeader3 = codesHeader2;
                        }
                        WalkPxCombinations(pxAllowAnyTimeDimensionIndex, isArray, tableName, codesHeader3, codes, codesCombi, values, valuesCombi, 0, "", "", timeDimensionIncodesIncludingTime, ref hyphenFound, ref underscoreFound);

                        //fill it with NaN for safety. Statistikbanken sometimes return only a subset of the data (and the subset is zeroes)
                        //also handles holes in dates, for instance for daily observations if there is no data for weekends

                        data = G.CreateArrayDouble(codesCombi.Count * totalDatesIncludingHoles, double.NaN);
                        expectedNumberOfDataInPxFile = codesCombi.Count * dates.Count;
                    }

                    string s = line;

                    int sstate = 1;
                    int lastStart = 0;

                    for (int i5 = 0; i5 < s.Length; i5++)
                    {
                        char c = s[i5];
                        if ((c == ' ' || i5 == s.Length - 1) && sstate == 1)
                        {
                            int add = 0;
                            if (i5 == s.Length - 1)
                            {
                                add = 1;
                            }
                            string temp2 = s.Substring(lastStart, i5 - lastStart + add).Trim();

                            double value = double.NaN;

                            if (temp2 == "")
                            {
                                continue;  //if there are more than 1 blank
                            }

                            if (temp2 == "\".\"" || temp2 == "\"..\"" || temp2 == "\"...\"" || temp2 == "\"....\"" || temp2 == "\":\"")
                            {
                                //See http://www.inside-r.org/packages/cran/pxr/docs/read.px
                                //do nothing, "." and ".." and "..." and "...." and ":" will be missing value (these include the quotes in the Axis file)
                            }
                            else
                            {

                                try
                                {
                                    value = G.ParseIntoDouble(temp2);
                                }
                                catch
                                {
                                    new Error("Could not convert '" + temp2 + "' into a number");
                                }
                            }

                            int holesii = 0;
                            if (holes != null) holesii = holes[ii];

                            int x = -12345;

                            if (pxAllowAnyTimeDimensionIndex)
                            {
                                int jj5 = 0;
                                int factor = 1;
                                if (foundNumberOfDataInPxFile > 0) indexes[codesIncludingTime.Count - 1]++; //not for the first
                                //This is a bit like counting. 
                                //If we have 799 and add 1 to that.
                                //Then we get 7 10 0, and then afterwards 8 0 0.
                                //Only here, it is not a 10-number system, but the dimensions have different sizes.
                                for (int i = codesIncludingTime.Count - 1; i >= 0; i--)
                                {
                                    if (indexes[i] >= codesIncludingTime[i].Count)
                                    {
                                        indexes[i - 1] += indexes[i] / codesIncludingTime[i].Count;
                                        indexes[i] = indexes[i] % codesIncludingTime[i].Count;
                                    }
                                    if (i != timeDimensionIncodesIncludingTime)
                                    {
                                        jj5 += factor * indexes[i];
                                        factor = factor * codesIncludingTime[i].Count;
                                    }
                                }

                                int ii5 = indexes[timeDimensionIncodesIncludingTime];
                                int holesii5 = 0;
                                if (holes != null) holesii5 = holes[ii5];
                                x = ii5 + holesii5 + jj5 * totalDatesIncludingHoles;
                            }
                            else
                            {
                                x = ii + holesii + jj * totalDatesIncludingHoles;
                            }

                            if (x >= data.Length)
                            {
                                new Error("More than " + data.Length + " (= " + codesCombi.Count + " x " + totalDatesIncludingHoles + ") numbers found in data section");
                            }

                            if (!double.IsNaN(data[x]))
                            {
                                //Cannot overwrite already existing value --> in that case we have a bug
                                //This check is fast, in principle there is the problem of a position being actively filled with a NaN from the px, but never mind. This catches gross problems.
                                //The check can be removed at some point, for instance in 2024. But maybe just keep it for safety.
                                new Error("Something went wrong regarding .px file reading. Technical detail: the element data[" + x + "] already has a value that cannot be overwritten.");
                            }

                            data[x] = value;  //ii is date, jj is variable
                            foundNumberOfDataInPxFile++;

                            //ii counts dates as they are. If dates are 2021m1d7, 2020m2d8, 2020m2d11, 2020m2d12
                            //ii will be 0, 1, 2, 3 here.
                            //but holes[] will be (0, 0, 2, 2), so ii + holes[ii] becomes (0, 1, 4, 5).
                            //in data[] we will get (data, data, NaN, NaN, data, data), where the 4
                            //numbers are put in.

                            ii++;

                            if (ii > dates.Count - 1)  //do NOT include holes here!
                            {
                                ii = 0;
                                jj++;
                            }
                        }

                        if (c != ' ' && sstate == 2)
                        {
                            lastStart = i5;
                        }

                        if (c == ' ')
                        {
                            sstate = 2;  //blanks
                        }
                        else
                        {
                            sstate = 1;  //nonblanks
                        }

                    }
                }
                else if (state == 2)
                {
                    //Reading dates from CODES("tid")
                    //This will only be run once                    

                    //========================================================================================================
                    //                          FREQUENCY LOCATION, indicates where to implement more frequencies
                    //========================================================================================================

                    hasSeenTimeDefinition = true;

                    string s = lineHelper.ToString();
                    if (s.StartsWith(codeTimeString, StringComparison.OrdinalIgnoreCase)) s = s.Substring(codeTimeString.Length);
                    else if (s.StartsWith(codeTimeString2, StringComparison.OrdinalIgnoreCase)) s = s.Substring(codeTimeString2.Length);

                    string[] ss = ss = G.SplitCsv(s).ToArray();

                    foreach (string s2 in ss)
                    {
                        string s3 = s2;

                        s3 = s3.Trim();

                        if (s3.IndexOf("m", StringComparison.OrdinalIgnoreCase) != -1)
                        {
                            freq = "m"; //2020m3
                        }
                        if (s3.IndexOf("k", StringComparison.OrdinalIgnoreCase) != -1)
                        {
                            freq = "q"; //2020k1
                        }
                        if (s3.IndexOf("q", StringComparison.OrdinalIgnoreCase) != -1)
                        {
                            freq = "q"; //2020q1
                        }
                        if (s3.IndexOf("u", StringComparison.OrdinalIgnoreCase) != -1)
                        {
                            freq = "w"; //2020w1
                        }
                        if (s3.IndexOf("w", StringComparison.OrdinalIgnoreCase) != -1)
                        {
                            freq = "w"; //2020w1
                        }
                        if (s3.IndexOf("m", StringComparison.OrdinalIgnoreCase) != -1 && s3.IndexOf("d", StringComparison.OrdinalIgnoreCase) != -1)
                        {
                            freq = "d";  //2020m3d15
                        }
                        dates.Add(s3);
                    }

                    if (dates.Count == 0)
                    {
                        new Error("No time dimension found in px file");
                    }

                    gt_start = GekkoTime.FromStringToGekkoTime(dates[0], true);
                    gt_end = GekkoTime.FromStringToGekkoTime(dates[dates.Count - 1], true);

                    if (gt_start.freq != gt_end.freq)
                    {
                        new Error("Frequency mismatch problem in px file");
                    }

                    obs = GekkoTime.Observations(gt_start, gt_end);

                    if (obs != dates.Count)
                    {
                        //========================================================================================================
                        //                          FREQUENCY LOCATION, indicates where to implement more frequencies
                        //========================================================================================================

                        //Guards against holes in the date sequence
                        //Note that gt_start and gt_end may be changed with datesRestrict below. Hmmm?

                        holes = new List<int>();
                        holes.Add(0); //to get started
                        holesForWarningMessage = new List<int>();  //will not get value for first observation

                        GekkoTime gt_before = GekkoTime.tNull;
                        string date_before = null;
                        //we have to read it the slow way (because of holes)

                        //consider there are n dates. For date[i], in the data array that contains raw data, it needs
                        //to be offset by holes[i] positions.

                        int sumOfAdjust = 0;
                        foreach (string date in dates)
                        {
                            GekkoTime gt = GekkoTime.FromStringToGekkoTime(date, true);
                            if (!gt_before.IsNull())
                            {
                                int gap = gt.Subtract(gt_before);  //1 if consequtive
                                if (gap < 1)
                                {
                                    new Error("It seems the date '" + date_before + "' is not before the following date: '" + date + "'");
                                }
                                sumOfAdjust += gap - 1;
                                holes.Add(sumOfAdjust);
                                holesForWarningMessage.Add(gap);
                            }
                            gt_before = gt;
                        }
                    }
                    codesIncludingTime.Add(new List<string>(ss));
                    timeDimensionIncodesIncludingTime = codesIncludingTime.Count - 1;
                }
                else if (state == 3)
                {
                    //state=3, handle the codes (names of dimensions)
                    //For instance:
                    //
                    //  CODES("ydelse, k?n og alder")="TOT","NET","LDP","LKT","AKI","ADP","AKT","MEN","KVR","U25","O25","O30","O40","O50","O60";
                    //  CODES("s?sonkorrigering og faktiske tal")="10";
                    //

                    if (hasSeenTimeDefinition)
                    {
                        pxAllowAnyTimeDimensionIndex = true;
                    }

                    string line777 = lineHelper.ToString();
                    int i = line777.IndexOf("=");
                    if (i < 0)
                    {
                        new Error("Expected a '=' in this line: " + line777);
                    }

                    string s3 = line777.Substring(0, i);
                    s3 = s3.Substring(7);
                    s3 = s3.Substring(0, s3.Length - 2);
                    codesHeader.Add(s3);

                    string s = line777.Substring(i + 1);

                    string[] ss = G.SplitCsv(s).ToArray();

                    List<string> names2 = new List<string>();
                    foreach (string s2 in ss)
                    {
                        string s4 = s2;
                        s4 = s4.Trim();
                        names2.Add(s4);
                    }
                    if (names2.Count == 0)
                    {
                        new Error("Expected 1 or more items in this line: " + line);
                    }
                    
                    codes.Add(names2);
                    codesIncludingTime.Add(names2);                    
                }
                else if (state == 4)
                {
                    //state=4, put the strings into the values array

                    string line5 = lineHelper.ToString();
                    int i = line5.IndexOf("=");
                    if (i < 0)
                    {
                        new Error("Expected a '=' in this line: " + line5);
                        //throw new GekkoException();
                    }
                    string s = line5.Substring(i + 1);
                    //if (s.EndsWith(";")) s = s.Substring(0, s.Length - 1);

                    string[] ss = ss = G.SplitCsv(s).ToArray();

                    List<string> values2 = new List<string>();
                    foreach (string s2 in ss)
                    {
                        string s5 = s2;

                        s5 = s5.Trim();

                        values2.Add(s5);
                    }
                    if (values2.Count == 0)
                    {
                        new Error("Expected 1 or more items in this line: " + line5);
                        //throw new GekkoException();
                    }
                    values.Add(values2);
                }
                else if (state == 5)
                {
                    //state=5, handle the variablecodes (aliases of names of dimensions)
                    //For instance:
                    //
                    //  VARIABLECODE("varegruppe")="VAREGR";
                    //                    

                    string line777 = lineHelper.ToString();
                    int i = line777.IndexOf("=");
                    if (i < 0)
                    {
                        new Error("Expected a '=' in this line: " + line777);
                    }

                    string s3 = line777.Substring(0, i);
                    s3 = s3.Substring(14); 
                    s3 = s3.Substring(0, s3.Length - 2);

                    string s = line777.Substring(i + 1);

                    string[] ss = G.SplitCsv(s).ToArray();

                    List<string> names2 = new List<string>();
                    foreach (string s2 in ss)
                    {
                        string s4 = s2;
                        s4 = s4.Trim();
                        names2.Add(s4);
                    }
                    if (names2.Count != 1)
                    {
                        new Error("Expected 1 item in this line: " + line);
                    }

                    variablecodes.Add(s3, names2[0]);                                        
                }

                if (semi) state = 0;  //resetting

            }  //for each line            

            G.Writeln("    All data read and prepared, now putting into series");

            if (expectedNumberOfDataInPxFile != foundNumberOfDataInPxFile)
            {
                string s5 = "";
                foreach (List<string> xx in codes)
                {
                    s5 = s5 + xx.Count + " * ";
                }
                s5 = s5 + dates.Count;  //number of dates will be shown last here
                numberOfDataPointsWarning = "Beware: expected " + s5 + " = " + expectedNumberOfDataInPxFile + " data points in px file, got " + foundNumberOfDataInPxFile;
            }

            // ==================== putting into timeseries =============================
            // ==================== putting into timeseries =============================
            // ==================== putting into timeseries =============================
            // ==================== putting into timeseries =============================
            // ==================== putting into timeseries =============================

            if (isArray)
            {
                // ------------------------------ array-series ---------------------------------------

                //See also #asf87aufkdh

                int dimensionsWithoutTime = codes.Count;

                //put in the array-timeseries container
                string varNameWithFreq = G.Chop_AddFreq(tableName, freq);
                Series tsArray = new Series(G.ConvertFreq(freq), varNameWithFreq);
                tsArray.SetArrayTimeseries(dimensionsWithoutTime + 1, true);
                databank.AddIVariableWithOverwrite(tsArray.name, tsArray);
                tsArray.SetDirty(true);

                for (int j = 0; j < codesCombi.Count; j++)
                {
                    Series ts = null;

                    ts = new Series(ESeriesType.Normal, G.ConvertFreq(freq), Globals.seriesArraySubName + Globals.freqIndicator + freq);

                    ts.meta.label = valuesCombi[j];
                    ts.meta.source = source;
                    ts.meta.stamp = Globals.dateStamp;
                    ts.SetDirty(true);

                    int offset = 0;

                    ts.SetDataSequence(gt_start, gt_end, data, j * totalDatesIncludingHoles + offset);  //the last is the offset
                    ts.Trim();  //to save ram                    
                    if (gt0.IsNull()) gt0 = gt_start;
                    if (gt1.IsNull()) gt1 = gt_end;
                    if (gt_start.StrictlySmallerThan(gt0)) gt0 = gt_start;
                    if (gt_end.StrictlyLargerThan(gt1)) gt1 = gt_end;

                    string[] split = codesCombi[j].Split(new char[] { Globals.pxInternalDelimiter }, StringSplitOptions.RemoveEmptyEntries);
                    string[] split2 = new string[(split.Length - 1) / 2];
                    for (int i = 0; i < split2.Length; i++)
                    {
                        split2[i] = split[2 * i + 2];
                    }

                    tsArray.dimensionsStorage.AddIVariableWithOverwrite(new MultidimItem(split2, tsArray), ts);
                }
            }

            else
            {

                // ------------------------------ normal series ---------------------------------------

                for (int j = 0; j < codesCombi.Count; j++)
                {

                    Series ts = null;

                    if (true)
                    {
                        string name2 = codesCombi[j].Replace(Globals.pxInternalDelimiter, '_');
                        string name3 = G.Chop_AddFreq(name2, freq);
                        ts = new Series(G.ConvertFreq(freq), name3);
                        ts.meta.label = valuesCombi[j];
                        ts.meta.source = source;
                        ts.meta.stamp = Globals.dateStamp;
                        ts.SetDirty(true);
                    }

                    if (true)
                    {
                        int offset = 0;

                        ts.SetDataSequence(gt_start, gt_end, data, j * totalDatesIncludingHoles + offset);  //the last is the offset
                        ts.Trim();  //to save ram
                        if (gt0.IsNull()) gt0 = gt_start;
                        if (gt1.IsNull()) gt1 = gt_end;
                        if (gt_start.StrictlySmallerThan(gt0)) gt0 = gt_start;
                        if (gt_end.StrictlyLargerThan(gt1)) gt1 = gt_end;
                    }

                    //put in the timeseries
                    string varNameWithFreq = G.Chop_AddFreq(tableName, freq);
                    databank.AddIVariableWithOverwrite(ts.name, ts);
                    ts.SetDirty(true);
                }
            }

            string downloadOrImport = "Read";
            if (isDownload) downloadOrImport = "Downloaded";

            G.Writeln("--> " + downloadOrImport + " " + codesCombi.Count + " timeseries in total, frequency " + freq + ", " + G.FromDateToString(gt0) + "-" + G.FromDateToString(gt1));

            if (isArray)
            {
                G.Writeln("    First timeseries in px file: " + G.PrettifyTimeseriesHash(GetArrayName(tableName, codesCombi[0]), true, false));
                G.Writeln("    Last timeseries in px file: " + G.PrettifyTimeseriesHash(GetArrayName(tableName, codesCombi[codesCombi.Count - 1]), true, false));
            }
            else
            {
                G.Writeln("    First timeseries in px file: " + codesCombi[0].Replace(Globals.pxInternalDelimiter, '_'));
                G.Writeln("    Last timeseries in px file: " + codesCombi[codesCombi.Count - 1].Replace(Globals.pxInternalDelimiter, '_'));
            }

            //return values
            vars = codesCombi.Count;
            perStart = gt0;
            perEnd = gt1;

            if (pxAllowAnyTimeDimensionIndex)
            {
                using (Warning txt = new Warning())
                {
                    txt.MainAdd("The time dimension is not defined last in the .px file, and therefore an experimental module is used.");
                    txt.MoreAdd("The time dimension is not defined last in the .px file, since either CODES(\"tid\") or CODES(\"time\") does not seem to be the last CODES(...) element.");
                    txt.MoreAdd("When the time dimension is not defined last, an experimental Gekko module for px file reading is used (written in November 2021).");
                    txt.MoreAdd("In contrast to the original px file module, which has been running for a number of years, the new experimental module has not been tested a lot yet. So please check the results carefully!");
                    txt.MoreAdd("If you are uncertain about using the above-mentioned experimental px file module, and if the px file originates from a {a{DOWNLOAD¤download.htm}a} command, you may reorder the .json file:");
                    txt.MoreAdd("In your .json file, move the \"code\": \"tid\" or \"code\": \"time\" element last in the file. After this, the warning should go away.");
                    txt.MoreNewLine();
                    txt.MoreAdd("Note: If the new experimental px file module really turns out to contain bugs, these will probably be immediately visible,");
                    txt.MoreAdd("because the timeseries will look fundamentally scrambled. Expect the new px file module to be tested enough to eliminate this warning around spring 2022.");
                }
            }

            if (hyphenFound)
            {
                //Only for !isArray
                new Warning("Hyphens ('-') in names have been removed");
            }

            if (underscoreFound)
            {
                //Only for !isArray
                new Warning("Underscores ('_') in names have been removed");
            }

            if (holes != null)
            {
                using (Warning txt = new Warning())
                {
                    txt.MainAdd("There are gaps in the data: for some of the observations, there is a gap > 1 between the date of the observation and the previous date that contains data");

                    if (holesForWarningMessage != null)
                    {
                        txt.MoreAdd("The following dates have gap > 1 between the date and the previous date that contains data:");
                        txt.MoreNewLine();

                        GekkoTime gt = gt_start;
                        for (int i = 0; i < holesForWarningMessage.Count; i++)
                        {
                            //holesForWarningMessage[0] is the SECOND date in the dates.
                            gt = gt.Add(holesForWarningMessage[i]);  //in the first iteration (i = 0), gt will be the SECOND date of the data
                            if (holesForWarningMessage[i] > 1)
                            {
                                txt.MoreAdd(gt.ToString() + " = " + holesForWarningMessage[i]);
                                txt.MoreNewLineTight();
                            }
                        }
                    }
                }
            }
            if (variablecodeNote != null) new Note(variablecodeNote);
        }

        /// <summary>
        /// Helper method for ReadPx() method.
        /// </summary>
        /// <param name="tableName"></param>
        /// <param name="codesCombi"></param>
        /// <returns></returns>
        private static string GetArrayName(string tableName, string codesCombi)
        {
            string name3 = null;
            string name2 = codesCombi;
            string[] ss = name2.Split(Globals.pxInternalDelimiter);
            List<string> dims = new List<string>();
            for (int i = 2; i < ss.Length; i += 2)
            {
                //kind of hacky, make it more robust later on
                dims.Add(ss[i]);
            }
            foreach (string s in dims)
            {
                name3 += Globals.symbolTurtle + s;
            }
            name3 = tableName + name3;
            return name3;
        }

        /// <summary>
        /// Helper method for ReadPx() method. The elements of each dimension are combined, in order to construct array-series names.
        /// The method is recursive.
        /// </summary>
        /// <param name="isArray"></param>
        /// <param name="table"></param>
        /// <param name="codesHeader"></param>
        /// <param name="codes"></param>
        /// <param name="codesCombi"></param>
        /// <param name="values"></param>
        /// <param name="valuesCombi"></param>
        /// <param name="depth"></param>
        /// <param name="sCodes"></param>
        /// <param name="sValues"></param>
        /// <param name="hyphenFound"></param>
        /// <param name="underscoreFound"></param>
        private static void WalkPxCombinations(bool pxAllowAnyTimeDimensionIndex, bool isArray, string table, List<string> codesHeader, List<List<string>> codes, List<string> codesCombi, List<List<string>> values, List<string> valuesCombi, int depth, string sCodes, string sValues, int timeDimension, ref bool hyphenFound, ref bool underscoreFound)
        {
            //Hmmm what if a table name or column has a name with '_' inside? Probably not probable.
            if (depth > codes.Count - 1)
            {
                if (sCodes.EndsWith(Globals.pxInternalDelimiter.ToString())) sCodes = sCodes.Substring(0, sCodes.Length - 1);
                if (sValues.StartsWith(", ")) sValues = sValues.Substring(2);

                string name2 = null;

                string temp = table + sCodes;
                StringBuilder sb = new StringBuilder();
                for (int i = 0; i < temp.Length; i++)
                {
                    char tempi = temp[i];
                    if (!isArray) //accept funny strings for arrays
                    {
                        if (tempi == '-')
                        {
                            hyphenFound = true;
                        }
                        else if (tempi == '_')
                        {
                            underscoreFound = true;
                        }
                    }

                    if (tempi == 'æ') sb.Append("ae");
                    else if (tempi == 'ø') sb.Append("oe");
                    else if (tempi == 'å') sb.Append("aa");
                    else if (tempi == 'Æ') sb.Append("AE");
                    else if (tempi == 'Ø') sb.Append("OE");
                    else if (tempi == 'Å') sb.Append("AA");
                    else if (!isArray && !(G.IsLetterOrDigit(tempi) || tempi == Globals.pxInternalDelimiter))  //for non-arrays, only letter or digit is allowed, everything else is thrown out
                    {
                        //ignore it
                    }
                    else
                    {
                        sb.Append(tempi);  //here we know that it is englishletter or digit or underscore
                    }
                }
                name2 = sb.ToString();

                codesCombi.Add(name2);
                valuesCombi.Add(sValues);
                return;
            }

            if (pxAllowAnyTimeDimensionIndex && (G.Equal(codesHeader[depth], "tid") || G.Equal(codesHeader[depth], "time")))
            {
                WalkPxCombinations(pxAllowAnyTimeDimensionIndex, isArray, table, codesHeader, codes, codesCombi, values, valuesCombi, depth + 1, sCodes, sValues, timeDimension, ref hyphenFound, ref underscoreFound);
            }
            else
            {
                for (int i = 0; i < codes[depth].Count; i++)
                {
                    string sCodesTemp = sCodes + Globals.pxInternalDelimiter + codesHeader[depth] + Globals.pxInternalDelimiter + codes[depth][i];
                    string sValuesTemp = sValues + ", " + values[depth][i];
                    WalkPxCombinations(pxAllowAnyTimeDimensionIndex, isArray, table, codesHeader, codes, codesCombi, values, valuesCombi, depth + 1, sCodesTemp, sValuesTemp, timeDimension, ref hyphenFound, ref underscoreFound);
                }
            }
        }

        /// <summary>
        /// Overload.
        /// </summary>
        /// <param name="d"></param>
        /// <param name="format2"></param>
        /// <returns></returns>
        public static string NumberFormat(double d, string format2)
        {
            return NumberFormat(d, format2, null);
        }

        /// <summary>
        /// Format a double into a particular number format. Used in the Gekko format() function.
        /// </summary>
        /// <param name="d"></param>
        /// <param name="format2"></param>
        /// <param name="culture"></param>
        /// <returns></returns>
        public static string NumberFormat(double d, string format2, string culture)
        {
            string format = null;
            if (format2.Contains(":"))
            {
                format = "{0," + format2 + "}";  //0, is just that it is the first element in a list of numbers
            }
            else
            {
                format = "{0,0:" + format2 + "}";  //0,0: first element, with 0 blanks padding
            }
            string x = null;
            try
            {
                if (culture == null) x = String.Format(format, d);
                else
                {
                    CultureInfo ci = CultureInfo.CreateSpecificCulture(culture);  //for instance "da-DK", "en-US", "fr-FR", etc.
                    x = String.Format(ci, format, d);
                }
            }
            catch (Exception e)
            {
                new Error("format() function failed. The internal error message is this: " + e.Message);
            }
            return x;
        }

        /// <summary>
        /// /// Format a string into a particular string format. Used in the Gekko format() function.
        /// </summary>
        /// <param name="s"></param>
        /// <param name="format2"></param>
        /// <returns></returns>
        public static string StringFormat(string s, string format2)
        {
            string format = null;
            format = "{0," + format2 + "}";  //0, is just that it is the first element in a list of numbers
            string x = null;
            try
            {
                x = String.Format(format, s);
            }
            catch (Exception e)
            {
                new Error("format() function failed. The internal error message is this:" + e.Message);
            }
            return x;
        }

        /// <summary>
        /// Fixes glitch regarding .tsd and PCIM data file formats.
        /// </summary>
        /// <param name="varName"></param>
        /// <returns></returns>
        public static bool IsNonsenseVariableName(string varName)
        {
            bool nonsense = false;
            if (varName == "" || varName == "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0")
            {
                nonsense = true;
            }
            return nonsense;
        }

        /// <summary>
        /// Used in WriteTsd() to write the .tsd data file format.
        /// </summary>
        /// <param name="per1"></param>
        /// <param name="per2"></param>
        /// <param name="res"></param>
        /// <param name="ts"></param>
        /// <param name="name"></param>
        /// <param name="isCaps"></param>
        /// <param name="isTsdx"></param>
        private static void WriteTsdRecord(GekkoTime per1_input, GekkoTime per2_input, StreamWriter res, Series ts, string name, bool isCaps, bool isTsdx)
        {
            int index1 = -12345;
            int index2 = -12345;
            //TODO: can return null
            //TODO: and it might be called half overlapped like this:
            //            +++++++++++++++++++++++
            //      ---------------
            double[] dataArray = null;

            GekkoTime per1 = GekkoTime.tNull;
            GekkoTime per2 = GekkoTime.tNull;

            if (per1_input.IsNull() && per2_input.IsNull())
            {
                //TODO: Maybe better do this with ts.GetRealDataPeriodFirst() etc.?
                //could use stuff from the "else" below.
                //problem is if we mess up....
                index1 = ts.meta.firstPeriodPositionInArray;
                index2 = ts.meta.lastPeriodPositionInArray;
                dataArray = ts.GetDataSequenceUnsafePointerReadOnlyBEWARE();
                per1 = ts.GetPeriodFirst();
                per2 = ts.GetPeriodLast();
            }
            else
            {
                GekkoTime.ConvertFreqs(ts.freq, per1_input, per2_input, ref per1, ref per2);
                //also sets index1 and index2.
                dataArray = ts.GetDataSequenceBEWARE(out index1, out index2, per1, per2);  //a little bit slack not to use a pointer
            }

            //From here on, per1 and per2 have same freq as ts

            int count2 = 0;
            string s = "";
            double oldValue = double.NaN;
            bool firstTime = true;
            string varName = ts.name;
            if (isCaps) varName = varName.ToUpper();  //for use with AREMOS

            //========================================================================================================
            //                          FREQUENCY LOCATION, indicates where to implement more frequencies
            //========================================================================================================

            string super1 = per1.super.ToString();
            string super2 = per2.super.ToString();
            string sub1 = "";
            string sub2 = "";
            string freq = "A";
            if (ts.freq == EFreq.A)
            {
                sub1 = "0101";
                sub2 = "0101";
            }
            else if (ts.freq == EFreq.Q || ts.freq == EFreq.M)
            {
                //W will get weekday pattern added
                freq = G.ConvertFreq(ts.freq).ToUpper();
                sub1 = per1.sub.ToString("D2") + "01";
                sub2 = per2.sub.ToString("D2") + "01";
            }
            else if (ts.freq == EFreq.W)
            {
                //For weekly, tsd converts into YYYMMDD with a weekday pattern of only 1 day.
                freq = G.ConvertFreq(ts.freq).ToUpper();
                DateTime dt1 = ISOWeek.ToDateTime(per1, Globals.weeklyWeekDayDefaultTsd);
                DateTime dt2 = ISOWeek.ToDateTime(per2, Globals.weeklyWeekDayDefaultTsd);
                sub1 = dt1.Month.ToString("D2") + dt1.Day.ToString("D2");
                sub2 = dt2.Month.ToString("D2") + dt2.Day.ToString("D2");
                super1 = dt1.Year.ToString();
                super2 = dt2.Year.ToString();
            }
            else if (ts.freq == EFreq.D)
            {
                freq = G.ConvertFreq(ts.freq).ToUpper();
                sub1 = per1.sub.ToString("D2") + per1.subsub.ToString("D2");
                sub2 = per2.sub.ToString("D2") + per2.subsub.ToString("D2");
            }
            else throw new GekkoException();

            string varName2 = G.Chop_RemoveFreq(varName);
            if (varName.Length <= 16 && ts.meta.label != null && ts.meta.label.Length > 0)
            {
                res.WriteLine(varName2 + G.Blanks(16 - varName2.Length) + ts.meta.label);
            }
            else
            {
                //do not write label if name > 16 chars
                res.WriteLine(varName2);
            }

            string stmp = "01/01/00";
            if (ts.meta.stamp != null && ts.meta.stamp.Length == 10)
            {
                try
                {
                    int i = int.Parse(ts.meta.stamp.Substring(6, 4));
                    if (i >= 2000) i = i - 2000;
                    else i = i - 1900;
                    string temp = ts.meta.stamp.Substring(3, 2) + "/" + ts.meta.stamp.Substring(0, 2) + "/" + i;
                    if (temp.Length == 8) stmp = temp;
                }
                catch
                {
                }
            }

            string src = ts.meta.source;
            if (src == null) src = "";
            if (src.Length > 16) src = src.Substring(0, 16);
            else src = src + G.Blanks(16 - src.Length);

            string nul = "  0";
            if (ts.freq == EFreq.W)
            {
                //necessary for AREMOS
                string days = null;
                if (Globals.weeklyWeekDayDefaultTsd == DayOfWeek.Sunday) days += "1"; else days += "0";
                if (Globals.weeklyWeekDayDefaultTsd == DayOfWeek.Monday) days += "1"; else days += "0";
                if (Globals.weeklyWeekDayDefaultTsd == DayOfWeek.Tuesday) days += "1"; else days += "0";
                if (Globals.weeklyWeekDayDefaultTsd == DayOfWeek.Wednesday) days += "1"; else days += "0";
                if (Globals.weeklyWeekDayDefaultTsd == DayOfWeek.Thursday) days += "1"; else days += "0";
                if (Globals.weeklyWeekDayDefaultTsd == DayOfWeek.Friday) days += "1"; else days += "0";
                if (Globals.weeklyWeekDayDefaultTsd == DayOfWeek.Saturday) days += "1"; else days += "0";
                nul = "  0         " + days + "";  //weekdays sun, mon, tue, wed, thu, fri, sat
            }
            else if (ts.freq == EFreq.D)
            {
                //necessary for AREMOS, otherwise the program crashes completely!
                nul = "  0         1111111";  //weekdays sun, mon, tue, wed, thu, fri, sat --> are active
            }

            res.WriteLine("                " + src + stmp + "0000" + super1 + sub1 + super2 + sub2 + freq + nul); //time is set to 0000

            for (int index = index1; index <= index2; index++)
            {
                count2++;
                double value = double.NaN;
                {
                    value = dataArray[index];
                }

                if (double.IsNaN(value))
                {
                    value = 1.0e+15;
                }

                if (Math.Abs(value) <= 1.0e-99d)
                {
                    //otherwise we will get exponents with 3 characters,
                    //and PCIM does not like that
                    value = 0;
                }
                if (Math.Abs(value) >= 1.0e+99d)
                {
                    //otherwise we will get exponents with 3 characters,
                    //and PCIM does not like that
                    //Too large a number
                    //Missing does not have a sign
                    value = 1.0e+15d;
                }

                if (firstTime || (!firstTime && value != oldValue)) //This trick makes it run about 25% faster
                {
                    if (isTsdx)
                    {
                        s = string.Format(System.Globalization.CultureInfo.InvariantCulture, "{0:0.00000000000000E+00}", value);
                    }
                    else
                    {
                        s = string.Format(System.Globalization.CultureInfo.InvariantCulture, "{0:0.00000000E+00}", value);
                    }
                }

                firstTime = false;
                oldValue = value;

                if (value < 0)
                {
                    res.Write(s);
                }
                else
                {
                    res.Write(" " + s);
                }
                if (count2 % 5 == 0 && index != index2) res.WriteLine();  //new line for each 5 numbers written
            }
            res.WriteLine();
        }

        /// <summary>
        /// Write the Gekko-specific "flat" data file format.
        /// </summary>
        /// <param name="per1_input"></param>
        /// <param name="per2_input"></param>
        /// <param name="res"></param>
        /// <param name="ts"></param>
        /// <param name="name"></param>
        /// <param name="sb"></param>
        private static void WriteFlatRecord(GekkoTime per1_input, GekkoTime per2_input, StreamWriter res, Series ts, string name, StringBuilder sb)
        {
            GekkoTime per1 = GekkoTime.tNull; GekkoTime per2 = GekkoTime.tNull;
            if (per1_input.IsNull() && per2_input.IsNull())
            {
                per1 = ts.GetRealDataPeriodFirst();
                per2 = ts.GetRealDataPeriodLast();
            }
            else GekkoTime.ConvertFreqs(ts.freq, per1_input, per2_input, ref per1, ref per2);

            sb.Clear();
            sb.Append(name).Append(" ").Append(per1.ToString()).Append(" ").Append(per2.ToString()).Append(" ");
            foreach (GekkoTime t in new GekkoTimeIterator(per1, per2))
            {
                double d = ts.GetDataSimple(t);
                string s = d.ToString();
                if (G.isNumericalError(d)) s = "m";
                sb.Append(s).Append(" ");
            }
            res.WriteLine(sb);
        }

        /// <summary>
        /// Helper for writing a TSP data file.
        /// </summary>
        /// <param name="per1"></param>
        /// <param name="per2"></param>
        /// <param name="res"></param>
        /// <param name="ts"></param>
        /// <param name="name"></param>
        /// <param name="isCaps"></param>
        private static void WriteTspRecord(GekkoTime per1, GekkoTime per2, StreamWriter res, Series ts, string name, bool isCaps)
        {
            int index1 = -12345;
            int index2 = -12345;
            //TODO: can return null
            //TODO: and it might be called half overlapped like this:
            //            +++++++++++++++++++++++
            //      ---------------
            double[] dataArray = null;
            if (per1.IsNull() && per2.IsNull())
            {
                index1 = ts.meta.firstPeriodPositionInArray;
                index2 = ts.meta.lastPeriodPositionInArray;
                dataArray = ts.GetDataSequenceUnsafePointerReadOnlyBEWARE();
                per1 = ts.GetPeriodFirst();
                per2 = ts.GetPeriodLast();
            }
            else
            {
                //also sets index1 and index2.
                dataArray = ts.GetDataSequenceBEWARE(out index1, out index2, per1, per2);  //a little bit slack not to use a pointer
            }

            int count2 = 0;
            string s = "";
            string varName = G.Chop_GetName(name); // ts.name;
            if (isCaps) varName = varName.ToUpper();

            if (ts.freq == EFreq.A)
            {
                new Error("WRITE <tsp> only implemented for annual data");
                //throw new GekkoException();
            }

            res.WriteLine("smpl " + per1.super + " " + per2.super + ";");
            res.WriteLine("load " + varName + ";");

            for (int index = index1; index <= index2; index++)
            {
                count2++;
                double value = double.NaN;
                {
                    value = dataArray[index];
                }
                if (double.IsNaN(value))
                {
                    res.WriteLine(".");
                }
                else
                {
                    res.WriteLine(value);
                }
            }
            res.WriteLine(";");
            res.WriteLine();
        }

        /// <summary>
        /// Helper for writing a TSP data file.
        /// </summary>
        /// <param name="yr1"></param>
        /// <param name="yr2"></param>
        /// <param name="res"></param>
        /// <param name="varNumber"></param>
        /// <param name="data"></param>
        /// <param name="var2"></param>
        public static void WriteTsdRecord2(int yr1, int yr2, StreamWriter res, int varNumber, double[] data, String var2)
        {
            //TODO: quarters
            if (Program.options.freq != EFreq.A)
            {
                new Error("Tsp to tsd conversion only works on annual data");
                //throw new GekkoException();
            }
            res.WriteLine(var2);
            //res.WriteLine("                                 1/ 1/ 10800" + (yr1 + 0) + "0100" + (yr2 + 0) + "0100A  0");
            res.WriteLine("                                11/22/ 72014" + (yr1 + 0) + "0101" + (yr2 + 0) + "0101A2 0         0000000");

            int count2 = 0;
            for (int t = yr1; t <= yr2; t++)
            {
                count2++;
                double value = double.NaN;
                if (varNumber == -12345 && data != null)
                {
                    value = data[t];
                }
                else
                {
                    new Error("Internal error 9329329", false);
                    //value = a[varNumber, t];
                }

                if (double.IsNaN(value))
                {
                    value = 1.0e+15;
                }

                if (Math.Abs(value) <= 1.0e-99d)
                {
                    //otherwise we will get exponents with 3 characters,
                    //and PCIM does not like that
                    value = 0;
                }
                if (Math.Abs(value) >= 1.0e+99d)
                {
                    //otherwise we will get exponents with 3 characters,
                    //and PCIM does not like that
                    //Too large a number
                    //Missing does not have a sign
                    value = 1.0e+15d;
                }

                String valueExp = string.Format(System.Globalization.CultureInfo.InvariantCulture, "{0:0.000000E+00}", value);

                if (value < 0)
                {
                    res.Write("  " + valueExp);
                }
                else
                {
                    res.Write("   " + valueExp);
                }
                if (count2 % 5 == 0) res.WriteLine();  //new line for each 5 numbers written
            }
            if (count2 % 5 != 0) res.WriteLine();

        }

        /// <summary>
        /// In a Gekko model, finds the equation (EquationHelper) that corresponds to a LHS variable name.
        /// </summary>
        /// <param name="lhsName"></param>
        /// <returns></returns>
        public static EquationHelper FindEquationByMeansOfVariableName(string lhsName)
        {

            int r = -12345;
            if (Program.model?.modelGekko?.fromVariableToEquationNumber != null && Program.model.modelGekko.fromVariableToEquationNumber.TryGetValue(lhsName + Globals.lagIndicator + "0", out r))
            {
                //r will get a value
            }
            else
            {
                return null;
            }

            int number = r;
            EquationHelper found = Program.model.modelGekko.equations[number];  //should alway find something
            return found;
        }

        /// <summary>
        /// Helper for printing out ordering information on a Gekko model.
        /// </summary>
        /// <param name="al"></param>
        /// <param name="res"></param>
        public static void PrintEquationLeftHandSideNames(List<int> al, StreamWriter res)
        {
            foreach (int i in al)
            {
                int tmp = Program.model.modelGekko.m2.fromEqNumberToBNumber[i];
                string var = Program.model.modelGekko.varsBTypeInverted[tmp];
                TwoStrings ts = GetVariableAndLag(var);
                string var2 = G.GetUpperLowerCase(ts.s1);
                res.WriteLine("  " + var2);
            }
        }

        /// <summary>
        /// For dynamic C# code, it is detected whether Gekko is 32- or 64-bit, and appropriate compiler settings
        /// are set.
        /// </summary>
        /// <returns></returns>
        public static string GetCompilerOptions()
        {
            if (Environment.Is64BitProcess) return Globals.compilerOptions64;
            else return Globals.compilerOptions32;
        }

        /// <summary>
        /// This is the main entry into running Gekko commands, called for instance from the Gekko GUI window.
        /// These commands are parsed, compiled and executed. BEWARE: Do not change name or signature without changing in 
        /// Gekcel solution, too!!
        /// </summary>
        /// <param name="text">Set this "" not null if missing</param>
        /// <param name="fileName">Set this "" not null if missing</param>
        /// <param name="skip">Only for internal use</param>
        /// <param name="p"></param>
        /// 
        public static void RunGekkoCommands(string text, string fileName, int skip, P p)
        {
            //#98073245298345
            //Here, we are translating (1) a gui oneliner, (2) a gui command block, or a gcm file (that might be .ini or called with LIBRARY).

            Globals.suggestions.Clear();  //to not fill out ram too much

            if (Globals.excelDna || Globals.hideGui)
            {
                if (!Globals.nolog)
                {
                    //if the below object is null, nothing is printed/written to it afterwards
                    //.nolog will be false for Gekcel, but may be true for gekko.exe call.
                    Globals.excelDnaOutput = new StringBuilder();  //clears, and records everything from now on for use in Excel window            
                }
            }

            int max = 1;
            if (G.Equal(Program.options.interface_debug, "dialog")) max = int.MaxValue;  //should suffice as tries :-)

            for (int i = 0; i < max; i++)  //number of tries to run a cmd file that has parser/lexer errors
            {
                string islooping = "parser";
                if (i > 0) islooping = "parser_islooping";

                Parser.ConvertHelper ch = null;

                Parser.ParseHelper ph = new Parser.ParseHelper();
                ph.commandsText = text;
                ph.fileName = fileName;
                ph.isModel = false;

                string commandLinesFlat = null;
                //It is either txt or fileName, depending of how method is called

                if (Globals.runningOnTTComputer && Globals.showTimings) G.Writeln("Handle start: " + G.SecondsFormat((DateTime.Now - p.startingTime).TotalMilliseconds), Color.LightBlue);

                if (fileName != "")
                {
                    //a file
                    if (!fileName.Contains("tablecode." + Globals.defaultCommandFileExtension))  //don't count an autogenerated table as a cmd file
                    {
                        p.hasBeenCmdFile = true;
                    }
                    string input = GetTextFromFileWithWait(fileName);
                    commandLinesFlat = HandleGekkoCommands(input);
                    if (skip != 0)
                    {
                        List<string> ss = Stringlist.CreateListOfStringsFromFile(commandLinesFlat);
                        commandLinesFlat = "";
                        for (int ii = 0; ii < skip; ii++)
                        {
                            if (ii == ss.Count)
                            {
                                G.Writeln2("Skip is set after file end");
                                break;
                            }
                            commandLinesFlat += ss[ii] + G.NL;
                        }
                    }
                    ph.isOneLinerFromGui = false;
                }
                else if (text != "")
                {
                    //oneliner from GUI
                    if (text.Contains("\n"))
                    {
                        commandLinesFlat = HandleGekkoCommands(text);  //is handled exactly as if it was a file
                        ph.isOneLinerFromGui = false;  //is a more-liner........
                    }
                    else
                    {
                        string text0 = HandleGekkoCommandsSpecialCheatCommandsOnDeveloperComputer(text);
                        commandLinesFlat = HandleGekkoCommands(text0);
                        ph.isOneLinerFromGui = true;
                        p.isOneLinerFromGui = true;
                    }
                }

                ph.commandsText = commandLinesFlat;
                p.SetCommandFileText(commandLinesFlat);
                p.SetCurrentLibrary(null);  //a call to a gcm file always counts a current library == null

                try
                {
                    if (Globals.runningOnTTComputer && Globals.showTimings) G.Writeln("Parse start: " + G.SecondsFormat((DateTime.Now - p.startingTime).TotalMilliseconds), Color.LightBlue);
                    p.lastFileSentToANTLR = fileName;
                    p.SetLastFileSentToANTLR(fileName);
                    ch = Gekko.Parser.Gek.ParserGekCreateAST.ParseAndCallWalkAndEmit(ph, p);
                    if (Globals.runningOnTTComputer && Globals.showTimings) G.Writeln("Parse end: " + G.SecondsFormat((DateTime.Now - p.startingTime).TotalMilliseconds), Color.LightBlue);
                }
                catch (Exception e)
                {
                    Program.PrintExceptionWraps(e);

                    if (G.Equal(Program.options.interface_debug, "dialog"))
                    {
                        string eh = Program.ErrorHandling(islooping, p, false);

                        if (eh == "stop")
                        {
                            //throw new GekkoException(); //this will make a double error -- but the other one will be identified later on (both text and filename are null) and skipped -- a little bit hacky, but oh well...
                            throw;
                        }
                        else if (eh == "retry")
                        {
                            continue;  //try again
                        }
                        else
                        {
                            new Error("Strange error in gcm file -- please report this to the developer");
                            //throw new GekkoException();
                            //throw;
                        }
                    }
                    else
                    {
                        string eh = Program.ErrorHandling(islooping, p, true);
                        throw new GekkoException(); //this will make a double error -- but the other one will be identified later on (both text and filename are null) and skipped -- a little bit hacky, but oh well...
                    }
                }

                ch.commandsText = commandLinesFlat;
                if (fileName == "")
                {
                    //either a one-liner, else a marked block, issued with [Enter].
                    Globals.commandMemory.storage.AppendLine(text); //is syntax-ok, but may still run-time fail                   
                }

                try
                {
                    bool onlyParse = false;

                    if (onlyParse && Globals.runningOnTTComputer)
                    {
                        if (commandLinesFlat.ToLower().StartsWith("run ") && Regex.Matches(commandLinesFlat, ";").Count == 1)
                        {
                            //else we cannot even do a RUN xx.gcm, because the file does not get called.
                            Gekko.Parser.Gek.ParserGekCompileAndRunAST.CompileAndRunAST(ch, p);
                        }
                        else
                        {
                            //skip running
                        }
                    }
                    else
                    {
                        Gekko.Parser.Gek.ParserGekCompileAndRunAST.CompileAndRunAST(ch, p);
                    }
                }
                catch (Exception e)
                {
                    throw;
                }
                finally
                {
                    if (!Globals.isAutoExec) RecordRestorInfo();  //not done at the very startup
                }

                break;  //if we get to here, everything is ok so break the file-trying loop
            }
        }

        private static void RecordRestorInfo()
        {
            //after the command is done -- even if an error occurs
            //by recording these files after the command, * in "read *" or "model *" will have been
            //replaced with real filenames.


            try
            {
                string fileSnapshot = System.Windows.Forms.Application.LocalUserAppDataPath + "\\GekkoSnapshot.gcm";
                StreamWriter sw2 = new StreamWriter(fileSnapshot);
                string s2 = CrossThreadStuff.GetInputWindowText();
                sw2.Write(s2);
                sw2.Flush();
                sw2.Close();
            }
            catch (Exception e)
            {
                //do nothing
            }

            try
            {
                string fileHistory = System.Windows.Forms.Application.LocalUserAppDataPath + "\\GekkoHistory.gcm";
                StreamWriter sw1 = new StreamWriter(fileHistory);
                string s1 = Globals.commandMemory.storage.ToString();
                sw1.Write(s1);
                sw1.Flush();
                sw1.Close();
            }
            catch (Exception e)
            {
                //do nothing
            }

        }

        /// <summary>
        /// Precedents means which variables (often timeseries) are part of a given expression. This can be "recorded" when issuing
        /// a given expression or statement, for instance the GetIVariable() method can report back that a certain variable has been
        /// used in the expression. Such variables are then stored in Globals.precedents (a Dictionary with string keys).
        /// </summary>
        /// <param name="variableName"></param>
        /// <param name="iv"></param>
        /// <param name="db"></param>
        public static void PrecedentsHelper(string variableName, IVariable iv, Databank db)
        {
            if (Globals.precedents == null) return;
            if (iv == null) return;
            Series rv_series = iv as Series;
            if (rv_series != null)
            {
                Program.AddToPrecedents(db, rv_series.GetName());
            }
        }

        /// <summary>
        /// Deals with tracing info (metadata)
        /// </summary>
        /// <param name="name"></param>
        /// <param name="ib"></param>
        /// <param name="iv"></param>
        public static void Trace(string name, IBank ib, IVariable iv, bool isLhs)
        {
            if (!Globals.useTrace) return;
            //if (!Globals.useTrace || Globals.trace2 == null) return;
            bool onlyTraceSeries = false;
            if (iv == null) return;
            Series rv_series = iv as Series;
            string x_lhs = "";
            if (isLhs) x_lhs = "LHS";
            string x_objectName = null;
            if (rv_series != null) x_objectName = rv_series.GetName();
            string x_bankOrMap = null;
            
            if (ib.BankType() == EBankType.Map)
            {
                x_bankOrMap = "map";
            }
            else
            {
                x_bankOrMap = ib.GetFileNameWithPath() + " " + ib.GetStamp();
            }

            if (!onlyTraceSeries || rv_series != null)
            {
                string x_source = null;
                if (rv_series != null && rv_series.meta != null) x_source = rv_series.meta.source;
                string s = "name: " + name + " // " + "bank: " + x_bankOrMap + " // " + "oname: " + x_objectName + " // " + "source: " + x_source + " // " + "lhs?: " + x_lhs;
                if (isLhs)
                {
                    if (rv_series.meta.calc == null) rv_series.meta.calc = new List<string>();
                    rv_series.meta.calc.Add(s);
                    foreach (IVariable iv2 in Globals.trace2)
                    {
                        if (iv2 == iv) continue;
                        if (iv2.Type() != EVariableType.Series) continue;
                        Series iv2_series = iv2 as Series;
                        if (iv2_series.meta == null) continue;
                        foreach (string s4 in iv2_series.meta.calc)
                        {
                            rv_series.meta.calc.Add("--" + s4);
                        }
                    }
                }

                if (!Globals.trace.ContainsKey(s)) Globals.trace.Add(s, new Trace());
                if (!Globals.trace2.Contains(iv)) Globals.trace2.Add(iv);

                //if (Globals.useTrace)
                //{
                //    if (rv_series != null && isLhs)
                //    {
                //        if (Globals.trace.Count > 0 && rv_series.meta.calc == null) rv_series.meta.calc = new List<string>();                        
                //        foreach (string ss in Globals.trace.Keys)
                //        {                            
                //            //rv_series.meta.calc.Add(ss);
                //        }
                //    }
                //}
            }
        }

        /// <summary>
        /// Used for playing a sound after long-running jobs.
        /// </summary>
        /// <param name="p"></param>
        public static void MaybePlaySound(P p)
        {
            if (Program.options.interface_sound == false) return;
            if (p.hasBeenCmdFile == false) return;
            //if (p.hasBeenIsstartCmdFile == true) return;
            int sec = Program.options.interface_sound_wait;
            if ((DateTime.Now - p.timeAtLastUserInteraction).TotalMilliseconds / 1000d > (double)sec)
            {
                PlaySound();
                p.timeAtLastUserInteraction = DateTime.Now;
            }
        }

        /// <summary>
        /// Used for playing a sound after long-running jobs.
        /// </summary>
        public static void PlaySound()
        {
            System.Media.SoundPlayer simpleSound = new System.Media.SoundPlayer(Application.StartupPath + "\\images\\" + Program.options.interface_sound_type + ".wav");
            simpleSound.Play();
        }

        /// <summary>
        /// Update the GUI status field with current time period, working folder, etc.
        /// </summary>
        /// <param name="s"></param>
        public static void ShowPeriodInStatusField(string s)
        {
            if (G.IsUnitTesting()) return;

            string s1 = "";
            //TODO: make a smart trim procedure
            if (s.Length > 90)
            {
                s1 = s.Remove(88);
                s1 += "...";
            }
            else
            {
                s1 = s;
            }

            string start = "";
            string end = "";

            start = G.FromDateToString(Globals.globalPeriodStart);
            end = G.FromDateToString(Globals.globalPeriodEnd);
            string f = Program.options.freq.Pretty();

            string workingFolder = "";
            string banks = "";
            if (s1.Equals(""))
            {
                int wCount = Program.databanks.GetFirst().storage.Count;
                int rCount = Program.databanks.GetRef().storage.Count;
                string originalDataFileWork = "[empty]";
                string originalDataFileBaseline = "[empty]";
                string w = GetDatabankFileNameWithPath(Program.databanks.GetFirst());
                string b = GetDatabankFileNameWithPath(Program.databanks.GetRef());
                if (w != null) originalDataFileWork = w;
                if (b != null) originalDataFileBaseline = b;
                string banks1 = "";
                string banks2 = "";

                if (originalDataFileWork != "") banks1 = originalDataFileWork;
                try
                {
                    banks1 = Path.GetFileName(banks1);
                }
                catch { }
                if (banks1.EndsWith(".tsd", StringComparison.OrdinalIgnoreCase)) banks1 = banks1.Substring(0, banks1.Length - ".tsd".Length);
                if (banks1.EndsWith("." + Globals.extensionDatabank, StringComparison.OrdinalIgnoreCase)) banks1 = banks1.Substring(0, banks1.Length - Globals.extensionDatabank.Length - 1);
                //TODO: make a smart trim procedure

                if (banks1.Length > 30)
                {
                    string ss1 = banks1.Substring(0, 17);
                    string ss2 = banks1.Substring(banks1.Length - 10);
                    banks1 = ss1 + "..." + ss2;
                }
                if (originalDataFileBaseline != "") banks2 = originalDataFileBaseline;
                try
                {
                    banks2 = Path.GetFileName(banks2);
                }
                catch { }
                if (banks2.EndsWith(".tsd", StringComparison.OrdinalIgnoreCase)) banks2 = banks2.Substring(0, banks2.Length - 4);
                if (banks2.EndsWith("." + Globals.extensionDatabank, StringComparison.OrdinalIgnoreCase)) banks2 = banks2.Substring(0, banks2.Length - Globals.extensionDatabank.Length - 1);
                if (banks2.Length > 30)
                {
                    string ss1 = banks2.Substring(0, 17);
                    string ss2 = banks2.Substring(banks2.Length - 10);
                    banks2 = ss1 + "..." + ss2;

                }

                if (wCount == 0) banks1 = "[empty]";
                if (rCount == 0) banks2 = "[empty]";

                if (banks1 == "[empty]" && banks2 == "[empty]")
                {
                    banks = "";
                }
                else if (banks2 == "[empty]")
                {
                    banks = "    |    First: " + banks1;
                }
                else
                {
                    banks = "    |    First: " + banks1 + "    |    " + "Ref" + ": " + banks2;
                }

                workingFolder = Program.options.folder_working;

            }

            //========================================================================================================
            //                          FREQUENCY LOCATION, indicates where to implement more frequencies
            //========================================================================================================
            string ss = "Period: " + f + " " + start + "-" + end + G.NL + "First: " + GetDatabankFileNameWithPath(Program.databanks.GetFirst()) + G.NL + "" + Globals.Ref + ": " + GetDatabankFileNameWithPath(Program.databanks.GetRef()) + G.NL + "Working folder: " + Program.options.folder_working + G.NL + "Mode: " + Program.options.interface_mode;

            if (ss != Gui.gui.toolStripStatusLabel1.ToolTipText) Gui.gui.toolStripStatusLabel1.ToolTipText = ss;

            if (Globals.workerThread != null)
            {
                string ss2 = G.FreqAndPeriodPretty(false, false) + banks + "    |    " + workingFolder;
                WorkerThreadHelper1 wh = new WorkerThreadHelper1();
                wh.statusField = ss2;
                Globals.workerThread.gekkoGui.Invoke(Globals.workerThread.gekkoGui.threadDelegateSetTitle, wh);
            }

            int i = 0;
            foreach (Graph g in Globals.windowsGraph)
            {
                i++;
            }
            foreach (Window1 g in Globals.windowsDecomp)
            {
                i++;
            }
            foreach (WindowDecomp g in Globals.windowsDecomp2)
            {
                i++;
            }
            CrossThreadStuff.CutButtonEnabled(i > 0);
        }

        /// <summary>
        /// Small helper method.
        /// </summary>
        /// <param name="bank"></param>
        /// <returns></returns>
        private static string GetDatabankFileNameWithPath(Databank bank)
        {
            string fileName = "[no bank filename]";
            if (bank != null)
            {
                fileName = bank.FileNameWithPathPretty;
            }
            return fileName;
        }

        /// <summary>
        /// Error message.
        /// </summary>
        /// <param name="lineNumber"></param>
        /// <param name="problemLine"></param>
        /// <param name="text"></param>
        /// <param name="fileName"></param>
        public static void WriteErrorMessage(int lineNumber, string problemLine, string text, string fileName)
        {
            if (Globals.threadIsInProcessOfAborting) return;
            G.Writeln(text, Color.Red, true);  //will also be red for a STOP command, but without counting as an error
            G.Writeln("    " + "[" + G.IntFormat(lineNumber, 4) + "]:" + "   " + G.ReplaceGlueSymbols(problemLine), Color.Blue, true);
        }

        /// <summary>
        /// Small helper method.
        /// </summary>
        /// <param name="fileName"></param>
        /// <returns></returns>
        private static string GetOriginalTableFileName(string fileName)
        {
            string s2 = "";
            if (fileName.Contains("tablecode." + Globals.defaultCommandFileExtension))
            {
                string s = GetTextFromFileWithWait(fileName);
                List<string> ss = Stringlist.ExtractLinesFromText(s);
                s2 = ss[2];
                s2 = s2.Replace(Globals.tableConverterText3, "");
            }
            return s2;
        }

        /// <summary>
        /// Helper for databank unswapping (not used at the moment)
        /// </summary>
        /// <param name="print"></param>
        public static void Unswap(bool print)
        {
            Databanks.Unswap();
        }

        /// <summary>
        /// Overload.
        /// </summary>
        public static void Unswap()
        {
            Unswap(true);
        }

        /// <summary>
        /// Helper for R interface.
        /// </summary>
        /// <param name="logger"></param>
        /// <returns></returns>
        private static string GetRhomeWin32NT(StringBuilder logger)
        {
            RegistryKey rCoreKey = GetRCoreRegistryKeyWin32(logger);
            return GetRInstallPathFromRCoreKegKey(rCoreKey, logger);
        }

        /// <summary>
        /// Helper for R interface.
        /// </summary>
        /// <param name="rCoreKey"></param>
        /// <param name="logger"></param>
        /// <returns></returns>
        private static string RecurseFirstSubkey(RegistryKey rCoreKey, StringBuilder logger)
        {
            string[] subKeyNames = rCoreKey.GetSubKeyNames();
            if (subKeyNames.Length > 0)
            {
                var versionNum = subKeyNames.First();
                var rVersionCoreKey = rCoreKey.OpenSubKey(versionNum);
                //doLogSetEnvVarInfo("As a last resort, trying to recurse into " + rVersionCoreKey, logger);
                return GetRInstallPathFromRCoreKegKey(rVersionCoreKey, logger);
            }
            else
            {
                //doLogSetEnvVarWarn("No sub-key found under " + rCoreKey, logger);
                return null;
            }
        }

        /// <summary>
        /// Obtain Gekko version number.
        /// </summary>
        public static void GetVersionAndGekkoExeLocationFromAssembly()
        {
            try
            {
                string version = Assembly.GetExecutingAssembly().GetName().Version.ToString();
                if (version.EndsWith(".0"))
                {
                    version = version.Substring(0, version.Length - 2);
                }
                Globals.gekkoVersion = version;
                string path = Assembly.GetExecutingAssembly().Location;
                Globals.gekkoExePath = path;
            }
            catch (Exception e) { };
        }

        /// <summary>
        /// Internal helper method to show info on Gekko (bitness, JIT-ness, etc.)
        /// </summary>
        /// <returns></returns>
        public static string IsJit()
        {
            var HasDebuggableAttribute = false;
            var IsJITOptimized = false;
            var IsJITTrackingEnabled = false;
            var BuildType = "";
            var DebugOutput = "";

            Assembly ReflectedAssembly = null;

            try
            {
                ReflectedAssembly = Assembly.LoadFile(Globals.gekkoExePath);
            }
            catch (Exception e)
            {

            }

            //	var ReflectedAssembly = Assembly.LoadFile(@"path to the dll you are testing");
            object[] attribs = ReflectedAssembly.GetCustomAttributes(typeof(DebuggableAttribute), false);

            // If the 'DebuggableAttribute' is not found then it is definitely an OPTIMIZED build
            if (attribs.Length > 0)
            {
                // Just because the 'DebuggableAttribute' is found doesn't necessarily mean
                // it's a DEBUG build; we have to check the JIT Optimization flag
                // i.e. it could have the "generate PDB" checked but have JIT Optimization enabled
                DebuggableAttribute debuggableAttribute = attribs[0] as DebuggableAttribute;
                if (debuggableAttribute != null)
                {
                    HasDebuggableAttribute = true;
                    IsJITOptimized = !debuggableAttribute.IsJITOptimizerDisabled;

                    // IsJITTrackingEnabled - Gets a value that indicates whether the runtime will track information during code generation for the debugger.
                    IsJITTrackingEnabled = debuggableAttribute.IsJITTrackingEnabled;
                    BuildType = debuggableAttribute.IsJITOptimizerDisabled ? "Debug" : "Release";

                    // check for Debug Output "full" or "pdb-only"
                    DebugOutput = (debuggableAttribute.DebuggingFlags &
                                    DebuggableAttribute.DebuggingModes.Default) !=
                                    DebuggableAttribute.DebuggingModes.None
                                    ? "Full" : "pdb-only";
                }
            }
            else
            {
                IsJITOptimized = true;
                BuildType = "Release";
            }

            string s = null;

            s += G.NL;
            s += "----- ONLY ON TT COMPUTER -----------------" + G.NL;
            s += $"{nameof(HasDebuggableAttribute)}: {HasDebuggableAttribute}" + " (not grave if True)" + G.NL;
            s += $"{nameof(IsJITOptimized)}: {IsJITOptimized}" + " (TT: should be True)" + G.NL;
            s += $"{nameof(IsJITTrackingEnabled)}: {IsJITTrackingEnabled}" + " (TT: should be False)" + G.NL;
            s += $"{nameof(BuildType)}: {BuildType}" + " (TT: should be Release)" + G.NL;
            s += $"{nameof(DebugOutput)}: {DebugOutput}" + G.NL;
            s += "--> See also the DumpBin() method (unused) that can check files" + G.NL;

            s += "-------------------------------------------" + G.NL;

            return s;
        }

        /// <summary>
        /// Internal helper method to test RAM allocation. Can be called with "testram" from GUI.
        /// </summary>
        /// <param name="read"></param>
        public static void TestRam(bool read)
        {

            if (true)
            {
                //with 32 bit around:                2.81 mio m chunks = 100 --> 281 mio 32 bits (4 bytes) --> 1.12 GB. 
                //with 32 bit large-ram-aware about: 6.21 RamLargeAware                                    --> 2.48 GB
                //with 64 bit it probably uses pagefile, got all the way up to around 40 mio chunks        --> 16 GB...
                //     However, 64-bit got SLOW fast, so probably needs tuning regarding page file. 

                G.Writeln(Get64Bitness(0));

                int ii = 0;
                //memory test to test 64-bit versions

                int chunk = 100;
                int i_report = 100000000 / 4 / chunk;  //100 MB

                //chunk = 3;
                //i_report = 4;

                DateTime t = DateTime.Now;
                LinkedList<List<int>> list = new LinkedList<List<int>>();
                try
                {
                    for (int i = 0; i < int.MaxValue; i++)
                    {

                        List<int> temp = new List<int>(chunk);
                        for (int i2 = 0; i2 < chunk; i2++)
                        {
                            temp.Add(i2);  //from 0...99
                        }

                        list.AddLast(temp);
                        if (i % i_report == 0)
                        {
                            double gb = (double)(chunk * 4) * (double)i / 1e9d;
                            G.Writeln("GB = " + gb + " ----> write ram = " + G.Seconds(t));
                            t = DateTime.Now;

                            if (read)
                            {
                                double d = 0d;
                                //double d2 = 0d;

                                foreach (List<int> temp2 in list)
                                {
                                    foreach (int temp3 in temp2)
                                    {
                                        d += (double)temp3;
                                        //d2 += 1d;
                                    }
                                }
                                //if 1 chunk runs from i1-i2 (inclusive), we get sum = (i2-i1+1)*(i1+i2)/2
                                double check = (double)(i + 1) * (double)chunk * ((double)chunk - 1) / 2;

                                G.Writeln("     Reading test: " + (d - check) + " == 0 ----> read ram = " + G.Seconds(t) + " ... per GB = " + Math.Round((DateTime.Now - t).TotalMilliseconds / 1000d / gb, 2));
                                //G.Writeln("     Test   " + d2 + "   " + d2 * 4d / 1e9d);  //just a test that the GB are correctly calculated

                                t = DateTime.Now;
                            }


                        }
                        ii = i;
                    }
                }
                catch (Exception e)
                {
                    if (Globals.threadIsInProcessOfAborting || Globals.applicationIsInProcessOfAborting)
                    {
                        MessageBox.Show("+++ NOTE: Hard abort of memory test");
                    }
                    else
                    {
                        MessageBox.Show("+++ NOTE: Memory test ran out of memory (not unexpected)");
                    }
                    //MessageBox.Show("ii = " + ii + ", chunk = " + chunk + ", " + Ex.Message + " " + Ex.InnerException);
                    //Microsoft.VisualBasic.Devices.ComputerInfo CI = new ComputerInfo();
                    //Console.WriteLine(CI.AvailablePhysicalMemory);
                }
            }
        }

        /// <summary>
        /// Internal helper method.
        /// </summary>
        /// <returns></returns>
        //keep it even if not referenced
        public static List<string> DumpBin()
        {
            List<string> rv = new List<string>();
            string s = @"call ""c:\Program Files(x86)\Microsoft Visual Studio\2017\Community\VC\Tools\MSVC\14.16.27023\bin\Hostx64\x64\dumpbin"" /headers *.exe | findstr ""machine Dump"" > dumpbin.txt";  //fethces lines with either "machine" or "Dump"
            return rv;
        }

        /// <summary>
        /// Info on bitness of Gekko. Type == 0 is verbose, type == 1 only returns "32" or "64".
        /// </summary>
        /// <returns></returns>
        public static string Get64Bitness(int type)
        {
            string s1 = null;
            string s2 = null;
            if (Environment.Is64BitProcess)
            {
                s1 = "64-bit Gekko process on ";
                s2 = "64";
            }
            else
            {
                s1 = "32-bit Gekko process on ";
                s2 = "32";
            }
            if (Environment.Is64BitOperatingSystem) s1 += "64-bit Windows system";
            else s1 += "32-bit Windows system";

            if (type == 0) return s1;
            else return s2;
        }

        /// <summary>
        /// R helper method.
        /// </summary>
        /// <param name="rCoreKey"></param>
        /// <returns></returns>
        private static string GetRCurrentVersionStringFromRegistry(RegistryKey rCoreKey)
        {
            return rCoreKey.GetValue("Current Version") as string;
        }

        /// <summary>
        /// R helper method.
        /// </summary>
        /// <param name="rCoreKey"></param>
        /// <param name="logger"></param>
        /// <returns></returns>
        private static string GetRInstallPathFromRCoreKegKey(RegistryKey rCoreKey, StringBuilder logger)
        {
            string installPath = null;
            string[] subKeyNames = rCoreKey.GetSubKeyNames();
            string[] valueNames = rCoreKey.GetValueNames();
            if (valueNames.Length == 0)
            {
                //doLogSetEnvVarWarn("Did not find any value names under " + rCoreKey, logger);
                return RecurseFirstSubkey(rCoreKey, logger);
            }
            else
            {
                const string installPathKey = "InstallPath";
                if (valueNames.Contains(installPathKey))
                {
                    //doLogSetEnvVarInfo("Found sub-key InstallPath under " + rCoreKey, logger);
                    installPath = (string)rCoreKey.GetValue(installPathKey);
                }
                else
                {
                    //doLogSetEnvVarInfo("Did not find sub-key InstallPath under " + rCoreKey, logger);
                    if (valueNames.Contains("Current Version"))
                    {
                        //doLogSetEnvVarInfo("Found sub-key Current Version under " + rCoreKey, logger);
                        string currentVersion = GetRCurrentVersionStringFromRegistry(rCoreKey);
                        if (subKeyNames.Contains(currentVersion))
                        {
                            var rVersionCoreKey = rCoreKey.OpenSubKey(currentVersion);
                            return GetRInstallPathFromRCoreKegKey(rVersionCoreKey, logger);
                        }
                        else
                        {
                            //doLogSetEnvVarWarn("Sub key " + currentVersion + " not found in " + rCoreKey, logger);
                        }
                    }
                    else
                    {
                        //doLogSetEnvVarInfo("Did not find sub-key Current Version under " + rCoreKey, logger);
                        return RecurseFirstSubkey(rCoreKey, logger);
                    }
                }
            }
            //doLogSetEnvVarInfo(string.Format("InstallPath value of key " + rCoreKey.ToString() + ": {0}",
            // installPath == null ? "null" : installPath), logger);
            return installPath;
        }        

        /// <summary>
        /// R helper method.
        /// </summary>
        private static void CheckPlatformWin32()
        {
            if (Environment.OSVersion.Platform != PlatformID.Win32NT)
                throw new NotSupportedException("This method is supported only on the Win32NT platform");
        }

        /// <summary>
        /// R helper method.
        /// </summary>
        /// <param name="logger"></param>
        /// <returns></returns>
        private static RegistryKey GetRCoreRegistryKeyWin32(StringBuilder logger)
        {
            CheckPlatformWin32();
            var rCore = Registry.LocalMachine.OpenSubKey(@"SOFTWARE\R-core");
            if (rCore == null)
            {
                //doLogSetEnvVarInfo(@"Local machine SOFTWARE\R-core not found - trying current user", logger);
                rCore = Registry.CurrentUser.OpenSubKey(@"SOFTWARE\R-core");
                if (rCore == null)
                    throw new ApplicationException("Windows Registry key 'SOFTWARE\\R-core' not found in HKEY_LOCAL_MACHINE nor HKEY_CURRENT_USER");
            }
            //doFoundWinRegKey(rCore, logger);
            bool is64Bit = Environment.Is64BitProcess;
            var subKey = is64Bit ? "R64" : "R";
            var r = rCore.OpenSubKey(subKey);
            if (r == null)
            {
                throw new ApplicationException(string.Format(
                   "Windows Registry sub-key '{0}' of key '{1}' was not found", subKey, rCore.ToString()));
            }
            //doFoundWinRegKey(rCore, logger);
            return r;
        }

        /// <summary>
        /// Write a Gekko matrix to a string suitable for R or Python.
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="name"></param>
        /// <param name="m"></param>
        /// <param name="type"></param>
        /// <returns></returns>
        public static string MatrixFromGekkoToROrPython<T>(string name, T[,] m, int type)
        {
            //See also MatrixFromROrPythonToGekko()
            if (m == null || m.Length == 0) return null;
            string s = null;
            if (type == 0)
            {
                //hmmm, why not just use the double loop, strange...
                //maybe because of comma
                s = name + " = c(" + m[0, 0];
                for (int i = 1; i < m.GetLength(0); i++)
                    s += "," + m[i, 0];
                for (int j = 1; j < m.GetLength(1); j++)
                    for (int i = 0; i < m.GetLength(0); i++)
                        s += "," + m[i, j];
                s += ")" + G.NL;
                s += "dim(" + name + ") = c(" + m.GetLength(0) + ", " + m.GetLength(1) + ")";
            }
            else
            {
                s = name + " = ";
                s += "numpy.array([";
                for (int i = 0; i < m.GetLength(0); i++)
                {
                    if (i > 0) s += ",";
                    s += "[";
                    for (int j = 0; j < m.GetLength(1); j++)
                    {
                        if (j > 0) s += ",";
                        if (typeof(T) == typeof(double))
                        {
                            double[,] xx = m as double[,];
                            double d = xx[i, j];
                            if (G.isNumericalError(d))
                                s += "numpy.nan";
                            else
                                s += m[i, j];
                        }
                        else
                        {
                            s += m[i, j];
                        }
                    }
                    s += "]";
                }
                s += "])";
            }
            return s;
        }

        /// <summary>
        /// Used for R_RUN and PYTHON_RUN.
        /// </summary>
        /// <param name="names"></param>
        /// <param name="target"></param>
        /// <param name="type"></param>
        public static void ROrPythonExport(List names, string target, int type)
        {
            //type 0 = R, type 1 = Python

            List<string> fileContent = null;
            string programName = null;
            if (type == 0)
            {
                fileContent = Globals.r_fileContent;
                programName = "R";
            }
            else
            {
                fileContent = Globals.python_fileContent;
                programName = "Python";
            }
            string all = null;
            List<string> exportItems = O.Restrict(names, true, true, false, false);  //only matrices, #x
            if (exportItems != null)
            {
                foreach (string s in exportItems)
                {
                    string rawS = G.Chop_RemoveBank(s).Replace(Globals.symbolCollection.ToString(), "");
                    IVariable iv = O.GetIVariableFromString(s, O.ECreatePossibilities.NoneReportError, true);
                    if (iv != null && iv.Type() == EVariableType.Matrix)
                    {
                        Matrix m = (Matrix)iv;
                        all += Program.MatrixFromGekkoToROrPython<double>(rawS, m.data, type) + G.NL;
                    }
                    else
                    {
                        new Error("Could not find matrix " + s);
                        //throw new GekkoException();
                    }
                }
            }

            if (target == null)
            {
                //insert at top
                List<string> l2 = new List<string>();
                if (all != null) l2.Add(all);
                if (fileContent != null) l2.AddRange(fileContent);
                fileContent.Clear();
                foreach (string s in l2) fileContent.Add(s);
            }
            else
            {
                bool hit = false;
                List<string> l2 = new List<string>();
                if (fileContent == null)
                {
                    new Error("the " + programName.ToUpper() + "_FILE is empty");
                    //throw new GekkoException();
                }
                foreach (string line in fileContent)
                {
                    l2.Add(line);
                    if (line.TrimStart().ToLower().StartsWith("gekkoimport "))
                    {
                        string[] ss = line.Split(new string[] { " " }, StringSplitOptions.RemoveEmptyEntries);
                        if (ss.Length > 1)
                        {
                            if (G.IsIdent(ss[1]))
                            {
                                string foundBlock = ss[1];
                                if (G.Equal(target, foundBlock))
                                {
                                    l2.Add(all);
                                    hit = true;
                                }
                            }
                        }
                    }
                }
                if (hit == false)
                {
                    new Error("Could not find statement 'gekkoimport " + target + "' in the " + programName + " file");
                    //throw new GekkoException();
                }

                fileContent.Clear();
                foreach (string s in l2) fileContent.Add(s);

                //fileContent = l2;

            }
        }

        /// <summary>
        /// Handling R_RUN command.
        /// </summary>
        /// <param name="o"></param>
        public static void RunR(Gekko.O.R_run o)
        {

            string RFileName = Globals.localTempFilesLocation + "\\tempRFile.r";
            string RExportFileName = Globals.localTempFilesLocation + "\\tempR2Gekko.txt";
            List<string> lines2 = new List<string>();

            string def1 = "#gekkoexport function def start";
            string def2 = "#gekkoexport function def end";

            lines2.Add(def1);
            lines2.Add("gekkoexport  <- function(input) {");
            lines2.Add("  name <- deparse(substitute(input))");
            lines2.Add("  filename <- `" + RExportFileName.Replace("\\", "\\\\") + "`");
            lines2.Add("  cols <- NCOL(input)");
            lines2.Add("  write(paste(`name = `, name), filename, append=TRUE)");
            lines2.Add("  write(paste(`rows = `, as.character(NROW(input))), filename, append=TRUE)");
            lines2.Add("  write(paste(`cols = `, as.character(NCOL(input))), filename, append=TRUE)");
            lines2.Add("  write(t(input), file = filename, n=cols, append=TRUE)");
            lines2.Add("  write(`-------------------`, filename, append=TRUE)");
            lines2.Add("}");
            lines2.Add(def2);
            string f = Stringlist.ExtractTextFromLines(lines2).ToString().Replace("`", Globals.QT);

            if (o.fileName != null)
            {
                //called in the new way
                Globals.r_fileContent = null;
                FindFileHelper ffh = Program.FindFile(o.fileName, null, true, true, o.p);
                string file = ffh.realPathAndFileName;
                if (file == null) new Error("The file does not exist: " + ffh.prettyPathAndFileName);
                Globals.r_fileContent = Stringlist.ExtractLinesFromText(Program.GetTextFromFileWithWait(file));
                Program.ROrPythonExport(o.names, o.opt_target, 0);
            }
            else
            {
                //called in old way
                if (Globals.r_fileContent == null)
                {
                    new Error("No R file defined in R_FILE");
                    //throw new GekkoException();
                }
            }

            using (FileStream fs = WaitForFileStream(RFileName, null, GekkoFileReadOrWrite.Write))
            using (StreamWriter sw = G.GekkoStreamWriter(fs))  //using new StreamWriter() not good here, then problem with chars like (c) copyright in filename. See also #7284242898
            {
                sw.Write(f);
                foreach (string s2 in Globals.r_fileContent)
                {
                    if (s2.TrimStart().ToLower().StartsWith("gekkoimport ")) continue;
                    sw.WriteLine(s2);
                }
                sw.Flush();
                sw.Close();
            }

            //Make r2gekko.txt file that R later on fills into
            using (FileStream fs = WaitForFileStream(RExportFileName, null, GekkoFileReadOrWrite.Write))
            using (StreamWriter sw = G.GekkoStreamWriter(fs))
            {
                sw.WriteLine("R2Gekko version 1.0");
                sw.WriteLine("-------------------");
                sw.Flush();
                sw.Close();
            }

            string exe = "rscript.exe";

            string RPathUsedHere = null;
            if (Program.options.r_exe_folder.Trim() == "")
            {
                //no path stated manually
                if (Globals.detectedRPath == null || Globals.detectedRPath == "[[RDetectFailed]]")
                {
                    //do not do this every time R is called!
                    string RPath = GetRhomeWin32NT(null);
                    if (RPath == null || RPath.Trim() == "") Globals.detectedRPath = "[[RDetectFailed]]";
                    else Globals.detectedRPath = RPath + "\\bin\\" + exe;
                }
                else
                {
                    //either second etc. time, or previous detect fail                    
                }
                RPathUsedHere = Globals.detectedRPath;
            }
            else
            {
                //overrides
                if (Program.options.r_exe_folder.ToLower().EndsWith("\\" + exe))
                {
                    RPathUsedHere = Program.options.r_exe_folder;
                }
                else
                {
                    if (Program.options.r_exe_folder.EndsWith("\\")) RPathUsedHere = Program.options.r_exe_folder + exe;
                    else RPathUsedHere = Program.options.r_exe_folder + "\\" + exe;
                }
            }

            //Now RPathUsedHere should be either
            // - A file path ending with "\rscript.exe"
            // - "[[RDetectFailed]]"

            if (RPathUsedHere == "[[RDetectFailed]]")
            {
                new Error("R.exe folder could not be auto-detected. Please state the R.exe folder manually with OPTION r exe folder = ...");

                //throw new GekkoException();
            }

            //Now RPathUsedHere is a file path ending with "\Rscript.exe"            

            G.Writeln2("----- R start -----");
            string ss7 = "\"\"" + RPathUsedHere + "\" --no-save \"" + RFileName + "\"\"";
            Program.ExecuteShellCommand(ss7, G.Equal(o.opt_mute, "yes"));
            G.Writeln("------ R end ------");

            //Old way --> r.StartInfo.Arguments = " CMD BATCH --no-save " + Globals.QT + RFileName + Globals.QT + " " + Globals.QT + RFileName + ".txt" + Globals.QT;

            string s = Program.GetTextFromFileWithWait(RExportFileName);
            List<string> lines = Stringlist.ExtractLinesFromText(s);
            MatrixFromROrPythonToGekko(lines, 0);
        }

        /// <summary>
        /// Getting a matrix from R or Python back into Gekko.
        /// </summary>
        /// <param name="lines"></param>
        /// <param name="type"></param>
        private static void MatrixFromROrPythonToGekko(List<string> lines, int type)
        {
            //See also MatrixFromGekkoToROrPython()
            string data = null;
            string name = null;
            int rows = -12345;
            int cols = -12345;
            bool first = true;
            foreach (string line in lines)
            {
                if (type == 0 && line.StartsWith("R2Gekko")) continue;
                if (type == 1 && line.StartsWith("Python2Gekko")) continue;
                if (line.StartsWith("---"))
                {
                    if (first)
                    {
                        first = false;
                        continue;
                    }
                    else
                    {
                        string[] ss = data.Split(new char[] { ' ' }, StringSplitOptions.RemoveEmptyEntries);

                        Matrix m = new Matrix(rows, cols);

                        int cnt = -1;
                        foreach (string s2 in ss)
                        {
                            cnt++;
                            double d = double.NaN;
                            if (s2 != "NA") d = G.ParseIntoDouble(s2);
                            m.data[cnt / cols, cnt % cols] = d;
                        }

                        Program.databanks.GetFirst().AddIVariableWithOverwrite(Globals.symbolCollection + name, m);

                        data = null;
                        name = null;
                        rows = -12345;
                        cols = -12345;
                        continue;
                    }
                }
                if (line.StartsWith("name ="))
                {
                    name = line.Split('=')[1].Trim();
                    continue;
                }
                if (line.StartsWith("rows ="))
                {
                    rows = int.Parse(line.Split('=')[1].Trim());
                    continue;
                }
                if (line.StartsWith("cols ="))
                {
                    cols = int.Parse(line.Split('=')[1].Trim());
                    continue;
                }
                data += line + " ";
            }
        }

        /// <summary>
        /// Handle PYTHON_RUN.
        /// </summary>
        /// <param name="o"></param>
        public static void RunPython(Gekko.O.Python_run o)
        {
            string pythonFileName = Globals.localTempFilesLocation + "\\tempPyFile.py";
            string pythonExportFileName = Globals.localTempFilesLocation + "\\tempPy2Gekko.txt";
            List<string> lines2 = new List<string>();

            string def1 = "#gekkoexport function def start";
            string def2 = "#gekkoexport function def end";

            lines2.Add(def1);
            //-------
            lines2.Add(@"");
            lines2.Add(@"import numpy");
            lines2.Add(@"import inspect");
            lines2.Add(@"def gekkoexport(input, name2 = None):");
            lines2.Add(@"  if name2 is None:");
            lines2.Add(@"    frame = inspect.currentframe()");
            lines2.Add(@"    frame = inspect.getouterframes(frame)[1]");
            lines2.Add(@"    s = inspect.getframeinfo(frame[0]).code_context[0].strip()");
            lines2.Add(@"    args = s[s.find('gekkoexport('):-1].split(')')");
            lines2.Add(@"    name = args[0].replace('gekkoexport(', '') # only one gekkoexport() per line, and no expressions");
            lines2.Add(@"  else:");
            lines2.Add(@"    name = name2");
            lines2.Add(@"  filename = r'" + pythonExportFileName + "'");
            lines2.Add(@"  dim = -12345");
            lines2.Add(@"  isList = False");
            lines2.Add(@"  if isinstance(input, list):");
            lines2.Add(@"    isList = True");
            lines2.Add(@"    if (isinstance(input[0], list)):");
            lines2.Add(@"      dim = 2 #could be higher...");
            lines2.Add(@"      rows = len(input)");
            lines2.Add(@"      cols = len(input[0])");
            lines2.Add(@"    else:");
            lines2.Add(@"      dim = 1");
            lines2.Add(@"      rows = len(input)");
            lines2.Add(@"      cols = 1");
            lines2.Add(@"  elif isinstance(input, (int, float)):");
            lines2.Add(@"    dim = 0");
            lines2.Add(@"    rows = 1");
            lines2.Add(@"    cols = 1");
            lines2.Add(@"  else:");
            lines2.Add(@"    if len(input.shape) == 1:");
            lines2.Add(@"      dim = 1");
            lines2.Add(@"      rows = input.shape[0]");
            lines2.Add(@"      cols = 1");
            lines2.Add(@"    else:");
            lines2.Add(@"      dim = len(input.shape)");
            lines2.Add(@"      rows, cols = input.shape");
            lines2.Add(@"  f = open(filename, 'a')");
            lines2.Add(@"  f.write('name = ' + name + '\n')");
            lines2.Add(@"  f.write('rows = ' + str(rows) + '\n')");
            lines2.Add(@"  f.write('cols = ' + str(cols) + '\n')");
            lines2.Add(@"  if dim == 0:");
            lines2.Add(@"    f.write(str(input) + '\n')");
            lines2.Add(@"  elif dim == 1:");
            lines2.Add(@"    for i in range(0, rows):");
            lines2.Add(@"      f.write(str(input[i]) + '\n')");
            lines2.Add(@"  elif dim == 2:");
            lines2.Add(@"    for i in range(0, rows):");
            lines2.Add(@"      for j in range(0, cols):");
            lines2.Add(@"        if isList:");
            lines2.Add(@"          f.write(str(input[i][j]) + '\n')");
            lines2.Add(@"        else:");
            lines2.Add(@"          f.write(str(input[i, j]) + '\n')");
            lines2.Add(@"  f.write('-------------------\n')");
            lines2.Add(@"  f.close()");
            //-------
            lines2.Add(def2);
            string f = Stringlist.ExtractTextFromLines(lines2).ToString().Replace("`", Globals.QT);

            if (true)
            {
                Globals.python_fileContent = null;
                FindFileHelper ffh = Program.FindFile(o.fileName, null, true, true, o.p);
                string file = ffh.realPathAndFileName;
                if (file == null) new Error("The file does not exist: " + ffh.prettyPathAndFileName);
                Globals.python_fileContent = Stringlist.ExtractLinesFromText(Program.GetTextFromFileWithWait(file));
                Program.ROrPythonExport(o.names, o.opt_target, 1);
            }

            using (FileStream fs = WaitForFileStream(pythonFileName, null, GekkoFileReadOrWrite.Write))
            using (StreamWriter sw = new StreamWriter(fs))    //using G.GekkoStreamWriter() not good here, then problem with chars like (c) copyright in filename. See also #7284242898
            {
                sw.Write(f);
                foreach (string s2 in Globals.python_fileContent)
                {
                    if (s2.TrimStart().ToLower().StartsWith("gekkoimport ")) continue;
                    sw.WriteLine(s2);
                }
                sw.Flush();
                sw.Close();
            }

            //Make python2gekko.txt file that Python later on fills into
            using (FileStream fs = WaitForFileStream(pythonExportFileName, null, GekkoFileReadOrWrite.Write))
            using (StreamWriter sw = G.GekkoStreamWriter(fs))
            {
                sw.WriteLine("Python2Gekko version 1.0");
                sw.WriteLine("------------------------");
                sw.Flush();
                sw.Close();
            }

            string pythonPathUsedHere = null;
            if (Program.options.python_exe_folder.Trim() == "")
            {
                //no path stated manually
                if (Globals.detectedPythonPath == null || Globals.detectedPythonPath == "[[PythonDetectFailed]]")
                {
                    //do not do this every time Python is called!
                    string pythonPath = GetPythonPath();
                    if (pythonPath == null || pythonPath.Trim() == "") Globals.detectedPythonPath = "[[PythonDetectFailed]]";
                    else Globals.detectedPythonPath = pythonPath;
                }
                else
                {
                    //either second etc. time, or previous detect fail                    
                }
                pythonPathUsedHere = Globals.detectedPythonPath;
            }
            else
            {
                //overrides
                if (Program.options.python_exe_folder.ToLower().EndsWith("\\python.exe"))
                {
                    pythonPathUsedHere = Program.options.python_exe_folder;
                }
                else
                {
                    if (Program.options.python_exe_folder.EndsWith("\\")) pythonPathUsedHere = Program.options.python_exe_folder + "python.exe";
                    else pythonPathUsedHere = Program.options.python_exe_folder + "\\python.exe";
                }
            }

            //Now pythonPathUsedHere should be either
            // - A file path ending with "\python.exe"
            // - "[[PythonDetectFailed]]"

            if (pythonPathUsedHere == "[[PythonDetectFailed]]")
            {
                new Error("python.exe path could not be auto-detected. Please state the python.exe path manually with OPTION python exe folder = ...");

                //throw new GekkoException();
            }

            G.Writeln2("----- Python start -----");
            //Python needs -u argument to show long-running processes output line by line
            string ss7 = "\"\"" + pythonPathUsedHere + "\" -u \"" + pythonFileName + "\"\"";
            Program.ExecuteShellCommand(ss7, G.Equal(o.opt_mute, "yes"));
            G.Writeln("------ Python end ------");

            string s = Program.GetTextFromFileWithWait(pythonExportFileName);
            List<string> lines = Stringlist.ExtractLinesFromText(s);
            MatrixFromROrPythonToGekko(lines, 1);
        }

        /// <summary>
        /// Helper for Python interface.
        /// </summary>
        /// <returns></returns>
        public static string GetPythonPath()
        {
            //https://gis.stackexchange.com/questions/44411/how-can-i-programmatically-get-the-path-of-python-exe-used-by-arcmap
            IDictionary environmentVariables = Environment.GetEnvironmentVariables();
            string pathVariable = environmentVariables["Path"] as string;
            if (pathVariable != null)
            {
                string[] allPaths = pathVariable.Split(';');
                foreach (var path in allPaths)
                {
                    string pythonPathFromEnv = path + "\\python.exe";
                    if (File.Exists(pythonPathFromEnv))
                        return pythonPathFromEnv;
                }
            }
            return null;
        }

        /// <summary>
        /// See PrecedentsHelper().
        /// </summary>
        /// <param name="db"></param>
        /// <param name="varnameWithFreq"></param>
        public static void AddToPrecedents(Databank db, string varnameWithFreq)
        {
            string two = db.name + ":" + varnameWithFreq;
            if (!Globals.precedents.ContainsKey(two))
            {
                Globals.precedents.Add(two, 0);
            }
        }

        /// <summary>
        /// Method for the X12A command, seasonal correction. An external .exe file is called.
        /// </summary>
        /// <param name="o"></param>
        public static void X12a(Gekko.O.X12a o)
        {
            GekkoTime t1 = GekkoTime.tNull; GekkoTime t2 = GekkoTime.tNull;  //obtained from o.t1 and o.t2 later on

            List<string> listItems = O.Restrict(o.names, true, false, true, false);
            string parameters = o.opt_param;
            if (parameters == null)
            {
                //emulates AREMOS 100%
                parameters = "save=(d10, d11, saa) mode=mult sigmalim=(1.50,2.50) seasonalma=msr force=totals";
            }

            //TODO: implement for array-series. For array-series x, produce x_saa etc. Or how is it done
            //

            string tempName = "tempX12aFile";
            string spcFileName = Globals.localTempFilesLocation + "\\" + tempName + ".spc";
            List<string> lines2 = new List<string>();

            //Delete tempX12aFile.*
            string[] files = Directory.GetFiles(Globals.localTempFilesLocation, "" + tempName + "*.*");
            foreach (string file in files) WaitForFileDelete(file);

            string meta = null;
            int counter = 0;

            List<Series> tss = new List<Series>();

            for (int i = 0; i < listItems.Count; i++)
            {
                IVariable iv = O.GetIVariableFromString(listItems[i], O.ECreatePossibilities.NoneReportError, true);

                Series ts = O.ConvertToSeries(iv) as Series;
                tss.Add(ts);  //for later use

                if (ts.freq == EFreq.Q || ts.freq == EFreq.M)
                {
                    //good
                }
                else
                {
                    new Error("You cannot use X12A on " + ts.freq.Pretty() + " timeseries. The external X12A component from the US Census Bureau only supports Quarterly or Monthly.");
                }

                //We may be operating on a timeseries with another frequency than what is current or put into the <...> option field                
                GekkoTime.ConvertFreqs(ts.freq, o.t1, o.t2, ref t1, ref t2);

                counter++;
                string data = null;
                foreach (GekkoTime t in new GekkoTimeIterator(t1, t2))
                {
                    double v = ts.GetDataSimple(t);
                    if (G.isNumericalError(v))
                    {
                        new Error("Missing value in '" + ts.name + "', period " + G.FromDateToString(t));
                    }
                    data += v.ToString() + G.NL;
                }
                //Create data files
                meta += tempName + counter + ".dat" + G.NL;
                using (FileStream fs = WaitForFileStream(Globals.localTempFilesLocation + "\\" + tempName + counter + ".dat", null, GekkoFileReadOrWrite.Write))
                using (StreamWriter sw = G.GekkoStreamWriter(fs))
                {
                    sw.Write(data);
                    sw.Flush();
                    sw.Close();
                }
            }

            using (FileStream fs = WaitForFileStream(Globals.localTempFilesLocation + "\\" + tempName + ".dta", null, GekkoFileReadOrWrite.Write))
            using (StreamWriter sw = G.GekkoStreamWriter(fs))
            {
                sw.Write(meta);
                sw.Flush();
                sw.Close();
            }
            string s2 = null;
            s2 += "series {" + G.NL;  //for instance 2000.2
            s2 += "start = " + t1.super + "." + t1.sub + G.NL;  //for instance 2000.2
            s2 += "period = " + GetFreqNumbers(t1.freq) + G.NL;  //4 or 12
            s2 += "}" + G.NL;

            s2 += "x11{ " + parameters + " }" + G.NL;

            //Create tempX12aFile.spc
            using (FileStream fs = WaitForFileStream(spcFileName, null, GekkoFileReadOrWrite.Write))
            using (StreamWriter sw = G.GekkoStreamWriter(fs))
            {
                sw.Write(s2);
                sw.Flush();
                sw.Close();
            }

            string currentDir = Directory.GetCurrentDirectory();  //remembered in order to switch back
            Directory.SetCurrentDirectory(Globals.localTempFilesLocation);
            try
            {
                Process process = new Process();
                string startup = null;
                if (G.IsUnitTesting())
                {
                    startup = Globals.ttPath2 + "\\" + Globals.ttPath3 + "\\Gekko\\bin\\Debug";
                }
                else
                {
                    startup = Application.StartupPath;
                }

                process.StartInfo.FileName = startup + "\\X12A.EXE";
                process.StartInfo.WindowStyle = ProcessWindowStyle.Hidden;
                //tempName does not contain blanks, so quotes are not needed
                //TODO: perhaps do this like PLOT with random numbers attached
                process.StartInfo.Arguments = tempName + " -d " + tempName;
                process.Start();
                process.WaitForExit();
                process.Close();
            }
            finally
            {
                Directory.SetCurrentDirectory(currentDir);
            }

            List<string> ext = new List<string>() { "c17", "d10", "d11", "d12", "d13", "saa" };
            //Import data
            files = Directory.GetFiles(Globals.localTempFilesLocation, "" + tempName + "*.*");
            bool first = true;
            foreach (string file in files)
            {
                int i = -1;
                foreach (Series ts0 in tss)

                //for (int i = 0; i < o.listItems.Count; i++)
                {
                    i++;
                    foreach (string e in ext)
                    {
                        string sss = Path.GetFileName(file);
                        if (G.Equal(sss, tempName + (i + 1) + "." + e))
                        {

                            string varName2 = null; string freq = null; O.ChopFreq(ts0.name, ref freq, ref varName2);
                            string varName = varName2 + "_" + e + Globals.freqIndicator + freq;

                            Series ts = new Series(t1.freq, varName);

                            string s = Program.GetTextFromFileWithWait(file);
                            List<string> lines = Stringlist.ExtractLinesFromText(s);
                            foreach (string line in lines)
                            {
                                if (line.TrimStart().ToLower().StartsWith("date")) continue;
                                if (line.TrimStart().ToLower().StartsWith("---")) continue;
                                string[] ss = line.Split(new string[] { "\t" }, StringSplitOptions.RemoveEmptyEntries);
                                if (ss.Length != 2)
                                {
                                    new Error("Error #8907523 in X12A");
                                }
                                try
                                {
                                    if (ss[0].Length != 6)
                                    {
                                        new Error("Error #897525 in X12A");
                                    }
                                    int i1 = int.Parse(ss[0].Substring(0, 4));
                                    int i2 = int.Parse(ss[0].Substring(4, 2));
                                    GekkoTime gt = new GekkoTime(t1.freq, i1, i2);
                                    ts.SetData(gt, G.ParseIntoDouble(ss[1]));
                                }
                                catch
                                {
                                    new Error("Error #897524 in X12A");
                                }
                            }
                            Databank db = ts0.meta.parentDatabank;

                            db.AddIVariableWithOverwrite(ts);

                            ts.Stamp();
                            //ts.SetDirty(true);  //already set with .AddIVariableWithOverwrite()

                            if (first) G.Writeln();
                            G.Writeln("Adjusted timeseries: " + db.name + ":" + varName);
                            first = false;
                        }
                    }
                    //}
                }
            }

            if (first)
            {
                string extra = null;
                int n = GekkoTime.Observations(t1, t2);
                int n2 = t2.super - t1.super + 1;  //yearly obs
                if (t1.freq == EFreq.M)
                {
                    if (n > 708)
                    {
                        extra = "Note: there are " + n + " months in the sample " + t1.ToString() + "-" + t2.ToString() + ". ";
                        extra += "It seems that the external X12A component used in Gekko only supports up to 708 months or 59 years for monthly data. ";
                        extra += "To remedy this, you may split the period into overlapping sub-periods and use {a{SPLICE¤splice.htm}a} to splice them.";
                    }
                }
                else if (t1.freq == EFreq.Q)
                {
                    if (n2 > 60)
                    {
                        extra = "Note: the quarters span over " + n2 + " calendar years (" + t2.super + " - " + t1.super + " + 1 = " + n2 + ") in the sample " + t1.ToString() + "-" + t2.ToString() + ". ";
                        extra += "It seems that the external X12A component used in Gekko only supports up to 60 calendar years for quarterly data. ";
                        extra += "To remedy this, you may split the period into overlapping sub-periods and use {a{SPLICE¤splice.htm}a} to splice them.";
                    }
                }

                using (Warning txt = new Warning())
                {
                    txt.MainAdd("The X12A component did not produce any adjusted timeseries. See more info/logging in the tempX12aFile... files here: " + Globals.localTempFilesLocation + ".");
                    if (extra != null)
                    {
                        txt.MainNewLine();
                        txt.MainAdd(extra);
                    }
                }
            }

            if (parameters != null)
            {
                if (!(parameters.ToLower().Contains("totals") && parameters.ToLower().Contains("force")))
                {
                    if (parameters.ToLower().Contains("saa"))
                    {
                        new Note("For 'saa' type, you need the parameter 'force=totals'");
                    }
                }
            }
        }

        /// <summary>
        /// Helper for X12A command, see X12a() method.
        /// </summary>
        /// <param name="freq"></param>
        /// <returns></returns>
        private static string GetFreqNumbers(EFreq freq)
        {
            string per = "";
            if (freq == EFreq.A)
            {
                new Error("You cannot use X12A on an annual timeseries");
                //throw new GekkoException();
            }
            else if (freq == EFreq.U)
            {
                new Error("You cannot use X12A on an undated timeseries");
                //throw new GekkoException();
            }
            else if (freq == EFreq.Q)
            {
                per = "4";
            }
            else if (freq == EFreq.M)
            {
                per = "12";
            }
            else if (freq == EFreq.D)
            {
                per = "365";
            }
            return per;
        }

        /// <summary>
        /// Print a Gekko matrix. Used in PRT command.
        /// </summary>
        /// <param name="a"></param>
        /// <param name="label"></param>
        public static void ShowMatrix(Matrix a, string label)
        {
            if (a.data.GetLength(0) < 1 || a.data.GetLength(1) < 1)
            {
                G.Writeln2("The matrix has dimensions " + a.data.GetLength(0) + "x" + a.data.GetLength(1) + ", and cannot be printed");
                throw new GekkoException();
            }
            Gekko.Table tab = new Gekko.Table();
            for (int i = 0; i < a.data.GetLength(0); i++)
            {
                for (int j = 0; j < a.data.GetLength(1); j++)
                {
                    Cell c = new Cell();
                    c.cellType = CellType.Number;
                    c.number = a.data[i, j];
                    c.numberFormat = "f" + Program.options.print_fields_nwidth + "." + Program.options.print_fields_ndec + "";
                    tab.Set(new Coord(i + 2, j + 2), c);
                }
            }
            for (int i = 0; i < a.data.GetLength(0); i++)
            {
                //row dimension
                Cell c = null;
                if (a.rownames != null && i < a.rownames.Count && a.rownames[i].Trim() != "")
                {
                    c = new Cell();
                    c.cellType = CellType.Text;
                    c.CellText = new Gekko.Text();
                    c.CellText.TextData = new List<string> { a.rownames[i].Trim() };
                    c.align = -1;
                }
                else
                {
                    c = new Cell();
                    c.cellType = CellType.Number;
                    c.number = i + 1;
                    c.numberFormat = "f4.0";
                }
                tab.Set(new Coord(i + 2, 1), c);
            }
            for (int i = 0; i < a.data.GetLength(1); i++)
            {
                //col dimension                
                Cell c = null;
                if (a.colnames != null && i < a.colnames.Count && a.colnames[i].Trim() != "")
                {
                    c = new Cell();
                    c.cellType = CellType.Text;
                    c.CellText = new Gekko.Text();
                    c.CellText.TextData = new List<string> { a.colnames[i].Trim() };
                    c.align = 1;
                }
                else
                {
                    c = new Cell();
                    c.cellType = CellType.Number;
                    c.number = i + 1;
                    c.numberFormat = "f4.0";
                }
                tab.Set(new Coord(1, i + 2), c);
            }
            List<string> xx = tab.PrintText();

            int widthRemember = Program.options.print_width;
            Program.options.print_width = int.MaxValue;

            //G.Writeln();

            string label2 = G.ReplaceGlueSymbols(label);
            label2 = ScalarString.SubstituteScalarsInString(label2, false, true);  //#lkjadsfkalsdfjaskl

            PrintLabel(label2);
            foreach (string s in xx)
            {
                G.Writeln(s);
            }

            Program.options.print_width = widthRemember;

            Globals.lastPrtOrMulprtTable = tab;  //this puts the matrix on the clipboard.
            CrossThreadStuff.CopyButtonEnabled(true);
        }

        /// <summary>
        /// Helper function to see if compiler option is set for 32-bit Gekko (more RAM access)
        /// </summary>
        /// <param name="file"></param>
        /// <returns></returns>
        public static bool IsLargeAware(string file)
        {
            using (var fs = File.OpenRead(file))
            {
                return IsLargeAware(fs);
            }
        }

        /// <summary>
        /// Helper function to see if compiler option is set for 32-bit Gekko (more RAM access). Checks if the stream is a MZ header and if it is large address aware. 
        /// </summary>
        /// <param name="stream">Stream to check, make sure its at the start of the MZ header</param>
        /// <exception cref=""></exception>
        /// <returns></returns>
        public static bool IsLargeAware(Stream stream)
        {
            const int IMAGE_FILE_LARGE_ADDRESS_AWARE = 0x20;

            var br = new BinaryReader(stream);

            if (br.ReadInt16() != 0x5A4D)       //No MZ Header
                return false;

            br.BaseStream.Position = 0x3C;
            var peloc = br.ReadInt32();         //Get the PE header location.

            br.BaseStream.Position = peloc;
            if (br.ReadInt32() != 0x4550)       //No PE header
                return false;

            br.BaseStream.Position += 0x12;
            return (br.ReadInt16() & IMAGE_FILE_LARGE_ADDRESS_AWARE) == IMAGE_FILE_LARGE_ADDRESS_AWARE;
        }

        /// <summary>
        /// Method to handle Gekko flowcharts. These are defunct in Gekko 3.x at the moment, but may be revived. Cf. the GekkoFlowChart
        /// project.
        /// </summary>
        /// <param name="s"></param>
        /// <param name="code"></param>
        /// <param name="period"></param>
        public static void FlowChart(string s, string code, GekkoTime period)
        {
            Dictionary<string, int> counter = new Dictionary<string, int>(StringComparer.OrdinalIgnoreCase);
            List<GekkoFlowChart.FlowNode> sw2 = new List<GekkoFlowChart.FlowNode>();
            List<GekkoFlowChart.FlowArrow> sw = new List<GekkoFlowChart.FlowArrow>();

            int maxDepth = 20;
            double prune = Globals.pruneDecomp;  //is relative, NOT percent
            //int year = int.Parse(s2);  //TODO: quarters etc.

            counter.Add(s, counter.Count);

            GekkoFlowChart.FlowNode fn = new GekkoFlowChart.FlowNode();
            fn.varName = s;
            fn.counter = counter[s];
            fn.labelBig = Program.FlowInsertLabel(s);
            if (Program.VariableTypeEndoExo(s) == EEndoOrExo.Exo) fn.isExogenous = true;
            else fn.isExogenous = false;
            fn.isStartNode = true;
            sw2.Add(fn);

            Dictionary<string, int> d = new Dictionary<string, int>(StringComparer.OrdinalIgnoreCase);
            d.Add(s, 0);
            Program.DecompForFlowChart(s, period, maxDepth, prune, 1d, 0, counter, sw, sw2, d, code);
            G.Writeln();

            GekkoFlowChart.Helper h = new GekkoFlowChart.Helper();
            h.flowArrows = sw;
            h.flowNodes = sw2;
            GekkoFlowChart.FruchtermanReingoldLayout.h = h;
            GekkoFlowChart.DataModel.instance = new GekkoFlowChart.DataModel(-12345, Globals.pruneDecomp, true);
            System.Windows.Window w = new GekkoFlowChart.MainWindow();
            w.Show();
        }

        /// <summary>
        /// Helper for flowcharts.
        /// </summary>
        /// <param name="s"></param>
        /// <returns></returns>
        public static string FlowInsertLabel(string s)
        {
            string rv = "";
            foreach (string s2 in GetVariableExplanationAugmented(s, null))
            {
                rv += s2 + G.NL;
            }
            return rv;
        }        

        /// <summary>
        /// Get name, label, source, unit, etc. for a timeseries (will also get lines from external varlist.dat file if present: these lines are shown right after name)
        /// </summary>
        /// <param name="varnameWithoutFreq"></param>
        /// <param name="printName"></param>
        /// <param name="printData"></param>
        /// <param name="tStart"></param>
        /// <param name="tEnd"></param>
        /// <returns></returns>
        public static List<string> GetVariableExplanation(string varnameWithoutFreq, string varnameMaybeWithFreq, bool printName, bool printData, GekkoTime tStart, GekkoTime tEnd, HtmlBrowserSettings htmlBrowserSettings)
        {
            bool danish = false;
            if (htmlBrowserSettings != null && htmlBrowserSettings.isDanish) danish = true;

            List<string> rv = new List<string>();
            IVariable iv = O.GetIVariableFromString(varnameMaybeWithFreq, O.ECreatePossibilities.NoneReturnNullButErrorForParentArraySeries, false);
            Series ts = null;
            if (iv != null) ts = iv as Series;
            if (printName)
            {
                rv.Add("Series: " + varnameMaybeWithFreq);
            }

            List<string> explanationsFromExternalFile = Program.GetVariableExplanationFromExternalFile(varnameWithoutFreq);
            foreach (string line in explanationsFromExternalFile)
            {
                if (line != "")
                {
                    rv.Add(line);
                }
            }

            try
            {

                if (ts.type == ESeriesType.Normal || ts.type == ESeriesType.Timeless || ts.type == ESeriesType.ArraySuper)
                {
                    string label_string = "";  //DGR asked to omit "Label: ", and it is typically pretty obvious anyway.
                    string source_string = "Source: "; if (danish) source_string = "Kilde: ";
                    string units_string = "Units: "; if (danish) units_string = "Enhed: ";  //DGR asked to change from Enheder --> Enhed.

                    if (!G.NullOrBlanks(ts.meta.label))
                    {
                        rv.Add(label_string + ts.meta.label);
                    }
                    else
                    {
                        if (ts.mmi != null && ts.mmi.parent != null && !G.NullOrBlanks(ts.mmi.parent.meta.label))
                        {
                            rv.Add(label_string + ts.mmi.parent.meta.label);
                        }
                    }

                    if (!G.NullOrBlanks(ts.meta.source))
                    {
                        if (htmlBrowserSettings != null && htmlBrowserSettings.show_source == false)
                        {
                            //do nothing
                        }
                        else
                        {
                            rv.Add(source_string + ts.meta.source);
                        }
                    }
                    else
                    {
                        if (htmlBrowserSettings != null && htmlBrowserSettings.show_source == false)
                        {
                            //do nothing
                        }
                        else
                        {
                            if (ts.mmi != null && ts.mmi.parent != null && !G.NullOrBlanks(ts.mmi.parent.meta.source))
                            {
                                rv.Add(source_string + ts.mmi.parent.meta.source);
                            }
                        }
                    }

                    if (!G.NullOrBlanks(ts.meta.units))
                    {
                        rv.Add(units_string + ts.meta.units);
                    }
                    else
                    {
                        if (ts.mmi != null && ts.mmi.parent != null && !G.NullOrBlanks(ts.mmi.parent.meta.units))
                        {
                            rv.Add(units_string + ts.mmi.parent.meta.units);
                        }
                    }
                }

                if (printData)
                {

                    rv.Add("-----------------------------------------------");
                    rv.Add("Period        value        %");

                    int counter = 0;

                    //must be able to handle TIME where freq does not match the series freq
                    foreach (GekkoTime gt in new GekkoTimeIterator(Program.ConvertFreqs(tStart, tEnd, ts.freq)))
                    {
                        counter++;
                        string sss = gt.ToString() + " ";  //see how it is done with a table here: #kj3ha3438u

                        double n1 = ts.GetDataSimple(gt);
                        double n0 = ts.GetDataSimple(gt.Add(-1));

                        double level1 = n1;
                        double pch1 = ((n1 / n0 - 1) * 100d);

                        if (n1 == n0) pch1 = 0d;

                        string levelFormatted;
                        string pchFormatted;
                        Program.ConvertToPrintFormat(level1, pch1, out levelFormatted, out pchFormatted);

                        sss += levelFormatted + " " + pchFormatted + " ";
                        rv.Add(sss);
                    }
                }
            }
            catch
            {
                //no need to fail on this
            }
            return rv;
        }

        /// <summary>
        /// Helper method.
        /// </summary>
        /// <param name="variableNameWithOrWithoutLag"></param>
        /// <returns></returns>
        public static List<string> GetVariableExplanationAugmented(string variableNameWithOrWithoutLag, HtmlBrowserSettings htmlBrowserSettings)
        {
            string ss = "";
            string var2 = G.ExtractOnlyVariableIgnoreLag(variableNameWithOrWithoutLag, Globals.leftParenthesisIndicator);
            List<string> ss2 = Program.GetVariableExplanation(G.Chop_RemoveFreq(var2), var2, true, false, GekkoTime.tNull, GekkoTime.tNull, htmlBrowserSettings);
            return ss2;
        }

        /// <summary>
        /// Decomp engine for Gekko flowcharts (these are defunct in Gekko 3.x).
        /// </summary>
        /// <param name="s"></param>
        /// <param name="year"></param>
        /// <param name="maxDepth"></param>
        /// <param name="prune"></param>
        /// <param name="factor"></param>
        /// <param name="depth"></param>
        /// <param name="counter"></param>
        /// <param name="sw"></param>
        /// <param name="sw2"></param>
        /// <param name="d"></param>
        /// <param name="code"></param>
        public static void DecompForFlowChart(string s, GekkoTime year, int maxDepth, double prune, double factor, int depth, Dictionary<string, int> counter, List<GekkoFlowChart.FlowArrow> sw, List<GekkoFlowChart.FlowNode> sw2, Dictionary<string, int> d, string code)
        {
            if (!Program.model.modelGekko.m2.endogenous.ContainsKey(s))
            {
                //do nothing
            }
            else
            {
                G.Writeln("FLOW = " + s + ", depth = " + depth + ", factor = " + factor);
                DecompOptions decompOptions = new DecompOptions();
                //decompOptions.vars = new List<string>() { s };
                decompOptions.t1 = year;
                decompOptions.t2 = year;
                decompOptions.localBanks = new LocalBanks();
                decompOptions.type = "sq";  //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
                decompOptions.variable = s;
                Table table = Program.DecompHelper2(decompOptions, code, false);
                //table.PrintCellsForDebug();
                //List<string> stable = table.Print();
                //foreach (string s in stable) G.Writeln(s);

                string dependent = table.Get(2, 1).CellText.TextData[0];

                for (int i = 3; i < table.GetRowMaxNumber() + 1; i++)
                {
                    string variable = table.Get(i, 1).CellText.TextData[0];
                    double effect = table.Get(i, 2).number;
                    double ff = factor * effect / 100d;
                    //G.Writeln(i + " " + table.Get(i, 1).CellText.TextData[0] + " " + table.Get(i, 2).number);
                    if (Math.Abs(effect) > prune * 100d)
                    {
                        if (!counter.ContainsKey(variable))
                        {
                            GekkoFlowChart.FlowNode fn = new GekkoFlowChart.FlowNode();
                            counter.Add(variable, counter.Count);
                            fn.varName = variable;
                            fn.counter = counter[variable];
                            fn.labelBig = FlowInsertLabel(variable);
                            if (Program.VariableTypeEndoExo(variable) == EEndoOrExo.Exo) fn.isExogenous = true;
                            else fn.isExogenous = false;
                            fn.isStartNode = false;
                            fn.id = counter[variable];
                            sw2.Add(fn);
                            //if (G.Equal(variable, "pm59"))
                            //    G.Writeln();
                        }
                        GekkoFlowChart.FlowArrow fa = new GekkoFlowChart.FlowArrow();
                        fa.varName1 = variable;
                        fa.varName2 = dependent;
                        fa.counter1 = counter[variable];
                        fa.counter2 = counter[dependent];
                        fa.weight = ff;

                        string aname = fa.varName1 + "," + fa.varName2;
                        if (d.ContainsKey(aname))
                        {
                            continue;  //no loops
                        }

                        d.Add(aname, 0);
                        sw.Add(fa);

                        if (depth < maxDepth && Math.Abs(ff) > prune)
                        {
                            if (d.ContainsKey(variable)) continue;  //do not do loops
                            DecompForFlowChart(variable, year, maxDepth, prune, ff, depth + 1, counter, sw, sw2, d, code);
                        }
                    }
                }
            }
        }

        /// <summary>
        /// Some unit tests.
        /// </summary>
        /// <returns></returns>
        public static bool TestKP2010Model()
        {
            Dictionary<string, CompareHelper> skip = new Dictionary<string, CompareHelper>(StringComparer.OrdinalIgnoreCase);
            skip.Add("RKQYFA", new CompareHelper(new GekkoTime((Program.options.freq), 2011, 1), new GekkoTime((Program.options.freq), 2011, 1)));
            skip.Add("RKQYFB", new CompareHelper(new GekkoTime((Program.options.freq), 2011, 1), new GekkoTime((Program.options.freq), 2011, 1)));
            skip.Add("RKQYFNB", new CompareHelper(new GekkoTime((Program.options.freq), 2011, 1), new GekkoTime((Program.options.freq), 2011, 1)));
            skip.Add("RKQYFNF", new CompareHelper(new GekkoTime((Program.options.freq), 2011, 1), new GekkoTime((Program.options.freq), 2011, 1)));
            skip.Add("RKQYFNK", new CompareHelper(new GekkoTime((Program.options.freq), 2011, 1), new GekkoTime((Program.options.freq), 2011, 1)));
            skip.Add("RKQYFNM", new CompareHelper(new GekkoTime((Program.options.freq), 2011, 1), new GekkoTime((Program.options.freq), 2011, 1)));
            skip.Add("RKQYFNN", new CompareHelper(new GekkoTime((Program.options.freq), 2011, 1), new GekkoTime((Program.options.freq), 2011, 1)));
            skip.Add("RKQYFNQ", new CompareHelper(new GekkoTime((Program.options.freq), 2011, 1), new GekkoTime((Program.options.freq), 2011, 1)));
            skip.Add("RKQYFNT", new CompareHelper(new GekkoTime((Program.options.freq), 2011, 1), new GekkoTime((Program.options.freq), 2011, 1)));
            skip.Add("RKQYFQH", new CompareHelper(new GekkoTime((Program.options.freq), 2011, 1), new GekkoTime((Program.options.freq), 2011, 1)));
            skip.Add("RKQYFQQ", new CompareHelper(new GekkoTime((Program.options.freq), 2011, 1), new GekkoTime((Program.options.freq), 2011, 1)));
            skip.Add("RKQYFQT", new CompareHelper(new GekkoTime((Program.options.freq), 2011, 1), new GekkoTime((Program.options.freq), 2011, 1)));
            //btydd is due to _G__D code, see patchZvar option (probably Gekko error)
            skip.Add("BTYDD", new CompareHelper(new GekkoTime((Program.options.freq), 2020, 1), new GekkoTime((Program.options.freq), 2020, 1)));
            //bven/bveq is strange: seems pcim error not consistent with equation
            skip.Add("bven", new CompareHelper(new GekkoTime((Program.options.freq), 2012, 1), new GekkoTime((Program.options.freq), 2020, 1)));
            skip.Add("bveq", new CompareHelper(new GekkoTime((Program.options.freq), 2012, 1), new GekkoTime((Program.options.freq), 2020, 1)));
            //ecpuxh difference probably because of data inaccuracy (tsd-file)
            skip.Add("ecpuxh", new CompareHelper(new GekkoTime((Program.options.freq), 2013, 1), new GekkoTime((Program.options.freq), 2016, 1)));
            skip.Add("efcpuxh", new CompareHelper(new GekkoTime((Program.options.freq), 2013, 1), new GekkoTime((Program.options.freq), 2013, 1)));
            //pivo is 0 in Gekko and missing in PCIM. Probably due to changed relation in Gekko. Variable not meaningful anyway.
            skip.Add("pivo", new CompareHelper(new GekkoTime((Program.options.freq), 2009, 1), new GekkoTime((Program.options.freq), 2020, 1)));
            //Tiskia is a bit strange: why is there a JR<>0 in PCIM, but not in Gekko.
            skip.Add("tiskia", new CompareHelper(new GekkoTime((Program.options.freq), 2012, 1), new GekkoTime((Program.options.freq), 2020, 1)));
            //uagap and ulgap: differences seem ok
            skip.Add("uagap", new CompareHelper(new GekkoTime((Program.options.freq), 2013, 1), new GekkoTime((Program.options.freq), 2015, 1)));
            skip.Add("ulgap", new CompareHelper(new GekkoTime((Program.options.freq), 2014, 1), new GekkoTime((Program.options.freq), 2015, 1)));

            int t1 = 2005;  //base databank starts in 2000
            //int t2 = 2100;
            int t2 = 2020;  //to avoid too many errors
            //these are set a bit loose to avoid too many errors

            double absCrit = 0.001d;
            double relCritSmart = 0.01d;  //1%
            double relCritNormal = 0.01d;  //1%

            List<string> both = new List<string>();
            Databank work = Program.databanks.GetFirst();
            Databank base2 = Program.databanks.GetRef();
            foreach (string tsString in work.storage.Keys)
            {
                Series tsGrund = base2.GetIVariable(tsString + "!a") as Series;
                if (tsGrund != null)
                {
                    both.Add(tsString);
                }
            }
            both.Sort(StringComparer.InvariantCulture);
            int counter = 0;
            foreach (string s in both)
            {
                //these eliminate a lot of variables
                if (s.ToLower().StartsWith("j")) continue;
                if (s.ToLower().StartsWith("z")) continue;

                Series tsWork = work.GetIVariable(s + "!a") as Series;
                Series tsBase = base2.GetIVariable(s + "!a") as Series;
                bool ok2 = true;

                double maxVariance = 0d;
                foreach (GekkoTime t in new GekkoTimeIterator(new GekkoTime((Program.options.freq), t1, 1), new GekkoTime((Program.options.freq), t2, 1)))
                {
                    double variance = CalculateHistoricalVarianceForVariable(tsBase, t);
                    if (variance > maxVariance) maxVariance = variance;
                }

                foreach (GekkoTime t in new GekkoTimeIterator(new GekkoTime((Program.options.freq), t1, 1), new GekkoTime((Program.options.freq), t2, 1)))
                {

                    double valueWork = tsWork.GetDataSimple(t);
                    double valueBase = tsBase.GetDataSimple(t);
                    double relative = double.NaN;
                    bool isOk = SolveGauss777.CheckRelativeDifferenceSmart(1d, false, maxVariance, absCrit, relCritSmart, valueWork, valueBase, out relative);

                    if (!isOk)
                    {
                        if (Math.Abs(valueWork / valueBase - 1) < relCritNormal) isOk = true;  //overrules any problems if "real" % is small enough
                    }

                    if (!isOk)
                    {
                        if (skip.ContainsKey(s))
                        {
                            CompareHelper ch = skip[s];
                            if (t.LargerThanOrEqual(ch.t1) && t.SmallerThanOrEqual(ch.t2))
                            {
                                isOk = true;
                            }
                        }
                    }
                    if (!isOk)
                    {
                        G.Writeln("jul05 full check: variable " + s + " deviated in " + t.ToString() + " (variance is " + maxVariance + ")");
                        ok2 = false;
                        return false;  //can comment this out, in order to get full list of problems
                    }
                }
                if (ok2 == false) counter++;
            }
            return true;
        }

        /// <summary>
        /// Internal helper method that can create/produce a large number of linear models, where the parameters and variables
        /// are determined randomly. See \Gekko\regres\Models\Random\, where such models reside. It is used to check solvers,
        /// among other things that prologue, simulrecursive, epilogue etc. work as intended.
        /// </summary>
        public static void Randommodel()
        {

            int endoexo = 0;  //0 means none, 2 means 2 goals
            bool gaussMode = true;
            double factor = 2d; if (gaussMode) factor = factor / 2d;
            int nn = 50;
            Random r = new Random(11111);  //11111 used for regressions, with nn = 1000 and factor = 1d;

            for (int ii = 0; ii < nn; ii++)
            {
                if (true)
                {
                    int n = 20;
                    int p1 = 10;
                    int p2 = 10;
                    double[,] e = new double[n, n];
                    double[,] x = new double[n, 2];

                    for (int j1 = 0; j1 < n; j1++)
                    {
                        for (int j2 = 0; j2 < n; j2++)
                        {
                            if (r.Next(0, 100) < p1) e[j1, j2] = (double)r.Next(1, 999) / 1000d;
                        }
                        if (r.Next(0, 100) < p2) x[j1, 0] = (double)r.Next(1, 999) / 1000d;
                        if (r.Next(0, 100) < p2) x[j1, 1] = (double)r.Next(1, 999) / 1000d;
                    }

                    for (int j1 = 0; j1 < n; j1++)
                    {
                        double sum = 0d;
                        for (int j2 = 0; j2 < n; j2++)
                        {
                            sum += e[j1, j2];
                        }
                        if (sum == 0)
                        {
                            //row sum = 0
                            if (j1 > 0) e[j1, j1 - 1] = 0.55555d;
                            else e[j1, n - 1] = 0.55555d;
                        }
                    }

                    int i = r.Next(0, n - 1);
                    for (int j2 = 0; j2 < n; j2++)
                    {
                        e[i, j2] = 0;
                    }
                    x[i, 1] = 0.66666;  //inducing an equation Ei = 0.66666*X1, to start a prologue chain

                    double sum0 = 0d;
                    double sum1 = 0d;
                    for (int j1 = 0; j1 < n; j1++)
                    {
                        sum0 += x[j1, 0];
                        sum1 += x[j1, 1];
                    }

                    if (sum0 == 0)
                    {
                        x[r.Next(0, n - 1), 0] = 0.44444;
                    }
                    if (sum1 == 0)
                    {
                        x[r.Next(0, n - 1), 1] = 0.44444;
                    }

                    string ss = "";
                    for (int j1 = 0; j1 < n; j1++)
                    {
                        ss += "FRML _GJRD e" + j1 + " = 0." + r.Next(1, 999) + " + ";
                        for (int j2 = 0; j2 < n; j2++)
                        {
                            if (e[j1, j2] != 0) ss += e[j1, j2] * factor + "*e" + j2 + " + ";
                        }
                        if (x[j1, 0] != 0) ss += x[j1, 0] + "*x" + 0 + " + ";
                        if (x[j1, 1] != 0) ss += x[j1, 1] + "*x" + 1 + " + ";

                        if (r.Next(0, 100) < 10) ss += "0.001*e" + r.Next(0, n - 1) + "(-1) + ";

                        if (ss.EndsWith("+ ")) ss = ss.Substring(0, ss.Length - 2);
                        ss = ss + ";\n";
                    }

                    string vv = ss;
                    for (int j1 = 0; j1 < n; j1++)
                    {
                        vv = vv.Replace("FRML _GJRD e" + j1 + " = ", "abs(e" + j1 + " - (");
                    }
                    vv = vv.Replace(";", ")) + ");
                    if (vv.EndsWith("+ \n"))
                    {
                        vv = vv.Substring(0, vv.Length - 3);
                        vv += ";\n";
                    }
                    vv = "GENR sum = " + vv;
                    string vvv = "";
                    if (endoexo == 1) vvv = "EXO e0; ENDO x0;\n";
                    if (endoexo == 2) vvv = "EXO e0 e1; ENDO x0 x1;\n";
                    vv = "RESET; MODEL m" + ii + ";\n READ<tsd> m;\n " + vvv + "SIM 2002 2100;\n " + vv + "\n PRT<2002 2005> sum e0 e1 e2;\n";

                    //ok that this is not G.GekkoStreamWriter()
                    StreamWriter sw = new StreamWriter(Program.options.folder_working + "m" + ii + ".frm");
                    sw.Write(ss);
                    sw.Flush();
                    sw.Close();

                    //ok that this is not G.GekkoStreamWriter()
                    StreamWriter sw2 = new StreamWriter(Program.options.folder_working + "m" + ii + "." + Globals.defaultCommandFileExtension);
                    if (endoexo > 0) sw2 = new StreamWriter(Program.options.folder_working + "n" + ii + "." + Globals.defaultCommandFileExtension);
                    sw2.Write(vv);
                    sw2.Flush();
                    sw2.Close();

                    G.Writeln("Created random model " + ii);

                }
            }
        }

        /// <summary>
        /// Helper method for Laspeyres chain index method, cf. Laspeyres() method.
        /// </summary>
        /// <param name="tStart0"></param>
        /// <param name="tEnd"></param>
        /// <param name="varsX"></param>
        /// <returns></returns>
        private static double[,] PutTimeseriesIntoArrayPossiblyNegative(GekkoTime tStart0, GekkoTime tEnd, List<string> varsX)
        {
            int obs = GekkoTime.Observations(tStart0, tEnd);
            double[,] aX = new double[varsX.Count, obs];
            int id = -1;
            foreach (string var in varsX)
            {
                id++;
                int length = -12345;
                int index1 = -12345;
                int index2 = -12345;
                double[] x = null;
                string var2 = var;
                bool negative = false;
                if (var.StartsWith("-"))
                {
                    var2 = var2.Substring(1);
                    negative = true;
                }

                Series ts = O.GetIVariableFromString(G.Chop_AddFreq(var2, EFreq.A), O.ECreatePossibilities.NoneReportError, true) as Series;

                if (ts == null)
                {
                    new Error("Variable '" + var2 + "' does not exist");
                    //throw new GekkoException();
                }
                else
                {
                    //Hmmm, Annual?? What about quarters/months??
                    x = ts.GetDataSequenceBEWARE(out index1, out index2, tStart0, tEnd);  //implicit ", false" ending this method, no setting of start/end period of timeseries
                    length = index2 - index1 + 1;
                    if (negative)
                    {
                        double[] xNew = new double[x.Length];
                        for (int i = 0; i < x.Length; i++)
                        {
                            //NaN and +/- Infinity pass ok through this
                            xNew[i] = -x[i];
                        }
                        x = xNew;  //points to this temp array: otherwise real timeseries data will be overridden
                    }
                }
                Buffer.BlockCopy(x, 8 * index1, aX, 8 * id * obs, 8 * length);  //TODO: what if out of bounds regarding x???
                //I guess after this loop is done, the whole of a[,] will be filled with data or NaN.
                //It should not be possible that there is a 0 left originating from "double[,] a = new double[vars, obs];"
            }
            return aX;
        }

        /// <summary>
        /// Matrix inversion
        /// </summary>
        /// <param name="lu"></param>
        /// <param name="indx"></param>
        private static void LUDecompose(ref double[,] lu, ref int[] indx)
        {
            //Running a 1000x1000 dense matrix with code below takes about 2800 ms
            //Compare this with the 1200 ms described here: http://mathnetnumerics.codeplex.com/discussions/360326
            //See also the 1800 ms here: http://www.meta-numerics.net/Pages/Performance.aspx
            //Random r = new Random();
            //int n2 = 1000;
            //lu = new double[n2, n2];
            //indx = new int[n2];
            //for (int ii = 0; ii < n2; ii++)
            //{
            //    for (int jj = 0; jj < n2; jj++)
            //    {
            //        lu[ii, jj] = r.NextDouble();
            //    }
            //}
            //DateTime t0 = DateTime.Now;


            int i, imax = 0, j, k, n = lu.GetLength(0);
            double big, temp1, temp2;
            double[] vv = new double[n];
            //preChecks
            if (lu.GetLength(0) != lu.GetLength(1) || lu.GetLength(0) != indx.Length)
                throw new Exception("matrix dimension problem only use square matrices");
            //for each row find the absolute value of the greatest cell and store in vv
            for (i = 0; i < n; i++)
            {
                big = 0.0;
                for (j = 0; j < n; j++)
                    if ((temp1 = Math.Abs(lu[i, j])) > big) big = temp1;
                if (big == 0.0)
                {
                    int endoNumber = (int)Program.model.modelGekko.m2.simulFeedback[i];
                    EquationHelper eh = Program.model.modelGekko.equations[endoNumber];

                    using (Error e = new Error())
                    {
                        e.MainAdd("Trying to invert a singular matrix. This is because the equations are");
                        e.MainAdd("somehow undetermined, for instance because of an equation 'X = X', ");
                        e.MainAdd("or an equation 'Y = Z', where Z is exogenous, and the variable");
                        e.MainAdd("Y has been exogenized (by means of the EXO command).");
                        e.MainAdd("The problem arises in the following equation: ");
                        e.MainNewLineTight();
                        e.MainAdd("  " + eh.equationText);
                        e.MainNewLineTight();
                        e.MainAdd("Please correct the equation or the goals / means(ENDO / EXO variables).");
                    }
                }

                vv[i] = 1.0 / big;//calculate scaling and save
            }
            //k is for colums start with the left look for the columns under the diagonal for the biggest value want to move the largest over diagonal
            for (k = 0; k < n; k++)//find the largest pivot element
            {
                big = 0.0;
                for (i = k; i < n; i++)
                {
                    temp1 = vv[i] * Math.Abs(lu[i, k]);
                    if (temp1 > big)
                    {
                        big = temp1;
                        imax = i;
                    }
                }

                if (k != imax)//do we need a row change
                {
                    for (j = 0; j < n; j++)// counter for the colums
                    {
                        temp1 = lu[imax, j];// change the rows
                        lu[imax, j] = lu[k, j];
                        lu[k, j] = temp1;
                    }
                    vv[imax] = vv[k];
                    //G.Writeln2("Swapped row " + k + " and row " + imax);
                }
                indx[k] = imax;

                for (i = k + 1; i < n; i++)
                {
                    temp1 = lu[i, k] /= lu[k, k];//divide pilot element
                    if (temp1 != 0d)  //TT changed: changes time from 4 secs on 813x813 to 1.75 secs
                    {
                        for (j = k + 1; j < n; j++)
                        {
                            //lu[i, j] -= temp * lu[k, j];  //<---- original before TT changed, the change improves 1.75 secs to 1.57 secs.
                            temp2 = lu[k, j];
                            if (temp2 != 0d)
                            {
                                lu[i, j] -= temp1 * temp2;
                            }
                        }
                    }
                }
            }
        }

        /// <summary>
        /// Helper for InvertMatrixLu().
        /// </summary>
        /// <param name="b"></param>
        /// <param name="x"></param>
        /// <param name="indx"></param>
        /// <param name="lu"></param>
        private static void InvertMatrixSolve(ref double[] b, ref double[] x, int[] indx, double[,] lu)
        {
            if (b.Length != lu.GetLength(0) || x.Length != lu.GetLength(0))
                throw new Exception("vector dimension problem");

            int n = lu.GetLength(0);
            int i, ii = 0, ip, j;
            double sum = 0;
            for (i = 0; i < n; i++) x[i] = b[i];
            for (i = 0; i < n; i++)
            {
                ip = indx[i];
                sum = x[ip];
                x[ip] = x[i];
                if (ii != 0)
                    for (j = ii - 1; j < i; j++) sum -= lu[i, j] * x[j];
                else if (sum != 0.0)
                    ii = i + 1;
                x[i] = sum;
            }
            for (i = n - 1; i >= 0; i--)
            {
                sum = x[i];
                for (j = i + 1; j < n; j++) sum -= lu[i, j] * x[j];
                x[i] = sum / lu[i, i];
            }
        }

        /// <summary>
        /// Replace some characters to use for xml format.
        /// </summary>
        /// <param name="text"></param>
        /// <returns></returns>
        public static string SpecialXmlChars(string text)
        {
            text = text.Replace("&", "&amp;");
            text = text.Replace("<", "&lt;");
            text = text.Replace(">", "&gt;");
            text = text.Replace("<", ""); //hmmmm what does this do? never mind.
            text = text.Replace("\"", "&quot;");
            text = text.Replace("'", "&#39;");
            return text;
        }

        /// <summary>
        /// Print a Gekko table object, either as simple text, or as a html page.
        /// </summary>
        /// <param name="table"></param>
        /// <param name="printDateEtc"></param>
        /// <param name="printType"></param>
        /// <returns></returns>
        public static string PrintTableHelper(Table table, bool printDateEtc, string printType)
        {
            Globals.lastPrtOrMulprtTable = table;
            CrossThreadStuff.CopyButtonEnabled(true);
            //This method does NOT alter the table as a side-effect (because of ObjectCopier.Clone).
            bool printRawCode = false;

            //TODO: table types are a bit messy: clean this up at some point
            if (G.Equal(printType, "html_main"))
            {
                printType = "html";
                printRawCode = true;
            }
            if (printType == null && G.Equal(Program.options.table_type, "html"))
            {
                printType = "html";  //overrides txt, so "TABLE s1" or calling from menu will -> html table
            }

            List<string> ss = table.Print(printType);

            string fullFileNameAndPath = Globals.localTempFilesLocation + "\\" + "table.html";

            StampTypes type = StampTypes.Normal;
            if (G.Equal(Globals.tableOption, "m")) type = StampTypes.Multiplier;
            else if (G.Equal(Globals.tableOption, Globals.operator_r)) type = StampTypes.Base;
            List<string> lines = Program.GetDatabankInfo(type);
            if (Program.options.table_stamp)
            {
                string printed = "Table printed: " + Program.GetDateTimePretty(DateTime.Now);
                lines.Add(printed);
            }

            string pTag = "<p CLASS=\"gfsize gfont\" style=\"color: silver; margin: 2px;\">";

            if (printType == "html")
            {
                //---------------------
                //         HTML
                //---------------------
                if (printRawCode)
                {
                    int widthRemember = Program.options.print_width;
                    Program.options.print_width = int.MaxValue;
                    try
                    {
                        G.Write(pTag);
                        for (int i = 0; i < lines.Count; i++)
                        {
                            G.Write(lines[i]);
                            if (i < lines.Count - 1) G.Writeln("<br>");
                        }
                        G.Writeln("</p>");
                        foreach (string line in ss) G.Writeln(line);
                    }
                    catch (Exception e)
                    {
                        new Error("Table (in html format) could not be written");
                        //throw new GekkoException();
                    }
                    finally
                    {
                        //resetting, also if there is an error
                        Program.options.print_width = widthRemember;
                    }
                }
                else
                {
                    string s1 = Globals.htmlFileStart1 + Program.GetHtmlHeaderCssStyles() + Globals.htmlFileStart2;
                    string s2 = Globals.htmlFileEnd;

                    using (FileStream fs = Program.WaitForFileStream(fullFileNameAndPath, null, Program.GekkoFileReadOrWrite.Write))
                    using (StreamWriter sw = G.GekkoStreamWriter(fs))
                    {
                        sw.Write(s1);

                        string s5 = null;

                        s5 += pTag + "<a href=\"#\"   onclick=\"document.getElementById('hiddenText').style.display='block'; return false;\">Transform options</a> " + "</p>";

                        s5 += "<div style=\"display: none;\" id=\"hiddenText\">" + G.NL;
                        string s = "style = \"margin:0; padding:0; opacity : 0.5;\"";

                        s5 += "<table CLASS=\"gfsize gfont\"  style=\"color:gray\" >";
                        s5 += " <tr>";
                        s5 += "   <td></td>";
                        s5 += "   <td>First &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </td>";
                        s5 += "   <td>Reference &nbsp; &nbsp; &nbsp; &nbsp; </td>";
                        s5 += "   <td>Multiplier</td>";
                        s5 += " </tr>";
                        s5 += " <tr>";
                        s5 += "   <td>Levels &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  </td>";
                        s5 += "   <td><input title=\"Levels as they are in first databank\" CLASS=\"gfsize gfont\" type=\"radio\" name=\"table\" " + s + " onclick=\"window.location='table.html#n" + "';\"/>n</td>";
                        s5 += "   <td><input title=\"Levels as they are in reference databank\"  CLASS=\"gfsize gfont\" type=\"radio\" name=\"table\" " + s + " onclick=\"window.location='table.html#rn" + "';\"/>r&thinsp;n</td>";
                        s5 += "   <td></td>";
                        s5 += " </tr>";
                        s5 += " <tr>";
                        s5 += "   <td>Abs. diff.</td>";
                        s5 += "   <td><input title=\"Absolute time-change (difference) in first databank\" CLASS=\"gfsize gfont\" type=\"radio\" name=\"table\" " + s + " onclick=\"window.location='table.html#d" + "';\"/>d</td>";
                        s5 += "   <td><input title=\"Absolute time-change (difference) in reference databank\" CLASS=\"gfsize gfont\" type=\"radio\" name=\"table\" " + s + " onclick=\"window.location='table.html#rd" + "';\"/>r&thinsp;d</td>";
                        s5 += "   <td><input title=\"Absolute multiplier difference\" CLASS=\"gfsize gfont\" type=\"radio\" name=\"table\" " + s + " onclick=\"window.location='table.html#m" + "';\"/>m</td>";
                        s5 += " </tr>";
                        s5 += " <tr>";
                        s5 += "   <td>Rel. diff.</td>";
                        s5 += "   <td><input title=\"Percentage time growth rate in first databank\" CLASS=\"gfsize gfont\" type=\"radio\" name=\"table\" " + s + " onclick=\"window.location='table.html#p" + "';\"/>p</td>";
                        s5 += "   <td><input title=\"Percentage time growth rate in reference databank\" CLASS=\"gfsize gfont\" type=\"radio\" name=\"table\" " + s + " onclick=\"window.location='table.html#rp" + "';\"/>r&thinsp;p</td>";
                        s5 += "   <td><input title=\"Percentage multiplier difference\" CLASS=\"gfsize gfont\" type=\"radio\" name=\"table\" " + s + " onclick=\"window.location='table.html#q" + "';\"/>q</td>";
                        s5 += " </tr>";
                        s5 += " <tr>";
                        s5 += " </tr>";
                        s5 += " </table>";


                        s5 += "</div>" + G.NL;

                        if (Program.options.interface_table_operators) sw.Write(s5);
                        sw.Write(pTag);
                        for (int i = 0; i < lines.Count; i++)
                        {
                            sw.Write(lines[i]);
                            if (i < lines.Count - 1) sw.WriteLine("<br>");
                        }
                        sw.WriteLine("</p>");

                        foreach (string line in ss) sw.WriteLine(line);
                        sw.Write(s2);
                        sw.Close();
                    }

                    if (!G.IsUnitTesting())
                    {
                        CrossThreadStuff.SetTab("menu", true);
                        Gui.gui.webBrowser.Url = new Uri("file:///" + Globals.localTempFilesLocation + "\\table.html");
                        CrossThreadStuff.SetTab("menu", true);
                    }
                }
            }
            else
            {
                //---------------------
                //         TXT
                //---------------------
                int widthRemember = Program.options.print_width;
                Program.options.print_width = int.MaxValue;
                G.Writeln();
                try
                {
                    if (printDateEtc)
                    {
                        foreach (string s in lines) G.Writeln(s);
                        //G.Writeln(printed);
                    }
                    foreach (string s in ss) G.Writeln(s);
                    G.Writeln();
                }
                catch (Exception e)
                {
                    new Error("Table (in txt format) could not be written");
                    //throw new GekkoException();
                }
                finally
                {
                    //resetting, also if there is an error
                    Program.options.print_width = widthRemember;
                }
            }

            return printType;
        }

        /// <summary>
        /// Splits result from parser on (optional) '*' and '¤', so that filename and linenumber are extracted.
        /// For instance: file1.gcm*23¤5 becomes 'file1.gcm' and 28.
        /// </summary>
        /// <param name="originalFileName"></param>
        /// <param name="lineNumber"></param>
        /// <param name="s"></param>
        public static void SplitCommandBeingExecuted(out string originalFileName, out int lineNumber, string s)
        {
            string[] split = s.Split(Globals.parserErrorSeparator);
            originalFileName = split[0];

            string lineNumber2 = split[1];
            lineNumber = int.Parse(lineNumber2);  //1-based it seems

            CorrectLineNumber(ref originalFileName, ref lineNumber);
        }

        public static void CorrectLineNumber(ref string originalFileName, ref int lineNumber)
        {
            if (originalFileName == null) return;
            string[] split2 = originalFileName.Split(Globals.parserErrorSeparator2);
            if (split2.Length == 2)
            {
                originalFileName = split2[0];
                int lineNumber3 = 1;
                int.TryParse(split2[1], out lineNumber3);  //we are sure that this parses
                lineNumber += lineNumber3 - 1;  //we deduct one here
            }
        }

        /// <summary>
        /// The "old" DECOMP method. Will be obsolete.
        /// </summary>
        /// <param name="o"></param>
        public static void Decomp(O.Decomp1 o)
        {
            DecompOptions decompOptions = new DecompOptions();
            decompOptions.t1 = o.t1;
            decompOptions.t2 = o.t2;
            decompOptions.expressionOld = o.label;
            decompOptions.expression = o.expression;
            //decompOptions.smplForFunc = o.smplForFunc;
            decompOptions.prtOptionLower = o.opt_prtcode.ToLower();
            decompOptions.name = o.name;
            Decomp(decompOptions);
        }

        /// <summary>
        /// The "old" DECOMP method, will be obsolete.
        /// </summary>
        /// <param name="decompOptions"></param>
        public static void Decomp(DecompOptions decompOptions)
        {
            Thread thread = new Thread(new ParameterizedThreadStart(DecompThreadFunction));
            thread.SetApartmentState(ApartmentState.STA);
            thread.CurrentCulture = CultureInfo.InvariantCulture;
            //thread.CurrentCulture = new System.Globalization.CultureInfo("en-US");  //gets . instead of , in doubles
            thread.Start(decompOptions);
            if (true)
            {
                //Also see #9237532567
                //This stuff makes sure we wait for the window to open, before we move on with the code.
                for (int i = 0; i < 6000; i++)  //up to 60 s, then we move on anyway
                {
                    System.Threading.Thread.Sleep(10);  //0.01s
                    if (decompOptions.numberOfRecalcs > 0)
                    {
                        break;
                    }
                }
            }
        }

        /// <summary>
        /// Thread for "old" DECOMP, will be obsolete.
        /// </summary>
        /// <param name="o"></param>
        // Thread for decomp window
        public static void DecompThreadFunction(Object o)
        {
            DecompOptions decompOptions = (DecompOptions)o;
            //decompOptions.isCalledFromDecompWindow = false;

            Window1 w = null;
            if (true)
            {
                w = new Window1(decompOptions);
                Globals.windowsDecomp.Add(w);
            }

            string name = null;
            if (decompOptions.name != null)
            {
                List name_list = decompOptions.name as List;
                List<string> name_list2 = O.Restrict(name_list, false, false, false, true);
                if (name_list2.Count != 1)
                {
                    new Error("List of names not accepted in DECOMP");
                    //throw new GekkoException();
                }
                name = name_list2[0];
            }
            else
            {
                if (decompOptions.variable != null) name = decompOptions.variable;
            }

            if (name != null)
            {
                string name2 = G.Chop_GetName(name);
                List<string> name3 = G.Chop_GetIndex(name);

                decompOptions.variable = name2;
                decompOptions.variable_subelement = name3;
                decompOptions.expressionOld = null;
                decompOptions.expression = null;

                if (Program.model.modelGams != null)
                {
                    if (Program.model.modelGams == null)
                    {
                        new Error("DECOMP: A GAMS model is not loaded, cf. the MODEL command.");
                        //throw new GekkoException();
                    }
                    if (Program.model.modelGams.equationsByVarname != null)
                    {
                        ModelGamsEquation found = GamsModel.DecompEvalGams(null, decompOptions.variable, Program.model);
                        decompOptions.expression = found.expressions[0];
                        decompOptions.expressionOld = found.lhs + " = " + found.rhs;
                    }
                }
                else
                {

                    if (G.GetModelSourceType() != EModelType.Gekko)
                    {
                        new Error("DECOMP: A Gekko model is not loaded, cf. the MODEL command.");
                        //throw new GekkoException();
                    }

                    EquationHelper found = DecompEval(decompOptions.variable);
                    decompOptions.expression = Globals.expressions[0];
                    decompOptions.expressionOld = found.equationText;
                }
            }

            if (decompOptions.name == null)
            {
                w.Title = "Decompose expression";
            }
            else
            {
                w.Title = "Decompose " + decompOptions.variable + "";
            }
            w.Tag = decompOptions;

            w.SetRadioButtons();
            w.RecalcCellsWithNewType();
            decompOptions.numberOfRecalcs++;  //signal for Decomp() method to move on

            if (w.isClosing)  //if something goes wrong, .isClosing will be true
            {
                //The line below removes the window from the global list of active windows.
                //Without this line, this half-dead window will mess up automatic closing of windows (Window -> Close -> Close all...)
                if (Globals.windowsDecomp.Count > 0) Globals.windowsDecomp.RemoveAt(Globals.windowsDecomp.Count - 1); }
            else
            {
                if (decompOptions.isNew)
                {
                    //do not show it yet
                }
                else
                {
                    if (!G.IsUnitTesting())
                    {
                        w.ShowDialog();
                        w.Close();  //probably superfluous
                        w = null;  //probably superfluous
                    }
                }
            }
        }

        /// <summary>
        /// Helper method for "old" DECOMP. Will be obsolete.
        /// </summary>
        /// <param name="variable"></param>
        /// <returns></returns>
        public static EquationHelper DecompEval(string variable)
        {
            EquationHelper found = Program.FindEquationByMeansOfVariableName(variable);
            if (found == null)
            {
                new Error("DECOMP: Could not find variable '" + variable + "' as left-hand side in model");
                //throw new GekkoException();
            }
            string[] ss = found.equationText.Split('=');

            string rhs = ss[1].Trim();

            string lhsText = ss[0].Trim();
            string[] ss0 = lhsText.Split(new char[] { ' ' }, StringSplitOptions.RemoveEmptyEntries);
            if (!G.Equal(ss0[0], "frml"))
            {
                new Error("Model equation '" + variable + "': Equation does not start with 'frml'");
                //throw new GekkoException();
            }

            string lhs = null;
            for (int i = 2; i < ss0.Length; i++)
            {
                lhs += ss0[i];
            }
            lhs = lhs.Trim();  //trimmed with no blanks                                                              

            if (rhs.EndsWith("$")) rhs = rhs.Substring(0, rhs.Length - 1) + ";";  //only replace last $, not other $

            rhs = rhs.Trim();
            if (rhs.EndsWith(";")) rhs = rhs.Substring(0, rhs.Length - 1);

            for (int i = 1; i < 20; i++)
            {
                rhs = rhs.Replace("(-" + i + ")", "[-" + i + "]");
                rhs = rhs.Replace("(+" + i + ")", "[+" + i + "]");
            }

            string type = "none";  //dlog, dif, diff, log
            if (lhs.StartsWith("dlog(", StringComparison.OrdinalIgnoreCase))
            {
                type = "dlog";
                rhs = found.lhs + "[-1] * exp(" + rhs + ")";
            }
            else if (lhs.StartsWith("dif(", StringComparison.OrdinalIgnoreCase))
            {
                type = "dif";
                rhs = found.lhs + "[-1] + (" + rhs + ")";
            }
            else if (lhs.StartsWith("diff(", StringComparison.OrdinalIgnoreCase))
            {
                type = "diff";
                rhs = found.lhs + "[-1] + (" + rhs + ")";
            }
            else if (lhs.StartsWith("diff(", StringComparison.OrdinalIgnoreCase))
            {
                type = "log";
                rhs = "exp(" + rhs + ")";
            }

            if (found.equationCodeJ != "" && found.equationCodeJ != "_" && found.equationCodeJ != "__")
            {
                if (found.equationCodeJadditive)
                {
                    rhs = rhs + " + " + found.Jname;
                }
                else if (found.equationCodeJmultiplicative)
                {
                    rhs = "(" + rhs + ") * (1 + " + found.Jname + ")";
                }
                else
                {
                    //should not happen
                    new Error("Problem with J-factors in equation " + found.lhs);
                    //throw new GekkoException();
                }
            }

            if (found.equationCodeD != "" && found.equationCodeD != "_")
            {
                rhs = "(1 - " + found.Dname + ") * (" + rhs + ") + " + found.Dname + " * " + found.Zname;
            }

            //rhs = found.lhs + " = " + rhs + ";";
            rhs = rhs + ";";

            try
            {
                if (Globals.printAST)
                {
                    G.Writeln2("-------------- EVAL ---------------");
                    G.Writeln2("EVAL " + G.ReplaceGlueSymbols(rhs));
                    G.Writeln2("-----------------------------------");
                }

                CallEval(null, rhs);
            }
            catch (Exception e)
            {

            }

            return found;
        }


        /// <summary>
        /// Helper method for "old" DECOMP. Will become obsolete.
        /// </summary>
        /// <param name="lhs"></param>
        /// <param name="rhs"></param>
        /// <param name="simple"></param>
        /// <returns></returns>
        public static string EquationLhsRhs(string lhs, string rhs, bool simple)
        {
            //This method is just so that we keep the two ways of decomposing together,
            //that is, calling an equation like DECOMP eq1, or DECOMP y = x1 + x2.
            //The former has simple = true, the latter simple = false.
            //if (simple) return "-(" + lhs + ") + " + rhs;
            //else return "O.Add(" + Globals.smpl + ", O.Negate(" + Globals.smpl + ", " + lhs + "), " + rhs + ")";
            if (simple)
            {
                return lhs + " - (" + rhs + ")";
            }
            else
            {
                return "O.Add(" + Globals.smpl + ", " + lhs + ", O.Negate(" + Globals.smpl + ", (" + rhs + ")))";
            }
        }

        /// <summary>
        /// Internal helper method for SIM testing.
        /// </summary>
        /// <param name="list"></param>
        /// <param name="start"></param>
        /// <param name="end"></param>
        /// <returns></returns>
        public static List<string> TestSim(List<string> list, int start, int end)
        {
            List<string> res = new List<string>();
            CompilerResults cr;
            CreateTestSimDll(out cr, list, start, end);
            Object[] args2 = new Object[1];
            args2[0] = res;
            cr.CompiledAssembly.GetType("Gekko.TranslatedCode").InvokeMember("TestSim", BindingFlags.InvokeMethod, null, null, args2);
            return res;
        }

        /// <summary>
        /// Helper for the "old" DECOMP method. Will become obsolete.
        /// </summary>
        /// <param name="decompOptions"></param>
        /// <param name="transformationCodeAugmented"></param>
        /// <param name="useLocalData"></param>
        /// <returns></returns>
        public static Table DecompHelper2(DecompOptions decompOptions, string transformationCodeAugmented, bool useLocalData)
        {
            GekkoTime tStart = decompOptions.t1;
            GekkoTime tEnd = decompOptions.t2;

            bool isRaw = false;
            if (transformationCodeAugmented.ToLower().StartsWith("x")) isRaw = true;

            string type = decompOptions.type;
            //GekkoParserTimePeriod tp = decompOptions.tp;
            //List<string> vars = decompOptions.vars;
            LocalBanks localBanks = decompOptions.localBanks;
            string modelHash = decompOptions.modelHash;

            Table table = new Table();  //!!BEWARE: this object is also used for flowcharts, so if the layout is changed, change it in flowcharts also

            decompOptions.decompTablesFormat.isPercentageType = false;
            if (transformationCodeAugmented.StartsWith("s") || transformationCodeAugmented.EndsWith("p") || transformationCodeAugmented.EndsWith("dp") || transformationCodeAugmented.EndsWith("q") || transformationCodeAugmented.EndsWith("mp"))
            {
                decompOptions.decompTablesFormat.isPercentageType = true;
                table.Set(1, 1, "% ");
            }

            string var2 = decompOptions.variable;

            if (true)
            {

                string leftSideVariable = G.GetUpperLowerCase(var2);

                if (G.GetModelSourceType() != EModelType.Gekko)
                {
                    new Error("DECOMP: There does not seem to be any Gekko model defined");
                    //throw new GekkoException();
                }

                if (decompOptions.expressionOld == null && !Program.model.modelGekko.fromVariableToEquationNumber.ContainsKey(leftSideVariable + Globals.lagIndicator + "0"))
                {
                    new Error("DECOMP: variable '" + leftSideVariable + "' does not exist as left-hand side variable in model");
                    //throw new GekkoException();
                }

                Dictionary<string, string> precedents = null;
                EquationHelper eh = null;
                if (decompOptions.expressionOld != null)
                {
                    precedents = decompOptions.precedents[0];
                }
                else
                {
                    int eqNumber = (int)Program.model.modelGekko.fromVariableToEquationNumber[leftSideVariable + Globals.lagIndicator + "0"];
                    eh = Program.model.modelGekko.equations[eqNumber];
                    precedents = eh.precedentsWithLagIndicator;
                }

                CompilerResults cr;
                CreateDecompDll(leftSideVariable, decompOptions.expressionOld != null, eh, out cr);

                List<Dictionary<string, string>> precedents2 = new List<Dictionary<string, string>>();
                precedents2.Add(precedents);
                CheckVariableExistence(null, precedents2, false, false, false, false);  //checking in work bank, also ok for time decomp
                List<string> p2 = new List<string>();
                p2.AddRange(precedents.Keys);
                p2.Sort(StringComparer.InvariantCulture);

                //Beware: best to keep this constant for different years to deal with timeless variables
                double delta = Globals.jacobiDeltaProbe;  //can just as well be the same stepsize as used in newton algorithm

                Dictionary<string, List<DecompHelper>> decompHelpers = new Dictionary<string, List<DecompHelper>>();

                List<Databank> banks = new List<Databank>();

                Databank work = Program.databanks.GetFirst();
                Databank base2 = Program.databanks.GetRef();
                banks.Add(work);
                banks.Add(base2);
                List<string> allVariables = GetAllVariablesForDecompose(leftSideVariable, p2);

                int counter = -1;
                foreach (Databank bank in banks)
                {
                    counter++;
                    Databank databank = bank;

                    foreach (GekkoTime t in new GekkoTimeIterator(tStart.Add(-2), tEnd))  //-2 to deal with dp option
                    {
                        List<DecompHelper> decompContributions = new List<DecompHelper>();

                        double y0 = double.NaN;
                        y0 = RunDecompEquation(cr, t, databank);

                        double yDatabank = double.NaN;
                        if (decompOptions.expressionOld != null)
                        {
                            yDatabank = y0;
                        }
                        else
                        {
                            yDatabank = (databank.GetIVariable(leftSideVariable + Globals.freqIndicator + G.ConvertFreq(Program.options.freq)) as Series).GetDataSimple(t);
                        }

                        foreach (string variableWithLag in p2)
                        {
                            string variable = null;
                            int lag = -12345;
                            G.ExtractVariableAndLag(variableWithLag, out variable, out lag);

                            double before = (databank.GetIVariable(variable + Globals.freqIndicator + G.ConvertFreq(Program.options.freq)) as Series).GetDataSimple(t.Add(lag));
                            double after = before + delta;
                            (databank.GetIVariable(variable + Globals.freqIndicator + G.ConvertFreq(Program.options.freq)) as Series).SetData(t.Add(lag), after);
                            double y1 = double.NaN;
                            try
                            {
                                y1 = RunDecompEquation(cr, t, databank);
                            }
                            finally
                            {
                                //to make 100% sure it is always reset
                                (databank.GetIVariable(variable + Globals.freqIndicator + G.ConvertFreq(Program.options.freq)) as Series).SetData(t.Add(lag), before);
                            }

                            DecompHelper dh = new DecompHelper();
                            dh.variableWithLag = variableWithLag;
                            dh.y0 = y0;
                            dh.y1 = y1;
                            dh.x0 = before;
                            dh.x1 = after;
                            dh.slope = (dh.y1 - dh.y0) / (dh.x1 - dh.x0);
                            dh.z = yDatabank;
                            decompContributions.Add(dh);
                        }

                        //double truth = y1 - y0;
                        //double alpha = truth / sum;

                        //factors.Add(t + ": explanation = " + G.pchFormat(alpha * 100, 10) + "%");
                        //G.Writeln(t + "  " + "sum " + sum + "   truth " + truth + "  alpha " + alpha);
                        string key = "FIRST";
                        if (counter == 1) key = "REF";

                        decompHelpers.Add(key + "," + t.ToString(), decompContributions);  //key for instance "Work,2010"
                    }
                }

                if (decompOptions.decompTablesFormat.showErrors)
                {

                    if (isRaw)
                    {
                        table.Set(3, 1, Globals.decompText2a);
                        table.Set(4, 1, Globals.decompText1a);
                        table.Get(3, 1).backgroundColor = "LightYellow";
                        table.Get(4, 1).backgroundColor = "LightRed";
                    }
                    else
                    {
                        table.Set(3, 1, Globals.decompText2);
                        table.Set(4, 1, Globals.decompText1);
                        table.Get(3, 1).backgroundColor = "LightRed";
                        table.Get(4, 1).backgroundColor = "LightRed";
                    }
                }

                int o = 0;
                if (decompOptions.decompTablesFormat.showErrors) o = 2;

                int j = -1;
                foreach (GekkoTime t in new GekkoTimeIterator(tStart, tEnd))
                {
                    j++;
                    if (j == 0)
                    {
                        List<DecompHelper> dhList2 = decompHelpers["FIRST," + t.ToString()];
                        int i = -1;
                        foreach (DecompHelper dh in dhList2)
                        {
                            i++;
                            table.Set(i + 3 + o, 1, G.FormatVariableAndLag(dh.variableWithLag)); //What should format be?
                        }
                        if (decompOptions.expressionOld != null)
                        {
                            table.Set(2, 1, Globals.decompText0);
                        }
                        else
                        {
                            table.Set(2, 1, G.PrettifyTimeseriesHash(leftSideVariable, true, false));
                        }

                    }
                    table.SetDate(1, j + 2, t.ToString());

                    List<DecompHelper> data = null; decompHelpers.TryGetValue("FIRST," + t.ToString(), out data);
                    List<DecompHelper> data_lag = null; decompHelpers.TryGetValue("FIRST," + t.Add(-1).ToString(), out data_lag);
                    List<DecompHelper> data_lag2 = null; decompHelpers.TryGetValue("FIRST," + t.Add(-2).ToString(), out data_lag2);
                    List<DecompHelper> data_base = null; decompHelpers.TryGetValue("REF," + t.ToString(), out data_base);
                    List<DecompHelper> data_base_lag = null; decompHelpers.TryGetValue("REF," + t.Add(-1).ToString(), out data_base_lag);
                    List<DecompHelper> data_base_lag2 = null; decompHelpers.TryGetValue("REF," + t.Add(-2).ToString(), out data_base_lag2);

                    int offset_i = 2;
                    int offset_j = 2;

                    int decimals = 0;
                    if (decompOptions.decompTablesFormat.isPercentageType) decimals = decompOptions.decompTablesFormat.decimalsPch;
                    else decimals = decompOptions.decompTablesFormat.decimalsLevel;

                    string format = "f16." + decimals.ToString();

                    if (isRaw)
                    {
                        double line0 = double.NaN;
                        double line1 = double.NaN;
                        double line2 = double.NaN;
                        switch (transformationCodeAugmented)
                        {
                            case "xmn":
                                break;
                            case "xm":
                                {
                                    line0 = data[0].z - data_base[0].z;
                                    table.SetNumber(0 + offset_i, j + offset_j, line0, format);  //What should format be?
                                    if (decompOptions.decompTablesFormat.showErrors)
                                    {
                                        line2 = data[0].y0 - data_base[0].y0;
                                    }
                                    for (int i = 0; i < data.Count; i++)
                                    {
                                        table.SetNumber(i + offset_i + 1 + o, j + offset_j, data[i].x0 - data_base[i].x0, format);  //What should format be?
                                    }
                                }
                                break;
                            case "xq":
                                {
                                    line0 = (data[0].z / data_base[0].z - 1d) * 100d;
                                    table.SetNumber(0 + offset_i, j + offset_j, line0, format);  //What should format be?
                                    if (decompOptions.decompTablesFormat.showErrors)
                                    {
                                        line2 = (data[0].y0 / data_base[0].y0 - 1d) * 100d;
                                    }
                                    for (int i = 0; i < data.Count; i++)
                                    {
                                        table.SetNumber(i + offset_i + 1 + o, j + offset_j, (data[i].x0 / data_base[i].x0 - 1d) * 100d, format);  //What should format be?
                                    }
                                }
                                break;
                            case "xsm":
                                new Error("DECOMP option <" + transformationCodeAugmented + "> does not make (much) sense: did you mean <ms>?", false);
                                break;
                            // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                            case "":
                            case "xn":
                                {
                                    line0 = data[0].z;
                                    table.SetNumber(0 + offset_i, j + offset_j, line0, format);  //What should format be?
                                    if (decompOptions.decompTablesFormat.showErrors)
                                    {
                                        line2 = data[0].y0;
                                    }
                                    for (int i = 0; i < data.Count; i++)
                                    {
                                        table.SetNumber(i + offset_i + 1 + o, j + offset_j, data[i].x0, format);  //What should format be?
                                    }
                                }
                                break;
                            case "xb":
                            case "xbn":
                                {
                                    line0 = data_base[0].z;
                                    table.SetNumber(0 + offset_i, j + offset_j, line0, format);  //What should format be?
                                    if (decompOptions.decompTablesFormat.showErrors)
                                    {
                                        line2 = data_base[0].y0;
                                    }
                                    for (int i = 0; i < data.Count; i++)
                                    {
                                        table.SetNumber(i + offset_i + 1 + o, j + offset_j, data_base[i].x0, format);  //What should format be?
                                    }
                                }
                                break;
                            case "xd":
                                {
                                    line0 = data[0].z - data_lag[0].z;
                                    table.SetNumber(0 + offset_i, j + offset_j, line0, format);  //What should format be?
                                    if (decompOptions.decompTablesFormat.showErrors)
                                    {
                                        line2 = data[0].y0 - data_lag[0].y0;
                                    }
                                    for (int i = 0; i < data.Count; i++)
                                    {
                                        table.SetNumber(i + offset_i + 1 + o, j + offset_j, data[i].x0 - data_lag[i].x0, format);  //What should format be?
                                    }
                                }
                                break;
                            case "xbd":
                                {
                                    line0 = data_base[0].z - data_base_lag[0].z;
                                    table.SetNumber(0 + offset_i, j + offset_j, line0, format);  //What should format be?
                                    if (decompOptions.decompTablesFormat.showErrors)
                                    {
                                        line2 = data_base[0].y0 - data_base_lag[0].y0;
                                    }
                                    for (int i = 0; i < data.Count; i++)
                                    {
                                        table.SetNumber(i + offset_i + 1 + o, j + offset_j, data_base[i].x0 - data_base_lag[i].x0, format);  //What should format be?
                                    }
                                }
                                break;
                            case "xp":
                                {
                                    line0 = (data[0].z / data_lag[0].z - 1d) * 100d;
                                    table.SetNumber(0 + offset_i, j + offset_j, line0, format);  //What should format be?
                                    if (decompOptions.decompTablesFormat.showErrors)
                                    {
                                        line2 = (data[0].y0 / data_lag[0].y0 - 1d) * 100d;
                                    }
                                    for (int i = 0; i < data.Count; i++)
                                    {
                                        table.SetNumber(i + offset_i + 1 + o, j + offset_j, (data[i].x0 / data_lag[i].x0 - 1d) * 100d, format);  //What should format be?
                                    }
                                }
                                break;
                            case "xbp":
                                {
                                    line0 = (data_base[0].z / data_base_lag[0].z - 1d) * 100d;
                                    table.SetNumber(0 + offset_i, j + offset_j, line0, format);  //What should format be?
                                    if (decompOptions.decompTablesFormat.showErrors)
                                    {
                                        line2 = (data_base[0].y0 / data_base_lag[0].y0 - 1d) * 100d;
                                    }
                                    for (int i = 0; i < data.Count; i++)
                                    {
                                        table.SetNumber(i + offset_i + 1 + o, j + offset_j, (data_base[i].x0 / data_base_lag[i].x0 - 1d) * 100d, format);  //What should format be?
                                    }
                                }
                                break;
                            case "xdp":
                                {
                                    line0 = (data[0].z / data_lag[0].z - 1d) * 100d - (data_lag[0].z / data_lag2[0].z - 1d) * 100d;
                                    table.SetNumber(0 + offset_i, j + offset_j, line0, format);  //What should format be?
                                    if (decompOptions.decompTablesFormat.showErrors)
                                    {
                                        line2 = (data[0].y0 / data_lag[0].y0 - 1d) * 100d - (data_lag[0].y0 / data_lag2[0].y0 - 1d) * 100d;
                                    }
                                    for (int i = 0; i < data.Count; i++)
                                    {
                                        table.SetNumber(i + offset_i + 1 + o, j + offset_j, (data[i].x0 / data_lag[i].x0 - 1d) * 100d - (data_lag[i].x0 / data_lag2[i].x0 - 1d) * 100d, format);  //What should format be?
                                    }
                                }
                                break;
                            case "xbdp":
                                {
                                    line0 = (data_base[0].z / data_base_lag[0].z - 1d) * 100d - (data_base_lag[0].z / data_base_lag2[0].z - 1d) * 100d;
                                    table.SetNumber(0 + offset_i, j + offset_j, line0, format);  //What should format be?
                                    if (decompOptions.decompTablesFormat.showErrors)
                                    {
                                        line2 = (data_base[0].y0 / data_base_lag[0].y0 - 1d) * 100d - (data_base_lag[0].y0 / data_base_lag2[0].y0 - 1d) * 100d;
                                    }
                                    for (int i = 0; i < data.Count; i++)
                                    {
                                        table.SetNumber(i + offset_i + 1 + o, j + offset_j, (data_base[i].x0 / data_base_lag[i].x0 - 1d) * 100d - (data_base_lag[i].x0 / data_base_lag2[i].x0 - 1d) * 100d, format);  //What should format be?
                                    }
                                }
                                break;
                            case "xmp":
                                {
                                    line0 = (data[0].z / data_lag[0].z - 1d) * 100d - (data_base[0].z / data_base_lag[0].z - 1d) * 100d;
                                    table.SetNumber(0 + offset_i, j + offset_j, line0, format);  //What should format be?
                                    if (decompOptions.decompTablesFormat.showErrors)
                                    {
                                        line2 = (data[0].y0 / data_lag[0].y0 - 1d) * 100d - (data_base[0].y0 / data_base_lag[0].y0 - 1d) * 100d;
                                    }
                                    for (int i = 0; i < data.Count; i++)
                                    {
                                        table.SetNumber(i + offset_i + 1 + o, j + offset_j, (data[i].x0 / data_lag[i].x0 - 1d) * 100d - (data_base[i].x0 / data_base_lag[i].x0 - 1d) * 100d, format);  //What should format be?
                                    }
                                }
                                break;
                            case "xsd":
                                new Error("DECOMP option <" + transformationCodeAugmented + "> does not make (much) sense: did you mean <s>?", false);
                                break;


                                //======================================================================================

                        }  //end of switch

                        if (decompOptions.decompTablesFormat.showErrors)
                        {
                            line1 = line0 - line2;
                            table.SetNumber(2 + offset_i, j + offset_j, line1, format);
                            table.SetNumber(1 + offset_i, j + offset_j, line2, format);
                            table.Get(1 + offset_i, j + offset_j).backgroundColor = "LightYellow";
                            table.Get(2 + offset_i, j + offset_j).backgroundColor = "LightRed";
                        }

                    }  //if raw type (starts with x)
                    else
                    {
                        string code1 = "";
                        string code2 = transformationCodeAugmented;
                        if (transformationCodeAugmented.ToLower().StartsWith("s"))
                        {
                            code1 = "s";
                            code2 = transformationCodeAugmented.Substring(1);
                        }

                        double[] tableTemp = new double[data.Count + 1 + o];
                        double sum = double.NaN;
                        double truth = double.NaN;
                        double dataError = double.NaN;
                        double nonlinError = double.NaN;

                        if (true)
                        {
                            List<DecompHelper> data_CUR = null;
                            List<DecompHelper> data_ALT = null;
                            List<DecompHelper> dataLag_CUR = null;
                            List<DecompHelper> dataLag_ALT = null;
                            if (G.Equal(code2, "d") || G.Equal(code2, "p"))
                            {
                                data_CUR = data;
                                data_ALT = data_lag;
                            }
                            else if (G.Equal(code2, "bd") || G.Equal(code2, "bp"))
                            {
                                data_CUR = data_base;
                                data_ALT = data_base_lag;
                            }
                            else if (G.Equal(code2, "m") || G.Equal(code2, "q"))
                            {
                                data_CUR = data;
                                data_ALT = data_base;
                            }
                            else if (G.Equal(code2, "dp"))
                            {
                                data_CUR = data;
                                data_ALT = data_lag;
                                dataLag_CUR = data_lag;
                                dataLag_ALT = data_lag2;
                            }
                            else if (G.Equal(code2, "bdp"))
                            {
                                data_CUR = data_base;
                                data_ALT = data_base_lag;
                                dataLag_CUR = data_base_lag;
                                dataLag_ALT = data_base_lag2;
                            }
                            else if (G.Equal(code2, "mp"))
                            {
                                data_CUR = data;
                                data_ALT = data_lag;
                                dataLag_CUR = data_base;
                                dataLag_ALT = data_base_lag;
                            }
                            else
                            {
                                new Error("Internal error regarding decomposition");
                                //throw new GekkoException();
                            }
                            bool isRelative = false; //will be divided with lagged or baseline level
                            if (G.Equal(code2, "p") || G.Equal(code2, "bp") || G.Equal(code2, "dp") || G.Equal(code2, "bdp") || G.Equal(code2, "q") || G.Equal(code2, "mp"))
                            {
                                isRelative = true;
                            }
                            if (G.Equal(code2, "dp") || G.Equal(code2, "bdp") || G.Equal(code2, "mp"))
                            {
                                double sumNolag = double.NaN;
                                double sumLag = double.NaN;
                                double truthNolag = double.NaN;
                                double truthLag = double.NaN;
                                double dataErrorNolag = double.NaN;
                                double dataErrorLag = double.NaN;
                                double nonlinErrorNolag = double.NaN;
                                double nonlinErrorLag = double.NaN;
                                double[] tableTempNolag = new double[data.Count + 1 + o];
                                double[] tableTempLag = new double[data.Count + 1 + o];
                                DecompHelper3(ref sumNolag, ref truthNolag, ref dataErrorNolag, ref nonlinErrorNolag, o, tableTempNolag, data_CUR, data_ALT, isRelative);
                                DecompHelper3(ref sumLag, ref truthLag, ref dataErrorLag, ref nonlinErrorLag, o, tableTempLag, dataLag_CUR, dataLag_ALT, isRelative);
                                sum = sumNolag - sumLag;
                                truth = truthNolag - truthLag;
                                dataError = dataErrorNolag - dataErrorLag;
                                nonlinError = nonlinErrorNolag - nonlinErrorLag;
                                for (int i = 0; i < tableTemp.Length; i++)
                                {
                                    tableTemp[i] = tableTempNolag[i] - tableTempLag[i];
                                }
                            }
                            else
                            {
                                DecompHelper3(ref sum, ref truth, ref dataError, ref nonlinError, o, tableTemp, data_CUR, data_ALT, isRelative);
                            }
                        }

                        tableTemp[0] = truth;

                        if (decompOptions.decompTablesFormat.showErrors)
                        {
                            tableTemp[1] = nonlinError;
                            tableTemp[2] = dataError;
                        }
                        else
                        {
                            for (int i = 1; i < data.Count + 1; i++)
                            {
                                tableTemp[i] *= truth / sum;
                            }
                        }

                        if (G.Equal(code1, "s"))
                        {
                            double tableTemp0 = tableTemp[0];
                            for (int i = 0; i < data.Count + 1 + o; i++)
                            {
                                tableTemp[i] = tableTemp[i] / tableTemp0 * 100d;
                            }
                        }

                        for (int i = 0; i < data.Count + 1 + o; i++)
                        {
                            table.SetNumber(i + offset_i, j + offset_j, tableTemp[i], format);  //What should format be?
                        }

                        if (decompOptions.decompTablesFormat.showErrors)
                        {
                            table.Get(1 + offset_i, j + offset_j).backgroundColor = "LightRed";
                            table.Get(2 + offset_i, j + offset_j).backgroundColor = "LightRed";
                        }
                    }
                }
            }
            return table;
        }

        /// <summary>
        /// Helper method for the "old" DECOMP. Will become obsolete.
        /// </summary>
        /// <param name="sum"></param>
        /// <param name="truth"></param>
        /// <param name="dataError"></param>
        /// <param name="nonlinError"></param>
        /// <param name="o"></param>
        /// <param name="tableTemp"></param>
        /// <param name="data"></param>
        /// <param name="data_ALT"></param>
        /// <param name="isRelative"></param>
        private static void DecompHelper3(ref double sum, ref double truth, ref double dataError, ref double nonlinError, int o, double[] tableTemp, List<DecompHelper> data, List<DecompHelper> data_ALT, bool isRelative)
        {
            sum = 0d;
            for (int i = 0; i < data.Count; i++)
            {
                double val = data_ALT[i].slope * (data[i].x0 - data_ALT[i].x0);
                sum += val;
                tableTemp[i + 1 + o] = val;
            }
            double y = data[0].y0;  //y0 is the same in all of the items, so item 0 is chosen arbitrarily
            double z = data[0].z;
            double y_ALT = data_ALT[0].y0;
            double z_ALT = data_ALT[0].z;
            truth = z - z_ALT;
            dataError = (z - z_ALT) - (y - y_ALT);
            nonlinError = (y - y_ALT) - sum;
            if (isRelative)
            {
                double factor = 100d / data_ALT[0].z;
                for (int i = 0; i < data.Count; i++)
                {
                    tableTemp[i + 1 + o] *= factor;
                }
                truth *= factor;
                dataError *= factor;
                nonlinError *= factor;
                sum *= factor;
            }
        }

        /// <summary>
        /// Helper method for the "old" DECOMP. Will become obsolete.
        /// </summary>
        /// <param name="leftSideVariable"></param>
        /// <param name="p2"></param>
        /// <returns></returns>
        private static List<string> GetAllVariablesForDecompose(string leftSideVariable, List<string> p2)
        {
            List<string> allVariables = new List<string>();

            Dictionary<string, string> rightSideVariables = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
            foreach (string variableWithLag in p2)
            {
                if (variableWithLag.Contains(Globals.lagIndicator + Globals.lagIndicator))
                {
                    string[] split = variableWithLag.Split(new string[] { Globals.lagIndicator + Globals.lagIndicator }, StringSplitOptions.None);
                    if (split.Length != 2)
                    {
                        new Error("internal error related to fixed periods");
                        //throw new GekkoException();
                    }
                    //rightSideVariables.Add(split[0], "");
                    new Error("fixed periods (" + split[0] + Globals.leftParenthesisIndicator + split[1] + Globals.rightParenthesisIndicator + ") cannot be used when decomposing");
                    //throw new GekkoException();
                }
                else
                {
                    string variable = null;
                    int lag = -12345;
                    G.ExtractVariableAndLag(variableWithLag, out variable, out lag);
                    if (!rightSideVariables.ContainsKey(variable))
                    {
                        rightSideVariables.Add(variable, "");
                    }
                }
            }
            allVariables.AddRange(rightSideVariables.Keys);
            if (!rightSideVariables.ContainsKey(leftSideVariable))
            {
                allVariables.Add(leftSideVariable);
            }
            return allVariables;
        }

        /// <summary>
        /// Helper method for the "old" DECOMP. Will become obsolete.
        /// </summary>
        /// <param name="varName"></param>
        /// <param name="isExpression"></param>
        /// <param name="eh"></param>
        /// <param name="cr"></param>
        private static void CreateDecompDll(string varName, bool isExpression, EquationHelper eh, out CompilerResults cr)
        {
            string code = "";
            if (isExpression)
            {
                code = varName;
            }
            else
            {
                code = eh.csCodeRhsLongVersion;
            }

            StringBuilder s2 = new StringBuilder();
            s2.AppendLine("using System;");
            s2.AppendLine("using System.Collections.Generic;");
            s2.AppendLine("using System.Text;");
            s2.AppendLine("namespace Gekko");
            s2.AppendLine("{");
            s2.AppendLine("    public class TranslatedCode");
            s2.AppendLine("    {");
            s2.AppendLine("public static void DecompEquation(double[] result, GekkoTime t, Databank databank)");
            s2.AppendLine("{");
            s2.Append("double data = ");
            s2.AppendLine(code + ";");
            s2.AppendLine("result[0] = data;");
            s2.AppendLine("return;");
            s2.AppendLine("}");  //method DecompEquation()
            s2.AppendLine("}");  //class TranslatedCode
            s2.AppendLine("}");  //namespace Gekko
            s2.Replace("`", Globals.QT);
            CompilerParameters compilerParams = new CompilerParameters();
            compilerParams = new CompilerParameters();
            compilerParams.CompilerOptions = Program.GetCompilerOptions();
            compilerParams.GenerateInMemory = true;
            compilerParams.IncludeDebugInformation = false;
            compilerParams.ReferencedAssemblies.Add("system.dll");
            compilerParams.ReferencedAssemblies.Add(Application.ExecutablePath);
            compilerParams.GenerateExecutable = false;
            cr = Globals.iCodeCompiler.CompileAssemblyFromSource(compilerParams, s2.ToString());
            if (cr.Errors.HasErrors)
            {
                throw new GekkoException();
            }
        }

        /// <summary>
        /// Helper for the PREDICT command, compiling some dynamic C# code.
        /// </summary>
        /// <param name="code"></param>
        public static void CreatePredictActions(string code)
        {
            StringBuilder s2 = new StringBuilder();
            s2.AppendLine("using System;");
            s2.AppendLine("using System.Collections.Generic;");
            s2.AppendLine("using System.Text;");
            s2.AppendLine("namespace Gekko");
            s2.AppendLine("{");
            s2.AppendLine("    public class TranslatedCode");
            s2.AppendLine("    {");
            s2.AppendLine("public static void PredictActions()");
            s2.AppendLine("{");
            s2.AppendLine(code + ";");
            s2.AppendLine("}");  //method Predict()
            s2.AppendLine("}");  //class TranslatedCode
            s2.AppendLine("}");  //namespace Gekko
            s2.Replace("`", Globals.QT);
            CompilerParameters compilerParams = new CompilerParameters();
            compilerParams = new CompilerParameters();
            compilerParams.CompilerOptions = Program.GetCompilerOptions();
            compilerParams.GenerateInMemory = true;
            compilerParams.IncludeDebugInformation = false;
            compilerParams.ReferencedAssemblies.Add("system.dll");
            Gekko.Parser.Frm.ParserFrmCompileAST.ReferencedAssembliesGekko(compilerParams);
            compilerParams.GenerateExecutable = false;
            string code2 = s2.ToString();
            CompilerResults cr = Globals.iCodeCompiler.CompileAssemblyFromSource(compilerParams, code2);
            if (cr.Errors.HasErrors)
            {
                throw new GekkoException();
            }

            Object[] args = new Object[0];
            cr.CompiledAssembly.GetType("Gekko.TranslatedCode").InvokeMember("PredictActions", BindingFlags.InvokeMethod, null, null, args);
        }

        /// <summary>
        /// Helper for internal test of SIM command.
        /// </summary>
        /// <param name="cr"></param>
        /// <param name="list"></param>
        /// <param name="start"></param>
        /// <param name="end"></param>
        private static void CreateTestSimDll(out CompilerResults cr, List<string> list, int start, int end)
        {
            //This is a method only used for debugging purposes
            StringBuilder s2 = new StringBuilder();
            s2.AppendLine("using System;");
            s2.AppendLine("using System.Collections.Generic;");
            s2.AppendLine("using System.Text;");
            s2.AppendLine("namespace Gekko");
            s2.AppendLine("{");
            s2.AppendLine("    public class TranslatedCode");
            s2.AppendLine("    {");
            s2.AppendLine("public static void TestSim(List<string>res)");
            s2.AppendLine("{");
            s2.AppendLine("GekkoTime tStart, tEnd; tStart = Globals.globalPeriodStart; tEnd = Globals.globalPeriodEnd;");
            s2.AppendLine("foreach (GekkoTime t in new GekkoTimeIterator( tStart, tEnd)) {");
            s2.AppendLine("double hs;");
            s2.AppendLine("double vs;");
            s2.AppendLine("double difMax = 0d;");
            s2.AppendLine("double pchMax = 0d;");
            s2.AppendLine("double dif;");
            s2.AppendLine("double pch;");
            s2.AppendLine("string difMaxName = ``;");
            s2.AppendLine("string pchMaxName = ``;");
            s2.AppendLine("double difMaxVs = 0d;");
            s2.AppendLine("double pchMaxVs = 0d;");
            s2.AppendLine("double difMaxHs = 0d;");
            s2.AppendLine("double pchMaxHs = 0d;");
            s2.AppendLine("Databank databank = Program.databanks.GetDatabank(`Work`);");

            int count = -1;

            foreach (string s in list)
            {
                count++;
                if (count < start) continue;
                if (count > end) break;
                int eqNumber = (int)Program.model.modelGekko.fromVariableToEquationNumber[s + Globals.lagIndicator + "0"];
                EquationHelper eh = Program.model.modelGekko.equations[eqNumber];
                string code = eh.csCodeRhsLongVersion;
                s2.Append("hs = ");
                s2.AppendLine(code + ";");
                s2.AppendLine("vs = databank.GetVariable(`" + s + "`).GetDataNonLight(t);");
                s2.AppendLine("dif = Math.Abs(hs - vs);");
                s2.AppendLine("pch = Math.Abs((hs / vs - 1) * 100);");
                s2.AppendLine("if (dif > difMax) {difMaxVs=vs; difMaxHs=hs; difMax = dif; difMaxName = `" + s + "`; }");
                s2.AppendLine("if (pch > pchMax) {pchMaxVs=vs; pchMaxHs=hs; pchMax = pch; pchMaxName = `" + s + "`; }");
                //s2.AppendLine("G.Writeln(`XXXXXX: ` + t.ToString() + `: ` + dif + ` ` + pch);");
                s2.AppendLine();
            }
            s2.AppendLine("G.Writeln(`Abs: ` + t.ToString() + `: ` + difMaxName + ` = ` + difMax);");

            s2.AppendLine("res.Add(`abs¤` + t.ToString() + `¤` + difMaxName + `¤` + difMax + `¤` + difMaxVs + `¤` + difMaxHs);");

            s2.AppendLine("G.Writeln(`Rel: ` + t.ToString() + `: ` + pchMaxName + ` = ` + pchMax);");

            s2.AppendLine("res.Add(`rel¤` + t.ToString() + `¤` + pchMaxName + `¤` + pchMax + `¤` + pchMaxVs + `¤` + pchMaxHs);");

            s2.AppendLine("}");  //end time loop
            s2.AppendLine("}");  //method DecompEquation()
            s2.AppendLine("}");  //class TranslatedCode
            s2.AppendLine("}");  //namespace Gekko
            s2.Replace("`", Globals.QT);
            CompilerParameters compilerParams = new CompilerParameters();
            compilerParams = new CompilerParameters();
            compilerParams.CompilerOptions = Program.GetCompilerOptions();
            compilerParams.GenerateInMemory = false;
            compilerParams.IncludeDebugInformation = false;
            compilerParams.ReferencedAssemblies.Add("system.dll");
            compilerParams.ReferencedAssemblies.Add(Application.ExecutablePath);
            compilerParams.GenerateExecutable = false;
            cr = Globals.iCodeCompiler.CompileAssemblyFromSource(compilerParams, s2.ToString());
            if (cr.Errors.HasErrors)
            {
                throw new GekkoException();
            }
        }

        /// <summary>
        /// Helper for "old" DECOMP command. Will be obsolete.
        /// </summary>
        /// <param name="cr"></param>
        /// <param name="t"></param>
        /// <param name="db"></param>
        /// <returns></returns>
        private static double RunDecompEquation(CompilerResults cr, GekkoTime t, Databank db)
        {
            Object[] args2 = new Object[3];
            args2[0] = new double[1];
            args2[1] = t;
            args2[2] = db;
            cr.CompiledAssembly.GetType("Gekko.TranslatedCode").InvokeMember("DecompEquation", BindingFlags.InvokeMethod, null, null, args2);
            double val0 = ((double[])(args2[0]))[0];
            return val0;
        }

        /// <summary>
        /// For Gekko model files (.frm), takes care of normal equations (FRML), variable list, and runbefore$ or runafter$ code.
        /// </summary>
        /// <param name="input"></param>
        /// <param name="modelCommentsHelper"></param>
        /// <returns></returns>
        public static List<string> HandleModelFiles(List<string> input, ModelCommentsHelper modelCommentsHelper)
        {
            List<string> output = new List<string>();
            List<string> outputVarlist = new List<string>();
            List<string> outputRunBefore = new List<string>();
            List<string> outputRunAfter = new List<string>();

            bool outputVarlistFlag = false;
            bool outputRunBeforeFlag = false;
            bool outputRunAfterFlag = false;
            foreach (string line in input)
            {
                string line2 = line.Trim();
                if (line2.ToLower().StartsWith("varlist$") || line2.ToLower().StartsWith("varlist;"))
                {
                    outputVarlistFlag = true;
                    outputRunBeforeFlag = false;
                    outputRunAfterFlag = false;
                }
                else if (line2.ToLower().StartsWith("runbefore$") || line2.ToLower().StartsWith("runbefore;"))
                {
                    outputVarlistFlag = false;
                    outputRunBeforeFlag = true;
                    outputRunAfterFlag = false;
                }
                else if (line2.ToLower().StartsWith("runafter$") || line2.ToLower().StartsWith("runafter;"))
                {
                    outputVarlistFlag = false;
                    outputRunBeforeFlag = false;
                    outputRunAfterFlag = true;
                }
                if (outputVarlistFlag) outputVarlist.Add(line);
                else if (outputRunBeforeFlag) outputRunBefore.Add(line);
                else if (outputRunAfterFlag) outputRunAfter.Add(line);
                else output.Add(line);
            }

            StringBuilder temp1 = new StringBuilder();
            foreach (string line in outputVarlist) temp1.AppendLine(line);
            modelCommentsHelper.cutout_varlist = temp1.ToString();

            StringBuilder temp2 = new StringBuilder();
            foreach (string line in outputRunBefore) temp2.AppendLine(line);
            modelCommentsHelper.cutout_runbefore = temp2.ToString();

            StringBuilder temp3 = new StringBuilder();
            foreach (string line in outputRunAfter) temp3.AppendLine(line);
            modelCommentsHelper.cutout_runafter = temp3.ToString();

            return output;
        }

        /// <summary>
        /// "Parent" method for another method of the same name.
        /// </summary>
        /// <param name="input"></param>
        /// <param name="modelCommentsHelper"></param>
        /// <returns></returns>
        public static string HandleModelFiles(string input, ModelCommentsHelper modelCommentsHelper)
        {
            //As a side-effect, Program.model.modelGekko.varlist is filled with stuff after VARLIST$
            List<string> lines = Stringlist.ExtractLinesFromText(input);
            List<string> linesNew = HandleModelFiles(lines, modelCommentsHelper);  //after this, there is no varlist stuff in linesNew
            GetModelHashAndInfo(linesNew, modelCommentsHelper); //does some rough removing of comments, empty lines etc.
            Globals.modelFileLines = linesNew;
            StringBuilder sb = new StringBuilder();
            foreach (string line in linesNew)
            {
                sb.AppendLine(line);
            }
            string s2 = sb.ToString();
            return s2;
        }

        /// <summary>
        /// Get info fields from a model, and compute "true" hash of the model equations. This hash is both for signing of the model (cf. 
        /// the SIGN command), and for internal use when storing dynamic C# code corresponding to a model in a local cache (so that it
        /// can avoid parsing next time it is read with MODEL command).
        /// </summary>
        /// <param name="linesNew"></param>
        /// <param name="modelCommentsHelper"></param>
        private static void GetModelHashAndInfo(List<string> linesNew, ModelCommentsHelper modelCommentsHelper)
        {
            StringBuilder sb = new StringBuilder();
            StringBuilder comment = new StringBuilder();
            bool problem = false;
            for (int i = 0; i < 2; i++)
            {
                sb = new StringBuilder();
                comment = new StringBuilder();
                int nestedCommentCounter = 0;
                foreach (string s in linesNew)
                {
                    string s2 = s.Trim();
                    if (i == 0)
                    {
                        //TODO: handle ### model blocks together with comment blocks
                        if (s2.StartsWith("/*")) nestedCommentCounter++;
                        if (s2.EndsWith("*/")) nestedCommentCounter--;
                        if (nestedCommentCounter > 1 || nestedCommentCounter < 0)  //should be 0 or 1, nothing else, so nested comments will -> problem
                        {
                            problem = true;
                            break;
                        }
                        if (nestedCommentCounter == 1)
                        {
                            GetModelHashAndInfoHelper(comment, s2, modelCommentsHelper);
                            continue;  //inside comment
                        }
                    }
                    if (s2.StartsWith("()") || s2.StartsWith("//"))
                    {
                        GetModelHashAndInfoHelper(comment, s2, modelCommentsHelper);
                        if (!s2.Contains("###"))
                        {
                            continue;  //we ignore a normal comment. But if the comment contains '###'
                                       //it will be hashed. So model block lines count in hash code!
                        }
                    }
                    if (s2 == "") continue;
                    sb.AppendLine(s2);  //used for hash code
                }
                if (problem == false) break;
            }

            if (modelCommentsHelper.infoText == null && modelCommentsHelper.infoCounter > 0)
            {
                new Note("The correct syntax for info is 'Info: ' (followed by text). Note capital 'I' and the blank after ':'");
            }
            if (modelCommentsHelper.dateText == null && modelCommentsHelper.dateCounter > 0)
            {
                new Note("The correct syntax for date is 'Date: ' (followed by date). Note capital 'D' and the blank after ':'");
            }
            if (modelCommentsHelper.signatureFoundInFileHeader == null && modelCommentsHelper.signatureCounter > 0)
            {
                new Note("The correct syntax for signature is 'Signature: ' (followed by the signature). Note capital 'S' and the blank after ':'");
            }

            //The statement below makes sure that -- if a cached model is to be used -- the MODEL statement that created the cached model and the current MODEL statement are done under the same frequency
            sb.AppendLine("SubPeriods: " + O.CurrentSubperiods().ToString());  //for instance: "Frequency: 4". Cf. Program.model.modelGekko.subPeriods

            string trueHash = Program.GetMD5Hash(sb.ToString(), null, null);  //Pretty unlikely that two different .frm files could produce the same hash.
            trueHash = trueHash.Trim();  //probably not necessary
            G.WritelnGray("HASH: " + trueHash);

            Program.model.modelGekko.modelInfo.info = "[empty]";
            if (modelCommentsHelper.infoText != null) Program.model.modelGekko.modelInfo.info = modelCommentsHelper.infoText;

            Program.model.modelGekko.modelInfo.date = "[empty]";
            if (modelCommentsHelper.dateText != null) Program.model.modelGekko.modelInfo.date = modelCommentsHelper.dateText;

            if (modelCommentsHelper.signatureFoundInFileHeader == null)
            {
                modelCommentsHelper.signatureStatus = ESignatureStatus.SignatureNotFoundInModelFile;
            }
            else
            {
                if (modelCommentsHelper.signatureFoundInFileHeader == trueHash)
                {
                    modelCommentsHelper.signatureStatus = ESignatureStatus.Ok;
                }
                else
                {
                    modelCommentsHelper.signatureStatus = ESignatureStatus.SignaturesDoNotMatch;
                }
            }

            modelCommentsHelper.modelHashTrue = trueHash;

            return;
        }

        /// <summary>
        /// Helper method.
        /// </summary>
        /// <param name="sb"></param>
        /// <param name="s2"></param>
        /// <param name="modelCommentsHelper"></param>
        private static void GetModelHashAndInfoHelper(StringBuilder sb, string s2, ModelCommentsHelper modelCommentsHelper)
        {
            string s3 = s2.Trim();
            if (s3.StartsWith("/*")) s3 = s3.Substring(2);
            else if (s3.StartsWith("*/")) s3 = s3.Substring(2);
            else if (s3.StartsWith("//")) s3 = s3.Substring(2);
            else if (s3.StartsWith("()")) s3 = s3.Substring(2);
            s3 = s3.Trim();
            //-------------
            if (s3.StartsWith("Info: "))
            {
                if (modelCommentsHelper.infoText != null)
                {
                    new Error("Model file contains several comment lines starting with 'Info: '");
                    //throw new GekkoException();
                }
                modelCommentsHelper.infoText = s3.Substring(6).Trim();
            }
            if (s3.ToLower().StartsWith("info:") || s3.ToLower().StartsWith("info :")) modelCommentsHelper.infoCounter++;
            //-------------
            if (s3.StartsWith("Date: "))
            {
                if (modelCommentsHelper.dateText != null)
                {
                    new Error("Model file contains several comment lines starting with 'Date: '");
                    //throw new GekkoException();
                }
                modelCommentsHelper.dateText = s3.Substring(6).Trim();
            }
            if (s3.ToLower().StartsWith("date:") || s3.ToLower().StartsWith("date :")) modelCommentsHelper.dateCounter++;
            //-------------
            if (s3.StartsWith("Signature: "))
            {
                if (modelCommentsHelper.signatureFoundInFileHeader != null)
                {
                    new Error("Model file contains several comment lines starting with 'Signature: '");
                    //throw new GekkoException();
                }
                modelCommentsHelper.signatureFoundInFileHeader = s3.Substring(11).Trim();
            }
            if (s3.ToLower().StartsWith("signature:") || s3.ToLower().StartsWith("signature :")) modelCommentsHelper.signatureCounter++;
            //-------------
            sb.AppendLine(s3);
        }

        public static string HandleGekkoCommands(string input)
        {
            List<string> lines = Stringlist.ExtractLinesFromText(input);
            List<string> linesNew = null;
            linesNew = HandleGekkoCommandsGlueSymbols(lines);
            Globals.cmdFileLines = linesNew;  //used if there is a lexer error
            StringBuilder sb = new StringBuilder();
            foreach (string line in linesNew)
            {
                sb.AppendLine(line);
            }
            string s2 = sb.ToString();
            return s2;
        }

        /// <summary>
        /// The Gekko percentile() function, generalized medians.
        /// </summary>
        /// <param name="sequence"></param>
        /// <param name="excelPercentile"></param>
        /// <returns></returns>
        public static double Percentile(double[] sequence, double excelPercentile)
        {
            //handles NaN values, return Excel-style Percentile
            //for sequence 1,2,3,4,5 these correspond to 0%, 25%, 50%, 75%, 100% and interpolates between them.
            //that seems reasonable. Uses N-1 = 4 to multiply the %, seems this corresponds to the gaps between numbers (commas).
            //again this seems reasonable if 1 and 5 are min and max.

            if (excelPercentile < 0 || excelPercentile > 1d)
            {
                new Error("The percentile parameter should be between 0 and 1");
                //throw new GekkoException();
            }

            Array.Sort(sequence);
            if (double.IsNaN(sequence[0]))
            {
                int x = 0;
                for (int i = 0; i < sequence.Length; i++)
                {
                    if (!double.IsNaN(sequence[i]))
                    {
                        break;
                    }
                    x = i;
                }
                double[] seq2 = new double[sequence.Length - (x + 1)];
                for (int i = x + 1; i < sequence.Length; i++)
                {
                    double y = sequence[i];
                    if (double.IsNaN(y))
                    {
                        new Error("#9807435237");  //should not happen in .NET 4.0 or higher
                        //throw new GekkoException();
                    }
                    seq2[i - (x + 1)] = y;
                }
                sequence = seq2;
            }
            int N = sequence.Length;
            double n = (N - 1) * excelPercentile + 1;
            // Another method: double n = (N + 1) * excelPercentile;
            if (n == 1d) return sequence[0];
            else if (n == N) return sequence[N - 1];
            else
            {
                int k = (int)n;
                double d = n - k;
                return sequence[k - 1] + d * (sequence[k] - sequence[k - 1]);
            }
        }
        

        /// <summary>
        /// These are internal developer "commands" that can be issued from the Gekko command window (GUI). But only on the developer
        /// computer. Stuff like rungenr1, rungenr2, etc. Some of it is obsolete. On a non-developer pc, this method does exactly
        /// nothing. All this is to avoid using ANTLR, which would be tedious.
        /// </summary>
        /// <param name="text"></param>
        /// <returns></returns>
        public static string HandleGekkoCommandsSpecialCheatCommandsOnDeveloperComputer(string text)
        {
            string sub = text.Trim();
            if (sub.EndsWith(";")) sub = sub.Substring(0, sub.Length - 1);
            sub = sub.Trim();

            if (sub.StartsWith("I(\""))
            {
                int i = sub.IndexOf("\")");
                string text2 = sub.Substring(3, i - 3);  //handle comments!!!
                return text2;
            }

            switch (sub.ToLower())
            {
                case "--rungenr1":
                    {
                        //typing "rungenr1" will put cs code in Genr.cs
                        G.Writeln2("Put code in Genr.cs. Now you should compile...");
                        Program.Rungenr(1);
                    }
                    break;
                case "--rungenr2":
                    {
                        //typing "rungenr2" will run stuff in Genr.cs for debugging
                        G.Writeln2("Running Genr.cs for debugging:");
                        Program.Rungenr(2);
                    }
                    break;
                case "--timings":
                    {
                        Globals.showTimings = !Globals.showTimings;
                        G.Writeln("TIMINGS = " + Globals.showTimings);
                    }
                    break;
                case "--packsim":
                    {
                        Globals.alwaysEnablcPackForSimulation = true;
                        G.Writeln("alwaysEnablcPackForSimulation = " + Globals.alwaysEnablcPackForSimulation);
                    }
                    break;
                case "--aremos":
                    {
                        //typing "aremos" on the prompt opens the dialog for creating a wa.bat file.
                        //not intended for "normal" Gekko users.
                        MakeBatFileForAremos();
                    }
                    break;                
                case "--deploy":
                    {
                        //Deploy
                        G.Writeln2("Use 'deploy' from Total Commander prompt");
                        G.Writeln(@"Also see c:\Thomas\Gekko\GekkoCS\Deploy\!seher");
                    }
                    break;
                case "--testsim":
                    {
                        int n = 1000;
                        double[] abs = new double[3000];  //years
                        double[] rel = new double[3000];  //years
                        string[] absVar = new string[3000];  //years
                        string[] relVar = new string[3000];  //years

                        double[] absVs = new double[3000];  //years
                        double[] relVs = new double[3000];  //years

                        double[] absHs = new double[3000];  //years
                        double[] relHs = new double[3000];  //years

                        int min = int.MaxValue;
                        int max = int.MinValue;
                        List<string> list = Stringlist.GetListOfStringsFromList(Program.databanks.GetFirst().GetIVariable(Globals.symbolCollection + "endo"));
                        int x = list.Count;
                        G.Writeln("Testing " + x + " endogenous vars");
                        for (int i = 0; i < x; i += n)
                        {
                            G.Writeln("Testing " + i + " up to " + (i + n - 1));
                            List<string> res = TestSim(list, i, i + n - 1);
                            foreach (string s in res)
                            {
                                string[] s3 = s.Split('¤');
                                string type = s3[0];
                                int year = int.Parse(s3[1]);
                                string var = s3[2];
                                double val = G.ParseIntoDouble(s3[3]);
                                double vs = G.ParseIntoDouble(s3[4]);
                                double hs = G.ParseIntoDouble(s3[5]);
                                if (year < min) min = year;
                                if (year > max) max = year;
                                if (type == "abs")
                                {
                                    if (val > abs[year])
                                    {
                                        abs[year] = val;
                                        absVar[year] = var;
                                        absVs[year] = vs;
                                        absHs[year] = hs;
                                    }
                                }
                                else
                                {
                                    if (val > rel[year])
                                    {
                                        rel[year] = val;
                                        relVar[year] = var;
                                        relVs[year] = vs;
                                        relHs[year] = hs;
                                    }
                                }
                            }
                        }

                        G.Writeln();
                        for (int y = min; y <= max; y++)
                        {
                            G.Writeln("rel% " + y + " " + relVar[y] + " " + rel[y] + "%     left " + relVs[y] + " right " + relHs[y]);
                        }

                        G.Writeln();
                        for (int y = min; y <= max; y++)
                        {
                            G.Writeln("abs " + y + " " + absVar[y] + " " + abs[y] + "     left " + absVs[y] + " right " + absHs[y]);
                        }


                    }
                    break;
                case "--lex":
                    {
                        //show raw tokens
                        //only for debugging
                        //not intended for "normal" Gekko users.
                        if (Globals.debugTokens) Globals.debugTokens = false;
                        else Globals.debugTokens = true;
                        if (Globals.debugTokens == true)
                        {
                            G.Writeln("Lexing will be done...");
                        }
                        else
                        {
                            G.Writeln("Lexing undone...");
                        }
                    }
                    break;
                case "--ast":
                    {
                        //typing "ast" on the prompt means AST tree is printed out on screen
                        //only for debugging
                        //not intended for "normal" Gekko users.
                        Globals.printAST = true;
                        G.Writeln("AST tree will be printed...");
                    }
                    break;                
                case "--testram":
                    {
                        Program.TestRam(false);
                    }
                    break;
                case "--antlr":
                    {
                        //
                        //rem without Xconversiontimeout it will only compile 10 % of the times. 120000 probably means 120 sec.
                        //rem Takes about 1 minute 15 s, june 2019.The 1.5 GB setting makes compilation possible, and does not cost extra time.                        
                        string antlrFile = "c:\\Thomas\\Gekko\\GekkoCS\\ANTLR\\Cmd3.g";
                        string antlrFile4 = antlrFile.Replace("Cmd3.g", "Cmd4.g");
                        string javaPath = "c:\\Thomas\\Software\\Java\\jre6\\bin\\java.exe";
                        string classPath = "c:\\Thomas\\Software\\ANTLR\\antlr-3.1.3.jar";
                        string s = "\"" + javaPath + "\" -classpath " + classPath + " -Xmx500m org.antlr.Tool -Xconversiontimeout 120000 -traceParser " + antlrFile;
                        new Writeln("Start Cmd3.g");
                        Program.ExecuteShellCommand(s, false);
                        new Writeln("End Cmd3.g");
                        string txt2 = GetTextFromFileWithWait(antlrFile, false);  //keep ansi
                        List<string> txt3 = Stringlist.ExtractLinesFromText(txt2);
                        List<string> txt4 = new List<string>();
                        int hit = 0;
                        foreach (string s7 in txt3)
                        {
                            if (s7.Contains("//[[Cmd4.g -- do not touch]]")) continue;
                            string s8 = s7;
                            if (s8.Contains("grammar Cmd3;"))
                            {
                                s8 = s8.Replace("grammar Cmd3;", "grammar Cmd4;");
                                hit++;
                            }
                            txt4.Add(s8);
                        }
                        if (txt3.Count - txt4.Count != 4) new Error("Expected 4 lines difference between Cmd3.g and Cmd4g, got: " + (txt3.Count - txt4.Count));
                        if (hit != 1) new Error("Expected 1 'grammar Cmd3;'");
                        using (FileStream fs = WaitForFileStream(antlrFile4, null, GekkoFileReadOrWrite.Write))
                        using (StreamWriter sw = G.GekkoStreamWriter(fs))
                        {
                            foreach (string s2 in txt4)
                            {
                                sw.WriteLine(s2);
                            }
                            sw.Flush();
                        }
                        string s4 = "\"" + javaPath + "\" -classpath " + classPath + " -Xmx500m org.antlr.Tool -Xconversiontimeout 120000 -traceParser " + antlrFile4;
                        new Writeln("Start Cmd4.g");
                        Program.ExecuteShellCommand(s4, false);
                        new Writeln("End Cmd4.g");
                        new Writeln("Parsing finished");
                    }
                    break;
                case "--gray":
                    {
                        if (Globals.printGrayLinesForDebugging == true) Globals.printGrayLinesForDebugging = false;
                        else Globals.printGrayLinesForDebugging = true;
                        G.Writeln("Gray printing (debug) is set to: " + Globals.printGrayLinesForDebugging);
                    }
                    break;
                case "--prune":
                    {
                        string[] ss2 = sub.Split(' ');
                        double prune = G.ParseIntoDouble(ss2[1].Trim());
                        Globals.pruneDecomp = prune;
                        G.Writeln("Flowchart prune set to: " + Globals.pruneDecomp);
                        G.Writeln();
                    }
                    break;
                case "--killexcel":
                    {
                        DialogResult result = MessageBox.Show("Delete all processes with 'excel' in their names? CLOSE EXCEL SHEETS BEFOREHAND!!", "Gekko helper", MessageBoxButtons.YesNo, MessageBoxIcon.None, MessageBoxDefaultButton.Button2, MessageBoxOptions.DefaultDesktopOnly);
                        if (result == DialogResult.Yes)
                        {
                            G.Writeln("");
                            int counter = 0;
                            Process[] ps = Process.GetProcesses();
                            foreach (var process in ps)
                            {
                                string name = process.ProcessName;
                                if (name.ToLower().Contains("excel"))
                                {
                                    process.Kill();
                                    G.Writeln("Killed '" + name + "'");
                                    counter++;
                                }
                            }
                            G.Writeln("Killed " + counter + " Excel processes");
                        }
                        else G.Writeln2("Cancelled");
                    }
                    break;
                case "--locked":
                    {
                        //typing "locked" on the prompt searches for locked files (sharing violation)
                        //in working folder and sub-dirs
                        //intended for bug finding
                        if (true)
                        {
                            string workingFolder = G.GetWorkingFolder();
                            G.Writeln("Searching for locked files in " + workingFolder);
                            G.Writeln("The search includes sub-folders");
                            G.Writeln("----------- search starts --------------");
                            Globals.lockedCounter = 0;
                            FindLockedFiles(G.GetWorkingFolder());
                            G.Writeln("----------- search ends   --------------");
                            G.Writeln("Found " + Globals.lockedCounter + " locked files");
                            G.Writeln();
                        }
                    }
                    break;
                default:
                    {
                        //this is the common case: just return the text string untouched.
                        return text;
                    }
                    break;
            }

            return "";  //return a blank line, so that Gekko does not try to parse and run the line
        }

        /// <summary>
        /// Internal helper method to check for locked files when for instance reading.
        /// </summary>
        /// <param name="folder"></param>
        private static void FindLockedFiles(string folder)
        {
            foreach (string file in Directory.GetFiles(folder))
            {
                try
                {
                    using (FileStream fs = File.Open(file, FileMode.Open, FileAccess.Read, FileShare.None))
                    {
                        fs.Close();
                    }
                    // The file is not locked
                }
                catch (Exception)
                {
                    // The file is locked
                    G.Writeln("locked: " + file);
                    Globals.lockedCounter++;
                }

            }
            foreach (string subDir in Directory.GetDirectories(folder))
            {
                FindLockedFiles(subDir);
            }
        }

        /// <summary>
        /// Use together with convertToolStripMenuItem_Click(), but seems defunct/obsolete at the moment. Probably not that important,
        /// and offline tables should perhaps rather be .html format rather than .txt.
        /// </summary>
        /// <param name="folder"></param>
        public static void ConvertTabToText2(string folder) {

            string outputPath = Globals.localTempFilesLocation + "\\" + "tabtotextconversion";

            G.DeleteFolder(outputPath, true);
            Directory.CreateDirectory(outputPath);

            Globals.convertTabToTextCounter = 0;
            Globals.convertTabToTextErrorCounter = 0;

            G.Writeln("Starting conversion of tables to text...");

            try
            {
                Program.options.interface_debug = "none";
                ConvertTabToText(0, folder, folder, outputPath);
            }
            finally
            {
                WaitForFileDelete(Program.options.folder_working + "\\" + "temptabtotextfile.txt");
                Program.options.interface_debug = "dialog";
            }

            G.Writeln();
            G.Write("Zipping converted files... ");
            string zipFileNameInput = Program.CreateFullPathAndFileName(Program.options.folder_working + "\\converted_table_text.zip");
            Program.WaitForZipWrite(outputPath, zipFileNameInput);
            G.Writeln("... ended");
            G.Writeln();
            G.Writeln("Converted " + Globals.convertTabToTextCounter + " tables from folder: " + folder);
            G.Writeln("with " + Globals.convertTabToTextErrorCounter + " non-converted tables (errors).");
            G.Writeln("Result is in the file converted_table_text.zip in the working folder.");
        }

        /// <summary>
        /// Helper for ConvertTabToText2()
        /// </summary>
        /// <param name="depth"></param>
        /// <param name="start"></param>
        /// <param name="folder"></param>
        /// <param name="outputPath"></param>
        public static void ConvertTabToText(int depth, string start, string folder, string outputPath)
        {
            foreach (string file in Directory.GetFiles(folder))
            {
                string extra = file.Replace(start, "");
                if (file.ToLower().EndsWith("." + Globals.extensionTable))
                {
                    StringBuilder x = null;

                    try
                    {
                        string s = ConvertTabToTextHelper(depth, file);
                        x = new StringBuilder(s);
                    }
                    catch (Exception e)
                    {
                        new Error("Conversion failed completely: " + file, false);
                        Globals.convertTabToTextErrorCounter++;
                        x = null;
                    }

                    if (x != null)
                    {
                        Globals.convertTabToTextCounter++;
                        G.Writeln("Total converted tables: " + Globals.convertTabToTextCounter);
                        string newfile = outputPath + extra;
                        string path = Path.GetDirectoryName(newfile);
                        if (!Directory.Exists(path))
                        {
                            Directory.CreateDirectory(path);
                        }

                        newfile = Path.ChangeExtension(newfile, ".txt");

                        using (FileStream fs = WaitForFileStream(newfile, null, GekkoFileReadOrWrite.Write))
                        using (StreamWriter sw = G.GekkoStreamWriter(fs))
                        {
                            sw.Write(x);
                            sw.Flush();
                        }
                    }
                }
                else if (file.ToLower().EndsWith(".html"))
                {
                    //for HTML menu files, we change links to .tab files to .txt files (unfortunately necessary in order to get IE to read them).
                    string newfile = outputPath + extra;
                    string path = Path.GetDirectoryName(newfile);
                    if (!Directory.Exists(path))
                    {
                        Directory.CreateDirectory(path);
                    }

                    string s = GetTextFromFileWithWait(file);
                    s = s.Replace("." + Globals.extensionTable + "\"", ".txt\"");
                    using (FileStream fs = WaitForFileStream(newfile, null, GekkoFileReadOrWrite.Write))
                    using (StreamWriter sw = G.GekkoStreamWriter(fs))
                    {
                        sw.Write(s);
                        sw.Flush();
                    }
                }
            }
            if (true)  //we allow converting subfolders
            {
                foreach (string subDir in Directory.GetDirectories(folder))
                {
                    ConvertTabToText(depth + 1, start, subDir, outputPath);
                }
            }
        }

        /// <summary>
        /// Helper for ConvertTabToText2()
        /// </summary>
        /// <param name="depth"></param>
        /// <param name="file"></param>
        /// <returns></returns>
        public static string ConvertTabToTextHelper(int depth, string file)
        {
            string tt1 = "__tabletimestart";
            string tt2 = "__tabletimeend";

            P p = new P();
            TableStuff.XmlTable(file, "txt", null, p);
            Program.Pipe("temptabtotextfile.txt", null);  //no append
            O.Run o = new O.Run();
            o.fileName = Globals.localTempFilesLocation + "\\" + "tablecode." + Globals.defaultCommandFileExtension;
            o.p = p;
            Program.Run(o);
            Program.Pipe("con", null);

            string s = GetTextFromFileWithWait(Program.options.folder_working + "\\" + "temptabtotextfile.txt");

            return s;
        }

        /// <summary>
        /// Converting the old PCIM table format (.tab) to the new Gekko xml-based table format (.gtb). The conversion is surprisingly robust.
        /// </summary>
        public static void ConvertPCIMTables()
        {
            string folder = "";
            FolderBrowserDialog fbd = new FolderBrowserDialog();
            fbd.SelectedPath = Program.options.folder_working;
            if (fbd.ShowDialog() == DialogResult.OK)
            {
                folder = fbd.SelectedPath;
            }
            if (folder != "")
            {
                string outputPath = Globals.localTempFilesLocation + "\\" + "tabfilesconversion";

                G.DeleteFolder(outputPath, true);
                Directory.CreateDirectory(outputPath);

                Globals.convertTableCounter = 0;
                Globals.convertTableErrorCounter = 0;

                G.Writeln("Starting conversion of tables...");

                ConvertPCIMTablesHelper(folder, folder, outputPath);

                G.Writeln();
                G.Write("Zipping converted files... ");
                string zipFileNameInput = Program.CreateFullPathAndFileName(Program.options.folder_working + "\\converted_tables.zip");
                Program.WaitForZipWrite(outputPath, zipFileNameInput);
                G.Writeln("... ended");
                G.Writeln();
                G.Writeln("Converted " + Globals.convertTableCounter + " tables from folder: " + folder);
                G.Writeln("There were " + Globals.convertTableErrorCounter + " error messages.");
                G.Writeln("See the file converted_tables.zip in the working folder.");
            }
            else
            {
                new Error("Please choose a folder");
            }
        }

        /// <summary>
        /// Helper method.
        /// </summary>
        /// <param name="start"></param>
        /// <param name="folder"></param>
        /// <param name="outputPath"></param>
        public static void ConvertPCIMTablesHelper(string start, string folder, string outputPath)
        {
            foreach (string file in Directory.GetFiles(folder))
            {
                if (file.ToLower().EndsWith("." + "tab"))
                {
                    //G.Writeln("table file: " + file);
                    string extra = file.Replace(start, "");

                    StringBuilder x = new StringBuilder();

                    try
                    {
                        x = TableStuff.ConvertPcimTable(file);
                    }
                    catch (Exception e)
                    {
                        G.Writeln();
                        G.Writeln("Conversion failed completely: " + file);
                        G.Writeln();
                        x = null;
                    }

                    if (x != null)
                    {
                        Globals.convertTableCounter++;
                        string newfile = outputPath + extra;  //path and filename
                        if (newfile.ToLower().EndsWith(".tab"))
                        {
                            newfile = newfile.Substring(0, newfile.Length - 4);
                            newfile = newfile + "." + Globals.extensionTable + "";
                        }
                        else
                        {
                            //This should not be possible....
                        }
                        string path = Path.GetDirectoryName(newfile);
                        if (!Directory.Exists(path))
                        {
                            Directory.CreateDirectory(path);
                        }

                        using (FileStream fs = WaitForFileStream(newfile, null, GekkoFileReadOrWrite.Write))
                        using (StreamWriter sw = G.GekkoStreamWriter(fs))
                        {
                            sw.Write(x);
                            sw.Flush();
                        }
                    }
                }
            }
            foreach (string subDir in Directory.GetDirectories(folder))
            {
                ConvertPCIMTablesHelper(start, subDir, outputPath);
            }
        }

        /// <summary>
        /// First non-blank to the left. Returns blank if not found.
        /// </summary>
        /// <param name="s"></param>
        /// <param name="i"></param>
        /// <returns></returns>
        public static char Left(string s, int col)
        {
            char rv = ' ';
            for (int i = col - 1; i >= 0; i--)
            {
                if (s[i] != ' ')
                {
                    rv = s[i];
                    break;
                }
            }
            return rv;
        }

        /// <summary>
        /// First non-blank to the right. Returns blank if not found.
        /// </summary>
        /// <param name="s"></param>
        /// <param name="i"></param>
        /// <returns></returns>
        public static char Right(string s, int col)
        {
            char rv = ' ';
            for (int i = col + 1; i < s.Length; i++)
            {
                if (s[i] != ' ')
                {
                    rv = s[i];
                    break;
                }
            }
            return rv;
        }

        /// <summary>
        /// Suggestions/intellisense in the GUI, when the user presses Ctrl+Space or tab. 
        /// Inputs a string and the current cursor position. With an input string like "prt 1+ab-2;" it will activate
        /// when the cursor is at the 'a', the 'b' or the '-'.
        /// Returns a list of names|labels. Returns list with count = 0 if malformed input or no results.
        /// Also sets Globals.windowIntellisenseSuggestionsOffset1|2, for the GUI when pasted.
        /// Other programs have intellisense too,
        /// Visual Studio (Ctrl+Space), RStudio (tab, but Ctrl+Space also works), Sublime (Ctrl+Space), Spyder (tab or Ctrl+Space).
        /// </summary>
        /// <param name="s"></param>
        /// <returns></returns>
        public static List<TwoStrings> IntellisenseVariables(string s, int col)
        {
            List<TwoStrings> rv2 = new List<TwoStrings>();

            if (true)
            {
                //b : a*b!q[ * , *b ]
                //find start                

                int start = -12345;
                int lineEnd = col;
                bool hasMoved = false;
                if (lineEnd > s.Length - 1)
                {
                    lineEnd = s.Length - 1; //if outside string move it inside
                    hasMoved = true;
                }
                if (!hasMoved && !IsCharOk(s, lineEnd, -12345)) lineEnd--;  //we allow a blank as very last char
                for (int i = lineEnd; i >= 0; i--)
                {
                    bool ok = IsCharOk(s, i, -12345);
                    if (!ok)
                    {
                        start = i + 1; //best bet
                        break;
                    }
                    if (i == 0) start = i;
                }

                //now we have a start

                int end = -12345;
                for (int i = start; i < s.Length; i++)
                {
                    bool ok = IsCharOk(s, i, start);
                    if (!ok)
                    {
                        end = i - 1; //best bet
                        break;
                    }
                    if (i == s.Length - 1) end = i;
                }

                string x = G.Substring(s, start, end);
                string drop = G.Substring(s, end + 1, lineEnd);  //"prt xx, " with col at last blank will drop ", " which is too much. At col 1 less it would be "," and ok.
                if (Globals.runningOnTTComputer) new Writeln("TTH: input = {" + x + "} drop = {" + drop + "}");

                bool dropProblem1 = false;
                if (drop != null && drop.Length > 1) dropProblem1 = true;

                bool dropProblem2 = false;
                if (drop != null && x.EndsWith(" ") && drop.Length > 0) dropProblem2 = true;

                bool dropProblem3 = false;
                if (x != null && x.EndsWith("  ")) dropProblem3 = true;

                if (x != null && !dropProblem1 && !dropProblem2 && !dropProblem3)
                {
                    x = x.Trim();
                    if (!(x.Contains("*") || x.Contains("?"))) x = x + "*"; //aa --> aa*, x[ --> x[* x[aa --> x[aa*, x[a] --> x[a]* (the last is bad, but never mind)
                    bool bleft = x.Contains("[");
                    bool bright = x.Contains("]");
                    if (bleft && !bright) x = x + "]";
                    if (!bright && x.EndsWith("[*]")) x = x.Substring(0, x.Length - "[*]".Length) + "[**]";
                    List<string> names = null;
                    string x2 = x.Replace(" ", "");

                    if (x2.StartsWith("@")) x2 = "Ref:" + x2.Substring(1);

                    if (Globals.runningOnTTComputer) new Writeln("TTH: string = " + x2);
                    try { names = Program.Search(new List(new List<string>() { x2 }), null, EVariableType.Var); } catch { };

                    if (names != null)
                    {
                        foreach (string s7 in names)
                        {
                            string ss = Stringlist.ExtractTextFromLines(Program.GetVariableExplanation(s7, s7, false, false, GekkoTime.tNull, GekkoTime.tNull, null)).ToString();
                            rv2.Add(new TwoStrings(s7, ss));
                        }
                    }
                    Globals.windowIntellisenseSuggestionsOffset1 = start - col;
                    Globals.windowIntellisenseSuggestionsOffset2 = end - col;
                }
            }
            else
            {

                //We have a pointer .................|
                //We have a string "lkfjal klafjk lkadsfj lkj fkladsjf kl"
                //From the pointer we will look left and right as long as it is legal
                //Legal is alphanumeric, "_", "*", "?", ":", "@", "!". If we are left of ":" only
                //accept if an ident is left of ":" and the pointer is at this ident.
                //to the right of ":" or if no ":", accept normal and "*" and "?".
                //No blanks are accepted at all, except around ":".

                int col1 = col + 1;  //col1 is 1-based, easier here                

                string txt = s;
                var tags1 = new List<Tuple<string, string>>() { new Tuple<string, string>("/*", "*/") };
                var tags2 = new List<string>() { "//" };
                TokenList tokens2 = StringTokenizer.GetTokensWithLeftBlanks(txt, 0, tags1, tags2, null, null);
                int iCenter = -12345;
                for (int i = 0; i < tokens2.storage.Count; i++)
                {
                    //the token start pos (.column) is its first non-blank. So real start has leftblanks deducted,
                    //and the end has added length of token (.s) minus 1.
                    TokenHelper th = tokens2.storage[i];
                    if (TokenBorders(th).Item1 <= col1 && col1 <= TokenBorders(th).Item2) iCenter = i;
                }
                if (iCenter == -12345) iCenter = tokens2.storage.Count - 1; //should not happen

                //try to find out if we have this pattern: bankvarname [ ... ]
                //bankvarname will be found

                TokenHelper center = tokens2.storage[iCenter];

                List<TokenHelper> left = new List<TokenHelper>();
                List<TokenHelper> right = new List<TokenHelper>();

                bool centerAcceptable = false;
                if (AcceptableToken(center) || center.s == ":")
                {
                    centerAcceptable = true;
                }
                else
                {
                    //starts at something like ";" or "," etc.
                }

                //look at the left
                for (int i = iCenter - 1; i >= 0; i--)
                {
                    //accepts blank between i and i+1 if i+1 is colon
                    TokenHelper th = tokens2.storage[i];
                    if (AcceptableToken(th) && (tokens2.storage[i + 1].leftblanks == 0 || tokens2.storage[i + 1].s == ":" || tokens2.storage[i + 1].type == ETokenType.EOF)) left.Add(th);
                    else if (th.s == ":") left.Add(th);
                    else if (i == iCenter - 1 && !centerAcceptable) left.Add(th);
                    else break;
                }

                if (AcceptableToken(center) || center.s == ":")
                {
                    //look at the right
                    for (int i = iCenter + 1; i < tokens2.storage.Count; i++)
                    {
                        TokenHelper th = tokens2.storage[i];
                        if (AcceptableToken(th) && (th.leftblanks == 0 || tokens2.storage[i - 1].s == ":")) right.Add(th);
                        else if (th.s == ":") right.Add(th);
                        else break;
                    }
                }

                List<TokenHelper> all = new List<TokenHelper>();
                left.Reverse();
                all.AddRange(left);
                if (centerAcceptable) all.Add(center);
                all.AddRange(right);

                bool bad = false;
                if (all.Count > 0)
                {
                    //end-point restrictions
                    if (col1 < all[0].column) bad = true;
                    if (TokenBorders(all[all.Count - 1]).Item2 < col1 - 1) bad = true;
                }
                if (bad) all.Clear();

                if (all.Count > 0)
                {
                    int start = all[0].column;
                    int end = TokenBorders(all[all.Count - 1]).Item2;
                    Globals.windowIntellisenseSuggestionsOffset1 = start - col1;
                    Globals.windowIntellisenseSuggestionsOffset2 = end - col1;

                    //G.Writeln2("Center: '" + tokens2.subnodes.storage[iCenter].ToString() + "'   "+iCenter);            
                    //G.Writeln();            
                    string x = "";
                    foreach (TokenHelper th in all)
                    {
                        x += th.ToString();
                        //G.Writeln("--- '" + th.ToString() + "'   "+th.type);
                    }
                    if (!(x.Contains("*") || x.Contains("?"))) x = x + "*";

                    List<string> names = null;

                    string x2 = x.Replace(" ", "");
                    names = Program.Search(new List(new List<string>() { x2 }), null, EVariableType.Var);

                    //new Writeln("bankname = " + bankname + ", varname = " + varname + ", offset = " + Globals.windowIntellisenseSuggestionsOffset);

                    foreach (string s7 in names)
                    {
                        string ss = Stringlist.ExtractTextFromLines(Program.GetVariableExplanation(s7, s7, false, false, GekkoTime.tNull, GekkoTime.tNull, null)).ToString();
                        rv2.Add(new TwoStrings(s7, ss));
                    }
                }
            }

            return rv2;
        }

        private static bool IsCharOk(string s, int i, int start)
        {
            bool ok = false;
            int leftBracketCounter = 0;
            int rightBracketCounter = 0;

            if (start != -12345)
            {
                bool hasLeftBracket = false;
                for (int ii = start; ii < i; ii++)
                {
                    if (s[ii] == '[')
                    {
                        leftBracketCounter++;
                    }
                    else if (s[ii] == ']')
                    {
                        rightBracketCounter++;
                    }
                }
            }

            if (i < 0 || i > s.Length - 1) return false;
            if (s[i] == '_' || char.IsLetterOrDigit(s[i]) || s[i] == '*' || s[i] == '?' || s[i] == ':' || s[i] == '@' || s[i] == '!')
            {
                ok = true;
            }
            else if (s[i] == '[')
            {
                if (start == -12345)
                {
                    ok = true;
                }
                else
                {
                    if (leftBracketCounter == 0 && rightBracketCounter == 0) ok = true;
                }
            }
            else if (s[i] == ']')
            {
                if (start == -12345)
                {
                    ok = true;
                }
                else
                {
                    if (leftBracketCounter == 1 && rightBracketCounter == 0) ok = true;
                }
            }
            else if (s[i] == ',')
            {
                if (start == -12345)
                {
                    ok = true;
                }
                else
                {
                    if (leftBracketCounter == 1 && rightBracketCounter == 0) ok = true;
                }
            }
            else if (s[i] == ' ')
            {
                char l = Left(s, i);
                char r = Right(s, i);
                if (r == ']') ok = true;
                else if (l == ',' || r == ',') ok = true;
                else if (l == '[') ok = true;
                else if (l == ':' || r == ':') ok = true;
            }
            return ok;
        }

        private static bool AcceptableToken(TokenHelper th)
        {
            return th.type == ETokenType.Word || (th.type == ETokenType.Number && G.IsInteger(th.s)) || th.s == "*" || th.s == "?" || th.s == "@" || th.s == "!";
        }

        /// <summary>
        /// Real borders of token, including blanks to the left and adjusting for length. 1-based like TokenHelper.column.
        /// </summary>
        /// <param name="th"></param>
        /// <returns></returns>
        public static Tuple<int, int> TokenBorders(TokenHelper th)
        {
            return new Tuple<int, int>(th.column - th.leftblanks, th.column + th.s.Length - 1);
        }

        /// <summary>
        /// Helper method for HandleGekkoCommandsGlueSymbols()
        /// </summary>
        /// <param name="lineNewVersion"></param>
        /// <param name="start"></param>
        /// <returns></returns>
        private static bool Has2IdentsFollowing(string lineNewVersion, int start)
        {
            //The method looks for two idents like "a1 b2 " or "a1 b2>". Any spaces before, in middle or after are ok.
            //A '=' right after the second token is ok too.
            int j = G.SkipSpaces(lineNewVersion, start);
            if (j == -12345) return false;
            if (!G.IsLetterOrUnderscore(lineNewVersion[j])) return false;
            int blank = -12345;
            for (int k = j + 1; k < lineNewVersion.Length; k++)
            {
                if (lineNewVersion[k] == ' ')
                {
                    blank = k;
                    break;
                }
                if (!G.IsLetterOrDigitOrUnderscore(lineNewVersion[k]))
                {
                    return false;
                }
            }
            j = G.SkipSpaces(lineNewVersion, blank);
            if (j == -12345) return false;
            if (!G.IsLetterOrUnderscore(lineNewVersion[j])) return false;
            for (int k = j + 1; k < lineNewVersion.Length; k++)
            {
                if (lineNewVersion[k] == ' ' || lineNewVersion[k] == '=' || lineNewVersion[k] == '>')
                {
                    //these are ok: <m p q>, <stamp rows=yes>, <m p>
                    //so the first two tokens will not by tried to be interpreted as two dates
                    break;
                }
                if (!G.IsLetterOrDigitOrUnderscore(lineNewVersion[k]))
                {
                    return false;
                }
            }
            return true;
        }

        /// <summary>
        /// The ANTLR parser generally ignores whitespace, but this poses problems. For instance, we may like to allow a Gekko name to
        /// be written like "a{%i}", but would like to disallow "a {%i}", note the blank. The same goes for functions, where 
        /// we allow "f(x)", but not "f (x)", etc. etc. To handle this issue, some small "glue" characters/symbols 
        /// like '¨', '£', '§', '½' are introduced. This is not pretty, but it works. It would be much nicer if in the ANTLR parser
        /// one could ask if there is a blank to the left of for instance a '{' or a '(', but this is not so easy. So ANTLR sees these
        /// funny symbols, and when printing an error message from ANTLR, the symbols must be removed before being shown in Gekko.
        /// </summary>
        /// <param name="inputFileLines"></param>
        /// <returns></returns>
        private static List<string> HandleGekkoCommandsGlueSymbols(List<string> inputFileLines)
        {
            // ----------- NOTE ---------------------------------
            // Some of these glue symbols are probably not necessary
            // anymore and should be removed. For instance, are the
            // glue symbols added to non-quoted wildcards really
            // necessary, or are all wildcards in Gekko 3.0 inside
            // quotes anyway?
            // Fix this for a Gekko 4.0 version.
            // --------------------------------------------------

            List<string> inputFileLines2 = new List<string>();
            int lineCounter = 0;
            foreach (string line in inputFileLines)
            {
                lineCounter++;
                string lineNewVersion = line;

                if (lineNewVersion == Globals.iniFileSecretName)  //this strange name is made in GuiAutoExecStuff()
                {
                    //lineNewVersion = "run '" + Globals.autoExecCmdFileName + "';";
                    lineNewVersion = "ini;";
                }
                else if (lineNewVersion == "RunGekkoTabToTextStuff")
                {
                    ConvertTabToText2(Globals.RunGekkoTabToTextStuff_folder);
                    lineNewVersion = "";  //deleting it, has been handled above
                }

                string lineComment = lineNewVersion.Trim();


                // Special rule to make sure PRT<m d> is not interpreted as time period, so in that case we get
                // PRT<m d> --> PRT <¨<m d>
                //
                // Else: (ldu is letterDigitUnderscore)
                // For every ldu, '(', '[', '{', '%', '#'
                //   see if preceding char is ldu, ')', ']', '}', '%' or '#'.
                //   if so, put a glue in between.
                //   EXCEPTION: ldu before ldu gets no glue (of course)!
                // For '|' there is glue before, UNLESS there is a blank before OR after the '|'
                // For '.' ...
                //
                // For "<m d>" kind of options, we use a special kind of marker ('<<<' instead of '<') to indicate that it is
                // an "<ident ident..." type.
                List<char> glued3 = new List<char> { '|', '\\' };  //note special rules for '.', see glued3a
                List<char> glued3a = new List<char> { '=', '+', '-', '/', '*', '^', '(', '{', '[', '<', '>', ',', ':', ' ' };  // "=.12", "+.12", "-.12" etc.
                List<char> glued4 = new List<char> { '@' };  //only checked if no blank right of this
                List<char> glued5 = new List<char> { '.' };  //only checked if no blank right of this
                List<char> glued6 = new List<char> { '*', '?' };  //wildcards: a*b and a?b cannot have blanks.
                List<char> glued7 = new List<char> { Globals.freqIndicator };

                //=========== note =========================
                // [c1] [c2] [c3], where c2 is the char analyzed.
                //==========================================

                StringBuilder sb = new StringBuilder();
                for (int i = 0; i < lineNewVersion.Length; i++)  //ignore if first on line
                {
                    char c1 = '\n';
                    if (i > 0) c1 = lineNewVersion[i - 1];
                    char c2 = lineNewVersion[i];
                    char c3 = '\n';
                    if (i < lineNewVersion.Length - 1) c3 = lineNewVersion[i + 1];
                    char c4 = '\n';
                    if (i < lineNewVersion.Length - 2) c4 = lineNewVersion[i + 2];

                    // -------------------------------------------------------------
                    // Handle PRT<m d> etc.
                    // -------------------------------------------------------------
                    if (c2 == '<')
                    {
                        //Special rule to make sure the first two tokens inside <> in PRT<m d> or PRT<stamp row=yes> are not interpreted as time period
                        //If we have for instance "<m d>", the below will return true, and it will be transformed
                        //into "<¨<m d>". This makes it easier to identify such cases in the parser. We would not like
                        //to try to interpret <m d> as a time period, so two raw idents will never be thought of as a
                        //period. That way, missspellings like "<m dd>" will be caught in syntax, and it will not try
                        //to understand <filter row> as dates either. But <%t1 %t2> will be just fine as dates, as will
                        //<2010 2012>. Expressions can also be used for dates.
                        //So all in there is special treatment of the first two items in <>, since this is the only place
                        //a date is allowed.
                        if (Has2IdentsFollowing(lineNewVersion, i + 1))
                        {
                            sb.Append(Globals.symbolGlueChar5);
                            continue;
                        }
                    }

                    // -------------------------------------------------------------
                    // Handle x(, x[, x{, %x, #x
                    // c2 is current char, c1 is previous
                    // -------------------------------------------------------------
                    if (c1 != '\n')
                    {
                        /*
                               a(      --->   a¨(     and same for the others
                               a[      --->   special [_[ symbol
                               a{
                               a%  //part of name
                               a#  //part of name

                               )a  //for instance a%(%b)c, not need for glue here like this: a%(%b)|c as in a%d|c.
                               ){  //same logic
                               )%  //same logic
                               )#  //same logic
                               )[  //for instance #(list%i)[2] --> special [_[ symbol

                               }a
                               }{
                               }%
                               }#
                               }[  //for instance {%a}[2000] or {a}[2000], --> special [_[ symbol

                               %a
                               %(
                               %{

                               ][  //for instance #m[3][2001q3], --> special [_[ symbol

                               #(
                               #{



                               ...#a --> what is that??



                        */
                        bool glue = false;
                        bool glue2 = false;

                        if (G.IsLetterOrDigitOrUnderscore(c1) && c2 == '(') glue = true;
                        else if (G.IsLetterOrDigitOrUnderscore(c1) && c2 == '[') glue2 = true;
                        else if (G.IsLetterOrDigitOrUnderscore(c1) && c2 == '{') glue = true;
                        else if (G.IsLetterOrDigitOrUnderscore(c1) && c2 == Globals.symbolScalar) glue = true;
                        else if (G.IsLetterOrDigitOrUnderscore(c1) && c2 == Globals.symbolCollection) glue = true;

                        else if (c1 == ')' && G.IsLetterOrDigitOrUnderscore(c2)) glue = true;
                        else if (c1 == ')' && c2 == '{') glue = true;
                        else if (c1 == ')' && c2 == Globals.symbolScalar) glue = true;
                        else if (c1 == ')' && c2 == Globals.symbolCollection) glue = true;
                        else if (c1 == ')' && c2 == '[') glue2 = true;

                        else if (c1 == '}' && G.IsLetterOrDigitOrUnderscore(c2)) glue = true;
                        else if (c1 == '}' && c2 == '{') glue = true;
                        else if (c1 == '}' && c2 == Globals.symbolScalar) glue = true;
                        else if (c1 == '}' && c2 == Globals.symbolCollection) glue = true;
                        else if (c1 == '}' && c2 == '[') glue2 = true;

                        else if (c1 == Globals.symbolScalar && G.IsLetterOrDigitOrUnderscore(c2)) glue = true;
                        else if (c1 == Globals.symbolScalar && c2 == '(') glue = true;
                        else if (c1 == Globals.symbolScalar && c2 == '{') glue = true;

                        else if (c1 == Globals.symbolCollection && G.IsLetterOrDigitOrUnderscore(c2)) glue = true;
                        else if (c1 == Globals.symbolCollection && c2 == '(') glue = true;
                        else if (c1 == Globals.symbolCollection && c2 == '{') glue = true;

                        else if (c1 == ']' && c2 == '[') glue2 = true;

                        if (glue)
                        {
                            sb.Append(Globals.symbolGlueChar1);
                            sb.Append(c2);
                            continue;
                        }
                        else if (glue2)
                        {
                            sb.Append(Globals.symbolGlueChar6);
                            continue;
                        }

                        // -------------------------------------------------------------
                        // Handle x|x, x\\x
                        // c2 is current char, c1 is previous
                        // -------------------------------------------------------------
                        //glued3: '|', '\\'
                        else if (glued3.Contains(c2)) //add glue if "xx|yy", but not "xx| yy" or "xx |yy" or "xx | yy", and same regarding "\\"
                        {
                            //Handling '|' and '\\'
                            if (c3 != '\n')
                            {
                                if (c1 != ' ' && c3 != ' ')
                                {
                                    sb.Append(Globals.symbolGlueChar1); //12|34 --> 12¨|34, and 12\\34 --> 12¨\\34
                                    sb.Append(c2);
                                    continue;
                                }
                            }
                        }
                    }


                    // -------------------------------------------------------------
                    // Handle @
                    // -------------------------------------------------------------
                    if (glued4.Contains(c2))
                    {
                        //handling '@'
                        if (c3 != '\n')
                        {
                            if (c3 == ' ')
                            {
                                //ignore
                            }
                            else
                            {
                                //PRT @x --> PRT @¨x, but PRT @ x --> PRT @ x.
                                //Note that the glue is AFTER the @.
                                sb.Append(c2);
                                sb.Append(Globals.symbolGlueChar1);
                                continue;
                            }
                        }
                    }

                    // -------------------------------------------------------------
                    // Handle wildcards a*b, a?b -> a½*½b, a½?½b, also {'a'}*{'b'} will become {'a'}½*½{'b'}
                    // A * will get glue (½) to the left if there is ldu to the left. a* -> a½*
                    // A * will get glue (½) to the right if there is ldu the right.  *b -> *½b
                    // -------------------------------------------------------------
                    if (glued6.Contains(c2))
                    {
                        if (G.IsLetterOrDigitOrUnderscore(c1) || c1 == '}')
                        {
                            sb.Append(Globals.symbolGlueChar4);
                        }
                        sb.Append(c2);
                        if (G.IsLetterOrDigitOrUnderscore(c3) || c3 == '{')
                        {
                            sb.Append(Globals.symbolGlueChar4);
                        }
                        continue;
                    }

                    // -------------------------------------------------------------
                    // Handle dots (.)
                    // -------------------------------------------------------------
                    if (glued5.Contains(c2))
                    {
                        //c2 is a '.'
                        if (c1 != '\n' && c3 != '\n')
                        {

                            if (c3 == ' ')
                            {
                                //do nothing, normal dot, for instance 12. 34
                            }
                            else if (char.IsDigit(c3))
                            {
                                if (glued3a.Contains(c1))
                                {
                                    //  +.12, **.12, >.12, (.12, etc.
                                    sb.Append(Globals.symbolGlueChar3);  //GLUEDOTNUMBER
                                    sb.Append(c2);
                                    continue;
                                }
                                else if (char.IsDigit(c1))
                                {
                                    //in stuff like 12.34 the dot becomes a GLUEDOTNUMBER
                                    //but only if stuff before 12 is not ident, for instance
                                    //x12.34. We could have hgn2.1, and that is not a number.
                                    bool number = true;
                                    for (int ii = i - 1 - 1; ii >= 0; ii--)
                                    {
                                        //.... +123.45 loops through pure digits until + is met. Here number would be true.
                                        if (glued3a.Contains(lineNewVersion[ii]) || lineNewVersion[ii] == ';') break;  //for instance a "," or "+" to delimit the number ('token'), or the ';' in #m = [1.2;2.3]
                                        if (!char.IsDigit(lineNewVersion[ii]))
                                        {
                                            number = false;
                                            break;
                                        }
                                    }
                                    if (number)
                                    {
                                        sb.Append(Globals.symbolGlueChar3);  //GLUEDOTNUMBER
                                        sb.Append(c2);
                                        continue;
                                    }
                                    else
                                    {
                                        sb.Append(Globals.symbolGlueChar2);  //GLUEDOT
                                        sb.Append(c2);
                                        continue;
                                    }
                                }
                            }
                            if (c1 != ' ' && c3 != ' ')
                            {
                                sb.Append(Globals.symbolGlueChar2);  //GLUEDOT
                                sb.Append(c2);
                                continue;
                            }
                        }
                        else
                        {
                            if (c3 != '\n')
                            {
                                if (char.IsDigit(c3))
                                {
                                    //if line starts with .1, the dot is a GLUEDOTNUMBER
                                    sb.Append(Globals.symbolGlueChar3);  //GLUEDOTNUMBER
                                    continue;
                                }
                            }
                        }
                    }

                    // -------------------------------------------------------------
                    // Handle exclamation (!)  --> if no spaces --> ¨!¨
                    // -------------------------------------------------------------
                    if (glued7.Contains(c2))
                    {
                        //c2 is a '!'
                        if (c1 != '\n' && c3 != '\n')
                        {
                            if (c1 != ' ' && c3 != ' ')
                            {
                                sb.Append(Globals.symbolGlueChar1);
                                sb.Append(c2);
                                sb.Append(Globals.symbolGlueChar1);
                                continue;
                            }
                        }
                    }

                    sb.Append(c2);
                }
                lineNewVersion = sb.ToString();

                inputFileLines2.Add(lineNewVersion);
            }
            if (inputFileLines.Count != inputFileLines2.Count) throw new GekkoException();

            List<string> inputFileLines3 = new List<string>();

            if (Globals.runningOnTTComputer)
            {
                if (Globals.printAST)
                {
                    foreach (string s in inputFileLines2)
                    {
                        G.Writeln("-debug- " + s, Color.Orange);

                    }
                }
            }

            return inputFileLines2;
        }

        /// <summary>
        /// True if string contains '*' or '?'
        /// </summary>
        /// <param name="inside"></param>
        /// <returns></returns>
        public static bool CheckIfLooksLikeWildcard2(string inside)
        {
            if (inside == null) return false;
            if (inside.Contains("*") || inside.Contains("?")) return true;
            return false;
        }

        /// <summary>
        /// finds [a*b?] patterns, handled like {'a*b?'}. 
        /// Problem is that [a*b] looks like a matrix definition, therefore this code.
        /// </summary>
        /// <param name="inside"></param>
        /// <returns></returns>
        public static bool CheckIfLooksLikeWildcard(string inside)
        {
            //note that [bank:a*b?] is also allowed
            //note that [bank:a*b?!q] is also allowed            

            if (inside == null) return false;

            string[] sss = inside.Split(Globals.symbolBankColon2);

            if (sss.Length > 2) return false;

            string bank = null;
            string rest = null;
            if (sss.Length == 1)
            {
                rest = sss[0].Trim();
            }
            else
            {
                bank = sss[0].Trim();
                rest = sss[1].Trim();
            }
            if (bank != null && !G.IsSimpleToken(bank)) return false;

            string rest1 = null;
            string rest2 = null;  //freq
            string[] ssss = rest.Split(Globals.freqIndicator);
            if (ssss.Length == 1)
            {
                rest1 = ssss[0].Trim();
            }
            else
            {
                rest1 = ssss[0].Trim();
                rest2 = ssss[1].Trim();
            }

            int starCountFreq = 0;
            if (rest2 != null)
            {
                if (G.IsSimpleToken(rest2))
                {
                    //good
                }
                else if (rest2 == "*")
                {
                    //good
                    starCountFreq = 1;
                }
                else return false;
            }

            //seems this regex splits by '*' and '?', but keeps these delimiters
            string[] ss = Regex.Matches(rest1, @"[-\*?]|[^\*?-]+")
                .Cast<Match>()
                .Select(m => m.Value)
                .ToList()
                .ToArray<string>();

            int starCount = 0;
            int qCount = 0;
            for (int ii = 0; ii < ss.Length; ii++)
            {
                if (ss[ii] == "*")
                {
                    starCount++;
                }
                else if (ss[ii] == "?")
                {
                    qCount++;
                }
                else
                {
                    //why this test??
                    foreach (char c in ss[ii])
                    {
                        if (G.IsLetterOrDigitOrUnderscore(c) || c == Globals.symbolScalar || c == Globals.symbolCollection)
                        {
                            //good
                        }
                        else
                        {
                            //must be clean '0_ab_12x' type of word, can also contain % or #.
                            //blanks not allowed
                            return false;
                        }
                    }
                }
            }

            //if (starCount > 1) return false;  //only 1 accepted here, else use {'...'}
            if (starCount + qCount + starCountFreq == 0) return false;
            return true;
        }

        /// <summary>
        /// Used in CollapsePoints(), see this method
        /// </summary>
        /// <param name="ts"></param>
        /// <param name="countPeriods"></param>
        /// <param name="data"></param>
        /// <param name="gt"></param>
        /// <param name="method"></param>
        /// <param name="gt_min"></param>
        /// <param name="gt_max"></param>
        private static void HandleCollapseData(bool isPoints, Series ts, Series countPeriods, Series countNonMissing, double data, GekkoTime gt, ECollapseMethod method)
        {
            if (double.IsNaN(ts.GetDataSimple(gt)))
            {
                if (isPoints)
                {
                    ts.SetData(gt, data);  //first point in this bucket
                }
                else
                {
                    double count = countPeriods.GetDataSimple(gt);
                    if (double.IsNaN(count) || count == 0d)  //the latter can probably not happen
                    {
                        ts.SetData(gt, data);  //first observation allows NaN to become a value
                    }
                }
            }
            else
            {
                if (method == ECollapseMethod.First)
                {
                    //skip it if something already there
                }
                else if (method == ECollapseMethod.Last)
                {
                    //overwrite (no summing) if something already there
                    ts.SetData(gt, data);
                }
                else
                {
                    ts.SetData(gt, ts.GetDataSimple(gt) + data);
                }
            }

            if (double.IsNaN(countPeriods.GetDataSimple(gt)))
            {
                countPeriods.SetData(gt, 1d);  //first one
            }
            else
            {
                countPeriods.SetData(gt, countPeriods.GetDataSimple(gt) + 1d); //add 1
            }

            if (!double.IsNaN(data))
            {
                if (double.IsNaN(countNonMissing.GetDataSimple(gt)))
                {
                    countNonMissing.SetData(gt, 1d);  //first one
                }
                else
                {
                    countNonMissing.SetData(gt, countNonMissing.GetDataSimple(gt) + 1d); //add 1
                }
            }
        }

        /// <summary>
        /// Collapse Excel date "points" into Gekko timeseries of chosen frequency. These Excel dates are completely flexible,
        /// may even contain hours, minutes, etc., and Gekko will "collapse" (aggregate) these. Gets the data from .xls(x) via
        /// an intermediate/temporary TableLight table, just like more normal IMPORT&lt;xlsx&gt;.
        /// </summary>
        /// <param name="o"></param>
        public static void CollapsePoints(O.Read o)
        {
            if (o.readTo != null)
            {
                new Error("IMPORT<collapse=...> does not work with IMPORT ... TO ...");
                //throw new GekkoException();
            }

            if (o.opt_ref != null)
            {
                new Error("IMPORT<collapse=...> does not work with <ref>");
                //throw new GekkoException();
            }

            if (o.opt_first != null)
            {
                new Error("IMPORT<collapse=...> does not work with <first>");
                //throw new GekkoException();
            }

            if (o.opt_merge != null)
            {
                new Error("IMPORT<collapse=...> does not work with <merge>");
                //throw new GekkoException();
            }

            if (o.opt_xls == null && o.opt_xlsx == null)
            {
                new Error("IMPORT<collapse=...> should be used with xls- or xlsx-files");
                //throw new GekkoException();
            }

            string x = "xlsx";
            if (o.opt_xls != null) x = "xls";

            ECollapseMethod emethod = ECollapseMethod.Total;
            if (G.Equal(o.opt_method, "avg")) emethod = ECollapseMethod.Avg;
            else if (G.Equal(o.opt_method, "first")) emethod = ECollapseMethod.First;
            else if (G.Equal(o.opt_method, "last")) emethod = ECollapseMethod.Last;
            else if (G.Equal(o.opt_method, "count")) emethod = ECollapseMethod.Count;

            EFreq freq = G.ConvertFreq(o.opt_collapse);

            bool isTranspose = false;
            if (G.Equal(o.opt_cols, "yes")) isTranspose = true;

            string s2 = G.AddExtension(o.fileName, "." + x);
            FindFileHelper ffh = Program.FindFile(s2, null, true, true, o.p);
            string fn = ffh.realPathAndFileName;
            if (fn == null) new Error("Could not find file '" + ffh.prettyPathAndFileName + "'");

            //string s = Program.GetTextFromFileWithWait(fileName_string);

            TableLight matrix = null;
            matrix = Program.ReadExcel(fn, o.opt_sheet);
            G.Writeln2("Read " + matrix.GetRowMaxNumber() + "x" + matrix.GetColMaxNumber() + " matrix from file");
            if (isTranspose) matrix = matrix.Transpose();

            //Expects series to run row-wise (first col is names, first row is dates)

            CellOffset offset = new CellOffset();
            offset.cell = o.opt_cell;
            offset.namecell = o.opt_namecell;
            offset.datecell = o.opt_datecell;

            int i_data, j_data, i_names, j_names, i_dates, j_dates;
            HandleRectangularFileFormatCellOffset(offset, isTranspose, out i_data, out j_data, out i_names, out j_names, out i_dates, out j_dates);

            //expects dates to run i a row
            List<DateTime> dateList = new List<DateTime>();
            for (int j = j_dates; j <= matrix.GetColMaxNumber(); j++)
            {
                CellLight c = matrix.Get(i_dates, j);
                if (c.type == ECellLightType.Double)
                {
                    DateTime temp = DateTime.MinValue;
                    try
                    {
                        temp = GekkoTime.FromExcelDateToDateTime(c.data);
                    }
                    catch
                    {
                        new Error("Cell " + Program.GetExcelCell(i_dates, j, isTranspose) + " does not seem to be a date");
                    }

                    if (temp.Year < 1500 || temp.Year > 2500)
                    {
                        new Error("Cell " + Program.GetExcelCell(i_dates, j, isTranspose) + " does not seem to make sense (year = " + temp.Year + ")");
                    }
                    dateList.Add(temp);
                }
                else if (c.type == ECellLightType.DateTime)
                {
                    dateList.Add(c.dateTime);
                }
                else
                {
                    new Error("Expected cell " + Program.GetExcelCell(i_dates, j, isTranspose) + " to be date format, is " + c.type.ToString() + ": '" + c.text + "'");
                    //throw new GekkoException();
                }
            }

            List<string> nameList = new List<string>();
            for (int i = i_names; i <= matrix.GetRowMaxNumber(); i++)
            {
                CellLight c = matrix.Get(i, j_names);
                if (c.type != ECellLightType.String)
                {
                    new Error("Expected cell " + Program.GetExcelCell(i, j_names, isTranspose) + " to be a string, is " + c.type.ToString());
                }
                string s = c.text;
                if (!G.IsSimpleToken(s))
                {
                    new Error("Expected cell " + Program.GetExcelCell(i, j_names, isTranspose) + " to be a variable name, is '" + s + "'");
                }
                nameList.Add(s);
            }

            for (int i = i_data; i <= matrix.GetRowMaxNumber(); i++)
            {
                string varnameWithFreq = G.Chop_AddFreq(nameList[i - i_data], G.ConvertFreq(freq));
                Series ts = new Series(freq, varnameWithFreq);
                Series counter = new Series(freq, null);  //will be discared afterwards but practical here
                Series countNonMissing = new Series(freq, null);  //will be discared afterwards but practical here
                for (int j = j_data; j <= matrix.GetColMaxNumber(); j++)
                {
                    DateTime dt = dateList[j - j_data];
                    CellLight c = matrix.Get(i, j);
                    double v = Program.GetValueFromSpreadsheetCell(isTranspose, i, j, c);
                    GekkoTime gt = GekkoTime.FromDateTimeToGekkoTime(freq, dt);
                    HandleCollapseData(true, ts, counter, countNonMissing, v, gt, emethod);
                }

                if (emethod == ECollapseMethod.Avg)
                {
                    foreach (GekkoTime gt in new GekkoTimeIterator(ts.GetRealDataPeriodFirst(), ts.GetRealDataPeriodLast()))
                    {
                        if (!double.IsNaN(ts.GetDataSimple(gt)))
                        {
                            ts.SetData(gt, ts.GetDataSimple(gt) / counter.GetDataSimple(gt));
                        }
                    }
                }
                else if (emethod == ECollapseMethod.Count)
                {
                    foreach (GekkoTime gt in new GekkoTimeIterator(ts.GetRealDataPeriodFirst(), ts.GetRealDataPeriodLast()))
                    {
                        ts.SetData(gt, counter.GetDataSimple(gt));
                    }
                }

                if (!o.t1.IsNull())
                {
                    ts.Truncate(o.t1, o.t2);
                }

                IVariable ts2a = null; Program.databanks.GetFirst().storage.TryGetValue(varnameWithFreq, out ts2a);
                Series ts2 = ts2a as Series;

                GekkoTime tt1 = ts.GetRealDataPeriodFirst();
                GekkoTime tt2 = ts.GetRealDataPeriodLast();
                if (!tt1.IsNull())
                {
                    //there is some data in ts
                    if (ts2 == null)
                    {
                        Program.databanks.GetFirst().AddIVariable(varnameWithFreq, ts);
                    }
                    else
                    {
                        foreach (GekkoTime gt in new GekkoTimeIterator(tt1, tt2))
                        {
                            ts2.SetData(gt, ts.GetDataSimple(gt));
                        }
                    }
                }
            }

            int vars = matrix.GetRowMaxNumber() - i_data + 1;
            int obs = matrix.GetColMaxNumber() - j_data + 1;
            G.Writeln("Imported " + vars + " timeseries from " + obs + " data points");
        }

        /// <summary>
        /// Helper for GetTimeseriesFromWorkbookMatrix() and CollapsePoints()
        /// </summary>
        /// <param name="o"></param>
        /// <param name="isTranspose"></param>
        /// <param name="i_data"></param>
        /// <param name="j_data"></param>
        /// <param name="i_names"></param>
        /// <param name="j_names"></param>
        /// <param name="i_dates"></param>
        /// <param name="j_dates"></param>
        private static void HandleRectangularFileFormatCellOffset(CellOffset o, bool isTranspose, out int i_data, out int j_data, out int i_names, out int j_names, out int i_dates, out int j_dates)
        {
            if (o.cell == null)
            {
                o.cell = "b2";
            }
            Program.FromXls1Based(o.cell, out i_data, out j_data, isTranspose);

            if (i_data < 2 || j_data < 2)
            {
                new Error("<cell=...> has an illegal value (cannot be first row or column)");
                //throw new GekkoException();
            }
            if (o.namecell == null)
            {
                i_names = i_data;
                j_names = j_data - 1;
            }
            else
            {
                Program.FromXls1Based(o.namecell, out i_names, out j_names, isTranspose);
            }
            if (o.datecell == null)
            {
                i_dates = i_data - 1;
                j_dates = j_data;
            }
            else
            {
                Program.FromXls1Based(o.datecell, out i_dates, out j_dates, isTranspose);
            }

            if (i_data != i_names)
            {
                new Error("Positions " + o.namecell + " for names and " + o.cell + " for data do not correspond");
                //throw new GekkoException();
            }

            if (j_data != j_dates)
            {
                new Error("Positions " + o.datecell + " for names and " + o.cell + " for data do not correspond");
                //throw new GekkoException();
            }
        }

        /// <summary>
        /// Convert from an Excel cell (for instance C2) to two integers, for instance row=2, col=3
        /// </summary>
        /// <param name="s"></param>
        /// <param name="rowOffset"></param>
        /// <param name="colOffset"></param>
        /// <param name="transpose"></param>
        public static void FromXls1Based(string s, out int rowOffset, out int colOffset, bool transpose)
        {
            int index = s.IndexOfAny(new char[] { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9' });
            string chars = s.Substring(0, index);
            int num = Int32.Parse(s.Substring(index));
            if (transpose)
            {
                rowOffset = ExcelColumnNameToNumber(chars);
                colOffset = num;
            }
            else
            {
                rowOffset = num;
                colOffset = ExcelColumnNameToNumber(chars);
            }
        }

        /// <summary>
        /// Gets a text file as a string. Handles UTF8/ANSI encoding.
        /// </summary>
        /// <param name="filename"></param>
        /// <returns></returns>
        public static string GetTextFromFileWithWait(string filename)
        {
            return GetTextFromFileWithWait(filename, true);
        }

        /// <summary>
        /// Gets a text file as a string. Can handle UTF8/ANSI encoding, too. If convertAnyAnsiToUtf8 == false, it will run a bit faster, 
        /// but if the file IS in ANSI format, there will be funny characters. See also FindFile()
        /// </summary>
        /// <param name="filenameMaybeWithoutPath"></param>
        /// <returns></returns>
        public static string GetTextFromFileWithWait(string filenameMaybeWithoutPath, bool convertAnyAnsiToUtf8)
        {
            //Encoding encoding = Encoding.Default;
            String original = String.Empty;

            string filenameOriginal = filenameMaybeWithoutPath;

            //!usually it is already called with a full path, but never mind
            filenameMaybeWithoutPath = CreateFullPathAndFileName(filenameMaybeWithoutPath);

            Encoding current = null;

            bool utf8checker = false;
            using (FileStream fs = WaitForFileStream(filenameMaybeWithoutPath, null, GekkoFileReadOrWrite.Read))
            {
                if (convertAnyAnsiToUtf8) utf8checker = Utf8Checker.IsUtf8(fs);  //NOTE: tastes the file: this may be slow on very large files. So avoid GetTextFromFileWithWait() on databank reading etc. //previously, sr.CurrentEncoding was used, but it is not precise enough to detect UTF8 without BOM mark at start (TextPad for instance)
                fs.Position = 0;  //to rewind
                Encoding encoding = Encoding.Default;
                if (utf8checker) encoding = Encoding.UTF8;
                using (System.IO.StreamReader sr = new System.IO.StreamReader(fs, encoding))
                {
                    original = sr.ReadToEnd();
                    current = sr.CurrentEncoding;
                    sr.Close();
                }
            }

            if (convertAnyAnsiToUtf8)
            {
                string s = null;
                if (utf8checker)
                {
                    s = original;
                }
                else
                {
                    //Convert bytes from ANSI to UTF8
                    byte[] encBytes = current.GetBytes(original);  //'current' will always be equal to 'encoding' I guess, but just for safety
                    byte[] utf8Bytes = Encoding.Convert(current, Encoding.UTF8, encBytes);
                    s = Encoding.UTF8.GetString(utf8Bytes);
                }

                s = s.Replace(Convert.ToChar(160).ToString(), " ");  //non-breaking space
                s = s.Replace(Convert.ToChar(173).ToString(), "");  //soft hyphen

                //the code below is probably too dangerous: what about newlines etc.??
                //s = Regex.Replace(s, @"[^\u0000-\u001F]+", string.Empty);  //see http://stackoverflow.com/questions/123336/how-can-you-strip-non-ascii-characters-from-a-string-in-c, here we use 0-1F, that is: 0-31

                return s;
            }
            else
            {
                return original;
            }
        }

        /// <summary>
        /// Obtains MD5 hash code from (a) string input or (b) a file. 
        /// Re (a): Symbols '=', '+' and '/' in the MD5 are replaced, so MD5 here is not completely standard.
        /// Re (b): Symbol '-' in the MD5 is removed.
        /// Note that (b) is much faster on a file than first getting the file as a string.
        /// You can add salt, for instance if you need to adjust for some state like current frequency.
        /// The two versions are kept in 1 method to keep them together. Probably the internals are identical?
        /// Look at this for Gekko 4.0.
        /// </summary>
        /// <param name="inputText"></param>
        /// <returns></returns>
        public static string GetMD5Hash(string inputText, string fileNameWithPath, string salt)
        {            
            if (inputText != null && fileNameWithPath != null) new Error("Wrong call"); //one of them must be null

            DateTime t0 = DateTime.Now;

            string hash = null;

            if (inputText != null)
            {
                // step 1, calculate MD5 hash from input
                MD5 md5 = MD5.Create();
                byte[] inputBytes = Encoding.UTF8.GetBytes(inputText);  //UTF8 seems best choice
                byte[] hash2 = md5.ComputeHash(inputBytes);
                // step 2, convert byte array to hex string
                StringBuilder sb = new StringBuilder();
                hash = Convert.ToBase64String(hash2).Replace("=", "").Replace("+", "a").Replace("/", "b");
                //We remove empty indicator (=), and replace the two non-alphanumeric as well for simplicity.
                //a Base64-encoding can put 6 bits in each symbol, so that 128 bits become 23 symbols.
                //This is a little better than hex (32 symbols).
            }
            else if (fileNameWithPath != null)
            {
                //tried physically splitting file in n chunks --> 
                //has about same speed as MD5 itself... (0.6 s for a 176 MB file)                
                //also, copying the file with File.Copy is not that much slower than MD5 itself.
                //So we need to use something that operates on the file itself, also cannot put it in
                //byte[] array and operate on this.
                //Maybe just accept it, or wait until a suitable parallel implementation of SHA3.
                //Cannot use xxHash and similar directly, they produce a ulong suitable for Dictionary
                //hashing.
                //In general, allowing READ <type> xx.zip, where file.type is inside the zip would be nice,
                //because then the hashing would be faster. User would have to zip gdx files though.
                //
                //!! actually if xxHash returns 128 bits (uint128), that is actually the same as
                //   MD5. Then the question is about collisions... Maybe when this:
                //   https://github.com/uranium62/xxHash adds stream support for 128 bit hashes.
                //
                using (var md5Instance = MD5.Create())
                {
                    using (var stream = File.OpenRead(fileNameWithPath))
                    {
                        byte[] hash2 = md5Instance.ComputeHash(stream);
                        //hash = BitConverter.ToString(hash2).Replace("-", "").ToLowerInvariant();
                        //the above is longer because it only has 0, 1, 2, ... , 9, a, b, c, d, e, f.
                        hash = Convert.ToBase64String(hash2).Replace("=", "").Replace("+", "a").Replace("/", "b");                        
                    }
                }
            }
            else new Error("Wrong call");
            if (Globals.runningOnTTComputer) new Writeln("TTH: MD5 took " + G.Seconds(t0));
            hash += salt;
            return hash;
        }        

        /// <summary>
        /// RUN command.
        /// </summary>
        /// <param name="o"></param>
        public static void Run(O.Run o)
        {
            bool cancel = false;
            string fileName = o.fileName;
            if (fileName == "*")
            {
                Program.SelectFile(Globals.extensionCommand, ref fileName, ref cancel);
            }
            if (cancel) return;

            if (Globals.pink && fileName != null && (fileName.ToLower().Contains("g:\\datopgek\\") || fileName.ToLower().Contains("g:/datopgek/")))
            {
                Globals.datopgek_errors.Add("Running this command file: " + fileName);
            }

            RunHelper(o, fileName);
        }

        /// <summary>
        /// Does the actual smoothing, cf. SMOOTH or smooth()
        /// </summary>
        /// <param name="lhs"></param>
        /// <param name="rhs"></param>
        /// <param name="method"></param>
        /// <param name="overlay"></param>
        public static void SmoothHelper(Series lhs, Series rhs, ESmoothTypes method, Series overlay)
        {
            Series newSeriesTemp = rhs.DeepClone(null) as Series;  //brand new object, not present in Work (yet)                

            GekkoTime realStart = rhs.GetRealDataPeriodFirst();
            GekkoTime realEnd = rhs.GetRealDataPeriodLast();

            if (realStart.IsNull())
            {
                //do nothing, the lhs series is not touched (but may be created here)
                new Warning("Smooth of '" + rhs.name + "', method = " + method.ToString().ToLower() + " (" + rhs.name + " has no data)");
            }
            else
            {
                //this works okay if the rhs series has only 1 observation
                if (method == ESmoothTypes.Spline)
                {
                    int counter = -1;  //this can actually be an arbitrary number, but we start with 0.
                    List<double> xx = new List<double>();
                    List<double> yy = new List<double>();
                    List<int> missings = new List<int>();
                    List<GekkoTime> missingsDates = new List<GekkoTime>();
                    foreach (GekkoTime gt in new GekkoTimeIterator(realStart, realEnd))
                    {
                        counter++;
                        double data = rhs.GetDataSimple(gt);
                        if (G.isNumericalError(data))
                        {
                            missings.Add(counter);
                            missingsDates.Add(gt);
                            continue;  //ignore this observation
                        }
                        yy.Add(rhs.GetDataSimple(gt));
                        xx.Add(counter);
                    }

                    double[] x = xx.ToArray();
                    double[] y = yy.ToArray();

                    alglib.spline1dinterpolant s;
                    alglib.spline1dbuildcubic(x, y, out s);
                    for (int i = 0; i < missings.Count; i++)
                    {
                        newSeriesTemp.SetData(missingsDates[i], alglib.spline1dcalc(s, missings[i]));
                    }

                    //AREMOS spline, fits parabola nicely. Gekko gives the same on this input data (left column)
                    //2000       1.000000000000000     1.000000000000000
                    //2001                      NC     0.562500000000000
                    //2002       0.250000000000000     0.250000000000000
                    //2003                      NC     0.062500000000000
                    //2004       0.000000000000000     0.000000000000000
                    //2005                      NC     0.062500000000000
                    //2006       0.250000000000000     0.250000000000000
                    //2007                      NC     0.562500000000000
                    //2008       1.000000000000000     1.000000000000000                 
                }
                else if (method == ESmoothTypes.Linear || method == ESmoothTypes.Repeat || method == ESmoothTypes.Geometric)
                {
                    GekkoTime missingStart = GekkoTime.tNull;
                    bool recording = false;
                    foreach (GekkoTime gt in new GekkoTimeIterator(realStart, realEnd))
                    {
                        //realStart and realEnd can not be tNull here
                        double z = rhs.GetDataSimple(gt);
                        if (G.isNumericalError(z))
                        {
                            if (!recording)
                            {
                                missingStart = gt;
                                recording = true;
                            }
                            continue;
                        }

                        if (recording)
                        {
                            GekkoTime t1 = missingStart.Add(-1);
                            GekkoTime t2 = gt;
                            double z1 = rhs.GetDataSimple(t1);
                            double z2 = rhs.GetDataSimple(t2);
                            double n = t2.Subtract(t1);
                            if (method == ESmoothTypes.Geometric)
                            {
                                if (z1 <= 0d || z2 <= 0d)
                                {
                                    new Error("Geometric smoothing not intended for numbers <= 0");
                                }
                            }
                            double counterLinear = z1;
                            double counterLinearA = (z2 - z1) / n;
                            double counterGeometric = z1;
                            double counterGeometricA = Math.Pow((z2 / z1), 1d / n);

                            foreach (GekkoTime gt2 in new GekkoTimeIterator(t1.Add(1), t2.Add(-1)))
                            {
                                if (method == ESmoothTypes.Repeat)
                                {
                                    newSeriesTemp.SetData(gt2, z1);
                                }
                                else if (method == ESmoothTypes.Linear)
                                {
                                    counterLinear += counterLinearA;
                                    newSeriesTemp.SetData(gt2, counterLinear);
                                }
                                else if (method == ESmoothTypes.Geometric)
                                {
                                    counterLinear *= counterGeometricA;
                                    newSeriesTemp.SetData(gt2, counterLinear);
                                }
                                else throw new GekkoException();
                            }
                            recording = false;
                            missingStart = GekkoTime.tNull;
                        }
                    }
                }
                else if (method == ESmoothTypes.Overlay)
                {
                    if (overlay == null) new Error("For smoothing with overlay method, you need to input a timeseries as argument");

                    GekkoTime realStartOverlay = overlay.GetRealDataPeriodFirst();
                    GekkoTime realEndOverlay = overlay.GetRealDataPeriodLast();

                    if (realStartOverlay.IsNull())
                    {
                        new Warning("The overlay series '" + overlay.GetName() + "' has no observations");
                    }
                    else
                    {
                        foreach (GekkoTime gt in new GekkoTimeIterator(realStartOverlay, realEndOverlay))
                        {
                            //realStart and realEnd can not be tNull here
                            double z = rhs.GetDataSimple(gt);
                            if (G.isNumericalError(z))
                            {
                                newSeriesTemp.SetData(gt, overlay.GetDataSimple(gt));
                            }
                        }
                    }
                }
                else throw new GekkoException();

                foreach (GekkoTime gt in new GekkoTimeIterator(realStart, realEnd))
                {
                    //This is not terribly efficient, and we could use array copy etc.
                    //And we do create and clone a whole new timeseries (newSeriesTemp).
                    //But it works, and speed is probably not an issue with SMOOTH.
                    lhs.SetData(gt, newSeriesTemp.GetDataSimple(gt));
                }
                lhs.Stamp();
                lhs.SetDirty(true);
            }
        }

        /// <summary>
        /// Helper for Run(). Will search for .gcm (RUN) file in OPTION folder command|command1|command2.
        /// </summary>
        /// <param name="o"></param>
        public static void RunHelper(O.Run o, string fileName)
        {
            string s = fileName;
            s = G.StripQuotes(s);
            s = G.AddExtension(s, "." + Globals.extensionCommand);

            List<string> folders = new List<string>();
            folders.Add(Program.options.folder_command);
            folders.Add(Program.options.folder_command1);
            folders.Add(Program.options.folder_command2);

            FindFileHelper ffh = FindFile(s, folders, true, true, o.p);  //also calls CreateFullPathAndFileName()
            string fileName2 = ffh.realPathAndFileName;

            if (fileName2 == null)
            {
                //calling RUN gekko.ini here manually will fail if the file does not exist, which is fine
                new Error("Could not find file: " + ffh.prettyPathAndFileName);
            }

            Program.RunGekkoCommands("", fileName2, (int)o.opt_skip, o.p);

            if (G.Equal(s, Globals.autoExecCmdFileName))
            {
                G.Writeln();
                G.Writeln("Finished running INI file ('" + Path.GetFileName(Globals.cmdPathAndFileName) + "') from working folder");
            }
        }

        /// <summary>
        /// See CreateFullPathAndFileNameFromFolder(). Will add working folder. Does not taste any files: this is pure string manipulation.
        /// </summary>
        /// <param name="s"></param>
        /// <returns></returns>
        public static string CreateFullPathAndFileName(string s)
        {
            return CreateFullPathAndFileNameFromFolder(s, null);
        }

        /// <summary>
        /// Will add working folder for simple filename input. Does not taste any files: this is pure string manipulation.
        /// </summary>
        /// <param name="file"></param>
        /// <param name="folder"></param>
        /// <returns></returns>
        public static string CreateFullPathAndFileNameFromFolder(string file, string folder)
        {
            // TODO: If file contains a subfolder (like "\sub1\xx.csv), this is ok for working folder, but when called with for
            // instance folder \command1, \command2 etc., it should not be allowed to glue these on for instance \sub1\xx.csv.
            // Not super important. Maybe consider this for Gekko 4.0...

            //This method can be called with path = null or path = "", in that case it reduces to
            //only adding the working folder if file is without colon.
            //Path is given from options: "option folder bank = ..." for instance
            //String is user input.
            //RULES:
            //If file includes ":\" or starts with "\\"
            //   return = file
            //else
            //   if path includes ":\" or starts with "\\"
            //      return = path + file
            //   else
            //      return working_folder + path + file
            //   end
            //end
            //
            //    +++           If path = null or path = "", the above reduces to this:
            //    +++           If file includes ":\" or starts with "\\"
            //    +++              return = file
            //    +++           else
            //    +++              return working_folder + "" + file (i.e. working_folder + file)
            //    +++           end
            //
            if (folder == null) folder = "";
            if (file == null)
            {
                new Error("Expected a file name, but it is not defined");
            }

            file = file.Trim(); //Most probably not necessary, but better safe than sorry
            folder = folder.Trim(); //Most probably not necessary, but better safe than sorry
            string fileName2 = "";
            if (file.Contains(":\\") || file.StartsWith("\\\\") || IsLibraryWithColonName(file))  //either 'c:\...' or '\\server1\...' or 'lib1:data.csv'
            {
                fileName2 = file;
            }
            else
            {
                if (folder.Contains(":\\") || folder.StartsWith("\\\\"))   //either 'c:\...' or '\\server1\...'
                {
                    fileName2 = folder + "\\" + file;
                }
                else
                {
                    fileName2 = Program.options.folder_working + "\\" + folder + "\\" + file;  //path may be = "", and workingFolder may end with "\\", and file may start with "\\" --> 4 successive "\\" to be reduced later on
                }
            }

            bool isUNC = false;
            if (fileName2.StartsWith("\\\\"))
            {
                isUNC = true;
                fileName2 = fileName2.Substring(2);
            }

            while (true)
            {
                int count = fileName2.Length;
                fileName2 = fileName2.Replace("\\\\", "\\");
                if (count == fileName2.Length) break;  //keeps on going until nothing more to substitute
            }

            if (isUNC) fileName2 = "\\\\" + fileName2;

            string rv = O.ResolvePath(fileName2);

            return rv;  //see https://stackoverflow.com/questions/970911/net-remove-dots-from-the-path
        }

        /// <summary>
        /// The DISP command.
        /// </summary>
        /// <param name="tStart"></param>
        /// <param name="tEnd"></param>
        /// <param name="list"></param>
        /// <param name="o"></param>
        public static void Disp(GekkoTime tStart, GekkoTime tEnd, List<string> list, O.Disp o)
        {
            Disp(tStart, tEnd, list, false, false, false, o);
        }

        /// <summary>
        /// Searches for text parts in the variable list (loaded with a model). For instance, DISP 'balance of payments'; will search all variable labels
        /// and return those variables containing the string. Note: this is different from wildcards regarding variable names.
        /// </summary>
        /// <param name="s"></param>
        public static void DispSearch(string s)
        {
            Databank db = Program.databanks.GetFirst();

            int widthRemember = Program.options.print_width;
            Program.options.print_width = int.MaxValue;
            try
            {
                s = G.StripQuotes(s);

                List<string> vars = new List<string>();
                List<string> expl = new List<string>();
                //List<string> both = new List<string>();
                GekkoDictionary<string, string> both2 = new GekkoDictionary<string, string>(StringComparer.OrdinalIgnoreCase);

                //bool differentFreq = false;

                if (Program.model?.modelGekko?.modelInfo?.varlist != null && Program.model.modelGekko.modelInfo.varlist.Count > 0)
                {
                    List<string> explanation = new List<string>();
                    if (Program.model?.modelGekko?.modelInfo?.varlist == null) return;

                    foreach (Program.Item item in Program.model.modelGekko.modelInfo.varlist)
                    {
                        string ss = "";
                        if (item.explanation.Count > 0) ss = item.explanation[0];
                        if (G.Contains(ss, s))
                        {
                            if (!both2.ContainsKey(item.variable)) both2.Add(item.variable, ss);
                        }
                    }
                }

                if (true)
                {
                    //try variable labels
                    foreach (IVariable iv in db.storage.Values)
                    {
                        Series ts = iv as Series;
                        if (ts == null) continue;
                        if (Program.options.freq != ts.freq) continue;
                        string label = ts?.meta.label;
                        if (label == null) continue;
                        if (G.Contains(label, s))
                        {
                            string s3 = G.Chop_RemoveFreq(ts.name);
                            if (!both2.ContainsKey(s3)) both2.Add(s3, label);
                        }
                    }
                }

                int max = 0;
                foreach (string k in both2.Keys)
                {
                    max = Math.Max(max, k.Length);
                }
                max = Math.Max(max, "Variable".Length);

                int max2 = 0;
                foreach (string k in both2.Values)
                {
                    max2 = Math.Max(max2, k.Length);
                }

                List<string> lines = new List<string>();
                foreach (KeyValuePair<string, string> kvp in both2)
                {
                    lines.Add(kvp.Key + "¤" + kvp.Value);
                }
                lines.Sort(StringComparer.OrdinalIgnoreCase);

                if (lines.Count > 0)
                {
                    string w = "Variable" + G.Blanks(max - "Variable".Length + 2) + "Label";
                    string w2 = new string('-', max + max2 + 2);
                    G.Writeln();
                    G.Writeln(w);
                    G.Writeln(w2);

                    foreach (string xx in lines)
                    {
                        if (Globals.threadIsInProcessOfAborting) throw new GekkoException();
                        string[] xxx = xx.Split('¤');
                        G.WriteLink(xxx[0], "disp:" + xxx[0]);
                        G.Write(G.Blanks(max - xxx[0].Length + 2));
                        G.Writeln(xxx[1]);
                    }
                    G.Writeln(w2);
                    G.Writeln();
                }
                else
                {
                    G.Writeln2("The string '" + s + "' did not match any variable labels");
                }
            }
            finally
            {
                //resetting, also if there is an error
                Program.options.print_width = widthRemember;
            }

            return;
        }

        /// <summary>
        /// The DISP command. Wildcards can be used, like DISP x*; Wildcards use Program.Search().
        /// </summary>
        /// <param name="tStart"></param>
        /// <param name="tEnd"></param>
        /// <param name="list"></param>
        /// <param name="showDetailed"></param>
        /// <param name="showAllPeriods"></param>
        /// <param name="clickedLink"></param>
        /// <param name="o"></param>
        public static void Disp(GekkoTime tStart, GekkoTime tEnd, List<string> list, bool showDetailed, bool showAllPeriods, bool clickedLink, O.Disp o)
        {
            int nonSeries = 0;

            GekkoSmpl smpl = new GekkoSmpl(tStart, tEnd);

            Globals.dispLastDispStart = tStart; //kept if user chooses to click a link -- in that case we want to use same time settings
            Globals.dispLastDispEnd = tEnd; //kept if user chooses to click a link

            int seriesCounter = 0;

            List<string> names = null;

            List<IVariable> m = new List<IVariable>();
            if (list != null)
            {
                //seems list is always null when called from command
                foreach (string listItem in list)
                {
                    IVariable x = O.GetIVariableFromString(listItem, O.ECreatePossibilities.NoneReportError, true);
                    m.Add(x);
                }
            }
            else
            {
                //See also #87582903573829
                names = Program.Search(o.iv, null, EVariableType.Var);
                foreach (string s in names)
                {
                    m.Add(O.GetIVariableFromString(s, O.ECreatePossibilities.NoneReportError, true));
                }
            }

            for (int i5 = 0; i5 < m.Count; i5++)
            {

                IVariable x = m[i5];
                string name = null;
                if (names != null) name = names[i5];
                else name = list[i5];

                //one listitem could be obk:fx*, fy, #m, obk:#m, @fy

                Series ts = x as Series;

                if (ts == null)
                {
                    NonSeriesHelper helper = new NonSeriesHelper();
                    PrintNonSeries(x, null, 0, helper);
                    helper.Message();
                    nonSeries++;
                    continue;
                }
                else
                {

                    seriesCounter++;

                    string variableMaybeWithFreq = null;
                    string bank = null;
                    if (name == null)
                    {
                        variableMaybeWithFreq = ts.GetName();
                        bank = ts.GetParentDatabank().name;
                    }
                    else
                    {
                        variableMaybeWithFreq = name;
                        bank = ts.GetParentDatabank().name;
                    }

                    if (Program.model.modelCommon.GetModelSourceType() == EModelType.GAMSRaw || Program.model.modelCommon.GetModelSourceType() == EModelType.GAMSScalar)
                    {
                        DispGams(tStart, tEnd, showDetailed, showAllPeriods, clickedLink, true, ts, variableMaybeWithFreq, bank);
                    }
                    else
                    {
                        DispNonGams(tStart, tEnd, showDetailed, showAllPeriods, clickedLink, ts, variableMaybeWithFreq, bank);
                    }
                }
            }

            if (seriesCounter + nonSeries == 0)
            {
                G.Writeln2("Did not find any variable(s) to display");

                //See also #87582903573829
                SearchHelper1 helper = Program.SearchAllBanksAllFreqs(o.iv, null, EVariableType.Var);
                if (helper.allBanks.count > 0) G.Writeln("Note: " + helper.allBanks.name + " instead of " + helper.allBanks.nameOriginal + " --> " + helper.allBanks.count + " matches");
                if (helper.allFreqs.count > 0) G.Writeln("Note: " + helper.allFreqs.name + " instead of " + helper.allFreqs.nameOriginal + " --> " + helper.allFreqs.count + " matches");
                if (helper.allBanksAndFreqs.count > helper.allBanks.count + helper.allFreqs.count) G.Writeln("Note: " + helper.allBanksAndFreqs.name + " instead of " + helper.allBanksAndFreqs.nameOriginal + " --> " + helper.allBanksAndFreqs.count + " matches");
            }
            else if (seriesCounter == 0 && nonSeries > 0)
            {
                //nomessage
            }
            else
            {
                if (seriesCounter + nonSeries > 1)
                {
                    G.Writeln2("Displayed " + (seriesCounter + nonSeries) + " variables");
                }

            }

        }


        /// <summary>
        /// DISP for Gekko equations
        /// </summary>
        /// <param name="tStart"></param>
        /// <param name="tEnd"></param>
        /// <param name="showDetailed"></param>
        /// <param name="showAllPeriods"></param>
        /// <param name="clickedLink"></param>
        /// <param name="ts"></param>
        /// <param name="bank"></param>
        /// <param name="varnameWithoutFreq"></param>
        private static void DispNonGams(GekkoTime tStart, GekkoTime tEnd, bool showDetailed, bool showAllPeriods, bool clickedLink, Series ts, string varnameMaybeWithFreq, string bank)
        {
            //ADAM-style, normal timeseries

            string varnameWithoutFreq = G.Chop_RemoveFreq(varnameMaybeWithFreq);

            string note = null;

            bool isTimeless = ts.type == ESeriesType.Timeless;

            G.Writeln();
            G.Writeln("==========================================================================================");
            G.Writeln("SERIES " + bank + Globals.symbolBankColon + " " + ts.GetNameWithoutCurrentFreq(true));
            if (true)
            {
                EEndoOrExo type1 = VariableTypeEndoExo(varnameWithoutFreq);
                string type3 = "";
                if (type1 == EEndoOrExo.Exo) type3 = "Exogenous, ";
                else if (type1 == EEndoOrExo.Endo) type3 = "Endogenous, ";

                string freq = "[unknown frequency]";

                freq = ts.freq.Pretty();

                bool noData = ts.IsNullPeriod(); //We are opening up to this possibility of 'empty' data                    

                GekkoTime first = ts.GetRealDataPeriodFirst();
                GekkoTime last = ts.GetRealDataPeriodLast();

                G.Write(type3);
                string stamp = null;
                if (ts.meta.stamp != null && ts.meta.stamp != "") stamp = " (updated: " + ts.meta.stamp + ")";

                if (ts.type == ESeriesType.ArraySuper)
                {
                    //do not print any data period here, this is calculated for the sub-series in code further down.
                }
                else
                {
                    if (ts.freq == EFreq.A || ts.freq == EFreq.U)
                    {
                        if (noData || first.super == -12345 || last.super == -12345)
                        {
                            G.Writeln(freq + ", no data period");
                        }
                        else
                        {
                            //we don't want 1995a1 to 2005a1, instead 1995 to 2005
                            G.Writeln(freq + " data from " + first.super + " to " + last.super + stamp);
                        }
                    }
                    else
                    {
                        if (noData || first.super == -12345 || last.super == -12345)
                        {
                            G.Writeln(freq + ", no data period");
                        }
                        else
                        {
                            G.Writeln(freq + " data from " + first.ToString() + " to " + last.ToString() + stamp);
                        }
                    }
                }

                List<string> expls = Program.GetVariableExplanation(varnameWithoutFreq, varnameMaybeWithFreq, false, false, GekkoTime.tNull, GekkoTime.tNull, null);
                foreach (string expl in expls) G.Writeln(expl);

                bool eqsPrinted = false;
                List<MultidimItem> keys = null;
                GekkoDictionary<string, string>[] temp = null;
                if (ts.type == ESeriesType.ArraySuper)
                {
                    keys = ts.dimensionsStorage.storage.Keys.ToList();
                    keys.Sort(Multidim.CompareMultidimItems);
                    temp = new GekkoDictionary<string, string>[ts.dimensions];
                }

                if (!G.IsUnitTesting()) Gui.gui.GuiBrowseArrowsStuff(varnameWithoutFreq, clickedLink, 0);

                if (G.GetModelSourceType() == EModelType.Gekko)
                {
                    DispHelperShowNormalEquation(showDetailed, varnameWithoutFreq);
                }
                else
                {
                    if (Program.model.modelGams?.equationsByVarname != null)
                    {
                        note = "+++ NOTE: There is a GAMS model loaded, perhaps you should use 'OPTION model type = gams;'?";
                    }
                }

                if (ts.dimensions > 0)
                {
                    DispHelperArraySeries(ts, keys, eqsPrinted);
                }
                else
                {
                    DispHelperNormalSeries(tStart, tEnd, showAllPeriods, ts, varnameWithoutFreq, isTimeless);
                }

                G.Writeln("==========================================================================================");
                if (note != null) G.Writeln(note);
            }
        }

        /// <summary>
        /// DISP for Gekko equations
        /// </summary>
        /// <param name="showDetailed"></param>
        /// <param name="varnameWithoutFreq"></param>
        private static void DispHelperShowNormalEquation(bool showDetailed, string varnameWithoutFreq)
        {
            List<string> d4 = new List<string>();
            if (Program.model?.modelGekko?.dependents != null && Program.model.modelGekko.dependents.ContainsKey(varnameWithoutFreq))
            {
                Dictionary<string, string> d2 = Program.model.modelGekko.dependents[varnameWithoutFreq].storage;
                if (d2 != null)
                {
                    foreach (string d3 in d2.Keys)
                    {
                        d4.Add(d3);
                    }
                }
                d4.Sort(StringComparer.InvariantCulture);
            }

            EquationHelper found = Program.FindEquationByMeansOfVariableName(varnameWithoutFreq);

            if (found != null && found.modelBlock != null && found.modelBlock != "" && found.modelBlock != "Unnamed")
            {
                G.Writeln("Modelblock: " + found.modelBlock);
            }

            G.Write("Influences: ");
            if (d4.Count == 0) G.Writeln("<none>");
            else
            {
                G.PrintListWithCommas(d4, true);
            }

            G.Writeln("------------------------------------------------------------------------------------------");

            if (found != null)
            {
                int widthRemember = Program.options.print_width;
                Program.options.print_width = int.MaxValue;
                try
                {
                    //check for endo (but really not necessary, exo just does not exist)
                    //G.Writeln(found.equationFormula);
                    string strSplit = found.equationText;
                    strSplit = strSplit.Replace("\r\n", "£");  //hack: £ unlikely to be used much
                    char[] arrDelimiters = new char[] { ' ', '(', ')', '=', '+', '-', '*', '/', ',', ';', '$', '£' };  //last one is part of new line (\r\n)
                    List<string> alWork = Program.SplitStringAndKeepDelimiters(strSplit, arrDelimiters);
                    foreach (string s in alWork)
                    {
                        if (s == "£") G.Writeln();
                        else
                        {
                            if (Program.model.modelGekko.varsAType.ContainsKey(s))
                            {
                                //seems the word exists as variable
                                G.WriteLink(s, "disp:" + s);
                            }
                            else
                            {
                                G.Write(s);
                            }
                        }
                    }
                    G.Writeln();
                }
                finally
                {
                    //resetting, also if there is an error
                    Program.options.print_width = widthRemember;
                }

                G.Writeln("------------------------------------------------------------------------------------------");
                
                if (showDetailed)
                {
                    G.Writeln(Program.GetHumanReadableDetailedEquation(found) + ";");
                }
                else
                {
                    G.WriteLink("Show detailed equation", "disp2:" + varnameWithoutFreq);
                    G.Writeln();
                }
            }
        }

        /// <summary>
        /// Gets an equation like "phk = exp(phk[-1]) * (...) * (1 + JRphk)", with functions like dlog() etc. resolved.
        /// This code is produced by the .frm parser, but in contrast to the equations used by C#, there
        /// are no (or few) superfluous parentheses. These are set intelligently while parsing, but for 
        /// computer C# use, a lot of parentheses are kept for safety. So worst case, the equations produced
        /// here may be wrong, but the logic is probably ok.
        /// Output does not end with a ";".
        /// </summary>
        /// <param name="eh"></param>
        /// <returns></returns>
        public static string GetHumanReadableDetailedEquation(EquationHelper eh)
        {
            return eh.codeLhsHumanVersion.Trim().Replace("[0]", "") + " = " + eh.codeRhsHumanVersion.Trim().Replace("[0]", "");
        }

        /// <summary>
        /// DISP for GAMS equations.
        /// </summary>
        /// <param name="tStart"></param>
        /// <param name="tEnd"></param>
        /// <param name="showDetailed"></param>
        /// <param name="showAllPeriods"></param>
        /// <param name="clickedLink"></param>
        /// <param name="gamsToGekko"></param>
        /// <param name="ts"></param>
        /// <param name="variableMaybeWithFreq"></param>
        /// <param name="bank"></param>
        /// <param name="varnameWithoutFreq"></param>
        private static void DispGams(GekkoTime tStart, GekkoTime tEnd, bool showDetailed, bool showAllPeriods, bool clickedLink, bool gamsToGekko, Series ts, string variableMaybeWithFreq, string bank)
        {
            string varnameWithoutFreq = G.Chop_RemoveFreq(variableMaybeWithFreq);

            string note = null;

            string s2 = "[" + Stringlist.GetListWithCommas(ts.meta.domains) + "]";
            if (s2 == "[]") s2 = null;

            bool isTimeless = ts.type == ESeriesType.Timeless;

            string ss = "SERIES";
            if (ts.type == ESeriesType.ArraySuper) ss = "ARRAY-SERIES";
            G.Writeln2("==========================================================================================");
            G.Writeln(ss + " " + bank + Globals.symbolBankColon + " " + varnameWithoutFreq + s2);

            List<string> expls = Program.GetVariableExplanation(varnameWithoutFreq, varnameWithoutFreq, false, false, GekkoTime.tNull, GekkoTime.tNull, null);
            foreach (string expl in expls) G.Writeln(expl);

            if (ts.type == ESeriesType.ArraySuper)
            {

            }
            else
            {
                if (ts.mmi != null)
                {
                    //then it is a sub-series
                    Series parent = ts.mmi.parent;
                    if (parent != null)
                    {
                        //if (!G.NullOrBlanks(parent.meta.label)) G.Writeln(parent.meta.label);
                        if (parent.meta.fix == EFixedType.Parameter)
                        {
                            G.Writeln("Fixed (parameter)");
                        }
                    }
                }

                if (isTimeless)
                {
                    if (ts.meta.fix == EFixedType.Timeless)
                    {
                        G.Writeln("Fixed: " + Globals.fixedTimelessText);
                    }
                }
                else
                {
                    if (ts.meta.fix == EFixedType.Normal)
                    {
                        string s = ts.meta.fixedNormal.ToString();  //fixedNormal does exist if EFixedType.Normal
                        G.Writeln("Fixed: " + s);
                    }
                }
            }

            List<MultidimItem> keys = null;

            if (ts.type == ESeriesType.ArraySuper)
            {
                keys = ts.dimensionsStorage.storage.Keys.ToList();
                keys.Sort(Multidim.CompareMultidimItems);
            }

            bool eqsPrinted = false;

            if (Program.model.modelGams != null)
            {
                if (Program.model.modelGams.equationsByVarname != null)
                {
                    eqsPrinted = DispHelperShowGamsEquations(showDetailed, clickedLink, gamsToGekko, variableMaybeWithFreq, varnameWithoutFreq, eqsPrinted);
                }
            }
            else
            {
                if (Program.model?.modelGekko?.equations != null)
                {
                    note = "+++ NOTE: There is a normal model loaded, perhaps you should use 'OPTION model type = default;'?";
                }
            }

            if (ts.dimensions > 0)
            {
                DispHelperArraySeries(ts, keys, eqsPrinted);
            }
            else
            {
                DispHelperNormalSeries(tStart, tEnd, showAllPeriods, ts, varnameWithoutFreq, isTimeless);                
            }

            if (G.GetModelSourceType() == EModelType.GAMSScalar)
            {
                //we try to fetch equation names
            }

            G.Writeln("==========================================================================================");

            if (note != null) G.Writeln(note);
        }

        /// <summary>
        /// Check whether a variable is part of a GAMS model
        /// </summary>
        /// <param name="var"></param>
        /// <returns></returns>
        public static bool HasGamsEquation(string var, Model model)
        {
            if (var == null) return false;
            return Program.model.modelGams?.equationsByVarname != null && Program.model.modelGams.equationsByVarname.ContainsKey(var);
        }

        /// <summary>
        /// Overload, global model.
        /// </summary>
        /// <param name="var"></param>
        /// <returns></returns>
        public static bool HasGamsEquation(string var)
        {
            return HasGamsEquation(var, Program.model);
        }

        /// <summary>
        /// DISP for GAMS equations
        /// </summary>
        /// <param name="showDetailed"></param>
        /// <param name="clickedLink"></param>
        /// <param name="gamsToGekko"></param>
        /// <param name="var"></param>
        /// <param name="varnameWithoutFreq"></param>
        /// <param name="eqsPrinted"></param>
        /// <returns></returns>
        private static bool DispHelperShowGamsEquations(bool showDetailed, bool clickedLink, bool gamsToGekko, string var, string varnameWithoutFreq, bool eqsPrinted)
        {
            string varnameWithoutFreqAndIndex = G.Chop_RemoveIndex(varnameWithoutFreq);

            GekkoDictionary<string, string> dependents = new GekkoDictionary<string, string>(StringComparer.OrdinalIgnoreCase);
            foreach (KeyValuePair<string, List<ModelGamsEquation>> e4 in Program.model.modelGams.equationsByVarname)
            {
                foreach (ModelGamsEquation e5 in e4.Value)
                {
                    GekkoDictionary<string, string> knownVars2 = GetKnownVars(e5.rhsGams);
                    if (knownVars2.ContainsKey(varnameWithoutFreqAndIndex) && !dependents.ContainsKey(e4.Key))
                    {
                        dependents.Add(e4.Key, null);
                    }
                }
            }

            List<string> precedents2 = new List<string>();
            precedents2.AddRange(dependents.Keys);
            precedents2.Sort();

            if (precedents2.Count > 0)
            {
                G.Write("Variable " + varnameWithoutFreqAndIndex + " influences: ");
                int counter = -1;
                foreach (string s in precedents2)
                {
                    counter++;
                    if (counter > 0)
                    {
                        G.Write(", ");
                    }
                    G.WriteLink(s, "disp:" + s);
                }
                G.Writeln();
            }

            List<ModelGamsEquation> eqs = GamsModel.GetGamsEquationsByVarname(varnameWithoutFreqAndIndex, model);

            if (G.IsUnitTesting())
            {
                Globals.unitTestDependents = new List<string>();
                if (eqs != null)
                {
                    foreach (ModelGamsEquation eq in eqs)
                    {
                        Globals.unitTestDependents.Add(eq.nameGams);
                    }
                }
            }

            if (eqs != null && eqs.Count > 0)
            {
                if (G.Chop_HasIndex(varnameWithoutFreq) && eqs.Count > 1)
                {
                    new Note("Some of the following equations may relate to other elements of " + varnameWithoutFreqAndIndex + " than " + varnameWithoutFreq);
                }

                PrintEquationWithLinks(gamsToGekko, varnameWithoutFreqAndIndex, eqs, showDetailed);
                eqsPrinted = true;

                if (!showDetailed)
                {
                    G.Writeln();
                    G.WriteLink("Show GAMS equation" + G.S(eqs.Count), "disp2:" + var);
                    G.Writeln();
                }
            }

            if (!G.IsUnitTesting()) Gui.gui.GuiBrowseArrowsStuff(varnameWithoutFreqAndIndex, clickedLink, 0);
            return eqsPrinted;
        }

        /// <summary>
        /// For DISP (both Gekko and GAMS equations), show info on array-series, dimensions, etc.
        /// </summary>
        /// <param name="ts"></param>
        /// <param name="keys"></param>
        /// <param name="eqsPrinted"></param>
        private static void DispHelperArraySeries(Series ts, List<MultidimItem> keys, bool eqsPrinted)
        {
            // --------------
            // Array-series
            // --------------

            GekkoTime t1 = GekkoTime.tNull;
            GekkoTime t2 = GekkoTime.tNull;

            foreach (IVariable iv in ts.dimensionsStorage.storage.Values)
            {
                Series ts2 = iv as Series;
                if (ts == null || ts.freq != ts2.freq) continue;
                GekkoTime tt1 = ts2.GetRealDataPeriodFirst();
                GekkoTime tt2 = ts2.GetRealDataPeriodLast();
                if (tt1.StrictlySmallerThan(t1)) t1 = tt1;
                if (tt2.StrictlyLargerThan(t2)) t2 = tt2;
            }

            string period = null;
            if (t1.IsNull() || t2.IsNull())
            {
                //skip period
            }
            else
            {
                period = " (period " + t1.ToString() + " - " + t2.ToString() + ")";
            }

            if (eqsPrinted) G.Writeln("");

            G.Writeln(ts.freq.Pretty() + " series has " + keys.Count + " elements in " + ts.dimensions + " dimensions" + period);

            double dimCount2 = 1d;
            string dimCount = null;
            List<List<string>> elements = new List<List<string>>();
            List<string> domains = new List<string>();
            DispHelperArraySeries2(ts, keys, ref dimCount2, ref dimCount, elements, domains);

            dimCount = dimCount.Substring(0, dimCount.Length - " * ".Length);
            for (int i = 0; i < ts.dimensions; i++)
            {
                if (elements[i].Count > 0)
                {
                    G.Writeln("Dimension " + (i + 1) + " (" + domains[i] + elements[i].Count + " elements): " + Stringlist.GetListWithCommas(elements[i]));
                }
            }

            if (keys == null || keys.Count == 0)
            {
                //do nothing
            }
            else
            {
                MultidimItem mm = keys[0];
                string first = keys[0].ToString();
                string last = keys[keys.Count - 1].ToString();

                G.Writeln("First/last elements (alphabetically): " + G.Chop_RemoveFreq(ts.name) + "[" + first + "]" + " ... " + G.Chop_RemoveFreq(ts.name) + "[" + last + "]");
                if (ts.dimensions > 1)
                {
                    G.Writeln("Dimension span: " + dimCount + " = " + dimCount2 + ", density: " + keys.Count + "/" + dimCount2 + " = " + Program.NumberFormat(100d * (keys.Count / dimCount2), "0.00") + "%");
                }

                int countFix = 0;
                foreach (KeyValuePair<MultidimItem, IVariable> kvp in ts.dimensionsStorage.storage)
                {
                    Series sub = kvp.Value as Series;
                    if (sub.meta.fix == EFixedType.Timeless || sub.meta.fix == EFixedType.Normal) countFix++;
                }
                if (countFix > 0)
                {
                    string name = ts.GetName();
                    G.Write("Fixed: " + countFix + " out of " + ts.dimensionsStorage.storage.Count + " elements (");
                    G.WriteLink("more", "dispfix:" + name);
                    G.Writeln(")");
                }
                if (ts.meta.fix == EFixedType.Parameter)
                {
                    G.Writeln("Fixed (parameter)");
                }


            }
        }

        /// <summary>
        /// Helper for DISP, and also used in Functions.getelements()
        /// </summary>
        /// <param name="ts"></param>
        /// <param name="keys"></param>
        /// <param name="dimCount2"></param>
        /// <param name="dimCount"></param>
        /// <param name="elements"></param>
        /// <param name="domains"></param>
        public static void DispHelperArraySeries2(Series ts, List<MultidimItem> keys, ref double dimCount2, ref string dimCount, List<List<string>> elements, List<string> domains)
        {
            GekkoDictionary<string, string>[] temp = new GekkoDictionary<string, string>[ts.dimensions];
            for (int i = 0; i < ts.dimensions; i++)
            {
                string domain = null;
                try
                {
                    domain = ts.meta.domains[i];  //can fail in different ways, easiest with try-catch
                }
                catch { };
                if (domain == "*") domain = null;
                if (domain != null) domain = domain + ", ";
                temp[i] = new GekkoDictionary<string, string>(StringComparer.OrdinalIgnoreCase);
                int ii = 0;
                foreach (MultidimItem key in keys)
                {
                    if (!temp[i].ContainsKey(key.storage[i])) temp[i].Add(key.storage[i], null);
                    ii++;
                }
                List<string> temp2 = temp[i].Keys.ToList();
                temp2.Sort(G.CompareNaturalIgnoreCase);
                dimCount2 = dimCount2 * temp[i].Count;
                dimCount += temp2.Count + " * ";
                domains.Add(domain);
                elements.Add(temp2);
            }
        }

        /// <summary>
        /// DISP of normal series, both used for Gekko- and GAMS equations.
        /// </summary>
        /// <param name="tStart"></param>
        /// <param name="tEnd"></param>
        /// <param name="showAllPeriods"></param>
        /// <param name="ts"></param>
        /// <param name="varnameWithoutFreq"></param>
        /// <param name="isTimeless"></param>
        private static void DispHelperNormalSeries(GekkoTime tStart, GekkoTime tEnd, bool showAllPeriods, Series ts, string varnameWithoutFreq, bool isTimeless)
        {
            // --------------
            // Normal series (possibly timeless)
            // --------------

            bool hasFilter = false; if (Program.options.timefilter && Globals.globalPeriodTimeFilters2.Count > 0) hasFilter = true;

            int max = Program.options.print_disp_maxlines;
            if (hasFilter || Program.options.print_disp_maxlines == -1) max = int.MaxValue;

            if (max > 0)
            {

                if (isTimeless)
                {
                    G.Writeln("------------------------------------------------------------------------------------------");
                    G.Writeln("Value = " + G.levelFormatOld(ts.GetTimelessData()) + " (timeless)");
                    //G.Writeln("------------------------------------------------------------------------------------------");
                }
                else
                {

                    G.Writeln("------------------------------------------------------------------------------------------");
                    //G.Writeln("Period          value         %");


                    Table tab = new Table();  //See #kj3ha3438u
                    tab.Set(1, 1, "Period");
                    tab.Set(1, 2, "value"); tab.SetAlign(1, 2, Align.Right);
                    tab.Set(1, 3, "%"); tab.SetAlign(1, 3, Align.Right);

                    int counter = 0;

                    //must be able to handle TIME where freq does not match the series freq
                    foreach (GekkoTime gt in new GekkoTimeIterator(ConvertFreqs(tStart, tEnd, ts.freq)))
                    {
                        counter++;
                        if (hasFilter)  //some periods are set via TIMEFILTER
                        {
                            //if some filter is set, we never truncate output to 3 or 5 lines (showAllPeriods)
                            if (ShouldFilterPeriod(gt)) continue;
                        }
                        else
                        {
                            if (!showAllPeriods && counter > max)
                            {
                                continue;
                            }
                        }

                        //G.Write(gt.ToString() + G.Blanks(- gt.ToString().Length + dateLength[gt.freq]) + " ");                        

                        double n1 = ts.GetDataSimple(gt);
                        double n0 = ts.GetDataSimple(gt.Add(-1));

                        double level1 = n1;
                        double pch1 = ((n1 / n0 - 1) * 100d);

                        if (n1 == n0) pch1 = 0d;

                        string levelFormatted;
                        string pchFormatted;
                        Program.ConvertToPrintFormat(level1, pch1, out levelFormatted, out pchFormatted);

                        //G.Write(levelFormatted + " " + pchFormatted + " ");
                        //G.Writeln();

                        tab.Set(counter + 1, 1, gt.ToString());
                        tab.Set(counter + 1, 2, levelFormatted);
                        tab.Set(counter + 1, 3, pchFormatted);

                    }

                    foreach (string s in tab.Print())
                    {
                        G.Writeln(s);
                    }

                    int surplus = counter - max;
                    if (!showAllPeriods && surplus > 0)
                    {
                        G.Writeln("------------------------------------------------------------------------------------------");
                        string ps = "period";
                        if (surplus > 1) ps = "periods";

                        if (false)
                        {
                            G.Write(surplus + " " + ps + " hidden (");
                            G.WriteLink("show", "disp3:" + varnameWithoutFreq);
                            G.Writeln(")");
                        }
                        else
                        {
                            //G.WriteLink("show", "disp3:" + ts.GetName());
                            // ---------                
                            Action<GAO> a = (gao) =>
                            {
                                Globals.guiHomeMainEnabled = true;
                                List<string> temp = new List<string>();
                                string varnameWithBankAndFreq = ts.GetParentDatabank().name + Globals.symbolBankColon + ts.GetName();
                                temp.Add(varnameWithBankAndFreq);
                                Program.Disp(ConvertFreqs(tStart, tEnd, ts.freq).Item1, ConvertFreqs(tStart, tEnd, ts.freq).Item2, temp, false, true, true, null);
                            };
                            G.Writeln(surplus + " " + ps + " hidden (" + G.GetLinkAction("show", new GekkoAction(EGekkoActionTypes.Unknown, null, a)) + ")");
                        }
                    }
                }
            }
        }

        /// <summary>
        /// DISP: When a variable is part of a model (Gekko- og GAMS-), equations are printed. These are printed with links.
        /// The links are rtf-links, not very performant. Will be better when a WebBrowser component is used for this window,
        /// when porting to WPF:
        /// </summary>
        /// <param name="gamsToGekko"></param>
        /// <param name="varnameWithoutFreq"></param>
        /// <param name="eqs"></param>
        /// <param name="showGamsEquation"></param>
        private static void PrintEquationWithLinks(bool gamsToGekko, string varnameWithoutFreq, List<ModelGamsEquation> eqs, bool showGamsEquation)
        {
            int widthRemember = Program.options.print_width;
            Program.options.print_width = int.MaxValue;

            try
            {
                foreach (ModelGamsEquation eq in eqs)
                {

                    string lhs = null;
                    string rhs = null;
                    string conditionals = null;

                    if (showGamsEquation)
                    {
                        lhs = eq.lhsGams;
                        rhs = eq.rhsGams;
                        conditionals = eq.conditionalsGams;
                    }
                    else
                    {
                        lhs = eq.lhs;
                        rhs = eq.rhs;
                        conditionals = eq.conditionals;
                    }

                    G.Writeln();

                    PrintEquation(lhs); G.Write(" = ");
                    //G.Write(lhs + " = ");
                    //int length = (lhs + " = ").Length;

                    PrintEquation(rhs); G.Writeln(";");
                    G.Writeln("Conditionals: " + eq.conditionals);

                }
            }

            finally
            {
                //resetting, also if there is an error
                Program.options.print_width = widthRemember;
            }

        }

        /// <summary>
        /// The links are rtf-links, not very performant. Will be better when a WebBrowser component is used for this window,
        /// when porting to WPF:
        /// </summary>
        /// <param name="rhs"></param>
        private static void PrintEquation(string rhs)
        {
            GekkoDictionary<string, string> knownVars = GetKnownVars(rhs, true);
            TokenList tokens = StringTokenizer.GetTokensWithLeftBlanks(rhs);  //slack, tokenizing two times
            for (int i = 0; i < tokens.storage.Count; i++)
            {
                TokenHelper token = tokens[i];
                if (token.leftblanks > 0) G.Write(G.Blanks(token.leftblanks));
                if (token.type == ETokenType.Word && knownVars.ContainsKey(token.s))
                {
                    G.WriteLink(token.s, "disp:" + token.s);
                }
                else
                {
                    if (token.type == ETokenType.EOL)
                    {
                        G.Writeln();
                        TokenHelper next = tokens[i + 1];
                        if (next != null && next.type == ETokenType.EOL) i++;  //skip it
                        tokens[i + 1].leftblanks = 4;
                        continue;
                    }
                    G.Write(token.s);
                }
            }
            //G.Writeln(";");
        }

        /// <summary>
        /// Overload.
        /// </summary>
        /// <param name="input"></param>
        /// <returns></returns>
        private static GekkoDictionary<string, string> GetKnownVars(string input)
        {
            return GetKnownVars(input, false);
        }

        /// <summary>
        /// Used for GAMS equations.
        /// </summary>
        /// <param name="input"></param>
        /// <param name="useDatabank"></param>
        /// <returns></returns>
        private static GekkoDictionary<string, string> GetKnownVars(string input, bool useDatabank)
        {
            GekkoDictionary<string, string> knownVars = new GekkoDictionary<string, string>(StringComparer.OrdinalIgnoreCase);
            TokenList tokens = StringTokenizer.GetTokensWithLeftBlanks(input);
            foreach (TokenHelper token in tokens.storage)
            {
                if (token.type == ETokenType.Word)
                {
                    //List<ModelGamsEquation> e3 = null; Program.modelGams.equations.TryGetValue(token.s, out e3);
                    List<ModelGamsEquation> e3 = GamsModel.GetGamsEquationsByVarname(token.s, model);

                    if (e3 != null)
                    {
                        if (!knownVars.ContainsKey(token.s)) knownVars.Add(token.s, null);
                    }
                    else
                    {
                        if (useDatabank)
                        {
                            string varnameWithFreq = token.s + Globals.freqIndicator + G.ConvertFreq(Program.options.freq);
                            if (Program.databanks.GetFirst().ContainsIVariable(varnameWithFreq))
                            {
                                if (!knownVars.ContainsKey(token.s)) knownVars.Add(token.s, null);
                            }
                        }
                    }
                }
            }
            return knownVars;
        }

        /// <summary>
        /// Used for DISP, identify words. But why not use a tokenizer?
        /// </summary>
        /// <param name="strSplit"></param>
        /// <param name="arrDelimiters"></param>
        /// <returns></returns>
        public static List<string> SplitStringAndKeepDelimiters(string strSplit, char[] arrDelimiters)
        {
            // Start of tokenizing
            // Create a work array where the finished result also will be
            List<string> alWork = new List<string>();
            alWork.Add(strSplit);
            // Temporary variables
            Object[] arrSplitted;
            Char[] arrChar = new Char[1];
            List<string> alTemp = new List<string>();
            // Process each delimiter
            foreach (Char c in arrDelimiters)
            {
                // Clear temp vars
                arrChar[0] = c;
                alTemp.Clear();
                // Process each string
                foreach (String strWork in alWork)
                {
                    // Split it by delimiter
                    arrSplitted = strWork.Split(arrChar, StringSplitOptions.None);
                    if (arrSplitted.Length > 1)
                    {
                        // Split took place, add delimiter between every item
                        for (int n = 0; n < arrSplitted.Length; n++)
                        {
                            alTemp.Add((string)arrSplitted[n]);
                            if (n < arrSplitted.Length - 1)
                            {
                                alTemp.Add(c.ToString());
                            }
                        }
                    }
                    else
                    {
                        // No split took place, use original string
                        alTemp.Add(strWork);
                    }
                }
                // Copy temp array to work array
                // In C++ it would be some nice pointer swapping instead!
                alWork.Clear();
                alWork.AddRange(alTemp);
            }
            return alWork;
        }

        /// <summary>
        /// For a timeseries, get label, source, units, etc. from the external variable list (varlist.dat)
        /// </summary>
        /// <param name="var"></param>
        /// <returns></returns>
        public static List<string> GetVariableExplanationFromExternalFile(string var)
        {
            List<string> explanation = new List<string>();
            if (Program.model?.modelGekko?.modelInfo?.varlist == null) return explanation;
            foreach (Program.Item item in Program.model.modelGekko.modelInfo.varlist)
            {
                if (G.Equal(var, item.variable))
                {
                    explanation = item.explanation;
                }
            }
            return explanation;
        }

        /// <summary>
        /// Pretty print for DISP and brower.
        /// </summary>
        /// <param name="level1"></param>
        /// <param name="pch1"></param>
        /// <param name="levelFormatted"></param>
        /// <param name="pchFormatted"></param>
        public static void ConvertToPrintFormat(double level1, double pch1, out string levelFormatted, out string pchFormatted)
        {
            levelFormatted = G.levelFormatOld(level1);
            pchFormatted = G.pchFormatOld(pch1);
        }

        /// <summary>
        /// Used in print to decorate a variable with info on whether it is endogenous or exogenous.
        /// </summary>
        /// <param name="var"></param>
        /// <returns></returns>
        public static EEndoOrExo VariableTypeEndoExo(string varnameMaybeWithFreq)
        {
            string var = G.Chop_RemoveFreq(varnameMaybeWithFreq);
            EEndoOrExo type = EEndoOrExo.Unknown;
            if (var == null) return type;
            if (G.GetModelSourceType() == EModelType.Gekko)
            {
                //checks if left-hand var in model. So this ignores exo/endo commands.
                //so the E and X only describes the model equations as they are
                if (Program.model.modelGekko?.endogenousOriginallyInModel != null && Program.model.modelGekko.endogenousOriginallyInModel.ContainsKey(var))
                {
                    type = EEndoOrExo.Endo;
                }
                else if (Program.model?.modelGekko?.varsAType != null && Program.model.modelGekko.varsAType.ContainsKey(var))
                {
                    type = EEndoOrExo.Exo;
                }
            }
            return type;
        }        
        
        /// <summary>
        /// RENAME command.
        /// </summary>
        /// <param name="o"></param>
        public static void Rename(O.Rename o)
        {

            if (o.type == "ASTPLACEHOLDER") o.type = null;
            EVariableType type = EVariableType.Var;
            if (o.type != null) type = G.GetVariableType(o.type);

            List<ToFrom> outputs = SearchFromTo(o.names0, o.names1, o.opt_frombank, o.opt_tobank, EWildcardSearchType.Rename, null);

            if (G.IsUnitTesting() && Globals.unitTestCopyHelper2)
            {
                Globals.unitTestCopyHelper = outputs;  //for simpler testing of this
                return;
            }

            if (G.Equal(o.opt_print, "yes"))
            {
                G.Writeln2("Renaming the following " + outputs.Count + " variables:");
                G.Writeln();
                foreach (ToFrom two in outputs)
                {
                    G.Writeln(two.s1 + " ---> " + two.s2);
                }
            }

            foreach (ToFrom output in outputs)
            {
                IVariable iv = O.GetIVariableFromString(output.s1, O.ECreatePossibilities.NoneReportError);  //no search
                if (type != EVariableType.Var && type != iv.Type()) continue; //skip it                
                O.RemoveIVariableFromString(output.s1, true);  //get it out of dictionary
                Series iv_series = iv as Series;
                if (iv_series != null)
                {
                    //replaces the name, keeps freq. For instance, 
                    iv_series.name = G.Chop_GetName(output.s2) + Globals.freqIndicator + G.ConvertFreq(iv_series.freq);
                }
                O.AddIVariableWithOverwriteFromString(output.s2, iv); //get it into dictionary
            }
            G.Writeln2("Renamed " + outputs.Count + " variables");
        }

        /// <summary>
        /// COPY command. Uses Program.SearchFromTo() internally.
        /// </summary>
        /// <param name="o"></param>
        public static void Copy(O.Copy o)
        {

            if (o.type == "ASTPLACEHOLDER") o.type = null;
            EVariableType type = EVariableType.Var;
            if (o.type != null) type = G.GetVariableType(o.type);

            if (o.names2 == null)
            {
                o.names2 = new Gekko.List();
                o.names2.Add(new ScalarString("First:*"));
            }

            bool ignoreErrors = false; if (G.Equal(o.opt_error, "no")) ignoreErrors = true;
            SearchOptions options = new SearchOptions();
            if (ignoreErrors) options.ignoreErrors = true;
            List<ToFrom> outputs = SearchFromTo(o.names1, o.names2, o.opt_frombank, o.opt_tobank, EWildcardSearchType.Copy, options);

            int nIgnores = 0;
            int nOk = 0;

            if (G.IsUnitTesting() && Globals.unitTestCopyHelper2)
            {
                Globals.unitTestCopyHelper = outputs;  //for simpler testing of this
                return;
            }

            if (G.Equal(o.opt_print, "yes"))
            {
                G.Writeln2("Copying the following " + outputs.Count + " variables:");
                G.Writeln();
                foreach (ToFrom two in outputs)
                {
                    G.Writeln(two.s1 + " ---> " + two.s2);
                }
            }

            GekkoSmplSimple truncate = HandleRespectPeriod(o.t1, o.t2, o.opt_respect, null, "copy");

            foreach (ToFrom output in outputs)
            {
                IVariable iv = O.GetIVariableFromString(output.s1, O.ECreatePossibilities.NoneReturnNullButErrorForParentArraySeries);  //no search here

                if (iv == null)
                {
                    if (ignoreErrors)
                    {
                        new Note("Could not find variable '" + output.s1 + "' for copying");
                        nIgnores++;
                        continue;
                    }
                    else
                    {
                        O.GetIVariableFromString(output.s1, O.ECreatePossibilities.NoneReportError);  //will emit the error message
                    }
                }
                else
                {
                    if (type != EVariableType.Var && type != iv.Type()) continue; //skip it
                }

                nOk++;

                IVariable existing = O.GetIVariableFromString(output.s2, O.ECreatePossibilities.NoneReturnNullButErrorForParentArraySeries);
                bool injectingToExistingSeries = false;
                if (truncate != null && existing != null && iv.Type() == EVariableType.Series && existing.Type() == EVariableType.Series)
                {
                    Series iv_series = iv as Series;
                    Series existing_series = existing as Series;
                    if (iv_series.dimensionsStorage == null)
                    {
                        if (iv_series.freq == existing_series.freq)
                        {
                            injectingToExistingSeries = true;
                            foreach (GekkoTime gt in new GekkoTimeIterator(truncate.t1, truncate.t2))
                            {
                                existing_series.SetData(gt, iv_series.GetDataSimple(gt));
                            }
                        }
                    }
                }

                if (!injectingToExistingSeries)
                {
                    IVariable iv_clone = iv.DeepClone(truncate);
                    Series ts_clone = iv_clone as Series;
                    if (Globals.useTrace && ts_clone != null) ts_clone.meta.calc = null;  //erase it
                    O.AddIVariableWithOverwriteFromString(output.s2, iv_clone);
                    
                    if (Globals.useTrace && ts_clone != null)
                    {
                        ts_clone.meta.calc[0] += " // Copied " + ts_clone.GetName() + " from " + (iv as Series).GetName();
                    }
                }
            }

            string si = null;
            if (nIgnores > 0) si = " (ignored " + nIgnores + ")";

            G.Writeln2("Copied data for " + nOk + " variables" + si);

        }

        /// <summary>
        /// For READ/IMPORT, WRITE/EXPORT and COPY, handles the logic of "respecting" the given time period.
        /// </summary>
        /// <param name="t1"></param>
        /// <param name="t2"></param>
        /// <param name="respect"></param>
        /// <param name="all"></param>
        /// <param name="type"></param>
        /// <returns></returns>
        public static GekkoSmplSimple HandleRespectPeriod(GekkoTime t1, GekkoTime t2, string respect, string all, string type)
        {
            //type = copy, read, import, write, export
            GekkoSmplSimple truncate = null;
            if (t1.IsNull())
            {
                //No time period
                if (G.Equal(respect, "yes"))
                {
                    if (G.Equal(type, "import") || G.Equal(type, "export"))
                    {
                        new Error("You cannot use " + type.ToUpper() + "<respect>");
                        //throw new GekkoException();
                    }
                    //COPY<respect>, READ<respect>, WRITE<respect>
                    truncate = new GekkoSmplSimple(Globals.globalPeriodStart, Globals.globalPeriodEnd);
                }
                else if (G.Equal(all, "yes"))
                {
                    if (G.Equal(type, "copy") || G.Equal(type, "read") || G.Equal(type, "write"))
                    {
                        new Error("You cannot use " + type.ToUpper() + "<all>");
                        //throw new GekkoException();
                    }
                    //IMPORT<all> or EXPORT<all>
                    //truncate = new GekkoSmplSimple(true);
                }
                else
                {
                    if (!Program.options.bugfix_import_export)
                    {
                        if (G.Equal(type, "import") || G.Equal(type, "export"))
                        {
                            truncate = new GekkoSmplSimple(Globals.globalPeriodStart, Globals.globalPeriodEnd);
                        }
                    }
                }
            }
            else
            {
                //time period, READ<2010 2020> or IMPORT<2010 2020>                
                if (G.Equal(respect, "yes"))
                {
                    //READ<2010 2020 respect>
                    new Error("You cannot mix dates and 'respect' in the option field");
                    //throw new GekkoException();                    
                }
                else if (G.Equal(all, "yes"))
                {
                    //IMPORT<2010 2020 all>
                    new Error("You cannot mix dates and 'all' in the option field");
                    //throw new GekkoException();
                }
                else
                {
                    truncate = new GekkoSmplSimple(t1, t2);
                }
            }
            return truncate;
        }

        /// <summary>
        /// Fetces error message(s) from inside GekkoException, for printing. Will always return a List obj,
        /// but the List may have 0 elements.
        /// </summary>
        /// <param name="e"></param>
        /// <returns></returns>
        public static void PrintExceptionWraps(Exception e)
        {
            GekkoException ge = e as GekkoException;

            if (ge != null)
            {
                //TODO:
                //Could consolidate the nested errors here to make them look nice
                foreach (Wrap wrap in ge.wraps)
                {
                    CrossThreadStuff.Wrap(wrap); //Printing out --> .Exe2() will fail because it is on another thread than GUI
                }
                ge.wraps = new List<Wrap>();  //to make absolutely sure they are not printed > 1 time!
            }
        }

        /// <summary>
        /// Helper method for name ranges like xa..xd
        /// </summary>
        /// <param name="bankname"></param>
        /// <param name="freqname"></param>
        /// <param name="s"></param>
        /// <param name="s1"></param>
        /// <param name="s2"></param>
        /// <param name="m"></param>
        public static void AddIfInRange(string bankname, string freqname, string s, string s1, string s2, List<string> m)
        {
            if (string.Compare(s1, s, true) <= 0 && string.Compare(s, s2, true) <= 0)
            {
                string ss1 = null;
                string ss2 = null;
                if (bankname != null) ss1 = bankname + Globals.symbolBankColon;
                if (freqname != null) ss2 = Globals.freqIndicator + freqname;
                m.Add(ss1 + s + ss2);
            }
        }

        /// <summary>
        /// Wrapper method for SearchFromTo() method.
        /// </summary>
        /// <param name="names1"></param>
        /// <param name="frombank"></param>
        /// <param name="type"></param>
        /// <returns></returns>
        public static List<string> Search(List names1, string frombank, EVariableType type)
        {
            List<string> names = new List<string>();
            List<ToFrom> matches = Program.SearchFromTo(names1, null, frombank, null, EWildcardSearchType.Search, null);
            //List rv = new List();

            foreach (ToFrom two in matches)
            {
                if (type != EVariableType.Var)
                {
                    //a bit of double work here, but maybe it does not need to be super fast anyway
                    IVariable iv = O.GetIVariableFromString(two.s1, O.ECreatePossibilities.NoneReportError);  //no search here
                    if (type != EVariableType.Var && type != iv.Type()) continue; //skip it
                }
                names.Add(two.s1);
            }
            return names;
        }

        /// <summary>
        /// This is the central hub regarding wildcards in commands like INDEX, DISP, COPY, RENAME, DELETE, WRITE/EXPORT, READ/IMPORT, 
        /// and having a central hub assures the the wildcard logic is consistent. 
        /// It deals with the logic of for instance INDEX x*; or COPY x*b TO y*; etc. Also deals with {'...'} wildcards, and handles
        /// the logic if banknames are given, too. This is a quite complicated method.
        /// Beware that you cannot use @x, must use ref:x.
        /// </summary>
        /// <param name="names0"></param>
        /// <param name="names1"></param>
        /// <param name="frombank"></param>
        /// <param name="tobank"></param>
        /// <param name="type"></param>
        /// <param name="options"></param>
        /// <returns></returns>
        public static List<ToFrom> SearchFromTo(List names0, List names1, string frombank, string tobank, EWildcardSearchType type, SearchOptions options)
        {
            //names0 may contain ranges

            //In general, INDEX, DISP and {'...'} are maybe a bit different from 
            //wildcards in COPY, RENAME, WRITE, etc. In principle, the former could 
            //search in all banks, even without a '*:' but better to keep the logic unified.
            //So PRT x and y = x searches for x in all banks (if search is on), whereas the
            //wildcards need '*:' to do that.
            //
            //In essence, math expressions like PRT x and y = x search for 1 item, where
            //INDEX, DISP, {'...'}, COPY, RENAME, WRITE, etc search for many items. Therefore
            //the logic is different.
            //
            //Note that #m = {'...'} returns a list<string>, not list<series>, because 
            //it is understood like #m = item1, item2, ... But PRT {'...'} will still
            //get a list<series>.
            //
            //What if {'a*b'} returns list<series>, and ['a*b'] list<string>. You may
            //use {['a*b']} too. Then #m['a*b'] fits nicely.

            //Used in both COPY ... TO ... and RENAME ... AS ...
            //Also used for INDEX and ... = ... {'a*b'}
            //All the following combinations are tested in unit tests

            //If there is frombank, LHS without bank gets that bank

            //Use of wildcards:
            //
            // === Before TO (lhs): ==============================
            //
            // --- bank ---
            // a: no bank
            // b: given bank
            // c: wildcard bank (can be complicated)
            //
            // --- names ---
            // 01: list of given names
            // 02: wildcard name (can be complicated)
            //
            // === After TO (rhs): ===============================
            //
            // --- bank ---
            // A: no bank (all vars will get 'First:')
            // B: given bank (replaces bank)
            // C: star bank (not really a wildcard, can only be '*', will get same bank as lhs)
            //         
            // --- names ---   
            // 11: list of given names
            // 12: wildcard name (must be simple one-star like 'a*b')
            //  
            // ---------------------------------------------
            //
            // NOTE: If lhs contains an element with a wildcards ('*' or '?' in bank or name), the rhs MUST be a 1-element
            //       list (in practice this item is a wildcard, but collisions are checked anyway)
            //       This is to avoid that names obtained from wildcards are randomly put into a list
            //       of fixed names.
            //
            // =============================================

            bool removeCurrentFirstBankAndCurrentFreq = true;

            string currentFirstBankName = Program.databanks.GetFirst().name;
            string currentRefBankName = Program.databanks.GetRef().name;
            string currentFreq = G.ConvertFreq(Program.options.freq);

            string command = "COPY";
            string command2 = "copy";
            string command3 = "copied";
            if (type == EWildcardSearchType.Rename)
            {
                command = "RENAME";
                command2 = "rename";
                command3 = "renamed";
            }
            else if (type == EWildcardSearchType.Search)
            {
                command = "Search";
                command2 = "search";
                command3 = "searched";
            }
            else if (type == EWildcardSearchType.Write)
            {
                command = "WRITE";
                command2 = "write";
                command3 = "written";
            }
            else if (type == EWildcardSearchType.Delete)
            {
                command = "DELETE";
                command2 = "delete";
                command3 = "deleted";
            }

            List<ToFrom> outputs = new List<ToFrom>();

            List<string> lhs = O.Restrict(names0, true, true, true, true);
            bool allowBankRhs = true;
            if (type == EWildcardSearchType.Write)
            {
                allowBankRhs = true;
            }

            List<string> rhs = O.Restrict(names1, allowBankRhs, true, true, true);

            // --------------------------------------------
            //           LHS
            // --------------------------------------------

            List<string> lhsUnfolded = new List<string>();
            List<bool> lhsUnfoldedExplicit = new List<bool>();

            bool lhsHasStarOrQuestionGlobal = false;  //true for LHS, for 'a*', '*:x', 'b?:x?', etc.

            foreach (string wildCardLhs in lhs)
            {

                string bankLhs = null;
                string nameLhs = null;
                string freqLhs = null;
                string[] indexLhs = null;

                string nameLhsRange1 = null;
                string nameLhsRange2 = null;

                string[] ss = wildCardLhs.Split(new string[] { ".." }, StringSplitOptions.None);
                if (ss.Length == 2)
                {
                    //stuff like ['ab'..'f']
                    //['b2:ab'..'b2:f']
                    //['ab!q'..'f!q']

                    if (ss[0].StartsWith(Globals.symbolRefShortcut)) ss[0] = "ref:" + ss[0].Substring(1);
                    if (ss[1].StartsWith(Globals.symbolRefShortcut)) ss[1] = "ref:" + ss[1].Substring(1);

                    string bankLhs1, nameLhs1, freqLhs1; string[] indexLhs1;
                    O.Chop(ss[0], out bankLhs1, out nameLhs1, out freqLhs1, out indexLhs1);

                    string bankLhs2, nameLhs2, freqLhs2; string[] indexLhs2;
                    O.Chop(ss[1], out bankLhs2, out nameLhs2, out freqLhs2, out indexLhs2);

                    if (!G.Equal(bankLhs1, bankLhs2))
                    {
                        new Error("You must use the same bankname before and after '..' in a range");
                    }

                    if (!G.Equal(freqLhs1, freqLhs2))
                    {
                        new Error("You must use the same freq before and after '..' in a range");
                    }

                    if (nameLhs1[0] == Globals.symbolScalar && nameLhs2[0] != Globals.symbolScalar)
                    {
                        new Error("Scalar symbol '%' should be present both before and after '..'");
                    }

                    if (nameLhs1[0] == Globals.symbolCollection && nameLhs2[0] != Globals.symbolCollection)
                    {
                        new Error("Collection symbol '#' should be present both before and after '..'");
                    }
                    bankLhs = bankLhs1;
                    nameLhsRange1 = nameLhs1;
                    nameLhsRange2 = nameLhs2;
                    freqLhs = freqLhs1;

                }
                else
                {
                    string sss = wildCardLhs;
                    if (sss.StartsWith(Globals.symbolRefShortcut)) sss = "ref:" + sss.Substring(1);
                    O.Chop(sss, out bankLhs, out nameLhs, out freqLhs, out indexLhs);
                    if (nameLhs == "***")
                    {
                        if (bankLhs != null)
                        {
                            new Error("You cannot combine '***' with bank, frequency or index.");
                        }
                        bankLhs = "*";
                        nameLhs = "**";
                        //so *** = *:**
                    }
                }

                //Now we have bankLhs and freqLhs (indexLhs does not work...)
                //if nameLhs != null, it is normal wildcard
                //if nameLhsRange1 != null, it is a range

                //any "first" or "ref" is set to their real names. Null will still be null.
                bankLhs = SubstituteFirstRefNames(bankLhs);

                if (bankLhs == null && frombank != null) bankLhs = frombank;  //overwrites "naked" vars, so "COPY <frombank=b> a, b to c, d;" is same as "COPY b:a, b:b to c, d;"

                bool lhsHasStarOrQuestion = false;
                if (bankLhs != null && (bankLhs.Contains("*") || bankLhs.Contains("?"))) lhsHasStarOrQuestion = true;
                if (nameLhs != null && (nameLhs.Contains("*") || nameLhs.Contains("?"))) lhsHasStarOrQuestion = true;
                if (freqLhs != null && (freqLhs.Contains("*") || freqLhs.Contains("?"))) lhsHasStarOrQuestion = true;
                if (nameLhsRange1 != null) lhsHasStarOrQuestion = true;  //range
                if (lhsHasStarOrQuestion) lhsHasStarOrQuestionGlobal = true;  //used outside loop

                if (indexLhs != null)
                {
                    if (lhsHasStarOrQuestion)
                    {
                        new Error("" + command + " where variable name has wildcard and where []-brackets are present is not yet implemented");
                    }
                    else
                    {
                        //could be just DISP x[a] for instance
                    }
                }

                bool hasExplicitBank = bankLhs != null;

                if (!lhsHasStarOrQuestion && type == EWildcardSearchType.Search)
                {
                    //a hack to make DISP x[a] work                    
                    //OR: it is an INDEX command without stars, here we must find out if the single non-wildcard item exists
                    //OR: it is an index wildcard like x[*] or x[?] that returns a List (of Series).
                    IVariable iv = O.GetIVariableFromString(wildCardLhs, O.ECreatePossibilities.NoneReturnNullButErrorForParentArraySeries);
                    if (iv != null)
                    {
                        if (iv.Type() == EVariableType.List)
                        {
                            //x[*], x[?] etc.
                            foreach (IVariable child in (iv as List).list)
                            {
                                Series child_ts = child as Series;
                                string db = child_ts.GetParentDatabank().GetName();
                                EFreq freq = child_ts.freq;

                                string name = child_ts.GetName();

                                if (freq != Program.options.freq)
                                {
                                    name = G.Chop_SetFreq(name, freq);
                                }

                                if (!G.Equal(currentFirstBankName, db))
                                {
                                    name = G.Chop_SetBank(name, db);
                                }                                

                                lhsUnfolded.Add(name);
                                lhsUnfoldedExplicit.Add(hasExplicitBank);
                            }
                        }
                        else
                        {
                            lhsUnfolded.Add(wildCardLhs);
                            lhsUnfoldedExplicit.Add(hasExplicitBank);
                        }
                    }
                }
                else if (lhsHasStarOrQuestion)
                {
                    //There is a star or question in bank, name or freq, or a range in name                    

                    List<string> listOfAllOpenBanks = GetListOfAllBanks();
                    List<string> db_banks = new List<string>();
                    if (bankLhs == null)
                    {
                        db_banks.Add(currentFirstBankName);
                    }
                    else
                    {
                        db_banks = MatchWildcard(bankLhs, listOfAllOpenBanks);
                    }

                    foreach (string db_bank in db_banks)
                    {
                        //
                        // This is where the matching takes place
                        //
                        if (nameLhsRange1 != null)
                        {
                            List<string> range = RangeInBank(db_bank, nameLhsRange1, nameLhsRange2, freqLhs);
                            lhsUnfolded.AddRange(range);
                            foreach (string s in range) lhsUnfoldedExplicit.Add(hasExplicitBank);
                        }
                        else
                        {
                            List<string> match = MatchInBank(db_bank, nameLhs, freqLhs);
                            lhsUnfolded.AddRange(match);
                            foreach (string s in match) lhsUnfoldedExplicit.Add(hasExplicitBank);
                        }
                    }
                }
                else
                {
                    //item without * or ? or range
                    string bankTemp = bankLhs;
                    if (bankLhs == null)
                    {
                        LocalGlobal.ELocalGlobalType lg = Program.databanks.localGlobal.GetValue(nameLhs); //should be without freq                                                                                                             
                        bankTemp = O.HandleLocalGlobalBank2(lg);
                    }
                    string freq = null;
                    if (!G.Chop_HasSigil(nameLhs))
                    {
                        freq = freqLhs;
                        if (freqLhs == null) freq = currentFreq;
                    }
                    lhsUnfolded.Add(O.UnChop(bankTemp, nameLhs, freq, indexLhs));
                    lhsUnfoldedExplicit.Add(hasExplicitBank);
                }
            }

            bool reportError = true;
            if (options == null) reportError = false;
            if (options != null && options.ignoreErrors == true) reportError = false;
            if (reportError && lhsUnfolded.Count == 0)
            {
                new Error("" + command + " wildcard/range did not match any variables");
            }

            // ------------------------------------------------------------
            // Now the variables have been found
            // Next is which variables they (maybe) are
            // matched with, for instance with COPY or RENAME.
            // ------------------------------------------------------------

            if (type == EWildcardSearchType.Search || type == EWildcardSearchType.Delete)
            {
                for (int i = 0; i < lhsUnfolded.Count; i++)
                {
                    outputs.Add(new ToFrom(lhsUnfolded[i], null, lhsUnfoldedExplicit[i]));
                }
            }
            else
            {
                //type with destination
                if (rhs.Count > 1)
                {
                    if (lhsHasStarOrQuestionGlobal)
                    {
                        //Such assignment is too error-prone, like "COPY x* TO a, b, c;"
                        new Error("Using wildcards before TO/AS, you must state a single wildcard element after TO/AS");
                        //throw new GekkoException();
                    }
                    else
                    {
                        if (lhs.Count != rhs.Count)
                        {
                            new Error("Mismatch: there are " + lhs.Count + " elements before TO/AS, and " + rhs.Count + " elements after TO/AS");
                            //throw new GekkoException();
                        }
                    }
                }

                for (int i = 0; i < lhsUnfolded.Count; i++)
                {
                    string lhsElement = lhsUnfolded[i];
                    bool lhsElementExplicit = lhsUnfoldedExplicit[i];

                    string rhsElement = null;
                    if (rhs.Count > 1) rhsElement = rhs[i];
                    else rhsElement = rhs[0];

                    //This is (re)chopping of a LHS variable that has already had bankname etc. added
                    string bankLhs, nameLhs, freqLhs; string[] indexLhs;
                    O.Chop(lhsElement, out bankLhs, out nameLhs, out freqLhs, out indexLhs);
                    bankLhs = SubstituteFirstRefNames(bankLhs);

                    //TODO: some superfluous repetitive chopping here, if rhs has only 1 element
                    string bankRhs, nameRhs, freqRhs; string[] indexRhs;
                    O.Chop(rhsElement, out bankRhs, out nameRhs, out freqRhs, out indexRhs);
                    bankRhs = SubstituteFirstRefNames(bankRhs);

                    if (bankRhs == null && tobank != null) bankRhs = tobank;  //overwrites "naked" vars, so "COPY <tobank=b> a, b to c, d;" is same as "COPY a, b to b:c, b:d;"

                    string[] name2split = nameRhs.Split('*');

                    if (name2split.Length - 1 > 1)
                    {
                        new Error("More than one '*' not allowed in name in TO/AS part of " + command + "");
                        //throw new GekkoException();
                    }

                    if ((bankRhs != null && bankRhs.Contains("?")) || nameRhs.Contains("?"))
                    {
                        new Error("'?' not not allowed in TO/AS part of " + command + "");
                        //throw new GekkoException();
                    }

                    if (bankRhs == null)
                    {
                        //COPY...to   * --> first, same names
                        //COPY...to   x*y --> first, prefix suffix
                        //COPY...to   x --> first, fixed name

                        string bankTemp = bankRhs;
                        if (bankTemp == null)
                        {
                            LocalGlobal.ELocalGlobalType lg = Program.databanks.localGlobal.GetValue(nameRhs); //should be without freq                                                                                                             
                            bankTemp = O.HandleLocalGlobalBank2(lg);
                        }

                        //no bank given in second part
                        if (name2split.Length == 1)
                        {
                            //no stars
                            outputs.Add(new ToFrom(lhsElement, O.UnChop(bankTemp, nameRhs, freqLhs, indexLhs), lhsElementExplicit));
                        }
                        else
                        {
                            //one star
                            outputs.Add(new ToFrom(lhsElement, O.UnChop(currentFirstBankName, name2split[0] + nameLhs + name2split[1], freqLhs, indexLhs), lhsElementExplicit));
                        }
                    }
                    else if (!bankRhs.Contains("*"))
                    {
                        //COPY...to b:* --> b bank, same names
                        //COPY...to b:x*y --> b bank, prefix suffix
                        //COPY...to b:* --> b bank, same names

                        if (!G.IsSimpleToken(bankRhs))
                        {
                            new Error("Illegal bankname in TO/AS part of " + command + "");
                            //throw new GekkoException();
                        }

                        //fixed bank given in second part
                        if (name2split.Length == 1)
                        {
                            //no stars
                            outputs.Add(new ToFrom(lhsElement, O.UnChop(bankRhs, nameRhs, freqLhs, indexLhs), lhsElementExplicit));
                        }
                        else
                        {
                            //one star
                            outputs.Add(new ToFrom(lhsElement, O.UnChop(bankRhs, name2split[0] + nameLhs + name2split[1], freqLhs, indexLhs), lhsElementExplicit));
                        }
                    }
                    else
                    {
                        //COPY...to *:*--> fail: copies to itself                
                        //COPY...to *:x*y -- > same bank, prefix suffix
                        //COPY...to *:b  --> same bank, fixed name

                        if (bankRhs != "*")
                        {
                            new Error("Only simple '*' allowed in TO/AS part of " + command + "");
                            //throw new GekkoException();
                        }

                        //original bank stated in second part
                        if (name2split.Length == 1)
                        {
                            //no stars
                            outputs.Add(new ToFrom(lhsElement, O.UnChop(bankLhs, nameRhs, freqLhs, indexLhs), lhsElementExplicit));
                        }
                        else
                        {
                            //one star
                            outputs.Add(new ToFrom(lhsElement, O.UnChop(bankLhs, name2split[0] + nameLhs + name2split[1], freqLhs, indexLhs), lhsElementExplicit));
                        }
                    }
                }


                //So now, if RHS has > 1 element, LHS has no '*' or '?'
                //And if RHS has > 1 element, LHS has the same number.                

                Dictionary<string, int> lhsCheck = new Dictionary<string, int>(StringComparer.OrdinalIgnoreCase);
                Dictionary<string, int> rhsCheck = new Dictionary<string, int>(StringComparer.OrdinalIgnoreCase);

                int counter = 0;
                //G.Writeln();
                foreach (ToFrom two in outputs)
                {
                    if (type != EWildcardSearchType.Write && G.Equal(two.s1, two.s2)) //blanks are removed in two list, so indexes should compare fine, too.
                    {
                        //Copying to "itself" (that is, the databank) is fine for WRITE
                        new Error("You cannot " + command2 + " element '" + two.s1 + "' to itself");
                        //throw new GekkoException();
                    }
                    if (lhsCheck.ContainsKey(two.s1))
                    {
                        new Error("Dublet: element '" + two.s1 + "' appears several times before TO/AS");
                        //throw new GekkoException();
                    }
                    else
                    {
                        lhsCheck.Add(two.s1, 0);
                    }
                    if (rhsCheck.ContainsKey(two.s2))
                    {
                        List<string> temp = new List<string>();
                        foreach (ToFrom two2 in outputs)
                        {
                            if (G.Equal(two2.s2, two.s2))
                            {
                                temp.Add(two2.s1);
                            }
                        }
                        string ss = two.s2;
                        if (type == EWildcardSearchType.Write)
                        {
                            //Remove bank, which is always "First:" anyway
                            ss = G.Chop_RemoveBank(ss);
                        }
                        new Error("The variables " + Stringlist.GetListWithCommas(temp) + " are all " + command3 + " to " + ss);
                    }
                    else
                    {
                        rhsCheck.Add(two.s2, 0);
                    }


                    if (true)
                    {
                        //must have both bank colon
                        //THIS IF CAN BE REMOVED AFTER SOME TESTING
                        if (!two.s1.Contains(Globals.symbolBankColon) || !two.s2.Contains(Globals.symbolBankColon))
                        {
                            new Error("Internal error #08745765398475");
                            //throw new GekkoException();
                        }
                        if ((!G.Chop_HasSigil(two.s1) && !two.s1.Contains(Globals.freqIndicator)) || (!G.Chop_HasSigil(two.s2) && !two.s2.Contains(Globals.freqIndicator)))
                        {
                            new Error("Internal error #08745765398475");
                            //throw new GekkoException();
                        }
                    }

                }  //end of foreach (TwoStrings two in outputs)

            }  //end of if (type == EWildcardSearchType.Search)

            if (removeCurrentFirstBankAndCurrentFreq && type == EWildcardSearchType.Search)
            {

                foreach (ToFrom two in outputs)
                {
                    two.s1 = G.Chop_RemoveFreq(two.s1, currentFreq);
                    two.s1 = G.Chop_RemoveBank(two.s1, currentFirstBankName);
                    if (two.s2 != null)
                    {
                        two.s2 = G.Chop_RemoveFreq(two.s2, currentFreq);
                        two.s2 = G.Chop_RemoveBank(two.s2, currentFirstBankName);
                    }
                }
            }

            return outputs;
        }

        /// <summary>
        /// A helper method for Search(), and also implicit SearchFromTo(). For instance, an INDEX *; may 
        /// return 0 hits, because the timeseries are in other databanks, or in other frecuencies. So what this
        /// method does is to look at INDEX *:*; and INDEX *!*; and INDEX *:*!*; to see if there are other hits.
        /// If so, these can be reported. This is helpful for users who do not understand that '*' wildcard only
        /// matches series in first-position databank with current frequency.    
        /// </summary>
        /// <param name="names1"></param>
        /// <param name="opt_bank"></param>
        /// <param name="type"></param>
        /// <returns></returns>
        public static SearchHelper1 SearchAllBanksAllFreqs(List names1, string opt_bank, EVariableType type)
        {
            SearchHelper1 helper = new SearchHelper1();
            foreach (IVariable iv in names1.list)
            {
                try
                {
                    string s = O.ConvertToString(iv);
                    string bank = G.Chop_GetBank(s);
                    string freq = G.Chop_GetFreq(s);
                    bool sigil = G.Chop_HasSigil(s);

                    if (true)
                    {
                        string newName = G.Chop_SetBank(s, "*");
                        List<string> extraNames = Program.Search(new List(new List<string>() { newName }), opt_bank, type);
                        helper.allBanks.name = newName;
                        helper.allBanks.nameOriginal = s;
                        helper.allBanks.count = extraNames.Count;
                    }

                    if (true)
                    {
                        string newName = G.Chop_SetFreq(s, "*");
                        List<string> extraNames = Program.Search(new List(new List<string>() { newName }), opt_bank, type);
                        helper.allFreqs.name = newName;
                        helper.allFreqs.nameOriginal = s;
                        helper.allFreqs.count = extraNames.Count;
                    }

                    if (true)
                    {
                        string newName = G.Chop_SetFreq(s, "*");
                        newName = G.Chop_SetBank(newName, "*");
                        List<string> extraNames = Program.Search(new List(new List<string>() { newName }), opt_bank, type);
                        helper.allBanksAndFreqs.name = newName;
                        helper.allBanksAndFreqs.nameOriginal = s;
                        helper.allBanksAndFreqs.count = extraNames.Count;
                    }
                }
                catch { };  //if it fails, we live with that
            }

            return helper;
        }

        /// <summary>
        /// Used to handle #(listfile m) kinds of "variables": this example gets the "name" #listfile___m.
        /// </summary
        /// <param name="varnameWithFreq"></param>
        /// <returns></returns>
        public static bool IsListfileArtificialName(string varnameWithFreq)
        {
            if (varnameWithFreq == null) return false;
            return varnameWithFreq.StartsWith(Globals.symbolCollection + Globals.listfile + "___");
        }

        /// <summary>
        /// Used in the central SearchFromTo() method.
        /// </summary>
        /// <returns></returns>
        private static List<string> GetListOfAllBanks()
        {
            //Sequence: local, first, ref, rest, global
            List<string> temp = new List<string>();
            temp.Add(Globals.Local);
            for (int i = 0; i < Program.databanks.storage.Count; i++)
            {
                //if (i == 1) continue; //skip ref bank
                Databank databank = Program.databanks.storage[i];
                temp.Add(databank.name);
            }
            temp.Add(Globals.Global);
            //temp.Add(Program.databanks.storage[1].name); //ref bank
            return temp;
        }

        /// <summary>
        /// Used in the central SearchFromTo() method.
        /// </summary>
        /// <param name="bank"></param>
        /// <returns></returns>
        private static string SubstituteFirstRefNames(string bank)
        {
            if (bank == null) return bank;
            if (G.Equal(bank, Globals.First)) bank = Program.databanks.GetFirst().name;
            else if (G.Equal(bank, Globals.Ref)) bank = Program.databanks.GetRef().name;
            return bank;
        }

        /// <summary>
        /// Used in the central SearchFromTo() method.
        /// </summary>
        /// <param name="bankname"></param>
        /// <param name="wildcardName"></param>
        /// <param name="wildcardFreq"></param>
        /// <returns></returns>
        private static List<string> MatchInBank(string bankname, string wildcardName, string wildcardFreq)
        {
            if (wildcardName.Contains("."))
            {
                new Error("Wildcards contains a '.' --> please use '!' to indicate frequency");
            }

            //For each matching databank
            List<string> varsMatched = new List<string>();
            List<string> allVariablesInBank = new List<string>();
            Databank db = Program.databanks.GetDatabank(bankname, true);
            foreach (KeyValuePair<string, IVariable> kvp in db.storage)
            {
                allVariablesInBank.Add(kvp.Key);
            }

            if (wildcardName == "**")
            {
                //take all objects in given bank, corresponds to '*!*' + '%*' + '#*'
                if (wildcardFreq != null)
                {
                    new Error("You cannot combine '**' wildcard with frequency");
                }
                foreach (string s in allVariablesInBank)
                {
                    varsMatched.Add(bankname + Globals.symbolBankColon + s);
                }
            }
            else
            {

                string name3a = wildcardName;
                if (wildcardFreq == null)
                {
                    if (!G.Chop_HasSigil(wildcardName)) name3a += Globals.freqIndicator + G.ConvertFreq(Program.options.freq);
                }
                else
                {
                    name3a += Globals.freqIndicator + wildcardFreq;
                }

                List<string> matched = MatchWildcard(name3a, allVariablesInBank);

                foreach (string match in matched)
                {
                    varsMatched.Add(bankname + Globals.symbolBankColon + match);
                }
            }

            varsMatched.Sort(StringComparer.OrdinalIgnoreCase);  //always sorting here because they stem from dict keys that are in random order

            return varsMatched;
        }

        /// <summary>
        /// Used in the central SearchFromTo() method.
        /// </summary>
        /// <param name="bankname"></param>
        /// <param name="name1"></param>
        /// <param name="name2"></param>
        /// <param name="wildcardFreq"></param>
        /// <returns></returns>
        private static List<string> RangeInBank(string bankname, string name1, string name2, string wildcardFreq)
        {
            if (wildcardFreq == "*")
            {
                G.Writeln2("Frequency '!*' not supported for ranges ('..')");
                throw new GekkoException();
            }
            if (wildcardFreq == null) wildcardFreq = G.ConvertFreq(Program.options.freq);

            //For each matching databank
            List<string> varsMatched = new List<string>();
            List<string> allVariablesInBank = new List<string>();
            Databank db = Program.databanks.GetDatabank(bankname, true);
            foreach (KeyValuePair<string, IVariable> kvp in db.storage)
            {
                if (G.Chop_HasSigil(kvp.Key)) allVariablesInBank.Add(kvp.Key);
                else if (G.Equal(G.Chop_GetFreq(kvp.Key), wildcardFreq)) allVariablesInBank.Add(G.Chop_RemoveFreq(kvp.Key));
            }

            //after this, allVariablesInBank only has the right frequency (which is dropped), or have sigil

            foreach (string s in allVariablesInBank)
            {
                string w = null;
                if (!G.Chop_HasSigil(s)) w = wildcardFreq;
                AddIfInRange(bankname, w, s, name1, name2, varsMatched);
            }

            varsMatched.Sort(StringComparer.OrdinalIgnoreCase);  //always sorting here because they stem from dict keys that are in random order
            return varsMatched;
        }

        /// <summary>
        /// Matches wildcards like a*b?c. Simple matching, no fancy stuff regarding %, # or !.
        /// </summary>
        /// <param name="wild1"></param>
        /// <param name="stringsThatCanBeMatched"></param>
        /// <returns></returns>
        public static List<string> MatchWildcard(string wild1, List<string> stringsThatCanBeMatched)
        {
            //Simple, can replace MatchWilcard() and similar methods, do a search on "IsMatch("
            //Not sorted at the end
            List<string> inputs = new List<string>();

            Wildcard wc = new Wildcard(wild1, RegexOptions.IgnoreCase);
            foreach (string n2 in stringsThatCanBeMatched)
            {
                if (wc.IsMatch(n2)) inputs.Add(n2);
            }
            //if (sort) inputs.Sort(StringComparer.OrdinalIgnoreCase);
            return inputs;
        }

        /// <summary>
        /// CHECKOFF command.
        /// </summary>
        /// <param name="vars2"></param>
        /// <param name="type"></param>
        public static void Checkoff(List<string> vars2, string type)
        {

            if (type == "clear")
            {
                Globals.checkoff.Clear();
                G.Writeln();
                G.Writeln("CHECKOFF variables cleared");
            }
            else
            {

                if (vars2.Count == 1 && vars2[0] == "?")
                {
                    G.Writeln();
                    if (Globals.checkoff.Count == 0)
                    {
                        G.Writeln();
                        G.Writeln("There are 0 variables not checked for convergence in the Gauss algorithm.");
                    }
                    else
                    {
                        G.Writeln();
                        CheckoffHelper();
                    }
                }
                else
                {

                    List<string> vars3 = vars2;
                    Globals.checkoff.Clear();
                    Globals.checkoff.AddRange(vars3);
                    G.Writeln();
                    CheckoffHelper();
                }
            }
            return;
        }

        /// <summary>
        /// Helper method.
        /// </summary>
        private static void CheckoffHelper()
        {
            G.Writeln("The following " + Globals.checkoff.Count + " variables are not checked for convergence in the Gauss algorithm:");
            G.PrintListWithCommas(Globals.checkoff, false);
        }

        /// <summary>
        /// ENDO command.
        /// </summary>
        /// <param name="vars2"></param>
        public static void Endo(List<string> vars2)
        {
            if (G.GetModelSourceType() != EModelType.Gekko)
            {
                new Error("No Gekko model is defined for endogenization");
                //throw new GekkoException();
            }

            Globals.hasBeenEndoExoStatementsSinceLastSim = 1;

            if (vars2 == null)
            {
                Program.model.modelGekko.endogenized.Clear();
                return;
            }

            //TODO: check that manipulated vars exist in model -- no: model may be re-read etc.

            List<string> vars = vars2;
            //if (vars.Count == 0) Program.model.modelGekko.endogenized.Clear();  //not accumulating anymore
            Program.model.modelGekko.endogenized.Clear();
            foreach (string var in vars)
            {
                if (Program.model.modelGekko.endogenized.ContainsKey(var))
                {
                    new Error("" + var + " is already endogenized");
                    //throw new GekkoException();
                }
                else Program.model.modelGekko.endogenized.Add(var, "");

            }
            G.Writeln2("Endogenized " + vars.Count + " variables");
            return;
        }

        /// <summary>
        /// Print lists of endogenous and exogenous variables.
        /// </summary>
        public static void PrintEndoExoLists()
        {
            G.Writeln();
            if ((G.GetModelSourceType() != EModelType.Gekko) || Program.model.modelGekko.endogenized == null || Program.model.modelGekko.endogenized.Count == 0) G.Writeln("There are 0 endogenized variables");
            else
            {
                if (Program.model.modelGekko.endogenized.Count == 1) G.Write("There is " + Program.model.modelGekko.endogenized.Count + " endogenized var: ");
                else G.Write("There are " + Program.model.modelGekko.endogenized.Count + " endogenized vars: ");
                List<string> temp1 = new List<string>();
                foreach (string s in Program.model.modelGekko.endogenized.Keys) temp1.Add(s);
                temp1.Sort();
                G.PrintListWithCommas(temp1, false);
            }
            //G.Writeln();
            if ((G.GetModelSourceType() != EModelType.Gekko) || Program.model.modelGekko.exogenized == null || Program.model.modelGekko.exogenized.Count == 0) G.Writeln("There are 0 exogenized variables");
            else
            {
                if (Program.model.modelGekko.exogenized.Count == 1) G.Write("There is " + Program.model.modelGekko.exogenized.Count + " exogenized var: ");
                else G.Write("There are " + Program.model.modelGekko.exogenized.Count + " exogenized vars: ");
                List<string> temp1 = new List<string>();
                foreach (string s in Program.model.modelGekko.exogenized.Keys) temp1.Add(s);
                temp1.Sort();
                G.PrintListWithCommas(temp1, false);
            }
            G.Writeln();
            return;
        }

        /// <summary>
        /// EXO command.
        /// </summary>
        /// <param name="vars2"></param>
        public static void Exo(List<string> vars2)
        {
            //TODO: check that manipulated vars exist in model -- no: model may be re-read etc.
            if (G.GetModelSourceType() != EModelType.Gekko)
            {
                new Error("No Gekko model is defined for exogenization");
                //throw new GekkoException();
            }

            Globals.hasBeenEndoExoStatementsSinceLastSim = 1;

            if (vars2 == null)
            {
                Program.model.modelGekko.exogenized.Clear();
                return;
            }

            List<string> vars = vars2;
            //if (vars.Count == 0) Program.model.modelGekko.exogenized.Clear();  //not accumulating anymore
            Program.model.modelGekko.exogenized.Clear();
            foreach (string var in vars)
            {
                if (Program.model.modelGekko.exogenized.ContainsKey(var))
                {
                    new Error("" + var + " is already exogenized");
                    //throw new GekkoException();
                }
                else Program.model.modelGekko.exogenized.Add(var, "");
            }
            G.Writeln2("Endogenized " + vars.Count + " variables");
            return;
        }

        /// <summary>
        /// Used for DISP&lt;info&gt;. Will show values of variables determining an equation LHS.
        /// </summary>
        /// <param name="tStart"></param>
        /// <param name="tEnd"></param>
        /// <param name="list2"></param>
        public static void Info(GekkoTime tStart, GekkoTime tEnd, List list2)
        {
            if (G.GetModelSourceType() != EModelType.Gekko)
            {
                new Error("DIP<info> command requires a Gekko model -- seems no model is defined");
                //throw new GekkoException();
            }

            List<string> list = Stringlist.GetListOfStringsFromList(list2);

            if (!(tStart.super == tEnd.super && tStart.sub == tEnd.sub))
            {
                new Error("DISP<info> must be called with identical start and end date");
                //throw new GekkoException();
            }
            foreach (string var2 in list)
            {
                Program.PrintEquationVariables(tStart, var2);
            }
        }

        /// <summary>
        /// Overload.
        /// </summary>
        /// <param name="type"></param>
        /// <param name="leftSide"></param>
        /// <param name="rightSide"></param>
        public static void List(string type, string leftSide, List<string> rightSide)
        {
            List(type, leftSide, rightSide, true);
        }

        /// <summary>
        /// Helper method for clickable links
        /// </summary>
        /// <param name="type"></param>
        /// <param name="leftSideInput"></param>
        /// <param name="rightSide"></param>
        /// <param name="hasHashSign"></param>
        public static void List(string type, string leftSideInput, List<string> rightSide, bool hasHashSign)
        {
            if (type.StartsWith("?"))
            {
                if (type != "?" && type != "?_show_all_lists")
                {
                    //is a click on a system list: show it in output tab
                    try
                    {
                        string m = type.Substring(2);
                        List<string> a1 = Stringlist.GetListOfStringsFromList(Program.databanks.GetFirst().GetIVariable(Globals.symbolCollection + m));
                        bool showList = true;
                        if (a1.Count > 5000)
                        {
                            DialogResult result = MessageBox.Show("Note: showing lists with more than 5000 items tends to freeze the \noutput tab. You may use \"list listfile " + m + " = #" + m + ";\" to put the list into an\nexternal file " + m + ".lst. \nProceed anyway?", "Show list", MessageBoxButtons.YesNo, MessageBoxIcon.None, MessageBoxDefaultButton.Button2, MessageBoxOptions.DefaultDesktopOnly);
                            if (result != DialogResult.Yes)
                            {
                                showList = false;
                            }
                        }
                        if (showList)
                        {
                            Gui.gui.tabControl1.SelectedTab = Gui.gui.tabPageOutput;
                            O.Cls("output");
                            //run in thread ideally
                            foreach (string s in a1)
                            {
                                G.Writeln(s, ETabs.Output);
                            }
                        }
                    }
                    catch
                    {
                        new Error("Failed to show list");
                        //throw new GekkoException();
                    }
                }
                else
                {

                }

            }  //end of if startswith("?")
            else
            {
                new Error("Internal error #8794372264");
                //throw new GekkoException();                
            }
            return;
        }

        /// <summary>
        /// Helper method for printing out lists with LIST?, avoiding listing of all the models lists, if the model is large.
        /// </summary>
        /// <returns></returns>
        public static bool IsLargeModel()
        {
            bool hasLargeModel = false;
            IVariable all = Program.databanks.GetFirst().GetIVariable(Globals.symbolCollection + "all");
            if (all != null && all.Type() == EVariableType.List)
            {
                if ((all as List).list.Count > 100) hasLargeModel = true; //more then 100 vars --> no printing of model lists here
            }
            return hasLargeModel;
        }

        /// <summary>
        /// Helper method for LIST?.
        /// </summary>
        /// <param name="m"></param>
        public static void WriteListItems(string m)
        {
            IVariable iv = null; Program.databanks.GetFirst().GetIVariable(Globals.symbolCollection + m);
            if (iv == null)
            {
                new Error("List " + Globals.symbolCollection + m + " was not found");
            }
            List<string> a1 = Stringlist.GetListOfStringsFromList(iv);

            if (a1.Count == 0)
            {
                G.Writeln2("list #" + m + " = [null]");
            }
            else if (a1.Count < 100)
            {
                G.Writeln2("list #" + m + " = " + Stringlist.GetListWithCommas(a1) + "  (" + a1.Count + " elements)");
            }
            else
            {
                G.Write2("list #" + m + " = ["); G.WriteLink("show", "list:?_" + m); G.Writeln("]  (" + a1.Count + " elements from '" + a1[0] + "' to '" + a1[a1.Count - 1] + "')");
            }
        }

        /// <summary>
        /// Show the model name at the top of the main Gekko GUI window.
        /// </summary>
        public static void GuiSetModelName()
        {
            if (Globals.workerThread != null)
            {
                //1.4.9 stuff
                string version = G.PrintVersion(Globals.gekkoVersion, false);
                string s1 = "";
                if (Globals.modelFileName == null || Globals.modelFileName == "")
                {
                    s1 = "Gekko " + version;  //this is what Word etc. does too
                }
                else
                {
                    s1 = Globals.modelFileName + " - " + "Gekko " + version;  //this is what Word etc. does too
                }
                Program.WorkerThreadHelper1 wh = new Program.WorkerThreadHelper1();
                wh.titleField = s1;
                Globals.workerThread.gekkoGui.Invoke(Globals.workerThread.gekkoGui.threadDelegateSetTitle, wh);
            }
        }

        /// <summary>
        /// MODEL command, loads Gekko or GAMS models (the latter requires MODEL&lt;gms&gt;)
        /// </summary>
        /// <param name="o"></param>
        public static void Model(O.Model o)
        {
            //Three possibilities:
            //1. MODEL adam.frm;        EModelType.Gekko           --> Normal Gekko model, .frm extension is default
            //2. MODEL<gms> makro.gms;  EModelType.GAMSRaw         --> GAMS model, .gms extension is default. Tries to translate equations GAMS --> Gekko.
            //3. MODEL<gms> makro.zip;  EModelType.GAMSScalarModel --> GAMS model, files are in a zip file (and config.json describes files). Equations are excact, because unfolded GAMS eqs are transferred.

            bool isGms = G.Equal(o.opt_gms, "yes");  //later on, Program.options.model_type is set to "default" or "gams" depending upon this value.

            string fileName = o.fileName;
            P p = o.p;

            fileName = G.StripQuotes(fileName);

            Globals.modelRandomID = Program.RandomInt(11111111, 99999999);  //used in GetModelInfoPath()

            string type = "frm";
            if (isGms) type = "gms";

            bool cancel = false;
            if (fileName == "*")
            {
                SelectFile(type, ref fileName, ref cancel);
                CrossThreadStuff.SetTextInput(fileName, "model");
            }
            if (cancel) return;

            DateTime dt0 = DateTime.Now;

            fileName = G.AddExtension(fileName, "." + type);

            List<string> folders = new List<string>();
            folders.Add(Program.options.folder_model); //looks here first, after looking in working folder            
            FindFileHelper ffh = FindFile(fileName, folders, true, true, o.p);  //calls CreateFullPathAndFileName()

            Globals.modelPathAndFileName = ffh.prettyPathAndFileName;  //always contains a path            
            Globals.modelFileName = Path.GetFileName(ffh.prettyPathAndFileName);

            if (!File.Exists(ffh.realPathAndFileName))
            {
                using (Error e = new Error())
                {
                    e.MainAdd("Could not find model file '" + ffh.prettyPathAndFileName + "'");
                    e.MoreAdd("To run and solve a model, Gekko needs a model file in a suitable format (cf. the description {a{here¤model.htm}a}).");
                    e.MoreAdd("The model file must have extension .frm. For a guided tour of modeling, see {a{this¤guided_tour_modeling.htm}a} guide.");
                    e.MoreAdd("You may use 'model *;' to look for model files in the current working folder.");
                }
            }

            //salted with subpers, so will end with "1" for annual, "4" for quarterly.
            string modelHash = Program.GetMD5Hash(null, ffh.realPathAndFileName, O.CurrentSubperiods().ToString());

            //string mdlFileNameAndPath = Globals.localTempFilesLocation + "\\" + Globals.gekkoVersion + "_" + "model" + "_" + modelHash + Globals.cacheExtension;

            if (Program.options.model_cache == true)
            {
                try
                {
                    //TODO 
                    //TODO 
                    //TODO do something about ms here
                    //TODO 
                    //TODO 
                    double hashMs = 0d;
                    DateTime t0 = DateTime.Now;
                    Model modelTemp = Program.ReadParallelModelMaybe(modelHash);                    

                    if (modelTemp == null)
                    {
                        //model.modelGamsScalar = new ModelGamsScalar(model);
                        model.modelCommon.loadedFromCacheFile = false;
                    }
                    else
                    {
                        model = modelTemp;
                        if (Globals.runningOnTTComputer) new Writeln("TTH: Parallel protobuf read: " + G.Seconds(t0));
                        DateTime t1 = DateTime.Now;
                        if (model.modelGamsScalar != null)
                        {
                            GamsModel.GAMSScalarModelHelper(true, model.modelGamsScalar);
                        }
                        else if (model.modelGekko != null)
                        {
                            GetListsFromModelListHelper(model.modelGekko);
                            //=============================================
                            //FOR SAFETY: see mail from TKD 5/3 2013
                            Program.model.modelGekko.simulateResults = new double[10];
                            //=============================================                                                        
                            model.modelGekko.modelInfo.fileName = ffh.prettyPathAndFileName;  //otherwise the filename will be the file used when the cache-file was made (these are often equal of course, but not always).
                        }
                        model.modelCommon.loadedFromCacheFile = true;
                        //timeCompile = "compile: " + G.Seconds(t1);
                    }
                }
                catch (Exception e)
                {
                    if (G.IsUnitTesting())
                    {
                        throw;
                    }
                    else
                    {
                        //do nothing, we then have to parse the file
                        model.modelCommon.loadedFromCacheFile = false;
                    }
                }
            }
            else
            {
                model.modelCommon.loadedFromCacheFile = false;
            }

            if (model.modelCommon.loadedFromCacheFile)
            {
                //no writing of .mdl file of course                
            }
            else
            {
                EModelType modelType = EModelType.Gekko;
                if (isGms) { if (G.Equal(Path.GetExtension(ffh.realPathAndFileName), ".zip")) modelType = EModelType.GAMSScalar; else modelType = EModelType.GAMSRaw; }

                if (modelType == EModelType.Gekko)
                {                    
                    string textInputRaw = Program.GetTextFromFileWithWait(ffh.realPathAndFileName);  //textInputRaw is without any VARLIST$
                    ReadGekkoModel(ffh.realPathAndFileName, ffh.prettyPathAndFileName, dt0, textInputRaw, o.p);
                }
                else if (modelType == EModelType.GAMSRaw)
                {
                    string textInputRaw = Program.GetTextFromFileWithWait(ffh.realPathAndFileName);
                    Model model = GamsModel.ReadGamsRawModel(textInputRaw, ffh.realPathAndFileName, o);
                    Program.model = model;
                }
                else if (modelType == EModelType.GAMSScalar)
                {
                    Model model = GamsModel.ReadGAMSScalarModel(o, folders, ffh.realPathAndFileName);
                    if (false) GamsModel.GAMSParser();
                    if (false) GamsModel.GamsGMO();
                    Program.model = model;
                }
                else new Error("No model defined");

                try //not the end of world if it fails (should never be done if model is read from zipped protobuffer (would be waste of time))
                {
                    DateTime dt1 = DateTime.Now;
                    if (model.modelGamsScalar != null) GamsModel.GAMSScalarModelHelper(false, model.modelGamsScalar);                    
                    //TODO what about last argument ms?                    
                    Program.WriteParallelModel(Program.options.system_threads, ffh.realPathAndFileName, modelHash, 0, model);
                }
                catch (Exception e)
                {
                    //do nothing, not the end of the world if it fails
                }
            }

            //if not put here, info will not be printed when loading from cache
            if (model.modelGekko != null) model.modelGekko.modelInfo.Print(model.modelCommon);

        }

        /// <summary>
        /// Read a Gekko model from .frm file.
        /// </summary>
        private static void ReadGekkoModel(string fileName, string fileNamePretty, DateTime dt0, string textInputRaw, P p)
        {
            Model model = new Model();
            model.modelCommon.freq = Program.options.freq;

            Program.model = model;

            model.modelCommon.SetModelSourceType(EModelType.Gekko);
            //TODO: keep the old version, so model command can be undone (like undo sim)
            ModelGekko modelGekko = new ModelGekko(model);
            modelGekko.modelInfo = new ModelInfo();
            modelGekko.modelInfo.fileName = fileNamePretty;
            //this also creates Program.model.modelGekko.varlist if there is a varlist
            ModelCommentsHelper modelCommentsHelper = new ModelCommentsHelper();
            string textInput = Program.HandleModelFiles(textInputRaw, modelCommentsHelper);
            
            model.modelGekko.modelInfo.date = modelCommentsHelper.dateText;
            model.modelGekko.modelInfo.info = modelCommentsHelper.infoText;
            model.modelGekko.signatureStatus = modelCommentsHelper.signatureStatus;
            model.modelGekko.signatureFoundInFileHeader = modelCommentsHelper.signatureFoundInFileHeader;
            model.modelGekko.modelHashTrue = modelCommentsHelper.modelHashTrue;

            string parsingSeconds = null;

            DateTime t1 = DateTime.Now;
            //ParseModel() is reasonably fast. But needs only to be run when new model is called.
            //[[1]]
            GekkoDictionary<string, string> vals = Parser.Frm.ParserFrmCreateAST.ParserFrmCreateASTHelper(textInput, fileName);
            //TIMING: the rest of this method takes 0.5 sec on dec09, that is nearly as much as parsing and CreateASTNodesForModel()
            //This loop below alone takes 0.5 seconds on dec09, but it also does all the stuff regarding
            //  formula codes DJZ, dlog() on left and right side, broken lags etc. etc. So maybe fair enough it
            //  takes some time. It also writes out actual C# code to be used later on when compiling.
            Parser.Frm.ParserFrmWalkAST.ParserFrmWalkASTHelper(vals);

            ProduceGamsScalar2000Model(model); //in principle this could be done before first DECOMP. But then we would need to get that into protobuf, and WriteGamsScalarModel() is pretty fast.

            Program.GuiSetModelName();
            if (model.modelGekko.largestLead != model.modelGekko.largestLeadOutsideRevertedPart)
            {
                new Error("There is a lead [+" + model.modelGekko.largestLead + "] in one of the X- or Y-equations that is larger than the largest lead elsewhere in the model [+" + model.modelGekko.largestLeadOutsideRevertedPart + "]. Please use T-equations for such variables");                
            }
            parsingSeconds = G.Seconds(t1);
            Parser.Frm.ParserFrmCompileAST.ParserFrmOrderAndCompileAST(ECompiledModelType.Gauss, true, false);  //default.
            
            Parser.Frm.ParserFrmCompileAST.ParserFrmHandleVarlist(modelCommentsHelper, model, p);

            if (!G.NullOrEmpty(modelCommentsHelper.cutout_runbefore))
            {
                model.modelGekko.runBefore = modelCommentsHelper.cutout_runbefore;
            }

            if (!G.NullOrEmpty(modelCommentsHelper.cutout_runafter))
            {
                model.modelGekko.runAfter = modelCommentsHelper.cutout_runafter;
            }

            model.modelGekko.modelInfo.timeUsedParsing = parsingSeconds;
            model.modelGekko.modelInfo.timeUsedTotal = G.Seconds(dt0);
        }

        /// <summary>
        /// Produce a scalar-2000 model suitable for DECOMP. Input is a Gekko model.        
        /// </summary>
        /// <param name="model"></param>
        private static void ProduceGamsScalar2000Model(Model model)
        {
            DateTime dt0 = DateTime.Now;
            
            /// See #jseds78hsd33.
            List<string> equations = new List<string>();
            List<string> dictionary = new List<string>();

            List<string> dictionaryNames = new List<string>();  //0-based
            for (int i = 0; i < Program.model.modelGekko.varsBType.Count; i++) dictionaryNames.Add(null);
            List<string> dictionaryEqs = new List<string>();  //0-based

            equations.Add("* Equation counts " + Program.model.modelGekko.equations.Count);
            equations.Add("* Variable counts " + Program.model.modelGekko.varsBType.Count);

            GekkoTime t0 = new GekkoTime(model.modelCommon.GetFreq(), Globals.decomp2000, 1);

            int n = -1;
            foreach (EquationHelper eh in Program.model.modelGekko.equations)
            {
                n++;
                equations.Add("e" + (n + 1) + "..  " + eh.scalar_csCodeLhs + " =E= " + eh.scalar_csCodeRhs + ";");
                dictionaryEqs.Add("  e" + (n + 1) + "  " + Globals.gekkoEquationPrefix + eh.lhs + "(" + t0.ToString() + ")");
            }
            equations.Add("* set non-default bounds");
            equations.Add("Model m / all /;");

            n = -1;
            foreach (KeyValuePair<string, BTypeData> kvp in Program.model.modelGekko.varsBType)
            {
                n++;
                string s = kvp.Key;
                string variable = null; int lag = 0;
                G.ExtractVariableAndLag(kvp.Key, out variable, out lag);
                dictionaryNames[kvp.Value.bNumber] = "  x" + (n + 1) + "  " + variable + "(" + (t0.Add(lag).ToString()) + ")";
            }

            dictionary.Add("Equation counts " + dictionaryEqs.Count);
            dictionary.Add("");
            dictionary.Add("Variable counts " + dictionaryNames.Count);
            dictionary.Add("");
            dictionary.Add("Equations " + "1" + " to " + dictionaryEqs.Count);
            dictionary.AddRange(dictionaryEqs);
            dictionary.Add("");
            dictionary.Add("Variables " + "1" + " to " + dictionaryNames.Count);
            dictionary.AddRange(dictionaryNames);
            dictionary.Add("");

            string e = Stringlist.ExtractTextFromLines(equations).ToString();
            string d = Stringlist.ExtractTextFromLines(dictionary).ToString();

            //Program.model = new Model();                    
            GAMSScalarModelSettings settings = new GAMSScalarModelSettings();
            settings.scalarMemoryModelProducedByGekko = true;

            settings.equations = equations;
            settings.dictionary = dictionary;

            Model modelTemp = GamsModel.ReadGamsScalarModelEquations(settings, model);
            model.modelGamsScalar = modelTemp.modelGamsScalar;
            model.modelGamsScalar.isStaticModel = true;

            new Writeln("Linking to DECOMP module (" + G.Seconds(dt0) + ")");
        }

        /// <summary>
        /// Helper for REBASE and rebase(). The series tsNew should be a (deep) clone of the input series. Sum is sum over period for the input series.
        /// n is the observations in the period. The period is often n = 1.  See also RebaseHelpe12().
        /// </summary>
        /// <param name="tsNew"></param>
        /// <param name="sum"></param>
        /// <param name="n"></param>
        public static void RebaseHelper2(Series tsNew, double sum, double n, double indexValue)
        {
            double[] data = tsNew.GetDataSequenceUnsafePointerAlterBEWARE();  //do not optionally change NaN to 0
            for (int ii = 0; ii < data.Length; ii++)
            {
                //could use ts.firstPeriodPositionInArray etc., but better to do it for all since ts.ts.firstPeriodPositionInArray is not always correct
                data[ii] = data[ii] / (sum / n) * indexValue;
            }
        }

        /// <summary>
        /// Helper for REBASE and rebase(). For the period t1-t2 (rebase window, often just 1 period), sum and n (number of obs) is calculated. 
        /// A series t2 is returned (which is iv cast as Series). See also RebaseHelper2().
        /// </summary>
        /// <param name="t1"></param>
        /// <param name="t2"></param>
        /// <param name="iv"></param>
        /// <param name="ts"></param>
        /// <param name="sum"></param>
        /// <param name="n"></param>
        public static void RebaseHelper1(GekkoTime t1, GekkoTime t2, IVariable iv, out Series ts, out double sum, out double n)
        {
            ts = iv as Series;
            if (ts == null)
            {
                new Error("Rebasing is only meaningful for series type. Type is: " + G.GetTypeString(iv));
            }

            GekkoTime ddate1 = t1;
            GekkoTime ddate2 = t2;

            if (t1.freq == EFreq.A && (ts.freq == EFreq.Q || ts.freq == EFreq.M))
            {
                //if a year is used for a quarterly series, q1-q4 is used.
                ddate1 = new GekkoTime(ts.freq, t1.super, 1);
                int end = -12345;
                if (ts.freq == EFreq.Q)
                {
                    end = Globals.freqQSubperiods;
                }
                else if (ts.freq == EFreq.M)
                {
                    end = Globals.freqMSubperiods;
                }
                else
                {
                    new Error("freq error #903853245");
                    //throw new GekkoException();
                }
                ddate2 = new GekkoTime(ts.freq, t1.super, end);
            }

            if (ddate1.freq != ts.freq || ddate2.freq != ts.freq)
            {
                new Error("frequency of timeseries and frequency of period(s) do not match");
                //throw new GekkoException();
            }

            sum = 0d;
            n = 0d;
            foreach (GekkoTime t in new GekkoTimeIterator(ddate1, ddate2))
            {
                sum += ts.GetDataSimple(t);
                n++;
            }

            if (G.isNumericalError(sum))
            {
                new Error("Series " + ts.meta.parentDatabank.name + ":" + ts.name + " from " + ddate1.ToString() + "-" + ddate2.ToString() + " contains missing values");
                //throw new GekkoException();
            }
            if (sum == 0d)
            {
                new Error("Series " + ts.meta.parentDatabank.name + ":" + ts.name + " from " + ddate1.ToString() + "-" + ddate2.ToString() + " sums to 0, cannot rebase");
                //throw new GekkoException();
            }
        }

        ///// <summary>
        ///// Load a cached model from an internal protobuf file.
        ///// </summary>
        ///// <param name="fileNamePretty"></param>
        ///// <param name="mdlFileNameAndPath"></param>
        //private static void ParserFrmGetProtobuf(string fileNamePretty, string mdlFileNameAndPath)
        //{
        //    try
        //    {
        //        DateTime dt1 = DateTime.Now;
        //        Program.model.modelGekko = ProtobufRead<ModelGekko>(mdlFileNameAndPath);

        //        GetListsFromModelListHelper();

        //        //=============================================
        //        //FOR SAFETY: see mail from TKD 5/3 2013
        //        Program.model.modelGekko.simulateResults = new double[10];
        //        //=============================================

        //        G.WritelnGray("Loaded known model from cache in: " + G.SecondsFormat((DateTime.Now - dt1).TotalMilliseconds));
        //        model.loadedFromCacheFile = true;
        //        model.modelGekko.modelInfo.fileName = fileNamePretty;  //otherwise the filename will be the file used when the cache-file was made (these are often equal of course, but not always).
        //    }
        //    catch (Exception e)
        //    {
        //        if (G.IsUnitTesting())
        //        {
        //            throw;
        //        }
        //        else
        //        {
        //            //do nothing, we then have to parse the file
        //            model.loadedFromCacheFile = false;
        //        }
        //    }
        //}

        /// <summary>
        /// Helper for equation browser GUI window (FIND)
        /// </summary>
        /// <param name="s"></param>
        /// <returns></returns>
        public static string DecompGetNameFromContrib(string s)
        {
            string[] ss = s.Split('¤');
            string ss1 = G.Chop_RemoveBank(ss[0]);
            string ss5 = ss1;
            if (ss.Length > 1) ss5 = ss1 + "¤" + ss[1];
            return ss5;
        }

        /// <summary>
        /// Helper for eval function that transforms a statement (as a string) into a Func with the C# code.
        /// This method is also used by the "new" DECOMP.
        /// </summary>
        /// <param name="conditionals"></param>
        /// <param name="statement"></param>
        public static void CallEval(string conditionals, string statement)
        {
            string c = null;
            if (!G.NullOrEmpty(conditionals))
            {
                c = "$ (" + conditionals + ")";
            }
            string s = c + " = " + statement;
            Program.RunGekkoCommands("VAR_KDUSJFLQO2 deleteme " + s, "", 0, new P()); //produces Func<> Globals.expression with the expression             
        }

        /// <summary>
        /// Helper for GAMS models, finding out what is the "real" dependent LHS variable (left hand side).
        /// </summary>
        /// <param name="node"></param>
        /// <param name="lhs"></param>
        public static void GetLhsVariable(TokenHelper node, ref string lhs)
        {
            if (lhs != null) return;  //found the lhs

            if (node.HasNoChildren())
            {
                //not a sub-node, do nothing             
            }
            else
            {
                //an empty node with children
                string lineText = null;
                for (int ii = 0; ii < node.subnodes.Count(); ii++)
                {
                    string varname = null;

                    bool dollar = false;
                    TokenHelper previous = node.subnodes[ii].SiblingBefore();  //it seems dollars are only in the eq, not set on the lhs variable
                    if (previous != null && previous.s == "$")
                    {
                        dollar = true;
                    }

                    if (!dollar)  //we skip looking at variables, if it is like x $ ... or x $ (...)
                    {

                        if (node.subnodes[ii].HasChildren())
                        {
                            if (node.subnodes[ii].SubnodesType(false) == "(")
                            {
                                //will not look deeper into [...], or later on {...}, only (...)
                                GetLhsVariable(node.subnodes[ii], ref lhs);
                            }
                        }
                        else
                        {

                            if (node.subnodes[ii].type == ETokenType.Word)
                            {
                                varname = node.subnodes[ii].ToStringTrim();
                                lineText = node.subnodes[ii].LineAndPosText();

                                TokenHelper next = node.subnodes[ii].SiblingAfter();
                                if (IsLaggedOrLeaded(node.subnodes[ii]))  //will detect x[#i][-1] + y = ... for instance
                                {
                                    varname = null;
                                }
                                else if (next != null && next.HasChildren() && next.SubnodesType() == "(")  //will detect log(x) + y = ... , not thinking "log" is a variable
                                {
                                    varname = null;  //function name
                                }
                                else if (node.subnodes[ii].leftblanks == 0 && previous != null && (previous.s == "#" || previous.s == "%"))
                                {
                                    //name like #x or %x. This will probably not happen, since from gauss such a var will be a #i,
                                    //and the #i will be inside [...] or $ (...)
                                    varname = null;
                                }
                            }
                        }
                    }

                    if (lhs == null && G.IsSimpleToken(varname))
                    {
                        lhs = varname;  //only if lhs is not already found, and if the name is a token
                    }
                }
            }
        }

        /// <summary>
        /// Will detect x[#i][-1] + y = ...  . Used in GetLhsVariable().
        /// </summary>
        /// <param name="x"></param>
        /// <returns></returns>
        private static bool IsLaggedOrLeaded(TokenHelper x)
        {
            bool lagLead = false;
            if (Program.options.model_gams_dep_current) return false;  //even if it is x[-1] or x[+1], a false will be returned.
            TokenHelper next = x.SiblingAfter();
            if (next != null && next.SubnodesType() == "[")
            {
                TokenHelper next2 = next.SiblingAfter();
                if (next2 != null && next2.SubnodesType() == "[")
                {
                    //Something like x[a, #i, b][-1]
                    bool lagLead2 = IsLagOrLeadBracket(next2);
                    if (lagLead2) lagLead = true;
                }
                else
                {
                    //Something like x[-1]
                    bool lagLead2 = IsLagOrLeadBracket(next);
                    if (lagLead2) lagLead = true;
                }
            }
            return lagLead;
        }

        /// <summary>
        /// Used in IsLaggedOrLeaded().
        /// </summary>
        /// <param name="next2"></param>
        /// <returns></returns>
        private static bool IsLagOrLeadBracket(TokenHelper next2)
        {
            bool lagLead = false;
            List<TokenHelperComma> split = next2.SplitCommas(true);
            if (split.Count == 1)
            {
                string ss = split[0].list.ToString();
                if ((ss.StartsWith("-") || ss.StartsWith("+")) && G.IsInteger(ss, true, false))  //x[-1] or x[+1]
                {
                    lagLead = true;
                }
            }
            return lagLead;
        }

        /// <summary>
        /// Helper method when loading a model from a cached internal protobuf file (getting model lists back in).
        /// </summary>
        private static void GetListsFromModelListHelper(ModelGekko modelGekko)
        {
            string[] lists = new string[] { "all", "endo", "exo", "exod", "exodjz", "exoj", "exotrue", "exoz" };
            foreach (string s in lists)
            {
                if (Program.databanks.GetGlobal().ContainsIVariable(Globals.symbolCollection + s)) Program.databanks.GetGlobal().RemoveIVariable(Globals.symbolCollection + s);
            }

            if (modelGekko.modelInfo.modelListHelper.all != null) Program.databanks.GetGlobal().AddIVariable(Globals.symbolCollection + "all", new List(Stringlist.GetListOfIVariablesFromListOfStrings(modelGekko.modelInfo.modelListHelper.all.ToArray())));
            else Program.databanks.GetGlobal().AddIVariable(Globals.symbolCollection + "all", new List());

            if (modelGekko.modelInfo.modelListHelper.endo != null) Program.databanks.GetGlobal().AddIVariable(Globals.symbolCollection + "endo", new List(Stringlist.GetListOfIVariablesFromListOfStrings(modelGekko.modelInfo.modelListHelper.endo.ToArray())));
            else Program.databanks.GetGlobal().AddIVariable(Globals.symbolCollection + "endo", new List());

            if (modelGekko.modelInfo.modelListHelper.exo != null) Program.databanks.GetGlobal().AddIVariable(Globals.symbolCollection + "exo", new List(Stringlist.GetListOfIVariablesFromListOfStrings(modelGekko.modelInfo.modelListHelper.exo.ToArray())));
            else Program.databanks.GetGlobal().AddIVariable(Globals.symbolCollection + "exo", new List());

            if (modelGekko.modelInfo.modelListHelper.exod != null) Program.databanks.GetGlobal().AddIVariable(Globals.symbolCollection + "exod", new List(Stringlist.GetListOfIVariablesFromListOfStrings(modelGekko.modelInfo.modelListHelper.exod.ToArray())));
            else Program.databanks.GetGlobal().AddIVariable(Globals.symbolCollection + "exod", new List());

            if (modelGekko.modelInfo.modelListHelper.exodjz != null) Program.databanks.GetGlobal().AddIVariable(Globals.symbolCollection + "exodjz", new List(Stringlist.GetListOfIVariablesFromListOfStrings(modelGekko.modelInfo.modelListHelper.exodjz.ToArray())));
            else Program.databanks.GetGlobal().AddIVariable(Globals.symbolCollection + "exodjz", new List());

            if (modelGekko.modelInfo.modelListHelper.exoj != null) Program.databanks.GetGlobal().AddIVariable(Globals.symbolCollection + "exoj", new List(Stringlist.GetListOfIVariablesFromListOfStrings(modelGekko.modelInfo.modelListHelper.exoj.ToArray())));
            else Program.databanks.GetGlobal().AddIVariable(Globals.symbolCollection + "exoj", new List());

            if (modelGekko.modelInfo.modelListHelper.exotrue != null) Program.databanks.GetGlobal().AddIVariable(Globals.symbolCollection + "exotrue", new List(Stringlist.GetListOfIVariablesFromListOfStrings(modelGekko.modelInfo.modelListHelper.exotrue.ToArray())));
            else Program.databanks.GetGlobal().AddIVariable(Globals.symbolCollection + "exotrue", new List());

            if (modelGekko.modelInfo.modelListHelper.exoz != null) Program.databanks.GetGlobal().AddIVariable(Globals.symbolCollection + "exoz", new List(Stringlist.GetListOfIVariablesFromListOfStrings(modelGekko.modelInfo.modelListHelper.exoz.ToArray())));
            else Program.databanks.GetGlobal().AddIVariable(Globals.symbolCollection + "exoz", new List());

            modelGekko.modelInfo.modelListHelper = null;  //only used for temporary transfer of these lists
        }

        /// <summary>
        /// PIPE command.
        /// </summary>
        /// <param name="o"></param>
        public static void Pipe(O.Pipe o)
        {
            //This is where we start when issuing a PIPE
            //We call the older version below, the PIPE interface mess should be cleaned up at some point...
            List<string> temp = new List<string>();
            if (G.Equal(o.opt_append, "yes")) temp.Add("append");
            if (G.Equal(o.opt_html, "yes")) temp.Add("html");
            if (G.Equal(o.opt_pause, "yes")) temp.Add("pause");
            if (G.Equal(o.opt_continue, "yes")) temp.Add("continue");
            if (G.Equal(o.opt_stop, "yes")) temp.Add("stop");
            Pipe(o.fileName, temp);
        }

        /// <summary>
        /// PIPE command.
        /// </summary>
        /// <param name="fileName"></param>
        /// <param name="args"></param>
        public static void Pipe(string fileName, List<string> args)
        {
            Pipe(fileName, args, false);
        }

        /// <summary>
        /// PIPE command.
        /// </summary>
        /// <param name="fileName"></param>
        /// <param name="args"></param>
        /// <param name="mute"></param>
        public static void Pipe(string fileName, List<string> args, bool mute)  //mute used for closeall
        {
            bool append = false;
            bool html = false;
            bool stop = false;
            bool pause = false;
            bool continue2 = false;

            if (args != null)
            {
                foreach (string s in args)
                {
                    if (G.Equal(s, "append")) append = true;
                    else if (G.Equal(s, "html")) html = true;
                    else if (G.Equal(s, "stop")) stop = true;
                    else if (G.Equal(s, "pause")) pause = true;
                    else if (G.Equal(s, "continue")) continue2 = true;
                }
            }

            fileName = G.StripQuotes(fileName);
            //NOTE: If there is an error, Globals.pipeFile will be closed and disposed somewhere else in the
            //      code. So no need to think about using an "using" statement here.    

            if (pause && fileName != null)
            {
                new Error("You should use PIPE<pause> without a filename");
                //throw new GekkoException();
            }

            if (continue2 && fileName != null)
            {
                new Error("You should use PIPE<continue> without a filename");
                //throw new GekkoException();
            }

            if (G.Equal(fileName, "con") || stop)   //PIPE con, or PIPE<stop>
            {
                if (Globals.pipe == false)
                {
                    if (!mute)
                    {
                        if (G.Equal(fileName, "con")) new Warning("Please use PIPE<stop> instead of PIPE con");
                    }
                }
                else
                {
                    if (Globals.pipeFileHelper.pipeFile != null)
                    {
                        Globals.pipeFileHelper.CloseFile();
                    }
                    Globals.pipe = false;
                    Globals.pipeFileHelper.pipeFile = null;
                    Globals.pipeFileHelper.pipeFileFileWithPath = "";
                    if (!mute)
                        G.Writeln2("Directing output to main window");
                    if (G.Equal(fileName, "con"))
                    {
                        new Warning("Please use PIPE<stop> instead of PIPE con");
                    }
                }
            }
            else if (pause)
            {

                Globals.pipe = false;
            }
            else if (continue2)
            {

                Globals.pipe = true;
            }
            else
            {
                //piping to a file

                try
                {
                    fileName = CreateFullPathAndFileNameFromFolder(fileName, Program.options.folder_pipe);

                    if (Globals.pipe == true)
                    {
                        if (G.Equal(Globals.pipeFileHelper.pipeFileFileWithPath, fileName))
                        {
                            //already pipe to present pipefile
                            //just ignore it with no message: the message will end up in the pipefile                            
                        }
                        else
                        {
                            if (Globals.pipeFileHelper.pipeFile != null)
                            {
                                Globals.pipeFileHelper.CloseFile();
                            }
                            StartPipingToFile(fileName, append, html, mute);
                        }
                    }
                    else
                    {
                        StartPipingToFile(fileName, append, html, mute);
                    }
                }
                catch (Exception e)
                {
                    Globals.pipe = false;
                    MessageBox.Show("*** ERROR: Could not write to file '" + fileName + "'");
                    throw new GekkoException();
                }
                Globals.pipe = true;

            }
        }

        /// <summary>
        /// PIPE command. Also handles html piping.
        /// </summary>
        /// <param name="fileName"></param>
        /// <param name="append"></param>
        /// <param name="html"></param>
        /// <param name="mute"></param>
        private static void StartPipingToFile(string fileName, bool append, bool html, bool mute)
        {
            if (!mute && !Globals.pipe) G.Writeln2("Directing output to file: '" + fileName + "'");
            Globals.pipe = true;
            GekkoFileReadOrWrite option = GekkoFileReadOrWrite.Write;

            bool exists = false; if (File.Exists(fileName)) exists = true;

            bool mustDeleteFileFirst = false;
            string s1 = null;
            string s2 = null;
            if (html)
            {
                string css = "";
                //a fresh html file is made
                css = GetHtmlHeaderCssStyles();
                s1 = Globals.htmlFileStart1 + css + Globals.htmlFileStart2;
                s2 = Globals.htmlFileEnd;
                if (append && exists)
                {
                    mustDeleteFileFirst = true;
                    string s = GetTextFromFileWithWait(fileName);
                    if (s.Contains(Globals.htmlGekkoCommentary)) css = "";  //no need to duplicate
                    AddHtmlToExistingHtml(ref s1, ref s2, css, s);
                }
                else
                {
                    //then we will just use the simple empty html, since there is no file to append to.
                    //this behavior is equivalent to txt files.
                }
            }
            if (mustDeleteFileFirst)  //if html && append && exists
            {
                WaitForFileDelete(fileName);
            }

            if (append && exists && !mustDeleteFileFirst) option = GekkoFileReadOrWrite.WriteAppend;  //only for append in text files, html will have will have mustDeleteFileFirst = true. Should be ok if the file does not exist, then it is just created with no warning issued

            FileStream fs = WaitForFileStream(fileName, null, option);
            Globals.pipeFileHelper.pipeFile = G.GekkoStreamWriter(fs);
            Globals.pipeFileHelper.pipeFileTypeIsHtml = html;
            Globals.pipeFileHelper.pipeFileFileWithPath = fileName;
            if (html)
            {
                Globals.pipeFileHelper.pipeFile.Write(s1);  //this is the case if it is a html file, then we write the original content up until the </body> tag
                Globals.pipeFileHelper.htmlEndingTagsStuff = s2;
            }
        }

        /// <summary>
        /// Pipe to html file.
        /// </summary>
        /// <param name="s1"></param>
        /// <param name="s2"></param>
        /// <param name="css"></param>
        /// <param name="s"></param>
        private static void AddHtmlToExistingHtml(ref string s1, ref string s2, string css, string s)
        {
            int i = s.IndexOf("</body>", StringComparison.OrdinalIgnoreCase);
            if (i == -1)
            {
                new Error("Could not find </body> tag in the html file.");
                //throw new GekkoException();
            }
            G.SplitString(out s1, out s2, s, i);
            //new we have:
            //
            //s1 = <html> <body>
            //s2 = </body> </html>
            //
            //or
            //
            //s1 = <html> <head> </head> <body>
            //s2 = </body> </html>
            int j = s1.IndexOf("</head>", StringComparison.OrdinalIgnoreCase);
            if (j == -1)
            {
                //add a <head>...</head> section with css inside
                int k = s1.IndexOf("<body>", StringComparison.OrdinalIgnoreCase);
                if (k == -1)
                {
                    new Error("No <body> tag found in html file");
                    //throw new GekkoException();
                }
                string s1a, s1b;
                G.SplitString(out s1a, out s1b, s1, k);
                s1 = s1a + css + s1b;
            }
            else
            {
                //inject css into existing <head>...</head> section
                //multiple <style> sections are allowed in <head>
                string s1a, s1b;
                G.SplitString(out s1a, out s1b, s1, j);
                s1 = s1a + css + s1b;
            }
        }

        /// <summary>
        /// CSS code when piping or tabelling to htmll file. Used to make formatting look nice.
        /// </summary>
        /// <returns></returns>
        public static string GetHtmlHeaderCssStyles()
        {
            StringBuilder lines = new StringBuilder();
            lines.AppendLine("<style type=\"text/css\">");
            lines.AppendLine("<!-- " + Globals.htmlGekkoCommentary + " -->");
            lines.AppendLine("  td.w {}");  //lines.AppendLine("  td.w {width:4.5em;}");
            lines.AppendLine("  td.c {text-align: center;}");
            lines.AppendLine("  td.ws {white-space:nowrap;}");
            lines.AppendLine("  td.blue {background-color: rgb(174,199,225);}");
            lines.AppendLine("  td.pad {padding:0.1em 0.50em;}");
            lines.AppendLine("  td.top {border-top: 1px solid black;}");
            lines.AppendLine("  td.bottom {border-bottom: 1px solid black;}");
            lines.AppendLine("  td.left {border-left: 1px solid black;}");
            lines.AppendLine("  td.right {border-right: 1px solid black;}");
            lines.AppendLine("  td.rightlg {border-right: 1px solid lightgray;}");
            lines.AppendLine("  .gfsize {font-size: " + Program.options.table_html_fontsize + "%;}");
            lines.AppendLine("  .gfont { font-family: " + Program.options.table_html_font + " }");
            lines.AppendLine("  a { color: #0645AD; text-decoration: none; }");  //Wikipedia link color
            lines.AppendLine("  a:hover { text-decoration: underline; }");
            lines.AppendLine("</style>");
            string s = lines.ToString();
            return s;
        }

        /// <summary>
        /// Get a databank file. Will look in OPTION folder bank|bank1|bank2. May use popup if READ *.
        /// </summary>
        /// <param name="fileName"></param>
        /// <param name="cancel"></param>
        /// <param name="extension"></param>
        /// <returns></returns>
        private static FindFileHelper ReadHelper(string fileName, ref bool cancel, string extension, P p)
        {
            FindFileHelper ffh = new FindFileHelper();
            if (fileName == "*")
            {
                SelectFile(extension, ref fileName, ref cancel);
                CrossThreadStuff.SetTextInput(fileName, null);
                ffh.realPathAndFileName = fileName;
                ffh.prettyPathAndFileName = fileName;
            }
            else
            {
                fileName = G.AddExtension(fileName, "." + extension);
                List<string> folders = new List<string>();
                folders.Add(Program.options.folder_bank);
                folders.Add(Program.options.folder_bank1);
                folders.Add(Program.options.folder_bank2);
                ffh = FindFile(fileName, folders, true, true, p);
                fileName = ffh.realPathAndFileName;
            }

            return ffh;
        }

        /// <summary>
        /// Only used when finding tables ... (?)
        /// </summary>
        /// <param name="fileName"></param>
        /// <returns></returns>
        private static string FileNotFoundErrorMessage(string fileName)
        {
            string s = "*** ERROR: Could not read file '" + fileName + "' -- the file does not seem to exist";
            G.Writeln2(s);

            if (Program.options.folder == false)
            {
                G.Writeln("           Please note that 'option folder' is set to false -- so Gekko does not");
                G.Writeln("           search for the file in other folders than the working folder.");
            }
            return s;
        }

        /// <summary>
        /// Find a file, may indicate folders to look in, and may include working folder and may include libraries. 
        /// Will return null if no file is found (no file exists), but if return is non-null, the object will
        /// include the real path of the file (maybe copied or unzipped with a temp name) together with the pretty name
        /// for human use.
        /// Note that when allowLibrary == true, p must point to P object. If allowLibrary == false, p may be null.
        /// </summary>
        /// <param name="filenameMaybeWithoutPath"></param>
        /// <param name="folders"></param>
        /// <param name="includeWorkingFolder"></param>
        /// <returns></returns>
        public static FindFileHelper FindFile(string filenameMaybeWithoutPath, List<string> folders, bool includeWorkingFolder, bool allowLibrary, P p)
        {
            // +--------------- #kja890adsfjkaas1 ------------------+
            // |                                                    |
            // |    Note that something very similar takes place    |
            // |    in Libraries.GetFunction(). This method also    |
            // |    deals with "this" and "__" prefix, etc.         |
            // |                                                    |
            // +----------------------------------------------------+

            //Can be of these types:
            // -----------------------------------------------
            // zz.csv
            // sub1\sub2\zz.csv
            // \sub1\sub2\zz.csv
            // g:\data\sub1\sub2\zz.csv
            // \\localhost\g$\data\sub1\sub2\zz.csv
            // -----------------------------------------------
            // files.zip\sub2\zz.csv
            // \files.zip\sub2\zz.csv
            // g:\data\files.zip\sub2\zz.csv
            // \\localhost\g$\data\files.zip\sub2\zz.csv
            // ----------------------------------------------- 

            FindFileHelper rv = new FindFileHelper();
            bool success = false;
            string currentLibrary = null;
            if (p != null)
            {
                try
                {
                    currentLibrary = p.GetCurrentLibrary(p.GetDepthM1());
                }
                catch
                {
                    //The menu system (menu.html) does not like the above.
                    //Fix this properly for Gekko 4.0.
                }
            }

            bool hasPath = filenameMaybeWithoutPath.Contains("\\") || filenameMaybeWithoutPath.Contains(":");

            if (!success && allowLibrary && filenameMaybeWithoutPath.StartsWith(Globals.libraryDriveCheatString))
            {
                //a designated library like lib1:zz.csv (internally represented as library___name___lib1:\zz.csv).
                //can also be this:zz.csv
                //we also handle lib1:__f() here, being only legal if called from lib1. In contrast, this:__f() is always ok.
                string[] ss = filenameMaybeWithoutPath.Split(':');
                string libraryName = ss[0].Replace(Globals.libraryDriveCheatString, "");

                if (G.Equal(libraryName, Globals.thisLibraryString))
                {
                    //Handling 'this:data.csv'
                    if (currentLibrary == null)
                    {
                        using (Error txt = new Error())
                        {
                            txt.MainAdd("You are using 'this:' before a filename, but 'this:' is only legal when issued from a library function or procedure.");
                            txt.MoreAdd("Library files can only be put into a zip-file library (in a \\data subfolder), and therefore using 'this:' outside of a library function or procedure is not meaningful.");
                            txt.MoreAdd("The Local library (where 'normal' functions/procedures are stored) cannot contain files in the same way as a zip-file library.");
                            txt.MoreAdd("Why? The answer is that such a capability would not make much sense anyway, because local files are naturally stored in the working folder.");
                        }
                    }
                    else
                    {
                        libraryName = currentLibrary;
                    }
                }
                string dataFileNameWithoutPath = ss[1].Substring(1);
                if (dataFileNameWithoutPath.StartsWith("__"))
                {
                    if (!G.Equal(libraryName, currentLibrary))
                    {
                        new Error("You can only refer to a '__' library file from its own library.");
                    }
                }
                Library library = Program.libraries.GetLibrary(libraryName, true);
                //if we get here, the library exists, and if not there is an error issued above
                string dataFilePathInsideZip = null; library.GetDataFiles().TryGetValue(dataFileNameWithoutPath, out dataFilePathInsideZip);
                if (dataFilePathInsideZip == null)
                {
                    new Error("The file '" + dataFileNameWithoutPath + "' was not found inside the \\data subfolder of the library '" + library.GetFileNameWithPath() + "'");
                }
                rv.prettyPathAndFileName = library.GetFileNameWithPath() + dataFilePathInsideZip + "\\" + dataFileNameWithoutPath;
                rv.realPathAndFileName = FindFileResolveZip(rv.prettyPathAndFileName); //Here, we swap any parts of path that passes through zip files.                
                if (rv.realPathAndFileName != null && File.Exists(rv.realPathAndFileName)) success = true;
                //NOTE: for instance if filenameMaybeWithoutPath = "library___name___lb:\zz.csv" we may get 
                //fileNameTemp = "c:\Thomas\Desktop\gekko\testing\lib1.zip\data\sub\zz.csv" because
                //zz.csv is inside a \sub subfolder and the library "lb" is an alias from lib1.zip.                    
            }

            if (!success && allowLibrary && currentLibrary != null && !hasPath)
            {
                //Look for the file in its own library first (ok if it is __ file).
                //The file must be path-less ("raw").
                //If we are for instance reading from a f() function inside lib1, or 
                //if this f() function runs a .gcm that reads something, we
                //first look in the \data folder of lib1.zip.
                Library library = Program.libraries.GetLibrary(currentLibrary, false);
                if (library != null)
                {
                    //if we get here, the library exists, and if not there is an error issued above
                    string dataFilePathInsideZip = null; library.GetDataFiles().TryGetValue(filenameMaybeWithoutPath, out dataFilePathInsideZip);
                    if (dataFilePathInsideZip != null)
                    {
                        rv.prettyPathAndFileName = library.GetFileNameWithPath() + dataFilePathInsideZip + "\\" + filenameMaybeWithoutPath;
                        rv.realPathAndFileName = FindFileResolveZip(rv.prettyPathAndFileName); //Here, we swap any parts of path that passes through zip files.
                        if (rv.realPathAndFileName != null && File.Exists(rv.realPathAndFileName)) success = true;
                    }
                }
            }

            if (!success && includeWorkingFolder)
            {
                //always searched first of normal files in the file system, if it is included
                //allowed __ prefix names here.
                rv.prettyPathAndFileName = CreateFullPathAndFileName(filenameMaybeWithoutPath);  //will now start with g:\... or \\localhost\...    
                rv.realPathAndFileName = FindFileResolveZip(rv.prettyPathAndFileName); //Here, we swap any parts of path that passes through zip files.
                if (rv.realPathAndFileName != null && File.Exists(rv.realPathAndFileName)) success = true;
            }

            if (!success && Program.options.folder && folders != null)
            {
                //allowed to search in folders. Allowed __ prefix names here.
                foreach (string folder in folders)
                {
                    //when folder is "", shouldn't it just skip to next? For "", the result will be the working folder...?
                    //as long as working folder is always king, this is not an issue.
                    if (string.IsNullOrWhiteSpace(folder)) continue;
                    rv.prettyPathAndFileName = CreateFullPathAndFileNameFromFolder(filenameMaybeWithoutPath, folder);
                    rv.realPathAndFileName = FindFileResolveZip(rv.prettyPathAndFileName); //Here, we swap any parts of path that passes through zip files.
                    if (rv.realPathAndFileName != null && File.Exists(rv.realPathAndFileName))
                    {
                        success = true;
                        break; //no more searching
                    }
                }
            }

            if (!success && allowLibrary && !hasPath)
            {
                //normal raw filename without folder structure stated
                //a loose file without path like zz.csv. Cannot accept \data\zz.csv which must be on the real filesystem.
                //will search for the file in open libraries
                // (if the file is stated inside a library function, we may already have searched
                // for it in its own library. But never mind, checking takes very little time, and file reading
                // is slow anyway. Also Local lib will be checked, again never mind).

                if (!filenameMaybeWithoutPath.StartsWith("__"))
                {
                    //if it has prefix __, and there is a hit in its own library, this will have been
                    //caught above.
                    foreach (Library library in Program.libraries.GetLibrariesIncludingLocal())
                    {
                        //Local lib will just skip quickly, never mind
                        string dataFilePathInsideZip = null; library.GetDataFiles().TryGetValue(filenameMaybeWithoutPath, out dataFilePathInsideZip);
                        if (dataFilePathInsideZip != null)
                        {
                            rv.prettyPathAndFileName = library.GetFileNameWithPath() + dataFilePathInsideZip + "\\" + filenameMaybeWithoutPath;
                            rv.realPathAndFileName = FindFileResolveZip(rv.prettyPathAndFileName); //Here, we swap any parts of path that passes through zip files.
                            if (rv.realPathAndFileName != null && File.Exists(rv.realPathAndFileName))
                            {
                                success = true;
                                break;
                            }
                        }
                    }
                }
            }

            if (!success) rv.realPathAndFileName = null;  //signals failure
            return rv;
        }

        /// <summary>
        /// Locates a zip file inside a path (if there are more, it locates the first one). Returns start and end index.
        /// </summary>
        /// <param name="fileNameWithPath"></param>
        /// <returns></returns>
        public static Tuple<int, int> FindZipFileInString(string fileNameWithPath)
        {
            int ok1 = -12345;
            int ok2 = -12345;
            int j1 = fileNameWithPath.IndexOf(Globals.zip, StringComparison.OrdinalIgnoreCase);
            if (j1 != -1)
            {
                for (int j2 = j1 - 1; j2 >= 1; j2--)
                {
                    if (fileNameWithPath[j2] == '\\' && !(fileNameWithPath[j2 - 1] == '\\'))
                    {
                        ok1 = j2 + 1;
                        break;
                    }
                }
                int j3 = j1 + Globals.zip.Length;
                if (j3 < fileNameWithPath.Length && fileNameWithPath[j3] == '\\') ok2 = j3 - 1;
            }
            return new Tuple<int, int>(ok1, ok2);
        }

        /// <summary>
        /// Will identify zip parts of a path, like g:\sub1\data.zip\sub2\xx.csv, extract the file inside the zip, and put the xx.csv
        /// file somewhere in a temp folder (and return this path). The method will call itself recursively before leaving (so
        /// nested zips are possible).
        /// </summary>
        /// <param name="fileNameWithPath"></param>
        /// <param name="folders"></param>
        /// <param name="includeWorkingFolder"></param>
        /// <param name="allowLibrary"></param>
        /// <returns></returns>
        private static string FindFileResolveZip(string fileNameWithPath)
        {
            if ((fileNameWithPath.ToLower().Contains(Globals.zip) && (fileNameWithPath.Contains(":\\") || fileNameWithPath.StartsWith("\\\\"))))
            {
                //ok, we will proceed below
            }
            else
            {
                //nothing to do: either no .zip in path, or there is a .zip but it is something like xx.zip or \sub\xx.zip.
                return fileNameWithPath;
            }

            string rv_fileName = fileNameWithPath;
            Tuple<int, int> tup = FindZipFileInString(fileNameWithPath);

            if (tup.Item1 != -12345 && tup.Item2 != -12345)
            {
                //TODO: blanks would not be good, like ...\subfolder1\ lib1.zip \subfolder2\...
                string zipFileWithPath = fileNameWithPath.Substring(0, tup.Item2 + 1);
                string zipFileWithoutPath = fileNameWithPath.Substring(tup.Item1, tup.Item2 - tup.Item1 + 1);
                string pathInsideZip = G.Substring(fileNameWithPath, tup.Item2 + 2, fileNameWithPath.Length - 1);
                if (!File.Exists(zipFileWithPath)) new Error("The zip file '" + zipFileWithoutPath + "' does not seem to exist. Gekko is trying to unzip this file, because it is part of the path '" + fileNameWithPath + "'.");
                ZipArchive zFile = ZipFile.OpenRead(zipFileWithPath);

                ZipArchiveEntry entry = null;
                string fileToFind = pathInsideZip.Replace("\\", "/");

                if (true)
                {
                    //Case-insensitive, just like Window normally is. Probably only way to do it, .GetEntry() is case-sensitive.
                    foreach (ZipArchiveEntry zipEntry in zFile.Entries)
                    {
                        if (G.Equal(zipEntry.FullName, fileToFind))
                        {
                            entry = zipEntry;
                            break;
                        }
                    }
                }
                else
                {
                    entry = zFile.GetEntry(fileToFind);
                }

                if (entry == null)
                {
                    string s = null;
                    if (pathInsideZip.ToLower().Contains(Globals.zip)) s = "Note that nested zip files are not yet supported. ";
                    new Error("Could not find file '" + pathInsideZip + "' inside '" + zipFileWithPath + "' (the zip file has " + zFile.Entries.Count + " entries). " + s);
                }
                string tempFileNameWithPath = WaitForExtractZipFileEntryToTempFile(entry, zipFileWithPath);
                //cannot yet be recursive, like c:\Thomas\Desktop\gekko\testing\lib1.zip\data\sub\nested.zip\data\sub\zz2.csv
                rv_fileName = tempFileNameWithPath;
            }

            return rv_fileName;
        }

        /// <summary>
        /// Small helper method to extract an existing C# ZipArchiveEntry into a temporary file (the filename is returned).
        /// The string zipFileWithPath is only used for error messages.
        /// </summary>
        /// <param name="entry"></param>
        /// <returns></returns>
        public static string WaitForExtractZipFileEntryToTempFile(ZipArchiveEntry entry, string zipFileWithPath)
        {
            string tempFileName = null;

            int gap = Globals.waitFileGap;  //2 seconds
            int totalTime = Globals.waitFileTotalTime;  //the zip file may be blocked, but also the file name extracted to may be blocked (in the latter case, for each iteration a new temp folder is created, so this block should not persist)
            int repeats = totalTime / gap;
            bool success = false;

            string message = ""; string innerException = "";
            for (int i = 0; i < repeats; i++)
            {
                if (Globals.threadIsInProcessOfAborting && !Globals.applicationIsInProcessOfAborting) throw new GekkoException();
                tempFileName = Globals.tempFiles + "\\" + Globals.tempFileStart + ++Globals.tempFilesCounter + Globals.tempFileEnd;
                success = true;
                try
                {
                    if (File.Exists(tempFileName))
                    {
                        //this should not be possible, but anyway...
                        File.Delete(tempFileName);
                        System.Threading.Thread.Sleep(100);  //0.1 seconds, just to give Windows some time
                    }
                    entry.ExtractToFile(tempFileName, true);
                }
                catch (Exception e)
                {
                    message = "" + e?.Message; innerException = "" + e?.InnerException;
                    success = false;
                    new Warning("Trying to extract the file '" + entry.FullName + "' from inside the zip file '" + zipFileWithPath + "'. Blocked? Retrying... (" + (i * gap) + " seconds)");
                    //new random folder for such files
                    Globals.tempFiles = Program.CreateTempFolderPath("tempfiles");  //new path name
                    try
                    {
                        Program.CreateTempFilesFolder2();
                    }
                    catch { }; //fail silently
                    System.Threading.Thread.Sleep(gap * 1000);  //2 seconds
                    continue;
                }
                break;
            }

            if (success == false)
            {
                using (Error error = new Error())
                {
                    error.MainAdd("Gekko encountered a problem while extracting a file from inside of a zip file.");
                    error.MainAdd("Closing and reopening the Gekko main window normally fixes the issue (the issue is being investigated).");
                    // ---
                    error.MoreAdd("Gekko is trying to extract the file '" + entry.FullName + "' from inside the ");
                    error.MoreAdd("zip file '" + zipFileWithPath + "', giving it the ");
                    error.MoreAdd("temporary file location '" + tempFileName + "'. This fails, and you may want to check");
                    error.MoreAdd("whether the temporary file is already existing and blocked (which would be very unusual).");
                    error.MoreAdd("Additionally, check that the folder that the temporary file is supposed to be put into exists, which it should.");
                    error.MoreAdd("Finally, the zip file itself might be blocked.");
                    error.MoreNewLine();
                    error.MoreAdd("Closing and reopening the Gekko main window normally fixes the issue. The issue is being investigated");
                    error.MoreAdd("and may have to do with issues in the Windows file system. If the issue is frequent, please");
                    error.MoreAdd("contact the Gekko editor.");
                    error.MoreNewLine();
                    error.MoreAdd("The internal error is the following:");
                    error.MoreNewLineTight();
                    error.MoreAdd(message + " " + innerException);
                }
            }

            return tempFileName;
        }        

        /// <summary>
        /// Select from a list of files of a given type. Opens a GUI window.
        /// </summary>
        /// <param name="type"></param>
        /// <param name="fileName"></param>
        /// <param name="cancel"></param>
        public static void SelectFile(string type, ref string fileName, ref bool cancel)
        {
            string dataFile = "";
            System.Windows.Forms.OpenFileDialog openFileDialog1 = new System.Windows.Forms.OpenFileDialog();
            openFileDialog1.InitialDirectory = Program.options.folder_working;
            openFileDialog1.Filter = type + " files (*." + type + ")|*." + type + "|All files (*.*)|*.*";
            openFileDialog1.FilterIndex = 1;
            //openFileDialog1.RestoreDirectory = true;
            if (openFileDialog1.ShowDialog() == DialogResult.OK)
            {
                try
                {
                    if ((openFileDialog1.OpenFile()) != null)
                    {
                        dataFile = openFileDialog1.FileName;
                    }
                }
                catch (Exception ex)
                {
                    MessageBox.Show("Error: Could not read file from disk. Original error: " + ex.Message);
                    throw new GekkoException();
                }
            }
            else
            {
                cancel = true;
            }

            if (!cancel)
            {
                if (dataFile == "")
                {
                    new Error("While reading " + type + " file");
                }
                fileName = dataFile;
            }
        }

        public static void CutPrint(bool print)
        {
            if (print && Globals.ch.windowsGraphCloseCounter + Globals.ch.windowsDecompCloseCounter > 0)
            {
                G.Writeln();
                if (Globals.ch.windowsGraphCloseCounter > 0) G.Writeln("Closed " + Globals.ch.windowsGraphCloseCounter + " PLOT windows");
                if (Globals.ch.windowsDecompCloseCounter > 0) G.Writeln("Closed " + Globals.ch.windowsDecompCloseCounter + " DECOMP windows");
            }
        }

        public static void CutDecomp2()
        {
            List<WindowDecomp> windowsDecompTemp2 = new List<WindowDecomp>();
            windowsDecompTemp2.AddRange(Globals.windowsDecomp2);
            for (int i = 0; i < windowsDecompTemp2.Count; i++)
            {
                if (windowsDecompTemp2[i] == null) continue;
                CrossThreadStuff.CloseDecomp2(windowsDecompTemp2[i]);  //fails silently
            }
            Globals.windowsDecomp2 = new List<WindowDecomp>();
        }

        public static void CutDecomp1()
        {
            List<Window1> windowsDecompTemp = new List<Window1>();
            windowsDecompTemp.AddRange(Globals.windowsDecomp);
            for (int i = 0; i < windowsDecompTemp.Count; i++)
            {
                if (windowsDecompTemp[i] == null) continue;
                CrossThreadStuff.CloseDecomp(windowsDecompTemp[i]);  //fails silently
            }
            Globals.windowsDecomp = new List<Window1>();
        }

        public static void CutPlot()
        {
            List<Graph> windowsGraphTemp = new List<Graph>();
            windowsGraphTemp.AddRange(Globals.windowsGraph);
            Globals.ch = new CounterHelper();
            for (int i = 0; i < windowsGraphTemp.Count; i++)
            {
                if (windowsGraphTemp[i] == null) continue;
                CrossThreadStuff.CloseGraph(windowsGraphTemp[i]);  //fails silently
            }
            Globals.windowsGraph = new List<Graph>();
        }

        /// <summary>
        /// Used for DELETE&lt;nonmodel&gt;
        /// </summary>
        public static void Trimvars()
        {
            if (G.GetModelSourceType() != EModelType.Gekko)
            {
                new Error("No Gekko model is defined for trimming, cf. MODEL command.");
                //throw new GekkoException();
            }

            List<Databank> banks = new List<Databank> { Program.databanks.GetFirst(), Program.databanks.GetRef() };

            G.Writeln();
            foreach (Databank bank in banks)
            {
                List<string> onlyDatabankNotModel = new List<string>();
                foreach (KeyValuePair<string, IVariable> s in bank.storage)
                {
                    if (s.Value.Type() != EVariableType.Series) continue;
                    if (G.GetFreqFromName(s.Key) != Program.options.freq) continue;  //filter out other freqs
                    string s2 = G.Chop_RemoveFreq(s.Key);
                    if (!Program.model.modelGekko.varsAType.ContainsKey(s2))
                    {
                        onlyDatabankNotModel.Add(s2);
                    }
                }

                int c = 0;
                foreach (string s in onlyDatabankNotModel)
                {
                    string ss = s + Globals.freqIndicator + G.ConvertFreq(Program.options.freq);
                    if (bank.ContainsIVariable(ss))
                    {
                        bank.RemoveIVariable(ss);
                        c++;
                    }
                }
                G.Writeln2("Removed " + c + " variable(s) in '" + bank.name + "' databank");
            }
        }

        /// <summary>
        /// FINDMISSINGDATA command.
        /// </summary>
        /// <param name="o"></param>
        public static void FindMissingData(O.Findmissingdata o)
        {
            GekkoTime tStart = o.t1;
            GekkoTime tEnd = o.t2;

            List vars2 = O.Restrict2(o.names, false, false, false, false);   //only allows plain vars (idents)
            List<ToFrom> vars = null;
            if (vars2 != null) vars = SearchFromTo(vars2, null, null, null, EWildcardSearchType.Search, null);

            bool replace = true;
            if (double.IsNaN(o.opt_replace)) replace = false;

            bool hasFilter = false;
            bool hasModel = false;

            Databank work = Program.databanks.GetFirst();

            Dictionary<string, string> exod = null;
            Dictionary<string, string> exoj = null;
            Dictionary<string, string> exoz = null;
            Dictionary<string, string> exodjz = null;
            Dictionary<string, string> exo = null;
            Dictionary<string, string> exotrue = null;
            Dictionary<string, string> endo = null;
            Dictionary<string, string> all = null;

            if (!replace)
            {
                exod = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
                exoj = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
                exoz = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
                exodjz = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
                exo = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
                exotrue = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
                endo = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
                all = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
            }

            if ((G.GetModelSourceType() != EModelType.Gekko) || replace)
            {
            }
            else
            {
                hasModel = true;
                try
                {
                    foreach (string s in Stringlist.GetListOfStringsFromListOfIvariables(((List)O.GetIVariableFromString("global:" + Globals.symbolCollection + "exod", O.ECreatePossibilities.NoneReturnNullButErrorForParentArraySeries)).list.ToArray()))
                        exod.Add(s, "");
                    foreach (string s in Stringlist.GetListOfStringsFromListOfIvariables(((List)O.GetIVariableFromString("global:" + Globals.symbolCollection + "exoj", O.ECreatePossibilities.NoneReturnNullButErrorForParentArraySeries)).list.ToArray()))
                        exoj.Add(s, "");
                    foreach (string s in Stringlist.GetListOfStringsFromListOfIvariables(((List)O.GetIVariableFromString("global:" + Globals.symbolCollection + "exoz", O.ECreatePossibilities.NoneReturnNullButErrorForParentArraySeries)).list.ToArray()))
                        exoz.Add(s, "");
                    foreach (string s in Stringlist.GetListOfStringsFromListOfIvariables(((List)O.GetIVariableFromString("global:" + Globals.symbolCollection + "exodjz", O.ECreatePossibilities.NoneReturnNullButErrorForParentArraySeries)).list.ToArray()))
                        exodjz.Add(s, "");
                    foreach (string s in Stringlist.GetListOfStringsFromListOfIvariables(((List)O.GetIVariableFromString("global:" + Globals.symbolCollection + "exo", O.ECreatePossibilities.NoneReturnNullButErrorForParentArraySeries)).list.ToArray()))
                        exo.Add(s, "");
                    foreach (string s in Stringlist.GetListOfStringsFromListOfIvariables(((List)O.GetIVariableFromString("global:" + Globals.symbolCollection + "exotrue", O.ECreatePossibilities.NoneReturnNullButErrorForParentArraySeries)).list.ToArray()))
                        exotrue.Add(s, "");
                    foreach (string s in Stringlist.GetListOfStringsFromListOfIvariables(((List)O.GetIVariableFromString("global:" + Globals.symbolCollection + "endo", O.ECreatePossibilities.NoneReturnNullButErrorForParentArraySeries)).list.ToArray()))
                        endo.Add(s, "");
                    foreach (string s in Stringlist.GetListOfStringsFromListOfIvariables(((List)O.GetIVariableFromString("global:" + Globals.symbolCollection + "all", O.ECreatePossibilities.NoneReturnNullButErrorForParentArraySeries)).list.ToArray()))
                        all.Add(s, "");
                }
                catch { };  //if error, we just ignore it, and the list will be empty.
            }

            Dictionary<string, string> filter = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);

            //exod
            //exoj
            //exoz
            //exodjz
            //exo
            //exotrue
            //endo
            //all
            //work

            List<string> missing_exod = null;
            List<string> missing_exoj = null;
            List<string> missing_exoz = null;
            List<string> missing_exodjz = null;
            List<string> missing_exo = null;
            List<string> missing_exotrue = null;
            List<string> missing_endo = null;
            List<string> missing_all = null;
            List<string> missing_ = null;

            if (!replace)
            {
                missing_exod = new List<string>();
                missing_exoj = new List<string>();
                missing_exoz = new List<string>();
                missing_exodjz = new List<string>();
                missing_exo = new List<string>();
                missing_exotrue = new List<string>();
                missing_endo = new List<string>();
                missing_all = new List<string>();  //every variable in model
                missing_ = new List<string>();   //every model i work databank (this typically includes the "all" set, because the READ statement auto-creates model variables if they are not in the databank)
            }

            if (vars != null)  //if filter is set
            {
                hasFilter = true;
                foreach (ToFrom tf in vars)
                {
                    filter.Add(tf.s1, "");  //we are just using the keys, not values, therefore ""
                }
            }

            foreach (KeyValuePair<string, IVariable> kvp in work.storage)
            //all variables in work databank
            //foreach (string ss in work.storage.Keys)
            {
                if (kvp.Value.Type() != EVariableType.Series) continue;
                string ss = kvp.Key;
                if (G.GetFreqFromName(ss) != Program.options.freq) continue;  //we filter out other freqs
                string s = G.Chop_RemoveFreq(ss);

                if (hasFilter)
                {
                    if (!filter.ContainsKey(s)) continue;  //ignore this
                }
                Series ts = kvp.Value as Series;
                //Series ts = work.GetVariable(s);  //can this not be moved before loop??  //#getvar

                List<Series> l = new List<Series>();
                List<string> n = new List<string>();

                if (ts.type == ESeriesType.ArraySuper)
                {
                    foreach (KeyValuePair<MultidimItem, IVariable> kvpsub in ts.dimensionsStorage.storage)
                    {
                        Series sub = kvpsub.Value as Series;
                        l.Add(sub);
                        n.Add(sub.GetNameWithoutCurrentFreq(true));
                    }
                }
                else
                {
                    l.Add(ts);
                    n.Add(s);
                }

                for (int i = 0; i < l.Count; i++)
                {

                    foreach (GekkoTime t in new GekkoTimeIterator(tStart, tEnd))
                    {
                        double value = l[i].GetDataSimple(t);
                        if (G.isNumericalError(value))
                        {
                            if (replace)
                            {
                                l[i].SetData(t, o.opt_replace);
                            }
                            else
                            {
                                missing_.Add(n[i]);  //always put it in this list
                                if (exod.ContainsKey(n[i])) missing_exod.Add(s);
                                if (exoj.ContainsKey(n[i])) missing_exoj.Add(s);
                                if (exoz.ContainsKey(n[i])) missing_exoz.Add(s);
                                if (exodjz.ContainsKey(n[i])) missing_exodjz.Add(s);
                                if (exo.ContainsKey(n[i])) missing_exo.Add(s);
                                if (exotrue.ContainsKey(n[i])) missing_exotrue.Add(s);
                                if (endo.ContainsKey(n[i])) missing_endo.Add(s);
                                if (all.ContainsKey(n[i])) missing_all.Add(s);
                                break;  //one is enough
                            }
                        }
                    }
                }
            }

            if (!replace)
            {

                Dictionary<string, List<string>> names = new Dictionary<string, List<string>>(StringComparer.OrdinalIgnoreCase);
                names.Add("missingdata_", missing_);  //this one is a bit special
                names.Add("missingdata_exod", missing_exod);
                names.Add("missingdata_exoj", missing_exoj);
                names.Add("missingdata_exoz", missing_exoz);
                names.Add("missingdata_exodjz", missing_exodjz);
                names.Add("missingdata_exo", missing_exo);
                names.Add("missingdata_exotrue", missing_exotrue);
                names.Add("missingdata_endo", missing_endo);
                names.Add("missingdata_all", missing_all);

                List<string> names2 = new List<string>();
                names2.Add("missingdata_");
                if (hasModel)
                {
                    names2.Add("missingdata_all");
                    names2.Add("missingdata_endo");
                    names2.Add("missingdata_exotrue");
                    names2.Add("missingdata_exo");
                    names2.Add("missingdata_exodjz");
                    names2.Add("missingdata_exod");
                    names2.Add("missingdata_exoj");
                    names2.Add("missingdata_exoz");
                }

                G.Writeln();
                G.Writeln("------------------------ Report: Find missing data -------------------------------");
                G.Writeln();
                if (G.GetModelSourceType() != EModelType.Gekko)
                {
                    G.Writeln();
                    G.Writeln("No Gekko model seems to be loaded -- result cannot be split into exogenous, endogenous etc. variables");
                    G.Writeln();
                }

                foreach (string n2 in names2)
                {
                    List<string> list = names[n2];
                    string listname = n2;
                    if (listname == "missingdata_") listname = "missingdata";

                    if (true)
                    {
                        list.Sort();
                        Program.databanks.GetFirst().AddIVariableWithOverwrite(Globals.symbolCollection + listname, new List(list));

                        if (list.Count > 0)
                        {
                            string v = "variables";
                            if (list.Count == 1) v = "variable";
                            G.Writeln("List #" + listname + " has " + list.Count + " " + v + ":");
                            G.PrintListWithCommas(list, false);
                            G.Writeln();
                        }
                        else
                        {
                            G.Writeln("List #" + listname + " is empty");
                            G.Writeln();
                        }
                    }
                }
                G.Writeln("------------------------ Report end ----------------------------------------------");
                G.Writeln();
                G.Writeln();
            }
        }

        /// <summary>
        /// Helper for options that may be both yes, no or null.
        /// </summary>
        /// <param name="opt"></param>
        /// <returns></returns>
        //See #98745239543
        public static YesNoNull GetYesNoNullLocalOption(string opt)
        {
            YesNoNull rv = YesNoNull.Null;
            if (opt == null) rv = YesNoNull.Null;
            else if (G.Equal(opt, "yes")) rv = YesNoNull.Yes;
            else if (G.Equal(opt, "no")) rv = YesNoNull.No;
            else
            {
                new Error("Expected 'yes' or 'no', not '" + opt + "'");
                //throw new GekkoException();
            }
            return rv;
        }

        /// <summary>
        /// ITERSHOW command.
        /// </summary>
        /// <param name="vars"></param>
        /// <param name="t1"></param>
        /// <param name="t2"></param>
        public static void Itershow(List<string> vars, GekkoTime t1, GekkoTime t2)
        {
            if (G.GetModelSourceType() != EModelType.Gekko)
            {
                new Error("No Gekko model seems to be defined, see MODEL command.");
                //throw new GekkoException();
            }

            bool hasContent = false;

            Table tab = new Table();
            int row = 1;

            List<string> problems = new List<string>();

            foreach (string var in vars)
            {
                bool hasDifference = false;
                foreach (GekkoTime t in new GekkoTimeIterator(t1, t2))
                {
                    int rowYearStart = row;
                    List<IterMemory> iterMemories = null;
                    if (Program.model.modelGekko.bMemory.ContainsKey(t.ToString()))
                    {
                        iterMemories = Program.model.modelGekko.bMemory[t.ToString()];
                    }
                    else
                    {
                        G.Writeln("There were no recorded iterations in memory regarding period " + t.ToString());
                        continue;
                    }

                    hasContent = true;

                    tab.Set(row, 1, t.ToString());
                    tab.Set(row, 2, G.GetUpperLowerCase(var));
                    row++;
                    tab.Set(row, 1, "Iter");
                    tab.Set(row, 2, "Before");
                    tab.Set(row, 3, "After");
                    tab.Set(row, 4, "Hist. var");
                    tab.Set(row, 5, "Difference");
                    tab.Set(row, 6, "Relative1");
                    tab.Set(row, 7, "Relative2");
                    tab.SetAlign(row, 1, row, 7, Align.Right);
                    tab.SetBorder(row, 1, row, 7, BorderType.Top);
                    tab.SetBorder(row, 1, row, 7, BorderType.Bottom);

                    for (int it = 0; it < iterMemories.Count; it++)
                    {
                        IterMemory iterMemory = iterMemories[it];
                        double[] bBefore = iterMemory.bBefore;
                        double[] bAfter = iterMemory.bAfter;

                        EquationHelper found = Program.FindEquationByMeansOfVariableName(var);
                        if (found == null)
                        {
                            //G.Writeln();
                            new Error("ITERSHOW: Variable " + var + " is not endogenous");
                            //throw new GekkoException();
                        }
                        int i = found.bNumberLhs;
                        //G.Writeln("per " + t.ToString() + " it " + it + " bef " + bBefore[i] + " aft " + bAfter[i]);
                        row++;
                        double bOld = bBefore[i];
                        double b = bAfter[i];
                        double bVariance = Program.model.modelGekko.bVariance[i];

                        tab.Set(new Coord(row, 1), "", it + 1, CellType.Number, "f6.0");
                        tab.Set(new Coord(row, 2), "", bOld, CellType.Number, "f13.4");
                        tab.Set(new Coord(row, 3), "", b, CellType.Number, "f13.4");
                        tab.Set(new Coord(row, 4), "", bVariance, CellType.Number, "f13.4");

                        double abs = (b - bOld);
                        double rel = (abs / bOld);
                        double relHist = (abs / bVariance);

                        if (abs != 0d) hasDifference = true;

                        tab.Set(new Coord(row, 5), "", abs, CellType.Number, "f15.6");
                        tab.Set(new Coord(row, 6), "", relHist, CellType.Number, "f12.6");
                        tab.Set(new Coord(row, 7), "", rel, CellType.Number, "f12.6");
                    }
                    tab.SetBorder(row, 1, row, 7, BorderType.Bottom);
                    tab.SetBorder(rowYearStart + 1, 1, row, 1, BorderType.Left);
                    tab.SetBorder(rowYearStart + 1, 7, row, 7, BorderType.Right);
                    row++;
                    row++;

                }//time loop
                if (!hasDifference) problems.Add(var);
            }
            if (hasContent)
            {
                O.PrintTable(tab, false, null);
                if (problems.Count > 0)
                {
                    G.Writeln();
                    foreach (string s in problems)
                    {
                        new Note("Variable '" + s + "' might be part of the prologue or epilogue, and if so it does not change during Gauss iterations. Regarding ordering, see the [model]__info.zip file, inside [model].ordering.");
                    }
                }
                new Note("Damped variables have stricter convergence crits than non-damped.");
            }
            else
            {
                G.Writeln();
                G.Writeln("It seems there was no results stored regarding iterations: did you remember to set 'OPTION solve gauss dump = yes' before simulation?");
            }
        }

        /// <summary>
        /// Print some links for SIM. TODO: use GekkoAction instead.
        /// </summary>
        /// <param name="output"></param>
        /// <param name="s1"></param>
        /// <param name="s2"></param>
        /// <param name="s3"></param>
        public static void IterLink(StringBuilder output, string s1, string s2, string s3)
        {
            LinkContainer lc = new LinkContainer(output.ToString());
            Globals.linkContainer.Add(lc.counter, lc);
            G.Write(s1); G.WriteLink(s2, "outputtab:" + lc.counter); G.Write(s3);
        }

        /// <summary>
        /// TIME command.
        /// </summary>
        /// <param name="t1"></param>
        /// <param name="t2"></param>
        public static void Time(GekkoTime t1, GekkoTime t2)
        {
            Tuple<GekkoTime, GekkoTime> freqs = ConvertFreqs(t1, t2, Program.options.freq);

            G.CheckLegalPeriod(freqs.Item1, freqs.Item2);

            Globals.globalPeriodStart = freqs.Item1;
            Globals.globalPeriodEnd = freqs.Item2;
            G.Writeln2(G.FreqAndPeriodPretty(false, true));
            if (t1.freq != Program.options.freq || t2.freq != Program.options.freq)
            {
                new Note("The dates have been converted to " + Program.options.freq.Pretty() + " frequency");
            }
        }

        /// <summary>
        /// TIMEFILTER command.
        /// </summary>
        /// <param name="o"></param>
        public static void TimeFilter(O.TimeFilter o)
        {
            GekkoTimeSpans gtss = new GekkoTimeSpans();
            foreach (O.TimeFilterHelper tfh in o.timeFilterPeriods)
            {
                //This translation is a bit stupid since the two collections are almost identical
                //But never mind: this is not speed critical code.
                if (tfh.to.IsNull())
                {
                    gtss.data.Add(new GekkoTimeSpan(tfh.from, tfh.from, tfh.step));  //duplicating
                }
                else
                {
                    gtss.data.Add(new GekkoTimeSpan(tfh.from, tfh.to, tfh.step));
                }
            }
            Globals.globalPeriodTimeFilters = gtss;

            List<GekkoTime> positiveFilter = new List<GekkoTime>();
            List<GekkoTime> negativeFilter = new List<GekkoTime>();
            foreach (GekkoTimeSpan gts in Globals.globalPeriodTimeFilters.data)
            {
                int counter = 0;
                foreach (GekkoTime t in new GekkoTimeIterator(gts.tStart, gts.tEnd))
                {
                    if (counter % gts.by == 0)
                    {
                        positiveFilter.Add(t);  //dublets will be ok... should be Dictionary in the longer run...
                    }
                    counter++;
                }
            }
            List<string> chosen = new List<string>();
            List<string> filtered = new List<string>();
            GekkoTime gtLag = GekkoTime.tNull;

            foreach (GekkoTime gt in positiveFilter)
            {
                if (!gtLag.IsNull())
                {
                    if (!gt.StrictlyLargerThan(gtLag))
                    {
                        //G.Writeln();
                        new Error("TIMEFILTER sequence problem: '" + G.FromDateToString(gtLag) + "' should be larger than '" + G.FromDateToString(gt) + "'. Please check your TIMEFILTER command");
                    }
                    else
                    {
                        int dif = gt.Subtract(gtLag);
                        if (dif > 1)  //period 2000:2001 is 2 obs for example (both start and end counting)
                        {
                            //Actually this dif check should not be necessary, but the problem is that the
                            //iterator is ill-defined if start date is > end date. In that case, the start
                            //date will be iterated once... Too dangerous to fix right now, so we do the
                            //explicit check.
                            //For instance, if gtLag = 2000 and gt=2001, we will iterate between 2001 and 2000 to get
                            //the filtered periods, which should not include 2001. The dif check handles this case.
                            foreach (GekkoTime gt2 in new GekkoTimeIterator(gtLag.Add(1), gt.Add(-1)))
                            {
                                negativeFilter.Add(gt2);
                                filtered.Add(G.FromDateToString(gt2));
                            }
                        }
                    }
                }
                chosen.Add(G.FromDateToString(gt));
                gtLag = gt;
            }
            //f.Sort();  is already in sequence
            G.Writeln();
            G.Write("Chosen periods: ");
            if (chosen.Count > 0)
            {
                G.PrintListWithCommas(chosen, false);
            }
            else G.Writeln("[none]");
            G.Write("Hidden periods: ");
            if (filtered.Count > 0)
            {
                G.PrintListWithCommas(filtered, false);
            }
            else
            {
                G.Writeln("[none]");
                new Warning("Nothing is filtered out, so filter has no effect!");
            }
            Globals.globalPeriodTimeFilters2 = negativeFilter;
            if (Program.options.timefilter == false)
            {
                Program.options.timefilter = true;
                G.Writeln("Time filtering is switched on (OPTION timefilter = yes)");
            }
        }

        /// <summary>
        /// If a TIMEFILTER is set for the period, true is returned.
        /// </summary>
        /// <param name="t"></param>
        /// <returns></returns>
        public static bool ShouldFilterPeriod(GekkoTime t)
        {
            if (!Program.options.timefilter) return false;
            bool shouldFilter = false;
            if (Globals.globalPeriodTimeFilters2.Count > 0)
            {
                foreach (GekkoTime tFilter in Globals.globalPeriodTimeFilters2)
                {
                    if (t.EqualsGekkoTime(tFilter))
                    {
                        shouldFilter = true;
                        break;
                    }
                }
            }
            return shouldFilter;
        }

        /// <summary>
        /// SYS command: execute from Windows shell
        /// </summary>
        /// <param name="commandLine">Command line parameters to pass</param>        
        public static void ExecuteShellCommand(string commandLine, bool mute)
        {
            //To get it dynamically, maybe this?: https://stackoverflow.com/questions/12678407/getting-command-line-output-dynamically

            bool fail = false;
            // Set process variable
            // Provides access to local and remote processes and enables you to start and stop local <b style="color:black;background-color:#99ff99">system</b> processes.
            System.Diagnostics.Process process = null;

            int widthRemember = Program.options.print_width;
            Program.options.print_width = int.MaxValue;

            try
            {
                process = new System.Diagnostics.Process();
                // invokes the cmd process specifying the command to be executed.
                string _CMDProcess = string.Format(System.Globalization.CultureInfo.InvariantCulture, @"{0}\cmd.exe", new object[] { Environment.SystemDirectory });
                // pass executing file to cmd (Windows command interpreter) as a arguments
                // /C tells cmd that we want it to execute the command that follows, and then exit.
                //string _Arguments = string.Format(System.Globalization.CultureInfo.InvariantCulture, "/C {0}", new object[] { _FileToExecute });
                string _Arguments = "";
                // pass any command line parameters for execution
                if (commandLine != null && commandLine.Length > 0)
                {
                    _Arguments = string.Format(System.Globalization.CultureInfo.InvariantCulture, "/C {0}", new object[] { commandLine, System.Globalization.CultureInfo.InvariantCulture });
                }
                // sets a value indicating not to start the process in a new window.
                process.StartInfo.CreateNoWindow = true;
                // sets a value indicating not to use the operating system shell to start the process.
                process.StartInfo.UseShellExecute = false;
                // sets a value that indicates the output/input/error of an application is written to the Process.
                process.StartInfo.RedirectStandardOutput = true;
                process.StartInfo.RedirectStandardInput = false;
                process.StartInfo.RedirectStandardError = true;
                process.StartInfo.WorkingDirectory = Program.options.folder_working;
                process.StartInfo.Arguments = _Arguments;
                process.StartInfo.FileName = _CMDProcess;
                //process.StartInfo = p;
                // Starts a process resource and associates it with a Process component.

                int timeout = 7 * 24 * 60 * 60 * 1000; //7*24 hours

                //See https://stackoverflow.com/questions/139593/processstartinfo-hanging-on-waitforexit-why?lq=1

                //StringBuilder output = new StringBuilder();
                StringBuilder error = new StringBuilder();
                using (AutoResetEvent outputWaitHandle = new AutoResetEvent(false))
                using (AutoResetEvent errorWaitHandle = new AutoResetEvent(false))
                {
                    process.OutputDataReceived += (sender, e) =>
                    {
                        if (!Globals.threadIsInProcessOfAborting)
                        {
                            if (e.Data == null)
                            {
                                outputWaitHandle.Set();
                            }
                            else
                            {
                                if (!mute) G.Writeln(e.Data);  //write it as a flowing stream                            
                            }
                        }
                    };
                    process.ErrorDataReceived += (sender, e) =>
                    {
                        if (!Globals.threadIsInProcessOfAborting)
                        {
                            if (e.Data == null)
                            {
                                errorWaitHandle.Set();
                            }
                            else
                            {
                                error.AppendLine(e.Data);
                            }
                        }
                    };

                    process.Start();
                    //string output = process.StandardOutput.ReadToEnd();

                    if (!Globals.threadIsInProcessOfAborting)
                    {
                        process.BeginOutputReadLine();
                        process.BeginErrorReadLine();
                    }

                    if (process.WaitForExit(timeout) && outputWaitHandle.WaitOne(timeout) && errorWaitHandle.WaitOne(timeout))
                    {
                        // Process completed. Check process.ExitCode here.
                    }
                    else
                    {
                        // Timed out.
                    }
                }

                if (!Globals.threadIsInProcessOfAborting)
                {
                    int exitCode = process.ExitCode;
                    if (exitCode != 0)
                    {
                        new Warning("System call exited with code: " + exitCode + ". System command: " + commandLine);
                        //fail = true;
                    }
                }

                if (!mute || Globals.threadIsInProcessOfAborting)
                {
                    try
                    {
                        //G.Writeln2(output.ToString());
                        if (error.Length > 0)
                        {
                            G.Writeln2("=================== System error message ===================", Globals.warningColor);
                            G.Writeln2(error.ToString(), Globals.warningColor);
                            //fail = true;
                        }
                    }
                    catch (Exception e)
                    {
                        new Warning("Could not write output from system command");
                        //fail = true;
                    }
                }
            }
            catch (Win32Exception _Win32Exception)
            {
                if (!Globals.threadIsInProcessOfAborting)
                {
                    // Error
                    new Error("SYS Win32 exception: " + _Win32Exception.ToString(), false);
                    fail = true;
                }
            }
            catch (Exception _Exception)
            {
                if (!Globals.threadIsInProcessOfAborting)
                {
                    // Error
                    new Error("SYS exception: " + _Exception.ToString(), false);
                    fail = true;
                }
            }
            finally
            {
                if (Globals.threadIsInProcessOfAborting)
                {
                }
                else
                {
                    //resetting, also if there is an error
                    Program.options.print_width = widthRemember;
                    // close process and do cleanup
                    if (true)
                    {
                        //like killing it in the task manager, no questions asked
                        if (!process.HasExited)
                        {
                            try
                            {
                                process.Kill();
                            }
                            catch
                            {
                                //in principle, the process could exit just after .HasExited is asked, there the try here
                            }
                        }
                        else
                        {
                            try
                            {
                                process.Close();
                                process.Dispose();
                            }
                            catch { }
                        }
                    }
                    else
                    {
                        try
                        {
                            process.Close();
                            process.Dispose();
                        }
                        catch { }
                    }
                    //process = null;
                }
            }
            if (!Globals.threadIsInProcessOfAborting && fail) throw new GekkoException();  //we throw it here, after cleanup is performed
        }

        /// <summary>
        /// Used for WRITE&lt;gcm&gt;, writing a data file that can be RUN in Gekko.
        /// </summary>
        /// <param name="vars"></param>
        /// <param name="per1_input"></param>
        /// <param name="per2_input"></param>
        /// <param name="op"></param>
        /// <param name="file"></param>
        public static void WriteGcm(List<ToFrom> vars, GekkoTime per1_input, GekkoTime per2_input, string op, string file)
        {
            if (op == null) op = "n";
            if (op == "#") new Error("The '#' operator is not supported in EXPORT<series>");
            if (G.Equal(op, "mp")) new Error("The 'mp' operator is not supported in EXPORT<series>");

            int type = 0;
            if (op == "=" || op == "^=" || op == "%=" || op == "+=" || op == "*=") type = 1;
            if (G.Equal(op, "n") || G.Equal(op, "d") || G.Equal(op, "p") || G.Equal(op, "m") || G.Equal(op, "q")) type = 2;
            if (type == 0) new Error("Operator type '" + op + "' not recognized");

            Databank base2 = Program.databanks.GetRef();

            file = G.AddExtension(file, "." + Globals.extensionCommand);
            string pathAndFilename = CreateFullPathAndFileNameFromFolder(file, Program.options.folder_working);
            if (File.Exists(pathAndFilename))
            {
                new Error("The ." + Globals.extensionCommand + " file '" + pathAndFilename + "' already exists. Please remove it, for instance with SYS 'del <filename>'. This is to avoid overwriting a 'real' ." + Globals.extensionCommand + " command file.");
            }
            using (FileStream fs = WaitForFileStream(pathAndFilename, null, GekkoFileReadOrWrite.Write))
            using (StreamWriter sw = G.GekkoStreamWriter(fs))
            {
                for (int j = 0; j < vars.Count; j++)
                {
                    string var = vars[j].s2;  //includes bankname and freq
                    string baseVar = G.Chop_SetBank(vars[j].s2, Globals.Ref);
                    IVariable ivBase = null;
                    Series tsBase = null;

                    if (op == "*=" || op == "+=" || G.Equal(op, "q") || G.Equal(op, "m"))
                    {
                        ivBase = O.GetIVariableFromString(baseVar, O.ECreatePossibilities.NoneReportError);  //no search here
                        tsBase = ivBase as Series;
                    }

                    IVariable iv = O.GetIVariableFromString(var, O.ECreatePossibilities.NoneReportError, true);  //can search!
                    Series ts = iv as Series;

                    GekkoTime per1 = GekkoTime.tNull; GekkoTime per2 = GekkoTime.tNull;
                    if (per1_input.IsNull() && per2_input.IsNull())
                    {
                        per1 = ts.GetRealDataPeriodFirst();
                        per2 = ts.GetRealDataPeriodLast();
                    }
                    else GekkoTime.ConvertFreqs(ts.freq, per1_input, per2_input, ref per1, ref per2);

                    StringBuilder sb = new StringBuilder();
                    if (type == 1)
                    {
                        sb.Append(G.Chop_RemoveBank(var) + " <" + per1.ToString() + " " + per2.ToString() + "> " + op + " ");
                    }
                    else
                    {
                        sb.Append(G.Chop_RemoveBank(var) + " <" + per1.ToString() + " " + per2.ToString() + " " + op + "> = ");
                    }

                    foreach (GekkoTime t in new GekkoTimeIterator(per1, per2))
                    {
                        double val = double.NaN;
                        double w = ts.GetDataSimple(t);
                        double wLag = ts.GetDataSimple(t.Add(-1));

                        double b = double.NaN;
                        double bLag = double.NaN;  //well, not use at the moment

                        if (op == "*=" || op == "+=" || G.Equal(op, "q") || G.Equal(op, "m"))
                        {
                            b = tsBase.GetDataSimple(t);
                            bLag = tsBase.GetDataSimple(t.Add(-1));
                        }

                        if (op == "=" || op == "n")
                        {
                            val = w;
                        }
                        else if (op == "^=" || op == "d")
                        {
                            val = w - wLag;
                        }
                        else if (op == "%=" || op == "p")
                        {
                            val = (w / wLag - 1) * 100d;
                        }
                        else if (op == "+=" || op == "m")
                        {
                            val = w - b;
                        }
                        else if (op == "*=")
                        {
                            val = w / b;
                        }
                        else if (op == "q")
                        {
                            val = (w / b - 1) * 100d;
                        }

                        int decimals = 6;
                        if (op == "*=") decimals = 8;
                        string valstring = G.UpdprtFormat(val, decimals, true); //6 decimals, must be enough also for interest rates etc.

                        valstring = valstring.Trim();  //necesssary?
                        sb.Append(valstring);
                        if (GekkoTime.Observations(t, per2) > 1) sb.Append(", ");
                    }
                    sb.Append(";");
                    sw.WriteLine(sb);
                }
            }
            G.Writeln2("Exported " + vars.Count + " variables to file " + pathAndFilename);
        }

        /// <summary>
        /// Use for Gekko functions laspchain() and laspfixed(), Laspeyres indexes.
        /// </summary>
        /// <param name="function"></param>
        /// <param name="list1"></param>
        /// <param name="list2"></param>
        /// <param name="indexYear"></param>
        /// <param name="tStart"></param>
        /// <param name="tEnd"></param>
        /// <returns></returns>
        public static IVariable Laspeyres(string function, IVariable list1, IVariable list2, GekkoTime indexYear, GekkoTime tStart, GekkoTime tEnd)
        {
            if (!(Program.options.freq == EFreq.A))
            {
                //G.Writeln();
                new Error("Index functions only work for annual frequency at the moment");
                //throw new GekkoException();
            }

            int indexYearI = -12345;
            int counter = -1;
            bool found = false;
            foreach (GekkoTime t in new GekkoTimeIterator(tStart, tEnd))  //fix for other freqs
            {
                counter++;
                if (t.EqualsGekkoTime(indexYear))
                {
                    found = true;
                    indexYearI = counter;
                    break;
                }
            }

            if (!found)
            {
                new Error("with index year in Laspeyres function: seems outside time period");
            }

            List<string> varsP = Stringlist.GetListOfStringsFromList((List)list1);
            List<string> varsX = Stringlist.GetListOfStringsFromList((List)list2);

            if (varsP.Count == 0 || varsX.Count == 0)
            {
                new Error("List with 0 elements not permitted");
            }

            if (varsP.Count != varsX.Count)
            {
                new Error("The lists should have same number of elements");
            }

            foreach (string s in varsP)
            {
                if (s.StartsWith("-"))
                {
                    new Error("'" + s + "': Please use subtraction in quantity list only");
                }
            }

            double[,] aX = PutTimeseriesIntoArrayPossiblyNegative(tStart, tEnd, varsX);
            double[,] aP = PutTimeseriesIntoArrayPossiblyNegative(tStart, tEnd, varsP);
            int obs = GekkoTime.Observations(tStart, tEnd);
            int obs2 = GekkoTime.Observations(tStart, indexYear);

            double[,] xx = new double[5, obs];
            //Seems [3, ...] is not used

            if (G.Equal(function, "laspchain"))
            {
                double index = 1d;
                xx[4, 0] = 1d;
                for (int i = 0; i < obs; i++)
                {
                    double sum = 0d;
                    double sum1 = 0d;
                    for (int j = 0; j < varsX.Count; j++)
                    {
                        sum += aX[j, i] * aP[j, i];
                        if (i > 0) sum1 += aX[j, i] * aP[j, i - 1];
                    }
                    xx[0, i] = sum;  //total cost
                    xx[1, i] = sum1;  //total cost at previous period prices
                    if (i > 0)
                    {
                        xx[2, i] = xx[1, i] / xx[0, i - 1];  //lasp.indexet år for år: C(plag) / C(p).lag
                        index = index * xx[2, i];
                        xx[4, i] = index;                    //lasp.indexet ganget op (1 i startperiode)
                                                             //xx[4,...] is the quantity index
                    }
                }
            }
            else if (G.Equal(function, "laspfixed"))
            {
                for (int i = 0; i < obs; i++)
                {
                    double sum = 0d;
                    double sum1 = 0d;
                    for (int j = 0; j < varsX.Count; j++)
                    {
                        sum += aX[j, i] * aP[j, i];
                        sum1 += aX[j, i] * aP[j, indexYearI];
                    }
                    xx[0, i] = sum;  //total cost
                    xx[1, i] = sum1;  //total cost at index period prices
                    xx[4, i] = sum1; //xx[4,...] is the quantity index
                }
            }
            else
            {
                throw new GekkoException();
            }

            Series p = new Series(EFreq.A, "p!a");  //all this should be deleted, but the code will run like this...
            Series q = new Series(EFreq.A, "q!a");

            double priceInIndexYear = xx[0, indexYearI] / xx[4, indexYearI];
            counter = -1;
            foreach (GekkoTime t in new GekkoTimeIterator(tStart, tEnd))
            {
                counter++;

                if (true)  //price = 1 in index year
                {
                    q.SetData(t, xx[4, counter] * priceInIndexYear);
                    p.SetData(t, xx[0, counter] / xx[4, counter] / priceInIndexYear);
                }
                else
                {
                    //FIXME
                    //4 skal være = 0 in index
                    q.SetData(t, xx[4, counter] / xx[4, indexYearI] * xx[0, indexYearI]);
                    p.SetData(t, xx[0, counter] / xx[4, counter] / priceInIndexYear);
                }
            }

            Map m = new Map();
            m.AddIVariable(p.GetName(), p);
            m.AddIVariable(q.GetName(), q);
            return m;
        }

        /// <summary>
        /// WRITE/EXPORT command.
        /// </summary>
        /// <param name="o"></param>
        /// <returns></returns>
        public static int Write(O.Write o)
        {
            //TODO: introduce frombank

            EDatabankWriteType writeType = GetWriteType(o);

            List<ToFrom> list = null;
            if (o.list1 != null)
            {
                if (o.list2 == null)
                {
                    o.list2 = new List();

                    // TT: It used to be done like below, but that introduced errors when for instance doing EXPORT <csv> fx*, fy*, where we will "simulate" an EXPORT <csv> fx*, fy* TO first:*, first:*. Now there is only 1 first:*.
                    //for (int i = 0; i < o.list1.list.Count; i++)
                    //{
                    //    o.list2.Add(new ScalarString("First:*"));
                    //}

                    o.list2.Add(new ScalarString("First:*"));


                }
                list = SearchFromTo(o.list1, o.list2, o.opt_frombank, null, EWildcardSearchType.Write, null);
            }

            if (writeType == EDatabankWriteType.Tsdx)
            {
                new Error("You cannot use <tsdx>. The extension name has changed to ." + Globals.extensionDatabank + ". If you really need a .tsdx file, you can WRITE/EXPORT a ." + Globals.extensionDatabank + " file, and rename that file to .tsdx afterwards.");
            }

            bool isDefault = false;
            if (writeType == EDatabankWriteType.Gbk)
            {
                isDefault = true;
            }

            string fileName = o.fileName;
            fileName = G.StripQuotes(fileName);

            if (Globals.pink && fileName != null && (fileName.ToLower().Contains("g:\\datopgek\\") || fileName.ToLower().Contains("g:/datopgek/")))
            {
                Globals.datopgek_errors.Add("WRITE/EXPORT of this file: " + fileName);
            }

            if (Globals.pink2)
            {
                if (writeType == EDatabankWriteType.Csv || writeType == EDatabankWriteType.Prn || writeType == EDatabankWriteType.Tsd)
                {
                    if (fileName != null && (fileName.ToLower().Contains("g:\\datopgek3\\") || fileName.ToLower().Contains("g:/datopgek3/")))
                    {
                        string fileName7 = fileName;
                        if (writeType == EDatabankWriteType.Csv && string.IsNullOrEmpty(Path.GetExtension(fileName7))) fileName7 += ".csv";
                        else if (writeType == EDatabankWriteType.Prn && string.IsNullOrEmpty(Path.GetExtension(fileName7))) fileName7 += ".prn";
                        else if (writeType == EDatabankWriteType.Tsd && string.IsNullOrEmpty(Path.GetExtension(fileName7))) fileName7 += ".tsd";
                        string fileName77 = CreateFullPathAndFileName(fileName7);
                        Globals.datopgek_otherBanks.Add(fileName77);
                    }
                }
            }

            bool isCaps = true; if (G.Equal(o.opt_caps, "no")) isCaps = false;
            GekkoTime tStart = o.t1;
            GekkoTime tEnd = o.t2;

            bool writeAllVariables = false;
            if (list == null) writeAllVariables = true;

            bool aliasRemember = Program.options.interface_alias;

            EVariablesForWrite variablesType = EVariablesForWrite.Normal;

            try
            {

                if (writeAllVariables) Program.options.interface_alias = false;  //is remembered above and reverted

                if (writeType == EDatabankWriteType.R)
                {
                    //special treatment for the time being
                    ExportR(o);
                    return o.list1.Count();
                }
                else if (writeType == EDatabankWriteType.Python)
                {
                    //special treatment for the time being
                    ExportPython(o);
                    return o.list1.Count();
                }
                else if (writeAllVariables)  //writing the whole first databank
                {
                    list = new List<ToFrom>();
                    foreach (string s in Program.databanks.GetFirst().storage.Keys)
                    {
                        if (s == "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0" || s == "")
                        {
                            continue;  //probably some artefact creeping in from PCIM?
                        }
                        list.Add(new ToFrom("First:" + s, "First:" + s, true));
                    }
                }

                //??? why is EWriteType not used in line below and elsewhere???
                bool isRecordsFormat = isDefault || G.Equal(o.opt_gbk, "yes") || G.Equal(o.opt_tsd, "yes") || G.Equal(o.opt_gdx, "yes") || G.Equal(o.opt_flat, "yes") || G.Equal(o.opt_gcm, "yes") || G.Equal(o.opt_arrow, "yes");

                //TODO TODO TODO
                //TODO TODO TODO
                //TODO TODO TODO Not sure is this filter stuff works ok for quarters and months...?
                //TODO TODO TODO
                //TODO TODO TODO

                List<ToFrom> listFilteredForCurrentFreq = null;
                if (isRecordsFormat)
                {
                    //can handle multiple frequencies etc.
                    listFilteredForCurrentFreq = list;
                }
                else
                {
                    //2D format, only 1 frequency
                    //listFilteredForCurrentFreq = FilterListForFrequency(list);

                    foreach (ToFrom two in list)
                    {
                        if (G.Equal(G.ConvertFreq(Program.options.freq), G.Chop_GetFreq(two.s1)))  //.s2 is probably not used here
                        {
                            //good
                            if (listFilteredForCurrentFreq == null) listFilteredForCurrentFreq = new List<ToFrom>();
                            listFilteredForCurrentFreq.Add(two);
                        }
                    }

                    if (listFilteredForCurrentFreq == null)
                    {
                        if (list.Count == 1 && G.Chop_HasSigil(list[0].s1))
                        {
                            variablesType = EVariablesForWrite.OneNonSeries;  //will only be active for 2D format
                            //a %- or #-variable, not a series
                            listFilteredForCurrentFreq = new List<ToFrom>();
                            listFilteredForCurrentFreq.Add(list[0]);
                        }
                    }
                }

                if (listFilteredForCurrentFreq == null || listFilteredForCurrentFreq.Count == 0)
                {
                    string s = null;
                    if (!isRecordsFormat)
                    {
                        s += "NOTE: Only variables of the current frequency (" + Program.options.freq.ToString() + ") are considered.";
                    }
                    new Error("No variables to write. " + s);
                }

                if (tStart.IsNull() && tEnd.IsNull())
                {
                    if (isRecordsFormat)
                    {
                        //Do nothing, skip this, we do not need to know the timespan of the bank
                    }
                    else
                    {
                        //will find that largest timespan of the databank series
                        GetDatabankPeriodFilteredForFreq(listFilteredForCurrentFreq, ref tStart, ref tEnd);
                    }
                }

                string writeOption = "" + Globals.extensionDatabank + "";  //default
                if (G.Equal(o.opt_tsd, "yes")) writeOption = "tsd";

                if (G.Equal(o.opt_csv, "yes") || G.Equal(o.opt_prn, "yes"))
                {
                    //2D format
                    ErrorIfMatrix(variablesType);
                    EdataFormat format = EdataFormat.Csv;
                    if (G.Equal(o.opt_csv, "yes")) format = EdataFormat.Csv;
                    else if (G.Equal(o.opt_prn, "yes")) format = EdataFormat.Prn;
                    CheckSomethingToWrite(listFilteredForCurrentFreq);
                    return CsvPrnWrite(listFilteredForCurrentFreq, fileName, tStart, tEnd, format, G.Equal(o.opt_cols, "yes"), o.opt_dateformat);
                }
                else if (G.Equal(o.opt_gnuplot, "yes"))
                {
                    //2D format
                    ErrorIfMatrix(variablesType);
                    CheckSomethingToWrite(listFilteredForCurrentFreq);
                    return GnuplotWrite(listFilteredForCurrentFreq, fileName, tStart, tEnd);
                }
                else if (G.Equal(o.opt_tsp, "yes"))
                {
                    //RECORDS
                    ErrorIfMatrix(variablesType);
                    CheckSomethingToWrite(listFilteredForCurrentFreq);
                    return Tspwrite(listFilteredForCurrentFreq, fileName, tStart, tEnd, isCaps);
                }
                else if (G.Equal(o.opt_xls, "yes") || G.Equal(o.opt_xlsx, "yes"))
                {
                    //2D format
                    CheckSomethingToWrite(listFilteredForCurrentFreq);
                    WriteToExcel(fileName, tStart, tEnd, listFilteredForCurrentFreq, G.Equal(o.opt_cols, "yes"), o.opt_dateformat, o.opt_datetype, variablesType);
                    return 0;
                }
                else if (o.opt_gdx != null)
                {
                    //RECORDS
                    ErrorIfMatrix(variablesType);
                    if (fileName == null || fileName.Trim() == "")
                    {
                        new Error("Please indicate a file name for EXPORT<gdx>");
                    }
                    CheckSomethingToWrite(listFilteredForCurrentFreq);
                    string file = G.AddExtension(fileName, "." + "gdx");
                    string pathAndFilename = CreateFullPathAndFileName(file);
                    if (Program.options.gams_fast)
                    {
                        GamsData.WriteGdx(Program.databanks.GetFirst(), tStart, tEnd, pathAndFilename, list);
                    }
                    else
                    {
                        GamsData.WriteGdxSlow(Program.databanks.GetFirst(), tStart, tEnd, pathAndFilename, list);
                    }
                    return 0;
                }
                else if (o.opt_arrow != null)
                {
                    //RECORDS
                    ErrorIfMatrix(variablesType);
                    if (fileName == null || fileName.Trim() == "")
                    {
                        new Error("Please indicate a file name for EXPORT<arrow>");
                        //throw new GekkoException();
                    }
                    CheckSomethingToWrite(listFilteredForCurrentFreq);
                    string file = G.AddExtension(fileName, "." + "arrow");
                    string pathAndFilename = CreateFullPathAndFileName(file);
                    try
                    {
                        Arrow.WriteArrowDatabank(Program.databanks.GetFirst(), tStart, tEnd, pathAndFilename, list);
                    }
                    catch (Exception e)
                    {
                        if (e.Message.Contains("System.OutOfMemoryException"))
                        {
                            G.Writeln2("Arrow writing ran out of memory. At the moment, the Arrow implementation", Color.Red);
                            G.Writeln("in Gekko is not very fast or memory-efficient, but more of a proof of concept.", Color.Red);
                            G.Writeln("In the longer run, we expect the Arrow interface to run very fast and efficiently", Color.Red);
                            G.Writeln("in Gekko, since speed and efficiency are fundamental to the Arrow project.", Color.Red);
                            G.Writeln();
                            throw;
                        }
                    }
                    return 0;
                }
                else if (isRecordsFormat)
                {
                    //RECORDS
                    CheckSomethingToWrite(list);
                    //first argument (the databank) is only used if list = null
                    if (isDefault)
                    {
                        return WriteGbk(Program.databanks.GetFirst(), tStart, tEnd, fileName, isCaps, list, writeOption, writeAllVariables, false);
                    }
                    if (writeType == EDatabankWriteType.Tsd)
                    {
                        return WriteTsd(Program.databanks.GetFirst(), tStart, tEnd, fileName, isCaps, list, writeOption, writeAllVariables, false);
                    }
                    else if (writeType == EDatabankWriteType.Flat)
                    {
                        return WriteFlat(Program.databanks.GetFirst(), tStart, tEnd, fileName, isCaps, list, writeOption, writeAllVariables, false);
                    }
                    else if (writeType == EDatabankWriteType.Gcm)
                    {
                        Program.WriteGcm(list, tStart, tEnd, o.opt_op, fileName);
                        return 0;
                    }
                    else
                    {
                        new Error("Unknown databank format"); return 0;
                    }
                }
                else
                {
                    new Error("Unknown databank format"); return 0;
                }
            }
            finally
            {
                Program.options.interface_alias = aliasRemember;
            }
        }

        /// <summary>
        /// Helper for WRITE/EXPORT
        /// </summary>
        /// <param name="variablesType"></param>
        private static void ErrorIfMatrix(EVariablesForWrite variablesType)
        {
            if (variablesType == EVariablesForWrite.OneNonSeries)
            {
                new Error("The format can not be used to EXPORT matrices");
                //throw new GekkoException();
            }
        }

        /// <summary>
        /// Helper for WRITE/EXPORT
        /// </summary>
        /// <param name="o"></param>
        /// <returns></returns>
        private static EDatabankWriteType GetWriteType(O.Write o)
        {
            EDatabankWriteType writeType = EDatabankWriteType.Gbk;
            if (G.Equal(o.opt_csv, "yes")) writeType = EDatabankWriteType.Csv;
            else if (G.Equal(o.opt_gdx, "yes")) writeType = EDatabankWriteType.Gdx;
            else if (G.Equal(o.opt_gnuplot, "yes")) writeType = EDatabankWriteType.Gnuplot;
            else if (G.Equal(o.opt_prn, "yes")) writeType = EDatabankWriteType.Prn;
            else if (G.Equal(o.opt_r, "yes")) writeType = EDatabankWriteType.R;
            else if (G.Equal(o.opt_gcm, "yes")) writeType = EDatabankWriteType.Gcm;
            else if (G.Equal(o.opt_tsd, "yes")) writeType = EDatabankWriteType.Tsd;
            else if (G.Equal(o.opt_tsdx, "yes")) writeType = EDatabankWriteType.Tsdx;
            else if (G.Equal(o.opt_tsp, "yes")) writeType = EDatabankWriteType.Tsp;
            else if (G.Equal(o.opt_xls, "yes")) writeType = EDatabankWriteType.Xls;
            else if (G.Equal(o.opt_xlsx, "yes")) writeType = EDatabankWriteType.Xlsx;
            else if (G.Equal(o.opt_flat, "yes")) writeType = EDatabankWriteType.Flat;
            else if (G.Equal(o.opt_python, "yes")) writeType = EDatabankWriteType.Python;
            else if (G.Equal(o.opt_arrow, "yes")) writeType = EDatabankWriteType.Arrow;
            return writeType;
        }

        /// <summary>
        /// Export from R
        /// </summary>
        /// <param name="o"></param>
        private static void ExportR(O.Write o)
        {
            //Special treatment, for the time being

            if (o.fileName == null)
            {
                new Error("You must state a filename with FILE = ...");
                //throw new GekkoException();
            }

            string fullFileName = CreateFullPathAndFileName(o.fileName);

            using (FileStream fs = WaitForFileStream(fullFileName, null, GekkoFileReadOrWrite.Write))
            using (StreamWriter file = G.GekkoStreamWriter(fs))
            {
                foreach (IVariable iv2 in o.list1.list)
                {
                    string s = iv2.ConvertToString();
                    if (!s.StartsWith(Globals.symbolCollection.ToString()))
                    {
                        new Error("EXPORT<r>: expected all list items to start with '#'");
                        //throw new GekkoException();
                    }
                    IVariable iv = null; iv = Program.databanks.GetFirst().GetIVariable(s);
                    if (iv == null)
                    {
                        new Error("" + s + " does not exist");
                        //throw new GekkoException();
                    }
                    if (iv.Type() != EVariableType.Matrix)
                    {
                        new Error("" + s + " is not a matrix");
                        //throw new GekkoException();
                    }
                    Matrix m = (Matrix)iv;
                    file.WriteLine(Program.MatrixFromGekkoToROrPython<double>(s.Substring(1), m.data, 0));
                    file.WriteLine();
                }
                file.Flush();
            }
            G.Writeln2("R export of " + o.list1.Count() + " matrices, " + fullFileName);
        }

        /// <summary>
        /// Export from Python.
        /// </summary>
        /// <param name="o"></param>
        private static void ExportPython(O.Write o)
        {
            //Special treatment, for the time being

            if (o.fileName == null)
            {
                new Error("You must state a filename with FILE = ...");
                //throw new GekkoException();
            }

            string fullFileName = CreateFullPathAndFileName(o.fileName);

            using (FileStream fs = WaitForFileStream(fullFileName, null, GekkoFileReadOrWrite.Write))
            using (StreamWriter file = G.GekkoStreamWriter(fs))
            {
                foreach (IVariable iv2 in o.list1.list)
                {
                    string s = iv2.ConvertToString();
                    if (!s.StartsWith(Globals.symbolCollection.ToString()))
                    {
                        new Error("EXPORT<python>: expected all list items to start with '#'");
                        //throw new GekkoException();
                    }
                    IVariable iv = null; iv = Program.databanks.GetFirst().GetIVariable(s);
                    if (iv == null)
                    {
                        new Error("" + s + " does not exist");
                        //throw new GekkoException();
                    }
                    if (iv.Type() != EVariableType.Matrix)
                    {
                        new Error("" + s + " is not a matrix");
                        //throw new GekkoException();
                    }
                    Matrix m = (Matrix)iv;
                    file.WriteLine(Program.MatrixFromGekkoToROrPython<double>(s.Substring(1), m.data, 1));
                    file.WriteLine();
                }
                file.Flush();
            }
            G.Writeln2("Python export of " + o.list1.Count() + " matrices, " + fullFileName);
        }

        /// <summary>
        /// Error message for WRITE/EXPORT if there are 0 variables.
        /// </summary>
        /// <param name="listFilteredForCurrentFreq"></param>
        private static void CheckSomethingToWrite(List<ToFrom> listFilteredForCurrentFreq)
        {
            if (listFilteredForCurrentFreq == null || listFilteredForCurrentFreq.Count == 0)
            {
                new Error("No variables to write");
                //throw new GekkoException();
            }
        }

        private static void WriteToExcel(string fileName, GekkoTime tStart, GekkoTime tEnd, List<ToFrom> list, bool isCols, string dateformat, string datetype, EVariablesForWrite variablesType)
        {
            ExcelOptions eo = new ExcelOptions();

            if (variablesType == EVariablesForWrite.Normal)
            {

                G.Writeln2("Writing Excel file for the period " + G.FromDateToString(tStart) + "-" + G.FromDateToString(tEnd));
                //TODO: variables and time                

                int counter = 0;
                int numberOfCols = GekkoTime.Observations(tStart, tEnd);
                int numberOfRows = list.Count;

                eo.excelData = new double[numberOfRows, numberOfCols];
                eo.excelRowLabels = new string[numberOfRows, 1];
                eo.excelColumnLabels = new string[1, numberOfCols];
                eo.excelColumnLabelsGekkoTime = new GekkoTime[1, numberOfCols];
                eo.transpose = "no"; if (isCols) eo.transpose = "yes"; //kind of a workaround

                for (int i = 0; i < list.Count; i++)
                {
                    IVariable iv = O.GetIVariableFromString(list[i].s1, O.ECreatePossibilities.NoneReportError, true);
                    Series ts = iv as Series;
                    string varLabel = G.Chop_GetName(list[i].s2);
                    eo.excelRowLabels[i, 0] = varLabel;

                    if (ts == null)
                    {
                        //TODO: check this beforehand, and do a msgbox with all missing vars (a la when doing sim)                        
                        continue;
                    }
                    counter++;
                    int periodCounter = 0;

                    foreach (GekkoTime gt in new GekkoTimeIterator(tStart, tEnd))
                    {
                        eo.excelColumnLabels[0, periodCounter] = gt.ToString();
                        eo.excelColumnLabelsGekkoTime[0, periodCounter] = gt;
                        double var1 = ts.GetDataSimple(gt);
                        if (G.isNumericalError(var1)) var1 = 9.99999e+99;
                        eo.excelData[i, periodCounter] = var1;
                        periodCounter++;
                    }
                }
            }
            else
            {
                int iHere = 0;
                IVariable iv = O.GetIVariableFromString(list[iHere].s1, O.ECreatePossibilities.NoneReportError, true);
                Matrix m = iv as Matrix;
                if (m == null)
                {
                    G.Writeln2("The variable '" + list[iHere].s1 + "' is not a matrix");
                    throw new GekkoException();
                }
                double[,] data = m.data;
                int ni = data.GetLength(0);
                int nj = data.GetLength(1);

                G.Writeln2("Writing Excel file containing matrix");

                eo.excelData = new double[ni, nj];
                eo.colors = "no";

                if (m.rownames != null)
                {
                    eo.excelRowLabels = new string[m.rownames.Count, 1];
                    for (int i = 0; i < m.rownames.Count; i++) eo.excelRowLabels[i, 0] = m.rownames[i];
                }

                if (m.colnames != null)
                {
                    eo.excelColumnLabels = new string[1, m.colnames.Count];
                    for (int i = 0; i < m.colnames.Count; i++) eo.excelColumnLabels[0, i] = m.colnames[i];
                }

                for (int i = 0; i < ni; i++)
                {
                    for (int j = 0; j < nj; j++)
                    {
                        double var1 = data[i, j];
                        if (G.isNumericalError(var1)) var1 = 9.99999e+99;
                        eo.excelData[i, j] = var1;
                    }
                }

            }

            eo.fileName = fileName;

            Program.WriteExcel(eo, null, false, variablesType == EVariablesForWrite.OneNonSeries, dateformat, datetype);
        }

        public static string ArrayTimeseriesTip(string name)
        {
            return "Tip: try 'DISP " + name + ";' to see the dimensions.";
        }


        public static int WriteGbk(Databank databank, GekkoTime yr1, GekkoTime yr2, string file, bool isCaps, List<ToFrom> list, string writeOption, bool writeAllVariables, bool isCloseCommand)
        {
            if (databank.storage.Count == 0)
            {
                if (isCloseCommand)
                {
                    if (databank.fileHash == Globals.brandNewFile)
                    {
                        G.Writeln2("Databank " + databank.name + " is empty and hence not written");
                        return 0;
                    }
                    else
                    {
                        //write it: it could be an OPEN<edit> on existing file with series. Then CLEAR. Then CLOSE.
                        //in that case, an empty bank should be written.
                    }
                }
                else
                {
                    //nowadays we may have WRITE b2:* file=myfile, not related to Work or first bank at all!                    
                }
            }

            file = G.StripQuotes(file);
            bool isUsingOptionFolderBank = false;
            if (Program.options.folder && Program.options.folder_bank != "") isUsingOptionFolderBank = true;

            string tempTsdxPath = null;

            bool isTsdx = true;
            string extension = Globals.extensionDatabank;

            DateTime t = DateTime.Now;

            file = G.AddExtension(file, "." + extension);

            string path = null;
            if (isUsingOptionFolderBank)
            {
                path = Program.options.folder_bank;
            }
            string pathAndFilename = CreateFullPathAndFileNameFromFolder(file, path);

            string pathAndFileNameResultingFile = pathAndFilename;

            if (Globals.pink)
            {
                if (pathAndFileNameResultingFile != null && (pathAndFileNameResultingFile.ToLower().Contains("g:\\datopgek3\\") || pathAndFileNameResultingFile.ToLower().Contains("g:/datopgek3/")))
                {
                    Globals.datopgek_banks.Add(pathAndFileNameResultingFile);
                }
            }

            int count = 0;

            string tsdxVersion = "1.2"; //Gekko 3.0

            //try to zip it to this local folder
            tempTsdxPath = CreateTempFolderPath("temptsdxfolder");
            if (!Directory.Exists(tempTsdxPath))  //should almost never exist, since name is random
            {
                Directory.CreateDirectory(tempTsdxPath);
            }
            else
            {
                //in the very rare case, any files here will be overwritten
            }
            //pathAndFilename = tempTsdxPath + "\\" + "databank" + ".tsd";

            CreateDatabankXmlInfo(databank, tempTsdxPath, tsdxVersion, isCloseCommand);

            //May take a little time to create: so use static serializer if doing serialize on a lot of small objects

            string pathAndFilename2 = tempTsdxPath + "\\" + Program.options.databank_file_gbk_internal; //changed from .bin to .data
            databank.Trim();  //to make it smaller, slack removed from each IVariable

            //Note that if writeAllVariables=true, we don't make any list of the variables, the databank
            //object is simply serialized directly. So any timeseries will be written in that case.
            GekkoDictionary<string, IVariable> databankWithFewerVariables = null;
            GekkoDictionary<string, IVariable> storageOriginal = databank.storage;  //for resetting back to this afterwards

            try
            {
                if (writeAllVariables == false)
                {
                    //-----------------------
                    // truncate the variables
                    // here, databank variable is not used (this is actually only used for CLOSEing a bank)
                    //-----------------------
                    databankWithFewerVariables = new GekkoDictionary<string, IVariable>(StringComparer.OrdinalIgnoreCase);
                    foreach (ToFrom var in list)
                    {
                        //Databank db = GetBankFromBankNameVersion(var.bank);
                        //IVariable xx = O.Lookup(null, null, var.bank, var.name, var.freq, null, false, EVariableType.Var, true);

                        IVariable xx = O.GetIVariableFromString(var.s1, O.ECreatePossibilities.NoneReportError, true);

                        string varnameWithFreq = G.Chop_GetNameAndFreq(var.s2);

                        if (databankWithFewerVariables.ContainsKey(varnameWithFreq))
                        {
                            new Error("Gbk format does not allow duplicate variables, " + G.GetNameAndFreqPretty(varnameWithFreq) + ". This is enforced for " + Globals.extensionDatabank + " version 1.1 and later.");
                        }
                        else
                        {
                            databankWithFewerVariables.Add(varnameWithFreq, xx);
                        }
                    }
                }

                if (databankWithFewerVariables != null) databank.storage = databankWithFewerVariables;  //will be reset later on --> to storageOriginal

                if (!yr1.IsNull() || !yr2.IsNull())
                {
                    //----------------------
                    // truncate the periods
                    //----------------------
                    GekkoDictionary<string, IVariable> databankWithFewerPeriods = new GekkoDictionary<string, IVariable>(StringComparer.OrdinalIgnoreCase);
                    foreach (KeyValuePair<string, IVariable> kvp in databank.storage)
                    {
                        Series ts = kvp.Value as Series;
                        if (ts != null)
                        {
                            Series tsClone = ts.DeepClone(null) as Series;
                            tsClone.Truncate(yr1, yr2);
                            databankWithFewerPeriods.Add(kvp.Key, tsClone);
                        }
                    }
                    databank.storage = databankWithFewerPeriods;
                    databank.Trim();  //to make it smaller, slack removed from each Series
                }

                ProtobufWrite(databank, pathAndFilename2);
                count = databank.storage.Count;  //must be before the finally
            }
            finally
            {
                //so we are sure it always gets pointed back to its real Dictionary<>!
                databank.storage = storageOriginal;
            }            

            DateTime dt0 = DateTime.Now;

            WaitForZipWrite(tempTsdxPath, pathAndFileNameResultingFile);

            if (true)
            {
                G.Writeln();
                G.Writeln("Wrote " + count + " variables to " + pathAndFileNameResultingFile + " in " + G.Seconds(t));
                if (isUsingOptionFolderBank)
                {
                    if (!file.Contains(":"))  //Don't write this message if it is a absolute path, for instance c:\mybank\myfile. Relative paths will get the message (that must be ok)
                    {
                        new Note("Wrote to user-indicated folder (see 'option folder bank = ...')");
                    }
                }
            }
            return count;
        }

        /// <summary>
        /// Writes an object to protobuffer file
        /// </summary>
        /// <param name="o"></param>
        /// <param name="pathAndFilename2"></param>
        public static void ProtobufWrite(object o, string pathAndFilename2)
        {
            using (FileStream fs = WaitForFileStream(pathAndFilename2, null, GekkoFileReadOrWrite.Write))
            {
                try
                {
                    //May take a little time to create: so use static serializer if doing serialize on a lot of small objects
                    //But this way, it is more thread-safe?
                    //And a lot of small objects are not protobuffed anyway?
                    RuntimeTypeModel serializer = RuntimeTypeModel.Create();
                    serializer.UseImplicitZeroDefaults = false; //otherwise an int that has default constructor value -12345 but is set to 0 will reappear as a -12345 (instead of 0). For int, 0 is default, false for bools etc.
                    serializer.Serialize(fs, o);
                }
                catch (Exception e)
                {
                    //Hmmm: this will not abort if Error()
                    new Warning("Technical problem while writing protobuffer file '" + pathAndFilename2 + "'. Message: " + e.Message);
                    throw;
                }
            }
        }

        public static int WriteTsd(Databank databank, GekkoTime yr1, GekkoTime yr2, string file, bool isCaps, List<ToFrom> list, string writeOption, bool writeAllVariables, bool isCloseCommand)
        {
            if (databank.storage.Count == 0)
            {
                if (isCloseCommand)
                {
                    new Error("Closed TSD databank was changed but cannot be written back");
                    //throw new GekkoException();
                }
            }

            file = G.StripQuotes(file);
            bool isUsingOptionFolderBank = false;
            if (Program.options.folder && Program.options.folder_bank != "") isUsingOptionFolderBank = true;

            string tempTsdxPath = null;

            bool isTsdx = false;
            string extension = "tsd";

            DateTime t = DateTime.Now;

            file = G.AddExtension(file, "." + extension);

            string path = null;
            if (isUsingOptionFolderBank)
            {
                path = Program.options.folder_bank;
            }
            string pathAndFilename = CreateFullPathAndFileNameFromFolder(file, path);

            string pathAndFileNameResultingFile = pathAndFilename;

            int count = 0;

            DateTime dt0 = DateTime.Now;
            WriteTsdRecords(ref yr1, ref yr2, isCaps, list, databank, isTsdx, pathAndFilename, ref count);

            if (true)
            {
                G.Writeln();
                G.Writeln("Wrote " + count + " variables to " + pathAndFileNameResultingFile + " in " + G.Seconds(t));
                if (isUsingOptionFolderBank)
                {
                    if (!file.Contains(":"))  //Don't write this message if it is a absolute path, for instance c:\mybank\myfile. Relative paths will get the message (that must be ok)
                    {
                        new Note("Wrote to user-indicated folder (see 'option folder bank = ...')");
                    }
                }
            }
            return count;
        }

        public static int WriteFlat(Databank databank, GekkoTime yr1, GekkoTime yr2, string file, bool isCaps, List<ToFrom> list, string writeOption, bool writeAllVariables, bool isCloseCommand)
        {
            if (databank.storage.Count == 0)
            {
                new Error("Databank is empty");
                //throw new GekkoException();
            }

            file = G.StripQuotes(file);
            bool isUsingOptionFolderBank = false;
            if (Program.options.folder && Program.options.folder_bank != "") isUsingOptionFolderBank = true;

            string extension = "flat";
            DateTime t = DateTime.Now;
            file = G.AddExtension(file, "." + extension);

            string path = null;
            if (isUsingOptionFolderBank)
            {
                path = Program.options.folder_bank;
            }
            string pathAndFilename = CreateFullPathAndFileNameFromFolder(file, path);

            string pathAndFileNameResultingFile = pathAndFilename;

            int count = 0;

            DateTime dt0 = DateTime.Now;
            WriteFlatRecords(ref yr1, ref yr2, isCaps, list, databank, pathAndFilename, ref count);

            if (true)
            {
                G.Writeln();
                G.Writeln("Wrote " + count + " variables to " + pathAndFileNameResultingFile + " in " + G.Seconds(t));
                if (isUsingOptionFolderBank)
                {
                    if (!file.Contains(":"))  //Don't write this message if it is a absolute path, for instance c:\mybank\myfile. Relative paths will get the message (that must be ok)
                    {
                        new Note("Wrote to user-indicated folder (see 'option folder bank = ...')");
                    }
                }
            }
            return count;
        }

        private static void WriteFlatRecords(ref GekkoTime yr1, ref GekkoTime yr2, bool isCaps, List<ToFrom> list, Databank databank, string pathAndFilename, ref int count)
        {
            StringBuilder sb = new StringBuilder();

            using (FileStream fs = WaitForFileStream(pathAndFilename, null, GekkoFileReadOrWrite.Write))
            using (StreamWriter res = G.GekkoStreamWriter(fs))
            {
                foreach (ToFrom var in list)
                {
                    IVariable iv = O.GetIVariableFromString(var.s1, O.ECreatePossibilities.NoneReportError, true);

                    Series ts = iv as Series;
                    {
                        if (ts == null) continue; //skip  
                        if (ts.type != ESeriesType.Normal) continue; //skip  
                        count++;
                        WriteFlatRecord(yr1, yr2, res, ts, G.Chop_GetNameAndFreq(var.s2), sb);
                    }
                }
                res.Flush();
            }
        }

        public static void WriteFile(IVariable file2, IVariable x1)
        {
            string file = O.ConvertToString(file2);
            string x = O.ConvertToString(x1);
            string[] xx = x.Split(new string[] { "\\n" }, StringSplitOptions.None);
            using (FileStream fs = WaitForFileStream(file, null, GekkoFileReadOrWrite.Write))
            using (StreamWriter res = G.GekkoStreamWriter(fs))
            {

                for (int i = 0; i < xx.Length - 1; i++)
                {
                    res.WriteLine(xx[i]);
                }
                res.Write(xx[xx.Length - 1]);

                res.Flush();
            }
        }

        private static void WriteTsdRecords(ref GekkoTime yr1, ref GekkoTime yr2, bool isCaps, List<ToFrom> list, Databank databank, bool isTsdx, string pathAndFilename, ref int count)
        {
            using (FileStream fs = WaitForFileStream(pathAndFilename, null, GekkoFileReadOrWrite.Write))
            using (StreamWriter res = G.GekkoStreamWriter(fs))
            {
                foreach (ToFrom var in list)
                {
                    IVariable iv = O.GetIVariableFromString(var.s1, O.ECreatePossibilities.NoneReportError, true);

                    Series ts = iv as Series;
                    {
                        if (ts == null) continue;  //skip                            
                        count++;
                        WriteTsdRecord(yr1, yr2, res, ts, G.Chop_GetName(var.s2), isCaps, isTsdx);
                    }
                }
                res.Flush();
            }
        }

        private static void CreateDatabankXmlInfo(Databank databank, string tempTsdxPath, string tsdxVersion, bool isCloseCommand)
        {

            // Create the xml document containe
            XmlDocument doc = new XmlDocument();// Create the XML Declaration, and append it to XML document
            XmlDeclaration dec = doc.CreateXmlDeclaration("1.0", null, null);
            //doc.Attributes.Append(new XmlAttribute
            doc.AppendChild(dec);// Create the root element
            //Using PascalCase for elements, and camelCase for attributes.
            XmlElement root = doc.CreateElement("DatabankInfo");
            root.SetAttribute("databankVersion", tsdxVersion);  //needs to be changed if Databank/Series change
            root.SetAttribute("gekkoVersion", Globals.gekkoVersion);
            doc.AppendChild(root);

            XmlElement comment = doc.CreateElement("Info1");  //HDG
            comment.InnerText = databank.info1;
            root.AppendChild(comment);

            XmlElement date = doc.CreateElement("Date");
            string now = GetDateTimePretty(DateTime.Now);
            date.InnerText = now;
            root.AppendChild(date);

            if (G.GetModelSourceType() == EModelType.Gekko && !isCloseCommand)
            {
                //We do not want to put model info into XML if it is a CLOSE command triggering the bank write, for
                //instance after a OPEN<edit>, etc. This is mode=data and something else.
                //(Would probably happen very rarely anyhow, since model endogenous and databank variables must match)
                bool ok = true;
                foreach (string s in Program.model.modelGekko.endogenousOriginallyInModel.Keys)
                {
                    if (!databank.ContainsIVariable(s + Globals.freqIndicator + G.ConvertFreq(Program.options.freq)))
                    {
                        ok = false;
                        break;
                    }
                }

                if (ok == true)  //all model endogenous are found in the databank. If so, we add the extra model info. If not, only HDG and stamp are written into xml.
                {

                    XmlElement modelName = doc.CreateElement("ModelName");
                    modelName.InnerText = Path.GetFileName(Program.model.modelGekko.modelInfo.fileName);
                    root.AppendChild(modelName);

                    XmlElement modelInfo = doc.CreateElement("ModelInfo");
                    modelInfo.InnerText = Program.model.modelGekko.modelInfo.info;
                    root.AppendChild(modelInfo);

                    XmlElement modelDate = doc.CreateElement("ModelDate");
                    modelDate.InnerText = Program.model.modelGekko.modelInfo.date;
                    root.AppendChild(modelDate);

                    XmlElement modelSignature = doc.CreateElement("ModelSignature");
                    modelSignature.InnerText = Program.model.modelGekko.signatureFoundInFileHeader;
                    root.AppendChild(modelSignature);

                    XmlElement modelHash = doc.CreateElement("ModelHash");
                    modelHash.InnerText = Program.model.modelGekko.modelHashTrue;
                    root.AppendChild(modelHash);

                    XmlElement modelLastSimPeriod = doc.CreateElement("ModelLastSimPeriod");
                    if (Program.model.modelGekko.lastSimPer1.IsNull() || Program.model.modelGekko.lastSimPer2.IsNull()) modelLastSimPeriod.InnerText = "";
                    else modelLastSimPeriod.InnerText = G.FromDateToString(Program.model.modelGekko.lastSimPer1) + "-" + G.FromDateToString(Program.model.modelGekko.lastSimPer2);
                    root.AppendChild(modelLastSimPeriod);

                    XmlElement modelLastSimStamp = doc.CreateElement("ModelLastSimStamp");
                    modelLastSimStamp.InnerText = Program.model.modelGekko.lastSimStamp;
                    root.AppendChild(modelLastSimStamp);

                    XmlElement modelLargestLag = doc.CreateElement("ModelLargestLag");
                    modelLargestLag.InnerText = "" + Program.model.modelGekko.largestLag;
                    root.AppendChild(modelLargestLag);

                    XmlElement modelLargestLead = doc.CreateElement("ModelLargestLead");
                    modelLargestLead.InnerText = "" + Program.model.modelGekko.largestLead;
                    root.AppendChild(modelLargestLead);
                }
            }

            string xmlOutput = doc.OuterXml;
            using (FileStream fs = WaitForFileStream(tempTsdxPath + "\\" + "DatabankInfo.xml", null, GekkoFileReadOrWrite.Write))
            {
                doc.Save(fs);
            }
        }

        public static string GetDateTimePretty(DateTime date1)
        {
            return GetDateTimePretty(date1, false);
        }

        public static string GetDateTimePretty(DateTime date1, bool shortTime)
        {
            string code = "G";
            if (shortTime) code = "g";  //no seconds
            string now = date1.ToString(code, CultureInfo.CreateSpecificCulture(Globals.languageDaDK));
            return now;
        }

        public static string GetDateStamp()
        {
            //See also #80927435209843
            DateTime date1 = DateTime.Now;
            string now = date1.ToString("d", CultureInfo.CreateSpecificCulture(Globals.languageDaDK));
            return now;
        }

        public static string GetTimeStamp()
        {
            DateTime date1 = DateTime.Now;
            string now = date1.ToString("T", CultureInfo.CreateSpecificCulture(Globals.languageDaDK));
            return now;
        }



        //This is a general method for zipping the contents of a folder
        public static void WaitForZipWrite(string folder, string zipFileName)
        {
            string path_zipFileName = Path.GetDirectoryName(zipFileName);
            if (!Directory.Exists(path_zipFileName))
            {
                new Error("The directory '" + path_zipFileName + "' does not seem to exist");
                //throw new GekkoException();
            }

            DirectoryInfo folderInfo = new DirectoryInfo(folder);

            bool compress = true;
            if (zipFileName.ToLower().EndsWith("." + Globals.extensionDatabank + "") && Program.options.databank_file_gbk_compress == false) compress = false;

            if (Globals.threadIsInProcessOfAborting && !Globals.applicationIsInProcessOfAborting) throw new GekkoException();
            try
            {                
                if (!System.IO.Directory.Exists(folderInfo.FullName))
                {
                    new Warning("Zip file could not be created");  //should not be possible                        
                }

                int sleepMs = 10;

                using (FileStream fs = Program.WaitForFileStream(zipFileName, null, Program.GekkoFileReadOrWrite.Write))
                {
                    //fs is not actually used, but this way we wait for blocked files
                    Thread.Sleep(sleepMs);  //to make sure the file is released
                }

                File.Delete(zipFileName);
                Thread.Sleep(sleepMs);  //give some time after file is deleted
                if (compress)
                {
                    ZipFile.CreateFromDirectory(folder, zipFileName);
                }
                else
                {
                    ZipFile.CreateFromDirectory(folder, zipFileName, System.IO.Compression.CompressionLevel.NoCompression, false);
                }
            }
            catch (Exception e)
            {
                new Error("Zip write failed, error: " + e.InnerException + " " + e.Message);
            }

            try
            {
                if (System.IO.Directory.Exists(folderInfo.FullName))
                {
                    System.IO.Directory.Delete(folderInfo.FullName, true);
                }
            }
            catch (Exception e)
            {
                //do nothing
            }
        }

        //
        /// <summary>
        /// Only used for reading TSDX files, much more specific than WaitForZipRead()
        /// </summary>
        /// <param name="folder"></param>
        /// <param name="zipFileName"></param>
        /// <param name="inside"></param>
        /// <param name="originalFileName"></param>
        /// <returns></returns>
        public static string WaitForZipRead_TSDX(string folder, string zipFileName, string inside, string originalFileName)
        {

            //is not actually waiting...
            int gap = Globals.waitFileGap;  //2 seconds
            int totalTime = Globals.waitFileTotalTime;  //600 seconds
            int repeats = totalTime / gap;
            string tsdFile = "";
            bool isProtobuf = false;
            string ext = Path.GetExtension(zipFileName);
            if (G.Equal(ext, "." + Globals.extensionDatabank)) isProtobuf = true; //with .gbk files, the inside is always protobuf-files.
            DirectoryInfo folderInfo = new DirectoryInfo(folder);
            if (Globals.threadIsInProcessOfAborting && !Globals.applicationIsInProcessOfAborting) throw new GekkoException();
            //try-catch is not used here: normally a zip-file can be read even if blocked by others (not so for writing)                                

            try
            {
                ZipFile.ExtractToDirectory(zipFileName, folder);
            }
            catch (Exception e)
            {
                new Error("Zip extraction failed: " + e.InnerException + " " + e.Message, false);
            }

            string xmlFile = "";
            int tsdfilecounter = 0;
            foreach (FileInfo fi in (new DirectoryInfo(folder)).GetFiles())
            {
                string fileName2 = fi.Name;

                if (G.Equal(fileName2, Globals.protobufFileName) || G.Equal(fileName2, Globals.protobufFileName2) || G.Equal(fileName2, Program.options.databank_file_gbk_internal))
                {
                    //this is only relevant for the older .tsdx files, .gbk files always has isProtobuf = true.
                    isProtobuf = true;
                }

                if (string.Compare(inside, fileName2, true) == 0)
                {
                    //This is only for legacy reasons: all new tsdx files have databank.tsd as internal file.
                    //Remove this option a some point.
                    tsdFile = fileName2;
                    tsdfilecounter++;
                }
                if (string.Compare("databank.tsd", fileName2, true) == 0)
                {
                    tsdFile = fileName2;
                    tsdfilecounter++;
                }
                if (string.Compare("DatabankInfo.xml", fileName2, true) == 0)
                {
                    xmlFile = fileName2;
                }
            }

            if (xmlFile == "")
            {
                new Error("Cannot find xml-file inside zip-file. Expected to find '" + "DatabankInfo.xml" + "' inside '" + originalFileName + "'");
                //throw new GekkoException();
            }

            if (isProtobuf)
            {
                tsdFile = Globals.isAProto;  //okay, this is a hacky way to signal back...
            }
            else
            {
                if (tsdfilecounter == 2 && G.Equal(inside, "databank.tsd"))
                {
                    //the rare case where the databank file name is "databank"
                    tsdfilecounter = 1;
                }

                if (tsdfilecounter > 1)
                {
                    new Error("Found several tsd-files inside zip-file. Cannot decide which one to use");
                    //throw new GekkoException();
                }

                if (tsdFile == "")
                {
                    new Error("Cannot find tsd-file inside zip-file. Expected to find '" + inside + "' inside '" + originalFileName + "'");
                    //throw new GekkoException();
                }
            }

            return tsdFile;
        }

        public static void AbortingReset()
        {
            Globals.threadIsInProcessOfAborting = false;  //clearing this
            Globals.applicationIsInProcessOfAborting = false;  //clearing this
        }

        /// <summary>
        /// See called method. Note: prettyPathAndFilename may be = null if it is not a zip-extracted file.
        /// </summary>
        /// <param name="realPathAndFilename"></param>
        /// <param name="type"></param>
        /// <returns></returns>
        public static FileStream WaitForFileStream(string realPathAndFilename, string prettyPathAndFilename, GekkoFileReadOrWrite type)
        {
            return WaitForFileStream(realPathAndFilename, prettyPathAndFilename, type, false, -12345);
        }

        /// <summary>
        /// See called method. Note: prettyPathAndFilename may be = null if it is not a zip-extracted file.
        /// </summary>
        /// <param name="realPathAndFilename"></param>
        /// <param name="type"></param>
        /// <param name="bufferSize"></param>
        /// <returns></returns>
        public static FileStream WaitForFileStream(string realPathAndFilename, string prettyPathAndFilename, GekkoFileReadOrWrite type, int bufferSize)
        {
            return WaitForFileStream(realPathAndFilename, prettyPathAndFilename, type, false, bufferSize);
        }

        /// <summary>
        /// Set bufferSize to -12345 to make it default (4096 at the moment). For a lot of file reading, 4096 (bytes) is probably fine
        /// and small and fits cache etc. But when the Stream is fed to a hash code generator like SHA256, using 
        /// 1200000 bytes for bufferSize (1.2 MB) may speed up around 20%. Note: prettyPathAndFilename may be = null if it is not a zip-extracted file.
        /// </summary>
        /// <param name="realPathAndFilename"></param>
        /// <param name="type"></param>
        /// <param name="printAnyExceptionOnScreen"></param>
        /// <param name="bufferSize"></param>
        /// <returns></returns>
        public static FileStream WaitForFileStream(string realPathAndFilename, string prettyPathAndFilename, GekkoFileReadOrWrite type, bool printAnyExceptionOnScreen, int bufferSize)
        {
            if (type != GekkoFileReadOrWrite.Read)
            {
                PossibleLibraryOrZipWriteError(realPathAndFilename, "write");
            }

            FileStream fs = null;

            int gap = Globals.waitFileGap;  //2 seconds
            int totalTime = Globals.waitFileTotalTime;  //600 seconds
            int repeats = totalTime / gap;

            FileMode fm = FileMode.Create;  //if writing, -- if the file exists overwrite it, otherwise create it
            if (type == GekkoFileReadOrWrite.WriteAppend) fm = FileMode.Append; //if writing, -- if the file exists append to it, otherwise create it

            FileAccess fa = FileAccess.Write; //if writing
            FileShare fsh = FileShare.None; //if writing, -- don't allow others to read while we write

            if (type == GekkoFileReadOrWrite.Read)
            {
                fm = FileMode.Open; //if reading
                fa = FileAccess.Read; //if reading
                fsh = FileShare.Read; ; //if reading
            }

            for (int i = 0; i < repeats; i++)
            {
                if (Globals.threadIsInProcessOfAborting && !Globals.applicationIsInProcessOfAborting) throw new GekkoException();

                string realFilePathName = Path.GetDirectoryName(realPathAndFilename);

                if (type == GekkoFileReadOrWrite.Read)
                {

                    //checking if the file is there at all for reading
                    if (!File.Exists(realPathAndFilename))
                    {
                        using (Error e = new Error())
                        {
                            string f = null;
                            if (prettyPathAndFilename == null)
                            {
                                //normal: not from inside zipped file
                                e.MainAdd("Could not find file '" + realPathAndFilename + "' for reading.");
                                if (!Directory.Exists(realFilePathName)) e.MainAdd("The directory '" + realFilePathName + "' does not seem to exist.");
                            }
                            else
                            {
                                //from inside zipped file
                                e.MainAdd("Could not find file '" + prettyPathAndFilename + "' for reading.");
                                e.MainAdd("The file has been unzipped, but cannot be read from the following temporary file: '" + realPathAndFilename + "'");
                            }                            
                        }
                    }
                }
                else if (type == GekkoFileReadOrWrite.WriteAppend)
                {
                    //checking if the file is there at all for appending
                    if (!File.Exists(realPathAndFilename))
                    {
                        using (Error e = new Error())
                        {
                            e.MainAdd("Could not find file '" + realPathAndFilename + "' for appending.");
                            if (!Directory.Exists(realFilePathName)) e.MainAdd("The directory '" + realFilePathName + "' does not seem to exist.");
                        }
                    }
                }
                else if (type == GekkoFileReadOrWrite.Write)
                {
                    //checking if the path exists for writing the file
                    //string extension = Path.GetExtension(pathAndFilename);

                    if (Directory.Exists(realPathAndFilename))
                    {
                        new Error("There exists a folder with the same name: " + realPathAndFilename);
                    }

                    if (realFilePathName != "")  //sometimes pathAndFilename may be just the filename??
                    {
                        if (!Directory.Exists(realFilePathName))
                        {
                            new Error("Could not find directory '" + realFilePathName + "' for writing");
                        }
                    }
                }

                try
                {
                    //We used to use this:
                    //fs = File.Open(pathAndFilename, fm, fa, fsh);
                    //But according to this: https://stackoverflow.com/questions/2375369/difference-between-file-open-and-new-filestream
                    //we can use FileStream to also set a buffer
                    if (bufferSize == -12345)
                    {
                        fs = new FileStream(realPathAndFilename, fm, fa, fsh); //default: 4096
                    }
                    else
                    {
                        fs = new FileStream(realPathAndFilename, fm, fa, fsh, bufferSize); //default: 4096
                    }
                }
                catch (UnauthorizedAccessException e)
                {
                    new Warning("File '" + realPathAndFilename + "' seems read-only. Retrying... (" + (i * gap) + " seconds)");
                    Thread.Sleep(gap * 1000);  //1 seconds
                    continue;
                }
                catch (Exception e)
                {
                    new Warning("File '" + realPathAndFilename + "' seems blocked. Retrying... (" + (i * gap) + " seconds)");
                    Thread.Sleep(gap * 1000);  //1 seconds
                    continue;
                }
                break;
            }
            if (fs == null)
            {
                new Error("Gave up on file '" + realPathAndFilename + "'. Is it blocked by another program?");
            }
            return fs;
        }

        private static void PossibleLibraryOrZipWriteError(string pathAndFilename, string s)
        {
            if (pathAndFilename == null) return;

            if (pathAndFilename.StartsWith(Globals.libraryDriveCheatString))
            {
                //Trying to write to a file inside a zip folder (like for instance #(listfile lib1:m.lst) = a, b, c;
                //In that case, the file will look like "library___name___lib1:\m.lst".
                using (Error txt = new Error())
                {
                    txt.MainAdd("You cannot " + s + " the file '" + O.RemoveLibraryCheatString(pathAndFilename) + "'.");
                    txt.MainAdd("Files inside zip files (for instance inside libraries) are considered read-only.");
                }
            }

            if (G.ContainsZipPath(pathAndFilename))
            {
                //a zip path
                using (Error txt = new Error())
                {
                    txt.MainAdd("You cannot " + s + " the file '" + O.RemoveLibraryCheatString(pathAndFilename) + "'.");
                    txt.MainAdd("Files inside zip files (for instance inside libraries) are considered read-only.");
                }
            }
        }

        private static bool IsLibraryWithColonName(string pathAndFilename)
        {
            if (pathAndFilename.StartsWith(Globals.libraryDriveCheatString)) return true;
            return false;
        }

        public static void WaitForFileCopy(string pathAndFilenameSource, string pathAndFilenameDestination)
        {
            WaitForFileCopyDeleteAbstract(pathAndFilenameSource, pathAndFilenameDestination, "copy");
        }

        public static void WaitForFileDelete(string pathAndFilenameSource)
        {
            WaitForFileCopyDeleteAbstract(pathAndFilenameSource, null, "delete");
        }

        private static void WaitForFileCopyDeleteAbstract(string pathAndFilenameSource, string pathAndFilenameDestination, string type)
        {
            PossibleLibraryOrZipWriteError(pathAndFilenameDestination, type);

            if (!(type == "copy" || type == "delete"))
            {
                new Error("Internal Gekko error #837432");
            }

            string dir = Path.GetDirectoryName(pathAndFilenameDestination);
            if (type == "copy" && !Directory.Exists(dir))
            {
                new Error("The folder " + dir + " does not exist for file copying");
            }

            int gap = Globals.waitFileGap;  //2 second
            int totalTime = Globals.waitFileTotalTime;  //600 seconds
            int repeats = totalTime / gap;
            bool success = false;

            for (int i = 0; i < repeats; i++)
            {
                if (Globals.threadIsInProcessOfAborting && !Globals.applicationIsInProcessOfAborting) throw new GekkoException();

                string pathName = Path.GetDirectoryName(pathAndFilenameSource);

                //checking if the file is there at all
                if (!File.Exists(pathAndFilenameSource))
                {
                    using (Error e = new Error())
                    {
                        e.MainAdd("Could not find file '" + pathAndFilenameSource + "' (for " + type + "). ");
                        if (!Directory.Exists(pathName)) e.MainAdd("The directory '" + pathName + "' does not seem to exist.");
                    }
                }

                success = true;
                try
                {
                    if (type == "copy")
                    {
                        File.Copy(pathAndFilenameSource, pathAndFilenameDestination, true);
                    }
                    else if (type == "delete")
                    {
                        File.Delete(pathAndFilenameSource);
                    }
                }
                catch (Exception e)
                {
                    success = false;
                    if (type == "copy")
                    {
                        new Warning("File '" + pathAndFilenameSource + "' or '" + pathAndFilenameDestination + "'seems blocked. Retrying... (" + (i * gap) + " seconds)");
                    }
                    else if (type == "delete")
                    {
                        new Warning("File '" + pathAndFilenameSource + "' seems blocked. Retrying... (" + (i * gap) + " seconds)");
                    }
                    System.Threading.Thread.Sleep(gap * 1000);  //1 seconds
                    continue;
                }
                break;
            }
            if (success == false)
            {
                if (type == "copy")
                {
                    new Error("Gave up on copying '" + pathAndFilenameSource + "' to '" + pathAndFilenameDestination + "'. Is one of these files opened/blocked by another program?");
                }
                else if (type == "delete")
                {
                    new Error("Gave up on deleting file '" + pathAndFilenameSource + "'. Is it opened/blocked by another program?");
                }
                //throw new GekkoException();
            }
            return;
        }

        private static int CsvPrnWrite(List<ToFrom> vars, string filename, GekkoTime per1, GekkoTime per2, EdataFormat dateFormat, bool cols, string dateformat)
        {

            bool isFirst = true;
            string format = SplitDateFormatInTwo(dateformat, ref isFirst);

            int prnWidth = 20;

            int i = 1;
            int j = 1;
            TableLight tab = new TableLight();

            if (dateFormat == EdataFormat.Csv)
            {
                G.Writeln2("Writing csv file for the period " + G.FromDateToString(per1) + "-" + G.FromDateToString(per2));
                filename = G.AddExtension(filename, ".csv");
            }
            else if (dateFormat == EdataFormat.Prn)
            {
                G.Writeln2("Writing prn file for the period " + G.FromDateToString(per1) + "-" + G.FromDateToString(per2));
                filename = G.AddExtension(filename, ".prn");
            }

            string pathAndFilename = CreateFullPathAndFileName(filename);
            int counter = 0;
            if (true)
            {
                //Writing to csv/prn file                              

                if (dateFormat == EdataFormat.Prn)
                {
                    //file.Write(G.varFormat("name", prnWidth));

                    if (cols)
                    {
                        tab.Add(i, j, new CellLight(G.varFormat("date", prnWidth))); j++;
                    }
                    else
                    {
                        tab.Add(i, j, new CellLight(G.varFormat("name", prnWidth))); j++;
                    }
                }
                else
                {
                    tab.Add(i, j, new CellLight("")); j++;  //empty cell
                }
                foreach (GekkoTime t in new GekkoTimeIterator(per1, per2))
                {

                    if (dateFormat == EdataFormat.Csv)
                    {
                        string dateStringCsv = null;
                        if (IsGekkoDateFormat(format))
                        {
                            dateStringCsv = t.ToString();
                        }
                        else
                        {
                            DateTime dt; string f; GekkoTime.FromGekkoTimeToDifferentFormatsForWriting(t, isFirst, format, out dt, out f, out dateStringCsv);
                        }
                        tab.Add(i, j, new CellLight(dateStringCsv)); j++;
                    }
                    else
                    {
                        tab.Add(i, j, new CellLight(G.varFormat(" " + t.ToString(), prnWidth))); j++;
                    }
                }

                i++;

                foreach (ToFrom var in vars)
                {
                    j = 1;
                    string s3 = G.Chop_GetName(var.s2);  //If for instance export <csv> fy* file = test; the .s2 will be varnames with first bank glued on (typically work), and this bank is removed here.

                    IVariable iv = O.GetIVariableFromString(var.s1, O.ECreatePossibilities.NoneReportError, true);
                    Series ts = iv as Series;

                    GekkoTime tsStart = ts.GetPeriodFirst();
                    GekkoTime tsEnd = ts.GetPeriodLast();

                    counter++;
                    if (dateFormat == EdataFormat.Csv)
                    {
                        tab.Add(i, j, new CellLight(s3)); j++;
                    }
                    else
                    {
                        tab.Add(i, j, new CellLight(G.varFormat(s3, prnWidth))); j++;
                    }
                    foreach (GekkoTime t in new GekkoTimeIterator(per1, per2))
                    {
                        double data = ts.GetDataSimple(t);  //no lag or anything here, smpl can be null...?
                        if (G.isNumericalError(data))
                        {
                            if (t.StrictlySmallerThan(tsStart) || t.StrictlyLargerThan(tsEnd))
                            {
                                if (dateFormat == EdataFormat.Csv)
                                {
                                    //write nothing, indicates out-of-sample
                                    tab.Add(i, j, new CellLight("")); j++;
                                }
                                else
                                {
                                    //"", indicates out-of-sample
                                    tab.Add(i, j, new CellLight(G.varFormat(" \"\"", prnWidth))); j++;
                                }
                            }
                            else
                            {
                                string s = HandleFunnyNumbers(dateFormat == EdataFormat.Csv);
                                if (dateFormat == EdataFormat.Csv)
                                {
                                    tab.Add(i, j, new CellLight(s)); j++;
                                }
                                else
                                {
                                    tab.Add(i, j, new CellLight(G.varFormat(s, prnWidth))); j++;
                                }
                            }
                        }
                        else
                        {
                            string s = null;

                            bool fixProblem = true;

                            if (fixProblem)
                            {
                                s = data.ToString();
                                if (Program.options.interface_csv_ndec < 20)
                                {
                                    s = Program.NumberFormat(data, "f" + Program.options.interface_csv_ndec);
                                }
                                if (G.Equal(Program.options.interface_csv_decimalseparator, "period"))
                                {
                                    //ok                                        
                                }
                                else if (G.Equal(Program.options.interface_csv_decimalseparator, "comma"))
                                {
                                    s = s.Replace(".", ",");
                                }
                                else
                                {
                                    new Error("#8423824: Unknown decimalseparator");
                                }
                            }
                            else
                            {
                                if (G.Equal(Program.options.interface_csv_decimalseparator, "period"))
                                {

                                    {
                                        //The 0:... is alignment inside a field.
                                        s = string.Format(System.Globalization.CultureInfo.InvariantCulture, "{0:0.0000000000E+00}", data);
                                    }
                                }
                                else if (G.Equal(Program.options.interface_csv_decimalseparator, "comma"))
                                {
                                    NumberFormatInfo nfi = new NumberFormatInfo();
                                    nfi.NumberDecimalSeparator = ",";

                                    {
                                        s = string.Format(nfi, "{0:0.0000000000E+00}", data);
                                    }
                                }
                                else
                                {
                                    new Error("#8423824: Unknown decimalseparator");
                                }
                            }


                            if (dateFormat == EdataFormat.Csv)
                            {
                                tab.Add(i, j, new CellLight(s)); j++;
                            }
                            else
                            {
                                //prn and gnuplot
                                if (data < 0)
                                {
                                    tab.Add(i, j, new CellLight(G.varFormat(" " + s, prnWidth))); j++;
                                }
                                else
                                {
                                    tab.Add(i, j, new CellLight(G.varFormat("  " + s, prnWidth))); j++;
                                }
                            }
                        }
                    }

                    i++;
                }

            }

            if (cols)
            {
                tab = tab.Transpose();
            }

            string csvDelimiter = ";";
            if (G.Equal(Program.options.interface_csv_delimiter, "comma")) csvDelimiter = ",";

            if (G.Equal(Program.options.interface_csv_delimiter, "comma") && G.Equal(Program.options.interface_csv_decimalseparator, "comma"))
            {
                new Warning("Using comma both as decimal separator and field delimiter is not advised");
            }

            using (FileStream fs = WaitForFileStream(pathAndFilename, null, GekkoFileReadOrWrite.Write))
            using (StreamWriter file = G.GekkoStreamWriter(fs))
            {
                for (int ii = 1; ii <= tab.GetRowMaxNumber(); ii++)
                {
                    if (ii == 1 && cols && dateFormat == EdataFormat.Prn) file.Write(" ");  //strange that this is necessary
                    for (int jj = 1; jj <= tab.GetColMaxNumber(); jj++)
                    {
                        CellLight c = tab.Get(ii, jj);
                        if (c.type == ECellLightType.None) continue;  //skip
                        if (dateFormat == EdataFormat.Csv)
                        {
                            if (jj > 1) file.Write(csvDelimiter);
                            file.Write(c.text);
                        }
                        else
                        {
                            file.Write(c.text);
                        }
                    }
                    file.WriteLine();
                }
                file.Flush();
            }

            G.Writeln("Wrote " + counter + " variables to " + pathAndFilename);

            return counter;
        }



        private static void GetDatabankPeriodFilteredForFreq(List<ToFrom> vars, ref GekkoTime per1, ref GekkoTime per2)
        {
            //Databank first = Program.databanks.GetFirst();
            //vars: annual is fy, quarterly is fy%q, monthly is fy%m, undated is fy%u
            int start = int.MaxValue;
            int end = int.MinValue;
            foreach (ToFrom s in vars)
            {
                IVariable iv = O.GetIVariableFromString(s.s1, O.ECreatePossibilities.NoneReportError, true);
                if (iv.Type() != EVariableType.Series) continue;  //should never happen                
                Series ts = (Series)iv;
                if (ts.type != ESeriesType.Normal) continue;

                start = G.GekkoMin(start, ts.GetPeriodFirst().super);
                end = G.GekkoMax(end, ts.GetPeriodLast().super);
            }
            GetLowerFreqsFromYears(ref per1, ref per2, start, end);
        }

        private static Databank GetBankFromBankNameVersion(string bankName)
        {
            Databank db = null;
            if (bankName == null) db = Program.databanks.GetFirst();
            else db = Program.databanks.GetDatabank(bankName);
            if (db == null)
            {
                new Error("Databank '" + bankName + "' not found");
                //throw new GekkoException();
            }
            return db;
        }

        /// <summary>
        /// Used for databank period
        /// </summary>
        private static void GetLowerFreqsFromYears(ref GekkoTime per1, ref GekkoTime per2, int yearStart, int yearEnd)
        {
            //========================================================================================================
            //                          FREQUENCY LOCATION, indicates where to implement more frequencies
            //========================================================================================================

            //see also #980432
            if ((Program.options.freq == EFreq.A))
            {
                per1 = new GekkoTime((Program.options.freq), yearStart, 1);
                per2 = new GekkoTime((Program.options.freq), yearEnd, 1);
            }
            else if ((Program.options.freq == EFreq.Q))
            {
                per1 = new GekkoTime((Program.options.freq), yearStart, 1);
                per2 = new GekkoTime((Program.options.freq), yearEnd, 4);
            }
            else if ((Program.options.freq == EFreq.M))
            {
                per1 = new GekkoTime((Program.options.freq), yearStart, 1);
                per2 = new GekkoTime((Program.options.freq), yearEnd, 12);
            }
            else if ((Program.options.freq == EFreq.W))
            {
                per1 = ISOWeek.ToGekkoTime(new DateTime(yearStart, 1, 1));
                per2 = ISOWeek.ToGekkoTime(new DateTime(yearEnd, 12, 31));
            }
            else if ((Program.options.freq == EFreq.D))
            {
                per1 = new GekkoTime((Program.options.freq), yearStart, 1, 1);
                per2 = new GekkoTime((Program.options.freq), yearEnd, 12, 31);
            }
        }

        private static int GnuplotWrite(List<ToFrom> vars, string filename, GekkoTime per1, GekkoTime per2)
        {
            int prnWidth = 18;
            //Databank first = Program.databanks.GetFirst();

            G.Writeln2("Writing gnuplot file for the period " + G.FromDateToString(per1) + "-" + G.FromDateToString(per2));
            filename = G.AddExtension(filename, ".dat");

            string pathAndFilename = CreateFullPathAndFileName(filename);
            int counter = 0;
            using (FileStream fs = WaitForFileStream(pathAndFilename, null, GekkoFileReadOrWrite.Write))
            using (StreamWriter file = G.GekkoStreamWriter(fs))
            {
                //Writing to csv/prn file

                file.Write("# " + G.Blanks(prnWidth));  //comment
                foreach (ToFrom var in vars)
                {
                    //string s3 = var.name;
                    //Databank db = GetBankFromBankNameVersion(var.bank);
                    //Series ts = db.GetVariable(s3); //#getvar
                    IVariable iv = O.GetIVariableFromString(var.s1, O.ECreatePossibilities.NoneReportError, true);
                    Series ts = iv as Series;
                    if (ts == null)
                    {
                        new Error("Variable '" + var.s1 + "' is of wrong type");
                        //throw new GekkoException();
                    }
                    file.Write(G.varFormat(G.Chop_GetName(var.s2), prnWidth));  //prn and gnuplot
                }
                file.WriteLine();

                foreach (GekkoTime t in new GekkoTimeIterator(per1, per2))
                {
                    file.Write(GetDateStringSuitableForGnuplot(t.ToString()) + " ");
                    foreach (ToFrom var in vars)
                    {
                        //string s3 = var.name;
                        //Databank db = GetBankFromBankNameVersion(var.bank);
                        //Series ts = db.GetVariable(s3);  //existence has been checked //#getvar

                        IVariable iv = O.GetIVariableFromString(var.s1, O.ECreatePossibilities.NoneReportError, true);
                        Series ts = iv as Series;

                        double data = ts.GetDataSimple(t);
                        if (G.isNumericalError(data))
                        {
                            file.Write("NaN");
                        }
                        else
                        {
                            string s = string.Format(System.Globalization.CultureInfo.InvariantCulture, "{0:0.0000000000E+00}", data);
                            if (data < 0) file.Write(G.varFormat(s, prnWidth));
                            else file.Write(G.varFormat(" " + s, prnWidth));
                        }
                    }
                    file.WriteLine();
                }
                file.Flush();
            }

            G.Writeln("Wrote " + vars.Count + " variables to " + pathAndFilename);

            return vars.Count;
        }

        private static string HandleFunnyNumbers(bool isCsv)
        {
            string s = "";
            if (isCsv)
            {
                if (G.Equal(Program.options.interface_excel_language, "danish"))
                {
                    s = "#NAVN?";  //missing value indicator (M) -- SHEET uses na()
                }
                else
                {
                    s = "#NAME?";  //missing value indicator (M) -- SHEET uses na()
                }
            }
            else
            {
                s = " 1.0e+15";
            }
            return s;
        }

        private static int Tspwrite(List<ToFrom> vars, string filename, GekkoTime per1, GekkoTime per2, bool isCaps)
        {
            //Databank work = Program.databanks.GetFirst();
            filename = filename;
            filename = G.AddExtension(filename, ".tsp");
            string pathAndFilename = CreateFullPathAndFileName(filename);
            int counter = 0;
            using (FileStream fs = WaitForFileStream(pathAndFilename, null, GekkoFileReadOrWrite.Write))
            using (StreamWriter file = G.GekkoStreamWriter(fs))
            {
                string fileName = Path.GetFileName(pathAndFilename);
                file.WriteLine("? This file is produced by Gekko, and contains " + vars.Count + " LOAD-statements with data.");
                file.WriteLine("? You may INPUT this file in your TSP program, but for large datasets it");
                file.WriteLine("? may be better to create a TSP databank (.tlb).");
                file.WriteLine("? To do this, you may try the following statements:");
                file.WriteLine("?");
                file.WriteLine("?   options memory = 1000; ? 1000 MB");
                file.WriteLine("?   out mybankname;");
                file.WriteLine("?   input " + fileName + ";");
                file.WriteLine("?");
                file.WriteLine("? However, there seems to be a limit to the number of lines in a .tsp file,");
                file.WriteLine("? so you may have to split " + fileName + " into several files if it is large.");
                file.WriteLine("? NOTE: if the TSP databank (above: 'mybankname.tlb') already exists, you should delete");
                file.WriteLine("? it first -- otherwise any variables/data in the already existing .tlb file will");
                file.WriteLine("? stay in the file.");
                file.WriteLine();
                file.WriteLine();
                file.WriteLine("freq a;");
                file.WriteLine();
                foreach (ToFrom var in vars)
                {
                    //Databank db = GetBankFromBankNameVersion(var.bank);                    
                    //Series ts = db.GetVariable(var.name);  //#getvar

                    IVariable iv = O.GetIVariableFromString(var.s1, O.ECreatePossibilities.NoneReportError, true);
                    Series ts = iv as Series;

                    if (ts == null)
                    {
                        //TODO: check this beforehand, and do a msgbox with all missing vars (a la when doing sim)
                        new Error("Writing tsp file: variable " + var.s1 + " does not exist");
                        //throw new GekkoException();
                    }
                    WriteTspRecord(per1, per2, file, ts, var.s2, isCaps);
                    counter++;
                }
                file.Flush();
            }

            if (true) G.Writeln("Wrote " + counter + " variables to " + pathAndFilename);
            return counter;
        }


        //============================================================================================
        //============================================================================================
        //============================================================================================


        /// <summary>
        /// Finds time series in data bank.
        /// </summary>
        /// <param name="databank">The databank</param>
        /// <param name="varName">The variable name</param>
        /// <returns></returns>
        public static Series FindOrCreateTimeSeriesInDataBank(Databank databank, string varName, EFreq frequency)
        {
            //This auto-creates timeseries for use when reading for example tsd or PCIM files
            //Has an overload used for UPD statements etc.
            Series ts = null;

            string varName2 = G.Chop_AddFreq(varName, frequency);

            //string varName2 = Program.AddFreqAtEndOfVariableName(varName, frequency);

            if (!databank.ContainsIVariable(varName2))
            {
                ts = new Series(frequency, varName2);
                databank.AddIVariable(varName2, ts);
            }
            else
            {
                ts = databank.GetIVariable(varName2, true) as Series;
            }
            return ts;
        }

        public static void Cut(bool print)
        {
            Gui.CloseAllDecompUdvalg(print);
        }



        public static string HandleNewlines(string arg)
        {
            return arg.Replace("\\n", "\n");
        }

        public static void Clear(O.Clear o, P p)
        {
            //Take care with filename, when clearing: only wipe it out if it is Work or Ref banks, other banks may be OPENed banks that we would like to write back to when CLOSEing

            List<string> names = O.Restrict(o.names, false, false, false, false);

            if (names == null)
            {
                if (G.Equal(o.opt_first, "yes"))
                {
                    Program.databanks.GetFirst().Clear();
                    if (Program.databanks.GetFirst().name == Globals.Work || Program.databanks.GetFirst().name == Globals.Ref) { Program.databanks.GetFirst().FileNameWithPath = null; Program.databanks.GetFirst().FileNameWithPathPretty = null; }
                    G.Writeln2("Cleared first databank ('" + Program.databanks.GetFirst().name + "')");
                }
                if (G.Equal(o.opt_ref, "yes"))
                {
                    Program.databanks.GetRef().Clear();
                    if (Program.databanks.GetRef().name == Globals.Work || Program.databanks.GetRef().name == Globals.Ref) { Program.databanks.GetRef().FileNameWithPath = null; Program.databanks.GetRef().FileNameWithPathPretty = null; }
                    G.Writeln2("Cleared ref databank ('" + Program.databanks.GetRef().name + "')");
                }

                if (!G.Equal(o.opt_first, "yes") && !G.Equal(o.opt_ref, "yes"))
                {
                    //Before: Cleared 'Work' and 'Ref' regardless of position
                    Program.databanks.GetFirst().Clear();
                    Program.databanks.GetRef().Clear();
                    if (Program.databanks.GetFirst().name == Globals.Work || Program.databanks.GetFirst().name == Globals.Ref) { Program.databanks.GetFirst().FileNameWithPath = null; Program.databanks.GetFirst().FileNameWithPathPretty = null; }
                    if (Program.databanks.GetRef().name == Globals.Work || Program.databanks.GetRef().name == Globals.Ref) { Program.databanks.GetRef().FileNameWithPath = null; Program.databanks.GetRef().FileNameWithPathPretty = null; }
                    G.Writeln2("Cleared first and ref databanks ('" + Program.databanks.GetFirst().name + "' and '" + Program.databanks.GetRef().name + "')");
                }
            }
            else
            {

                foreach (string name in names)
                {

                    if (o.names != null && (o.opt_first != null || o.opt_ref != null))
                    {
                        new Error("You should use 'CLEAR<first>;' or  'CLEAR<ref>;'");
                        //throw new GekkoException();
                    }

                    if (o.names != null)
                    {
                        if (Program.databanks.GetDatabank(name) == null)
                        {
                            new Error("Trying to clear non-existing databank '" + name + "'");
                            //throw new GekkoException();
                        }

                        Databank db1 = Program.databanks.GetDatabank(name);
                        db1.Clear();
                        if (db1.name == Globals.Work || db1.name == Globals.Ref) { db1.FileNameWithPath = null; db1.FileNameWithPathPretty = null; }
                        G.Writeln2("Cleared databank: " + name);
                    }


                }
            }
        }


        public static void MaybeWriteOpenDatabank(Databank removed)
        {
            if (Program.IsDatabankDirty(removed))
            {
                if (removed.save == false)
                {
                    G.Writeln2("Databank '" + removed.name + "' closed, changes not written to file");
                }
                else if (!removed.editable)
                {
                    new Error("Internal error #872543: a non-editable bank '" + removed.name + "' should not be possible to alter.");                    
                }
                else
                {
                    Program.WriteRemovedDatabank(removed);
                }
            }
        }

        /// <summary>
        /// Reset or Restart. s may be "reset" or "restart" .
        /// </summary>
        /// <param name="smpl"></param>
        /// <param name="s"></param>
        /// <param name="p"></param>
        public static void Re(GekkoSmpl smpl, string s, P p)
        {
            bool ini = false;
            if (s == "restart") ini = true;

            Pipe(null, new List<string>() { "stop" }, true);  //silently (mute) sets output to screen (Gekko might be piping)            

            int w = -12345;
            int b = -12345;
            MaybeWriteOpenDatabanks(ref w, ref b);
            Databank w2 = Program.databanks.storage[w]; w2.Clear();
            Databank b2 = Program.databanks.storage[b]; b2.Clear();
            Program.databanks.storage.Clear();
            Program.databanks.storage.Add(w2);
            Program.databanks.storage.Add(b2);
            Program.databanks.local.Clear();
            Program.databanks.global.Clear();
            Program.databanks.localGlobal = new LocalGlobal();
            w2.FileNameWithPath = null; w2.FileNameWithPathPretty = null;
            b2.FileNameWithPath = null; b2.FileNameWithPathPretty = null;
            Globals.createdVariables.Clear();  //these should maybe live inside work databank

            string resetRestartFirstLine = null;
            string lastCommand = null;
            try
            {
                lastCommand = Globals.commandMemory.storage.ToString().Substring(Globals.commandMemory.lengthWhenLastEnterPressed).Trim();
            }
            catch
            {
                //not the end of the world if it fails
            }

            Globals.commandMemory = new CommandMemory();  //these commands are only remembered up to last clearing of workspace                                                         

            try
            {
                if (lastCommand != null)
                {
                    //this will catch stuff like "restart", "restart;", "restart ;", "restart;time 2020;", etc. (also for "reset").
                    TokenList tokens = StringTokenizer.GetTokensWithLeftBlanks(lastCommand);
                    string firstLower = null;
                    if (tokens.storage.Count > 0 && tokens.storage[0].type == ETokenType.Word) firstLower = tokens.storage[0].s.ToLower();

                    if (firstLower == "reset" || firstLower == "restart")
                    {
                        //We insert a reset/restart as if it had been entered by hand.
                        Globals.commandMemory.storage.AppendLine(lastCommand);
                        Globals.commandMemory.lengthWhenLastEnterPressed = Globals.commandMemory.storage.ToString().Length;
                    }
                }
            }
            catch
            {
                //not the end of the world if it fails
            }

            //User functions: more can be added if necessary, or users can use LIST or DICT.
            InitUfunctionsAndArithmeticsAndMore();

            Globals.printStorageAsFunc = new Dictionary<int, Func<GraphHelper, string>>();

            Program.model = new Model();

            Globals.modelFileName = "";
            GuiSetModelName();

            string workingFolder = Program.options.folder_working;
            Program.options = new Options();  //resetting these, but letting working folder live on.            

            CrossThreadStuff.Mode();  //to show default color

            Program.GetStartingPeriod();
            O.InitSmpl(smpl, p);  //Uses the method above. Just for ultra-safety, so that the smpl does not live on unadjusted after af RESET/RESTART

            Globals.globalPeriodTimeSpans = new GekkoTimeSpans();  //Probably not used anymore
            Globals.globalPeriodTimeFilters = new GekkoTimeSpans();  //nothing in .data yet.
            Globals.globalPeriodTimeFilters2 = new List<GekkoTime>();

            Globals.detectedRPath = null;  //we reset this, too
            Globals.r_fileContent = null;

            Program.alias = null;

            if (workingFolder != null && workingFolder != "")
            {
                Program.options.folder_working = workingFolder;
            }
            Globals.lastPrtOrMulprtTable = null;
            CrossThreadStuff.CopyButtonEnabled(false);
            //Globals.hasBeenTsdTsdxOptionChangeSinceLastClear = false;  //this logic can be removed in a couple of years (maybe in 2015)
            G.Writeln();
            G.Writeln("Clearing options, databanks, models, scalars, lists, collections and procedures/functions");
            if (ini) G.Writeln("INI files ('" + Globals.autoExecCmdFileName + "') will be run");
            else G.Writeln("No INI files ('" + Globals.autoExecCmdFileName + "') will be run");
            G.Writeln("Use CLS to clear the output window, and CUT to close plot/decomp windows.");
            if (ini)
            {
                G.Writeln();
                O.Ini(p);
            }
            try
            {
                CrossThreadStuff.RestartMenuBrowser();
            }
            catch
            {
                //no need for this to fail badly...
            }
            Globals.guiHomeMainEnabled = false;
            Program.guiBrowseHistory.Clear();
            Program.guiBrowseNumber = 0;
            Globals.guiHomeMenuEnabled = false;

            Globals.expressionText = null;
            Globals.expression = null;
            Globals.expressions = null;
            //Globals.freeIndexedListsDecomp = null;



            RemoteInit();

            StartPulse();
        }

        /// <summary>
        /// Initialization for Gekko, but also for unit tests, and probably also Gekcel.
        /// So stuff that gets set up at start should be here.
        /// </summary>
        public static void InitUfunctionsAndArithmeticsAndMore()
        {
            Program.libraries = new Libraries();

            Globals.arithmentics[0] = (x1, x2) => x1 + x2;
            Globals.arithmentics[1] = (x1, x2) => x2 + x1;
            Globals.arithmentics[2] = (x1, x2) => x1 - x2;
            Globals.arithmentics[3] = (x1, x2) => x2 - x1;
            Globals.arithmentics[4] = (x1, x2) => x1 * x2;
            Globals.arithmentics[5] = (x1, x2) => x2 * x1;
            Globals.arithmentics[6] = (x1, x2) => x1 / x2;
            Globals.arithmentics[7] = (x1, x2) => x2 / x1;
            Globals.arithmentics[8] = (x1, x2) => Math.Pow(x1, x2);
            Globals.arithmentics[9] = (x1, x2) => Math.Pow(x2, x1);
            Globals.arithmentics[10] = (x1, x2) => (x1 / x2 - 1d) * 100d;
            Globals.arithmentics[11] = (x1, x2) => Math.Log(x1 / x2);
            Globals.arithmentics[12] = (x1, x2) => Math.Round(x1, (int)x2, MidpointRounding.AwayFromZero);

            Globals.arithmentics1[0] = (x1) => -x1;
            Globals.arithmentics1[1] = (x1) => Math.Abs(x1);
            Globals.arithmentics1[2] = (x1) => Math.Log(x1);
            Globals.arithmentics1[3] = (x1) => Math.Exp(x1);
            Globals.arithmentics1[4] = (x1) => Math.Sqrt(x1);
            Globals.arithmentics1[5] = (x1) => Math.Truncate(x1); //same as (int)x1, but handles larger numbers 
            Globals.arithmentics1[6] = (x1) => Math.Floor(x1); //floor(-1.5) = -2, truncate(-1.5) = -1
            Globals.arithmentics1[7] = (x1) => Math.Ceiling(x1); //see above.
            Globals.arithmentics1[8] = (x1) => Math.Tanh(x1);  //hyperbolic tangens

            Globals.timeStrings = new string[Globals.timeStringsEnd - Globals.timeStringsStart + 1];
            for (int i = Globals.timeStringsStart; i <= Globals.timeStringsEnd; i++)
            {
                Globals.timeStrings[i - Globals.timeStringsStart] = i.ToString();
            }

            try
            {
                //used for 
                Program.CreateTempFilesFolder2();
            }
            catch { }; //fail silently
        }

        public static List<string> Add2Lists(List<string> x1, List<string> x2)
        {
            List<string> x = new List<string>();
            x.AddRange(x1);
            x.AddRange(x2);
            return x;
        }

        public static void RemoteInit()
        {
            try
            {
                Globals.remoteFileStamp = new DateTime(0l);  //fresh init of this
                Globals.remoteIsInvestigating = false;  //fresh init of this
                Globals.remoteExists = -12345; //unknown
            }
            catch { }  //kind of ok if it fails
        }

        public static void StartPulse()
        {
            //Pulse (for remote.gcm)
            Globals.guiTimerCounter2 = 0;
            if (Globals.guiTimer2 == null)
            {
                Globals.guiTimer2 = new System.Timers.Timer();
                Globals.guiTimer2.Elapsed += new System.Timers.ElapsedEventHandler(OnTimedEvent2);
                Globals.guiTimer2.Interval = 200;  //every 0.2 s
            }
            Globals.guiTimer2.Stop();
            Globals.guiTimer2.Start();
        }

        private static void OnTimedEvent2(object source, System.Timers.ElapsedEventArgs e)
        {
            CrossThreadStuff.Pulse();
        }

        /// <summary>
        /// Finds built in functions. Does not need to be GekkoDictionary
        /// </summary>
        /// <returns></returns>
        public static Dictionary<string, string> FindGekkoInbuiltFunctions()
        {
            Dictionary<string, string> gekkoBuiltInFunctions = new Dictionary<string, string>();
            Type myType = (typeof(Functions));
            MethodInfo[] myArrayMethodInfo = myType.GetMethods(BindingFlags.Public | BindingFlags.Static | BindingFlags.DeclaredOnly);
            for (int i = 0; i < myArrayMethodInfo.Length; i++)
            {
                MethodInfo myMethodInfo = (MethodInfo)myArrayMethodInfo[i];
                string name = myMethodInfo.Name.ToLower();  //should be superfluous
                string meta = null;
                object[] metaInfo = myMethodInfo.GetCustomAttributes(false);
                if (metaInfo.Length > 0) meta = ((MyCustomAttribute)(metaInfo[0])).Lag;

                //if(name.ToLower().Contains("helper_error"))
                //{

                //}

                if (name.StartsWith("HELPER_", StringComparison.OrdinalIgnoreCase) && !G.Equal(name, "HELPER_error"))
                {
                    //keep helper_error(), which is used for unit tests.
                    //but discard all other helper_... functions.
                }
                else
                {
                    if (!gekkoBuiltInFunctions.ContainsKey(name))
                    {
                        gekkoBuiltInFunctions.Add(name, meta);  //meta contains info on lags etc.         
                    }
                }
            }

            gekkoBuiltInFunctions.Add("string", null); //%s = string(1) is translated into tostring() since string() function is not allowed in C#.

            return gekkoBuiltInFunctions;
        }

        public static void MaybeWriteOpenDatabanks(ref int w, ref int b)
        {
            for (int i = 0; i < Program.databanks.storage.Count; i++)
            {
                //The avoids creating new databanks, better to keep the original ones and switch their places.
                if (G.Equal(Program.databanks.storage[i].name, Globals.Work)) w = i;
                else if (G.Equal(Program.databanks.storage[i].name, Globals.Ref)) b = i;
                else
                {
                    MaybeWriteOpenDatabank(Program.databanks.storage[i]);
                }
            }
        }

        public static void WriteRemovedDatabank(Databank removed)
        {
            if (removed == null) return;  //See TKD mail 6/6 2016, this should not be possible, but just in case
            if (removed.FileNameWithPath == null) return; //See TKD mail 6/6 2016, this should not be possible, but just in case
            bool skipWrite = false;
            GekkoTime tStart = GekkoTime.tNull;
            GekkoTime tEnd = GekkoTime.tNull;
            if (!removed.FileNameWithPath.EndsWith("." + Globals.extensionDatabank + ""))
            {
                string fn5 = Path.GetFileName(removed.FileNameWithPath);
                if (fn5.StartsWith(Globals.tempFileStart) && fn5.EndsWith(Globals.tempFileEnd))
                {
                    //a temp file representing a file unzipped from a zip file.
                    using (Error e = new Error())
                    {
                        e.MainAdd("The databank '" + removed.name + "' was opened from inside a zip file ('" + removed.FileNameWithPathPretty + "').");
                        e.MainAdd("The databank has been altered, but the changes cannot be written back to the zip file, ");
                        e.MainAdd("because such zip files are considered read-only.");
                        e.MainAdd("(If the databank was opened with OPEN<edit>, you may use WRITE to write the ");
                        e.MainAdd("databank to a normal file).");
                    }
                }
                else
                {
                    using (Error e = new Error())
                    {
                        e.MainAdd("The databank '" + removed.name + "' was opened with the OPEN command.");
                        e.MainAdd("It has been altered, but the changes cannot be written back to the");
                        e.MainAdd("underlying databank file, since this file is not a " + Globals.extensionDatabank + " file.");
                        e.MainAdd("(If the databank was opened with OPEN<edit>, you may use WRITE to write the ");
                        e.MainAdd("databank to a file).");
                    }
                }
            }
            if (true)
            {
                if (removed.fileHash == null)
                {
                    //do nothing, fileHashing is probably not active
                }
                else if (removed.fileHash == Globals.brandNewFile)
                {
                    if (File.Exists(removed.FileNameWithPath))
                    {
                        MessageBox.Show("*** ERROR: The databank file '" + removed.FileNameWithPath + "' did not exist when opening it,\nbut seems to exist as a file now. \nHence, Gekko cannot write the databank to file -- \nplease consider to run your code again.");
                        skipWrite = true;
                    }
                }
                else
                {
                    string trueFileHash = Program.GetMD5Hash(GetTextFromFileWithWait(removed.FileNameWithPath), null, null);
                    if (!(trueFileHash == removed.fileHash))
                    {
                        MessageBox.Show("*** ERROR: The databank file '" + removed.FileNameWithPath + "' seems to have changed since opening it. \nHence, Gekko cannot write the databank to file -- \nplease consider to run your code again.");
                        skipWrite = true;
                    }
                }
            }
            int n = 0;
            if (!skipWrite) n = WriteGbk(removed, tStart, tEnd, removed.FileNameWithPath, false, null, "" + Globals.extensionDatabank + "", true, true);
        }

        public static string ErrorHandling(string s, P p, bool noWindowShown)
        {
            if (Globals.threadIsInProcessOfAborting)
            {
                p.hasShownErrorHandling = EHasShownErrorHandling.True;  //to make the command files 'Fail' in status window.
                return "stop";
            }
            if (G.IsUnitTesting()) return "stop";

            if (!p.hasBeenCmdFile) return "stop";

            if (s == null) s = "";

            string type = "stop";

            if (p.canShowErrorDialog == true || s == "parser_islooping")  //show only 1 time, unless parsing-looping
            {
                p.hasShownErrorHandling = EHasShownErrorHandling.True;
                Window2 w = new Window2();
                w.p = p;
                if (s == "runtime")
                {
                    int lineNumber5;
                    string fileCalled5;
                    string commandText5;
                    List<string> commandLines5;
                    GetErrorLineAndText(p, p.GetDepth(), out lineNumber5, out fileCalled5, out commandLines5);

                    if (p.hasBeenCompilationError)
                    {
                        //this is shown somewhere else                        
                    }
                    else
                    {
                        int ln = lineNumber5;

                        commandText5 = "";
                        string text = "";
                        if (ln <= 0)
                        {
                            //this should not happen any more, after fix regarding token line numbers (2/9 2012)
                            text = "*** ERROR: " + "Running file " + fileCalled5 + ", line [unknown]";
                            commandText5 = "";
                        }
                        else
                        {
                            text = "*** ERROR: " + "Running file " + fileCalled5 + ", line " + ln;
                            commandText5 = commandLines5[ln - 1];
                        }
                        WriteErrorMessage(ln, commandText5, text, fileCalled5);
                    }

                    WriteCallStack(false, p);

                    w.textBox1.Text = "*** ERROR: Run-time error.";
                    w.textBox1.Text += "\n";
                    w.textBox1.Text += "\n";
                    w.textBox1.Text += "Gekko encountered a run-time error while trying to execute a command line (cf. the Gekko output window). You may stop the program execution ('Stop'), ";
                    w.textBox1.Text += "or try to skip the problematic line ('Skip line')." + "\n" + "\n" + "Skipping a line is usually ok if the line is non-vital for the rest of the program (for instance a print statement), ";
                    w.textBox1.Text += "else you should rerun your program files ('Stop' and run again).";
                    w.textBox1.Text += "\n";
                    w.textBox1.Text += "\n";
                    w.textBox1.Text += "Be warned that skipping these kinds of errors may leave data structures in an inconsistent state, ";
                    w.textBox1.Text += "so when skipping a line, no firm guarantees regarding the results can be issued. (Retrying the file is not ";
                    w.textBox1.Text += "allowed regarding run-time errors, since some of the lines in the file have already been executed).";

                    w.button2.IsEnabled = false;  //retry
                }
                else if (s == "parser" || s == "parser_islooping")
                {
                    w.textBox1.Text = "*** ERROR: Syntax error.";
                    w.textBox1.Text += "\n";
                    w.textBox1.Text += "\n";
                    w.textBox1.Text += "Gekko encountered a syntax error (cf. the Gekko output window). The problematic command file has not been run (since it could not be parsed), so you may try to fix the error and try again. ";
                    w.textBox1.Text += "\n" + "\n" + "If you fix the syntax error now and click 'Retry file', Gekko will continue executing the system of command files as if no error had happened. (If errors persist, the error dialog will show up again).";
                    w.button3.IsEnabled = false;  //skip

                    WriteCallStack(true, p);
                }
                else MessageBox.Show("Error handling: please report this to the developer");
                try
                {
                    CrossThreadStuff.SetReadOnly(true);
                    MaybePlaySound(p);
                    if (!noWindowShown) w.ShowDialog();  //the window is suppressed when debug = "none" (and not "dialog")
                }
                finally
                {
                    CrossThreadStuff.SetReadOnly(false);
                }
                type = w.type;

                if (noWindowShown) type = "stop";  //for some reason, when window not shown, type becomes "close"

                if (type == "stop") p.canShowErrorDialog = false;
                if (type == "retry") p.canShowErrorDialog = true;
                if (type == "skip")
                {
                    p.canShowErrorDialog = true;
                    p.hasShownErrorHandling = EHasShownErrorHandling.TrueAndAlsoSkippedLines;
                }
            }

            if (type == "skip") Globals.numberOfSkippedLines++;

            return type;
        }

        public static void WriteCallStack(bool syntaxError, P p)
        {
            WriteCallStack(true, syntaxError, p);
        }

        public static List<StackHelper> WriteCallStack(bool print, bool syntaxError, P p)
        {

            List<StackHelper> stackLines = new List<StackHelper>();

            int max = p.GetDepth();
            int limit = 1;
            if (syntaxError || p.hasBeenCompilationError) limit = 0;
            if (max > limit)
            {

                for (int i = 1; i <= max; i++)  //index 0 is not used
                {
                    int lineNumber2;
                    string fileCalled;
                    List<string> commandLines2;
                    GetErrorLineAndText(p, i, out lineNumber2, out fileCalled, out commandLines2);

                    string lineNumber3 = "" + lineNumber2;
                    if (lineNumber2 == 0) lineNumber3 = "[unknown]";

                    if (fileCalled == "")
                    {
                        if (commandLines2.Count == 1)
                        {
                            StackHelper sh = new StackHelper();
                            sh.line = "    " + "Call stack: Command line calling -->";
                            sh.file = "";
                            sh.line2 = lineNumber2;
                            stackLines.Add(sh);
                        }
                        else
                        {
                            StackHelper sh = new StackHelper();
                            sh.line = "    " + "Call stack: Command block line " + lineNumber3 + " calling -->";
                            sh.file = "";
                            sh.line2 = lineNumber2;
                            stackLines.Add(sh);
                        }
                    }
                    else
                    {

                        if (i < max || syntaxError)
                        {
                            StackHelper sh = new StackHelper();
                            sh.line = "    " + fileCalled + " line " + lineNumber3 + " calling -->";
                            sh.file = fileCalled;
                            sh.line2 = lineNumber2;
                            stackLines.Add(sh);
                        }
                        else
                        {
                            StackHelper sh = new StackHelper();

                            string lineNumber4 = lineNumber3;

                            if (p.hasSeenStopCommand > 0)
                            {
                                //
                                // a hack to make STOP line correct
                                //                                
                                int line7 = -12345;
                                int.TryParse(lineNumber3, out line7);
                                if (line7 != -12345)
                                {
                                    line7++;
                                    lineNumber4 = "" + line7;
                                }
                            }

                            sh.line = "    " + fileCalled + " (run-time error in line " + lineNumber4 + ")";
                            sh.file = fileCalled;
                            sh.line2 = lineNumber2;
                            stackLines.Add(sh);
                        }
                    }
                }
                if (syntaxError || p.hasBeenCompilationError)
                {
                    StackHelper sh = new StackHelper();
                    sh.line = "    " + p.lastFileSentToANTLR + " (syntax error)";
                    sh.file = p.lastFileSentToANTLR;
                    stackLines.Add(sh);
                }

                string tablefile = null;
                foreach (StackHelper sh in stackLines)
                {
                    if (sh.file.Contains("tablecode." + Globals.defaultCommandFileExtension))
                    {
                        tablefile = GetOriginalTableFileName(sh.file);
                    }
                }

                if (print)
                {
                    if (tablefile != null)
                    {
                        new Error("Table file failed: " + tablefile, false);
                    }

                    using (var w = new Writeln("    ", int.MaxValue, Color.Gray, true, ETabs.Main))
                    {
                        foreach (StackHelper sh in stackLines)
                        {
                            if (sh.file.Contains("tablecode." + Globals.defaultCommandFileExtension))
                            {
                                string tablefile2 = GetOriginalTableFileName(sh.file);
                                w.MainAdd("    " + tablefile2 + " calling -->");
                                w.MainNewLineTight();
                            }
                            w.MainAdd(sh.line);
                            w.MainNewLineTight();
                        }
                    }

                    G.Writeln();  //hack, we need an extra line
                }
            }
            return stackLines;
        }

        public static void GetErrorLineAndText(P p, int i, out int lineNumber2, out string lineText, out List<string> commandLines)
        {
            //if it is a procedure, command will be something like: "procedure 'test', C:\Thomas\Desktop\gekko\testing\Datopgek3\MAKRO\bug.gcm¤10"
            //if it is a procedure, command will be something like: "function 'test()', C:\Thomas\Desktop\gekko\testing\Datopgek3\MAKRO\bug.gcm¤10"
            //if it is a gcm, command will be something like: "C:\Thomas\Desktop\gekko\testing\Datopgek3\MAKRO\bug.gcm¤12"
            //
            //The start 'procedure ' and 'function' is stable, not likely to be changed. So we can use it to determine if we are inside a procedure/function call

            string command = p.GetStack(i);
            int ii = i - 1;
            if (command.StartsWith("procedure ", StringComparison.OrdinalIgnoreCase) || command.StartsWith("function ", StringComparison.OrdinalIgnoreCase))
            {
                ii--;
            }
            string fileText = "";
            try
            {
                fileText = p.GetStackCommandFileText(ii);
            }
            catch { };
            if (command == null)
            {
                lineText = "[?]";
                lineNumber2 = 0;
            }
            else
            {
                SplitCommandBeingExecuted(out lineText, out lineNumber2, command);
            }
            commandLines = new List<string>();
            commandLines.Add("Unknown file");
            if (fileText != null)
            {
                commandLines = Stringlist.CreateListOfStringsFromFile(fileText);
            }
            if (p.hasSeenStopCommand == 1)
            {
                lineNumber2++;  //else it reports the line before the STOP command                
                p.hasSeenStopCommand = 2;  //no adjustments for callee command files (this is a bit of a hack)
            }
        }

        /// <summary>
        /// Flushes all cache files. I
        /// </summary>
        public static void Flush()
        {
            Flush(true);
        }

        /// <summary>
        /// If hard==true, flushes all cache files. If soft, checks a limit and flushes all cache files if over limit.
        /// </summary>
        /// <param name="hard"></param>
        public static void Flush(bool hard)
        {
            if (hard)
            {
                new Writeln("Deleting/flushing temporary folders: " + System.Windows.Forms.Application.LocalUserAppDataPath);

                FlushHelper();

                if (false)
                {
                    //If we need something like LRU cache, not deleting everything,
                    //the stuff below could be resurrected.

                    string path = "??";

                    try
                    {
                        long sumMax = 1000L * 1000000L;  //1000 MB, if over it is pruned down to 80% of this (800 MB), deleting 200 MB of oldest models/libs
                                                         //1000 MB corresponds to > 120 different large models
                        double fraction = 0.8d;
                        long sum = 0L;

                        FileInfo[] files = new DirectoryInfo(path).GetFiles();

                        List<DateTimeHelper> ddd = new List<DateTimeHelper>();
                        foreach (FileInfo file in files)
                        {
                            if (G.Equal(file.Extension, Globals.cacheExtensionModel) || G.Equal(file.Extension, Globals.cacheExtension))
                            {
                                sum += file.Length;
                                ddd.Add(new DateTimeHelper() { dt = file.LastWriteTime, s = file.FullName, size = file.Length });
                            }
                        }

                        if (sum > sumMax)
                        {
                            ddd.Sort((a, b) => a.dt.CompareTo(b.dt));
                            double temp = (double)sumMax * fraction;  //we crop it some more, so we don't have to delete files for a while (= speedy startup)
                            long tooMuch = sum - (long)(temp);
                            long sum2 = 0L;
                            foreach (DateTimeHelper d in ddd)
                            {
                                sum2 += d.size;
                                File.Delete(d.s);  //best not to use WaitForFileDelete() here, since failure is caught when calling the method (cleanup)                        
                                if (sum2 > tooMuch) break;
                            }
                        }
                    }
                    catch (Exception e)
                    {
                        //fail silently, sometimes the files may be locked temporarily
                    }
                }
            }
            else
            {
                //if soft, flush localTempFilesLocation if localTempFilesLocation > cacheSize4
                long size = CacheFilesSize();
                if (size > Globals.cacheFileMax)
                {
                    FlushHelper();
                    new Writeln("Gekko cache files were deleted because limit of " + G.UpdprtFormat((double)Globals.cacheFileMax / 1000000000d, 2, false) + " GB was exceeded.");
                }
            }
        }

        /// <summary>
        /// In bytes
        /// </summary>
        /// <returns></returns>
        public static long CacheFilesSize()
        {
            long size = DirSize(new DirectoryInfo(Globals.localTempFilesLocation));
            return size;
        }

        /// <summary>
        /// Size of dir including subdirs (in bytes)
        /// </summary>
        public static long DirSize(DirectoryInfo d)
        {
            long size = 0;
            // Add file sizes.
            FileInfo[] fis = d.GetFiles();
            foreach (FileInfo fi in fis)
            {
                size += fi.Length;
            }
            // Add subdirectory sizes.
            DirectoryInfo[] dis = d.GetDirectories();
            foreach (DirectoryInfo di in dis)
            {
                size += DirSize(di);
            }
            return size;
        }

        public static List<string> GetDatabankInfo(StampTypes type)
        {
            Databank work = Program.databanks.GetFirst();
            Databank base2 = Program.databanks.GetRef();
            string workInfo = "";
            if (work != null && work.info1 != null) workInfo = work.info1;
            string base2Info = "";
            if (base2 != null && base2.info1 != null) base2Info = base2.info1;
            string workDate = "";
            if (work != null && work.date != null) workDate = work.date;
            string base2Date = "";
            if (base2 != null && base2.date != null) base2Date = base2.date;

            List<string> lines = new List<string>();
            if (type == StampTypes.Multiplier)
            {
                lines.Add("Multiplier");
                if (workInfo != "") lines.Add(workInfo + " [" + workDate + "]");
                if (base2Info != "") lines.Add("Reference: " + base2Info + " [" + base2Date + "]");
            }
            else if (type == StampTypes.Base)
            {
                if (base2Info != "") lines.Add("Reference: " + base2Info + " [" + base2Date + "]");
            }
            else
            {
                if (workInfo != "") lines.Add(workInfo + " [" + workDate + "]");
            }
            return lines;
        }


        // --------------------------------------------------------------------------------------
        // ----------------- used for tables start ----------------------------------------------
        // --------------------------------------------------------------------------------------

        //Used for tables, don't use for other stuff!
        public static double Level(string db2, string s, GekkoTime t)
        {
            Databank db = Program.databanks.GetDatabank(db2);
            if (!db.ContainsIVariable(s + Globals.freqIndicator + G.ConvertFreq(Program.options.freq)))
            {
                if (Program.options.series_normal_table_missing == ESeriesMissing.M)
                {
                    return Globals.missingVariableArtificialNumber;
                }
                else
                {
                    new Error("Could not find variable " + s + " in " + db2 + " databank");
                }
            }
            return (db.GetIVariable(s + Globals.freqIndicator + G.ConvertFreq(Program.options.freq)) as Series).GetDataSimple(t);  //#getvar
        }

        //Used for tables, don't use for other stuff!
        public static double MulLevel(string s, GekkoTime t)
        {
            if (!Program.databanks.GetFirst().ContainsIVariable(s + Globals.freqIndicator + G.ConvertFreq(Program.options.freq)))
            {
                if (Program.options.series_normal_table_missing == ESeriesMissing.M)
                {
                    return Globals.missingVariableArtificialNumber;
                }
                else
                {
                    new Error("Could not find variable " + s + " in Work databank");
                }
            }
            if (!Program.databanks.GetRef().ContainsIVariable(s + Globals.freqIndicator + G.ConvertFreq(Program.options.freq)))
            {
                if (Program.options.series_normal_table_missing == ESeriesMissing.M)
                {
                    return Globals.missingVariableArtificialNumber;
                }
                else
                {
                    new Error("Could not find variable " + s + " in " + Globals.Ref + " databank");
                }
            }
            return (Program.databanks.GetFirst().GetIVariable(s + Globals.freqIndicator + G.ConvertFreq(Program.options.freq)) as Series).GetDataSimple(t) - (Program.databanks.GetRef().GetIVariable(s + Globals.freqIndicator + G.ConvertFreq(Program.options.freq)) as Series).GetDataSimple(t);  //#getvar
        }
        public static void RevertSmpl(GekkoSmpl2 smplRemember, GekkoSmpl smpl)
        {
            if (smplRemember != null)
            {
                smpl.t0 = smplRemember.t0;
                smpl.t3 = smplRemember.t3;
            }
        }

        //Used for tables, don't use for other stuff!
        public static double Pch(string db2, string s, GekkoTime t)
        {
            Databank db = Program.databanks.GetDatabank(db2);
            if (!db.ContainsIVariable(s + Globals.freqIndicator + G.ConvertFreq(Program.options.freq)))
            {
                if (Program.options.series_normal_table_missing == ESeriesMissing.M)
                {
                    return Globals.missingVariableArtificialNumber;
                }
                else
                {
                    new Error("Could not find variable " + s + " in " + db2 + " databank");
                }
            }
            return ((db.GetIVariable(s + Globals.freqIndicator + G.ConvertFreq(Program.options.freq)) as Series).GetDataSimple(t) / (db.GetIVariable(s + Globals.freqIndicator + G.ConvertFreq(Program.options.freq)) as Series).GetDataSimple(t.Add(-1)) - 1) * 100;  //#getvar
        }

        //Used for tables, don't use for other stuff!
        public static double MulPch(string s, GekkoTime t)
        {
            if (!Program.databanks.GetFirst().ContainsIVariable(s + Globals.freqIndicator + G.ConvertFreq(Program.options.freq)))
            {
                if (Program.options.series_normal_table_missing == ESeriesMissing.M)
                {
                    return Globals.missingVariableArtificialNumber;
                }
                else
                {
                    new Error("Could not find variable " + s + " in Work databank");
                }
            }
            if (!Program.databanks.GetRef().ContainsIVariable(s + Globals.freqIndicator + G.ConvertFreq(Program.options.freq)))
            {
                if (Program.options.series_normal_table_missing == ESeriesMissing.M)
                {
                    return Globals.missingVariableArtificialNumber;
                }
                else
                {
                    new Error("Could not find variable " + s + " in " + Globals.Ref + " databank");
                }
            }
            double pch_base = ((Program.databanks.GetRef().GetIVariable(s + Globals.freqIndicator + G.ConvertFreq(Program.options.freq)) as Series).GetDataSimple(t) / (Program.databanks.GetRef().GetIVariable(s + Globals.freqIndicator + G.ConvertFreq(Program.options.freq)) as Series).GetDataSimple(t.Add(-1)) - 1) * 100;  //#getvar
            double pch_work = ((Program.databanks.GetFirst().GetIVariable(s + Globals.freqIndicator + G.ConvertFreq(Program.options.freq)) as Series).GetDataSimple(t) / (Program.databanks.GetFirst().GetIVariable(s + Globals.freqIndicator + G.ConvertFreq(Program.options.freq)) as Series).GetDataSimple(t.Add(-1)) - 1) * 100;  //#getvar
            return pch_work - pch_base;
        }

        public static int ComputerYear()
        {
            int year = DateTime.Now.Year;
            if (year < 2020 || year > 2099) year = 2020;  //Set to something sensible if computer clock is completely crazy...????
            return year;
        }

        public static void GetStartingPeriod()
        {
            int year = ComputerYear();
            Globals.globalPeriodStart = new GekkoTime(Program.options.freq, year - 10, 1);
            Globals.globalPeriodEnd = new GekkoTime(Program.options.freq, year + 0, 1);
        }

        public static void Compare(O.Compare o)
        {
            if (o.opt_rel != 0d && o.opt_pch != 0d)
            {
                new Error("You cannot use <rel> and <pch> at the same time");
                //throw new GekkoException();
            }
            double rel = o.opt_rel;
            if (o.opt_pch != 0d) rel = o.opt_pch / 100d;

            string type2 = o.opt_sort;
            bool order = true;
            List<string> variables = O.Restrict(o.listItems, true, false, false, true);

            string variablesType = null;  //"_s" etc.
            bool dlog = false;
            string block = null;
            string file = o.fileName;
            file = G.StripQuotes(file);
            //TODO TODO 
            //TODO TODO file should be path...
            //TODO TODO 

            bool history = false;
            if (G.Equal(o.opt_type, "hist")) history = true;
            Sam(o.t1, o.t2, Program.databanks.GetRef(), Program.databanks.GetFirst(), type2, order, variables, variablesType, dlog, block, file, o.fileName, o.opt_dump, o.opt_abs, rel, history);

        }

        //Used for tables, don't use for other stuff!
        public static double Dif(string db2, string s, GekkoTime t)
        {
            Databank db = Program.databanks.GetDatabank(db2);
            if (!db.ContainsIVariable(s + Globals.freqIndicator + G.ConvertFreq(Program.options.freq)))
            {
                if (Program.options.series_normal_table_missing == ESeriesMissing.M)
                {
                    return Globals.missingVariableArtificialNumber;
                }
                else
                {
                    new Error("Could not find variable " + s + " in " + db2 + " databank");
                }
            }
            return (db.GetIVariable(s + Globals.freqIndicator + G.ConvertFreq(Program.options.freq)) as Series).GetDataSimple(t) - (db.GetIVariable(s + Globals.freqIndicator + G.ConvertFreq(Program.options.freq)) as Series).GetDataSimple(t.Add(-1));  //#getvar
        }

        //Used for tables, don't use for other stuff!
        public static double MulDif(string s, GekkoTime t)
        {
            if (!Program.databanks.GetFirst().ContainsIVariable(s + Globals.freqIndicator + G.ConvertFreq(Program.options.freq)))
            {
                if (Program.options.series_normal_table_missing == ESeriesMissing.M)
                {
                    return Globals.missingVariableArtificialNumber;
                }
                else
                {
                    new Error("Could not find variable " + s + " in Work databank");
                }
            }
            if (!Program.databanks.GetRef().ContainsIVariable(s + Globals.freqIndicator + G.ConvertFreq(Program.options.freq)))
            {
                if (Program.options.series_normal_table_missing == ESeriesMissing.M)
                {
                    return Globals.missingVariableArtificialNumber;
                }
                else
                {
                    new Error("Could not find variable " + s + " in " + Globals.Ref + " databank");
                }
            }
            double dif_base = (Program.databanks.GetRef().GetIVariable(s + Globals.freqIndicator + G.ConvertFreq(Program.options.freq)) as Series).GetDataSimple(t) - (Program.databanks.GetRef().GetIVariable(s + Globals.freqIndicator + G.ConvertFreq(Program.options.freq)) as Series).GetDataSimple(t.Add(-1)); //#getvar
            double dif_work = (Program.databanks.GetFirst().GetIVariable(s + Globals.freqIndicator + G.ConvertFreq(Program.options.freq)) as Series).GetDataSimple(t) - (Program.databanks.GetFirst().GetIVariable(s + Globals.freqIndicator + G.ConvertFreq(Program.options.freq)) as Series).GetDataSimple(t.Add(-1)); //#getvar
            return dif_work - dif_base;
        }

        // --------------------------------------------------------------------------------------
        // ----------------- used for tables end ------------------------------------------------
        // --------------------------------------------------------------------------------------

        public static void Create(List varsInput, bool questionMark, O.Create o)
        {
            //ErrorIfDatabanksSwapped();
            if (varsInput == null && questionMark == true)
            {
                int count = Globals.createdVariables.Count;
                if (count == 1) G.Writeln2("There is 1 created variable:");
                else G.Writeln2("There are " + count + " created variables:");
                List<string> a4 = new List<string>();
                foreach (string s in Globals.createdVariables.Keys) a4.Add(s);
                a4.Sort(StringComparer.InvariantCulture);
                foreach (string m in a4)
                {
                    G.Writeln("  " + m);
                }
                G.Writeln();
            }
            else
            {
                List<string> vars = O.Restrict(o.names, true, false, true, false);

                foreach (string s in vars)
                {
                    IVariable iv = O.GetIVariableFromString(s, O.ECreatePossibilities.Can);
                }

                G.Writeln2("Created: " + Stringlist.GetListWithCommas(vars));


            }
        }



        public static void Collapse(List lhs, List rhs, string method, string missing, P p)
        {

            if (lhs.list.Count != rhs.list.Count)
            {
                new Error("" + lhs.list.Count + " items on left, " + rhs.list.Count + " items on right");
            }

            List<string> xlhs = O.Restrict(lhs, true, false, true, true);
            List<string> xrhs = O.Restrict(rhs, true, false, true, true);

            if (xlhs.Count != xrhs.Count)
            {
                new Error("Internal error #89353245");
            }

            for (int i = 0; i < xlhs.Count; i++)
            {

                string yLhs = xlhs[i];
                string yRhs = xrhs[i];

                Series ts_lhs = O.GetIVariableFromString(yLhs, O.ECreatePossibilities.Must, false) as Series;
                Series ts_rhs = O.GetIVariableFromString(yRhs, O.ECreatePossibilities.NoneReportError, true) as Series;  //can search

                CollapseHelper helper = new CollapseHelper();
                if (method != null)
                {
                    helper.method = method;
                }
                else
                {
                    helper.method = Program.options.collapse_method.ToLower();
                }
                if (missing != null) helper.collapse_missing = missing;
                CollapseHelper(ts_lhs, ts_rhs, helper);

                ts_lhs.Stamp();
                ts_lhs.SetDirty(true);

                G.ServiceMessage("Collapsed " + ts_lhs.GetName() + " (" + ts_lhs.freq.Pretty() + ") from " + ts_rhs.GetName() + " (" + ts_rhs.freq.Pretty() + ")", p);

            }
            return;
        }

        /// <summary>
        /// COLLAPSE and collapse(). The helper object contains counts only when collapsing from Daily to lower freqs
        /// (this is used internally).
        /// </summary>
        /// <param name="ts_lhs"></param>
        /// <param name="ts_rhs"></param>
        /// <param name="method"></param>
        /// <returns></returns>
        public static void CollapseHelper(Series ts_lhs, Series ts_rhs, CollapseHelper helper)
        {
            //========================================================================================================
            //                          FREQUENCY LOCATION, indicates where to implement more frequencies
            //========================================================================================================

            ECollapseMethod emethod = ECollapseMethod.Total;  //note: .Count is not used here
            if (G.Equal(helper.method, "total")) emethod = ECollapseMethod.Total;
            else if (G.Equal(helper.method, "avg")) emethod = ECollapseMethod.Avg;
            else if (G.Equal(helper.method, "first")) emethod = ECollapseMethod.First;
            else if (G.Equal(helper.method, "last")) emethod = ECollapseMethod.Last;
            else new Error("Expected method to be 'total', 'avg', 'first' or 'last'.");

            EFreq freq_lhs = ts_lhs.freq;
            EFreq freq_rhs = ts_rhs.freq;

            if (helper.collapse_missing != null && !(G.Equal(helper.collapse_missing, "strict") || G.Equal(helper.collapse_missing, "flex")))
            {
                new Error("For <missing = ...> you must use 'strict' or 'flex', not '" + helper.collapse_missing + "'");
            }

            string missingLower = "strict";
            if (freq_rhs == EFreq.D)
            {
                missingLower = Program.options.collapse_missing_d.ToLower();
                if (helper.collapse_missing != null) missingLower = helper.collapse_missing.ToLower();
            }
            else
            {
                //non-daily RHS
                missingLower = "strict";  //default, has no global option default like daily
                if (helper.collapse_missing != null) missingLower = helper.collapse_missing.ToLower();
                if (G.Equal(missingLower, "flex"))
                {
                    new Error("COLLAPSE: You cannot use local option <missing=flex> on an input series of " + freq_rhs.Pretty().ToLower() + " frequency.");
                }
            }

            if (freq_rhs == EFreq.U || freq_lhs == EFreq.U)
            {
                new Error("COLLAPSE cannot involve undated timeseries");
            }

            GekkoTime t1_highfreq = ts_rhs.GetRealDataPeriodFirst(); //start of high-freq timeseries
            if (t1_highfreq.IsNull()) new Error("It seems the input series " + ts_rhs.GetNameAndFreqPretty(true) + " has no data.");
            GekkoTime t2_highfreq = ts_rhs.GetRealDataPeriodLast(); //end of high-freq timeseries

            if (freq_rhs == EFreq.Q && freq_lhs == EFreq.A)
            {
                //Conversion from Q to A
                double vsum = double.NaN;
                foreach (GekkoTime t in new GekkoTimeIterator(t1_highfreq, t2_highfreq))
                {
                    double value = ts_rhs.GetDataSimple(t);
                    if (t.sub == 1) vsum = 0d;
                    GekkoTime ttemp = new GekkoTime(freq_lhs, t.super, 1);
                    if (emethod == ECollapseMethod.Total)
                    {
                        vsum += value;
                        if (t.sub == Globals.freqQSubperiods) ts_lhs.SetData(ttemp, vsum);
                    }
                    else if (emethod == ECollapseMethod.Avg)
                    {
                        vsum += value;
                        if (t.sub == Globals.freqQSubperiods) ts_lhs.SetData(ttemp, vsum / (double)Globals.freqQSubperiods);
                    }
                    else if (emethod == ECollapseMethod.First)
                    {
                        if (t.sub == 1) ts_lhs.SetData(ttemp, value);
                    }
                    else if (emethod == ECollapseMethod.Last)
                    {
                        if (t.sub == Globals.freqQSubperiods) ts_lhs.SetData(ttemp, value);
                    }
                }
            }
            else if (freq_rhs == EFreq.M && freq_lhs == EFreq.A)
            {
                //Conversion from M to A
                double vsum = double.NaN;
                foreach (GekkoTime t in new GekkoTimeIterator(t1_highfreq, t2_highfreq))
                {

                    double value = ts_rhs.GetDataSimple(t);
                    if (t.sub == 1) vsum = 0d;
                    GekkoTime ttemp = new GekkoTime(freq_lhs, t.super, 1);
                    if (emethod == ECollapseMethod.Total)
                    {
                        vsum += value;
                        if (t.sub == Globals.freqMSubperiods) ts_lhs.SetData(ttemp, vsum);
                    }
                    else if (emethod == ECollapseMethod.Avg)
                    {
                        vsum += value;
                        if (t.sub == Globals.freqMSubperiods) ts_lhs.SetData(ttemp, vsum / (double)Globals.freqMSubperiods);
                    }
                    else if (emethod == ECollapseMethod.First)
                    {
                        if (t.sub == 1) ts_lhs.SetData(ttemp, value);
                    }
                    else if (emethod == ECollapseMethod.Last)
                    {
                        if (t.sub == Globals.freqMSubperiods) ts_lhs.SetData(ttemp, value);
                    }
                }
            }
            else if (freq_rhs == EFreq.M && freq_lhs == EFreq.Q)
            {
                //Conversion from M to Q
                double vsum = double.NaN;
                foreach (GekkoTime t in new GekkoTimeIterator(t1_highfreq, t2_highfreq))
                {
                    double value = ts_rhs.GetDataSimple(t);
                    int mPerQ = Globals.freqMSubperiods / Globals.freqQSubperiods;  //3
                    int quarter = (t.sub - 1) / mPerQ + 1;
                    if (t.sub % mPerQ == 1) vsum = 0d;
                    GekkoTime ttemp = new GekkoTime(freq_lhs, t.super, quarter);
                    if (emethod == ECollapseMethod.Total)
                    {
                        vsum += value;
                        if (t.sub % mPerQ == 0) ts_lhs.SetData(ttemp, vsum);
                    }
                    else if (emethod == ECollapseMethod.Avg)
                    {
                        vsum += value;
                        if (t.sub % mPerQ == 0) ts_lhs.SetData(ttemp, vsum / (double)mPerQ);
                    }
                    else if (emethod == ECollapseMethod.First)
                    {
                        if (t.sub % mPerQ == 1) ts_lhs.SetData(ttemp, value);
                    }
                    else if (emethod == ECollapseMethod.Last)
                    {
                        if (t.sub % mPerQ == 0) ts_lhs.SetData(ttemp, value);
                    }
                }
            }
            else if (freq_rhs == EFreq.W && (freq_lhs == EFreq.A || freq_lhs == EFreq.Q || freq_lhs == EFreq.M))
            {
                //We first split the series to daily freq, so they are easier to collapse

                if (G.Equal(helper.method, "first") || G.Equal(helper.method, "last"))
                {
                    new Error("When collapsing from Weekly freq, method 'first' or 'last' are not implemented.");
                }

                Series ts_daily = new Series(EFreq.D, null);
                InterpolateHelper(ts_daily, ts_rhs, "prorate");
                CollapseHelper helper2 = new CollapseHelper();  //fetches the count series. Using this is more robust than trying to infer the number of observations from two dates
                helper2.method = helper.method;
                //if (missingLower != null) helper2.collapse_missing_d = missingLower;
                helper2.collapse_missing = "strict";  //must be strict here
                if (Globals.collapseFlexOverride) helper2.collapse_missing = "flex";  //only for unit test, not legal
                CollapseHelper(ts_lhs, ts_daily, helper2);

                //TODO TODO
                //TODO TODO
                //TODO TODO
                //TODO TODO
                //TODO TODO If we are using this for non-weeks, correct the seven
                //TODO TODO
                //TODO TODO
                //TODO TODO
                //TODO TODO
                int seven = GekkoTimeStuff.numberOfDaysInAWeek;

                if (emethod == ECollapseMethod.Avg)
                {
                    GekkoTime realFirst = ts_lhs.GetRealDataPeriodFirst();
                    if (!realFirst.IsNull())
                    {
                        //only do this if there are actually some data
                        GekkoTime realLast = ts_lhs.GetRealDataPeriodLast();
                        foreach (GekkoTime gt in new GekkoTimeIterator(realFirst, realLast))
                        {
                            ts_lhs.SetData(gt, ts_lhs.GetDataSimple(gt) * (double)seven);  //nominator may be NaN
                        }
                    }
                }
            }
            else if (freq_rhs == EFreq.D && (freq_lhs == EFreq.A || freq_lhs == EFreq.Q || freq_lhs == EFreq.M || freq_lhs == EFreq.W))
            {
                if (G.Equal(helper.method, "first") || G.Equal(helper.method, "last"))
                {
                    new Error("When collapsing from Daily freq, method 'first' or 'last' are not implemented.");
                }

                Series countPeriods = new Series(freq_lhs, null);  //will be semi-discared afterwards but practical here
                Series countNonMissing = new Series(freq_lhs, null); //will be semi-discared afterwards but practical here

                //for the first and last highfreq real observations, find the first/last observation of the corresponding "parent" (lower freq) time period.
                //this way, missing values at the start/end of the "parent" time period can be detected conveniently
                GekkoTime t1_highfreq_adjusted = GekkoTime.ConvertFreqsFirst(freq_rhs, GekkoTime.ConvertFreqsFirst(freq_lhs, t1_highfreq, null), null);  //first/last is important here
                GekkoTime t2_highfreq_adjusted = GekkoTime.ConvertFreqsLast(freq_rhs, GekkoTime.ConvertFreqsLast(freq_lhs, t2_highfreq)); //first/last is important here

                foreach (GekkoTime t in new GekkoTimeIterator(t1_highfreq_adjusted, t2_highfreq_adjusted))
                {
                    double data = ts_rhs.GetDataSimple(t);
                    if (G.isNumericalError(data))
                    {
                        //Note: these are only holes *inside * real data blocks, not surrounding them
                        if (missingLower == "flex")
                        {
                            continue;  //skip it, and do not count it either.                            
                        }
                        else if (missingLower == "strict")
                        {
                            //live with it: missings will be encountered
                        }
                        else
                        {
                            new Error("Error #782342b234");
                        }
                    }
                    GekkoTime gt = GekkoTime.ConvertFreqsFirst(freq_lhs, t, null);  //...FreqsFirst() --> could just as well be ...FreqsLast(), since we are converting from the highest frequency availiable (days)
                    HandleCollapseData(false, ts_lhs, countPeriods, countNonMissing, data, gt, emethod);
                }

                if (emethod == ECollapseMethod.Avg)
                {
                    GekkoTime time1 = ts_lhs.GetRealDataPeriodFirst();
                    if (!time1.IsNull())
                    {
                        GekkoTime time2 = ts_lhs.GetRealDataPeriodLast();
                        foreach (GekkoTime gt in new GekkoTimeIterator(time1, time2))
                        {
                            ts_lhs.SetData(gt, ts_lhs.GetDataSimple(gt) / countPeriods.GetDataSimple(gt));  //nominator may be NaN
                        }
                    }
                }
            }
            else
            {
                new Error("Cannot COLLAPSE frequency " + freq_rhs.Pretty() + " to frequency " + freq_lhs.Pretty() + "");
            }
        }

        private static void CollapseHelper(string method, Series ts_lhs, double vsum, double n, GekkoTime tLowFreq)
        {
            double y = 1d;
            if (G.Equal(method, "avg")) y = n;
            ts_lhs.SetData(tLowFreq, vsum / y);
        }


        public static void Interpolate(List lhs, List rhs, string method, P p)
        {
            if (lhs.list.Count != rhs.list.Count)
            {
                new Error("" + lhs.list.Count + " items on left, " + rhs.list.Count + " items on right");
                //throw new GekkoException();
            }

            List<string> xlhs = O.Restrict(lhs, true, false, true, true);
            List<string> xrhs = O.Restrict(rhs, true, false, true, true);

            if (xlhs.Count != xrhs.Count)
            {
                new Error("Internal error #89353245");
            }

            for (int ii = 0; ii < xlhs.Count; ii++)
            {

                string yLhs = xlhs[ii];
                string yRhs = xrhs[ii];

                Series ts_lhs = O.GetIVariableFromString(yLhs, O.ECreatePossibilities.Must, false) as Series;
                Series ts_rhs = O.GetIVariableFromString(yRhs, O.ECreatePossibilities.NoneReportError, true) as Series;  //can search

                if (ts_lhs == null)
                {
                    new Error("Cannot find: " + yRhs);
                }

                if (method == null) method = Program.options.interpolate_method; // default is "repeat"
                InterpolateHelper(ts_lhs, ts_rhs, method);

                ts_lhs.Stamp();
                ts_lhs.SetDirty(true);

                G.ServiceMessage("Interpolated " + ts_lhs.GetName() + " (" + ts_lhs.freq.Pretty() + ") from " + ts_rhs.GetName() + " (" + ts_rhs.freq.Pretty() + ")", p);
            }
            return;
        }

        public static void InterpolateHelper(Series ts_lhs, Series ts_rhs, string method)
        {
            //========================================================================================================
            //                          FREQUENCY LOCATION, indicates where to implement more frequencies
            //========================================================================================================

            //In principle, the generic methodology used for D freq destination could be used for all freqs here.
            //But for speed, we keep the code from A --> Q, A --> M and Q --> M. 

            if (G.Equal(method, "rep") || G.Equal(method, "repeat") || G.Equal(method, "prorate"))
            {
                //good
            }
            else
            {
                new Error("Wrong method in INTERPOLATE: '" + method + "'. Choose between 'repeat' or 'prorate'.");
            }

            EFreq freq_rhs = ts_rhs.freq;
            EFreq freq_lhs = ts_lhs.freq;
            GekkoTime t1_rhs = ts_rhs.GetRealDataPeriodFirst(); //start of low-freq timeseries.
            if (t1_rhs.IsNull()) new Error("It seems the input series " + ts_rhs.GetNameAndFreqPretty(true) + " has no data.");
            GekkoTime t2_rhs = ts_rhs.GetRealDataPeriodLast(); //end of low-freq timeseries

            if (freq_lhs == EFreq.W && (freq_rhs == EFreq.A || freq_rhs == EFreq.Q || freq_rhs == EFreq.M))
            {
                //Splitting out W into A, Q or M is done in a special way.
                //We cannot just run over the RHS time period, because the freqs do not fit neatly and we first convert to D freq.
                //First we interpolate the RHS into D freq, which makes it easier.
                Series ts_daily = new Series(EFreq.D, null);
                InterpolateHelper(ts_daily, ts_rhs, "repeat");
                GekkoTime t1_daily = ts_daily.GetRealDataPeriodFirst();
                if (t1_daily.IsNull()) new Error("The input series has no data.");
                GekkoTime t2_daily = ts_daily.GetRealDataPeriodLast();

                foreach (GekkoTime t5 in new GekkoTimeIterator(t1_daily, t2_daily))  //t5 is D freq
                {
                    double divide = double.NaN;
                    if (G.Equal(method, "rep") || G.Equal(method, "repeat"))
                    {
                        divide = GekkoTimeStuff.numberOfDaysInAWeek;
                    }
                    else if (G.Equal(method, "prorate"))
                    {
                        GekkoTime gt7 = GekkoTime.ConvertFreqsFirst(freq_rhs, t5, null);  //first/last method will yield the same, we are converting from high-freq to lower-freq                        
                        divide = GekkoTime.Observations(GekkoTime.ConvertFreqsFirst(EFreq.D, gt7, null), GekkoTime.ConvertFreqsLast(EFreq.D, gt7));
                    }
                    ts_daily.SetData(t5, ts_daily.GetDataSimple(t5) / divide);
                }
                CollapseHelper helper2 = new CollapseHelper();
                helper2.method = "total";
                helper2.collapse_missing = "strict";
                if (Globals.collapseFlexOverride) helper2.collapse_missing = "flex";  //only for unit test, not legal
                CollapseHelper(ts_lhs, ts_daily, helper2);
            }
            else
            {

                foreach (GekkoTime t in new GekkoTimeIterator(t1_rhs, t2_rhs))
                {
                    double value = ts_rhs.GetDataSimple(t);
                    if (value == double.NaN) continue;
                    if (freq_lhs == EFreq.Q && freq_rhs == EFreq.A)
                    {
                        //Conversion from A to Q                                        
                        if (G.Equal(method, "rep") || G.Equal(method, "repeat"))
                        {
                            for (int i = 1; i < Globals.freqQSubperiods + 1; i++)
                            {
                                GekkoTime gt = new GekkoTime(EFreq.Q, t.super, i);
                                ts_lhs.SetData(gt, value);
                            }
                        }
                        else if (G.Equal(method, "prorate"))
                        {
                            for (int i = 1; i < Globals.freqQSubperiods + 1; i++)
                            {
                                GekkoTime gt = new GekkoTime(EFreq.Q, t.super, i);
                                ts_lhs.SetData(gt, value / (double)Globals.freqQSubperiods);
                            }
                        }
                        else throw new GekkoException();
                    }
                    else if (freq_lhs == EFreq.M && freq_rhs == EFreq.A)
                    {
                        //Conversion from A to M
                        if (G.Equal(method, "repeat"))
                        {
                            for (int i = 1; i < Globals.freqMSubperiods + 1; i++)
                            {
                                GekkoTime gt = new GekkoTime(EFreq.M, t.super, i);
                                ts_lhs.SetData(gt, value);
                            }
                        }
                        else if (G.Equal(method, "prorate"))
                        {
                            for (int i = 1; i < Globals.freqMSubperiods + 1; i++)
                            {
                                GekkoTime gt = new GekkoTime(EFreq.M, t.super, i);
                                ts_lhs.SetData(gt, value / (double)Globals.freqMSubperiods);
                            }
                        }
                        else throw new GekkoException();
                    }
                    else if (freq_lhs == EFreq.M && freq_rhs == EFreq.Q)
                    {
                        //Conversion from Q to M
                        int mInQ = Globals.freqMSubperiods / Globals.freqQSubperiods; //3
                        int startSub = (t.sub - 1) * mInQ + 1;  //1->1, 2->4, 3->7, 4->10
                        if (G.Equal(method, "repeat"))
                        {
                            for (int i = startSub; i < startSub + mInQ; i++)
                            {
                                GekkoTime gt = new GekkoTime(EFreq.M, t.super, i);
                                ts_lhs.SetData(gt, value);
                            }
                        }
                        else if (G.Equal(method, "prorate"))
                        {
                            for (int i = startSub; i < startSub + mInQ; i++)
                            {
                                GekkoTime gt = new GekkoTime(EFreq.M, t.super, i);
                                ts_lhs.SetData(gt, value / (double)mInQ);
                            }
                        }
                        else throw new GekkoException();
                    }
                    else if (freq_lhs == EFreq.D && (freq_rhs == EFreq.A || freq_rhs == EFreq.Q || freq_rhs == EFreq.M || freq_rhs == EFreq.W))
                    {
                        GekkoTime t1_lhs = GekkoTime.ConvertFreqsFirst(freq_lhs, t, null);
                        GekkoTime t2_lhs = GekkoTime.ConvertFreqsLast(freq_lhs, t);
                        //For instance, freq_lhs is D and freq_rhs may be A, and we may have t1_rhs = 2020.
                        //Then, we convert 2020 into the D date 2020m1d1.

                        double x = ts_rhs.GetDataSimple(t);
                        int n = GekkoTime.Observations(t1_lhs, t2_lhs);

                        if (G.Equal(method, "repeat"))
                        {
                            foreach (GekkoTime t_lhs in new GekkoTimeIterator(t1_lhs, t2_lhs))
                            {
                                ts_lhs.SetData(t_lhs, x);
                            }
                        }
                        else if (G.Equal(method, "prorate"))
                        {
                            foreach (GekkoTime t_lhs in new GekkoTimeIterator(t1_lhs, t2_lhs))
                            {
                                ts_lhs.SetData(t_lhs, x / (double)n);
                            }
                        }
                        else throw new GekkoException();
                    }
                    else new Error("Cannot INTERPOLATE frequency '" + freq_rhs + "' to frequency '" + freq_lhs + "'");
                }
            }
        }

        private static Databank GetDatabank(string b1)
        {
            Databank databank1 = Program.databanks.GetFirst();
            if (b1 == "@") databank1 = Program.databanks.GetRef();
            else if (b1 != "") databank1 = Program.databanks.GetDatabank(b1);
            if (databank1 == null)
            {
                new Error("Databank '" + b1 + "' not found");
                //throw new GekkoException();
            }

            return databank1;
        }

        public static void Delete(List vars2)
        {


            List vars = O.Restrict2(vars2, true, true, true, false);

            List<ToFrom> list = SearchFromTo(vars, null, null, null, EWildcardSearchType.Delete, null);

            int counter = 0;
            G.Writeln();

            for (int i = 0; i < list.Count; i++)
            {
                string var = list[i].s1;
                IVariable iv = O.RemoveIVariableFromString(var, false); //just warning
                if (iv != null) counter++;
            }

            if (counter == 0) G.Writeln("Did not delete any variables");
            else if (counter == 1) G.Writeln("Deleted 1 variable");
            else G.Writeln("Deleted " + counter + " variables");
        }

        public static void Combine(List<IVariable> input, List<List<string>> output, int depth, Stack<string> stack)
        {
            //could have cleaner interface, but never mind it works

            //input may be for instance a list: ('a', #i, 'x', #j), where we need to unfold
            //the second element and last

            if (depth == 0)  //use stack?
            {
                //first index                
            }

            if (depth == input.Count)
            {
                //we are beyond the length of input

                List<string> temp = new List<string>(stack.Reverse());
                output.Add(temp);
                stack.Pop();
                return;
            }

            IVariable iv = input[depth];

            if (iv.Type() == EVariableType.String)
            {
                string s = iv.ConvertToString();
                //output[output.Count - 1].Add(s);
                stack.Push(s);
                Combine(input, output, depth + 1, stack);

            }
            else if (iv.Type() == EVariableType.List)
            {
                foreach (IVariable iv2 in ((List)iv).list)
                {
                    string s = iv2.ConvertToString();
                    //output[output.Count - 1].Add(s);
                    stack.Push(s);
                    Combine(input, output, depth + 1, stack);
                }
            }
            else
            {
                new Error("Expected indices to be of string or list type");
                //throw new GekkoException();
            }
            if (depth > 0) stack.Pop();
            return;
        }


        public static double[,] XTransposeX(double[,] x)
        {
            //  1 2
            //  3 4     5 6 7 8       -->   3x2 * 2x4 = 3x4
            //  5 6     8 9 8 5
            //
            int xRows = x.GetLength(1);
            int xCols = x.GetLength(0);
            //int yRows = x.GetLength(0);
            //int yCols = x.GetLength(1);

            double[,] z = new double[xRows, xRows];
            for (int i = 0; i < xRows; i++)
            {
                for (int j = 0; j < xRows; j++)
                {
                    double sum = 0d;
                    for (int k = 0; k < xCols; k++)
                    {
                        sum += x[k, i] * x[k, j];
                    }
                    z[i, j] = sum;
                }
            }
            return z;

        }

        public static GekkoAction GetGekkoAction(long n)
        {
            GekkoAction ga = null;
            Globals.linkAction.TryGetValue(n, out ga);
            if (ga == null || ga.action == null)
            {
                using (Warning w = new Warning())
                {
                    w.MainAdd("Link of type '" + ga.type.ToString() + "' has expired. ");
                    if (ga.type == EGekkoActionTypes.Ols)
                    {
                        w.MainAdd("You may use different names for your OLS equations to avoid this.");
                    }
                }
            }
            return Globals.linkAction[n];
        }

        public static void DeleteGekkoActions(EGekkoActionTypes type, string name)
        {
            foreach (GekkoAction ga in Globals.linkAction.Values)
            {
                if (ga.type == type)
                {
                    if (name == null || (name != null && G.Equal(ga.name, name)))
                    {
                        //expire all links that match the type and name
                        //if no name given (=null), all links with that type are expired
                        ga.action = null;
                    }
                }
            }
        }

        public static int GetDigits(double coeff, int i)
        {
            int digits = -(int)RoundDecimals1(coeff) + i;  //can be negative
            if (digits < 0) digits = 0;
            return digits;
        }

        public static double StandardDeviation(List<double> valueList)
        {
            double M = 0.0;
            double S = 0.0;
            int k = 1;
            foreach (double value in valueList)
            {
                double tmpM = M;
                M += (value - tmpM) / k;
                S += (value - tmpM) * (value - M);
                k++;
            }
            return Math.Sqrt(S / (k - 2));
        }

        public static double Mean(List<double> valueList)
        {
            double m = 0d;
            foreach (double value in valueList)
            {
                m += value;
            }
            return m / valueList.Count;
        }

        public static void Max(out int maxI, out double max, List<double> list)
        {
            maxI = int.MinValue;
            max = double.MinValue;
            for (int i = 0; i < list.Count; i++)
            {
                double d = list[i];
                if (d > max)
                {
                    max = d;
                    maxI = i;
                }
            }
        }

        public static void Min(out int minI, out double min, List<double> list)
        {
            minI = int.MaxValue;
            min = double.MaxValue;
            for (int i = 0; i < list.Count; i++)
            {
                double d = list[i];
                if (d < min)
                {
                    min = d;
                    minI = i;
                }
            }
        }

        public static List<IVariable> Unfold(IVariable x)
        {
            return Unfold(new List<IVariable> { x });
        }

        public static List<IVariable> Unfold(List<IVariable> xlist)
        {
            List<IVariable> xlistUnfolded = new List<IVariable>();
            foreach (IVariable x in xlist)
            {
                if (x.Type() == EVariableType.Series)
                {
                    xlistUnfolded.Add(x);
                }
                else if (x.Type() == EVariableType.Val)
                {
                    xlistUnfolded.Add(x);
                }
                else if (x.Type() == EVariableType.Matrix && ((Matrix)x).data.Length == 1)  //an 1x1 matrix
                {
                    xlistUnfolded.Add(x);
                }
                else if (x.Type() == EVariableType.List)
                {
                    foreach (IVariable iv in ((List)x).list)
                    {
                        List<IVariable> extraContainerExplode = Unfold(iv);
                        xlistUnfolded.AddRange(extraContainerExplode);
                    }
                }
                else
                {
                    using (Error e = new Error())
                    {
                        string type = G.GetTypeString(x);
                        e.MainAdd("The argument is of " + type + " type.");
                        e.MainAdd("The argument can only be series, value, 1x1 matrix (or lists containing these).");
                        if (type == "string")
                        {
                            e.MainAdd("If you are using a string %s as a series name, you should enclose it in curlies: {%s}.");
                        }
                    }
                }
            }
            return xlistUnfolded;
        }

        /// <summary>
        /// Used in the other UnfoldAsSeries() method that accepts a list of IVariables.
        private static List<Series> UnfoldAsSeries(GekkoSmpl smpl, IVariable x)
        {
            return UnfoldAsSeries(smpl, new List<IVariable> { x });
        }

        /// <summary>
        /// Takes a list of IVariables an convert them into a list of Series. The IVariables may
        /// be series, val or 1x1 matrix. 
        /// Note: See also the methods O.ConvertToSeriesMaybeConstant() and Functions.Helper_GeneralFunction().
        /// </summary>
        /// <param name="smpl"></param>
        /// <param name="xlist"></param>
        /// <returns></returns>
        public static List<Series> UnfoldAsSeries(GekkoSmpl smpl, List<IVariable> xlist)
        {
            List<Series> xlistUnfolded = new List<Series>();
            foreach (IVariable x in xlist)
            {
                if (x.Type() != EVariableType.List)
                {
                    xlistUnfolded.Add(O.ConvertToSeriesMaybeConstant(smpl, x));
                }
                else
                {
                    foreach (IVariable iv in ((List)x).list)
                    {
                        List<Series> extraContainerExplode = UnfoldAsSeries(smpl, iv);
                        xlistUnfolded.AddRange(extraContainerExplode);
                    }
                }
            }
            return xlistUnfolded;
        }

        public static void Analyze(O.Analyze o)
        {

            //set per 2001 2010;
            //ser x1 = 1,2,4,5,6,5,6,7,8,6;
            //ser x2 = 5,4,4,5,6,3,6,1,8,6;
            //ser x3 = 7,5,4,1,6,5,9,7,8,9;
            //analyze <matrix>x1,x2,x3 xx;
            //disp<decimals 8> xx;

            //time 2001 2010;
            //create x1, x2, x3;
            //ser x1 = 1,2,4,5,6,5,6,7,8,6;
            //ser x2 = 5,4,4,5,6,3,6,1,8,6;
            //ser x3 = 7,5,4,1,6,5,9,7,8,9;
            //analyze x1,x2,x3;

            //  1 x1
            //    ANNUAL Data for   10 periods from 2001  to 2010
            //     Mean            5.00            Standard deviation         2.16
            //     Maximum         8.00 in  2009
            //     Minimum         1.00 in  2001
            //  2 x2
            //    ANNUAL Data for   10 periods from 2001  to 2010
            //     Mean            4.80            Standard deviation         1.93
            //     Maximum         8.00 in  2009
            //     Minimum         1.00 in  2008
            //  3 x3
            //    ANNUAL Data for   10 periods from 2001  to 2010
            //     Mean            6.10            Standard deviation         2.47
            //     Maximum         9.00 in  2010
            //     Minimum         1.00 in  2004

            //     Cross correlation based on    10 observations
            //      1      2      3
            //  1   1.00
            //  2   0.21   1.00
            //  3   0.31   0.31   1.00

            // => disp<decimals 8> xx

            //MATRIX   XX

            //              1          2          3
            //   1 1.00000000 0.21295885 0.31237800
            //   2 0.21295885 1.00000000 0.30733932
            //   3 0.31237800 0.30733932 1.00000000

            GekkoTime t1 = o.t1;
            GekkoTime t2 = o.t2;

            List<IVariable> input = Unfold(o.x);
            List<string> labels = new List<string>();
            for (int i = 0; i < input.Count; i++)
            {
                labels.Add(G.ReplaceGlueSymbols(o.expressionsText[i]));
            }

            int n = GekkoTime.Observations(t1, t2);
            int k = input.Count;
            double[,] tsData = new double[n, k];

            int n_i = 0;
            foreach (GekkoTime t in new GekkoTimeIterator(t1, t2))
            {
                int k_i = 0;
                foreach (IVariable x in input)
                {
                    tsData[n_i, k_i] = x.GetVal(t);
                    k_i++;
                }
                n_i++;
            }

            G.Writeln();
            int counter = -1;
            foreach (string s in labels)
            {
                counter++;
                List<double> x = new List<double>(n);
                for (int i = 0; i < n; i++)
                {
                    x.Add(tsData[i, counter]);
                }
                double std = StandardDeviation(x);
                double mean = Mean(x);
                int minI; double min;
                Min(out minI, out min, x);
                int maxI; double max;
                Max(out maxI, out max, x);
                int width = 16;
                G.Writeln(s);
                G.Writeln("  " + n + " observations from " + t1.ToString() + " to " + t2.ToString());
                G.Writeln("  Mean    = " + G.levelFormat(mean, width));
                G.Writeln("  St.dev. = " + G.levelFormat(std, width));
                G.Writeln("  Min     = " + G.levelFormat(min, width) + " in " + t1.Add(minI).ToString());
                G.Writeln("  Max     = " + G.levelFormat(max, width) + " in " + t1.Add(maxI).ToString());
            }

            if (k > 1)
            {

                foreach (double d in tsData)
                {
                    if (G.isNumericalError(d))
                    {
                        new Error("Correlation cannot be computed due to missing values");
                        //throw new GekkoException();
                    }
                }

                double[,] y = null;
                alglib.pearsoncorrm(tsData, out y);
                Matrix m = new Matrix();
                m.data = y;

                Program.databanks.GetFirst().AddIVariableWithOverwrite("#corr", m);

                G.Writeln2("Cross correlation based on " + k + " variables and " + n + " observations");
                //counter = 0;
                //foreach (string s in labels)
                //{
                //    counter++;
                //    G.Writeln("Variable " + counter + ": " + s);
                //}
                Program.ShowMatrix(m, Globals.symbolCollection + "corr");
            }
        }



        public static DialogResult InputBox(string title, string promptText, ref string value)
        {
            Form form = new Form();
            System.Windows.Forms.Label label = new System.Windows.Forms.Label();
            TextBox textBox = new TextBox();
            Button buttonOk = new Button();
            Button buttonCancel = new Button();

            form.Text = title;
            label.Text = promptText;
            //label.Text = "This is the first line\r\nAnd this is the second line.";
            //string s = "This is the first line\r\nAnd this is the second line.";
            textBox.Text = value;

            buttonOk.Text = "OK";
            buttonCancel.Text = "Cancel";
            buttonOk.DialogResult = DialogResult.OK;
            buttonCancel.DialogResult = DialogResult.Cancel;

            label.SetBounds(9, 20 - 5, 372, 13);
            textBox.SetBounds(12, 36, 372, 20);
            buttonOk.SetBounds(228, 72, 75, 23);
            buttonCancel.SetBounds(309, 72, 75, 23);

            label.AutoSize = true;
            textBox.Anchor = textBox.Anchor | AnchorStyles.Right;
            buttonOk.Anchor = AnchorStyles.Bottom | AnchorStyles.Right;
            buttonCancel.Anchor = AnchorStyles.Bottom | AnchorStyles.Right;

            form.ClientSize = new Size(396, 107);
            form.Controls.AddRange(new Control[] { label, textBox, buttonOk, buttonCancel });
            form.ClientSize = new Size(Math.Max(300, label.Right + 10), form.ClientSize.Height);
            form.FormBorderStyle = FormBorderStyle.FixedDialog;
            form.StartPosition = FormStartPosition.CenterScreen;
            form.MinimizeBox = false;
            form.MaximizeBox = false;
            form.AcceptButton = buttonOk;
            form.CancelButton = buttonCancel;

            DialogResult dialogResult = form.ShowDialog();
            value = textBox.Text;
            return dialogResult;
        }

        public static double RoundToSignificantDigits(this double d, int digits)
        {
            if (d == 0) return 0;
            return RoundDecimals2(d, digits);
        }

        private static double RoundDecimals2(double d, int digits)
        {
            double scale = Math.Pow(10, RoundDecimals1(d));
            double scale2 = scale * Math.Round(d / scale, digits, MidpointRounding.AwayFromZero);
            return scale2;
        }

        private static double RoundDecimals1(double d)
        {
            return Math.Floor(Math.Log10(Math.Abs(d))) + 1;
        }



        public static void AllSeriesCheckRecursive(IVariable x, ref bool fail, ref int seriesCounter)
        {
            if (x.Type() == EVariableType.List)
            {
                foreach (IVariable iv in (x as List).list)
                {
                    AllSeriesCheckRecursive(iv, ref fail, ref seriesCounter);
                    if (fail) break;  //no need to carry on
                }
            }
            else
            {
                if (!IsSeriesType(x)) fail = true;
                if (x.Type() == EVariableType.Series) seriesCounter++;
            }
        }


        private static bool IsSeriesType(IVariable iv)
        {
            //if (iv == null) return false;
            bool b = true;
            if (iv.Type() != EVariableType.Series && iv.Type() != EVariableType.Val)
            {
                b = false;
            }
            return b;
        }

        public static ExcelOptions PrepareDataForExcel(Table tab2)
        {
            int startRows = 1;
            int startCols = 1;
            ExcelOptions eo = new ExcelOptions();
            eo.excelRowLabels = new string[tab2.GetRowMaxNumber() - startRows, 1];
            eo.excelColumnLabels = new string[1, tab2.GetColMaxNumber() - startCols];
            eo.excelColumnLabelsGekkoTime = new GekkoTime[1, tab2.GetColMaxNumber() - startCols];
            eo.excelData = G.CreateArrayDouble(tab2.GetRowMaxNumber() - startRows, tab2.GetColMaxNumber() - startCols, double.NaN);

            for (int i = 1; i <= tab2.GetRowMaxNumber(); i++)
            {
                for (int j = 1; j <= tab2.GetColMaxNumber(); j++)
                {
                    Cell cell2 = tab2.Get(i, j);
                    string s2 = "";
                    if (cell2 == null)
                    {
                    }
                    else
                    {
                        if (i == 1 && j == 1)
                        {
                            //do nothing
                        }
                        else if (j == 1)
                        {
                            //first row
                            string s = cell2.CellText.TextData[0];
                            if (s == null) s = "";
                            eo.excelRowLabels[i - 1 - startRows, j - 1] = s;
                        }
                        else if (i == 1)
                        {
                            string s = cell2.CellText.TextData[0];
                            if (s == null) s = "";
                            eo.excelColumnLabels[i - 1, j - 1 - startCols] = s;
                            eo.excelColumnLabelsGekkoTime[i - 1, j - 1 - startCols] = cell2.date_hack; //a hack, the cell ought to be date format
                        }
                        else
                        {
                            eo.excelData[i - startRows - 1, j - startCols - 1] = cell2.number;
                            s2 = cell2.date;
                        }
                    }
                }
            }

            return eo;
        }

        /// <summary>
        /// Plotting in Gekko (PLOT command). Can plot mixed frequencies.
        /// </summary>
        public static PlotTable PlotMixed(GekkoSmpl smpl, EPrintTypes type, List<O.Prt.Element> containerExplode, int n, O.Prt o, EFreq highestFreq)
        {
            PlotTable plotTable = new PlotTable();
            plotTable.dates = new List<List<double>>();
            plotTable.values = new List<List<double>>();
            for (int j = 0; j < n; j++)
            {
                plotTable.dates.Add(new List<double>());
                plotTable.values.Add(new List<double>());
            }

            for (int j = 2; j < n + 2; j++)  //cols/variables starts at j=2. So for 3 variables we have 2, 3, 4.
            {
                int[] skipCounter = new int[4];

                O.Prt.Element cc;
                string operator2, format;
                List<string> label;
                EFreq freqColumn;
                double scalarValueWork, scalarValueRef;
                Series tsWork, tsRef;
                Print.PrintPrepareColumn(type, containerExplode, j, out cc, out operator2, out label, out format, out freqColumn, out scalarValueWork, out tsWork, out scalarValueRef, out tsRef);

                bool isScalar = tsWork == null && tsRef == null;

                EFreq freqHere = highestFreq;
                if (isScalar)
                {
                    //will become highestFreq
                }
                else
                {
                    if (tsWork != null) freqHere = tsWork.freq;
                    else if (tsRef != null) freqHere = tsRef.freq;
                }

                int i = 0;
                foreach (GekkoTime t in new GekkoTimeIterator(ConvertFreqs(smpl.t1, smpl.t2, freqHere)))  //handles if the freq given is different from the series freq
                {
                    double d = double.NaN;
                    if (isScalar)  //not series
                    {
                        d = Print.PrintHelperTransformScalar(scalarValueWork, scalarValueRef, operator2, o.guiGraphIsLogTransform, EPrtCollapseTypes.None, 1, skipCounter);
                    }
                    else
                    {
                        d = Print.PrintHelperTransform(smpl, tsWork, tsRef, t, operator2, o.guiGraphIsLogTransform, EPrtCollapseTypes.None, 1, skipCounter);
                    }
                    i++;

                    double tt = PlotTableTime(freqHere, t);

                    //The columns (variables) are counted with j=1 for date column, and variables following for j=2, j=3, ...
                    //We skip the j=1 column, so the following logic applies, if there are n variables
                    //j=1 --> skip
                    //j=2 --> 1 and 1+n
                    //j=3 --> 2 and 2+n

                    plotTable.dates[j - 2].Add(tt);
                    plotTable.values[j - 2].Add(d);

                }
            }

            return plotTable;
        }

        /// <summary>
        /// Concert a GekkoTime into a PLOT-suitable double.
        /// </summary>
        /// <param name="freqHere"></param>
        /// <param name="t"></param>
        /// <returns></returns>
        public static double PlotTableTime(EFreq freqHere, GekkoTime t)
        {
            double tt = ((ScalarVal)Functions.helper_time(t)).val;
            if (freqHere == EFreq.A) tt += 0.5d;  //annual years should be 2020.5 to be centered correctly
            return tt;
        }


        public static void NonSeriesHandling(O.Prt oPrt)
        {
            string pling = null;
            pling = "'";
            foreach (O.Prt.Element element in oPrt.prtElements)
            {
                string[] w = Print.RemoveSplitter(element.labelGiven[0]).Split('|');  //raw label   
                string labelGiven = G.ReplaceGlueSymbols(w[0]);
                NonSeriesHelper helper = new NonSeriesHelper();
                PrintNonSeries(element.variable[0], labelGiven, 0, helper);
                helper.Message();
            }
        }

        private static string PrintNonSeries(IVariable x, string labelGiven, int depth, NonSeriesHelper helper)
        {
            string s = "";
            string pling = "'";
            if (depth == 0)
            {
                if (x.Type() == EVariableType.List)
                {
                    G.Writeln2(labelGiven);                    
                    List x_list = x as List;
                    for (int i = 0; i < x_list.Count(); i++)
                    {
                        string ss = PrintNonSeries(x_list.list[i], null, depth + 1, helper);
                        s += ss;
                        if (x_list.Count() == 1)
                        {
                            //
                        }
                        else if (i < x_list.Count() - 1)
                        {
                            s += ", ";
                        }
                    }
                    G.Write(s);
                    G.Writeln("   [" + x_list.Count() + " item" + G.S(x_list.Count()) + "]", Color.LightGray);
                }
                else if (x.Type() == EVariableType.Matrix)
                {
                    Program.ShowMatrix((Matrix)x, labelGiven);
                }
                else if (x.Type() == EVariableType.String)
                {
                    PrintLabel(labelGiven);
                    G.Writeln(pling + ((ScalarString)x).string2 + pling);
                }
                else if (x.Type() == EVariableType.Val)
                {
                    PrintLabel(labelGiven);
                    double d = ((ScalarVal)x).val;
                    if (G.isNumericalError(d))
                    {
                        G.Writeln(Globals.printNaNIndicator);
                    }
                    else
                    {
                        G.Writeln(d.ToString());
                    }
                }
                else if (x.Type() == EVariableType.Date)
                {
                    PrintLabel(labelGiven);
                    G.Writeln(((ScalarDate)x).date.ToString());
                }
                else if (x.Type() == EVariableType.Map)
                {
                    PrintLabel(labelGiven);
                    Map map = x as Map;

                    if (map.storage.Count == 0)
                    {
                        G.Writeln("[empty map]");
                    }
                    else
                    {
                        G.Writeln("MAP printing not implemented yet. But individual elements can");
                        G.Writeln("be printed like for instance #m.%s, #m.x, etc.");
                    }
                }
                else if (x.Type() == EVariableType.Null)
                {
                    G.Writeln2("[null]");
                }
                else
                {
                    new Error("Unkonwn variable type", false);  //why new exception
                    //SERIES: should not be possible
                }
            }
            else
            {
                //depth > 0
                if (x.Type() == EVariableType.List)
                {
                    if (depth > helper.depth) helper.depth = depth;
                    List x_list = x as List;
                    for (int i = 0; i < x_list.Count(); i++)
                    {
                        helper.rows++;
                        string ss = PrintNonSeries(x_list.list[i], null, depth + 1, helper);
                        s += ss;
                        if (x_list.Count() == 1)
                        {
                            s += ",";
                        }
                        else if (i < x_list.Count() - 1)
                        {
                            s += ", ";
                        }
                    }
                    s = "(" + s + ")";
                }
                else if (x.Type() == EVariableType.String)
                {
                    s += pling + ((ScalarString)x).string2 + pling;
                }
                else if (x.Type() == EVariableType.Date)
                {
                    s += ((ScalarDate)x).date.ToString();
                }
                else if (x.Type() == EVariableType.Val)
                {
                    ////See also #83490837432, these should be merged/fusioned
                    //We use same format as for normal PRT of series, but the width is truncated regarding blanks
                    double d = ((ScalarVal)x).val;

                    if (G.isNumericalError(d))
                    {
                        s += Globals.printNaNIndicator;
                    }
                    else
                    {
                        //string format = "f" + Program.options.print_fields_nwidth + "." + Program.options.print_fields_ndec + "";
                        //G.FormatNumber(d, format, false, false).Trim();
                        string z = "";
                        for (int i = 0; i < Program.options.print_fields_ndec; i++) z += "#";
                        string format = "0." + z;
                        string s3 = d.ToString("0." + z, CultureInfo.InvariantCulture);
                        s += s3;
                    }
                }
                else
                {
                    s += "[" + x.Type().ToString().ToLower() + "]";  //series, map, matrix
                }


            }
            return s;

        }

        private static void PrintLabel(string labelGiven)
        {
            if (!G.NullOrBlanks(labelGiven)) G.Writeln2(labelGiven);
            else G.Writeln();
        }

        public static bool HandleLabels(TokenList tokenList, int level, List<O.LabelHelperIVariable> iVariableList, string[] uncontrolledSimpleLists, ref int counter)
        {
            //it is checked that the IVariables from iVariableList match in number with the relevant {...} and x{...} in the tokenList.
            //for x[..., ..., ...] they must also match in indexer position
            //if any of this is wrong, the method returns true (= fail), and in that case
            //the labels are not unfolded but just shown as they are.
            //so there will be no catastrophic fail here, just labels that are not very informative.
            //the counting check is quite a good check that the {...} and x[...] match.

            foreach (TokenHelper token in tokenList.storage)
            {
                if (token.HasChildren())
                {
                    if (token.SubnodesType() == "[" || token.SubnodesType() == "{")
                    {
                        List<TokenHelperComma> listOfTokensListsCommaSplit = token.SplitCommas(true);
                        int ii = -1;
                        foreach (TokenHelperComma tokenListCommaSplit in listOfTokensListsCommaSplit)  //does not include start and end parenthesis
                        {
                            counter++;
                            ii++;
                            if (tokenListCommaSplit.list.storage.Count == 2 && tokenListCommaSplit.list[0].s == Globals.symbolCollection.ToString() && tokenListCommaSplit.list[1].type == ETokenType.Word)
                            {
                                string listName = tokenListCommaSplit.list[1].s;
                                TokenHelper parent = tokenListCommaSplit.list[0];
                                bool foundAsSumFunction = false;
                                while (true)
                                {
                                    if (parent == null) break;
                                    if (parent.SubnodesType() == "(")
                                    {
                                        TokenHelper left = parent.Offset(-1);
                                        if (left != null)
                                        {
                                            if (G.Equal(left.s, "sum"))
                                            {
                                                List<TokenHelperComma> split = parent.SplitCommas(true);
                                                if (split.Count > 1)
                                                {
                                                    TokenList firstSplit = split[0].list;
                                                    if (firstSplit.storage.Count == 1)
                                                    {
                                                        if (firstSplit[0].SubnodesType() == "(")
                                                        {
                                                            //handles sum((#i, #j), ...)
                                                            List<TokenHelperComma> splitNew = firstSplit[0].SplitCommas(true);
                                                            foreach (TokenHelperComma splitNewItem in splitNew)
                                                            {
                                                                string listName2 = HandleLabelsIsSimpleListName(splitNewItem.list);
                                                                if (listName2 != null)
                                                                {
                                                                    if (G.Equal(listName, listName2))
                                                                    {
                                                                        foundAsSumFunction = true;
                                                                        break;
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                    else if (firstSplit.storage.Count > 1)
                                                    {
                                                        string listName2 = HandleLabelsIsSimpleListName(firstSplit);
                                                        if (listName2 != null)
                                                        {
                                                            //handles sum(#i, ...)

                                                            if (G.Equal(listName, listName2))
                                                            {
                                                                foundAsSumFunction = true;
                                                                break;
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    parent = parent.parent;
                                }

                                if (!foundAsSumFunction)
                                {
                                    //We have a simple #x as this argument                                    
                                    //a free list has its string value put in
                                    if (counter >= iVariableList.Count)
                                    {
                                        return true;  //out of bounds, do not proceed. It seems we have more tokens found with {...} or x[...] than there are IVariables.
                                    }
                                    O.LabelHelperIVariable helper = iVariableList[counter];
                                    if (helper.index != ii)
                                    {
                                        //does not match the index position
                                        return true;
                                    }
                                    if (helper.iv.Type() == EVariableType.String)
                                    {
                                        HandleLabelsInsertIVariables(token, tokenListCommaSplit.list, O.ConvertToString(helper.iv));
                                    }
                                }
                                else
                                {
                                    //this is a bounded list, like sum(#i, x[#i]).
                                    //in that case, we just keep the #i.
                                }
                            }
                            else
                            {
                                //it is not a simple #x
                                if (counter >= iVariableList.Count)
                                {
                                    return true;  //out of bounds, do not proceed. It seems we have more tokens found with {...} or x[...] than there are IVariables.
                                }
                                O.LabelHelperIVariable helper = iVariableList[counter];
                                if (helper.index != ii)
                                {
                                    //does not match the index position
                                    return true;
                                }

                                if (helper.iv.Type() == EVariableType.String || helper.iv.Type() == EVariableType.Date || helper.iv.Type() == EVariableType.Val)
                                {
                                    HandleLabelsInsertIVariables(token, tokenListCommaSplit.list, ((ScalarString)Functions.tostring(null, null, null, helper.iv)).string2);
                                }
                            }

                        }

                    }
                    else
                    {
                        //The list only contains index values at the uppermost nesting level of [] or {} parentheses.
                        //But we handle sub-nests regarding ()-parentheses.
                        bool problem = HandleLabels(token.subnodes, level + 1, iVariableList, uncontrolledSimpleLists, ref counter);
                        if (problem)
                        {
                            return true;
                        }
                    }
                }
                else
                {
                    //s += th.leftblanks + th.s;
                }
            }
            if (level == 0 && (counter + 1 != iVariableList.Count)) //only when returning from the upmost level, where we can see if the numbers match.
            {
                return true;
            }
            return false;

        }

        private static string HandleLabelsIsSimpleListName(TokenList splitNewItem)
        {
            if (splitNewItem.storage.Count == 2 && splitNewItem[0].s == Globals.symbolCollection.ToString() && splitNewItem[1].type == ETokenType.Word)
            {
                return splitNewItem[1].s;
            }
            else return null;
        }

        private static void HandleLabelsInsertIVariables(TokenHelper th, TokenList temp2, string iv_string)
        {
            temp2[0].s = iv_string;
            temp2[0].type = ETokenType.Word;
            temp2[0].subnodes = null;
            for (int ii = 1; ii < temp2.storage.Count; ii++)
            {
                temp2[ii].s = "";
                temp2[ii].type = ETokenType.Unknown;
                temp2[ii].subnodes = null;
            }
            if (th.SubnodesType() == "{")
            {
                //Removing the '{'and '}'
                th.subnodes[0].s = "";
                th.subnodes[th.subnodes.storage.Count - 1].s = "";
            }
        }



        private static void PrintHelper2(List<O.PrtContainer> containerExplode, GekkoDictionary<string, bool> freqs, O.PrtContainer container, bool root, bool isRef, List<IVariable> errorList)
        {
            //TODO: what to do with ref, how to merge??? What if MULPRT {#m1}, and #m1 has different elements 


            if (container.variable[0] != null && container.variable[0].Type() == EVariableType.Series)
            {
                containerExplode.Add(container);
                PrintFreqHelper(freqs, container.variable[0]);  //the ref one should be same freq
            }
            else if (container.variable[0] != null && container.variable[0].Type() == EVariableType.Val)
            {
                containerExplode.Add(container);
            }
            else if (container.variable[0] != null && container.variable[0].Type() == EVariableType.Matrix && ((Matrix)container.variable[0]).data.Length == 1)  //an 1x1 matrix
            {
                containerExplode.Add(container);
            }
            else if (container.variable[0] != null && container.variable[0].Type() == EVariableType.List)
            {
                if (root)
                {
                    for (int i = 0; i < ((List)container.variable[0]).list.Count; i++)
                    {
                        O.PrtContainer c2 = new O.PrtContainer();
                        if (container.variable[0] != null) c2.variable[0] = ((List)container.variable[0]).list[i];
                        if (container.variable[0] != null) c2.variable[0] = ((List)container.variable[0]).list[i];
                        c2.label = container.label;
                        c2.operator2 = container.operator2;
                        PrintHelper2(containerExplode, freqs, c2, false, isRef, errorList);  //the counter is fixed
                    }
                }
            }
            else
            {
                errorList.Add(container.variable[0]);
            }
        }

        private static void PrintFreqHelper(GekkoDictionary<string, bool> freqs, IVariable iv)
        {
            if (((Series)iv).freq == EFreq.A) freqs["A"] = true;
            else if (((Series)iv).freq == EFreq.Q) freqs["Q"] = true;
            else if (((Series)iv).freq == EFreq.M) freqs["M"] = true;
        }


        private static bool HasIdenticalCodes(O.Prt o)
        {
            //a bit costly method, and the loop here is looped again later on, but this is not speed critical.
            bool identicalCodes = false;
            GekkoDictionary<string, string> temp = new GekkoDictionary<string, string>(StringComparer.OrdinalIgnoreCase);
            foreach (O.Prt.Element pe in o.prtElements)  //varI 0-based
            {
                List<string> operators = GetElementOperators(o, pe);
                foreach (string s in operators)
                {
                    if (!temp.ContainsKey(s)) temp.Add(s, "");
                }
            }
            if (temp.Count == 1) identicalCodes = true;
            return identicalCodes;
        }


        private static double CalculateAveragesForPrint(string operator2, List<double> filterMemoryValues, EPrtCollapseTypes collapse, int n)
        {
            double rv = double.NaN;
            if (Print.IsLevelOperator(operator2))
            {
                if (n == -12345)
                {
                    double start1 = 0d;
                    for (int i = 0; i < filterMemoryValues.Count; i++) start1 += filterMemoryValues[i];
                    rv = start1 / (double)filterMemoryValues.Count;
                }
                else
                {
                    if (filterMemoryValues.Count - n >= 0)
                    {
                        double start1 = 0d;
                        for (int i = filterMemoryValues.Count - n; i < filterMemoryValues.Count; i++) start1 += filterMemoryValues[i];
                        double den = (double)n;
                        if (collapse == EPrtCollapseTypes.Total) den = 1d;
                        rv = start1 / den;
                    }
                }
            }
            else
            {
                //percent print codes
                if (G.Equal(operator2, "p") || G.Equal(operator2, Globals.operator_rp))
                {
                    if (n == -12345)
                    {
                        double start1 = 1d;
                        for (int i = 0; i < filterMemoryValues.Count; i++) start1 *= 1 + filterMemoryValues[i] / 100d;
                        rv = (Math.Pow(start1, 1d / (double)filterMemoryValues.Count) - 1d) * 100d;
                    }
                    else
                    {
                        if (filterMemoryValues.Count - 2 * n >= 0)
                        {
                            int counter = 0;
                            double xa = 0;
                            double xb = 0;
                            double start1 = 1d;
                            for (int i = filterMemoryValues.Count - 2 * n; i < filterMemoryValues.Count; i++)
                            {
                                counter++;
                                start1 *= 1 + filterMemoryValues[i] / 100d;
                                if (counter <= n) xa += start1;
                                else if (counter >= n + 1) xb += start1;
                            }
                            rv = (xb / xa - 1d) * 100d;
                        }
                    }
                }
                else
                {
                    //#89074323455
                    //for instance q printcode, could be in MULPRT
                    rv = double.NaN;
                }

                //double start2 = 1d;
                //for (int i = 0; i < filterMemoryValues.Count; i++)
                //{
                //    start2 *= 1 + filterMemoryValues[i] / 100d;
                //}
                //rv = (Math.Pow(start2, 1d / (double)filterMemoryValues.Count) - 1d) * 100d;
            }
            return rv;
        }

        public static List<string> GetElementOperators(O.Prt o, O.Prt.Element ope)
        {
            List<string> operators = new List<string>();
            if (o.guiGraphOperator != null)
            {
                operators.Add(o.guiGraphOperator);
            }
            else
            {
                bool isGraph = false;
                bool isSheet = false;
                if (G.Equal(o.prtType, "plot")) isGraph = true;
                else if (G.Equal(o.prtType, "sheet")) isSheet = true;
                else if (G.Equal(o.prtType, "clip")) isSheet = true;

                bool isMulprt = Print.IsMulprt(o);

                operators.AddRange(GetSuperOperators(o)); //start with a fresh copy of super-printcodes

                if (!isMulprt && operators.Count == 1 && G.Equal(operators[0], "lev"))
                {
                    new Error("PRT<lev> is not legal: use PRT<abs> to print absolute levels");
                    //throw new GekkoException();
                }

                if (isMulprt && operators.Count == 1 && (G.Equal(operators[0], "dif") || G.Equal(operators[0], "diff")))
                {
                    new Error("MULPRT<dif> is not legal: use MULPRT<abs> to print multiplier differences");
                    //throw new GekkoException();
                }

                if (ope != null && ope.operators != null && ope.operators.Count > 0)
                {
                    //element-specific printcode overrides!
                    operators = new List<string>();
                    foreach (OptString ts in ope.operators)
                    {
                        //hmmm, what if there is a no after a yes for the same code????
                        if (G.Equal(ts.s2, "yes")) operators.Add(ts.s1);
                        else if (G.Equal(ts.s2, "no"))
                        {
                            //do not add
                        }
                        else
                        {
                            new Error("Operator = '" + ts.s2 + "' should be 'yes' or 'no'");
                            //throw new GekkoException();
                        }
                    }
                }
                operators = PrintGetOperatorsOLD(isMulprt, operators, isGraph, isSheet);
            }
            return operators;
        }

        private static List<string> GetSuperOperators(O.Prt o)
        {
            List<string> operatorsGlobal = new List<string>();
            foreach (OptString ts in o.operators)
            {
                //hmmm, what if there is a no after a yes for the same code????
                if (G.Equal(ts.s2, "yes"))
                {
                    operatorsGlobal.Add(ts.s1);
                }
                else if (G.Equal(ts.s2, "no"))
                {
                    operatorsGlobal.Add("no" + ts.s1);  //for instance 'nopch'
                }
                else if (G.Equal(ts.s2, "append"))
                {
                    operatorsGlobal.Add("_" + ts.s1);  //for instance '_lev'
                }
                else
                {
                    new Error("Operator = '" + ts.s2 + "' should be 'yes' or 'no' or 'append'");
                    //throw new GekkoException();
                }
            }
            return operatorsGlobal;
        }

        private static void SetGmulprtOperators(PrtHelper ph)
        {
            ph.operators.Clear();
            ph.operators.Add("n");
            ph.operators.Add("p");
            ph.operators.Add(Globals.operator_r);
            ph.operators.Add(Globals.operator_rp);
            ph.operators.Add("m");
            ph.operators.Add("q");
        }

        public static string GetXmlError(Exception e, string file)
        {
            string s = "The file seems to be invalid as regards XML syntax: ";
            if (e.InnerException != null) s += e.InnerException.Message;
            else s += e.Message;
            s += ".";
            return s;
        }

        private static void ChangeOperatorsToLower(PrtHelper ph)
        {
            if (ph.operators != null) ph.operators = ph.operators.ConvertAll(d => d.ToLower());
            foreach (PrtHelperElement phe in ph.elementOptions)
            {
                if (phe == null) continue;
                if (phe.operators == null) continue;
                phe.operators = phe.operators.ConvertAll(d => d.ToLower());
            }
        }

        public static string SetBlanks()
        {
            return G.NL + G.Blanks(200);
        }


        private static int PrintPrettify(O.Prt o, Table tab, int numberOfLabelsLinesMax, bool transpose, int maxLabelsLinesFound, bool identicalCodes, string oneOperatorLabel, int virtualRowsStart, int virtualRowsMaxSeen)
        {
            if (identicalCodes)  //put in general marker for whole table just over the period column (or left of it if transposed)
            {
                string s = "";
                if (o.operators.Count == 1) s = oneOperatorLabel;
                if (s != "")
                {
                    int ii = numberOfLabelsLinesMax + virtualRowsStart;
                    int jj = 1;
                    if (transpose)
                    {
                        ii = 1;
                        jj = numberOfLabelsLinesMax;
                    }
                    tab.Set(ii, jj, s);
                    if (!transpose)
                    {
                        tab.SetAlign(ii, jj, Align.Right);
                    }
                }
            }

            int difference = numberOfLabelsLinesMax - maxLabelsLinesFound;

            if (!transpose && difference > 0)
            {
                for (int i = 0; i < difference; i++)
                {
                    tab.DeleteRow(1 + virtualRowsStart);
                }
            }

            return virtualRowsMaxSeen - difference;
        }

        private static void NonExistenceError(List<string> nonExistenceErrors, string variableLabel, string variableName, string ss)
        {
            if (variableLabel != null && !G.Equal(variableName, variableLabel)) ss += ":   " + variableLabel;
            if (!nonExistenceErrors.Contains(ss)) nonExistenceErrors.Add(ss);
        }


        private static List<string> PrintGetOperatorsOLD(bool isMulprt, List<string> operators, bool isGraph, bool isSheet)
        {
            bool mul_lev = false;
            bool mul_abs = false;
            bool mul_pch = false;
            bool mul_gdif = false;
            bool abs = false;
            bool dif = false;
            bool pch = false;
            bool gdif = false;

            List<string> operatorsNew = null;
            //Range: ShortVersion, LongVersionHasYes, LongVersionHasAppend, LongVersionOnlyNo, None
            EOperatorTypes operatorType = GetOperatorType(operators);  //also performs validation that they are not mixed wrongly

            if (operatorType == EOperatorTypes.None || operatorType == EOperatorTypes.LongVersionHasYes || operatorType == EOperatorTypes.LongVersionHasAppend || operatorType == EOperatorTypes.LongVersionOnlyNo)
            {
                operatorsNew = new List<string>();
                PrintGetOperatorHelper2(isSheet, ref mul_lev, ref mul_abs, ref mul_pch, ref mul_gdif, ref abs, ref dif, ref pch, ref gdif);
                if (isGraph)
                {
                    mul_pch = false;  //probably never relavant, but for symmetry
                    pch = false;
                }

                if (operatorType == EOperatorTypes.LongVersionHasYes)  //then it may contain yes and no elements (but no append). The yes element clears all defaults, so no elements are not really interesting here since they will have no effect
                {
                    //clear them all
                    mul_lev = false;
                    mul_abs = false;
                    mul_pch = false;
                    mul_gdif = false;
                    abs = false;
                    dif = false;
                    pch = false;
                    gdif = false;
                }
                else
                {
                    //keep global option values for None, LongVersionHasAppend or LongVersionOnlyNo
                }
                bool levTest = false;
                bool absTest = false;
                bool difTest = false;
                bool pchTest = false;
                bool gdifTest = false;

                foreach (string operator2 in operators)
                {
                    if (isMulprt)  //MULPRT
                    {
                        if (operator2 == "lev" || operator2 == "_lev")
                        {
                            levTest = TestNoDuplicateDisplayCode(levTest, "lev");
                            mul_lev = true;
                        }
                        else if (operator2 == "nolev")
                        {
                            levTest = TestNoDuplicateDisplayCode(levTest, "lev");
                            mul_lev = false;
                        }
                        else if (operator2 == "abs" || operator2 == "_abs")
                        {
                            absTest = TestNoDuplicateDisplayCode(absTest, "abs");
                            mul_abs = true;
                        }
                        else if (operator2 == "noabs")
                        {
                            absTest = TestNoDuplicateDisplayCode(absTest, "abs");
                            mul_abs = false;
                        }
                        else if (operator2 == "pch" || operator2 == "_pch")
                        {
                            pchTest = TestNoDuplicateDisplayCode(pchTest, "pch");
                            mul_pch = true;
                        }
                        else if (operator2 == "nopch")
                        {
                            pchTest = TestNoDuplicateDisplayCode(pchTest, "pch");
                            mul_pch = false;
                        }
                        else if (operator2 == "gdif" || operator2 == "_gdif")
                        {
                            gdifTest = TestNoDuplicateDisplayCode(gdifTest, "gdif");
                            mul_gdif = true;
                        }
                        else if (operator2 == "nogdif")
                        {
                            gdifTest = TestNoDuplicateDisplayCode(gdifTest, "gdif");
                            mul_gdif = false;
                        }
                    }
                    else  //normal PRT
                    {
                        if (operator2 == "abs" || operator2 == "_abs")
                        {
                            absTest = TestNoDuplicateDisplayCode(absTest, "abs");
                            abs = true;
                        }
                        else if (operator2 == "noabs")
                        {
                            absTest = TestNoDuplicateDisplayCode(absTest, "abs");
                            abs = false;
                        }
                        else if (operator2 == "dif" || operator2 == "_dif")
                        {
                            difTest = TestNoDuplicateDisplayCode(difTest, "dif");
                            dif = true;
                        }
                        else if (operator2 == "nodif")
                        {
                            difTest = TestNoDuplicateDisplayCode(difTest, "dif");
                            dif = false;
                        }
                        else if (operator2 == "pch" || operator2 == "_pch")
                        {
                            pchTest = TestNoDuplicateDisplayCode(pchTest, "pch");
                            pch = true;
                        }
                        else if (operator2 == "nopch")
                        {
                            pchTest = TestNoDuplicateDisplayCode(pchTest, "pch");
                            pch = false;
                        }
                        else if (operator2 == "gdif" || operator2 == "_gdif")
                        {
                            gdifTest = TestNoDuplicateDisplayCode(gdifTest, "gdif");
                            gdif = true;
                        }
                        else if (operator2 == "nogdif")
                        {
                            gdifTest = TestNoDuplicateDisplayCode(gdifTest, "gdif");
                            gdif = false;
                        }
                    }
                }
                if (isMulprt)
                {
                    //will always be in {n,m,q,mp} order
                    if (mul_lev) operatorsNew.Add("n");
                    if (mul_abs) operatorsNew.Add("m");
                    if (mul_pch) operatorsNew.Add("q");
                    if (mul_gdif) operatorsNew.Add("mp");
                }
                else
                {
                    //will always be in {n,d,p,dp} order
                    if (abs) operatorsNew.Add("n");
                    if (dif) operatorsNew.Add("d");
                    if (pch) operatorsNew.Add("p");
                    if (gdif) operatorsNew.Add("dp");
                }
            }
            else
            {
                if (!isMulprt && !isGraph && operators.Count == 1 && G.Equal(operators[0], "r"))
                {
                    //PRT<r> or SHEET/CLIP<r>
                    PrintGetOperatorHelper2(isSheet, ref mul_lev, ref mul_abs, ref mul_pch, ref mul_gdif, ref abs, ref dif, ref pch, ref gdif);
                    operatorsNew = new List<string>();
                    if (abs) operatorsNew.Add("rn");
                    if (dif) operatorsNew.Add("rd");
                    if (pch) operatorsNew.Add("rp");
                    if (gdif) operatorsNew.Add("rdp");
                }
                else
                {
                    operatorsNew = operators;  //point to same object
                }
            }
            return operatorsNew;
        }

        private static void PrintGetOperatorHelper2(bool isSheet, ref bool mul_lev, ref bool mul_abs, ref bool mul_pch, ref bool mul_gdif, ref bool abs, ref bool dif, ref bool pch, ref bool gdif)
        {
            if (isSheet)
            {
                //In this case, the printcodes are transformed to the short format
                mul_lev = Program.options.sheet_mulprt_lev;
                mul_abs = Program.options.sheet_mulprt_abs;
                mul_pch = Program.options.sheet_mulprt_pch;
                mul_gdif = Program.options.sheet_mulprt_gdif;
                abs = Program.options.sheet_prt_abs;
                dif = Program.options.sheet_prt_dif;
                pch = Program.options.sheet_prt_pch;
                gdif = Program.options.sheet_prt_gdif;
            }
            else
            {
                mul_lev = Program.options.print_mulprt_lev;
                mul_abs = Program.options.print_mulprt_abs;
                mul_pch = Program.options.print_mulprt_pch;
                mul_gdif = Program.options.print_mulprt_gdif;
                abs = Program.options.print_prt_abs;
                dif = Program.options.print_prt_dif;
                pch = Program.options.print_prt_pch;
                gdif = Program.options.print_prt_gdif;
            }
        }

        private static void PrintGetWithAndDecimals(O.Prt o, int varI, List<string> operatorsNew, List<int> widths, List<int> decs)
        {
            foreach (string operator2 in operatorsNew)
            {
                int width = -12345;
                int dec = -12345;
                bool isPchType = false;
                if (Print.IsLevelOperator(operator2))
                {
                    isPchType = false;
                    width = options.print_fields_nwidth;
                    dec = options.print_fields_ndec;
                }
                else
                {
                    isPchType = true;
                    width = options.print_fields_pwidth;
                    dec = options.print_fields_pdec;
                    if (operator2 == Globals.operator_dl || operator2 == Globals.operator_rdl) dec = dec + 2;
                }

                // ---------------------------------------------
                // --- Width -----------------------------------
                // ---------------------------------------------
                if (o.opt_width != -12345) width = (int)o.opt_width;
                if (isPchType)
                {
                    //overrides ph.width if given
                    if (o.opt_pwidth != -12345) width = (int)o.opt_pwidth;
                }
                else
                {
                    //overrides ph.width if given
                    if (o.opt_nwidth != -12345) width = (int)o.opt_nwidth;
                }

                //element-specific stuff
                if (o.prtElements[varI] != null && o.prtElements[varI].width != -12345) width = o.prtElements[varI].width;   //element-specific width overrides!
                if (isPchType)
                {
                    //overrides ph.width if given
                    if (o.prtElements[varI] != null && o.prtElements[varI].pwidth != -12345) width = o.prtElements[varI].pwidth;
                }
                else
                {
                    //overrides ph.width if given
                    if (o.prtElements[varI] != null && o.prtElements[varI].nwidth != -12345) width = o.prtElements[varI].nwidth;
                }


                // ---------------------------------------------
                // --- Decimals --------------------------------
                // ---------------------------------------------
                if (o.opt_dec != -12345) dec = (int)o.opt_dec;
                if (isPchType)
                {
                    //overrides ph.dec if given
                    if (o.opt_pdec != -12345) dec = (int)o.opt_pdec;
                }
                else
                {
                    //overrides ph.dec if given
                    if (o.opt_ndec != -12345) dec = (int)o.opt_ndec;
                }

                //element-specific stuff
                if (o.prtElements[varI] != null && o.prtElements[varI].dec != -12345) dec = o.prtElements[varI].dec;   //element-specific dec overrides!
                if (isPchType)
                {
                    //overrides ph.dec if given
                    if (o.prtElements[varI] != null && o.prtElements[varI].pdec != -12345) dec = o.prtElements[varI].pdec;
                }
                else
                {
                    //overrides ph.dec if given
                    if (o.prtElements[varI] != null && o.prtElements[varI].ndec != -12345) dec = o.prtElements[varI].ndec;
                }


                widths.Add(width);
                decs.Add(dec);
            }
        }



        private static bool HasIdenticalCodes(List<string> graphVars, PrtHelper ph)
        {
            bool identicalCodes = true;
            for (int varI = 0; varI < graphVars.Count; varI++)  //varI 0-based
            {
                if (ph.elementOptions[varI] != null)
                {
                    identicalCodes = false;
                    break;
                }
            }
            if (ph.operators.Count > 1) identicalCodes = false;
            if (ph.operators.Count == 1)
            {
                string s = ph.operators[0];
                if (IsOperatorLongAppend(s)) identicalCodes = false;
                if (IsOperatorLongNo(s)) identicalCodes = false;
            }
            return identicalCodes;
        }

        private static bool HasIdenticalCodesNew(List<Series> graphVars, PrtHelper ph)
        {
            bool identicalCodes = true;
            for (int varI = 0; varI < graphVars.Count; varI++)  //varI 0-based
            {
                if (ph.elementOptions[varI] != null)
                {
                    identicalCodes = false;
                    break;
                }
            }
            if (ph.operators.Count > 1) identicalCodes = false;
            if (ph.operators.Count == 1)
            {
                string s = ph.operators[0];
                if (IsOperatorLongAppend(s)) identicalCodes = false;
                if (IsOperatorLongNo(s)) identicalCodes = false;
            }
            return identicalCodes;
        }

        private static bool TestNoDuplicateDisplayCode(bool variable, string name)
        {
            if (variable)
            {
                new Error("There are more than one '" + name + "' display codes");
            }
            variable = true;
            return variable;
        }

        private static EOperatorTypes GetOperatorType(List<string> operators)
        {
            EOperatorTypes operatorType = EOperatorTypes.Null;
            bool isVerbose = false;
            foreach (string operator2 in operators)
            {
                if (IsOperatorLong(operator2))
                {
                    if (operatorType == EOperatorTypes.LongVersionHasAppend)
                    {
                        WriteOperatorMismatchError();
                    }
                    operatorType = EOperatorTypes.LongVersionHasYes;
                }
                else if (IsOperatorLongAppend(operator2))
                {
                    if (operatorType == EOperatorTypes.LongVersionHasYes)
                    {
                        WriteOperatorMismatchError();
                    }
                    operatorType = EOperatorTypes.LongVersionHasAppend;
                }
                else if (IsOperatorLongNo(operator2))
                {
                    if (operatorType == EOperatorTypes.Null)
                    {
                        //do not override if others are found
                        operatorType = EOperatorTypes.LongVersionOnlyNo;
                    }
                }
                else if (IsOperatorShort(operator2))
                {
                    if (operatorType == EOperatorTypes.LongVersionHasAppend || operatorType == EOperatorTypes.LongVersionHasYes || operatorType == EOperatorTypes.LongVersionOnlyNo)
                    {
                        using (Error e = new Error()) {
                            e.MainAdd("You cannot mix display codes of short and long type, for example");
                            e.MainAdd("PRT <p abs> or PRT<d pch=no> etc. Please consult the help file regarding");
                            e.MainAdd("the PRT and MULPRT commands. Short types are n, d, p, m, q, mp and");
                            e.MainAdd("similar, whereas long types are lev, abs, dif, pch, gdif.");
                        }
                    }
                    operatorType = EOperatorTypes.ShortVersion;
                }
                else if (G.Equal(operator2, "v"))
                {
                    //in that case, all other print options are suppressed, so you can write MULPRT<v gdif> and only a MULPRT<v> will be issued (this makes it easier to quickly put a 'v' in the optionfield to get a GMULPRT)
                    isVerbose = true;
                }
                else
                {
                    new Error("Sorry, internal Gekko error related to operator");
                }
            }
            if (operators.Count == 0)
            {
                operatorType = EOperatorTypes.None;
            }
            if (isVerbose) operatorType = EOperatorTypes.Verbose;  //overrides everything else
            if (operatorType == EOperatorTypes.Null)
            {
                new Error("Sorry, internal Gekko error related to display codes");
            }
            return operatorType;
        }

        public static bool IsOperatorShort(string operator2)
        {
            return G.Equal(operator2, "n") || G.Equal(operator2, "d") || G.Equal(operator2, "p") || G.Equal(operator2, "dp") || G.Equal(operator2, Globals.operator_r) || G.Equal(operator2, Globals.operator_rn) || G.Equal(operator2, Globals.operator_rd) || G.Equal(operator2, Globals.operator_rp) || G.Equal(operator2, Globals.operator_rdp) || G.Equal(operator2, "m") || G.Equal(operator2, "q") || G.Equal(operator2, "mp") || G.Equal(operator2, Globals.operator_l) || G.Equal(operator2, Globals.operator_dl) || G.Equal(operator2, Globals.operator_rl) || G.Equal(operator2, Globals.operator_rdl);
        }

        public static bool IsOperatorShortMultiplier(string operator2)
        {
            return G.Equal(operator2, "m") || G.Equal(operator2, "q") || G.Equal(operator2, "mp") || G.Equal(operator2, "v");
        }

        public static bool IsOperatorShortBase(string operator2)
        {
            return G.Equal(operator2, Globals.operator_r) || G.Equal(operator2, Globals.operator_rn) || G.Equal(operator2, Globals.operator_rd) || G.Equal(operator2, Globals.operator_rp) || G.Equal(operator2, Globals.operator_rdp) || G.Equal(operator2, Globals.operator_rl) || G.Equal(operator2, Globals.operator_rdl);
        }

        public static bool IsOperatorShortWork(string operator2)
        {
            return operator2 == null || G.Equal(operator2, "") || G.Equal(operator2, "n") || G.Equal(operator2, "d") || G.Equal(operator2, "p") || G.Equal(operator2, "dp") || G.Equal(operator2, Globals.operator_l) || G.Equal(operator2, Globals.operator_dl);
        }

        private static bool IsOperatorLongNo(string operator2)
        {
            return G.Equal(operator2, "nolev") || G.Equal(operator2, "noabs") || G.Equal(operator2, "nodif") || G.Equal(operator2, "nopch") || G.Equal(operator2, "nogdif");
        }

        private static bool IsOperatorLongAppend(string operator2)
        {
            return G.Equal(operator2, "_lev") || G.Equal(operator2, "_abs") || G.Equal(operator2, "_dif") || G.Equal(operator2, "_pch") || G.Equal(operator2, "_gdif");
        }

        private static bool IsOperatorLong(string operator2)
        {
            return G.Equal(operator2, "lev") || G.Equal(operator2, "abs") || G.Equal(operator2, "dif") || G.Equal(operator2, "pch") || G.Equal(operator2, "gdif");
        }

        private static void WriteOperatorMismatchError()
        {
            new Error("You cannot mix display codes of type 'yes' and 'append', for instance PRT<pch=yes gdif=append> or the equivalent PRT<pch _gdif>");
        }

        public static void PrtClipboard(Table table, bool calledFromCopyButton)
        {
            if (table == null)
            {
                new Error("No print or table recorded to put on clipboard");
            }
            StringBuilder s = new StringBuilder();

            for (int i = 1; i <= table.GetRowMaxNumber(); i++)
            {
                if (i > 1) s.Append("\n");
                for (int j = 1; j <= table.GetColMaxNumber(); j++)
                {
                    Cell cell2 = table.Get(i, j);
                    string s2 = "";
                    if (cell2 == null)
                    {
                    }
                    else
                    {
                        if (cell2.cellType == CellType.Number)
                        {
                            s2 = PrepareDataForClipboard(cell2.number);
                        }
                        else if (cell2.cellType == CellType.Date)
                        {
                            s2 = cell2.date;
                        }
                        else if (cell2.cellType == CellType.Text)
                        {
                            s2 = cell2.CellText.TextData[0];
                        }
                    }
                    if (j > 1) s.Append("\t");
                    s.Append(s2);
                }
            }
            string ss = s.ToString();
            if (ss != null && ss != "")
            {
                System.Windows.Forms.Clipboard.SetText(ss, System.Windows.Forms.TextDataFormat.Text);
                G.Writeln2("You may now paste (Ctrl-V) cells into your spreadsheet (e.g. Excel)");
                if (calledFromCopyButton)
                {
                    G.Writeln("These are the cells from your last PRT/MULPRT/SHOW or table.");
                }
            }
        }

        public static void PrtToExcelDna(Table table, bool isMulprt, bool isStamp, string title)
        {            
            int extraRows = 0;
            if (isStamp) extraRows++;
            if (title != null) extraRows++;

            int rowsOffset = 0; //not used yet
            int colOffset = 0; //not used yet

            object[,] cells = new object[table.GetRowMaxNumber() + rowsOffset + extraRows, table.GetColMaxNumber() + colOffset];

            int extra = 0;
            if (isStamp)
            {
                cells[extra, 0] = GetStamp(isMulprt);
                extra++;
            }
            if (title != null)
            {
                cells[extra, 0] = title;
            }

            for (int i = 0; i < table.GetRowMaxNumber(); i++)
            {
                for (int j = 0; j < table.GetColMaxNumber(); j++)
                {
                    Cell cell2 = table.Get(i + 1, j + 1);
                    string s2 = "";
                    if (cell2 == null)
                    {
                        //skip
                    }
                    else
                    {
                        int ii = i + rowsOffset + extraRows;
                        int jj = j + colOffset;
                        if (cell2.cellType == CellType.Number)
                        {
                            cells[ii, jj] = cell2.number;
                        }
                        else if (cell2.cellType == CellType.Date)
                        {
                            cells[ii, jj] = cell2.date;
                        }
                        else if (cell2.cellType == CellType.Text)
                        {
                            cells[ii, jj] = cell2.CellText.TextData[0];
                        }
                    }
                }
            }

            Globals.excelDnaData = new ExcelDnaData { cells = cells };
        }

        /// <summary>
        /// Format a double for use as string on clipboard. Respects Program.options.interface_clipboard_decimalseparator.
        /// When pasting to Excel, make sure that decimalseparator there conforms to Program.options.interface_clipboard_decimalseparator,
        /// and also that 1000-separator is the inverse value. Otherwise it is chaos.
        /// </summary>
        /// <param name="d2"></param>
        /// <returns></returns>
        public static string PrepareDataForClipboard(double d2)
        {
            string s2 = null;            
            s2 = d2.ToString(CultureInfo.InvariantCulture);  //should always be "." with this locale corresponding to US style (is used also for PRT etc)
            
            if (s2.Contains(",") && s2.Contains("."))
            {
                if (s2.IndexOf(",") < s2.IndexOf("."))
                {
                    //we have at least one "____,____.____", so at least one "," to the left of "."
                    //then we remove the ",", for instance in 12,345,678.22 --> 12345678.22
                    //(If it should happen to be 12.345.678,22 then we would not be here)
                    s2 = s2.Replace(",", "");
                }
            }

            //now s2 should be with "." if there is a decimal (and no thousand grouping)

            if (G.Equal(Program.options.interface_clipboard_decimalseparator, "comma"))
            {
                s2 = s2.Replace(".", ",");
            }
            if (s2 == "9.99999E+99" || s2 == "9,99999E+99"  //I think this is funny number made in Excel printing routine, to signal missing value
                || G.isNumericalError(d2) || d2 == Globals.missingVariableArtificialNumber)  //NumericalError is 'M', and the number Globals.missingVariableArtificialNumber is a signal from a table that variable is non-existing ('N')
            {
                s2 = "=" + NaForExcelInDifferentLanguages(0);
            }
            return s2;
        }

        private static string NaForExcelInDifferentLanguages(int i)
        {
            string s2 = null;
            if (i == 0)
            {
                s2 = "na()";
                if (G.Equal(Program.options.interface_excel_language, "danish")) s2 = "ikke.tilgængelig()";
                return s2;
            }
            else if (i == 1)
            {
                s2 = "na()";
            }
            return s2;
        }

        public static DataTable GetDataTable(IVariable input)
        {
            int decimals = 4; //TODO, depend on PRT settings

            DataTable dt = new DataTable();

            List m1 = input as List;
            if (m1 == null)
            {
                dt.Columns.Add("1", typeof(string));
                var dtRow = dt.NewRow();                
                dtRow[0] = GetText(input, decimals);
                dt.Rows.Add(dtRow);
                return dt;
            }
                        
            int maxCols = 1;
            int i = -1;
            foreach (IVariable iv in m1.list)
            {
                i++;
                List iv2 = iv as List;                
                if (iv2 != null && iv2.Count() > maxCols) maxCols = iv2.Count();
            }
            
            for (int ii = 0; ii < maxCols; ii++)
            {
                dt.Columns.Add("" + (ii + 1) + "", typeof(string));
            }

            i = -1;
            foreach (IVariable x2 in m1.list)  //we know m1 is a list
            {
                i++;
                var dtRow = dt.NewRow();
                if (x2.Type() != EVariableType.List)
                {
                    dtRow[0] = GetText(x2, decimals);
                }
                else
                {
                    List m2 = x2 as List;
                    int j = -1;
                    foreach (IVariable x3 in m2.list)
                    {
                        j++;
                        string s = null;
                        s = GetText(x3, decimals);
                        dtRow[j] = s;
                    }
                }
                //add the row *after* populating it (else slow)
                dt.Rows.Add(dtRow);
            }
            return dt;
        }

        private static string GetText(IVariable x3, int decimals)
        {
            string s;
            if (x3.Type() == EVariableType.String)
            {
                s = ((ScalarString)x3).string2;
            }
            else if (x3.Type() == EVariableType.Date)
            {
                s = ((ScalarDate)x3).date.ToString();
            }
            else if (x3.Type() == EVariableType.Val)
            {
                s = G.UpdprtFormat(((ScalarVal)x3).val, decimals, false);
            }
            else
            {
                s = "[" + x3.Type().ToString().ToLower() + "]";
            }

            return s;
        }

        //public static DataTable GetDataTable(IVariable input)
        //{
        //    DataTable dt = new DataTable();

        //    List m1 = input as List;
        //    if (m1 == null) new Error("The variable is not a list");

        //    int maxCols = 1;
        //    int i = -1;
        //    foreach (IVariable iv in m1.list)
        //    {
        //        i++;
        //        List iv2 = iv as List;
        //        if (iv2 == null) new Error("Sub-element #" + (i + 1) + " is not a (sub)list");
        //        if (iv2.Count() > maxCols) maxCols = iv2.Count();
        //    }

        //    for (int ii = 0; ii < maxCols; ii++)
        //    {
        //        dt.Columns.Add("  dim" + (ii + 1) + "  ", typeof(string));
        //    }

        //    i = -1;
        //    foreach (IVariable x2 in m1.list)
        //    {
        //        i++;
        //        var dtRow = dt.NewRow();
        //        List m2 = x2 as List;
        //        int j = -1;
        //        foreach (IVariable x3 in m2.list)
        //        {
        //            j++;
        //            string s = null;
        //            ScalarString ss = x3 as ScalarString;
        //            s = ss.string2;
        //            //try
        //            //{
        //            //    s = x3.ConvertToString();
        //            //}
        //            //catch
        //            //{
        //            //    new Error("Element " + (i + 1) + ", " + (j + 1) + "");
        //            //}

        //            dtRow[j] = "  " + s + "  ";
        //        }
        //        //add the row *after* populating it (else slow)
        //        dt.Rows.Add(dtRow);
        //    }
        //    return dt;
        //}


        public static void GraphThreadFunction(Object o)
        {
            GraphOptions graphOptions = (GraphOptions)o;
            Graph g = new Graph(graphOptions);
            Globals.windowsGraph.Add(g);
            if (true)
            {
                //otherwise, setting them checked = true fires a redraw event
                Globals.disableRationButtons = 1;
                g.radioButton1.Checked = graphOptions.po.isLevel;
                g.radioButton2.Checked = graphOptions.po.isLog;
                g.radioButton5.Checked = graphOptions.po.isDiff;
                g.radioButton3.Checked = graphOptions.po.isPch;
                g.radioButton8.Checked = graphOptions.po.isDlog;
                g.checkBox1.Checked = graphOptions.po.isMultiplier;
                Globals.disableRationButtons = 0;
            }

            g.ShowDialog();
            graphOptions.windowIsShown = true;

            //end of graph window
            g.Close();
            g.Dispose();
            g = null;
        }

        private static void MaybeStartPipe2(string fileName)
        {
            if (fileName != null && fileName != "" && !Globals.pipe2)  //is piped to special pipe-file (pipe2), and not already piping to pipe2 (could be case if called via DIFPRT for example)
            {
                //if exception, these will be reset somewhere else, so no need to have a try-catch-finally regarding the file stream
                Globals.pipe2 = true;
                Globals.pipeFileHelper2.pipeFileFileWithPath = CreateFullPathAndFileName(fileName);
                Globals.pipeFileHelper2.pipeFile = G.GekkoStreamWriter(WaitForFileStream(Globals.pipeFileHelper2.pipeFileFileWithPath, null, GekkoFileReadOrWrite.Write));
            }
        }


        private static string SubstituteEscapeCharacters(string s, bool fromEscapeToArtificialChars)
        {
            if (false)
            {
                //Problem is for instance: "READ c:\folders\#bankname\scenarion"
                //This will be seen a lot.
                //what about &lbrace;  &rbrace;  &hash;
                //or &lbrace$  &rbrace$  &hash$
                //or &lbrace&  &rbrace&  &hash&
                //or {{  }}  ##

                if (fromEscapeToArtificialChars)
                {
                    s = s.Replace("\\{", "<[LEFTCURLY]>");
                    s = s.Replace("\\}", "<[RIGHTCURLY]>");
                    s = s.Replace("\\#", "<[HASHCHARACTER]>");
                    //s = s.Replace("\\'", "<[QUOTE]>");
                }
                else
                {
                    s = s.Replace("<[LEFTCURLY]>", "{");
                    s = s.Replace("<[RIGHTCURLY]>", "}");
                    s = s.Replace("<[HASHCHARACTER]>", "#");
                    //s = s.Replace("<[QUOTE]>", "'");
                }
            }
            return s;
        }

        private static List<string> ExtractEndoExoIndicators(List<string> variables, List<Dictionary<string, string>> precedents)
        {
            List<string> endoExoIndicators = new List<string>();
            for (int i = 0; i < precedents.Count; i++)
            {
                string var = "";
                string endoExo = "";
                Dictionary<string, string> d = precedents[i];

                bool endo = true;
                bool exo = true;
                foreach (string s in d.Keys)
                {
                    string varWithoutLag = G.ExtractOnlyVariableIgnoreLag(s);
                    if (varWithoutLag.StartsWith("@")) varWithoutLag = varWithoutLag.Substring(1);
                    EEndoOrExo type = VariableTypeEndoExo(varWithoutLag);
                    if (type != EEndoOrExo.Endo) endo = false;
                    if (type != EEndoOrExo.Exo) exo = false;
                }
                if (endo)
                {
                    endoExo = "e";
                }
                else if (exo)
                {
                    endoExo = "x";
                }
                else endoExo = " ";
                endoExoIndicators.Add(endoExo);
            }
            if (endoExoIndicators.Count != variables.Count) throw new GekkoException();  //sanity check
            return endoExoIndicators;
        }



        private static void AddListToPrecedentsEtc(List<string> variables, List<string> variablesLabels, List<Dictionary<string, string>> precedents, List<string> unfolded)
        {
            foreach (string listItem in unfolded)
            {
                variables.Add(listItem);
                variablesLabels.Add(listItem);
                Dictionary<string, string> precedentsTemp = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
                precedentsTemp.Add(listItem + Globals.lagIndicator + "0", "");
                precedents.Add(precedentsTemp);
            }
        }

        public static void CreateLeftSideVariableIfNeeded(List<Dictionary<string, string>> precedentsWithLagIndicator, string variable)
        {            
            if (Program.databanks.GetFirst().GetIVariable(variable) == null)
            {
                if (!variable.ToLower().StartsWith("xx"))
                {
                    IssueCreateWarning(variable);
                }
                new Note("Variable " + variable + " not found in databank -- is created");
                Series tempTs = new Series(Program.options.freq, variable);
                Program.databanks.GetFirst().AddIVariable(tempTs.name, tempTs);

                for (int i = 0; i < precedentsWithLagIndicator.Count; i++)
                {
                    Dictionary<string, string> d = precedentsWithLagIndicator[i];
                    foreach (string prec in d.Keys)
                    {
                        string variable2 = "";
                        int lag = 0;

                        if (prec.Contains(Globals.lagIndicator + Globals.lagIndicator))
                        {
                            //drop to issue this warning if this is the case: genr nyvar = nyvar(2001m1) $
                            //that will give NaN with no warning/explanation given.
                        }
                        else
                        {
                            G.ExtractVariableAndLag(prec, out variable2, out lag);
                            if (G.Equal(variable, variable2) && lag != 0)
                            {
                                new Warning("The non-existing variable " + variable + " appears with lag or leads on right hand side -- so this will produce missing values");
                                break;
                            }
                        }
                    }
                }
            }
        }

        private static void IssueCreateWarning(string variable)
        {
            new Error("You are trying to put data into a variable or list ('" + variable + "') that does not exist. Please create the variable or list first (CREATE or LIST command), or use a name that starts with the characters 'xx'.", false);
        }

        public static EMissingType CheckVariableExistence(List<string> variablesLabelsForPrtCommand, List<Dictionary<string, string>> precedents, bool isMultiplier, bool isCalledFromGenr, bool isBaseline, bool isCalledFromTable)
        {
            if (!(G.Equal(Program.databanks.GetFirst().name, Globals.Work) && G.Equal(Program.databanks.GetRef().name, Globals.Ref)))
            {
                new Error("Please use Work and " + Globals.Ref + " as first and reference databanks");
                //throw new GekkoException();
            }
            //In the method below, any memory vars of VAL type will be removed
            //if (isCalledFromGenr) SubstituteAssignVarsInPrecedents(precedents);  //a bit slow for GENR maybe... for PRT etc. it has already been called when this method is called
            bool hasIssuedWarning = false;
            Dictionary<string, string> problem = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
            for (int i = 0; i < precedents.Count; i++)
            {
                Dictionary<string, string> d = precedents[i];
                foreach (string s in d.Keys)
                {
                    List<string> banks = new List<string>();

                    string varWithBaseBankIndicator = G.ExtractOnlyVariableIgnoreLag(s);  //TODO: will produce dublets if "p fy/fy(-1)" or "p fy fm/fy" , but never mind now

                    string[] split = null;
                    if (varWithBaseBankIndicator.Contains(":"))
                    {
                        //p<m>adam:fy
                        split = varWithBaseBankIndicator.Split(':');
                        banks.Add(split[0]);
                    }
                    else
                    {

                        if (isMultiplier)
                        {
                            if (varWithBaseBankIndicator.StartsWith("@"))
                            {
                                //p<m>@fy                --------- this is not really meaningful
                                banks.Add(Globals.Ref);
                                if (!hasIssuedWarning) new Warning("Note that you are using @-variables in combination with the <m> (multiplier) option");
                                hasIssuedWarning = true;
                            }
                            else
                            {
                                //p<m>fy
                                banks.Add(Globals.Work);
                                banks.Add(Globals.Ref);
                            }
                        }
                        else
                        {
                            if (isBaseline)
                            {
                                if (varWithBaseBankIndicator.StartsWith("@"))
                                {
                                    //p<b>@fy                --------- this is not really meaningful
                                    banks.Add(Globals.Ref);
                                    if (!hasIssuedWarning) new Warning("Note that you are using @-variables in combination with the <r> (reference) option");
                                    hasIssuedWarning = true;
                                }
                                else
                                {
                                    //p<b>fy
                                    banks.Add(Globals.Ref);
                                }
                            }
                            else
                            {
                                if (varWithBaseBankIndicator.StartsWith("@"))
                                {
                                    //p @fy
                                    banks.Add(Globals.Ref);
                                }
                                else
                                {
                                    //p fy
                                    banks.Add(Globals.Work);
                                }
                            }
                        }
                    }

                    string variableName = varWithBaseBankIndicator;
                    if (variableName.StartsWith("@"))
                    {
                        variableName = variableName.Substring(1);
                    }
                    else if (varWithBaseBankIndicator.Contains(":"))
                    {
                        variableName = split[1];
                    }

                    foreach (string bank in banks)
                    {
                        bool noBank = false;
                        if (Program.databanks.GetDatabank(bank) == null) noBank = true;
                        if (noBank || Program.databanks.GetDatabank(bank).GetIVariable(variableName) == null)
                        {
                            if (!problem.ContainsKey(varWithBaseBankIndicator))
                            {
                                problem.Add(varWithBaseBankIndicator, "");
                                string ss = "";
                                if (variablesLabelsForPrtCommand != null && !G.Equal(variableName, variablesLabelsForPrtCommand[i])) ss = " -- " + variablesLabelsForPrtCommand[i];
                                if (isCalledFromTable && Program.options.series_normal_table_missing != ESeriesMissing.Error)
                                {
                                }
                                else
                                {
                                    using (Error e = new Error())
                                    {
                                        e.MainAdd("Could not find variable '" + variableName + "' (freq = " + Program.options.freq + ") in '" + bank + "' databank" + ss);
                                        if (noBank)
                                        {
                                            e.MainAdd("The databank '" + bank + "' does not seem to exist");
                                        }
                                        e.ThrowNoException();
                                    }
                                }
                            }
                        }
                    }
                }
            }
            if (isCalledFromTable && Program.options.series_normal_table_missing != ESeriesMissing.Error)
            {
                if (problem.Count > 0)
                {
                    return EMissingType.HasMissingVariables;
                }
                else
                {
                    return EMissingType.Ok;
                }
            }
            else
            {
                if (problem.Count > 0)
                {
                    throw new GekkoException();
                }
            }
            return EMissingType.Ok;
        }


        private static void PrintFirstLineLabels(List<string> rememberWriteStatements, List<string> graphVarsLabels, PrintHelper ph, int numberOfLabelsRows, string[,] labelsArray, List<string> endoExoIndicators)
        {
            for (int i2 = 0; i2 < numberOfLabelsRows; i2++)
            {
                string line = "";
                int i = numberOfLabelsRows - i2 - 1;  //the labels in labelsArray are in reverted order.
                line += G.Blanks(ph.widthDate);
                for (int j = 0; j < graphVarsLabels.Count; j++)
                {
                    line += "  " + G.Blanks(ph.widthLabel - labelsArray[i, j].Length) + labelsArray[i, j];
                    if (ph.width2 > 0)
                    {
                        if (i == 0)
                        {
                            if (endoExoIndicators[j] == " ")
                            {
                                line += "  %";
                            }
                            else
                            {
                                line += " " + "%" + endoExoIndicators[j].ToUpper();
                            }
                        }
                        else
                        {
                            line += "   ";
                        }
                    }
                }
                rememberWriteStatements.Add(line);
            }
        }

        public static string TruncateTextWithDots(int maxLength, string ss)
        {
            if (ss == null) return ss;
            if (ss.Length > maxLength)
            {
                if (maxLength >= 3)
                {
                    ss = ss.Substring(0, maxLength - 3);
                    ss += "...";
                }
                else ss = ss.Substring(0, maxLength);   //almost absurd... maxlength should always be >= 3 (typically 100)
            }

            return ss;
        }

        private static int PrintCreateLabelsArray(List<string> graphVarsLabels, PrintHelper ph, int numberOfLabelsRowsMax, int numberOfLabelsRows, int maxLength, string[,] labelsArray)
        {
            for (int j = 0; j < graphVarsLabels.Count; j++)
            {
                string label = graphVarsLabels[j];
                string ss = label;
                if (ss.Length > maxLength)
                {
                    if (maxLength >= 3)
                    {
                        ss = ss.Substring(0, maxLength - 3);
                        ss += "...";
                    }
                    else ss = ss.Substring(0, maxLength);   //almost absurd... maxlength should always be >= 3 (typically 100)
                }
                for (int i = 0; i < numberOfLabelsRowsMax; i++)
                {
                    //chopping off text backwards
                    int start = ss.Length - ph.widthLabel;
                    string s = "";
                    if (start >= 0)
                    {
                        s = ss.Substring(start);
                        ss = ss.Substring(0, ss.Length - s.Length);  //cropping s off
                    }
                    else
                    {
                        if (ss.Length > 0) s = ss;
                        ss = "";
                    }
                    labelsArray[i, j] = s;
                    if (labelsArray[i, j] != "")
                    {
                        if (i + 1 > numberOfLabelsRows) numberOfLabelsRows = i + 1;
                    }
                }
            }
            return numberOfLabelsRows;
        }



        public static double ParseIntoDouble(string x)
        {
            double y = double.NaN;
            if (x != null)
            {
                if (!G.TryParseIntoDouble(x, out y))
                {
                    new Error("Could not parse '" + x + "' as a number");
                    //throw new GekkoException();
                }
            }
            return y;
        }

        private static string GetDateStringSuitableForGnuplot(string d)
        {
            if (Program.options.freq == EFreq.Q)
            {
                if (d.EndsWith("q1")) d = d.Substring(0, d.Length - 2) + "/01/01" + "";
                else if (d.EndsWith("q2")) d = d.Substring(0, d.Length - 2) + "/04/01" + "";
                else if (d.EndsWith("q3")) d = d.Substring(0, d.Length - 2) + "/07/01" + "";
                else if (d.EndsWith("q4")) d = d.Substring(0, d.Length - 2) + "/10/01" + "";
                else throw new GekkoException();
            }
            else if (Program.options.freq == EFreq.M)
            {
                if (d.EndsWith("m1")) d = d.Substring(0, d.Length - 2) + "/01/01" + "";
                else if (d.EndsWith("m2")) d = d.Substring(0, d.Length - 2) + "/02/01" + "";
                else if (d.EndsWith("m3")) d = d.Substring(0, d.Length - 2) + "/03/01" + "";
                else if (d.EndsWith("m4")) d = d.Substring(0, d.Length - 2) + "/04/01" + "";
                else if (d.EndsWith("m5")) d = d.Substring(0, d.Length - 2) + "/05/01" + "";
                else if (d.EndsWith("m6")) d = d.Substring(0, d.Length - 2) + "/06/01" + "";
                else if (d.EndsWith("m7")) d = d.Substring(0, d.Length - 2) + "/07/01" + "";
                else if (d.EndsWith("m8")) d = d.Substring(0, d.Length - 2) + "/08/01" + "";
                else if (d.EndsWith("m9")) d = d.Substring(0, d.Length - 2) + "/09/01" + "";
                else if (d.EndsWith("m10")) d = d.Substring(0, d.Length - 3) + "/10/01" + "";
                else if (d.EndsWith("m11")) d = d.Substring(0, d.Length - 3) + "/11/01" + "";
                else if (d.EndsWith("m12")) d = d.Substring(0, d.Length - 3) + "/12/01" + "";
                else throw new GekkoException();
            }
            return d;
        }

        public static string EncodeDanish(string txt)
        {
            string s = "";
            foreach (char c in txt)
            {
                if (c == 'æ') s += "\\" + (346).ToString();
                else if (c == 'ø') s += "\\" + (370).ToString();
                else if (c == 'å') s += "\\" + (345).ToString();
                else if (c == 'Æ') s += "\\" + (306).ToString();
                else if (c == 'Ø') s += "\\" + (330).ToString();
                else if (c == 'Å') s += "\\" + (305).ToString();
                else s += c.ToString();
            }
            return s;
        }


        /// <summary>
        /// Computes operator-corrected values for a single GekkoTime (gt)
        /// </summary>
        /// <param name="var1"></param>
        /// <param name="varPch"></param>
        /// <param name="operator2"></param>
        /// <param name="gt"></param>
        /// <param name="tsWork"></param>
        /// <param name="tsRef"></param>
        /// <param name="isLogTransform"></param>
        /// <param name="isCalledFromTable"></param>
        /// <param name="sumOver"></param>
        public static void ComputeValueForPrintPlotNew(out double var1, out double varPch, string operator2, GekkoTime gt, Series tsWork, Series tsRef, bool isLogTransform, bool isCalledFromTable, EPrtCollapseTypes collapse, int sumOver)
        {
            string operator3 = operator2.Trim();  //when it comes from for instance a table

            if (isCalledFromTable && !G.Equal(Globals.tableOption, "n"))
            {
                if (G.Equal(Globals.tableOption, "d"))
                {
                    if (G.Equal(operator3, "n")) operator3 = "d";
                    else if (G.Equal(operator3, "d")) operator3 = "";
                    else if (G.Equal(operator3, "p")) operator3 = "";
                    else if (G.Equal(operator3, "dp")) operator3 = "";
                    else if (G.Equal(operator3, "r")) operator3 = "rd";
                    else if (G.Equal(operator3, "rn")) operator3 = "rd";
                    else if (G.Equal(operator3, "rd")) operator3 = "";
                    else if (G.Equal(operator3, "rp")) operator3 = "";
                    else if (G.Equal(operator3, "rdp")) operator3 = "";
                    else if (G.Equal(operator3, "m")) operator3 = "";
                    else if (G.Equal(operator3, "q")) operator3 = "";
                    else if (G.Equal(operator3, "mp")) operator3 = "";
                }
                else if (G.Equal(Globals.tableOption, "p"))
                {
                    if (G.Equal(operator3, "n")) operator3 = "p";
                    else if (G.Equal(operator3, "d")) operator3 = "";
                    else if (G.Equal(operator3, "p")) operator3 = "";
                    else if (G.Equal(operator3, "dp")) operator3 = "";
                    else if (G.Equal(operator3, "r")) operator3 = "rp";
                    else if (G.Equal(operator3, "rn")) operator3 = "rp";
                    else if (G.Equal(operator3, "rd")) operator3 = "";
                    else if (G.Equal(operator3, "rp")) operator3 = "";
                    else if (G.Equal(operator3, "rdp")) operator3 = "";
                    else if (G.Equal(operator3, "m")) operator3 = "";
                    else if (G.Equal(operator3, "q")) operator3 = "";
                    else if (G.Equal(operator3, "mp")) operator3 = "";
                }
                else if (G.Equal(Globals.tableOption, "dp"))
                {
                    if (G.Equal(operator3, "n")) operator3 = "dp";
                    else if (G.Equal(operator3, "d")) operator3 = "";
                    else if (G.Equal(operator3, "p")) operator3 = "";
                    else if (G.Equal(operator3, "dp")) operator3 = "";
                    else if (G.Equal(operator3, "r")) operator3 = "rdp";
                    else if (G.Equal(operator3, "rn")) operator3 = "rdp";
                    else if (G.Equal(operator3, "rd")) operator3 = "";
                    else if (G.Equal(operator3, "rp")) operator3 = "";
                    else if (G.Equal(operator3, "rdp")) operator3 = "";
                    else if (G.Equal(operator3, "m")) operator3 = "";
                    else if (G.Equal(operator3, "q")) operator3 = "";
                    else if (G.Equal(operator3, "mp")) operator3 = "";
                }
                else if (G.Equal(Globals.tableOption, "r") || G.Equal(Globals.tableOption, "rn"))
                {
                    if (G.Equal(operator3, "n")) operator3 = "r";
                    else if (G.Equal(operator3, "d")) operator3 = "rd";
                    else if (G.Equal(operator3, "p")) operator3 = "rp";
                    else if (G.Equal(operator3, "dp")) operator3 = "rdp";
                    else if (G.Equal(operator3, "r")) operator3 = "";
                    else if (G.Equal(operator3, "rn")) operator3 = "";
                    else if (G.Equal(operator3, "rd")) operator3 = "";
                    else if (G.Equal(operator3, "rp")) operator3 = "";
                    else if (G.Equal(operator3, "rdp")) operator3 = "";
                    else if (G.Equal(operator3, "m")) operator3 = "";
                    else if (G.Equal(operator3, "q")) operator3 = "";
                    else if (G.Equal(operator3, "mp")) operator3 = "";
                }
                else if (G.Equal(Globals.tableOption, "rd"))
                {
                    if (G.Equal(operator3, "n")) operator3 = "rd";
                    else if (G.Equal(operator3, "d")) operator3 = "";
                    else if (G.Equal(operator3, "p")) operator3 = "";
                    else if (G.Equal(operator3, "dp")) operator3 = "";
                    else if (G.Equal(operator3, "r")) operator3 = "";
                    else if (G.Equal(operator3, "rn")) operator3 = "";
                    else if (G.Equal(operator3, "rd")) operator3 = "";
                    else if (G.Equal(operator3, "rp")) operator3 = "";
                    else if (G.Equal(operator3, "rdp")) operator3 = "";
                    else if (G.Equal(operator3, "m")) operator3 = "";
                    else if (G.Equal(operator3, "q")) operator3 = "";
                    else if (G.Equal(operator3, "mp")) operator3 = "";
                }
                else if (G.Equal(Globals.tableOption, "rp"))
                {
                    if (G.Equal(operator3, "n")) operator3 = "rp";
                    else if (G.Equal(operator3, "d")) operator3 = "";
                    else if (G.Equal(operator3, "p")) operator3 = "";
                    else if (G.Equal(operator3, "dp")) operator3 = "";
                    else if (G.Equal(operator3, "r")) operator3 = "";
                    else if (G.Equal(operator3, "rn")) operator3 = "";
                    else if (G.Equal(operator3, "rd")) operator3 = "";
                    else if (G.Equal(operator3, "rp")) operator3 = "";
                    else if (G.Equal(operator3, "rdp")) operator3 = "";
                    else if (G.Equal(operator3, "m")) operator3 = "";
                    else if (G.Equal(operator3, "q")) operator3 = "";
                    else if (G.Equal(operator3, "mp")) operator3 = "";
                }
                else if (G.Equal(Globals.tableOption, "rdp"))
                {
                    if (G.Equal(operator3, "n")) operator3 = "rdp";
                    else if (G.Equal(operator3, "d")) operator3 = "";
                    else if (G.Equal(operator3, "p")) operator3 = "";
                    else if (G.Equal(operator3, "dp")) operator3 = "";
                    else if (G.Equal(operator3, "r")) operator3 = "";
                    else if (G.Equal(operator3, "rn")) operator3 = "";
                    else if (G.Equal(operator3, "rd")) operator3 = "";
                    else if (G.Equal(operator3, "rp")) operator3 = "";
                    else if (G.Equal(operator3, "rdp")) operator3 = "";
                    else if (G.Equal(operator3, "m")) operator3 = "";
                    else if (G.Equal(operator3, "q")) operator3 = "";
                    else if (G.Equal(operator3, "mp")) operator3 = "";
                }
                else if (G.Equal(Globals.tableOption, "m"))
                {
                    if (G.Equal(operator3, "n")) operator3 = "m";
                    else if (G.Equal(operator3, "d")) operator3 = "";
                    else if (G.Equal(operator3, "p")) operator3 = "mp";
                    else if (G.Equal(operator3, "dp")) operator3 = "";
                    else if (G.Equal(operator3, "r")) operator3 = "";
                    else if (G.Equal(operator3, "rn")) operator3 = "";
                    else if (G.Equal(operator3, "rd")) operator3 = "";
                    else if (G.Equal(operator3, "rp")) operator3 = "";
                    else if (G.Equal(operator3, "rdp")) operator3 = "";
                    else if (G.Equal(operator3, "m")) operator3 = "";
                    else if (G.Equal(operator3, "q")) operator3 = "";
                    else if (G.Equal(operator3, "mp")) operator3 = "";
                }
                else if (G.Equal(Globals.tableOption, "q"))
                {
                    if (G.Equal(operator3, "n")) operator3 = "q";
                    else if (G.Equal(operator3, "d")) operator3 = "";
                    else if (G.Equal(operator3, "p")) operator3 = "";
                    else if (G.Equal(operator3, "dp")) operator3 = "";
                    else if (G.Equal(operator3, "r")) operator3 = "";
                    else if (G.Equal(operator3, "rn")) operator3 = "";
                    else if (G.Equal(operator3, "rd")) operator3 = "";
                    else if (G.Equal(operator3, "rp")) operator3 = "";
                    else if (G.Equal(operator3, "rdp")) operator3 = "";
                    else if (G.Equal(operator3, "m")) operator3 = "";
                    else if (G.Equal(operator3, "q")) operator3 = "";
                    else if (G.Equal(operator3, "mp")) operator3 = "";
                }
                else if (G.Equal(Globals.tableOption, "mp"))
                {
                    if (G.Equal(operator3, "n")) operator3 = "mp";
                    else if (G.Equal(operator3, "d")) operator3 = "";
                    else if (G.Equal(operator3, "p")) operator3 = "";
                    else if (G.Equal(operator3, "dp")) operator3 = "";
                    else if (G.Equal(operator3, "r")) operator3 = "";
                    else if (G.Equal(operator3, "rn")) operator3 = "";
                    else if (G.Equal(operator3, "rd")) operator3 = "";
                    else if (G.Equal(operator3, "rp")) operator3 = "";
                    else if (G.Equal(operator3, "rdp")) operator3 = "";
                    else if (G.Equal(operator3, "m")) operator3 = "";
                    else if (G.Equal(operator3, "q")) operator3 = "";
                    else if (G.Equal(operator3, "mp")) operator3 = "";
                }
                if (operator3 == "")
                {
                    new Error("TABLE <" + Globals.tableOption + "> and table-file operator '" + operator2 + "' do not combine");
                }
            }

            GekkoTime tMinusOne = gt.Add(-1);
            var1 = 0;
            varPch = 0;

            double divide = 1d;
            if (collapse == EPrtCollapseTypes.Avg) divide = (double)sumOver;

            double x = double.NaN;
            double xLag = double.NaN;
            double xLag2 = double.NaN;
            double y = double.NaN;
            double yLag = double.NaN;
            double yLag2 = double.NaN;
            if (tsWork != null)
            {
                x = 0d;
                xLag = 0d;
                xLag2 = 0d;

                //We do the autocollapse FIRST, before any transformations.

                for (int i = 0; i < sumOver; i++)
                {
                    //for instance if gt is 2020m3, we will add 2020m3+2020m2+2020m1.
                    x += tsWork.GetDataSimple(gt.Add(-i)); //actually quite good that GetData is used here, because for instance "PRT x;" will have the real series x here, where NaN have not optionally been replace with 0 (cf. option series data missing). But the GetData method takes care of that.
                    //for instance if gt is 2020m3, we will add 2019m12+2019m11+2010m10.
                    xLag += tsWork.GetDataSimple(gt.Add(-sumOver - i));
                    //for instance if gt is 2020m3, we will add 2019m9+2019m8+2010m7.
                    xLag2 += tsWork.GetDataSimple(gt.Add(-2 * sumOver - i));
                }

                x = x / divide;
                xLag = xLag / divide;
                xLag2 = xLag2 / divide;

                if (isLogTransform)
                {
                    //only used for PLOT radio button, and PLOT does not support autocollapse.
                    //when redoing PLOT, use <l> option instead for this
                    x = Math.Log(x);
                    xLag = Math.Log(xLag);
                    xLag2 = Math.Log(xLag2);
                }
            }
            if (tsRef != null)
            {
                y = 0d;
                yLag = 0d;
                yLag2 = 0d;
                for (int i = 0; i < sumOver; i++)
                {
                    y += tsRef.GetDataSimple(gt.Add(-i));
                    yLag += tsRef.GetDataSimple(gt.Add(-sumOver - i));
                    yLag2 += tsRef.GetDataSimple(gt.Add(-2 * sumOver - i));
                }

                y = y / divide;
                yLag = yLag / divide;
                yLag2 = yLag2 / divide;

                if (isLogTransform)
                {
                    //only used for PLOT radio button, and PLOT does not support autocollapse.                
                    //when redoing PLOT, use <l> option instead for this
                    y = Math.Log(y);
                    yLag = Math.Log(yLag);
                    yLag2 = Math.Log(yLag2);
                }
            }

            if (operator3 == "" || operator3 == "n")
            {
                var1 = x;
                varPch = PchFunction(x, xLag);
            }
            else if (operator3 == "d")
            {
                var1 = x - xLag;
                varPch = PchFunction(x, xLag);
            }
            else if (operator3 == "p")
            {
                var1 = PchFunction(x, xLag);
                varPch = double.PositiveInfinity;
            }
            else if (operator3 == "dp")
            {
                var1 = PchFunction(x, xLag) - PchFunction(xLag, xLag2);
                varPch = double.PositiveInfinity;
            }
            else if (operator3 == Globals.operator_r || operator3 == Globals.operator_rn)  //r or rn
            {
                var1 = y;
                varPch = PchFunction(y, yLag);
            }
            else if (operator3 == Globals.operator_rd)  //rd
            {
                var1 = y - yLag;
                varPch = PchFunction(y, yLag);
            }
            else if (operator3 == Globals.operator_rp)  //rp
            {
                var1 = PchFunction(y, yLag);
                varPch = double.PositiveInfinity;
            }
            else if (operator3 == Globals.operator_rdp)  //rdp
            {
                var1 = PchFunction(y, yLag) - PchFunction(yLag, yLag2);
                varPch = double.PositiveInfinity;
            }
            else if (operator3 == "m")
            {
                var1 = x - y;
                varPch = PchFunction(x, y);
            }
            else if (operator3 == "q")
            {
                var1 = PchFunction(x, y);
                varPch = double.PositiveInfinity;
            }
            else if (operator3 == "mp")
            {
                var1 = PchFunction(x, xLag) - PchFunction(y, yLag);
                varPch = double.PositiveInfinity;
            }
            else if (operator3 == Globals.operator_l)
            {
                var1 = Math.Log(x);
                varPch = double.PositiveInfinity;
            }
            else if (operator3 == Globals.operator_dl)
            {
                var1 = Math.Log(x) - Math.Log(xLag);
                varPch = double.PositiveInfinity;
            }
            else if (operator3 == Globals.operator_rl)
            {
                var1 = Math.Log(y);
                varPch = double.PositiveInfinity;
            }
            else if (operator3 == Globals.operator_rdl)
            {
                var1 = Math.Log(y) - Math.Log(yLag);
                varPch = double.PositiveInfinity;
            }
            else
            {
                new Error("Internal error: unrecognized print code: '" + operator3 + "'");
                //throw new GekkoException();
            }
            return;
        }

        private static double PchFunction(double x, double x0)
        {
            double z = ((x / x0) - 1d) * 100d;
            if (x == x0) z = 0d;    //0 and 0 gives 0%
            return z;
        }

        private static void ComputeValueForPrintPlot(out double var1, out double varPch, PrtOptionsHelper po, GekkoTime gt, Series tsWork, Series tsBase)
        {
            GekkoTime tMinusOneOrTwo = gt.Add(-1);
            var1 = 0;
            varPch = 0;

            if (po.isDp)
            {
                Series ts = tsWork; if (po.isBaseline) ts = tsBase;
                double var = ts.GetDataSimple(gt);
                double varLag = ts.GetDataSimple(gt.Add(-1));
                double varLag2 = ts.GetDataSimple(gt.Add(-2));
                double pch = (var / varLag - 1) * 100d;
                double pchLag = (varLag / varLag2 - 1) * 100d;
                double dpch = pch - pchLag;
                var1 = dpch;  //TODO: do we get the first year without missing (it uses 2 lags...)?
                varPch = double.NaN;  //TODO: remove this in print
            }
            else if (po.isMp)
            {
                double var = tsWork.GetDataSimple(gt);
                double varLag = tsWork.GetDataSimple(gt.Add(-1));
                double varBase = tsBase.GetDataSimple(gt);
                double varBaseLag = tsBase.GetDataSimple(gt.Add(-1));
                double pch = (var / varLag - 1) * 100d;
                double pchBase = (varBase / varBaseLag - 1) * 100d;
                double dpch = pch - pchBase;
                var1 = dpch;
                varPch = double.NaN;  //TODO: remove this in print
            }
            else if (po.isLevel == true)
            {
                Series ts = tsWork; if (po.isBaseline) ts = tsBase;
                var1 = ts.GetDataSimple(gt);
                varPch = ((ts.GetDataSimple(gt) / ts.GetDataSimple(tMinusOneOrTwo) - 1d) * 100d);
                if (ts.GetDataSimple(gt) == ts.GetDataSimple(tMinusOneOrTwo)) varPch = 0d;    //0 and 0 gives 0%
            }
            else if (po.isLog == true)
            {
                Series ts = tsWork; if (po.isBaseline) ts = tsBase;
                var1 = Math.Log(ts.GetDataSimple(gt));
            }
            else if (po.isPch == true)
            {
                if (po.isMultiplier == true)
                {
                    if (po.isBaseline)
                    {
                        new Error("It is not meaningful to use 'pch', 'multiplier' and 'reference' at the same time");
                        //throw new GekkoException();
                    }
                    var1 = ((tsWork.GetDataSimple(gt) / tsBase.GetDataSimple(gt) - 1d) * 100d);
                    if (tsWork.GetDataSimple(gt) == tsBase.GetDataSimple(gt)) var1 = 0d;     //0 and 0 gives 0%
                }
                else
                {
                    Series ts = tsWork; if (po.isBaseline) ts = tsBase;
                    var1 = ((ts.GetDataSimple(gt) / ts.GetDataSimple(tMinusOneOrTwo) - 1d) * 100d);
                    if (ts.GetDataSimple(gt) == ts.GetDataSimple(tMinusOneOrTwo)) var1 = 0d;     //0 and 0 gives 0%
                }
            }
            else if (po.isDiff == true)
            {
                if (po.isMultiplier == true)
                {
                    if (po.isBaseline)
                    {
                        new Error("It is not meaningful to use 'diff', 'multiplier' and 'reference' at the same time");
                        //throw new GekkoException();
                    }
                    var1 = tsWork.GetDataSimple(gt) - tsBase.GetDataSimple(gt);
                    varPch = ((tsWork.GetDataSimple(gt) / tsBase.GetDataSimple(gt) - 1d) * 100d);
                    if (tsWork.GetDataSimple(gt) == tsBase.GetDataSimple(gt)) varPch = 0d;  //0 and 0 gives 0%
                }
                else
                {
                    Series ts = tsWork; if (po.isBaseline) ts = tsBase;
                    var1 = ts.GetDataSimple(gt) - ts.GetDataSimple(tMinusOneOrTwo);
                }
            }
            else if (po.isDlog == true)
            {
                if (po.isMultiplier == true)
                {
                    if (po.isBaseline)
                    {
                        new Error("It is not meaningful to use 'dlog', 'multiplier' and 'reference' at the same time");
                        //throw new GekkoException();
                    }
                    var1 = Math.Log(tsWork.GetDataSimple(gt) / tsBase.GetDataSimple(gt));
                }
                else
                {
                    Series ts = tsWork; if (po.isBaseline) ts = tsBase;
                    var1 = Math.Log(ts.GetDataSimple(gt) / ts.GetDataSimple(tMinusOneOrTwo));
                }
            }
            return;
        }

        public static void Function(double[] arg, ref double func, object obj)
        {
            //Rosenbrock function
            double a = 1; double b = 100;
            double x = arg[0]; double y = arg[1];
            func = (a - x) * (a - x) + b * (y - x * x) * (y - x * x);
        }

        /// <summary>
        /// Invert matrix, may print error. Beware: probably alters the input matrix and returns it as a side-effect?
        /// </summary>
        /// <param name="matrix"></param>
        /// <returns></returns>
        public static double[,] InvertMatrix(double[,] matrix)
        {
            return InvertMatrix(matrix, true);
        }

        /// <summary>
        /// Inverts matrix. Beware: probably alters the input matrix and returns it as a side-effect?
        /// </summary>
        /// <param name="matrix"></param>
        /// <param name="printError"></param>
        /// <returns></returns>
        public static double[,] InvertMatrix(double[,] matrix, bool printError)
        {
            int success = 0;
            alglib.matinvreport report = new alglib.matinvreport();
            alglib.rmatrixinverse(ref matrix, out success, out report);
            if (success == 3)
            {
                if (printError) new Error("Inv(): It seems the matrix is singular");
                else throw new GekkoException();
            }
            else if (success != 1)
            {
                if (printError) new Error("Inv(): Could not invert matrix");
                else throw new GekkoException();
            }
            return matrix;
        }

        public static bool InvertMatrix(IElementalAccessVector residuals, IElementalAccessVector dx)
        {
            if (Program.options.solve_newton_invert == "lu")
            {
                //LU with reuse of factorization
                //Would be nice with sparse parallel LU solver!
                return InvertMatrixLU(residuals, dx);
            }
            else if (Program.options.solve_newton_invert == "iter")
            {
                //Uses an iterative sparse solver (Math.NET), with an LU-solver (alglib) as fallback
                //It seems to be tolerant with respect to equations like "x = x".
                //Problem is that solve of inverted matrix cannot be reused as in InvertMatrixLU(), to
                //use in fast Newton steps. Also, the iterative solver may not converge.
                return InvertMatrixSparseIter(residuals, dx);
            }
            else
            {
                new Error("Strange error #793438734"); return false;
                //throw new GekkoException();
            }
        }

        private static bool InvertMatrixSparseIter(IElementalAccessVector residuals, IElementalAccessVector dx)
        {
            double relCrit = Globals.invertRelativeConvergence;

            for (int i = 0; i < residuals.Length; i++)
            {
                double val = residuals.GetValue(i);
                if (double.IsNaN(val) || double.IsInfinity(val)) return false;
            }

            {
                for (int iter2 = 0; iter2 < 100; iter2++)
                {
                    if (Globals.solveUseOnlyDenseInverse == false)
                    {
                        DefaultLinearIteration iter = null;
                        try
                        {
                            ILinearSolver solver = null;
                            //IElementalAccessVector gradient = new DenseVector(x.Length);
                            //Blas.Default.TransMult(jacobyMatrix, residuals, gradient);  //checked that it MUST be transposed -- else wrong
                            //ILinearSolver solver = new BiCGSolver();  //1.00, BiCG family supposed to be unstable
                            //ILinearSolver solver = new BiCGstabSolver(); //0.47, supposed to be unstable
                            //ILinearSolver solver = new CGSSolver();  //0.46, supposed to be unstable, should have double spped of BiCG, seems unstable
                            //ILinearSolver solver = new IRSolver();  //not conv
                            if (Globals.runningOnTTComputer) solver = new GMRESSolver();  //1.01, supposed to be stable
                            else solver = new QMRSolver();  //USED: 1.24, more robust versoin of BiCG

                            IPreconditioner M = new IdentityPreconditioner();
                            iter = new DefaultLinearIteration();

                            //playing with conv crits don't change too much regarding steps
                            iter.SetParameters(Globals.invertRelativeConvergence * Math.Pow(10, iter2), Globals.invertAbsoluteConvergence, 1e+5, Globals.invertIterations);  //first param is relative convergence, which is OR'ed with absolute convergence (which we keep pretty strict)

                            M.Setup(Program.model.modelGekko.jacobiMatrix);
                            solver.Preconditioner = M;
                            solver.Iteration = iter;

                            double[] ans = null;

                            ans = Blas.Default.GetArrayCopy(solver.Solve(Program.model.modelGekko.jacobiMatrix, residuals, dx));
                            if (Program.options.solve_print_details) G.Writeln("Matrix inversion took " + iter.IterationCount + " steps");

                            break; //no exception, so we are good to go
                        }
                        catch (Exception e)
                        {
                            if (Program.options.solve_print_details) G.Writeln("Matrix inversion took " + iter.IterationCount + " steps");
                        }
                    }


                    if (Globals.solveUseOnlySparseInverse == false)
                    {
                        {
                            if (Program.options.solve_print_details) G.Writeln("Sparse matrix inversion failed, trying dense matrix inversion (slower)");
                            double[] b = new double[residuals.Length];
                            double[] x = new double[residuals.Length];
                            double[,] a = PutJacobiIntoArray();
                            for (int i = 0; i < residuals.Length; i++)
                            {
                                b[i] = residuals.GetValue(i);
                            }
                            int info = 0;
                            alglib.densesolver.densesolverreport rep = new alglib.densesolver.densesolverreport();
                            //old version below, with some ref
                            //alglib.densesolver.rmatrixsolve(ref a, b.Length, ref b, ref info, ref rep, ref x);
                            //MessageBox.Show("Test that the new alglib method gives the same");
                            alglib.densesolver.rmatrixsolve(a, b.Length, b, ref info, rep, ref x);
                            if (info != 1)
                            {
                                //if (false)  //it seems that rmatrixsolvels can stall completely, never returning from a loop.
                                //{           //providing a timer for it might be a solution, but for now it is switched off. So
                                //    //if the sparse solver does not work, we try the normal alglib solver, but not the
                                //    //least-squares solver. Often the values from the sparse solver are ok to continue
                                //    //with, even though it throws an exception.
                                //    int infols = 0;
                                //    if (Program.options.solve_print_details) G.Writeln("Problem with dense matrix inversion, trying less strict crits");
                                //    alglib.densesolver.densesolverlsreport repls = new alglib.densesolver.densesolverlsreport();
                                //    alglib.densesolver.rmatrixsolvels(ref a, b.Length, b.Length, ref b, 0d, ref infols, ref repls, ref x);
                                //    if (infols != 1)
                                //    {
                                //        if (Program.options.solve_print_details) G.Writeln("Could not perform dense matrix inversion, using result from sparse matrix inversion");
                                //    }
                                //    else
                                //    {
                                //        for (int i = 0; i < x.Length; i++)
                                //        {
                                //            dx.SetValue(i, x[i]);
                                //        }
                                //        break;  //we are good
                                //    }
                                //}
                            }
                            else
                            {
                                for (int i = 0; i < x.Length; i++)
                                {
                                    dx.SetValue(i, x[i]);
                                }
                                break;  //we are good
                            }
                        }
                    }
                }  //iterations
            }

            Blas.Default.Scale(-1d, dx);  //the direction is NEGATIVE!
            //dx is Newton direction
            return true;
        }

        private static bool InvertMatrixLU(IElementalAccessVector residuals, IElementalAccessVector dx)
        {
            int n = residuals.Length;
            for (int i = 0; i < residuals.Length; i++)
            {
                double val = residuals.GetValue(i);
                if (double.IsNaN(val) || double.IsInfinity(val)) return false;
            }

            double[,] lu = null;
            int[] indx;
            if (Program.model.modelGekko.jacobiMatrixInvertedIndex == null)
            {
                //lu = new double[n, n];
                if (Program.model.modelGekko.jacobiMatrixInverted == null) Program.model.modelGekko.jacobiMatrixInverted = new double[n, n];  //The very first time this method is called, the array will be null
                Array.Copy(Program.model.modelGekko.jacobiMatrixDense, Program.model.modelGekko.jacobiMatrixInverted, Program.model.modelGekko.jacobiMatrixDense.Length);
                lu = Program.model.modelGekko.jacobiMatrixInverted;
                indx = new int[n];  //this one is not recycled like jacobiMatrixInverted, to add some security that we are not mistakenly using old stuff from previous periods etc.
                LUDecompose(ref lu, ref indx);
                Program.model.modelGekko.jacobiMatrixInvertedIndex = indx;
            }
            else
            {
                lu = Program.model.modelGekko.jacobiMatrixInverted;
                indx = Program.model.modelGekko.jacobiMatrixInvertedIndex;
            }

            double[] b = new double[residuals.Length];
            for (int i = 0; i < residuals.Length; i++)
            {
                b[i] = residuals.GetValue(i);
            }

            double[] x = new double[residuals.Length];
            InvertMatrixSolve(ref b, ref x, indx, lu);

            for (int i = 0; i < x.Length; i++)
            {
                dx.SetValue(i, x[i]);
            }

            Blas.Default.Scale(-1d, dx);  //the direction is NEGATIVE!
            //dx is Newton direction
            return true;
        }

        public static Table Decompose(DecompOptions o)
        {
            //
            //
            //
            //                 Ref   -- m -->      Work
            //
            //                   ^                    ^
            //                   |                    |
            //                  rd                    d
            //                   |                    |
            //            
            //                 Ref[-1]             Work[-1]
            //
            //

            int funcCounter = 0;

            DateTime dt = DateTime.Now;

            string code1 = o.prtOptionLower;
            string code2 = null;
            if (code1.StartsWith("s"))
            {
                code1 = code1.Substring(1);
                code2 = "s";
            }

            o.decompTablesFormat.isPercentageType = false;
            if (code1.Contains("p") || code1.Contains("q") || code2 == "s")
            {
                o.decompTablesFormat.isPercentageType = true;
            }

            Table tab = new Table();

            GekkoTime per1 = o.t1;
            GekkoTime per2 = o.t2;

            bool isRaw = false;
            if (o.prtOptionLower.StartsWith("x")) isRaw = true;

            GekkoSmpl smpl = new GekkoSmpl(per1, per2);
            IVariable y0a = null;
            IVariable y0aRef = null;

            int perLag = -2;
            string lhs = "Expression value";

            bool usesRef = OperatorUsesRef(code1);

            try
            {

                if (o.decompTables == null) o.decompTables = new DecompData();

                if ((!usesRef && !o.hasCalculatedQuo) || (usesRef && !o.hasCalculatedRef))
                {
                    List<int> mm = new List<int>();

                    if (!usesRef)
                    {
                        o.decompTables.cellsGradQuo = new DecompDict();
                        o.decompTables.cellsQuo = new DecompDict();
                        o.decompTables.cellsContribD = new DecompDict();
                        mm.Add(0);
                        o.hasCalculatedQuo = true;
                    }
                    else
                    {
                        o.decompTables.cellsGradRef = new DecompDict();
                        o.decompTables.cellsRef = new DecompDict();
                        o.decompTables.cellsContribDRef = new DecompDict();
                        o.decompTables.cellsContribM = new DecompDict();
                        mm.Add(1);
                        o.hasCalculatedRef = true;
                    }

                    Globals.precedents = new GekkoDictionary<string, int>(StringComparer.OrdinalIgnoreCase);

                    //Function call start --------------
                    O.AdjustSmplForDecomp(smpl, 0);
                    y0a = o.expression(smpl); funcCounter++;  //this call fills Globals.precedents with variables
                    O.AdjustSmplForDecomp(smpl, 1);
                    //Function call end   --------------

                    List<DecompPrecedent> decompPrecedents = new List<DecompPrecedent>();
                    if (true)
                    {
                        List<string> ss = Globals.precedents.Keys.ToList<string>();
                        ss.Sort(StringComparer.OrdinalIgnoreCase);
                        foreach (string s in ss)
                        {
                            IVariable x = O.GetIVariableFromString(s, O.ECreatePossibilities.NoneReportError);

                            if (x.Type() == EVariableType.Series)
                            {
                                Series ivTemp_series = x as Series;
                                if (ivTemp_series.type == ESeriesType.ArraySuper) continue;  //skipped: we are only looking at sub-series                                
                                decompPrecedents.Add(new DecompPrecedent(s, x));
                            }
                            else if (x.Type() == EVariableType.Val)
                            {
                                decompPrecedents.Add(new DecompPrecedent(s, x));
                            }
                        }
                    }

                    Globals.precedents = null;  //!!! This is important: if not set to null, afterwards there will be a lot of superfluous lookup in the dictionary                

                    Series y0a_series = y0a as Series;
                    if (y0a == null)
                    {
                        new Error("DECOMP expects the expression to be of series type");
                        //throw new GekkoException();
                    }
                    Series y0_series = y0a_series;
                    if (y0a_series.type != ESeriesType.Light)
                    {
                        y0_series = y0a.DeepClone(null) as Series;  //a lag like "DECOMP x[-1]" may just move a pointer to real timeseries x, and x is changed with shocks...
                    }

                    Series y0aRef_series = null;
                    Series y0Ref_series = null;
                    if (usesRef)
                    {
                        //Function call start --------------
                        O.AdjustSmplForDecomp(smpl, 0);
                        smpl.bankNumber = 1;
                        y0aRef = o.expression(smpl); funcCounter++;
                        smpl.bankNumber = 0;
                        O.AdjustSmplForDecomp(smpl, 1);
                        //Function call end   --------------

                        y0aRef_series = y0aRef as Series;
                        if (y0aRef == null)
                        {
                            new Error("DECOMP expects the expression to be of series type");
                            //throw new GekkoException();
                        }
                        y0Ref_series = y0aRef_series;
                        if (y0aRef_series.type != ESeriesType.Light)
                        {
                            y0Ref_series = y0aRef.DeepClone(null) as Series;  //a lag like "DECOMP x[-1]" may just move a pointer to real timeseries x, and x is changed with shocks...
                        }
                    }

                    foreach (GekkoTime t in new GekkoTimeIterator(per1.Add(perLag), per2))
                    {
                        o.decompTables.cellsQuo[lhs].SetData(t, y0_series.GetData(smpl, t));
                        o.decompTables.cellsContribD[lhs].SetData(t, y0_series.GetData(smpl, t) - y0_series.GetData(smpl, t.Add(-1)));
                        if (usesRef)
                        {
                            o.decompTables.cellsRef[lhs].SetData(t, y0Ref_series.GetData(smpl, t));
                            o.decompTables.cellsContribM[lhs].SetData(t, y0_series.GetData(smpl, t) - y0Ref_series.GetData(smpl, t));
                            o.decompTables.cellsContribDRef[lhs].SetData(t, y0Ref_series.GetData(smpl, t) - y0Ref_series.GetData(smpl, t.Add(-1)));
                        }
                    }

                    double eps = Globals.newtonSmallNumber;

                    if (decompPrecedents.Count > 0)
                    {
                        GekkoDictionary<string, int> vars = new GekkoDictionary<string, int>(StringComparer.OrdinalIgnoreCase);

                        int iVar = -1;

                        foreach (DecompPrecedent dp in decompPrecedents)
                        {
                            iVar++;

                            //G.Writeln("Progress: " + G.pchFormat(100 * (double)iVar / (double)decompPrecedents.Count, 15));

                            Series xRef_series = null;
                            IVariable dpx = O.GetIVariableFromString(dp.s, O.ECreatePossibilities.NoneReportError);

                            if (dpx.Type() == EVariableType.Series)
                            {
                                if ((dpx as Series).type == ESeriesType.Timeless) continue;  //skip timeless series, #2983473298472
                                                                                             //could also use smpl.bankNumber = 1 to do this, but then GetIVariableFromString should use smpl.bankNumbe 
                                if (usesRef)
                                {
                                    xRef_series = O.GetIVariableFromString(G.Chop_SetBank(dp.s, "Ref"), O.ECreatePossibilities.NoneReportError) as Series;
                                }
                            }
                            else
                            {
                                //else what?
                            }

                            foreach (GekkoTime t1 in new GekkoTimeIterator(per1.Add(-O.MaxLag()), per2.Add(O.MaxLead())))
                            {

                                // --------------------------------------------
                                // This is where the decomposition takes place
                                // --------------------------------------------

                                foreach (int j in mm)
                                {
                                    if (dpx.Type() == EVariableType.Series)
                                    {
                                        Series x_series = null;
                                        Series y_series = null;
                                        if (j == 0)
                                        {
                                            x_series = dpx as Series;
                                            y_series = y0_series;
                                        }
                                        else
                                        {
                                            x_series = xRef_series;
                                            y_series = y0Ref_series;
                                        }
                                        double x_before = x_series.GetData(smpl, t1);
                                        try
                                        {
                                            double x_after = x_before + eps;
                                            x_series.SetData(t1, x_after);

                                            //Function call start --------------
                                            O.AdjustSmplForDecomp(smpl, 0);
                                            if (j == 1) smpl.bankNumber = 1;
                                            IVariable y1 = null;
                                            y1 = o.expression(smpl); funcCounter++;
                                            if (j == 1) smpl.bankNumber = 0;
                                            O.AdjustSmplForDecomp(smpl, 1);
                                            //Function call end   --------------

                                            Series y1_series = y1 as Series;

                                            foreach (GekkoTime t2 in new GekkoTimeIterator(per1.Add(perLag), per2.Add(0)))
                                            //foreach (GekkoTime t2 in new GekkoTimeIterator(t1, t1))
                                            {
                                                double y0_double = y_series.GetData(smpl, t2);
                                                double y1_double = y1_series.GetData(smpl, t2);
                                                double grad = (y1_double - y0_double) / eps;
                                                int lag = -t2.Subtract(t1);  //x[-1] --> lag = -1                                            
                                                string name = G.Chop_RemoveFreq(dp.s, per1.freq);

                                                if (lag != 0)
                                                {
                                                    if (lag < 0) name += "¤[" + lag + "]";
                                                    else name += "¤[+" + lag + "]";
                                                }

                                                if (lag == 0 || (lag < 0 && -lag <= Program.options.decomp_maxlag) || (lag > 0 && lag <= Program.options.decomp_maxlead))
                                                {
                                                    //slack: we get too many variants of name[-x] and name[+x] here
                                                    if (j == 0)
                                                    {
                                                        o.decompTables.cellsQuo[name].SetData(t2, x_before);
                                                        //G.Writeln("quo " + name + " " + t2.ToString() + " " + x_before);
                                                    }
                                                    else
                                                    {
                                                        o.decompTables.cellsRef[name].SetData(t2, x_before);
                                                        //G.Writeln("ref " + name + " " + t2.ToString() + " " + x_before);
                                                    }
                                                }

                                                if (!G.isNumericalError(grad) && grad != 0d)
                                                {
                                                    if (j == 0)
                                                    {
                                                        o.decompTables.cellsGradQuo[name].SetData(t2, grad);
                                                        //G.Writeln("gradquo " + name + " " + t2.ToString() + " " + grad);
                                                    }
                                                    else
                                                    {
                                                        o.decompTables.cellsGradRef[name].SetData(t2, grad);
                                                        //G.Writeln("gradref " + name + " " + t2.ToString() + " " + grad);
                                                    }

                                                    if (!vars.ContainsKey(name))
                                                    {
                                                        vars.Add(name, 0);
                                                        //G.Writeln("--> added var " + name);
                                                    }
                                                    else
                                                    {
                                                        //G.Writeln("checked name");
                                                    }

                                                }
                                            }
                                        }
                                        finally
                                        {
                                            x_series.SetData(t1, x_before);
                                        }
                                    }
                                    else if (dpx.Type() == EVariableType.Val)
                                    {
                                        //TODO
                                    }
                                    else
                                    {
                                        //skip other types, this includes matrices
                                        //so an expression with a matrix that changes from Work to Ref is
                                        //not decomoposed as regards to this matrix
                                        //(we would have to shock each cell in the matrix...)
                                    }

                                    //decompContributions.Add(dh);
                                    //decompHelpers.Add(key + "," + t.ToString(), decompContributions);  //key for instance "Work,2010"
                                }
                            }
                        }

                        if (o.vars2 == null)
                        {
                            o.vars2 = new List<string>(vars.Keys.ToArray());
                            o.vars2.Sort(StringComparer.OrdinalIgnoreCase);
                            o.vars2.Insert(0, lhs);
                        }

                        tab.writeOnce = true;

                        int i = 0;
                        foreach (GekkoTime t2 in new GekkoTimeIterator(per1, per2))
                        {
                            i++;
                            int j = 0;
                            foreach (string s in o.vars2)
                            {
                                if (s == lhs) continue;
                                j++;

                                double vQuo = o.decompTables.cellsQuo[s].GetData(smpl, t2);
                                double vQuoLag = o.decompTables.cellsQuo[s].GetData(smpl, t2.Add(-1));
                                double vGradQuoLag = o.decompTables.cellsGradQuo[s].GetData(smpl, t2.Add(-1));
                                double vGradQuo = o.decompTables.cellsGradQuo[s].GetData(smpl, t2);
                                double dContribD = vGradQuoLag * (vQuo - vQuoLag);
                                o.decompTables.cellsContribD[s].SetData(t2, dContribD);

                                if (usesRef)
                                {
                                    double vRef = o.decompTables.cellsRef[s].GetData(smpl, t2);
                                    double vRefLag = o.decompTables.cellsRef[s].GetData(smpl, t2.Add(-1));
                                    double vGradRef = o.decompTables.cellsGradRef[s].GetData(smpl, t2);
                                    double vGradRefLag = o.decompTables.cellsGradRef[s].GetData(smpl, t2.Add(-1));
                                    double dContribM = vGradRef * (vQuo - vRef);
                                    double dContribDRef = vGradRefLag * (vRef - vRefLag);
                                    o.decompTables.cellsContribM[s].SetData(t2, dContribM);
                                    o.decompTables.cellsContribDRef[s].SetData(t2, dContribDRef);
                                }
                            }
                        }
                    }
                }
            }
            finally
            {
                //Important: makes sure is is *always* nulled after a DECOMP
                Globals.precedents = null;
            }

            if (funcCounter > 0)
            {
                G.Writeln2("DECOMP took " + G.SecondsFormat((DateTime.Now - dt).TotalMilliseconds) + " --> " + funcCounter + " evals");
                new Note("DECOMP only works well on simulated values -- a patch for 3.0 will fix this.");
            }

            DecomposePutIntoTable(o, code1, code2, tab, per1, per2, smpl, lhs, o.vars2);

            return tab;

        }

        private static bool OperatorUsesRef(string code1)
        {
            return code1 == "r" || code1 == "xr" || code1 == "xrn" || code1 == "rd" || code1 == "xrd" || code1 == "m" || code1 == "xm" || code1 == "rp" || code1 == "xrp" || code1 == "q" || code1 == "xq" || code1 == "rdp" || code1 == "xrdp" || code1 == "mp" || code1 == "xmp";
        }

        public static string GetDecompResidualName(int counter, int all)
        {
            string s = "";
            if (all > 1) s = (counter + 1).ToString();
            return Program.databanks.GetFirst().name + ":" + Globals.decompResidualName + s + "¤[0]";
        }

        public static bool IsDecompResidualName(string name)
        {
            return name.Contains(Globals.decompResidualName);
        }        

        private static void DecomposePutIntoTable(DecompOptions o, string code1, string code2, Table tab, GekkoTime per1, GekkoTime per2, GekkoSmpl smpl, string lhs, List<string> vars2)
        {
            int iOffset = 0;
            if (o.decompTablesFormat.showErrors) iOffset = 1;

            if (o.decompTablesFormat.isPercentageType)
            {
                tab.Set(1, 1, "%");
            }

            int j = 0;
            foreach (GekkoTime t2 in new GekkoTimeIterator(per1, per2))
            {
                j++;
                int i = 0;
                double lhsSum = 0d;
                double rhsSum = 0d;
                foreach (string varname in vars2)
                {
                    i++;
                    if (j == 1)
                    {
                        string varname2 = varname;
                        string lag5 = null;
                        string[] ss = varname.Split('¤');
                        if (ss.Length == 2)
                        {
                            varname2 = ss[0];
                            lag5 = ss[1];
                        }
                        else
                        {
                            //do nothing
                        }
                        tab.Set(i + 1, 1, G.Chop_RemoveBank(varname2, Program.databanks.GetFirst().name) + lag5);
                    }

                    if (i == 1)
                    {
                        Cell c = new Cell();
                        c.date = t2.ToString();
                        c.cellType = CellType.Date;
                        tab.Set(new Coord(1, j + 1), c);
                    }
                    double d = double.NaN;
                    if (code1 == "n" || code1 == "xn" || code1 == "x")
                    {
                        d = o.decompTables.cellsQuo[varname].GetData(smpl, t2);  //for instance {"x¤2002", 2.5} or {"x[-1]¤2003", -1.5}
                                                                                 //o.cellsGrad.TryGetValue(s + "¤" + t2.ToString(), out d);  //for instance {"x¤2002", 2.5} or {"x[-1]¤2003", -1.5}
                    }
                    else if (code1 == "r" || code1 == "xr" || code1 == "xrn")
                    {
                        d = o.decompTables.cellsRef[varname].GetData(smpl, t2);
                        //o.decompTables.cellsGradRef.TryGetValue(s + "¤" + t2.ToString(), out d);  //for instance {"x¤2002", 2.5} or {"x[-1]¤2003", -1.5}
                    }
                    else if (code1 == "d")
                    {
                        d = o.decompTables.cellsContribD[varname].GetData(smpl, t2);
                    }
                    else if (code1 == "rd")
                    {
                        d = o.decompTables.cellsContribDRef[varname].GetData(smpl, t2);
                    }
                    else if (code1 == "xd")
                    {
                        double d1 = o.decompTables.cellsQuo[varname].GetData(smpl, t2);
                        double d0 = o.decompTables.cellsQuo[varname].GetData(smpl, t2.Add(-1));
                        d = d1 - d0;
                    }
                    else if (code1 == "xrd")
                    {
                        double d1 = o.decompTables.cellsRef[varname].GetData(smpl, t2);
                        double d0 = o.decompTables.cellsRef[varname].GetData(smpl, t2.Add(-1));
                        d = d1 - d0;
                    }
                    else if (code1 == "m")
                    {
                        d = o.decompTables.cellsContribM[varname].GetData(smpl, t2);
                    }
                    else if (code1 == "xm")
                    {
                        double d1 = o.decompTables.cellsQuo[varname].GetData(smpl, t2);
                        double d0 = o.decompTables.cellsRef[varname].GetData(smpl, t2);
                        d = d1 - d0;
                    }
                    else if (code1 == "p")
                    {
                        double dd = o.decompTables.cellsContribD[varname].GetData(smpl, t2);
                        double dLhsLag = o.decompTables.cellsQuo[lhs].GetData(smpl, t2.Add(-1));
                        d = (dd / dLhsLag) * 100d;
                    }
                    else if (code1 == "rp")
                    {
                        double dd = o.decompTables.cellsContribDRef[varname].GetData(smpl, t2);
                        double dLhsLag = o.decompTables.cellsRef[lhs].GetData(smpl, t2.Add(-1));
                        d = (dd / dLhsLag) * 100d;
                    }
                    else if (code1 == "xp")
                    {
                        double d1 = o.decompTables.cellsQuo[varname].GetData(smpl, t2);
                        double d0 = o.decompTables.cellsQuo[varname].GetData(smpl, t2.Add(-1));
                        d = (d1 / d0 - 1d) * 100d;
                    }
                    else if (code1 == "xrp")
                    {
                        double d1 = o.decompTables.cellsRef[varname].GetData(smpl, t2);
                        double d0 = o.decompTables.cellsRef[varname].GetData(smpl, t2.Add(-1));
                        d = (d1 / d0 - 1d) * 100d;
                    }
                    else if (code1 == "q")
                    {
                        double dd = o.decompTables.cellsContribM[varname].GetData(smpl, t2);
                        double dLhsLag = o.decompTables.cellsRef[lhs].GetData(smpl, t2);
                        d = (dd / dLhsLag) * 100d;
                    }
                    else if (code1 == "xq")
                    {
                        double d1 = o.decompTables.cellsQuo[varname].GetData(smpl, t2);
                        double d0 = o.decompTables.cellsRef[varname].GetData(smpl, t2);
                        d = (d1 / d0 - 1d) * 100d;
                    }
                    else if (code1 == "dp")
                    {
                        double dd = o.decompTables.cellsContribD[varname].GetData(smpl, t2);
                        double dd_lag = o.decompTables.cellsContribD[varname].GetData(smpl, t2.Add(-1));
                        double dLhsLag = o.decompTables.cellsQuo[lhs].GetData(smpl, t2.Add(-1));
                        double dLhsLag_lag = o.decompTables.cellsQuo[lhs].GetData(smpl, t2.Add(-1).Add(-1));
                        d = (dd / dLhsLag - dd_lag / dLhsLag_lag) * 100d;
                    }
                    else if (code1 == "rdp")
                    {
                        double dd = o.decompTables.cellsContribDRef[varname].GetData(smpl, t2);
                        double dd_lag = o.decompTables.cellsContribDRef[varname].GetData(smpl, t2.Add(-1));
                        double dLhsLag = o.decompTables.cellsRef[lhs].GetData(smpl, t2.Add(-1));
                        double dLhsLag_lag = o.decompTables.cellsRef[lhs].GetData(smpl, t2.Add(-1).Add(-1));
                        d = (dd / dLhsLag - dd_lag / dLhsLag_lag) * 100d;
                    }
                    else if (code1 == "xdp")
                    {
                        double d1 = o.decompTables.cellsQuo[varname].GetData(smpl, t2);
                        double d1_lag = o.decompTables.cellsQuo[varname].GetData(smpl, t2.Add(-1));
                        double d0 = o.decompTables.cellsQuo[varname].GetData(smpl, t2.Add(-1));
                        double d0_lag = o.decompTables.cellsQuo[varname].GetData(smpl, t2.Add(-1).Add(-1));
                        d = (d1 / d0 - 1d - (d1_lag / d0_lag - 1d)) * 100d;
                    }
                    else if (code1 == "xrdp")
                    {
                        double d1 = o.decompTables.cellsRef[varname].GetData(smpl, t2);
                        double d1_lag = o.decompTables.cellsRef[varname].GetData(smpl, t2.Add(-1));
                        double d0 = o.decompTables.cellsRef[varname].GetData(smpl, t2.Add(-1));
                        double d0_lag = o.decompTables.cellsRef[varname].GetData(smpl, t2.Add(-1).Add(-1));
                        d = (d1 / d0 - 1d - (d1_lag / d0_lag - 1d)) * 100d;
                    }
                    else if (code1 == "mp")  // <p> - <rp>
                    {
                        double dd = o.decompTables.cellsContribD[varname].GetData(smpl, t2);
                        double dLhsLag = o.decompTables.cellsQuo[lhs].GetData(smpl, t2.Add(-1));

                        double dd2 = o.decompTables.cellsContribDRef[varname].GetData(smpl, t2);
                        double dLhsLag2 = o.decompTables.cellsRef[lhs].GetData(smpl, t2.Add(-1));
                        d = (dd / dLhsLag - dd2 / dLhsLag2) * 100d;


                    }
                    else if (code1 == "xmp")
                    {
                        double d1 = o.decompTables.cellsQuo[varname].GetData(smpl, t2);
                        double d0 = o.decompTables.cellsQuo[varname].GetData(smpl, t2.Add(-1));
                        double d1_ref = o.decompTables.cellsRef[varname].GetData(smpl, t2);
                        double d0_ref = o.decompTables.cellsRef[varname].GetData(smpl, t2.Add(-1));
                        d = (d1 / d0 - 1d - (d1_ref / d0_ref - 1d)) * 100d;
                    }
                    else
                    {
                        MessageBox.Show("*** ERROR: Wrong operator: " + o.prtOptionLower);
                        throw new GekkoException();
                    }

                    if (i == 1)
                    {
                        lhsSum = d;
                    }
                    else
                    {
                        rhsSum += d;
                    }

                    DecomposeInsertValue(tab, j, i, d, o.decompTablesFormat);

                    if (i == 1 && o.decompTablesFormat.showErrors)
                    {
                        i = i + iOffset;
                        //skip a line, to make room for error showing (at i = 2, or row 3 in the table)
                        if (j == 1 && DecomposePutIntoTableIsError(o.decompTablesFormat.showErrors, i))
                        {
                            tab.Set(i + 1, 1, Globals.decompText2);
                            tab.Get(i + 1, 1).backgroundColor = "LightRed";
                        }
                    }

                }
                if (code1 == "d" || code1 == "rd" || code1 == "m" || code1 == "p" || code1 == "rp" || code1 == "q" || code1 == "dp" || code1 == "rdp" || code1 == "mp")
                {
                    double error = lhsSum - rhsSum;
                    double factor = lhsSum / rhsSum;
                    int end = vars2.Count;
                    if (o.decompTablesFormat.showErrors)
                    {
                        factor = 1d;  //resetting
                        end = end + iOffset;
                    }
                    for (i = 2; i <= end; i++)  //note: the real rows of the table are i+1
                    {
                        if (DecomposePutIntoTableIsError(o.decompTablesFormat.showErrors, i)) //real table row 3
                        {
                            DecomposeInsertValue(tab, j, i, error, o.decompTablesFormat);
                            tab.Get(i + 1, j + 1).backgroundColor = "LightRed";
                        }
                        else
                        {
                            tab.Get(i + 1, j + 1).number *= factor;
                        }
                    }
                    if (code2 == "s")
                    {
                        //just take raw cell numbers and make them sum to 100
                        tab.Get(1 + 1, j + 1).number *= 100d / tab.Get(1 + 1, j + 1).number;  //variable 1, table row 2
                        double sum = 0d;
                        for (i = 2; i <= end; i++)  //note: the real rows of the table are i+1
                        {
                            sum += tab.Get(i + 1, j + 1).number;
                        }
                        for (i = 2; i <= end; i++)  //note: the real rows of the table are i+1
                        {
                            tab.Get(i + 1, j + 1).number *= 100d / sum;
                        }
                    }
                }
            }
        }

        public static List<string> DecompGetVars(DecompData decompData, string varname, string expressionText, GekkoDictionary<string, bool> ignore)
        {
            List<string> vars = new List<string>(decompData.cellsContribD.storage.Keys);
            vars.Sort(StringComparer.OrdinalIgnoreCase);
            List<string> vars2 = new List<string>();
            if (varname == null)
            {
                vars2 = new List<string>(vars);
            }
            else
            {
                foreach (string var in vars)
                {
                    //making sure that the variable we are going to decompose is shown at top
                    string[] ss = var.Split('¤');
                    string varnameWithoutFirstBank = G.Chop_RemoveBank(ss[0], Program.databanks.GetFirst().name);
                    if (ss[1] == "[0]" && G.Equal(varname, varnameWithoutFirstBank)) vars2.Add(var);
                }
                if (vars2.Count == 0)
                {
                    new Error("Did not find variable '" + varname + "' in the equation " + expressionText);
                    //throw new GekkoException();
                }
                foreach (string var in vars)
                {
                    //adding the rest of the variables, except the variable we are going to decompose
                    if (G.Equal(vars2[0], var)) continue;
                    if (ignore.ContainsKey(var)) continue;  //variables that are eliminated via links
                    vars2.Add(var);
                }
            }
            return vars2;
        }

        private static void DecomposeAddToRow(DataRow dr, string col_variable, string varName)
        {
            //string s = varName;
            //if (string.IsNullOrEmpty(varName)) varName = "gekko_empty";
            dr[col_variable] = varName;
        }

        public static Table DecomposePutIntoTableHelper2(DataTable tab2, string col_value, bool isValues)
        {
            Table tab = new Table();
            for (int jj = 1; jj < tab2.Columns.Count; jj++)  //1: skip (1, 1) element
            {
                tab.Set(1, jj + 1, tab2.Columns[jj].ToString());
            }

            int i = 1; int j = 0;
            foreach (DataRow row in tab2.Rows)
            {
                i++; j = 0;
                foreach (DataColumn col in tab2.Columns)
                {
                    j++;
                    //starts at i = 2, j = 1
                    if (i > 1 && j > 1)
                    {
                        if (isValues)
                        {
                            DecomposePutIntoTableHelper2Cast(tab, i, j, row, col);
                        }
                        else
                        {
                            if (col.ColumnName == col_value)
                            {
                                DecomposePutIntoTableHelper2Cast(tab, i, j, row, col);
                            }
                            else
                            {
                                string s = row[col].ToString();
                                tab.Set(i, j, s);
                            }
                        }
                    }
                    else
                    {
                        string s = row[col].ToString();
                        tab.Set(i, j, s);
                    }
                }
            }
            return tab;
        }

        private static void DecomposePutIntoTableHelper2Cast(Table tab, int i, int j, DataRow row, DataColumn col)
        {
            double d = double.NaN;
            Object o = row[col];
            if (o.GetType() == typeof(double)) d = (double)row[col];
            else
            {
                string s = o as string;
                double.TryParse(s, out d);
            }
            tab.Set(new Coord(i, j), null, d, CellType.Number, "f13.4");
        }




        private static bool DecomposePutIntoTableIsError(bool showErrors, int i)
        {
            return showErrors && i == 2;
        }

        private static void DecomposeInsertValue(Table tab, int j, int i, double d, DecompTablesFormat o)
        {
            Cell c = new Cell();
            c.number = d;
            c.cellType = CellType.Number;
            int decimals = 0;
            if (o.isPercentageType) decimals = o.decimalsPch;
            else decimals = o.decimalsLevel;
            string format2 = "f16." + decimals.ToString();
            c.numberFormat = format2;
            tab.Set(new Coord(i + 1, j + 1), c);
        }

        private static void DecomposeInsertValue2(Table tab, string code1, string code2, int j, int i, double d, DecompTablesFormat format)
        {
            Cell c = new Cell();
            c.number = d;
            c.cellType = CellType.Number;
            int decimals = 0;
            if (format.isPercentageType) decimals = format.decimalsPch;
            else decimals = format.decimalsLevel;
            string format2 = "f16." + decimals.ToString();
            c.numberFormat = format2;
            tab.Set(new Coord(i + 1, j + 1), c);
        }        

        public static double[,] PutJacobiIntoArray()
        {
            double[,] a = new double[Program.model.modelGekko.jacobiMatrix.RowCount, Program.model.modelGekko.jacobiMatrix.ColumnCount];
            for (int i = 0; i < Program.model.modelGekko.jacobiMatrix.RowCount; i++)
            {
                for (int j = 0; j < Program.model.modelGekko.jacobiMatrix.ColumnCount; j++)
                {
                    a[i, j] = Program.model.modelGekko.jacobiMatrix.GetValue(i, j);
                }
            }
            return a;
        }



        private static void PrintIterationVariables(double[] b, string[] vars, int iterCounter)
        {
            if (vars == null) return;
            if (vars.Length == 0) return;
            if (true)
            {
                G.Writeln();
                foreach (string var5 in vars)
                {
                    BTypeData temp = (BTypeData)Program.model.modelGekko.varsBType[var5 + Globals.lagIndicator + "0"];
                    int tem2 = temp.bNumber;
                    double num = b[tem2];
                    G.Writeln(iterCounter + "  " + var5 + " = " + num);
                }
                G.Writeln();
            }
        }


        public static double[,] MultiplyMatrixScalar(double[,] a, double b, int m, int k)
        {
            double[,] c = new double[m, k];
            for (int i = 0; i < m; i++)
            {
                for (int j = 0; j < k; j++)
                {
                    c[i, j] = a[i, j] * b;
                }
            }
            return c;
        }

        public static double[,] AddMatrixMatrix(double[,] a, double[,] b, int m, int k)
        {
            double[,] c = new double[m, k];
            for (int i = 0; i < m; i++)
            {
                for (int j = 0; j < k; j++)
                {
                    c[i, j] = a[i, j] + b[i, j];
                }
            }
            return c;
        }


        public static double[,] SubtractMatrixMatrix(double[,] a, double[,] b, int m, int k)  //a - b
        {
            double[,] c = new double[m, k];
            for (int i = 0; i < m; i++)
            {
                for (int j = 0; j < k; j++)
                {
                    c[i, j] = a[i, j] - b[i, j];
                }
            }
            return c;
        }

        /// <summary>
        /// Multiplies to matrices (arrays)
        /// </summary>
        /// <param name="x"></param>
        /// <param name="y"></param>
        /// <returns></returns>
        public static double[,] MultiplyMatrices(double[,] x, double[,] y)
        {
            //  1 2
            //  3 4     5 6 7 8       -->   3x2 * 2x4 = 3x4
            //  5 6     8 9 8 5
            //
            int xRows = x.GetLength(0);
            int xCols = x.GetLength(1);
            int yRows = y.GetLength(0);
            int yCols = y.GetLength(1);
            if (xCols != yRows)
            {
                new Error("Matrices do not conform for multiplication");
                //throw new GekkoException();
            }
            double[,] z = new double[xRows, yCols];
            for (int i = 0; i < xRows; i++)
            {
                for (int j = 0; j < yCols; j++)
                {
                    double sum = 0d;
                    for (int k = 0; k < xCols; k++)
                    {
                        sum += x[i, k] * y[k, j];
                    }
                    z[i, j] = sum;
                }
            }
            return z;
        }



        private static void EigenValues()
        {
            if (true)
            {
                //http://mathdl.maa.org/mathDL/4/?pa=content&sa=viewDocument&nodeId=607&bodyId=967
                // 0.78  -0.33    A matrix         --> G =    0     0.33/0.78                     [0.423]     lambda1=0, lambda2=-0.33*0.44/(0.78*0.45)=-0.414.
                //-0.44   0.45                                0     0.33*0.44/(0.78*0.45)         [0.414]
                //frml _i x1 = 0.22*x1 + 0.33*x2 + 1;
                //frml _i x2 = 0.44*x1 + 0.55*x2 + 1;

                //Program.model.modelGekko.jacobiMatrixDense = new double[3, 3];
                //Program.model.modelGekko.jacobiMatrixDense[0, 0] = 9;
                //Program.model.modelGekko.jacobiMatrixDense[0, 1] = -1;
                //Program.model.modelGekko.jacobiMatrixDense[0, 2] = 2;
                //Program.model.modelGekko.jacobiMatrixDense[1, 0] = -2;
                //Program.model.modelGekko.jacobiMatrixDense[1, 1] = 8;
                //Program.model.modelGekko.jacobiMatrixDense[1, 2] = 4;
                //Program.model.modelGekko.jacobiMatrixDense[2, 0] = 1;
                //Program.model.modelGekko.jacobiMatrixDense[2, 1] = 1;
                //Program.model.modelGekko.jacobiMatrixDense[2, 2] = 8;



                int n = Program.model.modelGekko.jacobiMatrixDense.GetLength(0);
                double[,] ja = Program.model.modelGekko.jacobiMatrixDense;

                double[,] minusU = new double[n, n];
                double[,] DL = new double[n, n];
                //double[,] d = new double[n, n];

                for (int i = 0; i < n; i++)
                {
                    for (int j = 0; j < n; j++)
                    {
                        if (i >= j) DL[i, j] = ja[i, j];
                        //else if (i > j) l[i, j] = ja[i, j];
                        else if (i < j) minusU[i, j] = -ja[i, j];
                    }
                }

                //alglib.inv.rmatrixinverse(ref DL, n);
                //double[,] g = MultiplyMatrix(DL, minusU);

                ////Array.Copy(Program.model.modelGekko.jacobiMatrixDense, j, Program.model.modelGekko.jacobiMatrixDense.Length);
                //double[] lambda = new double[n];
                //double[] lambdai = new double[n];
                //double[,] vl = new double[n, n];
                //double[,] vr = new double[n, n];

                //bool xx = alglib.nsevd.rmatrixevd(g, n, 0, ref lambda, ref lambdai, ref vl, ref vr);
                //double largest = 0d;
                //for (int i = 0; i < lambda.Length; i++)
                //{
                //    double modulus = Math.Sqrt(lambda[i] * lambda[i] + lambdai[i] * lambdai[i]);
                //    G.Writeln(G.levelFormat(modulus, 10) + " " + G.levelFormat(lambda[i], 10) + " " + G.levelFormat(lambdai[i], 10));
                //    largest = Math.Max(largest, modulus);
                //}
                //G.Writeln("LARGEST LAMBDA = " + largest);
                //G.Writeln();
            }
        }

        private static void ClearMatrix(IElementalAccessMatrix dy)
        {
            for (int c1 = 0; c1 < dy.ColumnCount; c1++)
            {
                for (int c2 = 0; c2 < dy.RowCount; c2++)
                {
                    if (dy.GetValue(c2, c1) != 0)
                    {
                        dy.SetValue(c2, c1, 0d);
                    }
                }
            }
        }



        private static bool IsSimultaneousPrologueVariable(int endo)
        {
            bool flagSimulProlo = false;
            //slack: should create array with feedb vars first
            for (int i3 = 0; i3 < Program.model.modelGekko.m2.simulRecursive.Count; i3++)
            {
                int simProloEndo = Program.model.modelGekko.m2.sparseInfo[(int)Program.model.modelGekko.m2.simulRecursive[i3]][0];  //could be 0,4,5,7
                if (endo == simProloEndo) flagSimulProlo = true;  //the var is a feedback var
            }
            return flagSimulProlo;
        }
        private static bool IsSimultaneousPrologueVariable1(int endo, Hashtable ht)
        {
            return ht.Contains(endo);
        }

        private static bool isFeedbackVariable(int endo)
        {
            bool flagFeedback = false;
            //slack: should create array with feedb vars first
            for (int i3 = 0; i3 < Program.model.modelGekko.m2.simulFeedback.Count; i3++)
            {
                int feedbEndo = Program.model.modelGekko.m2.sparseInfo[(int)Program.model.modelGekko.m2.simulFeedback[i3]][0];  //could be 0,4,5,7
                if (endo == feedbEndo) flagFeedback = true;  //the var is a feedback var
            }
            return flagFeedback;
        }
        private static bool isFeedbackVariable1(int endo, Hashtable ht)
        {
            return ht.Contains(endo);
        }




        public static string Add1ToFileName(string input, string inputLast, string workingFolder)
        {
            DirectoryInfo di = new DirectoryInfo(workingFolder);
            FileInfo[] rgFiles = di.GetFiles(input + "*." + inputLast);
            int high = -1;
            foreach (FileInfo fi in rgFiles)
            {
                string name = fi.Name;
                int idx = name.IndexOf("." + inputLast);
                if (idx > input.Length && idx < name.Length)
                {
                    string name1 = name.Substring(input.Length, name.Length - input.Length - inputLast.Length - 1);
                    int result;
                    if (int.TryParse(name1, out result))
                    {
                        high = Math.Max(result, high);
                    }
                    else
                    {
                        //ignore
                    }
                }
            }
            string name2 = input + (high + 1) + "." + inputLast;
            return name2;
        }

        static public string UnfoldVariableList(StringReader file, Model model)
        {
            // var line can be delimited by spaces or ";", spacing is irrelevant
            // description lines are all following lines (typically 4)
            // a record MUST end with "---" at least, and first line MUST be var line
            // "()" and "//" are ignored all over
            // the index name inside {} must be 1 char only wide
            // file must be in utf-8
            bool firstRealLineFound = false;
            List<Item> shortList = new List<Item>();
            List<Item> longList = new List<Item>();
            int counter = 0;
            int state = 1; //read var
            Item item = new Item();
            bool varlistFound = false;
            while (true)
            {
                //================== read and parse variable line ==============================
                if (file.Peek() < 0) break;
                string line = file.ReadLine();
                line = line.Trim();  //removes all blanks at start or end
                if (G.Equal(line, "varlist$") || G.Equal(line, "varlist;"))
                {
                    varlistFound = true;
                    continue;
                }
                if (varlistFound == false) continue;
                if (line.Length >= 2 && line.Substring(0, 2) == "()") continue;
                if (line.Length >= 2 && line.Substring(0, 2) == "//") continue;
                //if we get here, varlist$ has been found, and the line is not a ()-line or //-line
                if (firstRealLineFound == false && line == "")
                {
                    continue;
                }
                else
                {
                    firstRealLineFound = true;
                }

                if (line.StartsWith("---"))  //at least three '-' ends a block
                {
                    if (true)
                    {
                        counter++;
                        state = 1;
                        shortList.Add(item);
                        item = new Item();
                        continue;
                    }
                }
                if (state == 1)
                {
                    //expects variable
                    EquationBrowserExtractVariableNameEtc(line, item);
                    state = 2;  //expects description
                    continue;
                }
                if (state == 2)
                {
                    //expects description
                    item.explanation.Add(line);
                    state = 2;  //expects more description
                    continue;
                }
            }
            file.Close();

            foreach (Item shortItem in shortList)
            {
                if (shortItem.listOfLists == null)
                {
                    Item temp = new Item();
                    temp.variable = shortItem.variable;
                    temp.explanation = shortItem.explanation;
                    longList.Add(temp);
                    continue;
                }
                List<Item>[] dimensions = new List<Item>[shortItem.listOfLists.Count + 1];
                dimensions[0] = new List<Item>();
                dimensions[0].Add(shortItem);
                for (int d = 0 + 1; d < dimensions.Length; d++)  //for each list {i}->1, {j}->2 etc.
                {
                    dimensions[d] = new List<Item>();
                    foreach (Item original in dimensions[d - 1])
                    {
                        OneList thisList = shortItem.listOfLists[d - 1];
                        foreach (string element in thisList.indexItems)  //for each element in {i] etc.
                        {
                            Item temp = new Item();
                            string variable = original.variable;
                            variable = variable.Replace("{" + thisList.indexName + "}", element);
                            temp.variable = variable;
                            foreach (string line in original.explanation)
                            {
                                string line2 = line;
                                line2 = line2.Replace("{" + thisList.indexName + "}", element);
                                temp.explanation.Add(line2);
                            }
                            dimensions[d].Add(temp);
                        }
                    }
                }
                List<Item> result = dimensions[dimensions.Length - 1];
                longList.AddRange(result);
            }
            string s = null;
            if (counter > 0)
            {
                s = longList.Count + " var labels read";
            }
            model.modelGekko.modelInfo.varlist = longList;
            return s;
        }

        private static void EquationBrowserExtractVariableNameEtc(string line, Item itemFolded)
        {
            int sep = line.IndexOfAny(new char[] { ' ', ';' }, 0);  //search for blank or ';' to separate var name and list, starting at pos 0
            if (sep == -1)  //no separation found, so listOfList if just null
            {
                itemFolded.variable = line;
            }
            else
            {
                //it is a list of items, {i}
                //e.g. "dp{i}{j} i=1,2,3,4,5 j=wb,wm,wt"
                string var = line.Substring(0, sep - 0);
                string var3 = var.Trim();
                itemFolded.variable = var3;
                List<OneList> listOfLists = new List<OneList>();
                bool error = false;
                for (int i = 0; i < var3.Length; i++)
                {
                    if (var3[i] == '{')
                    {
                        if (var3.Length > i + 2)
                        {
                            if (var3[i + 2] == '}')
                            {
                                OneList oneList = new OneList();
                                oneList.indexName = var3.Substring(i + 1, 1);
                                listOfLists.Add(oneList);
                            }
                            else
                            {
                                error = true;
                            }
                        }
                        else
                        {
                            error = true;
                        }
                    }
                    if (error)
                    {
                        new Error("Could not parse indices in '" + var3 + "'", false);
                        G.Writeln(line);
                        G.Writeln();
                    }
                }

                string restOfLine = line.Substring(sep);
                restOfLine.Replace(';', ' ');  // ';' can be used as delimiter instead of space
                restOfLine.Trim();  //now restOfLine is "i=1,2,3,4,5 j=wb,wm,wt" or "i=1,2,3,4,5;j=wb,wm,wt"

                StringTokenizer tok = new StringTokenizer(restOfLine, false, true);
                tok.IgnoreWhiteSpace = true;
                tok.SymbolChars = new char[] { '=', ';', ',' };
                Token token;
                List<string> al = new List<string>();
                List<string> alType = new List<string>();
                do
                {
                    token = tok.Next();
                    al.Add(token.Value); alType.Add(token.Kind.ToString());
                } while (token.Kind != ETokenType.EOF);
                //below is a very innocent hack that makes stopping easier
                //like this, our tokens will end with these 3: {""/"EOF"}  {""/""}  {""/""}
                al.Add("");
                alType.Add("");
                al.Add("");
                alType.Add("");

                for (int i = 0; i < al.Count; i++)
                {
                    if (i + 1 < al.Count && al[i + 1] == "=")  //we have a new list
                    {
                        string name = al[i];
                        List<string> items = new List<string>();
                        for (int j = i + 2; j < al.Count; j += 2)
                        {
                            if (al[j - 1] == "=" || al[j - 1] == ",")
                            {
                                items.Add(al[j]);
                            }
                            else
                            {
                                //presume we are out of listed items
                                bool success = false;
                                foreach (OneList list in listOfLists)
                                {
                                    if (name == list.indexName)
                                    {
                                        success = true;
                                        list.indexItems = items;
                                        break;  //break out of foreach loop
                                    }
                                }
                                if (success == false)
                                {
                                    new Error("Indices do not match");
                                    G.Writeln(line);
                                    G.Writeln();
                                }
                                break;  //break out of j loop, continue i loop
                            }
                        }
                    }
                }
                itemFolded.listOfLists = listOfLists;
            }
        }



        public static Excel.Workbook OpenBook(Excel.Workbooks workbooks, string fileName, bool readOnly, bool editable,
        bool updateLinks)
        {
            Excel.Workbook book = workbooks.Open(
                fileName, updateLinks, readOnly,
                Type.Missing, Type.Missing, Type.Missing, Type.Missing, Type.Missing,
                Type.Missing, editable, Type.Missing, Type.Missing, Type.Missing,
                Type.Missing, Type.Missing);
            return book;
        }

        public static string GetExcelColumnName(int columnNumber)
        {
            int dividend = columnNumber;
            string columnName = String.Empty;
            int modulo;

            while (dividend > 0)
            {
                modulo = (dividend - 1) % 26;
                columnName = Convert.ToChar(65 + modulo).ToString() + columnName;
                dividend = (int)((dividend - modulo) / 26);
            }

            return columnName;
        }

        /// <summary>
        /// Read an Excel xls(x) file, using either EPPlus component or Office interop. Returns a TableLight table for further processing.
        /// </summary>
        /// <param name="file"></param>
        /// <param name="sheetName"></param>
        /// <returns></returns>
        public static TableLight ReadExcel(string file, string sheetName)
        {
            if (Program.options.sheet_engine == "internal")
            {
                return ReadExcel_EPPlus(file, sheetName);
            }
            else
            {
                return ReadExcel_Interop(file, sheetName);
            }
        }

        private static void WriteXlsError(string fileNameWithPath)
        {
            if (fileNameWithPath != null && G.Equal(Path.GetExtension(fileNameWithPath), ".xls"))
            {
                new Error("With 'OPTION sheet engine = internal;', only xlsx files are allowed. Please use 'OPTION sheet engine = excel;' for xls files. Note that option 'engine = excel' requires that Excel is installed on your machine.");


                //throw new GekkoException();
            }
        }

        /// <summary>
        /// Read an Excel xlsx file, using the recommended EPPlus component that does not depend upon Excel or Office. 
        /// Is read into a TableLight table for further processing. The code here will slowly become legacy
        /// </summary>
        /// <param name="file"></param>
        /// <param name="sheetName"></param>
        /// <returns></returns>
        public static TableLight ReadExcel_EPPlus(string file, string sheetName)
        {
            TableLight matrix = new TableLight();

            if (!File.Exists(file))
            {
                new Error("File " + file + " does not seem to exist");
                //throw new GekkoException();
            }

            WriteXlsError(file);

            try
            {

                using (ExcelPackage excel2 = new ExcelPackage(new FileInfo(file)))
                {
                    ExcelWorksheet ws = null;
                    if (sheetName != null)
                    {
                        ws = excel2.Workbook.Worksheets[sheetName];
                        if (ws == null)
                        {
                            new Error("Could not find sheet '" + sheetName + "' inside " + file);
                            //throw new GekkoException();
                        }
                    }
                    else
                    {
                        ws = excel2.Workbook.Worksheets.First<ExcelWorksheet>();
                    }

                    if (ws.Dimension == null)
                    {
                        new Error("It seems the sheet is empty.");
                    }
                    ExcelCellAddress start = ws.Dimension.Start;
                    ExcelCellAddress end = ws.Dimension.End;

                    object[,] intput = (object[,])ws.Cells[1, 1, end.Row, end.Column].Value;
                    int rows2 = intput.GetLength(0);
                    int cols2 = intput.GetLength(1);

                    //beware, this array is 0-based
                    for (int i = 0; i < end.Row; i++)
                    { // Row by row...
                        for (int j = 0; j < end.Column; j++)
                        { // ... Cell by cell...

                            Object temp = intput[i, j];
                            if (temp == null) continue;
                            CellLight cell;
                            Type t = temp.GetType();
                            if (t == typeof(double))
                            {
                                cell = new CellLight((double)temp);
                            }
                            else if (t == typeof(DateTime))
                            {
                                cell = new CellLight((DateTime)temp);
                            }
                            else if (t == typeof(int))
                            {
                                int iData = (int)temp;

                                //-2146826281 = #Div/0!
                                //-2146826246 = #N/A
                                //-2146826259 = #Name?
                                //-2146826288 = #Null!
                                //-2146826252 = #Num!
                                //-2146826265 = #Ref!
                                //-2146826273 = #Value!

                                if (iData == -2146826246)
                                {
                                    //just like it is in a csv file. The -2146826246 is really a hexadecimal error code from Excel, stating that the number is N/A.
                                    cell = new CellLight("#N/A");
                                }
                                else if (iData == -2146826259)
                                {
                                    cell = new CellLight("#Name?");
                                }
                                else if (iData == -2146826281)
                                {
                                    cell = new CellLight("#Div/0");
                                }
                                else
                                {
                                    cell = new CellLight((double)iData);
                                }
                            }
                            else if (temp.GetType() == typeof(string))
                            {
                                cell = new CellLight((string)temp);
                            }
                            else if (temp.GetType() == typeof(OfficeOpenXml.ExcelErrorValue))
                            {
                                cell = new CellLight(double.NaN);
                            }
                            else
                            {
                                Type tt = temp.GetType();
                                string ttt = temp.GetType().ToString();
                                cell = new CellLight("[data not recognized error]");
                            }
                            matrix.Add(i + 1, j + 1, cell);  //i and j are 0-based, matrix needs to be 1-based.

                        }
                    }
                }
            }
            catch (Exception e)
            {
                if (!(e is GekkoException))
                {
                    if (e.Message != null && e.Message != "")
                    {
                        new Error(e.Message, false);
                        WriteExcelError();
                    }
                }
                throw;
            }

            return matrix;
        }

        /// <summary>
        /// Helper method for ReadExcel_EPPlus()
        /// </summary>
        private static void WriteExcelError()
        {
            using (Note n = new Note())
            {
                n.MainAdd("You may set 'OPTION sheet engine = excel;' to use the Excel engine from Gekko 2.2.");
                n.MainAdd("Gekko 3.0 and on uses 'engine = internal' instead of 'engine = excel'. The new engine is");
                n.MainAdd("faster and more robust, but only supports .xslx, and not .xls files. In order to");
                n.MainAdd("use .xls files, you must use 'engine = excel'. If you encounter unexpected errors, please");
                n.MainAdd("try to see if 'engine = excel' solves them (requires Excel).");
            }
        }

        /// <summary>
        /// Read an Excel xls(x) file via interop/PIA. Not really recommended, slow and a bit buggy, but read the old xls format.
        /// </summary>
        /// <param name="file"></param>
        /// <param name="sheetName"></param>
        /// <returns></returns>
        private static TableLight ReadExcel_Interop(string file, string sheetName)
        {
            int threadID = (int)AppDomain.GetCurrentThreadId();  //should be ok, just not for "fibre" threads (on SQL server)... never mind
            if (!File.Exists(file))
            {
                new Error("File " + file + " does not seem to exist");
                //throw new GekkoException();
            }

            //DateTime t00 = DateTime.Now;
            TableLight matrix = new TableLight();
            //using file: this may be a copied file is copylocal is active. Else it is identical to oRead.fileName.

            Excel.Application excel = null;
            Excel.Workbooks workbooks = null;
            Excel.Workbook wkb = null;
            Excel.Sheets objSheets = null;
            Excel.Worksheet sheet = null;
            Excel.Range range = null;
            Excel.Range temprange = null;
            Excel.Range last = null;
            Object value2 = null;
            Object[,] input = null;

            try
            {
                if (true)
                {
                    //THIS SEEMS TO WORK, cf also #5298375235                    
                    //Starts up faster this way
                    if (Globals.objApp == null)
                    {
                        Globals.objApp = new Excel.Application();
                    }
                    else if (Globals.excelLastThreadID != threadID)
                    {
                        //#5298375235
                        Globals.excelLastThreadID = threadID;
                        System.Runtime.InteropServices.Marshal.FinalReleaseComObject(Globals.objApp);
                        Globals.objApp = null;
                        GC.Collect();
                        GC.WaitForPendingFinalizers();
                        // GC needs to be called twice in order to get the Finalizers called
                        // - the first time in, it simply makes a list of what is to be
                        // finalized, the second time in, it actually is finalizing. Only
                        // then will the object do its automatic ReleaseComObject.
                        GC.Collect();
                        GC.WaitForPendingFinalizers();
                        Globals.objApp = new Excel.Application();
                    }
                    excel = Globals.objApp;
                }

                workbooks = excel.Workbooks;

                wkb = OpenBook(workbooks, file, true, false, false);

                objSheets = wkb.Worksheets;

                if (sheetName == null)
                {
                    //do nothing, [1] is al
                    sheet = wkb.Sheets[1] as Excel.Worksheet;
                }
                else
                {
                    bool match = ExcelSheetCheckMatch(objSheets, sheetName);
                    if (match)
                    {
                        sheet = ExcelSheetTryGetSheet(objSheets, sheetName);
                    }
                    else
                    {
                        new Error("The sheet '" + sheetName + "' does not seem to exist", false);
                    }
                }

                //G.Writeln("open excel " + G.Seconds(d3));

                if (sheet != null)
                {
                    temprange = sheet.Cells;
                    last = temprange.SpecialCells(Excel.XlCellType.xlCellTypeLastCell, Type.Missing);
                    range = sheet.get_Range("A1", last);
                    //DateTime t2 = DateTime.Now;
                    value2 = range.Value2;
                    input = (Object[,])value2;
                    //G.Writeln("interop " + G.Seconds(t2));

                    //This is faster regarding the data, but problem is we will not get an error
                    //that points to the problematic cell. Could be implemented at a later point,
                    //if Excel reading becomes a bottleneck.
                    //  double[,] dst = new double[input.GetLength(0), input.GetLength(1)];
                    //  Array.Copy(input, dst, input.Length);

                    int rows = input.GetLength(0);
                    int cols = input.GetLength(1);

                    //DateTime t0 = DateTime.Now;

                    for (int i = 0 + 1; i < rows + 1; i++)
                    {
                        for (int j = 0 + 1; j < cols + 1; j++)
                        {
                            Object temp = input[i, j];
                            if (temp == null) continue;
                            CellLight cell;
                            if (temp.GetType() == typeof(double))
                            {
                                cell = new CellLight((double)temp);
                            }
                            else if (temp.GetType() == typeof(int))
                            {
                                int iData = (int)temp;

                                //-2146826281 = #Div/0!
                                //-2146826246 = #N/A
                                //-2146826259 = #Name?
                                //-2146826288 = #Null!
                                //-2146826252 = #Num!
                                //-2146826265 = #Ref!  
                                //-2146826273 = #Value!

                                if (iData == -2146826246)
                                {
                                    //just like it is in a csv file. The -2146826246 is really a hexadecimal error code from Excel, stating that the number is N/A.
                                    cell = new CellLight("#N/A");
                                }
                                else if (iData == -2146826259)
                                {
                                    cell = new CellLight("#Name?");
                                }
                                else if (iData == -2146826281)
                                {
                                    cell = new CellLight("#Div/0");
                                }
                                else
                                {
                                    cell = new CellLight((double)iData);
                                }
                            }
                            else if (temp.GetType() == typeof(string))
                            {
                                cell = new CellLight((string)temp);
                            }
                            else
                            {
                                new Error("Cell " + GetExcelCell(i, j, false) + " seems to be neither text or number. It has type " + temp.GetType().ToString()); cell = new CellLight();
                                //throw new GekkoException();
                            }
                            matrix.Add(i, j, cell);
                        }
                    }

                    //G.Writeln("loop excel " + G.Seconds(t0));
                }
            }
            catch (Exception ex)
            {
                //if you need to handle stuff
                new Error("Get data from Excel failed with the following message:", false);
                G.Writeln(ex.Message, Color.Red);
                ErrorMessageExcelInterop();
            }
            finally
            {
                //not sure how much of this is absolutely necessary
                //see //#5298375235 and fusion it
                GC.Collect();
                GC.WaitForPendingFinalizers();
                GC.Collect();
                GC.WaitForPendingFinalizers();
                value2 = null;
                input = null;
                Marshal.ReleaseComObject(range);
                Marshal.ReleaseComObject(temprange);
                Marshal.ReleaseComObject(last);
                Marshal.ReleaseComObject(sheet);
                Marshal.ReleaseComObject(objSheets);
                wkb.Close(false);
                Marshal.ReleaseComObject(wkb);
                workbooks.Close();
                Marshal.ReleaseComObject(workbooks);
                excel.Quit();
                // Marshal.ReleaseComObject(excel);
            }
            //G.Writeln("full excel " + G.Seconds(t00));
            return matrix;
        }

        /// <summary>
        /// Write to Excel xls(x) file, using either EPPlus component (recommended) or interop/PIA
        /// </summary>
        /// <param name="eo"></param>
        /// <param name="oPrt"></param>
        /// <param name="isMulprt"></param>
        /// <param name="isMatrix"></param>
        /// <param name="dateformat"></param>
        /// <param name="datetype"></param>
        /// <returns></returns>
        public static ExcelDataForClip WriteExcel(ExcelOptions eo, O.Prt oPrt, bool isMulprt, bool isMatrix, string dateformat, string datetype)
        {
            if (G.Equal(Program.options.sheet_engine, "internal"))
            {
                return WriteExcel_EPPlus(eo, oPrt, isMulprt, isMatrix, dateformat, datetype);
            }
            else
            {
                if (isMatrix)
                {
                    new Error("Matrix export only supported for 'option sheet engine = internal'.");
                }
                if (dateformat != null)
                {
                    new Error("Option 'dateformat' can only be used with 'option sheet engine = internal'.");
                }
                if (datetype != null)
                {
                    new Error("Option 'datetype' can only be used with 'option sheet engine = internal'.");
                }
                return WriteExcel_Interop(eo, oPrt, isMulprt);
            }
        }

        /// <summary>
        /// This basically transfers for instance the double[,] array eo.excelData (the data part of the transfer) to Excel via Epplus.
        /// </summary>
        /// <param name="eo"></param>
        /// <param name="oPrt"></param>
        /// <param name="isMulprt"></param>
        /// <param name="isMatrix"></param>
        /// <param name="dateformat"></param>
        /// <param name="datetype"></param>
        /// <returns></returns>        
        //Just before this method, regarding SHEET, eo.excelData has been made from a Table containing
        //the SHEET output.
        private static ExcelDataForClip WriteExcel_EPPlus(ExcelOptions eo, O.Prt oPrt, bool isMulprt, bool isMatrix, string dateformat, string datetype)
        {
            //
            // NOTE: IsClipOrDna() is always false, these are not done here
            //       clip stuff and dna could be removed here
            //

            // There are these combinations
            // ----------------------------------------------------------------------------------
            //1. append-     filename-     sheet-            show fakefilename sheet='Data'
            //2. append-     filename-     sheet+            show fakefilename sheet=sheetname
            //3. append-     filename+     sheet-            store filename sheet='Data'                        ...as above just silent
            //4. append-     filename+     sheet+            store filename sheet=sheetname                     ...as above just silent
            //5. append+     filename-     sheet-            FAIL
            //6. append+     filename-     sheet+            FAIL
            //7. append+     filename+     sheet-            append to filename, 'Sheet1' (first sheet)         ...use existing file
            //8. append+     filename+     sheet+            append to filename, sheetname                      ...use existing file

            bool useExcelDates = false;  //default
            bool isFirst = true;  //default
            string format = SplitDateFormatInTwo(dateformat, ref isFirst);

            if (G.Equal(datetype, "text")) useExcelDates = false;
            else if (G.Equal(datetype, "excel")) useExcelDates = true;

            try
            {

                bool copyLocal = true;  //always true                
                string fileNameWithPath = null;  //may be pointed to temp file
                string fileNameWithPathOriginal = null;  //may be null, for SHEET
                int blue = System.Drawing.ColorTranslator.ToOle(Globals.LightBlueWord);

                string ext = "xlsx";
                if (oPrt != null && oPrt.opt_filename != null) fileNameWithPath = oPrt.opt_filename;
                else if (eo.fileName != null) fileNameWithPath = eo.fileName;

                WriteXlsError(fileNameWithPath);

                if (fileNameWithPath != null)
                {
                    fileNameWithPath = G.AddExtension(CreateFullPathAndFileName(fileNameWithPath), ".xlsx");
                }
                fileNameWithPathOriginal = fileNameWithPath;

                EAppend append = EAppend.No;
                if (oPrt != null && oPrt.opt_append != null)
                {
                    if (G.Equal(oPrt.opt_append, "yes"))
                    {
                        append = EAppend.Yes;
                    }
                    else if (G.Equal(oPrt.opt_append, "no"))
                    {
                        //already set
                    }
                    else if (G.Equal(oPrt.opt_append, "ifexist"))
                    {
                        append = EAppend.Ifexist;
                    }
                    else
                    {
                        new Error("Append option must be either yes, no or ifexist");
                        //throw new GekkoException();
                    }
                }

                bool isAppend = false;
                if (append == EAppend.Yes) isAppend = true;
                if (append == EAppend.Ifexist)
                {
                    //only activate append if the file is already there
                    if (File.Exists(fileNameWithPathOriginal)) isAppend = true;
                }

                //bool isAppend = false; if (oPrt != null && G.Equal(oPrt.opt_append, "yes")) isAppend = true;

                //Deal with non-existing files
                if (isAppend)
                {
                    if (fileNameWithPathOriginal == null)
                    {
                        //(5) and (6)
                        new Error("You cannot use SHEET<append> without indicating a xlsx filename.");
                        //throw new GekkoException();
                    }

                    if (!File.Exists(fileNameWithPathOriginal))
                    {
                        new Error("You cannot use SHEET<append> on a non-existing file: " + fileNameWithPathOriginal);
                        //throw new GekkoException();
                    }
                }

                //Creates a blank workbook. Use the using statment, so the package is disposed when we are done.
                using (ExcelPackage excel = isAppend ? new ExcelPackage(new FileInfo(fileNameWithPathOriginal)) : new ExcelPackage())
                {
                    if (G.Equal(Path.GetExtension(fileNameWithPath), ".xlsm"))
                    {
                        //this injects some empty VBA code, and the file will then be of .xlsm type.
                        if (excel.Workbook.VbaProject == null) excel.Workbook.CreateVBAProject();
                    }

                    if (copyLocal)
                    {
                        fileNameWithPath = GetTempTsdFilePath(ext); //points to temp file now                     
                    }

                    bool isStamp = false; if (oPrt != null && G.Equal(oPrt.opt_stamp, "yes")) isStamp = true;
                    bool isDates = true; if (oPrt != null && G.Equal(oPrt.opt_dates, "no")) isDates = false;
                    bool isNames = true; if (oPrt != null && G.Equal(oPrt.opt_names, "no")) isNames = false;
                    bool isColors = true; if (oPrt != null && G.Equal(oPrt.opt_colors, "no")) isColors = false;

                    if (isMatrix)
                    {
                        isStamp = false;
                        isColors = false;
                        isNames = false;
                        isDates = false;
                        if (eo.excelRowLabels != null)
                        {
                            isNames = true;
                        }
                        if (eo.excelColumnLabels != null)
                        {
                            isDates = true;  //not really dates for matrices... but oh well                            
                        }
                    }

                    string sheet = null; if (oPrt != null) sheet = oPrt.opt_sheet;

                    bool isRows;
                    bool isCols;
                    HandleRowsCols(oPrt, out isRows, out isCols);

                    bool isTranspose = false;
                    if (isCols) isTranspose = true;  //Normally, SHEET has timeseries running in rows, unlike PRT default. So isTranspose means running in rows.
                    if (G.Equal(eo.transpose, "yes")) isTranspose = true;  //for WRITE<xlsx cols>

                    //string startCell = "a1"; if (oPrt != null && oPrt.opt_cell != null) startCell = oPrt.opt_cell;
                    int datesInt = 0; if (isDates) datesInt++;
                    int namesInt = 0; if (isNames) namesInt++;

                    ExcelWorksheet ws = null;

                    if (isAppend)
                    {
                        if (sheet != null)
                        {
                            //(8)
                            //try to locate the sheet, fail if it is not there
                            ws = excel.Workbook.Worksheets[sheet];
                            if (ws == null)
                            {
                                //we create it if it is not already there
                                ws = excel.Workbook.Worksheets.Add(sheet);
                            }
                        }
                        else
                        {
                            //(7)
                            //no sheet given, we take the one in the first position
                            ws = excel.Workbook.Worksheets.First<ExcelWorksheet>();
                        }
                    }
                    else
                    {
                        if (sheet != null)
                        {
                            //(2) and (4)
                            ws = excel.Workbook.Worksheets.Add(sheet);  //fresh workbook, add fresh sheet with the given name
                        }
                        else
                        {
                            //(1) and (3)
                            ws = excel.Workbook.Worksheets.Add("Data");  //fresh workbook with no sheet name given, we use default name
                        }
                    }

                    int rowcounter = 1;  //1-based
                    int colcounter = 1;  //1-based

                    if (true)
                    {
                        //See identical #98oiwu543w
                        string s2 = "a1";
                        if (oPrt != null && oPrt.opt_cell != null) s2 = oPrt.opt_cell;
                        int index = s2.IndexOfAny(new char[] { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9' });
                        string chars = s2.Substring(0, index);
                        int num = Int32.Parse(s2.Substring(index));
                        int rowOffset = num - 1;
                        int colOffset = ExcelColumnNameToNumber(chars) - 1;

                        rowcounter += rowOffset;
                        colcounter += colOffset;
                    }

                    if (isStamp)
                    {
                        string stamp = GetStamp(isMulprt);

                        if (true)
                        {
                            WorkBookHelper.WorkBookSetData_1(stamp, ws, rowcounter, colcounter);
                            ExcelRange range = ws.Cells[rowcounter, colcounter, rowcounter, colcounter];
                            range.Style.Font.Color.SetColor(System.Drawing.Color.Gray);
                            rowcounter++;
                        }
                    }

                    if (oPrt != null && oPrt.opt_title != null)
                    {
                        string heading = oPrt.opt_title;

                        if (true)
                        {
                            WorkBookHelper.WorkBookSetData_2(heading, ws, rowcounter, colcounter);
                            ExcelRange range = ws.Cells[rowcounter, colcounter, rowcounter, colcounter];
                            range.Style.Font.Bold = true;
                            rowcounter++;
                        }
                    }

                    // ======================== DATA MATRIX ===================================

                    //Get the range where the starting cell has the address
                    //m_sStartingCell and its dimensions are m_iNumRows x m_iNumCols.
                    int dataRows = eo.excelData.GetLength(0);
                    int dataCols = eo.excelData.GetLength(1);

                    int[,] excelColumnLabelsAnnual = new int[1, dataCols];
                    bool allAnnual = false;

                    if (!isMatrix && eo.excelColumnLabels != null)
                    {
                        allAnnual = true;  //start hypothesis, can be invalid for Q, M etc.
                        //Look at the labels, and if all are integers, allAnnual will remain true (else false).
                        //We cannot use current frequency, since we may be for instance printing x!q with frequncy set to annual.
                        for (int i = 0; i < eo.excelColumnLabels.Length; i++)
                        {
                            int z = 0;
                            bool ok = int.TryParse(eo.excelColumnLabels[0, i], out z);
                            if (!ok)
                            {
                                allAnnual = false;
                                break;
                            }
                            excelColumnLabelsAnnual[0, i] = z;
                        }
                    }

                    double[,] data = eo.excelData;

                    int d1 = rowcounter + datesInt;
                    int d2 = colcounter + namesInt;

                    if (isTranspose)
                    {
                        d1 = rowcounter + namesInt;
                        d2 = colcounter + datesInt;
                        data = Transpose(eo.excelData);
                    }

                    if (true)
                    {
                        WorkBookHelper.WorkBookSetData_3(ws, data, d1, d2);

                        if (isColors)
                        {
                            int minus = 0;
                            if (!isTranspose && isNames) minus = 1;
                            if (isTranspose && isDates) minus = 1;
                            ExcelRange range = ws.Cells[d1, d2 - minus, d1 + data.GetLength(0) - 1, d2 + data.GetLength(1) - 1];
                            range.Style.Border.BorderAround(OfficeOpenXml.Style.ExcelBorderStyle.Medium, Globals.LightBlueWord);
                        }
                    }

                    string na = NaForExcelInDifferentLanguages(1);

                    for (int i = 0; i < data.GetLength(0); i++)
                    {
                        for (int j = 0; j < data.GetLength(1); j++)
                        {
                            if (data[i, j] == 9.99999e99d || G.isNumericalError(data[i, j]))
                            {
                                ws.Cells[d1 + i, d2 + j].Formula = "=" + na;
                            }
                        }
                    }

                    //DATES ROW ---------------------------------------------------------------------
                    //DATES ROW ---------------------------------------------------------------------
                    //DATES ROW ---------------------------------------------------------------------

                    if (isDates)
                    {

                        object[,] data2 = null;
                        object[][] datesData = null;

                        if (useExcelDates)
                        {
                            //cf. DateTime.FromOADate(excelvalue);

                            if (isTranspose)
                            {
                                for (int i = d1; i <= d1 + eo.excelColumnLabelsGekkoTime.GetLength(1) - 1; i++)
                                {
                                    for (int j = d2 - 1; j <= d2 - 1 + eo.excelColumnLabelsGekkoTime.GetLength(0) - 1; j++)
                                    {
                                        GekkoTime gt = eo.excelColumnLabelsGekkoTime[j - (d2 - 1), i - d1];
                                        DateTime dt; string f; string discard; GekkoTime.FromGekkoTimeToDifferentFormatsForWriting(gt, isFirst, format, out dt, out f, out discard);
                                        WorkBookHelper.WorkBookSetData_4(ws, i, j, dt, f);
                                    }
                                }
                            }
                            else
                            {
                                for (int i = d1 - 1; i <= d1 - 1 + eo.excelColumnLabelsGekkoTime.GetLength(0) - 1; i++)
                                {
                                    for (int j = d2; j <= d2 + eo.excelColumnLabelsGekkoTime.GetLength(1) - 1; j++)
                                    {
                                        GekkoTime gt = eo.excelColumnLabelsGekkoTime[i - (d1 - 1), j - d2];
                                        DateTime dt; string f; string discard; GekkoTime.FromGekkoTimeToDifferentFormatsForWriting(gt, isFirst, format, out dt, out f, out discard);
                                        WorkBookHelper.WorkBookSetData_5(ws, i, j, dt, f);
                                    }
                                }
                            }
                        }
                        else
                        {
                            //text based dates

                            if (IsGekkoDateFormat(format))
                            {
                                //text based without format --> 2010, 2010q3, 2010m3

                                if (!isMatrix && allAnnual)
                                {
                                    //else the cells are left-justified and with a green triangle (warning)
                                    int[,] datesData2 = null;
                                    if (isTranspose)
                                    {
                                        datesData2 = Transpose(excelColumnLabelsAnnual);
                                    }
                                    else
                                    {
                                        datesData2 = excelColumnLabelsAnnual;
                                    }
                                    datesData = ToJaggedArray(datesData2);
                                }
                                else
                                {
                                    object[,] data3 = null;
                                    if (isTranspose) data3 = Transpose(eo.excelColumnLabels);
                                    else data3 = eo.excelColumnLabels;
                                    datesData = ToJaggedArray(data3);
                                }
                            }
                            else
                            {
                                string[,] tmp = new string[eo.excelColumnLabelsGekkoTime.GetLength(0), eo.excelColumnLabelsGekkoTime.GetLength(1)];
                                for (int i = 0; i < eo.excelColumnLabelsGekkoTime.GetLength(0); i++)
                                {
                                    for (int j = 0; j < eo.excelColumnLabelsGekkoTime.GetLength(1); j++)
                                    {
                                        DateTime dt; string f; string date_as_string;
                                        GekkoTime.FromGekkoTimeToDifferentFormatsForWriting(eo.excelColumnLabelsGekkoTime[i, j], isFirst, format, out dt, out f, out date_as_string);
                                        tmp[i, j] = date_as_string;
                                    }
                                }
                                object[,] data3 = null;
                                if (isTranspose) data3 = Transpose(tmp);
                                else data3 = tmp;
                                datesData = ToJaggedArray(data3);
                            }

                            if (isTranspose)
                            {
                                WorkBookHelper.WorkBookSetData_6(ws, d1, d2, datesData);
                            }
                            else
                            {
                                WorkBookHelper.WorkBookSetData_7(ws, d1, d2, datesData);
                            }
                        }

                        if (!isTranspose && isColors)
                        {
                            int minus = 0;
                            if (isNames) minus = 1;
                            ExcelRange range = ws.Cells[d1 - 1, d2 - minus, d1 - 1 + eo.excelColumnLabels.GetLength(0) - 1, d2 + eo.excelColumnLabels.GetLength(1) - 1];
                            range.Style.Fill.PatternType = OfficeOpenXml.Style.ExcelFillStyle.Solid;
                            range.Style.Fill.BackgroundColor.SetColor(Globals.LightBlueWord);
                            range.Style.Font.Color.SetColor(Color.White);
                        }
                    }

                    //====================== VARIABLE NAMES COLUMN -----------------------------------------------------------------

                    if (isNames)
                    {
                        string[,] labels = null;
                        if (isTranspose)
                        {
                            labels = Transpose(eo.excelRowLabels);
                            WorkBookHelper.WorkBookSetData_8(ws, d1, d2, labels);

                            if (isColors)
                            {
                                int minus = 0;
                                if (isDates) minus = 1;
                                ExcelRange range = ws.Cells[d1 - 1, d2 - minus, d1 - 1 + labels.GetLength(0) - 1, d2 + labels.GetLength(1) - 1];
                                range.Style.Fill.PatternType = OfficeOpenXml.Style.ExcelFillStyle.Solid;
                                range.Style.Fill.BackgroundColor.SetColor(Globals.LightBlueWord);
                                range.Style.Font.Color.SetColor(Color.White);
                            }
                        }
                        else
                        {
                            labels = eo.excelRowLabels;
                            WorkBookHelper.WorkBookSetData_9(ws, d1, d2, labels);
                        }
                    }

                    //Save the new workbook. We haven't specified the filename so use the Save as method.
                    excel.SaveAs(new FileInfo(fileNameWithPath));

                    if (copyLocal)
                    {
                        if (fileNameWithPathOriginal != null)
                        {
                            try
                            {
                                if (File.Exists(fileNameWithPathOriginal)) WaitForFileDelete(fileNameWithPathOriginal);  //probably not necessary
                                WaitForFileCopy(fileNameWithPath, fileNameWithPathOriginal);
                                if (true) G.Writeln2("Wrote dataset with " + dataRows + " rows and " + dataCols + " cols to " + fileNameWithPathOriginal);
                            }
                            catch (Exception e)
                            {
                                new Error("Could not write Excel file -- is it open/blocked?: " + fileNameWithPathOriginal);
                            }
                        }
                    }
                }

                if (fileNameWithPathOriginal == null)
                {
                    try
                    {
                        System.Diagnostics.Process.Start(fileNameWithPath);  //seems faster than below
                                                                             //System.Diagnostics.Process.Start("excel.exe", fileNameWithPath);                 
                    }
                    catch (Exception e)
                    {
                        using (Error err = new Error())
                        {
                            err.MainAdd("Opening the produced .xlsx file with an external program associated with .xlsx");
                            err.MainAdd("files (such as for example Microsoft Excel) failed.");
                            err.MainAdd(e.Message);
                            err.ThrowNoException();
                        }
                    }
                }
            }
            catch (Exception e)
            {
                if (!(e is GekkoException))
                {
                    if (e.Message != null && e.Message != "")
                    {
                        new Error(e.Message, false);
                        WriteExcelError();
                    }
                }
                throw;
            }

            return null;
        }

        /// <summary>
        /// Optional time stamp for writing to Excel
        /// </summary>
        /// <param name="isMulprt"></param>
        /// <returns></returns>
        private static string GetStamp(bool isMulprt)
        {
            StampTypes type = StampTypes.Normal;
            if (isMulprt) type = StampTypes.Multiplier; //we drop .Base for now...

            List<string> lines = GetDatabankInfo(type);
            string ss = GetDateTimePretty(DateTime.Now) + ". ";
            foreach (string s in lines)
            {
                ss = ss + s + ". ";
            }
            if (ss.EndsWith(". ")) ss = ss.Substring(0, ss.Length - 2);
            return ss;
        }

        /// <summary>
        /// Helper method for dealing with Gekko dateformat options (may include "first" or "last").
        /// </summary>
        /// <param name="dateformat"></param>
        /// <param name="isFirst"></param>
        /// <returns></returns>
        private static string SplitDateFormatInTwo(string dateformat, ref bool isFirst)
        {
            string format = null;
            if (dateformat != null)
            {
                format = dateformat;

                if (dateformat.Trim().EndsWith(" first", StringComparison.OrdinalIgnoreCase))
                {
                    format = dateformat.Trim().Substring(0, dateformat.Trim().Length - " first".Length);
                    isFirst = true;
                }
                else if (dateformat.Trim().EndsWith(" last", StringComparison.OrdinalIgnoreCase))
                {
                    format = dateformat.Trim().Substring(0, dateformat.Trim().Length - " last".Length);
                    isFirst = false;
                }
            }

            return format;
        }

        /// <summary>
        /// Helper method for WriteExcel_EPPlus(). Has to transform a 2D array into a jagged array, for some odd reason.
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="twoDimensionalArray"></param>
        /// <returns></returns>
        public static object[][] ToJaggedArray<T>(T[,] twoDimensionalArray)
        {
            int rowsFirstIndex = twoDimensionalArray.GetLowerBound(0);
            int rowsLastIndex = twoDimensionalArray.GetUpperBound(0);
            int numberOfRows = rowsLastIndex + 1;

            int columnsFirstIndex = twoDimensionalArray.GetLowerBound(1);
            int columnsLastIndex = twoDimensionalArray.GetUpperBound(1);
            int numberOfColumns = columnsLastIndex + 1;

            object[][] jaggedArray = new object[numberOfRows][];
            object[][] xx = new object[numberOfRows][];

            for (int i = rowsFirstIndex; i <= rowsLastIndex; i++)
            {
                xx[i] = new object[numberOfColumns];

                for (int j = columnsFirstIndex; j <= columnsLastIndex; j++)
                {
                    xx[i][j] = twoDimensionalArray[i, j];
                }
            }
            return xx;
        }

        /// <summary>
        /// Write to Excel xls(x) file using interop/PIA. Note really recommended, better and faster to use WriteExcel_EPPlus().
        /// The code here will slowly become legacy
        /// </summary>
        /// <param name="eo"></param>
        /// <param name="oPrt"></param>
        /// <param name="isMulprt"></param> 
        /// <returns></returns>
        private static ExcelDataForClip WriteExcel_Interop(ExcelOptions eo, O.Prt oPrt, bool isMulprt)
        {
            Excel.Workbook objBook = null;

            //TODO: #89073253245
            //this method transposes the input-table itself, which is a bit stupid since the table
            //is easy to transpose when it is constructed (with option rows/cols)            

            string stampText = null;
            //TODO: think about extensions. If no extension given, it seems append=yes does not work properly.
            ExcelDataForClip cplotData = new ExcelDataForClip();  //only used if called from CSHEET, data are fetched and returned, but not used for normal WPLOT use.
            bool copyLocal = true;
            int threadID = (int)AppDomain.GetCurrentThreadId();  //should be ok, just not for "fibre" threads (on SQL server)... never mind
            //int managedThreadId = Thread.CurrentThread.ManagedThreadId;  //duer ikke, er ikke distinkt nok
            int blue = System.Drawing.ColorTranslator.ToOle(Globals.LightBlueWord);
            bool blueColors = Program.options.interface_excel_modernlook;
            string version = GetExcelVersion(eOfficeApp.eOfficeApp_Excel);
            if (eo.fileName != null) G.Write("Calling Excel " + version + " ... ");
            //see MS bug 320369
            //without, there was a bug on Excel 2003 (english version), where the language was set to
            //something different that english.
            System.Globalization.CultureInfo oldCI = System.Threading.Thread.CurrentThread.CurrentCulture;
            System.Threading.Thread.CurrentThread.CurrentCulture = new System.Globalization.CultureInfo(Globals.languageEnUS);

            try  //this try makes ture the thread currentculture is set back to what it was
            {

                Excel.Workbooks objBooks = null;
                Excel.Sheets objSheets = null;
                Excel.Worksheet objSheet = null;
                Excel.Range range = null;
                Excel.Worksheet newSheet = null;

                bool isStamp = false; if (oPrt != null && G.Equal(oPrt.opt_stamp, "yes")) isStamp = true;
                bool isDates = true; if (oPrt != null && G.Equal(oPrt.opt_dates, "no")) isDates = false;
                bool isNames = true; if (oPrt != null && G.Equal(oPrt.opt_names, "no")) isNames = false;
                bool isColors = true; if (oPrt != null && G.Equal(oPrt.opt_colors, "no")) isColors = false;
                bool isAppend = false; if (oPrt != null && G.Equal(oPrt.opt_append, "yes")) isAppend = true;
                string sheet = null; if (oPrt != null) sheet = oPrt.opt_sheet;


                bool isRows;
                bool isCols;
                HandleRowsCols(oPrt, out isRows, out isCols);

                bool isTranspose = false;
                if (isCols) isTranspose = true;  //Normally, SHEET has timeseries running in rows, unlike PRT default. So isTranspose means running in rows.
                if (G.Equal(eo.transpose, "yes")) isTranspose = true;  //for WRITE<xlsx cols>

                string startCell = "a1"; if (oPrt != null && oPrt.opt_cell != null) startCell = oPrt.opt_cell;

                int datesInt = 0; if (isDates) datesInt++;
                int namesInt = 0; if (isNames) namesInt++;

                string fileNameWithPath = null;
                string fileName3 = null;
                string fileNameOriginalFile = null;
                string fileNameTempLocalFile = null;

                string ext = null;

                string fileName = null;
                if (oPrt != null && oPrt.opt_filename != null) fileName = oPrt.opt_filename;
                else if (eo.fileName != null) fileName = eo.fileName;

                if (fileName != null)
                {
                    fileNameWithPath = CreateFullPathAndFileName(fileName);
                    fileName3 = fileNameWithPath;
                    if (fileName3.ToLower().EndsWith(".xls")) fileName3 = fileName3.Substring(0, fileName3.Length - 4);
                    if (fileName3.ToLower().EndsWith(".xlsx")) fileName3 = fileName3.Substring(0, fileName3.Length - 5);
                    //fileName3 is stripped of .xls or .xlsx
                    fileNameOriginalFile = "";

                    //A bit hacky...........
                    if (version == "2000" || version == "2003" || version == "95" || version == "97" || version == "XP")
                    {
                        ext = "xls";
                    }
                    else
                    {
                        //"2007"
                        //"2010"
                        //"Unrecognized version", including successor to 2010
                        ext = "xlsx";
                    }
                    fileNameOriginalFile = fileName3 + "." + ext;
                }

                fileNameTempLocalFile = fileNameOriginalFile;  //3a is original file, 4 may become a local copy below

                if (copyLocal)
                {
                    fileNameTempLocalFile = GetTempTsdFilePath(ext);
                    if (isAppend)
                    {
                        try
                        {
                            WaitForFileCopy(fileNameOriginalFile, fileNameTempLocalFile);
                        }
                        catch (Exception e)
                        {
                            new Error("Could not find file: " + fileNameOriginalFile);
                        }
                    }
                }

                try
                {
                    if (!eo.isClip)
                    {
                        if (isAppend)
                        {
                            //TODO, BUG: there is a problem here, if fileNameWithPath has no extension

                            if (Globals.objApp == null)
                            {
                                Globals.objApp = new Excel.Application();
                            }
                            else if (Globals.excelLastThreadID != threadID)
                            {
                                //#5298375235
                                Globals.excelLastThreadID = threadID;
                                System.Runtime.InteropServices.Marshal.FinalReleaseComObject(Globals.objApp);
                                Globals.objApp = null;
                                GC.Collect();
                                GC.WaitForPendingFinalizers();
                                // GC needs to be called twice in order to get the Finalizers called
                                // - the first time in, it simply makes a list of what is to be
                                // finalized, the second time in, it actually is finalizing. Only
                                // then will the object do its automatic ReleaseComObject.
                                GC.Collect();
                                GC.WaitForPendingFinalizers();
                                Globals.objApp = new Excel.Application();
                            }

                            objBooks = Globals.objApp.Workbooks;
                            objBook = objBooks.Open(fileNameTempLocalFile,
                                Type.Missing, Type.Missing, Type.Missing, Type.Missing,
                                Type.Missing, Type.Missing, Type.Missing, Type.Missing,
                                Type.Missing, Type.Missing, Type.Missing, Type.Missing,
                                Type.Missing, Type.Missing);
                            objSheets = objBook.Worksheets;
                            if (sheet == null)
                            {
                                objSheet = (Excel.Worksheet)objSheets.get_Item(1);
                            }
                            else
                            {
                                bool match = ExcelSheetCheckMatch(objSheets, sheet);
                                if (match)
                                {
                                    objSheet = ExcelSheetTryGetSheet(objSheets, sheet);

                                }
                                else
                                {
                                    //creating a new one
                                    objSheet = (Excel.Worksheet)objSheets.Add(objSheets[1], Type.Missing, Type.Missing, Type.Missing);
                                    objSheet.Name = sheet;
                                }
                                // The first argument below inserts the new worksheet as the first one
                            }
                        }
                        else
                        {
                            // Instantiate Excel and start a new workbook.
                            Globals.objApp = new Excel.Application();
                            objBooks = Globals.objApp.Workbooks;
                            objBook = objBooks.Add(Missing.Value);
                            objSheets = objBook.Worksheets;
                            objSheet = (Excel.Worksheet)objSheets.get_Item(1);
                            if (sheet != null)
                            {
                                objSheet.Name = sheet;
                            }
                        }
                    }

                    Excel.Range range0 = null;

                    if (!eo.isClip) range0 = objSheet.get_Range(startCell, Missing.Value);

                    if (isStamp)
                    {
                        StampTypes type = StampTypes.Normal;
                        if (isMulprt) type = StampTypes.Multiplier; //we drop .Base for now...

                        List<string> lines = GetDatabankInfo(type);
                        string ss = GetDateTimePretty(DateTime.Now) + ". ";
                        foreach (string s in lines)
                        {
                            ss = ss + s + ". ";
                        }
                        if (ss.EndsWith(". ")) ss = ss.Substring(0, ss.Length - 2);
                        cplotData.stamp = ss;
                        if (!eo.isClip) if (isColors) range0.Font.Color = System.Drawing.ColorTranslator.ToOle(System.Drawing.Color.Gray);
                        if (!eo.isClip) range0.set_Value(Missing.Value, cplotData.stamp);
                        if (!eo.isClip) range0 = range0.get_Offset(1, 0);
                    }

                    if (oPrt != null && oPrt.opt_title != null)
                    {
                        cplotData.heading = oPrt.opt_title;
                        if (!eo.isClip) if (isColors) range0.Font.Bold = true;
                        if (!eo.isClip) range0.set_Value(Missing.Value, cplotData.heading);
                        if (!eo.isClip) range0 = range0.get_Offset(1, 0);
                    }


                    // ======================== DATA MATRIX ===================================

                    //Get the range where the starting cell has the address
                    //m_sStartingCell and its dimensions are m_iNumRows x m_iNumCols.
                    int dataRows = eo.excelData.GetLength(0);
                    int dataCols = eo.excelData.GetLength(1);

                    int[,] excelColumnLabelsAnnual = new int[1, dataCols];
                    if (options.freq == EFreq.A)
                    {
                        for (int i = 0; i < eo.excelColumnLabels.Length; i++)
                        {
                            //should never give an error
                            excelColumnLabelsAnnual[0, i] = int.Parse(eo.excelColumnLabels[0, i]);
                        }
                    }

                    if (isTranspose)
                    {
                        if (!eo.isClip) range = range0.get_Offset(namesInt, datesInt);
                        if (!eo.isClip) range = range.get_Resize(dataCols, dataRows);
                        double[,] data = Transpose(eo.excelData);
                        if (!eo.isClip) range.set_Value(Missing.Value, data);
                        cplotData.data = data;
                    }
                    else
                    {
                        if (!eo.isClip) range = range0.get_Offset(datesInt, namesInt);
                        if (!eo.isClip) range = range.get_Resize(dataRows, dataCols);
                        double[,] data = eo.excelData;
                        if (!eo.isClip) range.set_Value(Missing.Value, data);
                        cplotData.data = data;
                    }

                    string na = NaForExcelInDifferentLanguages(0);

                    if (!eo.isClip)
                    {
                        Globals.objApp.DisplayAlerts = false;
                        bool success = (bool)range.Replace(
                            "9,99999E+99",
                            "=" + na,
                            1, //XlLookAt.xlWhole,
                            1, //XlSearchOrder.xlByRows,
                            true, Type.Missing, Type.Missing, Type.Missing);
                        success = (bool)range.Replace(
                            "9.99999E+99",
                            "=" + na,
                            1, //XlLookAt.xlWhole,
                            1, //XlSearchOrder.xlByRows,
                            true, Type.Missing, Type.Missing, Type.Missing);
                        success = (bool)range.Replace(  //309827520439857
                            "65535",
                            "=" + na,
                            1, //XlLookAt.xlWhole,
                            1, //XlSearchOrder.xlByRows,
                            true, Type.Missing, Type.Missing, Type.Missing);
                        Globals.objApp.DisplayAlerts = true;
                    }

                    //DATES ROW ---------------------------------------------------------------------
                    //range = objSheet.get_Range("B2", Missing.Value);

                    if (isDates)
                    {

                        if (!eo.isClip)
                        {
                            if (isTranspose)
                            {
                                range = range0.get_Offset(namesInt, 0);
                                range = range.get_Resize(dataCols, 1);
                            }
                            else
                            {
                                range = range0.get_Offset(0, namesInt);
                                range = range.get_Resize(1, dataCols);
                            }
                        }

                        string[,] data2 = null;

                        if (options.freq == EFreq.A)
                        {
                            //else the cells are left-justified and with a green triangle (warning)

                            int[,] data = null;
                            if (isTranspose)
                            {
                                data = Transpose(excelColumnLabelsAnnual);
                                if (!eo.isClip) range.set_Value(Missing.Value, data);
                            }
                            else
                            {
                                data = excelColumnLabelsAnnual;
                                if (!eo.isClip) range.set_Value(Missing.Value, data);
                            }
                            data2 = ConvertToString(data);
                        }
                        else
                        {
                            string[,] data3 = null;
                            if (isTranspose)
                            {
                                data3 = Transpose(eo.excelColumnLabels);
                                if (!eo.isClip) range.set_Value(Missing.Value, data3);
                            }
                            else
                            {
                                data3 = eo.excelColumnLabels;
                                if (!eo.isClip) range.set_Value(Missing.Value, data3);
                            }
                            data2 = data3;
                        }
                        cplotData.dates = data2;
                    }

                    //====================== VARIABLE NAMES COLUMN -----------------------------------------------------------------

                    if (isNames)
                    {
                        string[,] labels = null;
                        if (isTranspose)
                        {
                            if (!eo.isClip) range = range0.get_Offset(0, datesInt);
                            if (!eo.isClip) range = range.get_Resize(1, dataRows);
                            labels = Transpose(eo.excelRowLabels);
                            if (!eo.isClip) range.set_Value(Missing.Value, labels);
                        }
                        else
                        {
                            if (!eo.isClip) range = range0.get_Offset(datesInt, 0);
                            if (!eo.isClip) range = range.get_Resize(dataRows, 1);
                            labels = eo.excelRowLabels;
                            if (!eo.isClip) range.set_Value(Missing.Value, labels);
                        }
                        cplotData.varnames = labels;
                    }

                    cplotData.transpose = isTranspose;
                    if (eo.isClip) return cplotData;

                    //====================== coloring ==============================

                    if (isColors)
                    {
                        if (isTranspose)  //dates running downwards
                        {
                            if (isNames)
                            {
                                //Names row
                                range = range0.get_Offset(0, 0);
                                range = range.get_Resize(1, dataRows + datesInt);
                                if (blueColors)
                                {
                                    range.Interior.Color = blue;
                                    range.Font.Color = System.Drawing.ColorTranslator.ToOle(System.Drawing.Color.White);
                                }
                                else
                                {
                                    range.Borders[Excel.XlBordersIndex.xlEdgeTop].Weight = Excel.XlBorderWeight.xlMedium;
                                    range.Borders[Excel.XlBordersIndex.xlEdgeBottom].Weight = Excel.XlBorderWeight.xlMedium;
                                }
                            }
                        }
                        else
                        {
                            if (isDates)
                            {
                                //Dates row
                                range = range0.get_Offset(0, 0);
                                range = range.get_Resize(1, dataCols + namesInt);
                                if (blueColors)
                                {
                                    range.Interior.Color = blue;
                                    range.Font.Color = System.Drawing.ColorTranslator.ToOle(System.Drawing.Color.White);
                                }
                                else
                                {
                                    range.Borders[Excel.XlBordersIndex.xlEdgeTop].Weight = Excel.XlBorderWeight.xlMedium;
                                    range.Borders[Excel.XlBordersIndex.xlEdgeBottom].Weight = Excel.XlBorderWeight.xlMedium;
                                }
                            }
                        }

                        //Data border
                        if (isTranspose)
                        {
                            range = range0.get_Offset(0, 0);
                            range = range.get_Resize(dataCols + namesInt, dataRows + datesInt);
                        }
                        else
                        {
                            range = range0.get_Offset(0, 0);
                            range = range.get_Resize(dataRows + datesInt, dataCols + namesInt);
                        }
                        if (blueColors)
                        {
                            range.Borders[Excel.XlBordersIndex.xlEdgeTop].Weight = Excel.XlBorderWeight.xlMedium;
                            range.Borders[Excel.XlBordersIndex.xlEdgeTop].Color = blue;
                            range.Borders[Excel.XlBordersIndex.xlEdgeBottom].Weight = Excel.XlBorderWeight.xlMedium;
                            range.Borders[Excel.XlBordersIndex.xlEdgeBottom].Color = blue;
                            range.Borders[Excel.XlBordersIndex.xlEdgeLeft].Weight = Excel.XlBorderWeight.xlMedium;
                            range.Borders[Excel.XlBordersIndex.xlEdgeLeft].Color = blue;
                            range.Borders[Excel.XlBordersIndex.xlEdgeRight].Weight = Excel.XlBorderWeight.xlMedium;
                            range.Borders[Excel.XlBordersIndex.xlEdgeRight].Color = blue;
                        }
                        else
                        {
                            range.Borders[Excel.XlBordersIndex.xlEdgeTop].Weight = Excel.XlBorderWeight.xlMedium;
                            range.Borders[Excel.XlBordersIndex.xlEdgeBottom].Weight = Excel.XlBorderWeight.xlMedium;
                        }

                    }

                    // ===================== put cursor =========================

                    if (fileName == null)
                    {
                        //Return control of Excel to the user.
                        Globals.objApp.Visible = true;
                        Globals.objApp.UserControl = true;
                    }
                    else
                    {
                        // Save the Workbook and quit Excel.
                        Globals.objApp.DisplayAlerts = false;
                        if (isAppend == false)
                        {
                            if (File.Exists(fileNameTempLocalFile)) WaitForFileDelete(fileNameTempLocalFile);  //probably not necessary
                        }
                        if (isAppend)
                        {
                            objBook.Save();
                        }
                        else
                        {
                            //This may just file without error, and without producing a file -- BAD!
                            objBook.SaveCopyAs(fileNameTempLocalFile);
                            //objBook.SaveAs(fileName4, Missing.Value, Missing.Value,
                            //    Missing.Value, false, false, Excel.XlSaveAsAccessMode.xlNoChange,
                            //    false, false, Missing.Value, Missing.Value, Missing.Value);
                        }

                        if (copyLocal)
                        {
                            try
                            {
                                //Maybe use WaitForFileCopy() here at some point.
                                //Not sure why fileNameOriginalFile is deleted first (safety?)
                                WaitForFileCopy(fileNameTempLocalFile, fileNameOriginalFile);
                            }
                            catch (Exception e)
                            {
                                new Error("Could not write Excel file -- is it open/blocked?: " + fileNameOriginalFile);
                            }
                        }

                        ExcelCleanup(ref objBook, ref objBooks, ref objSheets, ref objSheet, ref range, ref newSheet, ref range0);
                        if (true) G.Writeln2("Wrote dataset with " + dataRows + " rows and " + dataCols + " cols to " + fileNameOriginalFile);
                    }
                    return null;
                }
                catch (Exception theException)
                {
                    //G.Writeln(" ...did not finish");
                    String errorMessage;
                    errorMessage = "*** ERROR: Excel failed with the following error: ";
                    errorMessage = String.Concat(errorMessage, theException.Message);
                    errorMessage = String.Concat(errorMessage, " Line: ");
                    errorMessage = String.Concat(errorMessage, theException.Source);
                    G.Writeln(errorMessage);
                    //see MS bug 320369

                    ErrorMessageExcelInterop();

                    System.Threading.Thread.CurrentThread.CurrentCulture = oldCI;
                    throw new GekkoException();
                }
            }
            finally
            {
                //see MS bug 320369
                System.Threading.Thread.CurrentThread.CurrentCulture = oldCI;
            }
        }

        /// <summary>
        /// Error message for read/write of Excel xls(X) file using interop
        /// </summary>
        private static void ErrorMessageExcelInterop()
        {
            using (Note n = new Note())
            {
                n.MainAdd("The Excel engine for import/export of Excel sheets is slow and unstable.");
                n.MainAdd("Consider setting OPTION sheet engine = internal, using a better in-built engine for this.");
                n.MainAdd("However, this only works for the newer .xlsx file format, not for .xls files.");
            }
        }

        /// <summary>
        /// Cleanup ram after WriteExcel_Interop().
        /// </summary>
        /// <param name="objBook"></param>
        /// <param name="objBooks"></param>
        /// <param name="objSheets"></param>
        /// <param name="objSheet"></param>
        /// <param name="range"></param>
        /// <param name="newSheet"></param>
        /// <param name="range0"></param>
        private static void ExcelCleanup(ref Excel.Workbook objBook, ref Excel.Workbooks objBooks, ref Excel.Sheets objSheets, ref Excel.Worksheet objSheet, ref Excel.Range range, ref Excel.Worksheet newSheet, ref Excel.Range range0)
        {
            objBook.Close(false, Missing.Value, Missing.Value);

            Globals.objApp.DisplayAlerts = true;

            if (newSheet != null)
            {
                System.Runtime.InteropServices.Marshal.FinalReleaseComObject(newSheet);
                newSheet = null;
            }
            if (range != null)
            {
                System.Runtime.InteropServices.Marshal.FinalReleaseComObject(range);
                range = null;
            }
            if (range0 != null)
            {
                System.Runtime.InteropServices.Marshal.FinalReleaseComObject(range0);
                range0 = null;
            }
            if (objSheet != null)
            {
                System.Runtime.InteropServices.Marshal.FinalReleaseComObject(objSheet);
                objSheet = null;
            }
            if (objSheets != null)
            {
                System.Runtime.InteropServices.Marshal.FinalReleaseComObject(objSheets);
                objSheets = null;
            }
            if (objBook != null)
            {
                System.Runtime.InteropServices.Marshal.FinalReleaseComObject(objBook);
                objBook = null;
            }
            if (objBooks != null)
            {
                System.Runtime.InteropServices.Marshal.FinalReleaseComObject(objBooks);
                objBooks = null;
            }
            //see also id7372367
            //Globals.objApp = null;  --> dealt with when Gekko exits.
            GC.Collect();
            GC.WaitForPendingFinalizers();
            // GC needs to be called twice in order to get the Finalizers called
            // - the first time in, it simply makes a list of what is to be
            // finalized, the second time in, it actually is finalizing. Only
            // then will the object do its automatic ReleaseComObject.
            GC.Collect();
            GC.WaitForPendingFinalizers();
        }

        /// <summary>
        /// Helper method for ReadExcel_Interop() and WriteExcel_Interop()
        /// </summary>
        /// <param name="objSheets"></param>
        /// <param name="sheet"></param>
        /// <returns></returns>
        private static Excel.Worksheet ExcelSheetTryGetSheet(Excel.Sheets objSheets, string sheet)
        {
            Excel.Worksheet objSheet;
            try
            {
                objSheet = (Excel.Worksheet)objSheets[sheet];  //seems it is not case sensitive
            }
            catch (Exception e)
            {
                new Error("problem while trying to access to existing sheet '" + sheet + "'");
                objSheet = null;
                //throw new GekkoException();
            }

            return objSheet;
        }

        /// <summary>
        /// Helper method for ReadExcel_Interop() and WriteExcel_Interop()
        /// </summary>
        /// <param name="objSheets"></param>
        /// <param name="sheet"></param>
        /// <returns></returns>
        private static bool ExcelSheetCheckMatch(Excel.Sheets objSheets, string sheet)
        {
            bool match = false;
            foreach (Excel.Worksheet xx in objSheets)
            {
                if (G.Equal(xx.Name.Trim(), sheet.Trim()))
                {
                    match = true;
                }
            }

            return match;
        }

        /// <summary>
        /// Helper method for Excel file writing
        /// </summary>
        /// <param name="oPrt"></param>
        /// <param name="isRows"></param>
        /// <param name="isCols"></param>
        private static void HandleRowsCols(O.Prt oPrt, out bool isRows, out bool isCols)
        {
            isRows = false;
            isCols = false;
            if (oPrt != null)
            {
                if (G.Equal(oPrt.prtType, "sheet") || G.Equal(oPrt.prtType, "clip"))
                {
                    isRows = Program.options.sheet_rows;
                    isCols = Program.options.sheet_cols;
                }
                else
                {
                    isRows = false;
                    isCols = true;
                }

                if (isRows && isCols)
                {
                    new Error("It seems that OPTION sheet rows/cols are both set to 'yes'");
                    //throw new GekkoException();
                }
                if (G.Equal(oPrt.opt_rows, "yes") && G.Equal(oPrt.opt_cols, "yes"))
                {
                    new Error("It seems that options <rows> and <cols> are used at the same time");
                    //throw new GekkoException();
                }
                if (G.Equal(oPrt.opt_rows, "yes"))
                {
                    isRows = true;
                    isCols = false;
                }
                else if (G.Equal(oPrt.opt_cols, "yes"))
                {
                    isRows = false;
                    isCols = true;
                }
            }
            else
            {
                isRows = true;
                isCols = false;
            }
        }

        /// <summary>
        /// Gets info on Excel, to show in GUI: Help --> About.
        /// </summary>
        /// <param name="app"></param>
        /// <returns></returns>
        public static string GetExcelVersion(Program.eOfficeApp app)
        {
            return Program.GetExcelVersion2(Program.GetApplicationVersion(app));
        }

        /// <summary>
        /// Transpose a double[,] array.
        /// </summary>
        /// <param name="x"></param>
        /// <returns></returns>
        public static double[,] Transpose(double[,] x)
        {
            double[,] y = new double[x.GetLength(1), x.GetLength(0)];
            for (int i = 0; i < x.GetLength(0); i++)
            {
                for (int j = 0; j < x.GetLength(1); j++)
                {
                    y[j, i] = x[i, j];
                }
            }
            return y;
        }

        /// <summary>
        /// Helper method for the internal --rungenr1 and --rungenr2
        /// </summary>
        /// <param name="i"></param>
        public static void Rungenr(int i)
        {
            if (i == 1)
            {
                if (Globals.lastDynamicCsCode != null && Globals.lastDynamicCsCode.Contains("TranslatedCode"))
                {
                    string s = Application.ExecutablePath;
                    string s2 = Path.GetDirectoryName(s);
                    string s3 = s2.Replace("\\Debug", "");
                    string s4 = s3.Replace("\\bin", "");
                    StreamWriter sw = new StreamWriter(s4 + "\\Genr.cs");
                    sw.Write(Globals.lastDynamicCsCode);
                    sw.Flush();
                    sw.Close();
                }
                else
                {
                    G.Writeln2("---> empty CS code... --> fail");
                }
            }
            else if (i == 2)
            {
                //Gekko.TranslatedCode.CodeLines(new P());
                TranslatedCode xx = new TranslatedCode();
                TranslatedCode.CodeLines(new P());
            }
        }

        /// <summary>
        /// Transpose int[,] array
        /// </summary>
        /// <param name="x"></param>
        /// <returns></returns>
        public static int[,] Transpose(int[,] x)
        {
            int[,] y = new int[x.GetLength(1), x.GetLength(0)];
            for (int i = 0; i < x.GetLength(0); i++)
            {
                for (int j = 0; j < x.GetLength(1); j++)
                {
                    y[j, i] = x[i, j];
                }
            }
            return y;
        }

        /// <summary>
        /// Convert an int[,] array to a string[,] array (used in WriteExcel_Interop())
        /// </summary>
        /// <param name="x"></param>
        /// <returns></returns>
        public static string[,] ConvertToString(int[,] x)
        {
            string[,] y = new string[x.GetLength(0), x.GetLength(1)];
            for (int i = 0; i < x.GetLength(0); i++)
            {
                for (int j = 0; j < x.GetLength(1); j++)
                {
                    y[i, j] = x[i, j].ToString();
                }
            }
            return y;
        }

        /// <summary>
        /// Transpose a string[,] array
        /// </summary>
        /// <param name="x"></param>
        /// <returns></returns>
        public static string[,] Transpose(string[,] x)
        {
            string[,] y = new string[x.GetLength(1), x.GetLength(0)];
            for (int i = 0; i < x.GetLength(0); i++)
            {
                for (int j = 0; j < x.GetLength(1); j++)
                {
                    y[j, i] = x[i, j];
                }
            }
            return y;
        }

        /// <summary>
        /// Helper method for GetExcelVersion()
        /// </summary>
        /// <param name="input"></param>
        /// <returns></returns>
        public static string GetExcelVersion2(eOfficeVersion input)
        {
            if (input == eOfficeVersion.eOfficeVersion_95) return "95";
            if (input == eOfficeVersion.eOfficeVersion_97) return "97";
            if (input == eOfficeVersion.eOfficeVersion_XP) return "XP";
            if (input == eOfficeVersion.eOfficeVersion_2000) return "2000";
            if (input == eOfficeVersion.eOfficeVersion_2003) return "2003";
            if (input == eOfficeVersion.eOfficeVersion_2007) return "2007";
            if (input == eOfficeVersion.eOfficeVersion_2010) return "2010";
            if (input == eOfficeVersion.eOfficeVersion_2013) return "2013";
            if (input == eOfficeVersion.eOfficeVersion_2016) return "2016";
            if (input == eOfficeVersion.eOfficeVersion_2019) return "2019?";
            if (input == eOfficeVersion.eOfficeVersion_Unrecognized) return "[Unrecognized]";
            return "[Unrecognized]";
        }

        /// <summary>
        /// Helper method for GetExcelVersion().
        /// </summary>
        /// <param name="appToCheck"></param>
        /// <returns></returns>
        public static eOfficeVersion GetApplicationVersion(eOfficeApp appToCheck)
        {
            // some of this function is based on the code in the article at: http://support.microsoft.com/kb/q247985/
            string progID = GetProgID(appToCheck);

            RegistryKey hKey = Registry.ClassesRoot.OpenSubKey(progID, RegistryKeyPermissionCheck.ReadSubTree, System.Security.AccessControl.RegistryRights.ReadKey);
            if (hKey == null)
                return eOfficeVersion.eOfficeVersion_Unrecognized;

            RegistryKey hKey1 = hKey.OpenSubKey("CurVer", RegistryKeyPermissionCheck.ReadSubTree, System.Security.AccessControl.RegistryRights.ReadKey);
            if (hKey1 == null)
            {
                hKey1.Close();
                hKey.Close();
                return eOfficeVersion.eOfficeVersion_Unrecognized;
            }

            // Get the Version information
            string progAndVersion = (string)hKey1.GetValue("");

            // Close the registry keys
            hKey1.Close();
            hKey.Close();

            // Error while querying for value
            if (progAndVersion == null)
                return eOfficeVersion.eOfficeVersion_Unrecognized;

            // At this point progAndVersion contains the ProgID followed by a number.
            // For example, Word 97 will return Word.Application.8 and Word 2000 will return Word.Application.9

            int lastDot = progAndVersion.LastIndexOf('.');
            int firstCharOfVersion = lastDot + 1; // + 1 to get rid of the dot at the front
            string versionString = progAndVersion.Substring(firstCharOfVersion, progAndVersion.Length - firstCharOfVersion);

            return GetApplicationVersionHelper(versionString);
        }

        /// <summary>
        /// Helper method for GetApplicationVersion().
        /// </summary>
        /// <param name="officeApp"></param>
        /// <returns></returns>
        public static string GetProgID(eOfficeApp officeApp)
        {
            // ProgIDs from http://support.microsoft.com/kb/240794/EN-US/
            switch (officeApp)
            {
                case eOfficeApp.eOfficeApp_Word: { return "Word.Application"; } break;
                case eOfficeApp.eOfficeApp_Excel: { return "Excel.Application"; } break;
                case eOfficeApp.eOfficeApp_Outlook: { return "Outlook.Application"; } break;
                case eOfficeApp.eOfficeApp_Access: { return "Access.Application"; } break;
                case eOfficeApp.eOfficeApp_PowerPoint: { return "Powerpoint.Application"; } break;
                default: { /*ASSERT(false);*/ return string.Empty; } break; // added another ???
            }
        }

        /// <summary>
        /// Helper method for GetApplicationVersion()
        /// </summary>
        /// <param name="versionString"></param>
        /// <returns></returns>
        public static eOfficeVersion GetApplicationVersionHelper(string versionString)
        {
            // mapping between the marketing version (e.g. 2003) and the behind-the-scenes version
            if ("7" == versionString)
            {
                return eOfficeVersion.eOfficeVersion_95;
            }
            else if ("8" == versionString)
            {
                return eOfficeVersion.eOfficeVersion_97;
            }
            else if ("9" == versionString)
            {
                return eOfficeVersion.eOfficeVersion_2000;
            }
            else if ("10" == versionString)
            {
                return eOfficeVersion.eOfficeVersion_XP;
            }
            else if ("11" == versionString)
            {
                return eOfficeVersion.eOfficeVersion_2003;
            }
            else if ("12" == versionString)
            {
                return eOfficeVersion.eOfficeVersion_2007;
            }
            else if ("13" == versionString || "14" == versionString)  //apparently 13 is not used because of superstition
            {
                return eOfficeVersion.eOfficeVersion_2010;
            }
            else if ("15" == versionString)  //this seems to be 2013 internal number
            {
                return eOfficeVersion.eOfficeVersion_2013;
            }
            else if ("16" == versionString)
            {
                return eOfficeVersion.eOfficeVersion_2016;
            }
            else if ("17" == versionString)
            {
                return eOfficeVersion.eOfficeVersion_2019;
            }
            else
            {
                return eOfficeVersion.eOfficeVersion_Unrecognized; // added another ???
            }
        }

        /// <summary>
        /// Use method CalculateHistoricalVarianceForVariable() to calculate such variances for b-variables (endogenous)
        /// </summary>
        /// <param name="timeSeriesPointers"></param>
        /// <param name="t0"></param>
        public static void CreateBVariance(Series[] timeSeriesPointers, GekkoTime t0)
        {
            foreach (int i in Program.model.modelGekko.endogenousBNumbersOriginalInModelList)
            {
                Series ts = timeSeriesPointers[i];
                double d = CalculateHistoricalVarianceForVariable(ts, t0);
                Program.model.modelGekko.bVariance[i] = d;
            }
        }

        /// <summary>
        /// Used for convergence checks, looks at historical variance for endogenous variables, to see what a 
        /// "large" deviation is supposed to mean. This is practical, especially for variables that fluctuate
        /// around zero.
        /// </summary>
        /// <param name="ts"></param>
        /// <param name="year0"></param>
        /// <returns></returns>
        public static double CalculateHistoricalVarianceForVariable(Series ts, GekkoTime year0)
        {
            //only abs calc is used
            if (ts == null) return double.NaN;
            double v3 = ts.GetDataSimple(year0.Add(-2));  //TODO: what about freq?
            double v2 = ts.GetDataSimple(year0.Add(-1));
            double v1 = ts.GetDataSimple(year0);

            double v = ((Math.Abs(v3) + Math.Abs(v2) + Math.Abs(v1)) / 3d);  //abs mean, not used
            double dLag = Math.Abs(v2 - v3);  //diff for x(-1)-x(-2)
            double dNonlag = Math.Abs(v1 - v2);  //diff for x-x(-1)
            double d = (dLag + dNonlag) / 2d;  //mean diff, ONLY THIS IS USED!
            double rel = d / v;  //not used

            //d resembles rss on differences, v resembles rss on levels.
            //d and v measure mean distance from x axis.
            //d = (abs(x - x[-1]) + abs(x[-1] - x[-2])) / 2
            //v = (abs(x] + abs(x[-1]) + abs(x[-2])) / 3
            //rel = d / v

            if (double.IsInfinity(d))
            {
                //seems there are none of these, how could there?
                d = double.NaN;  //for simplicity later on
            }

            if (d == 0)
            {
                //there are some of these, most with all values = 0
            }

            if (G.isNumericalError(d))
            {
                //seems there are none of these
            }

            return d;
        }

        /// <summary>
        /// Used for TSP interface.
        /// </summary>
        /// <param name="dataFile"></param>
        /// <param name="ignoreWhiteSpace"></param>
        /// <param name="addWorkingFolder"></param>
        /// <param name="al"></param>
        /// <param name="alType"></param>
        public static void TokensFromFileToArrayList(String dataFile, bool ignoreWhiteSpace, bool addWorkingFolder, List<string> al, List<string> alType)
        {
            //Only used in TSP utilities

            String all;
            String all2;
            String temp1 = "";
            String temp2 = "";

            //content is read from a .frm file
            string fileName = null;
            if (addWorkingFolder)
            {
                fileName = Program.options.folder_working + "\\" + dataFile;
            }
            else
            {
                fileName = dataFile;
            }

            all = GetTextFromFileWithWait(fileName);

            all2 = G.oddX0000Hack(all);
            StringTokenizer tok = new StringTokenizer(all2, false, true);
            tok.IgnoreWhiteSpace = ignoreWhiteSpace;
            tok.SymbolChars = new char[] { '?', '(', ')', '=', '+', '-', '*', '/', '$' };
            Token token;

            //----------------------------------------------------
            //read into ArrayList alStart and alStartType
            do
            {
                token = tok.Next(); temp1 = token.Kind.ToString(); temp2 = token.Value;
                al.Add(temp2); alType.Add(temp1);
            } while (token.Kind != ETokenType.EOF);
            //adding extra blanks, to avoid problems with overrun when probing alStart[i+x]
            for (int i = 1; i < Globals.extra; i++)
            {
                al.Add(""); alType.Add("");
            }
        }

        /// <summary>
        /// Menu item Utilities --> Compare model/databank/varlist...  This will compare variable names in the three places,
        /// identifying "missing" or superfluous variables. Used for maintenance.
        /// </summary>
        public static void CompareModelDatabankVarlist()
        {
            if (G.GetModelSourceType() != EModelType.Gekko)
            {
                new Error("No Gekko model seems to be loaded, cf. the MODEL statement. The comparison could not be performed.");
            }
            int dublets = 0;
            Dictionary<string, int> varlistDublets = new Dictionary<string, int>();
            CaseInsensitiveHashtable varlist = new CaseInsensitiveHashtable();
            if (Program.model?.modelGekko?.modelInfo?.varlist != null)
            {
                foreach (Program.Item item in Program.model.modelGekko.modelInfo.varlist)
                {
                    string varName = item.variable;
                    if (varlist.ContainsKey(varName))
                    {
                        dublets++;
                        if (varlistDublets.ContainsKey(varName))
                        {
                            varlistDublets[varName]++;
                        }
                        else
                        {
                            varlistDublets.Add(varName, 2);
                        }
                    }
                    else
                    {
                        varlist.Add(varName, "");
                    }
                }
            }
            else
            {
                new Note("A variable list was not found inside model file");
            }

            List<string> bothModelAndVarlist = new List<string>();
            List<string> onlyModelNotVarlist = new List<string>();
            List<string> onlyVarlistNotModel = new List<string>();
            List<string> bothModelAndDatabank = new List<string>();
            List<string> onlyModelNotDatabank = new List<string>();
            List<string> onlyDatabankNotModel = new List<string>();
            List<string> bothDatabankAndVarlist = new List<string>();
            List<string> onlyDatabankNotVarlist = new List<string>();
            List<string> onlyVarlistNotDatabank = new List<string>();

            foreach (string ss in Program.databanks.GetFirst().storage.Keys)
            {
                if (G.GetFreqFromName(ss) != Program.options.freq) continue;  //filter other freqs
                string s = G.Chop_RemoveFreq(ss);
                if (Program.model.modelGekko.varsDTypeAutoGenerated.ContainsKey(s) || Program.model.modelGekko.varsJTypeAutoGenerated.ContainsKey(s) || Program.model.modelGekko.varsZTypeAutoGenerated.ContainsKey(s)) continue;
                if (Program.model.modelGekko.varsAType.ContainsKey(s))
                {
                    bothModelAndDatabank.Add(s);
                }
                else
                {
                    onlyDatabankNotModel.Add(s);
                }

                if (varlist.ContainsKey(s))
                {
                    bothDatabankAndVarlist.Add(s);
                }
                else
                {
                    onlyDatabankNotVarlist.Add(s);
                }
            }

            foreach (string s in Program.model.modelGekko.varsAType.Keys)
            {
                if (Program.model.modelGekko.varsDTypeAutoGenerated.ContainsKey(s) || Program.model.modelGekko.varsJTypeAutoGenerated.ContainsKey(s) || Program.model.modelGekko.varsZTypeAutoGenerated.ContainsKey(s)) continue;
                if (Program.databanks.GetFirst().ContainsIVariable(s + Globals.freqIndicator + G.ConvertFreq(Program.options.freq)))
                {
                }
                else
                {
                    onlyModelNotDatabank.Add(s);
                }
                if (varlist.ContainsKey(s))
                {
                    bothModelAndVarlist.Add(s);
                }
                else
                {
                    onlyModelNotVarlist.Add(s);
                }
            }


            foreach (string s in varlist.Keys)
            {
                if (Program.databanks.GetFirst().ContainsIVariable(s + Globals.freqIndicator + G.ConvertFreq(Program.options.freq)))
                {
                }
                else
                {
                    onlyVarlistNotDatabank.Add(s);
                }
                if (Program.model.modelGekko.varsAType.ContainsKey(s))
                {
                }
                else
                {
                    onlyVarlistNotModel.Add(s);
                }
            }

            bothModelAndVarlist.Sort(StringComparer.InvariantCulture);
            onlyModelNotVarlist.Sort(StringComparer.InvariantCulture);
            onlyVarlistNotModel.Sort(StringComparer.InvariantCulture);
            bothModelAndDatabank.Sort(StringComparer.InvariantCulture);
            onlyModelNotDatabank.Sort(StringComparer.InvariantCulture);
            onlyDatabankNotModel.Sort(StringComparer.InvariantCulture);
            bothDatabankAndVarlist.Sort(StringComparer.InvariantCulture);
            onlyDatabankNotVarlist.Sort(StringComparer.InvariantCulture);
            onlyVarlistNotDatabank.Sort(StringComparer.InvariantCulture);

            string fullFileNameAndPath = CreateFullPathAndFileName("compare.txt");

            using (FileStream fs = WaitForFileStream(fullFileNameAndPath, null, GekkoFileReadOrWrite.Write))
            using (StreamWriter compareFile = G.GekkoStreamWriter(fs))
            {

                if (dublets > 0)
                {
                    compareFile.WriteLine("NOTE: there were " + dublets + " dublets in the varlist.");
                    compareFile.WriteLine("These dublets are ignored in the following comparisons.");
                    compareFile.WriteLine("The dublets are listed at the bottom of this file.");
                    compareFile.WriteLine();
                }
                compareFile.WriteLine("When comparing, auto-generated DJZ-type exogenous variables are ignored.");
                compareFile.WriteLine("Such variables appear in the model, sometimes in the databank");
                compareFile.WriteLine("(for instance when writing after a simulation), but in general");
                compareFile.WriteLine("not in the varlist. So comparing these kinds of variables does not");
                compareFile.WriteLine("make much sense and would just pollute the comparison.");
                compareFile.WriteLine();
                compareFile.WriteLine("----------------------------------------------------------");
                compareFile.WriteLine("--------------------- Model/databank ---------------------");
                compareFile.WriteLine("----------------------------------------------------------");
                compareFile.WriteLine("Both model and databank:     " + G.IntFormat(bothModelAndDatabank.Count, 7) + " variables");
                compareFile.WriteLine("In databank, not in model:   " + G.IntFormat(onlyDatabankNotModel.Count, 7) + " variables");
                compareFile.WriteLine("In model, not in databank:   " + G.IntFormat(onlyModelNotDatabank.Count, 7) + " variables");
                compareFile.WriteLine();
                compareFile.WriteLine("----------------------------------------------------------");
                compareFile.WriteLine("--------------------- Model/varlist  ---------------------");
                compareFile.WriteLine("----------------------------------------------------------");
                compareFile.WriteLine("Both model and varlist:      " + G.IntFormat(bothModelAndVarlist.Count, 7) + " variables");
                compareFile.WriteLine("In model, not in varlist:    " + G.IntFormat(onlyModelNotVarlist.Count, 7) + " variables");
                compareFile.WriteLine("In varlist, not in model:    " + G.IntFormat(onlyVarlistNotModel.Count, 7) + " variables");
                compareFile.WriteLine();
                compareFile.WriteLine("----------------------------------------------------------");
                compareFile.WriteLine("--------------------- Databank/varlist  ------------------");
                compareFile.WriteLine("----------------------------------------------------------");
                compareFile.WriteLine("Both databank and varlist:   " + G.IntFormat(bothDatabankAndVarlist.Count, 7) + " variables");
                compareFile.WriteLine("In varlist, not in databank: " + G.IntFormat(onlyVarlistNotDatabank.Count, 7) + " variables");
                compareFile.WriteLine("In databank, not in varlist: " + G.IntFormat(onlyDatabankNotVarlist.Count, 7) + " variables");
                compareFile.WriteLine();
                compareFile.WriteLine();
                compareFile.WriteLine("Below, missing variables are listed");
                compareFile.WriteLine();
                compareFile.WriteLine("In databank, not in model:   " + G.IntFormat(onlyDatabankNotModel.Count, 7) + " variables");
                compareFile.WriteLine("----------------------------------------------------------");
                G.PrintListWithCommasToFile(compareFile, onlyDatabankNotModel);
                compareFile.WriteLine();
                compareFile.WriteLine();
                compareFile.WriteLine("In model, not in databank:   " + G.IntFormat(onlyModelNotDatabank.Count, 7) + " variables");
                compareFile.WriteLine("----------------------------------------------------------");
                G.PrintListWithCommasToFile(compareFile, onlyModelNotDatabank);
                compareFile.WriteLine();
                compareFile.WriteLine();
                compareFile.WriteLine("In model, not in varlist:    " + G.IntFormat(onlyModelNotVarlist.Count, 7) + " variables");
                compareFile.WriteLine("----------------------------------------------------------");
                G.PrintListWithCommasToFile(compareFile, onlyModelNotVarlist);
                compareFile.WriteLine();
                compareFile.WriteLine();
                compareFile.WriteLine("In varlist, not in model:    " + G.IntFormat(onlyVarlistNotModel.Count, 7) + " variables");
                compareFile.WriteLine("----------------------------------------------------------");
                G.PrintListWithCommasToFile(compareFile, onlyVarlistNotModel);
                compareFile.WriteLine();
                compareFile.WriteLine();
                compareFile.WriteLine("In varlist, not in databank: " + G.IntFormat(onlyVarlistNotDatabank.Count, 7) + " variables");
                compareFile.WriteLine("----------------------------------------------------------");
                G.PrintListWithCommasToFile(compareFile, onlyVarlistNotDatabank);
                compareFile.WriteLine();
                compareFile.WriteLine();
                compareFile.WriteLine("In databank, not in varlist: " + G.IntFormat(onlyDatabankNotVarlist.Count, 7) + " variables");
                compareFile.WriteLine("----------------------------------------------------------");
                G.PrintListWithCommasToFile(compareFile, onlyDatabankNotVarlist);
                compareFile.WriteLine();
                compareFile.WriteLine();
                compareFile.WriteLine();
                compareFile.WriteLine("-----------------------------------------------------------");
                compareFile.WriteLine("The following variables are dublets in the varlist");
                foreach (KeyValuePair<string, int> x in varlistDublets)
                {
                    compareFile.WriteLine(G.varFormat(x.Key) + " --> " + x.Value + " times");
                }
                if (varlistDublets.Count == 0) compareFile.WriteLine("<none>");
                compareFile.Flush();
            }
        }

        /// <summary>
        /// Fires an action after x milliseconds.
        /// </summary>
        /// <param name="millisecond"></param>
        /// <param name="action"></param>
        public static void DelayAction(int millisecond, Action action)
        {
            var timer = new System.Windows.Threading.DispatcherTimer();
            timer.Tick += delegate
            {
                action.Invoke();
                timer.Stop();
            };
            timer.Interval = TimeSpan.FromMilliseconds(millisecond);
            timer.Start();
        }

        /// <summary>
        /// Check residuals. From Gekko GUI, use --> Utilities --> Check residuals...  Residual check checks if model 
        /// equations are in agreement, especially important for identities.
        /// </summary>
        /// <param name="checkType"></param>
        /// <param name="dlog"></param>
        /// <param name="split"></param>
        private static void ResidualCheck(string checkType, bool dlog, bool split)
        {
            string outputPath = Globals.localTempFilesLocation + "\\" + "residualcheck";
            G.DeleteFolder(outputPath, true);
            Directory.CreateDirectory(outputPath);

            //This code is not high-performant, but oh well...
            if (split)
            {
                List<string> d = new List<string>();
                foreach (EquationHelper eh in Program.model.modelGekko.equations)
                {
                    string block = eh.modelBlock;
                    if (!d.Contains(block)) d.Add(block);
                }
                d.Sort();
                foreach (string s in d)
                {
                    ResidualCheckHelper(checkType, dlog, s, outputPath);
                }
            }
            else ResidualCheckHelper(checkType, dlog, null, outputPath);

            G.Writeln();
            G.Write("Zipping residual check files... ");
            string zipfile = Program.options.folder_working + "\\residual_check.zip";
            string zipFileNameInput = Program.CreateFullPathAndFileName(zipfile);
            Program.WaitForZipWrite(outputPath, zipFileNameInput);
            G.Writeln("... ended");
            G.Writeln("See 'residual_check.zip'");
            G.Writeln();
        }

        /// <summary>
        /// Helper method for ResidualCheck().
        /// </summary>
        /// <param name="checkType"></param>
        /// <param name="dlog"></param>
        /// <param name="block"></param>
        /// <param name="path"></param>
        private static void ResidualCheckHelper(string checkType, bool dlog, string block, string path)
        {
            Databank work = Program.databanks.GetFirst();
            List<string> d_type = new List<string>();
            List<string> g_type = new List<string>();
            List<string> i_type = new List<string>();
            List<string> k_type = new List<string>();
            List<string> s_type = new List<string>();
            List<string> after_i_type = new List<string>();
            List<string> after_d_type = new List<string>();

            foreach (EquationHelper eh in Program.model.modelGekko.equations)
            {
                if (block != null && !G.Equal(block, eh.modelBlock)) continue; //out-filtering those that are not in chosen block
                string var = eh.lhs;
                string code = eh.equationCode;

                if (true)
                {
                    if (G.Equal(code.Substring(0, 1), "i"))
                    {
                        after_i_type.Add(var);
                    }
                    else if (G.Equal(code.Substring(0, 1), "d"))  //in frml file, it starts with "y" and typically var name (yEnly)
                    {
                        after_d_type.Add(var);
                    }
                    else
                    {
                        if (code.Length <= 1)
                        {
                            new Warning("Formula code regarding '" + var + "' seems problematic: " + code);
                        }
                        if (code.Length >= 2)
                        {
                            if (code.Substring(0, 1) != "_")
                            {
                                new Warning("Formula code regarding '" + var + "' does not start with '_' or 'i' or 'y': " + code);
                            }
                            else
                            {
                                string type = code.Substring(1, 1).ToLower();
                                if (type == "d")
                                {
                                    d_type.Add(var);
                                }
                                else if (type == "g")
                                {
                                    g_type.Add(var);
                                }
                                else if (type == "i")
                                {
                                    i_type.Add(var);
                                }
                                else if (type == "k")
                                {
                                    k_type.Add(var);
                                }
                                else if (type == "s")
                                {
                                    s_type.Add(var);
                                }
                                else
                                {
                                    new Warning("There was a unknown formula code type (i.e. not _d, _g, _i, _k or _s) regarding '" + var + "': " + code);
                                }
                            }
                        }
                        else
                        {
                            new Warning("There was a unknown formula code type (i.e. not _d, _g, _i, _k or _s) regarding '" + var + "': " + code);
                        }
                    }
                }
            }

            int t1 = Globals.globalPeriodStart.super;
            int t2 = Globals.globalPeriodEnd.super;

            string type2 = "";
            bool order = false;
            if (checkType == "absolute")
            {
                type2 = "absolute";
                order = true;
            }
            else if (checkType == "relative")
            {
                type2 = "relative";
                order = true;
            }
            else if (checkType == "alphabetical")
            {
                type2 = "alphabetical";
                order = false;
            }
            else
            {
                //hmmmm
            }

            GekkoTime gt1 = new GekkoTime((Program.options.freq), t1, 1);
            GekkoTime gt2 = new GekkoTime((Program.options.freq), t2, 1);

            Sam(gt1, gt2, Program.databanks.GetRef(), Program.databanks.GetFirst(), type2, order, d_type, "_d", dlog, block, path, null, null, double.NaN, double.NaN, false);
            Sam(gt1, gt2, Program.databanks.GetRef(), Program.databanks.GetFirst(), type2, order, g_type, "_g", dlog, block, path, null, null, double.NaN, double.NaN, false);
            Sam(gt1, gt2, Program.databanks.GetRef(), Program.databanks.GetFirst(), type2, order, i_type, "_i", dlog, block, path, null, null, double.NaN, double.NaN, false);
            Sam(gt1, gt2, Program.databanks.GetRef(), Program.databanks.GetFirst(), type2, order, k_type, "_k", dlog, block, path, null, null, double.NaN, double.NaN, false);
            Sam(gt1, gt2, Program.databanks.GetRef(), Program.databanks.GetFirst(), type2, order, s_type, "_s", dlog, block, path, null, null, double.NaN, double.NaN, false);
            Sam(gt1, gt2, Program.databanks.GetRef(), Program.databanks.GetFirst(), type2, order, after_i_type, "_after_i", dlog, block, path, null, null, double.NaN, double.NaN, false);
            Sam(gt1, gt2, Program.databanks.GetRef(), Program.databanks.GetFirst(), type2, order, after_d_type, "_after_d", dlog, block, path, null, null, double.NaN, double.NaN, false);
        }

        /// <summary>
        /// Use for writing the [modelname]__info file.
        /// </summary>
        /// <returns></returns>
        public static string GetModelInfoPath()
        {
            //put in local files on user pc
            int random = Globals.modelRandomID;
            string path = Globals.localTempFilesLocation + "\\" + Globals.modelFileName.Replace(".frm", "") + "__info" + "_" + random;
            return path;
        }

        /// <summary>
        /// Simple methods for the creation of a temp folder
        /// </summary>
        public static void CreateTempFilesFolder()
        {
            if (!Directory.Exists(Globals.localTempFilesLocation))
            {
                Directory.CreateDirectory(Globals.localTempFilesLocation);
            }
        }

        /// <summary>
        /// Creates a temp folder with a random name (for instance c:\Users\Peter\AppData\Local\Gekko\Gekko\3.1.13.0\tempfiles\tempfiles_28425041).
        /// Will use Globals.tempFiles for the path, cf. CreateTempFolderPath().
        /// </summary>
        /// <param name="counter"></param>
        public static void CreateTempFilesFolder2()
        {
            if (Directory.Exists(Globals.tempFiles))  //should almost never exist, since name is random            
            {
                Directory.Delete(Globals.tempFiles, true);  //in the very rare case, any files here will be deleted first
            }
            //See also #87f897aiosduf
            Directory.CreateDirectory(Globals.tempFiles);
        }

        /// <summary>
        /// Method to copy gekko.chm file (help file) as a local copy, to avoid security problems regarding reading it.
        /// </summary>
        public static void CreateLocalCopyHelpChm()
        {
            if (Program.options.interface_help_copylocal)
            {
                try
                {
                    string file = "";
                    if (Program.options.folder_help != "")
                    {
                        file = Program.options.folder_help + "\\gekko.chm";
                    }
                    else file = Application.StartupPath + "\\helpfiles\\gekko.chm";
                    if (File.Exists(file))
                    {
                        string tempPath = Globals.localTempFilesLocation + "\\" + "gekko.chm";
                        if (File.Exists(tempPath))
                        {
                            File.SetAttributes(tempPath, FileAttributes.Normal);  //it may be read-only if original file is so
                            File.Delete(tempPath);
                        }

                        File.Copy(file, tempPath, true);

                        G.WritelnGray("Local copying: gekko.chm");
                    }
                }
                catch
                {
                    //do nothing, we will survive this!
                }
            }
        }

        /// <summary>
        /// Temp folder, originally used to store a .tsd file that was later zipped into .tsdx or .gbk. Now also used for other stuff.
        /// </summary>
        /// <param name="type"></param>
        /// <returns></returns>
        public static string GetTempTsdFilePath(string type)
        {
            string tempPath = null;
            for (int i = 0; i < 100; i++)
            {
                int random = Program.RandomInt(11111111, 99999999);
                tempPath = Globals.localTempFilesLocation + "\\" + "temp" + type + "file" + "_" + random + "." + type;
                if (!File.Exists(tempPath)) break; //should normally be the case
                tempPath = null;  //very rare case probably: try with new random name
            }
            if (tempPath == null)
            {
                //tried random name 100 times, this should never happen... 100 blocked files at one time not very realistic...
                new Error("Could not make local copy of tsd file (filename problem)");
                //throw new GekkoException();
            }
            return tempPath;
        }

        /// <summary>
        /// Helper for creating a random path name for temp files. See also CreateTempFilesFolder2().
        /// </summary>
        /// <returns></returns>
        public static string CreateTempFolderPath(string s)
        {
            //put in local files on user pc
            //Random r = new Random();
            int random = Program.RandomInt(11111111, 99999999);
            string path = Globals.localTempFilesLocation + "\\" + s + "_" + random;
            return path;
        }

        /// <summary>
        /// Databank compare helper (GUI method)
        /// </summary>
        public static void Sam1()
        {
            Sam(Globals.globalPeriodStart, Globals.globalPeriodEnd, Program.databanks.GetRef(), Program.databanks.GetFirst(), "", false, false);
        }

        /// <summary>
        /// Databank compare helper (GUI method)
        /// </summary>
        public static void Sam2()
        {
            Sam(Globals.globalPeriodStart, Globals.globalPeriodEnd, Program.databanks.GetRef(), Program.databanks.GetFirst(), "absolute", true, false);
        }

        /// <summary>
        /// Databank compare helper (GUI method)
        /// </summary>
        public static void Sam3()
        {
            Sam(Globals.globalPeriodStart, Globals.globalPeriodEnd, Program.databanks.GetRef(), Program.databanks.GetFirst(), "relative", true, false);
        }

        /// <summary>
        /// Databank compare helper (GUI method)
        /// </summary>
        public static void SamE1(bool dlog, bool split)
        {
            ResidualCheck("alphabetical", dlog, split);
        }

        /// <summary>
        /// Databank compare helper (GUI method)
        /// </summary>
        public static void SamE2(bool dlog, bool split)
        {
            ResidualCheck("absolute", dlog, split);
        }

        /// <summary>
        /// Databank compare helper (GUI method)
        /// </summary>
        public static void SamE3(bool dlog, bool split)
        {
            ResidualCheck("relative", dlog, split);
        }

        /// <summary>
        /// Databank compare helper (GUI method)
        /// </summary>
        public static void Sam(GekkoTime tStart, GekkoTime tEnd, Databank base2, Databank work, string type, bool order, bool history)
        {
            //Called in order to compare databanks, 5 last args inactive
            Sam(tStart, tEnd, base2, work, type, order, null, null, false, null, null, null, null, double.NaN, double.NaN, history);
        }

        /// <summary>
        /// Generic method for comparisons (comparing timeseries observations)
        /// </summary>
        /// <param name="tStart"></param>
        /// <param name="tEnd"></param>
        /// <param name="base2"></param>
        /// <param name="work"></param>
        /// <param name="compareType"></param>
        /// <param name="order"></param>
        /// <param name="variables"></param>
        /// <param name="variablesType"></param>
        /// <param name="dlog"></param>
        /// <param name="block"></param>
        /// <param name="path"></param>
        /// <param name="fileName"></param>
        /// <param name="dump"></param>
        /// <param name="crit_abs"></param>
        /// <param name="crit_rel"></param>
        public static void Sam(GekkoTime tStart, GekkoTime tEnd, Databank base2, Databank work, string compareType, bool order, List<string> variables, string variablesType, bool dlog, string block, string path, string fileName, string dump, double crit_abs, double crit_rel, bool history)
        {
            //TODO: could be more clearly coded, with 6 compareTypes (3 databank and 3 residuals), doing a 'variables == null' is not too pretty
            //TODO: error handling if var not found in one of the banks in residual check
            //TODO: option to use CalculateHistoricalVarianceForVariable() and CheckRelativeDifferenceSmart()

            if (compareType != null) compareType = compareType.ToLower();
            int seriesShown = 0;

            long lagProblem = 0;
            long lag1Problem = 0;
            long lag2Problem = 0;
            long lagCounter = 0;

            List<string> dif = new List<string>();

            // =======================================
            bool removeCurrentFreqFromNames = true;
            double crit = double.NaN;
            string type = "smart...";
            bool plot = true;
            int plotExtraPeriods = 0;
            bool residuals = false;
            // =======================================

            if (compareType == "abs" || compareType == "absolute")
            {
                compareType = "absolute";
                order = true;
            }
            else if (compareType == "rel" || compareType == "relative")
            {
                compareType = "relative";
                order = true;
            }
            else if (compareType == "alpha" || compareType == null)
            {
                compareType = "alphabetical";
                order = false;
            }
            else
            {
                new Error("Expected SORT to be alpha, abs or rel.");
                //throw new GekkoException();
            }

            if (variables != null && variables.Count == 0)
            {
                return;  //to avoid empty files, especially when dividing into blocks
            }
            SortedList ordered = new SortedList();

            string samFileName = "";

            if (!residuals)
            {
                //i.e. we are doing a databank compare, not a residual compare
                samFileName = "compare_databanks.txt";
                if (fileName != null) samFileName = fileName;
                if (!Path.HasExtension(samFileName)) samFileName = samFileName + ".txt";
                path = Program.options.folder_working;
            }
            else
            {
                string s = "";
                if (block != null)
                {
                    s = "_" + block;
                }
                samFileName = "residuals" + s + variablesType + ".txt";
            }

            List<string> onlyWork2 = new List<string>();
            List<string> onlyRef2 = new List<string>();
            List<string> both2 = new List<string>();
            List<string> differentTypeSeries2 = new List<string>();
            List<string> notFoundBoth2 = new List<string>();  //only when a list is given. Such a series is not found in either bank

            List<SamHelper> items = new List<SamHelper>();
            if (variables == null)
            {
                // --------------------------------------------
                //looping over vars in Work and Ref banks
                // --------------------------------------------

                foreach (KeyValuePair<string, IVariable> kvp in work.storage)
                {
                    string tsNameWithFreq = kvp.Key;
                    Series ts = kvp.Value as Series;
                    if (ts == null) continue;  //non-series
                    //if (ts.freq != Program.options.freq) continue;
                    Series tsGrund = base2.GetIVariable(kvp.Key) as Series;
                    if (tsGrund == null)
                    {
                        onlyWork2.Add(MaybeRemoveFreq(tsNameWithFreq, removeCurrentFreqFromNames));
                    }
                    else
                    {
                        //the series exists in both banks
                        SamHandleTwoExistingSeries(onlyWork2, onlyRef2, both2, differentTypeSeries2, items, tsNameWithFreq, ts, tsGrund, removeCurrentFreqFromNames);
                    }
                }

                foreach (KeyValuePair<string, IVariable> kvp in base2.storage)  //7737
                {
                    string tsNameWithFreq = kvp.Key;
                    Series ts = kvp.Value as Series;
                    if (ts == null) continue;  //non-series
                    //if (ts.freq != Program.options.freq) continue;
                    Series tsWork = work.GetIVariable(kvp.Key) as Series;
                    if (tsWork == null)  //otherwise we get dublets
                    {
                        onlyRef2.Add(MaybeRemoveFreq(tsNameWithFreq, removeCurrentFreqFromNames));
                    }
                }
            }
            else
            {
                // --------------------------------------------
                //looping over a given list of variables
                // --------------------------------------------

                foreach (string tsString in variables)
                {

                    IVariable iv = O.GetIVariableFromString(tsString, O.ECreatePossibilities.NoneReportError);  //no search
                    IVariable ivGrund = O.GetIVariableFromString(G.Chop_SetBank(tsString, Globals.Ref), O.ECreatePossibilities.NoneReportError);

                    string tsNameWithFreq = tsString;

                    if (iv == null && ivGrund == null)
                    {
                        notFoundBoth2.Add(MaybeRemoveFreq(tsNameWithFreq, removeCurrentFreqFromNames));
                        continue;
                    }

                    //at this point, the series exists in at least one of the banks (we know it is a series, since non-series with sigils are filtered out by name above)

                    Series ts = null;
                    Series tsGrund = null;
                    if (iv != null) ts = iv as Series;
                    if (ivGrund != null) tsGrund = ivGrund as Series;

                    if (ts == null && tsGrund == null) continue;  //this should not happen, just for safety

                    if (ts == null) onlyRef2.Add(MaybeRemoveFreq(tsNameWithFreq, removeCurrentFreqFromNames));
                    else if (tsGrund == null) onlyWork2.Add(MaybeRemoveFreq(tsNameWithFreq, removeCurrentFreqFromNames));
                    else
                    {
                        //both exist and are of series type
                        SamHandleTwoExistingSeries(onlyWork2, onlyRef2, both2, differentTypeSeries2, items, tsNameWithFreq, ts, tsGrund, removeCurrentFreqFromNames);
                    }
                }
            }

            onlyWork2.Sort(StringComparer.OrdinalIgnoreCase);
            onlyRef2.Sort(StringComparer.OrdinalIgnoreCase);
            both2.Sort(StringComparer.OrdinalIgnoreCase);
            differentTypeSeries2.Sort(StringComparer.OrdinalIgnoreCase);
            notFoundBoth2.Sort(StringComparer.OrdinalIgnoreCase);

            bool dumpList = false;

            int pcounter = 0;
            string fullPathAndFileName = path;
                        
            //28/6 2022: the above regarding file names and parts were a complete mess.
            //Tried to clean it up a bit, with the line below.
            string pathAndFilename = Program.CreateFullPathAndFileNameFromFolder(samFileName, null);

            //using (FileStream fs = WaitForFileStream(fullPathAndFileName + "\\" + samFileName, null, GekkoFileReadOrWrite.Write))
            using (FileStream fs = WaitForFileStream(pathAndFilename, null, GekkoFileReadOrWrite.Write))
            using (StreamWriter samFile = G.GekkoStreamWriter(fs))
            {

                samFile.WriteLine("Comparing first-position (" + GetDatabankFileNameWithPath(Program.databanks.GetFirst()) + ") and reference (" + GetDatabankFileNameWithPath(Program.databanks.GetRef()) + ") databanks");
                samFile.WriteLine();
                samFile.WriteLine("There are the following " + both2.Count + " series in both databanks:");
                G.PrintListWithCommasToFile(samFile, both2);
                samFile.WriteLine();
                samFile.WriteLine();
                samFile.WriteLine("There are the following " + onlyWork2.Count + " series in the first-position databank, but not in " + Globals.Ref + " databank:");
                G.PrintListWithCommasToFile(samFile, onlyWork2);
                if (onlyWork2.Count == 0) samFile.WriteLine("[none]");
                samFile.WriteLine();
                samFile.WriteLine();
                samFile.WriteLine("There are the following " + onlyRef2.Count + " series in " + Globals.Ref + " databank, but not in the first-position databank:");
                G.PrintListWithCommasToFile(samFile, onlyRef2);
                if (onlyRef2.Count == 0) samFile.WriteLine("[none]");

                if (differentTypeSeries2.Count > 0)
                {
                    samFile.WriteLine();
                    samFile.WriteLine();
                    samFile.WriteLine("The following " + differentTypeSeries2.Count + " series were of different type (array-and non-array-series):");
                    G.PrintListWithCommasToFile(samFile, differentTypeSeries2);
                    if (differentTypeSeries2.Count == 0) samFile.WriteLine("[none]");
                }

                if (notFoundBoth2.Count > 0)
                {
                    samFile.WriteLine();
                    samFile.WriteLine();
                    samFile.WriteLine("The following " + notFoundBoth2.Count + " series were not found in Work or Ref:");
                    G.PrintListWithCommasToFile(samFile, notFoundBoth2);
                    if (notFoundBoth2.Count == 0) samFile.WriteLine("[none]");
                }

                samFile.WriteLine();
                samFile.WriteLine();

                List<string> differentType = new List<string>();

                int count = 0;
                //There is a little bit unnecessary overhead here, if compareType is "alphabetical". But never mind.
                foreach (SamHelper sh in items)
                {
                    count++;
                    Series ts = sh.series1;
                    Series tsGrund = sh.series2;

                    double max = 0d;
                    double maxAbs = 0d;
                    double maxRel = 0d;

                    foreach (GekkoTime t in new GekkoTimeIterator(ConvertFreqs(tStart, tEnd, ts.freq)))
                    {
                        double varDelta = 0;
                        double varPch = 0;

                        double var1 = ts.GetDataSimple(t);
                        double var2 = tsGrund.GetDataSimple(t);
                        double var2_lag1 = tsGrund.GetDataSimple(t.Add(-1));
                        double var2_lag2 = tsGrund.GetDataSimple(t.Add(-2));

                        //we check first both 0, both M, one non-M && one M.

                        if (var1 == 0 && var2 == 0d)
                        {
                            varPch = 0d;
                            varDelta = var1 - var2;
                        }
                        else if (G.IsBothNumericalError(var1, var2)) //see also #87342543534
                        {
                            //this is considered okay
                            varPch = 0d;
                            varDelta = 0d;
                        }
                        else if ((G.isNumericalError(var1) && !G.isNumericalError(var2)) || (!G.isNumericalError(var1) && G.isNumericalError(var2)))
                        {
                            //this is considered a problem
                            varPch = 1e+100d;
                            varDelta = 1e+100;
                        }
                        else if (var2 == 0 && !history)
                        {
                            varPch = 1e+100d;
                            varDelta = var1 - var2;
                        }
                        else
                        {
                            varPch = ComparePch(history, var1, var2, var2_lag1, var2_lag2);
                            varDelta = var1 - var2;
                        }

                        if (compareType == "absolute" || compareType == "alphabetical")
                        {
                            max = Math.Max(Math.Abs(varDelta), max);
                        }
                        else if (compareType == "relative")
                        {
                            max = Math.Max(Math.Abs(varPch), max);
                        }
                        maxAbs = Math.Max(Math.Abs(varDelta), maxAbs);
                        maxRel = Math.Max(Math.Abs(varPch / 100d), maxRel);

                        if (G.isNumericalError(max))
                        {
                            //this is igonred
                        }
                    }


                    if (G.isNumericalError(max))
                    {
                        //This probably never happens... for safety...
                        max = 1e+100d;
                        maxAbs = 1e+100d;
                        maxRel = 1e+100d;
                    }

                    //if (max == 0) continue;  //don't show vars if they are identical
                    //if no <abs=...> or <rel=...> are given, crit_abs and crit_rel are = 0.

                    if (crit_abs < 0) crit_abs = 0;
                    if (crit_rel < 0) crit_rel = 0;

                    if (maxRel > crit_rel && maxAbs > crit_abs)
                    {
                        seriesShown++;
                        //show this one
                    }
                    else
                    {
                        //not shown
                        continue;
                    }

                    double max1 = max * (1d + count / 12345678912d) + count / 12345678912d;
                    if (order)
                    {
                        while (true)
                        {
                            if (ordered.ContainsKey(-max1))
                            {
                                //this is very seldom, multiply with something small and add something small
                                //Random r = new Random();
                                double r2 = Program.RandomDouble();
                                max = max * (1 + r2 / 1000000d) + r2 / 1000000d;
                            }
                            else break;
                        }
                    }

                    if (order)
                    {
                        ordered.Add(-max1, sh);
                    }
                    else
                    {
                        string key = sh.series1.GetNameWithoutCurrentFreq(true);
                        if (!ordered.ContainsKey(key)) ordered.Add(key, sh);  //skip dublets here when printing
                    }
                }

                //databank compare
                samFile.WriteLine("Out of the " + both2.Count + " common series, there are differences regarding " + ordered.Count + " of them:");
                if (ordered.Count == 0) samFile.WriteLine("[none]");
                samFile.WriteLine();

                long counter = 0;                
                foreach (DictionaryEntry de in ordered)
                {
                    counter++;

                    SamHelper sh = (SamHelper)de.Value;

                    string tsString = sh.series1.name;

                    double number = 0;
                    if (order)
                    {
                        number = (double)de.Key;
                    }

                    Series ts = sh.series1;
                    Series tsGrund = sh.series2;

                    string name = null;

                    if (removeCurrentFreqFromNames)
                    {
                        name = ts.GetNameWithoutCurrentFreq(true);
                    }
                    else
                    {
                        name = ts.GetName();
                    }

                    dif.Add(name);

                    if (variables == null)
                    {
                        samFile.Write(G.varFormat(name) + "   WORK       REFERENCE             ABS DIFF      % DIFF");
                    }
                    else
                    {
                        samFile.Write(G.varFormat(name) + "   FRML       DATABANK              ABS DIFF      % DIFF");
                    }

                    if (history)
                    {
                        samFile.Write("     % HIST");
                    }

                    if (dlog)
                    {
                        samFile.Write("       DLOG");
                    }

                    if (order)
                    {
                        if (compareType == "relative")
                        {
                            samFile.WriteLine("         max = " + G.pchFormatOld(-number));
                        }
                        else
                        {
                            samFile.WriteLine("         max = " + G.levelFormatOld(-number));
                        }
                    }
                    else
                    {
                        samFile.WriteLine();
                    }

                    samFile.Write("-------------------------------------------------------------------");
                    if (history) samFile.WriteLine("------------");
                    if (dlog) samFile.WriteLine("------------");
                    samFile.WriteLine();
                    int tCounter = -1;
                    foreach (GekkoTime t in new GekkoTimeIterator(ConvertFreqs(tStart, tEnd, ts.freq)))
                    {
                        tCounter++;
                        double var1 = 0;
                        double var2 = 0;
                        double var2_lag1 = 0;
                        double var2_lag2 = 0;
                        double varDelta = 0;
                        double varPch = 0;
                        double varDlog = double.NaN;
                        double varRelHist = double.NaN;
                        samFile.Write(t + " ");

                        {
                            var1 = ts.GetDataSimple(t);
                            var2 = tsGrund.GetDataSimple(t);
                            var2_lag1 = tsGrund.GetDataSimple(t.Add(-1));
                            var2_lag2 = tsGrund.GetDataSimple(t.Add(-2));
                            varDelta = ts.GetDataSimple(t) - tsGrund.GetDataSimple(t);
                            varPch = ((ts.GetDataSimple(t) / tsGrund.GetDataSimple(t) - 1d) * 100d);

                            if (dlog)
                            {
                                varDlog = Math.Log(tsGrund.GetDataSimple(t) / ts.GetDataSimple(t));
                            }

                            if (history && tCounter == 0)
                            {
                                if (G.isNumericalError(var2))
                                {
                                    //ok then
                                }
                                else
                                {
                                    if (G.isNumericalError(var2_lag1))
                                    {                                     
                                        lag1Problem++;
                                    }
                                    if (G.isNumericalError(var2_lag2))
                                    {                                        
                                        lag2Problem++;
                                    }
                                    if (G.isNumericalError(var2_lag1) || G.isNumericalError(var2_lag2))
                                    {
                                        lagProblem++;
                                    }
                                    lagCounter++;
                                }
                                varRelHist = ComparePch(history, var1, var2, var2_lag1, var2_lag2);
                            }

                            samFile.Write(G.levelFormatOld(var1));
                            samFile.Write(" ");
                            samFile.Write(G.levelFormatOld(var2));
                            samFile.Write("       ");
                            samFile.Write(G.levelFormatOld(varDelta));
                            samFile.Write("    ");
                            if (varDelta == 0d) varPch = 0d; //this way, two clean 0's get 0% difference
                            samFile.Write(G.pchFormatOld(varPch));
                            if (history)
                            {
                                samFile.Write("    ");
                                samFile.Write(G.pchFormatOld(varRelHist, 8));
                            }
                            if (dlog)
                            {
                                samFile.Write("    ");
                                samFile.Write(G.levelFormatOld(varDlog, 8));
                            }

                        }
                        samFile.WriteLine();
                    }
                    samFile.WriteLine();
                }
                samFile.Flush();
                if (G.Equal(dump, "yes"))
                {
                    List m = new Gekko.List(dif);
                    Program.databanks.GetFirst().AddIVariableWithOverwrite(Globals.symbolCollection + "dif", m);
                    dumpList = true;
                }
            }
            G.Writeln2("Databank compare on " + both2.Count + " common series, " + ordered.Count + " differences shown in file '" + samFileName + "'");
            if (dumpList) G.Writeln2("List " + Globals.symbolCollection + "dif contains the " + dif.Count + " different variables");
            if (notFoundBoth2.Count > 0)
            {
                new Note(notFoundBoth2.Count + " series not found");
            }
            double l = (double)lagProblem / (double)lagCounter;
            double l1 = (double)lag1Problem / (double)lagCounter;
            double l2 = (double)lag2Problem / (double)lagCounter;
            if (history && lagCounter > 0 && l > 0.8d)
            {
                using (Warning txt = new Warning())
                {
                    txt.MainAdd("There are many missing values when computing historical variability for " + tStart.ToString() + ".");
                    txt.MoreAdd("For the period " + tStart.Add(-1).ToString() + ", " + Math.Round(l1 * 100, 0) + "% of reference databank values are missing values, ");
                    txt.MoreAdd("and for the period " + tStart.Add(-2).ToString() + ", " + Math.Round(l2 * 100, 0) + "% of reference databank values are missing values.");
                    txt.MoreAdd("Therefore, in " + tStart.ToString() + ", the relative check will be of limited value and will seldom make an impact (instead the absolute criterium will be dominant).");                    
                }
            }
        }

        /// <summary>
        /// Relative difference, where a "standard deviation" of the ref values is used. Note: percent (multiplied by 100), not relative.
        /// </summary>
        /// <param name="history"></param>
        /// <param name="var1"></param>
        /// <param name="var2"></param>
        /// <param name="var2_lag1"></param>
        /// <param name="var2_lag2"></param>
        /// <returns></returns>
        private static double ComparePch(bool history, double var1, double var2, double var2_lag1, double var2_lag2)
        {
            double varPch;
            if (history)
            {
                //This corresponds perfectly with the way convergence is checked in gauss-seidel SIM (per default)
                double d = (Math.Abs(var2 - var2_lag1) + Math.Abs(var2_lag1 - var2_lag2)) / 2;
                //if (G.isNumericalError(d)) d = 1e+100d;
                varPch = Math.Abs(var1 - var2) / d * 100d;  //if d provides NaN, varPch = 0 almost, and only abs check is performed.
                if (G.isNumericalError(varPch)) varPch = 1e+100d;
            }
            else
            {
                varPch = ((var1 / var2 - 1d) * 100d);
            }

            return varPch;
        }

        /// <summary>
        /// Pick out a freq from ConvertDateFreqsToAllFreqs(). Used to convert frequencies.
        /// </summary>
        /// <param name="tStart"></param>
        /// <param name="tEnd"></param>
        /// <param name="tsFreq"></param>
        /// <returns></returns>
        public static Tuple<GekkoTime, GekkoTime> ConvertFreqs(GekkoTime tStart, GekkoTime tEnd, EFreq tsFreq)
        {
            //========================================================================================================
            //                          FREQUENCY LOCATION, indicates where to implement more frequencies
            //========================================================================================================

            AllFreqsHelper dates = G.ConvertDateFreqsToAllFreqs(tStart, tEnd);
            GekkoTime tStart2 = GekkoTime.tNull;
            GekkoTime tEnd2 = GekkoTime.tNull;
            if (tsFreq == EFreq.A)
            {
                tStart2 = dates.t1Annual;
                tEnd2 = dates.t2Annual;
            }
            else if (tsFreq == EFreq.Q)
            {
                tStart2 = dates.t1Quarterly;
                tEnd2 = dates.t2Quarterly;
            }
            else if (tsFreq == EFreq.M)
            {
                tStart2 = dates.t1Monthly;
                tEnd2 = dates.t2Monthly;
            }
            else if (tsFreq == EFreq.W)
            {
                tStart2 = dates.t1Weekly;
                tEnd2 = dates.t2Weekly;
            }
            else if (tsFreq == EFreq.D)
            {
                tStart2 = dates.t1Daily;
                tEnd2 = dates.t2Daily;
            }
            else if (tsFreq == EFreq.U)
            {
                tStart2 = dates.t1Undated;
                tEnd2 = dates.t2Undated;
            }
            return new Tuple<GekkoTime, GekkoTime>(tStart2, tEnd2);
        }

        /// <summary>
        /// Used to convert frequencies. Allows startEnd to be = null, if input freq is higher than output freq
        /// </summary>
        /// <param name="t"></param>
        /// <param name="tsFreq"></param>
        /// <param name="startEnd"></param>
        /// <returns></returns>
        public static GekkoTime ConvertFreq(GekkoTime t, EFreq tsFreq, string startEnd)
        {
            if (startEnd == null)
            {
                GekkoTime t1 = GekkoTime.ConvertFreqsFirst(tsFreq, t, null);
                GekkoTime t2 = GekkoTime.ConvertFreqsLast(tsFreq, t);
                if (!t1.EqualsGekkoTime(t2)) new Error("Cannot convert " + t.ToString() + " to " + tsFreq.Pretty() + " frequency without indicating 'start' or 'end' parameter.");
                return t1;  //same as t2
            }
            else if (G.Equal(startEnd, "start"))
            {
                return GekkoTime.ConvertFreqsFirst(tsFreq, t, null);
            }
            else if (G.Equal(startEnd, "end"))
            {
                return GekkoTime.ConvertFreqsLast(tsFreq, t);
            }
            else
            {
                new Error("Expected 'start' or 'end' argument, not '" + startEnd + "'");
                return GekkoTime.tNull;
            }
        }

        /// <summary>
        /// Optionally remove freq from name if it is same as current freq (this is done for printing purposes).
        /// </summary>
        /// <param name="s1"></param>
        /// <param name="removeCurrentFreqFromNames"></param>
        /// <returns></returns>
        private static string MaybeRemoveFreq(string s1, bool removeCurrentFreqFromNames)
        {
            if (removeCurrentFreqFromNames) return G.Chop_RemoveFreq(s1, G.ConvertFreq(Program.options.freq));
            else return s1;
        }

        /// <summary>
        /// Helper method for Sam() method.
        /// </summary>
        /// <param name="onlyWork2"></param>
        /// <param name="onlyRef2"></param>
        /// <param name="both2"></param>
        /// <param name="differentTypeSeries2"></param>
        /// <param name="items"></param>
        /// <param name="tsNameWithFreq"></param>
        /// <param name="ts"></param>
        /// <param name="tsGrund"></param>
        /// <param name="removeCurrentFreqFromNames"></param>
        private static void SamHandleTwoExistingSeries(List<string> onlyWork2, List<string> onlyRef2, List<string> both2, List<string> differentTypeSeries2, List<SamHelper> items, string tsNameWithFreq, Series ts, Series tsGrund, bool removeCurrentFreqFromNames)
        {
            if (ts.type != tsGrund.type)
            {
                differentTypeSeries2.Add(MaybeRemoveFreq(tsNameWithFreq, removeCurrentFreqFromNames));
            }
            else
            {
                if (ts.type == ESeriesType.ArraySuper)
                {
                    //both series are array-series, compare the subseries
                    if (ts.dimensions != tsGrund.dimensions)
                    {
                        //different number of dimensions
                        differentTypeSeries2.Add(MaybeRemoveFreq(tsNameWithFreq, removeCurrentFreqFromNames));
                    }
                    else
                    {
                        foreach (KeyValuePair<MultidimItem, IVariable> kvpsub in ts.dimensionsStorage.storage)
                        {
                            if (tsGrund.dimensionsStorage.storage.ContainsKey(kvpsub.Key))
                            {
                                //present both places, for instance x['a', 'b'] both places
                                //these two are going to be checked
                                both2.Add(MaybeRemoveFreq(tsNameWithFreq, removeCurrentFreqFromNames) + "[" + kvpsub.Key.ToString() + "]");
                                items.Add(new SamHelper() { series1 = kvpsub.Value as Series, series2 = tsGrund.dimensionsStorage.storage[kvpsub.Key] as Series });
                            }
                            else
                            {
                                onlyWork2.Add(MaybeRemoveFreq(tsNameWithFreq, removeCurrentFreqFromNames) + "[" + kvpsub.Key.ToString() + "]");
                            }
                        }

                        foreach (KeyValuePair<MultidimItem, IVariable> kvpsub in tsGrund.dimensionsStorage.storage)
                        {
                            if (ts.dimensionsStorage.storage.ContainsKey(kvpsub.Key))
                            {
                                //ignore, has been dealt with above
                            }
                            else
                            {
                                onlyRef2.Add(MaybeRemoveFreq(tsNameWithFreq, removeCurrentFreqFromNames) + "[" + kvpsub.Key.ToString() + "]");
                            }
                        }
                    }
                }
                else
                {
                    both2.Add(MaybeRemoveFreq(tsNameWithFreq, removeCurrentFreqFromNames));
                    items.Add(new SamHelper() { series1 = ts, series2 = tsGrund });
                }
            }
        }

        /// <summary>
        /// Used for PIPE&lt;stop&gt;
        /// </summary>
        public static void ReleasePipe()
        {
            //In order to release any current piping to file, so it does not block other users
            if (Globals.pipeFileHelper.pipeFile != null)
            {
                Globals.pipeFileHelper.CloseFile();
            }
            Globals.pipeFileHelper.pipeFile = null;
            Globals.pipeFileHelper.pipeFileFileWithPath = "";
            Globals.pipe = false;
        }

        /// <summary>
        /// Used for PIPE&lt;stop&gt;
        /// </summary>
        public static void ReleasePipe2()
        {
            //Release piping to file when doing stuff like "prt fy file=output.txt"
            if (Globals.pipeFileHelper2.pipeFile != null)
            {
                Globals.pipeFileHelper2.CloseFile();
            }
            Globals.pipeFileHelper2.pipeFile = null;
            Globals.pipeFileHelper2.pipeFileFileWithPath = "";
            Globals.pipe2 = false;
        }

        /// <summary>
        /// Used when writing list of options on screen.
        /// </summary>
        /// <param name="s"></param>
        /// <returns></returns>
        public static string MaybeAddPointAndZero(string s)
        {
            bool isInt = true;
            foreach (char c in s)
            {
                if (!Char.IsDigit(c)) isInt = false;
            }
            if (isInt) s = s + ".0";  //so it does not look like an integer -- user can see it is float
            return s;
        }

        /// <summary>
        /// Used when printing a list of databanks, where the .gbk extension is not needed.
        /// </summary>
        /// <param name="databank"></param>
        /// <returns></returns>
        public static string GetDatabankFilename(Databank databank)
        {
            return System.IO.Path.GetFileName(databank.FileNameWithPathPretty);
        }

        /// <summary>
        /// Used for TABLE command 
        /// </summary>
        /// <param name="inputFileName"></param>
        /// <param name="menuTable"></param>
        /// <returns></returns>
        public static string TableHelper(string inputFileName, bool menuTable, P p)
        {
            //This is called from "TABLE filename.tab" command, including calls from menus which
            //will issue such a command in a thread (is so, menuTable is true).

            //inputFileName = Program.SubstituteAssignVarsInExpression(inputFileName);
            inputFileName = G.AddExtension(inputFileName, "." + Globals.extensionTable);

            List<string> folders = new List<string>();

            folders.Add(Program.options.folder_table);
            folders.Add(Program.options.folder_table1);
            folders.Add(Program.options.folder_table2);
            if (menuTable)  //never done for normal table call
            {
                folders.Add(Path.GetDirectoryName(inputFileName));
                //Called from menus, a .gtb file will always be with a full path.
                //But we want it to look in other folders too, so we strip the
                //path (added to folders above) and keep the filename.
                inputFileName = Path.GetFileName(inputFileName);
            }

            FindFileHelper ffh = FindFile(inputFileName, folders, true, true, p);
            string fileNameTemp = ffh.realPathAndFileName;

            if (fileNameTemp == null)
            {
                string s = FileNotFoundErrorMessage(ffh.prettyPathAndFileName);
                MessageBox.Show(s);
                throw new GekkoException();
            }
            else inputFileName = fileNameTemp;
            return inputFileName;
        }

        /// <summary>
        /// Used for CLONE and READ commands. Makes ref databank an excact copy of first-pos dabank.
        /// </summary>
        public static void MulbkClone()
        {
            Databank first = Program.databanks.GetFirst();
            //DateTime dt3 = DateTime.Now;
            Databank secondary = Program.databanks.GetRef();
            secondary.Clear();
            G.CloneDatabank(secondary, first);
            secondary.FileNameWithPath = first.FileNameWithPath; secondary.FileNameWithPathPretty = first.FileNameWithPathPretty;
        }

        /// <summary>
        /// Helper method for SIM (model solver)
        /// </summary>
        /// <param name="endoNoLagPointers"></param>
        public static void CreateEndoNoLagBNumbers(int[] endoNoLagPointers)
        {
            Program.model.modelGekko.endogenousBNumbersOriginalInModelList = new List<int>();
            for (int i = 0; i < Program.model.modelGekko.varsBType.Count; i++)
            {
                if (endoNoLagPointers[i] != 1)
                {
                    continue;
                }
                Program.model.modelGekko.endogenousBNumbersOriginalInModelList.Add(i);
            }
        }

        /// <summary>
        /// For an endogenous variable, prints the ingoing variables and
        /// values of these.
        /// </summary>
        /// <param name="t">Time period</param>
        /// <param name="var1">Variable name</param>
        public static void PrintEquationVariables(GekkoTime t, string var1)
        {
            bool success = false;
            foreach (EquationHelper eh in Program.model.modelGekko.equations)
            {
                if (G.Equal(eh.lhs, var1))
                {
                    PrintEquationVariables(t, eh);
                    success = true;
                }
            }
            if (!success) new Error("Variable " + var1 + " was not found as left-hand side variable in model", false);
        }

        /// <summary>
        /// For an equation number, prints the ingoing variables and
        /// values of these.
        /// </summary>
        /// <param name="t">Time period</param>
        /// <param name="eqNumber">Equation number</param>
        public static void PrintEquationVariables(GekkoTime t, EquationHelper eh)
        {
            int widthRemember = Program.options.print_width;
            Program.options.print_width = int.MaxValue;

            try
            {
                G.Writeln(eh.equationText);
            }
            finally
            {
                //resetting, also if there is an error
                Program.options.print_width = widthRemember;
            }

            string lhs = eh.lhs;
            Dictionary<string, string> precedents = eh.precedentsWithLagIndicator;
            string period = t.ToString();

            Series tsls = Program.databanks.GetFirst().GetIVariable(lhs + Globals.freqIndicator + G.ConvertFreq(Program.options.freq)) as Series;  //#getvar

            if (tsls == null)
            {
                new Error("Variable '" + lhs + "' does not exist in Work databank");
                //throw new GekkoException();
            }

            G.Writeln();
            string period2 = "period " + period;
            //G.Writeln("Time period = " + period);
            G.Writeln("              " + (G.Blanks(14 - period2.Length) + period2) + "       %");

            G.Writeln("----------------------------------------");
            G.Write(lhs + G.Blanks(14 - lhs.Length));
            double t1 = tsls.GetDataSimple(t.Add(0));
            double t0 = tsls.GetDataSimple(t.Add(0 - 1));
            double pch = (t1 / t0 - 1) * 100d;
            if (t1 - t0 == 0d) pch = 0d;  //this way, two clean 0's get 0% difference
            string pch1 = G.pchFormatOld(pch);
            G.Writeln(G.levelFormatOld(t1) + " " + pch1);
            G.Writeln("----------------------------------------");
            foreach (string var in precedents.Keys)
            {
                string variable; int lag;
                G.ExtractVariableAndLag(var, out variable, out lag);
                string var2 = "";
                if (lag != 0)
                {
                    var2 = variable + "[" + lag + "]";
                }
                else
                {
                    var2 = variable;
                }
                G.Write(var2 + G.Blanks(14 - var2.Length));
                Series ts = Program.databanks.GetFirst().GetIVariable(variable + Globals.freqIndicator + G.ConvertFreq(Program.options.freq)) as Series;

                if (variable == null)
                {
                    new Error("Variable '" + variable + "' does not exist in Work databank");
                    //throw new GekkoException();
                }

                t1 = ts.GetDataSimple(t.Add(lag));
                t0 = ts.GetDataSimple(t.Add(lag - 1));
                pch = (t1 / t0 - 1) * 100d;
                if (t1 - t0 == 0d) pch = 0d;  //this way, two clean 0's get 0% difference
                pch1 = G.pchFormatOld(pch);
                G.Writeln(G.levelFormatOld(t1) + " " + pch1);
            }
            //G.Writeln();
            G.Writeln("----------------------------------------");
            G.Writeln("Use 'DISP <" + G.FromDateToString(t) + " " + G.FromDateToString(t) + " info> variable;' or 'DECOMP <" + G.FromDateToString(t) + " " + G.FromDateToString(t) + "> variable;' to trace further.");
            G.Writeln();
        }

        /// <summary>
        /// Used for AREMOS, but will soon be completely legacy.
        /// </summary>
        public static void MakeBatFileForAremos()
        {
            GuiDialogMakeBatfile xx = new GuiDialogMakeBatfile(true);
            xx.ShowDialog();
            xx.Close();
        }

        /// <summary>
        /// Actually deletes the files (both cache and gnuplot files)
        /// </summary>
        private static void FlushHelper()
        {
            try
            {
                Directory.Delete(Globals.localTempFilesLocation, true);
            }
            catch { };

            try
            {
                Directory.Delete(Globals.localTempFilesLocationGnuplot, true);
            }
            catch { };

            //This is necessary regarding the first, but in principle not regarding the two next.

            try
            {
                Directory.CreateDirectory(Globals.localTempFilesLocation);
            }
            catch { };

            try
            {
                Directory.CreateDirectory(Globals.localTempFilesLocationGnuplot);
            }
            catch { };

            try
            {
                Directory.CreateDirectory(Globals.localTempFilesLocationGnuplot + "\\tempfiles");
            }
            catch { };
        }

        [ProtoContract]
        public class ReadInfo
        {
            public static GekkoTime tStart = GekkoTime.tNull;
            public static GekkoTime tEnd = GekkoTime.tNull;
            public string fileName = null;
            public string fileNamePretty = null;
            public string dbName = null; //internal name for the RAM databank (key in hashtable of databanks)            
            public int variables;
            public int startPerInFile = -12345;
            public int endPerInFile = -12345;
            public int startPerResultingBank = -12345;
            public int endPerResultingBank = -12345;
            public int createdVars;
            public int nanCounter;

            public double time = 0d;
            public Databank databank = null;
            public bool conversionMessage = false;
            public bool abortedStar = false;
            public bool open = false;
            public bool shouldMerge = false;
            public string pcim = "";  //only used for PCIM databanks.
            public string note = null;
            public string gamsNote = null;

            // ------- from XML
            public string databankVersion = "";
            public string info1 = null;  //from XML
            public string date;  //from XML
            public string modelName;  //from XML
            public string modelInfo;  //from XML
            public string modelDate;  //from XML
            public string modelSignature;  //from XML
            public string modelHash;  //from XML
            public string modelLastSimPeriod;  //from XML
            public string modelLastSimStamp;  //from XML
            public string modelLargestLag;  //from XML
            public string modelLargestLead;  //from XML

            public void Print()
            {
                string fileNameWithPathPretty = null;
                string fileNameWithoutPathPretty = null;
                string fileNameNamePretty = null;
                string fileNameExtensionPretty = null;
                if (this.fileName != null)
                {
                    fileNameWithPathPretty = this.fileNamePretty;
                    fileNameWithoutPathPretty = Path.GetFileNameWithoutExtension(this.fileNamePretty);
                    fileNameNamePretty = Path.GetFileName(this.fileNamePretty);
                    fileNameExtensionPretty = Path.GetExtension(this.fileNamePretty);
                }
                else
                {
                    if (Globals.excelDna)
                    {
                        fileNameWithPathPretty = "[Gekcel]";
                        fileNameWithoutPathPretty = "[Gekcel]";
                        fileNameNamePretty = "[Gekcel]";
                        fileNameExtensionPretty = "[xlsx]";
                    }
                }

                if (this.databank == null || this.databank.storage.Count == 0) return;  //no printing of these
                Table tab = new Table();
                tab.CurRow.SetTopBorder(1, 1);
                //this strange stuff is sometimes read from PCIM databanks
                string strange = "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0";
                string info = this.info1;
                if (info == null || info == "" || info == strange) info = "[empty]";
                string date = this.date;
                if (date == null || date == "" || date == strange) date = "[empty]";
                string ext = "";
                if (fileNameExtensionPretty.ToLower() == "bnk") ext = ".bnk";
                tab.CurRow.SetText(1, "DATABANK " + fileNameWithoutPathPretty);
                tab.CurRow.SetBottomBorder(1, 1);
                tab.CurRow.Next();
                tab.CurRow.SetText(1, "Info     : " + info);
                tab.CurRow.Next();
                tab.CurRow.SetText(1, "Date     : " + date);
                tab.CurRow.Next();
                if (open)
                {
                    tab.CurRow.SetText(1, "Open     : Opened " + fileNameNamePretty + " as '" + this.dbName + "'");
                    tab.CurRow.Next();
                }
                tab.CurRow.SetText(1, "File     : " + fileNameWithPathPretty + " " + this.databankVersion);
                tab.CurRow.Next();

                string i1, i2; GetYearPeriod(this.startPerInFile, this.endPerInFile, out i1, out i2);

                tab.CurRow.SetText(1, "Period   : The file contains data from " + i1 + "-" + i2);
                tab.CurRow.Next();
                //#8572309572439
                int total = Program.databanks.GetDatabank(this.dbName).storage.Count;
                if (this.shouldMerge)
                {
                    tab.CurRow.SetText(1, "Size     : Merged " + this.variables + " variables from file into " + this.dbName + " databank (" + G.SecondsFormat(time) + ")");
                }
                else
                {
                    if (this.open) tab.CurRow.SetText(1, "Size     : Read " + this.variables + " variables from file (" + G.SecondsFormat(time) + ")");
                    else tab.CurRow.SetText(1, "Size     : Read " + this.variables + " variables from file into cleared " + this.dbName + " databank (" + G.SecondsFormat(time) + ")");
                }

                if (!this.open && this.createdVars > 0)
                {
                    tab.CurRow.Next();
                    tab.CurRow.SetText(1, "         : Created " + this.createdVars + " model variables (filled with missing values) in " + this.dbName + " databank");
                }
                if (!this.open)
                {
                    tab.CurRow.Next();
                    tab.CurRow.SetText(1, "           " + this.dbName + " databank now contains " + total + " variables (" + this.startPerResultingBank + "-" + this.endPerResultingBank + ")");
                }
                tab.CurRow.SetText(1, "Note     : Press F2 for info on databanks. " + this.note);
                if (this.gamsNote != null)
                {
                    tab.CurRow.Next();
                    tab.CurRow.SetText(1, "GAMS     : " + this.gamsNote);
                }

                tab.CurRow.SetBottomBorder(1, 1);
                tab.CurRow.SetLeftBorder(1);
                tab.CurRow.SetRightBorder(1);

                int widthRemember = Program.options.print_width;
                Program.options.print_width = int.MaxValue;
                try
                {

                    List<string> ss = tab.Print();
                    foreach (string s in ss) G.Writeln(s);

                    if (this.modelName != null)
                    {
                        StringBuilder sb = new StringBuilder();
                        sb.AppendLine("The databank contains the following information regarding its corresponding model:");
                        sb.AppendLine("Model file name: " + this.modelName);
                        sb.AppendLine("Model info: " + this.modelInfo);
                        sb.AppendLine("Model date: " + this.modelDate);
                        sb.AppendLine("Model signature: " + this.modelSignature);
                        sb.AppendLine("Model hash code: " + this.modelHash);
                        sb.AppendLine("Model last SIM period: " + this.modelLastSimPeriod);
                        sb.AppendLine("Model last SIM stamp: " + this.modelLastSimStamp);
                        sb.AppendLine("Model largest lag/lead: " + this.modelLargestLag + "/" + this.modelLargestLead);
                        LinkContainer lc = new LinkContainer(sb.ToString());
                        Globals.linkContainer.Add(lc.counter, lc);
                        G.Write("The databank contains MODEL/SIM info ("); G.WriteLink("more", "outputtab:" + lc.counter); G.Writeln(")");
                    }
                }
                finally
                {
                    //resetting, also if there is an error
                    Program.options.print_width = widthRemember;
                }

                if (this.pcim != null && this.pcim != "")
                {
                    G.Writeln("PCIM name/model when the PCIM databank was written: " + this.pcim);
                }

                if (this.nanCounter > 0)
                {
                    new Warning("Encountered " + this.nanCounter + " instances of 'NaN' in the file. These are set to missing -- proper .tsd syntax is to use '1.000000E+15' to indicate a missing value");
                }

                if (this.conversionMessage)
                {
                    LinkContainer lc = new LinkContainer("The databank is a ." + Globals.extensionDatabank + " file version 1.0. Newer ." + Globals.extensionDatabank + " files load around three times faster, so please consider converting the " + Globals.extensionDatabank + " file. Converting from 'oldfile." + Globals.extensionDatabank + "' to 'newfile." + Globals.extensionDatabank + "' is very simple:" + G.NL + G.NL + "  READ <" + Globals.extensionDatabank + "> oldfile;" + G.NL + "  WRITE <" + Globals.extensionDatabank + "> newfile;" + G.NL + G.NL + "There is no loss of data or data quality in this process, so the new ." + Globals.extensionDatabank + " file is a perfect substitute for the old one. The difference is that these old ." + Globals.extensionDatabank + " files are not using a binary format (as the newer ones do).");
                    Globals.linkContainer.Add(lc.counter, lc);
                    G.Write("You may convert the databank file for speedier reading (", Color.Gray); G.WriteLink("more", "outputtab:" + lc.counter); G.Writeln(")", Color.Gray);
                }
            }
        }

        public static void GetYearPeriod(int startPerInFile, int endPerInFile, out string i1, out string i2)
        {
            i1 = "[year?]";
            i2 = "[year?]";
            if (startPerInFile != int.MaxValue) i1 = startPerInFile.ToString();
            if (endPerInFile != int.MinValue) i2 = endPerInFile.ToString();
        }

        [ProtoContract]
        public class OneList
        {
            [ProtoMember(1)]
            public string indexName;
            [ProtoMember(2)]
            public List<string> indexItems;
        }

        [ProtoContract]
        public class Item
        {
            [ProtoMember(1)]
            public string variable = "";
            [ProtoMember(2)]
            public List<OneList> listOfLists;
            [ProtoMember(3)]
            public List<string> explanation = new List<string>();
        }

        public class CompileErrorHelper
        {
            public List<string> text = new List<string>();
            public List<int> col = new List<int>();
            public int line = -1;
            public string file = "";
        }

        public class PrintHelper
        {
            public int widthDate = 0;
            public int width1 = 0;
            public int width2 = 0;
            public int widthLabel = 0;

        }

        public class WorkerThreadHelper1
        {
            //Titles, arrows
            public string titleField = "NULL";
            public string statusField = "NULL";
            public string leftArrow = "NULL";
            public string rightArrow = "NULL";
            public string homeButton = "NULL";
        }

        public class WorkerThreadHelper2
        {
            //For printing
            public string s;
            public string linktype;
            public bool newline;
            public Color color;
            public bool link;
            public ETabs tab;
            public bool mustScrollToEnd;
            public bool mustAlsoPrintToScreen = false;
            public EWrapType type = EWrapType.Writeln;
            public bool parentOfAll = false;

            public WorkerThreadHelper2 Clone()
            {
                WorkerThreadHelper2 wh = new WorkerThreadHelper2();
                wh.s = this.s;
                wh.linktype = this.linktype;
                wh.newline = this.newline;
                wh.color = this.color;
                wh.link = this.link;
                wh.tab = this.tab;
                wh.mustScrollToEnd = this.mustScrollToEnd;
                wh.mustAlsoPrintToScreen = this.mustAlsoPrintToScreen;
                wh.type = this.type;
                return wh;
            }
        }

        public class DecompHelper
        {
            public string variableWithLag = null;
            //public double contribution = double.NaN;
            public double x0 = double.NaN;
            public double x1 = double.NaN;  //plus epsilon
            public double z = double.NaN;
            public double y0 = double.NaN;
            public double y1 = double.NaN;  //change when x is altered from x0 to x1
            public double slope = double.NaN;
            //public double x1 = double.NaN;
            //public double d_contribution = double.NaN;
            //public double d_x0 = double.NaN;
            //public double d_x1 = double.NaN;
        }

        public class ErrorContainer
        {
            public long counter;
            public List<string> simInitEndoMissingValue = null; //a
            public List<string> simNonExistingVariable = null; //b
            public List<string> simMissingValueExoOrLaggedEndo = null;  //c
            //-----
            public List<string> simInitEndoMissingValueHelper = null; //a
            public ErrorContainer()
            {
                Globals.outputTabTextCounter += 1;
                counter = Globals.outputTabTextCounter;
            }
        }

        public class LinkContainer
        {
            public long counter;
            public string s = null;

            public LinkContainer(string si)
            {
                Globals.linkContainerCounter += 1;
                counter = Globals.linkContainerCounter;
                s = si;
            }
        }


        public class RememberWriteStatementsHelper
        {
            public List<string> linesVariables = new List<string>();
            public List<string> linesData = new List<string>();
        }

        public class Cache
        {
            Dictionary<object, object> cache = new Dictionary<object, object>();

            /// <summary>
            /// Keeps up with the most recently read items.
            /// Items at the end of the list were read last.
            /// Items at the front of the list have been the most idle.
            /// Items at the front are removed if the cache capacity is reached.
            /// </summary>
            public List<object> priority = new List<object>();
            public Type Type { get; set; }
            public Cache(Type type)
            {
                this.Type = type;
                //TODO: register this cache with the manager
            }
            public object this[object key]
            {
                get
                {
                    lock (this)
                    {
                        if (!cache.ContainsKey(key)) return null;
                        //move the item to the end of the list
                        priority.Remove(key);
                        priority.Add(key);
                        return cache[key];
                    }
                }
                set
                {
                    lock (this)
                    {
                        if (Capacity > 0 && cache.Count == Capacity)
                        {
                            cache.Remove(priority[0]);
                            priority.RemoveAt(0);
                        }
                        cache[key] = value;
                        priority.Remove(key);
                        priority.Add(key);

                        if (priority.Count != cache.Count)
                            throw new Exception("Capacity mismatch.");
                    }
                }
            }
            public int Count { get { return cache.Count; } }
            public int Capacity { get; set; }

            public void Clear()
            {
                lock (this)
                {
                    priority.Clear();
                    cache.Clear();
                }
            }
        }
    }

    /// <summary>
    /// These methods are not used at the moment, but just keep them here. May become
    /// Gekko functions later on. The functions are thoroughly tested.
    /// </summary>
    public static class Ces
    {
        // ================================================
        // CES stuff, perhaps make available in Function.cs
        // ================================================

        // with theta

        public static double CES_XL(double yrel, double p1rel, double p2rel, double theta, double sigma)
        {
            double uc = CES_UC(p1rel, p2rel, theta, sigma);
            return yrel * Math.Pow(uc / p1rel, sigma);
        }

        public static double CES_XR(double yrel, double p1rel, double p2rel, double theta, double sigma)
        {
            double uc = CES_UC(p1rel, p2rel, theta, sigma);
            return yrel * Math.Pow(uc / p2rel, sigma);
        }

        public static double C(double ca, double p1, double p2, double p1a, double p2a, double theta, double sigma)
        {
            double c = ca * CES_UC(p1 / p1a, p2 / p2a, theta, sigma);
            return c;
        }

        public static double CES_UC(double p1rel, double p2rel, double theta, double sigma)
        {
            double c = Math.Pow(theta * Math.Pow(p1rel, 1 - sigma) + (1 - theta) * Math.Pow(p2rel, 1 - sigma), 1 / (1 - sigma));
            return c;
        }

        public static double Y(double x1, double x2, double ya, double x1a, double x2a, double theta, double sigma)
        {
            double rho = (sigma - 1) / sigma;
            double y_cal = ya * Math.Pow((theta * Math.Pow(x1 / x1a, rho) + (1 - theta) * Math.Pow(x2 / x2a, rho)), 1 / rho);
            return y_cal;
        }

        // -------

        // with delta

        public static double Y_orig(double x1, double x2, double kappa, double delta, double sigma)
        {
            double rho = (sigma - 1) / sigma;
            double y = kappa * Math.Pow(delta * Math.Pow(x1, rho) + (1 - delta) * Math.Pow(x2, rho), 1 / rho);
            return y;
        }

        public static double X1_orig(double y, double p1, double p2, double kappa, double delta, double sigma)
        {
            double x1 = y / kappa * Math.Pow((delta * kappa * AC_orig(p1, p2, kappa, delta, sigma)) / p1, sigma);
            return x1;
        }

        public static double X2_orig(double y, double p1, double p2, double kappa, double delta, double sigma)
        {
            double x2 = y / kappa * Math.Pow(((1 - delta) * kappa * AC_orig(p1, p2, kappa, delta, sigma)) / p2, sigma);
            return x2;
        }

        public static double C_orig(double y, double p1, double p2, double kappa, double delta, double sigma)
        {
            double c = y * AC_orig(p1, p2, kappa, delta, sigma);
            return c;
        }

        public static double AC_orig(double p1, double p2, double kappa, double delta, double sigma)
        {
            double ac = 1 / kappa * Math.Pow(Math.Pow(delta, sigma) * Math.Pow(p1, 1 - sigma) + Math.Pow(1 - delta, sigma) * Math.Pow(p2, 1 - sigma), 1 / (1 - sigma));
            return ac;
        }

        // ================================================
        // CES stuff end
        // ================================================
    }

    public class LocalGlobal
    {
        public enum ELocalGlobalType
        {
            Local,
            Global,
            None
        }

        private ELocalGlobalType all = ELocalGlobalType.None;
        private GekkoDictionary<string, ELocalGlobalType> storage = null;

        public void SetAllLocal()
        {
            if (this.Count() > 0 || all != ELocalGlobalType.None)
            {
                new Error("LOCAL<all> must be the only LOCAL/GLOBAL statement");
                //throw new GekkoException();
            }
            this.all = ELocalGlobalType.Local;
        }

        public void SetAllGlobal()
        {
            if (this.Count() > 0 || all != ELocalGlobalType.None)
            {
                new Error("GLOBAL<all> must be the only LOCAL/GLOBAL statement");
                //throw new GekkoException();
            }
            this.all = ELocalGlobalType.Global;
        }

        public int Count()
        {
            if (this.storage == null) return 0;
            return this.storage.Count;
        }

        public ELocalGlobalType GetValue(string s)
        {
            if (this.all != ELocalGlobalType.None) return this.all;
            if (this.storage == null) return ELocalGlobalType.None;
            ELocalGlobalType rv;
            if (storage.TryGetValue(s, out rv))  //cannot be out rv, because if TryGetValue() fails, it returns the default value of the enum, and that is brittle
            {
                return rv;
            }
            return ELocalGlobalType.None;
        }


        public void Add(string s, ELocalGlobalType type)
        {
            if (this.all != ELocalGlobalType.None)
            {
                new Error("Failed because " + this.all.ToString().ToUpper() + "<all> been set previously");
                //throw new GekkoException();
            }
            if (this.storage == null) this.storage = new GekkoDictionary<string, ELocalGlobalType>(StringComparer.OrdinalIgnoreCase);
            if (this.storage.ContainsKey(s))
            {
                new Error("The variable '" + s + "' is already set as " + this.storage[s].ToString().ToUpper());
                //throw new GekkoException();
            }
            this.storage.Add(s, type);
        }
    }


    public class LocalBanks
    {
        public Databank localWork = null;
        public Databank localBase = null;
    }

    public class PrtHelperElement
    {
        //public string printCode = null;  //will be OBSOLETE
        public List<string> operators = new List<string>();
        public int width = -12345;
        public int dec = -12345;
        public int nwidth = -12345;
        public int ndec = -12345;
        public int pwidth = -12345;
        public int pdec = -12345;
    }

    public class PrtHelper
    {
        public string prtType = null;  //prt, mulprt, pctprt etc.
        public List<PrtHelperElement> elementOptions = null;
        public List<string> operators = new List<string>();
        //public string printCode = null; // m, d, p, q, etc. --> will be OBSOLETE
        public string printType = null; //PRT, SHEET, CSHEET, PLOT, etc.
        public bool rows = false;
        public int width = -12345;
        public int dec = -12345;
        public int nwidth = -12345;
        public int ndec = -12345;
        public int pwidth = -12345;
        public int pdec = -12345;
        //stuff for VPRT ------------------------
        public bool timeSpanShouldBeSetGlobally = false;
        //stuff mostly for Excel ----------------
        public string title = null;
        public string heading = null;
        public string stamp = null;
        public string fileName = null;
        public string sheet = null;
        public string cell = null;
        public string transpose = null;
        public string dates = null;
        public string labels = null;
        public string colors = null;
        public string append = null;
        public string timefilter = null;
        //general stuff -------------------------
        public bool isGmulprt = false;  //overrules a lot of the others
        public bool isVprt = false;  //overrules a lot of the others
        public bool isCalledFromGraphWindow = false;
    }

    public class PrtPplotHelper
    {
        public bool isDecomp = false;
        public bool isDecompToExcel = false;
        public bool onlyDoTimeseriesCheck = false;
        public bool isGmulprt = false;
        public bool isVprt = false;
        public bool timeSpanShouldBeSetGlobally = false;

        public string prtCsSnippet;

    }



    public class PrtOptionsHelper
    {
        public bool isLevel = false;
        public bool isLog = false;
        public bool isPch = false;
        public bool isDiff = false;
        public bool isDlog = false;
        public bool isMultiplier = false;
        public bool isBaseline = false;
        public bool printPeriod = true;
        public string title = "";
        public string heading = "";
        public bool isGmulprt = false;  //overrules a lot of the others
        public bool isVprt = false;  //overrules a lot of the others
        public bool isDp = false;  //code "dp"
        public bool isMp = false;  //code "mp"
        public bool timeSpanShouldBeSetGlobally = false;  //only used for VPRT, PRT etc. puts it inside ConvertToGekkoTiIme()
        public bool isCalledFromGraphWindow = false;
        public string pplotType = "emf";
    }

    public class IterMemory
    {
        public double[] bBefore;
        public double[] bAfter;
    }

    public class ExcelOptions
    {
        public string printOptions = null;
        public string title = null;
        public string heading = null;
        public string stamp = null;
        public string fileName = null;
        public string sheet = null;
        public string cell = null;
        public string transpose = null;
        public string dates = null;
        public string labels = null;
        public string colors = null;
        public string append = null;
        public bool isClip = false;
        public string[,] excelRowLabels = null;
        public string[,] excelColumnLabels = null;
        public GekkoTime[,] excelColumnLabelsGekkoTime = null;
        public double[,] excelData = null;
    }

    public class Wildcard : Regex
    {
        /// <summary>
        /// Initializes a wildcard with the given search pattern.
        /// </summary>
        /// <param name="pattern">The wildcard pattern to match.</param>
        public Wildcard(string pattern)
            : base(WildcardToRegex(pattern))
        {
        }

        /// <summary>
        /// Initializes a wildcard with the given search pattern and options.
        /// </summary>
        /// <param name="pattern">The wildcard pattern to match.</param>
        /// <param name="options">A combination of one or more
        /// <see cref="System.Text.RegexOptions"/>.</param>
        public Wildcard(string pattern, RegexOptions options)
            : base(WildcardToRegex(pattern), options)
        {
        }

        /// <summary>
        /// Converts a wildcard to a regex.
        /// </summary>
        /// <param name="pattern">The wildcard pattern to convert.</param>
        /// <returns>A regex equivalent of the given wildcard.</returns>
        public static string WildcardToRegex(string pattern)
        {
            return "^" + Regex.Escape(pattern).
             Replace("\\*", ".*").
             Replace("\\?", ".") + "$";
        }
    }

    public class ExcelDataForClip
    {
        public bool transpose = false;
        public double[,] data;
        public string[,] varnames;
        public string[,] dates;
        public string stamp = null;
        public string heading = null;
    }

    public enum EHasShownErrorHandling
    {
        True,
        TrueAndAlsoSkippedLines,
        False
    }

    public enum EDataFormat
    {
        None,
        Tsd,
        Tsdx,
        Gbk,
        Tsp,
        Csv,
        Prn,
        Pcim,
        Px,
        Flat,
        Xls,
        Xlsx,
        Gdx,
        Aremos
    }

    public enum EOpenType
    {
        Normal,
        Edit, //OPEN<edit>, not used elsewhere
        First, //READ<first>, CLEAR<first>, etc. 
        Sec,
        Last,
        Pos,
        Ref //READ<ref>, CLEAR<ref>, etc.
    }

    public class ReadOpenMulbkHelper
    {
        public GekkoTime t1 = GekkoTime.tNull;
        public GekkoTime t2 = GekkoTime.tNull;
        public List<List<string>> openFileNames = null;
        private string fileName = null;
        private EDataFormat type = EDataFormat.None;  //type of data(bank)
        private bool merge = false;  //merge or not.
        private string as2 = null; //for OPEN AS.
        private string orientation = null;  //rows or cols
        public EOpenType openType = EOpenType.Normal;
        public int openTypePosition = -12345;
        public bool editable = false;
        public string gdxopt = null;
        public string array = null;
        public string dateformat = null;
        public string datetype = null;
        public string sheet = null;
        public bool isVariablecode = false;

        public string FileName
        {
            get { return fileName; }
            set { fileName = value; }
        }

        public EDataFormat Type
        {
            get { return type; }
            set { type = value; }
        }

        public bool Merge
        {
            get { return merge; }
            set { merge = value; }
        }

        public string As
        {
            get { return as2; }
            set { as2 = value; }
        }

        public string Orientation
        {
            get { return orientation; }
            set { orientation = value; }
        }

    }


    public class P
    {
        public bool hasWrittenRunTimeErrorOnce = false;  //bit hacky
        public EHasShownErrorHandling hasShownErrorHandling = EHasShownErrorHandling.False;
        private int counter = 0;  //1 gets added soon enough
        //private Q[] stackQ = new Q[200]; //contains arguments to different methods, new object put in here every time a new .cmd file is run.
        private string[] stack = new string[200];  //2000 nested cmd files -- should be enough
        private string[] stackCommandFileText = new string[200];
        private string[] stackFileSentToAntlr = new string[200];
        private string[] stackCurrentLibrary = new string[200];
        public string lastFileSentToANTLR = null;
        public string currentLibrary = null;
        public bool isOneLinerFromGui = false;
        public bool hasBeenCmdFile = false;
        //public bool hasBeenIsstartCmdFile = false;
        public bool hasBeenClosebanks = false;
        public bool canShowErrorDialog = true;
        public DateTime timeAtLastUserInteraction = DateTime.Now;
        public DateTime startingTime = DateTime.Now;
        public bool hasBeenCompilationError = false;
        public int hasSeenStopCommand = 0; //if 0, no STOP is encountered. Can also be 1 or 2.
        private GekkoDictionary<string, int> commandFileCounter = new GekkoDictionary<string, int>(StringComparer.OrdinalIgnoreCase);
        private GekkoDictionary<string, string> commandFileCounterTainted = new GekkoDictionary<string, string>(StringComparer.OrdinalIgnoreCase);
        public int numberOfServiceMessages = 0;

        public string GetStack(int i)
        {
            return stack[i];
        }

        public string GetLastFileSentToANTLR(int i)
        {
            return stackFileSentToAntlr[i];
        }


        public bool IsSimple()
        {
            if (this.isOneLinerFromGui && this.counter <= 1)
            {
                return true;
            }
            return false;
        }

        public string GetStackCommandFileText(int i)
        {
            return stackCommandFileText[i];
        }

        public string GetCurrentLibrary(int i)
        {
            return stackCurrentLibrary[i];
        }

        public int GetDepth()
        {
            return counter;
        }

        public int GetDepthM1()
        {
            return counter - 1;
        }

        public void SetLastFileSentToANTLR(string s)
        {
            //This method is called in translated code, for each line (that is not "simple", ie. FOR, IF etc.)
            this.stackFileSentToAntlr[counter] = s;
        }

        public void SetStack(string s)
        {
            //This method is called in translated code, for each line (that is not "simple", ie. FOR, IF etc.)

            string file = "";
            if (counter > 0) file = this.stackFileSentToAntlr[counter - 1];  //counter will probably always be 1 or larger when this method is called
            this.stack[counter] = file + s;
            ReportToRunStatus(false);
        }

        public void SetCommandFileText(string s)
        {
            this.stackCommandFileText[counter] = s;
        }

        /// <summary>
        /// This library name is always == null for running gcm files, or for functions/procedures defined
        /// in a normal gcm file. The library name is only != null when a function or procedure is loaded
        /// from a library zip file. In that case, the library name is burned into the function/procedure while
        /// parsing (cf. LocalCode1()).
        /// </summary>
        /// <param name="s"></param>
        public void SetCurrentLibrary(string s)
        {
            this.stackCurrentLibrary[counter] = s;
        }

        public void Deeper()
        {
            //if (Globals.runningOnTTComputer) G.Writeln2("DEEPER " + this.counter, Color.Green);
            this.counter++;
        }

        public void RemoveLast()
        {
            //if (Globals.runningOnTTComputer) G.Writeln2("REMOVELAST " + this.counter, Color.Green);
            if (this.counter > 0)
            {
                string temp = this.stack[counter];
                if (temp != null)
                {
                    if (this.commandFileCounter.ContainsKey(temp))
                    {
                        this.commandFileCounter[temp]++;
                    }
                    else
                    {
                        this.commandFileCounter.Add(temp, 1);
                    }

                    if (this.hasShownErrorHandling == EHasShownErrorHandling.True)
                    {
                        //Such a file will be given status "Failed" instead of "Ok".
                        //files with omitted lines will keep "Ok" status, it is up to
                        //the user to remember that he or she is skipping stuff (the number
                        //of skipped lines will be reported at the end, though).
                        //A file with syntax problems is considered unseen, until
                        //it can be parsed, compiled and run.
                        if (!this.commandFileCounterTainted.ContainsKey(temp))
                        {
                            this.commandFileCounterTainted.Add(temp, "");
                        }
                    }
                }
                this.stack[counter] = null;
                this.stackCommandFileText[counter - 1] = null;
                this.stackFileSentToAntlr[counter - 1] = null;
                this.stackCurrentLibrary[counter - 1] = null;

            }
            this.counter--;
        }

        public void ReportToRunStatus(bool enforce)  //enforce forces update, even if little time has elaspsed
        {
            if (Globals.windowRunStatus == null) return;

            DateTime d = DateTime.Now;
            if (!enforce && (d - Globals.windowRunStatusLastCall).TotalMilliseconds < 250) return;
            Globals.windowRunStatusLastCall = d;

            bool stackTab = false;
            bool runTab = false;
            if (Globals.windowRunStatusIsStackTab) stackTab = true;
            else runTab = true;
            if (enforce)
            {
                stackTab = true;
                runTab = true;
            }

            if (stackTab)
            {
                ObservableCollection<RunStatusData> items = new ObservableCollection<RunStatusData>();
                int max = this.GetDepth();
                int start = 1;
                if (this.isOneLinerFromGui) start = 2;  //do not show the 1 user input line starting it all (will be a run statement anyway, if starting a job)
                for (int i = start; i <= max; i++)  //index 0 is not used
                {
                    int lineNumber2;
                    string fileCalled;
                    List<string> commandLines2;
                    //Note: may return '[?]' as file
                    Program.GetErrorLineAndText(this, i, out lineNumber2, out fileCalled, out commandLines2);
                    string line = "?";
                    if (lineNumber2 > 0) line = lineNumber2.ToString();
                    if (lineNumber2 == 0)
                    {
                        continue;  //most of these null-nodes are filtered out, seems a few are left...
                    }
                    if (fileCalled == "[?]")
                    {
                        continue; //filtered out, seems it does not happen anymore...
                    }
                    string calling = "";
                    if (i - start > 0) calling = "...calling:";

                    string fileName = Path.GetFileName(fileCalled);
                    string fileNameAndPath = fileCalled;
                    if (i - start == 0 && fileCalled == "")
                    {
                        fileName = "[User input lines]";
                        fileNameAndPath = "[Multiple lines marked in Main window]";
                    }
                    RunStatusData data = new RunStatusData(fileName, line, fileNameAndPath, calling, null);
                    items.Add(data);
                }
                Gekko.CrossThreadStuff.StackTrace(items);
            }

            if (runTab)
            {
                List<RunStatusData> items = new List<RunStatusData>();
                //ObservableCollection<RunStatusData> items = new ObservableCollection<RunStatusData>();

                foreach (KeyValuePair<string, int> kvp in this.commandFileCounter)
                {
                    string lineText;
                    int lineNumber2;
                    Program.SplitCommandBeingExecuted(out lineText, out lineNumber2, kvp.Key);
                    if (lineText != null && lineText != "")
                    {
                        string status = "OK";
                        if (this.commandFileCounterTainted.ContainsKey(kvp.Key)) status = "Failed";
                        RunStatusData data = new RunStatusData(Path.GetFileName(lineText), kvp.Value.ToString(), lineText, null, status);
                        items.Add(data);
                    }
                }
                items.Sort();
                ObservableCollection<RunStatusData> items2 = new ObservableCollection<RunStatusData>();
                foreach (RunStatusData r in items) items2.Add(r);
                Gekko.CrossThreadStuff.RunStatus(items2);
            }
        }
    }

    class XmlColInfo
    {
        public Attrib attrib = new Attrib();
        public List<string> subcolborders = new List<string>();  //for now this is not really used, but will be later on
    }

    class Attrib
    {
        public Dictionary<string, string> data = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
        public string Get(string s)
        {
            string t = null; data.TryGetValue(s, out t);
            return t;
        }
        public bool Set(string s, string t)
        {
            if (data.ContainsKey(s)) return false;
            data[s] = t;
            return true;
        }
    }

    class XmlHelper
    {
        public StringBuilder s = new StringBuilder();
        public StringBuilder sEnd = new StringBuilder();
        public List<int> colLeftBorders = new List<int>();
        public List<int> colRightBorderPlusOne = new List<int>();
        public int totalCols = 0;
        public int totalRows = 0;
        public bool probe = true;
        public Attrib table = new Attrib();
        public List<XmlColInfo> cols = new List<XmlColInfo>();
        public Attrib rowGlobal = new Attrib();
        public List<int> colA = new List<int>();  //not sure what this is... seems not used at all: nothing is ever added to it
        public List<int> colB = new List<int>();  //not sure what this is... seems not used at all: nothing is ever added to it
        public int rowCounter = 0;
        public bool isLastRow = false;
    }

    public class Utf8Checker
    {
        public static bool Check(string fileName)
        {
            using (BufferedStream fstream = new BufferedStream(File.OpenRead(fileName)))
            {
                return IsUtf8(fstream);
            }
        }

        /// <summary>
        /// Check if stream is utf8 encoded.
        /// Notice: stream is read completely in memory!
        /// </summary>
        /// <param name="stream">Stream to read from.</param>
        /// <returns>True if the whole stream is utf8 encoded.</returns>
        public static bool IsUtf8(Stream stream)
        {
            int count = 4 * 1024;
            byte[] buffer;
            int read;
            while (true)
            {
                buffer = new byte[count];
                stream.Seek(0, SeekOrigin.Begin);
                read = stream.Read(buffer, 0, count);
                if (read < count)
                {
                    break;
                }
                buffer = null;
                count *= 2;
            }
            return IsUtf8(buffer, read);
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="buffer"></param>
        /// <param name="length"></param>
        /// <returns></returns>
        public static bool IsUtf8(byte[] buffer, int length)
        {
            int position = 0;
            int bytes = 0;
            while (position < length)
            {
                if (!IsValid(buffer, position, length, ref bytes))
                {
                    return false;
                }
                position += bytes;
            }
            return true;
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="buffer"></param>
        /// <param name="position"></param>
        /// <param name="length"></param>
        /// <param name="bytes"></param>
        /// <returns></returns>
        public static bool IsValid(byte[] buffer, int position, int length, ref int bytes)
        {
            if (length > buffer.Length)
            {
                throw new ArgumentException("Invalid length");
            }

            if (position > length - 1)
            {
                bytes = 0;
                return true;
            }

            byte ch = buffer[position];

            if (ch <= 0x7F)
            {
                bytes = 1;
                return true;
            }

            if (ch >= 0xc2 && ch <= 0xdf)
            {
                if (position >= length - 2)
                {
                    bytes = 0;
                    return false;
                }
                if (buffer[position + 1] < 0x80 || buffer[position + 1] > 0xbf)
                {
                    bytes = 0;
                    return false;
                }
                bytes = 2;
                return true;
            }

            if (ch == 0xe0)
            {
                if (position >= length - 3)
                {
                    bytes = 0;
                    return false;
                }

                if (buffer[position + 1] < 0xa0 || buffer[position + 1] > 0xbf ||
                    buffer[position + 2] < 0x80 || buffer[position + 2] > 0xbf)
                {
                    bytes = 0;
                    return false;
                }
                bytes = 3;
                return true;
            }


            if (ch >= 0xe1 && ch <= 0xef)
            {
                if (position >= length - 3)
                {
                    bytes = 0;
                    return false;
                }

                if (buffer[position + 1] < 0x80 || buffer[position + 1] > 0xbf ||
                    buffer[position + 2] < 0x80 || buffer[position + 2] > 0xbf)
                {
                    bytes = 0;
                    return false;
                }

                bytes = 3;
                return true;
            }

            if (ch == 0xf0)
            {
                if (position >= length - 4)
                {
                    bytes = 0;
                    return false;
                }

                if (buffer[position + 1] < 0x90 || buffer[position + 1] > 0xbf ||
                    buffer[position + 2] < 0x80 || buffer[position + 2] > 0xbf ||
                    buffer[position + 3] < 0x80 || buffer[position + 3] > 0xbf)
                {
                    bytes = 0;
                    return false;
                }

                bytes = 4;
                return true;
            }

            if (ch == 0xf4)
            {
                if (position >= length - 4)
                {
                    bytes = 0;
                    return false;
                }

                if (buffer[position + 1] < 0x80 || buffer[position + 1] > 0x8f ||
                    buffer[position + 2] < 0x80 || buffer[position + 2] > 0xbf ||
                    buffer[position + 3] < 0x80 || buffer[position + 3] > 0xbf)
                {
                    bytes = 0;
                    return false;
                }

                bytes = 4;
                return true;
            }

            if (ch >= 0xf1 && ch <= 0xf3)
            {
                if (position >= length - 4)
                {
                    bytes = 0;
                    return false;
                }

                if (buffer[position + 1] < 0x80 || buffer[position + 1] > 0xbf ||
                    buffer[position + 2] < 0x80 || buffer[position + 2] > 0xbf ||
                    buffer[position + 3] < 0x80 || buffer[position + 3] > 0xbf)
                {
                    bytes = 0;
                    return false;
                }

                bytes = 4;
                return true;
            }

            return false;
        }
    }


    public class CompareHelper
    {
        public CompareHelper(GekkoTime g1, GekkoTime g2)
        {
            t1 = g1;
            t2 = g2;
        }
        public GekkoTime t1;
        public GekkoTime t2;
    }

    public class PipeFileHelper
    {
        public string pipeFileFileWithPath = "";
        public StreamWriter pipeFile = null;
        public bool pipeFileTypeIsHtml = false;
        public string htmlEndingTagsStuff = "";  //this is going to be appended to a html file when the pipe stops.
                                                 //public bool isPiping = true;

        public void CloseFile()
        {
            if (pipeFileTypeIsHtml)
            {
                pipeFile.Write(htmlEndingTagsStuff);
            }
            this.pipeFile.Flush();
            this.pipeFile.Close();
            this.pipeFile.Dispose();

            //this.pipeFile.BaseStream.Flush();  --> does not work
            //this.pipeFile.BaseStream.Close();
            //this.pipeFile.BaseStream.Dispose();
        }
    }

    public class HPfilter
    {
        public double[] HPFilter(double[] data, double lambda)
        {
            {
                {
                    int N = data.Length;
                    int K;
                    double[] a = new double[N];
                    double[] b = new double[N];
                    double[] c = new double[N];

                    // Elemente der Haupt- und Nebendiagonalen

                    a[0] = 1 + lambda;
                    b[0] = -2 * lambda;
                    c[0] = lambda;
                    for (K = 1; K < N - 2; K++)
                    {
                        a[K] = 6 * lambda + 1;
                        b[K] = -4 * lambda;
                        c[K] = lambda;
                    }
                    a[1] = 5 * lambda + 1;
                    a[N - 1] = 1 + lambda;
                    a[N - 2] = 5 * lambda + 1;
                    b[0] = -2 * lambda;
                    b[N - 2] = -2 * lambda;
                    b[N - 1] = 0;
                    c[N - 2] = 0;
                    c[N - 1] = 0;

                    data = pentas(a, b, c, data, N);

                    return data;


                }
            }
        }

        static double[] pentas(double[] a, double[] b, double[] c, double[] data, int N)
        {
            /*
             *  Schneller Algorithmus zur Lösung des LGS BxX=Y
             * unter Berücksichtigung, dass B eine pentadiagonale Matrix ist
             * siehe z.B. Helmut Späth "Numerik, Eine Einführung für
             * Mathematiker und Informatiker", S. 110 ff, Braunschweig &
             * Wiesbaden, 1994
             *
            */

            int K;
            double H1 = 0;
            double H2 = 0;
            double H3 = 0;
            double H4 = 0;
            double H5 = 0;
            double HH1 = 0;
            double HH2 = 0;
            double HH3 = 0;
            double HH4 = 0;
            double HH5 = 0;
            double Z;
            double HB;
            double HC;

            // Vorwärts
            for (K = 0; K < N; K++)
            {
                Z = a[K] - H4 * H1 - HH5 * HH2;
                HB = b[K];
                HH1 = H1;
                H1 = (HB - H4 * H2) / Z;
                b[K] = H1;
                HC = c[K];
                HH2 = H2;
                H2 = HC / Z;
                c[K] = H2;
                a[K] = (data[K] - HH3 * HH5 - H3 * H4) / Z;
                HH3 = H3;
                H3 = a[K];
                H4 = HB - H5 * HH1;
                HH5 = H5;
                H5 = HC;
            }

            // Rückwärts
            H2 = 0;
            H1 = a[N - 1];
            data[N - 1] = H1;

            for (K = N - 2; K > -1; K--)
            {

                data[K] = a[K] - b[K] * H1 - c[K] * H2;
                H2 = H1;
                H1 = data[K];
            }
            return data;
        }
    }


    public enum ECellLightType
    {
        None,
        String,
        Double,
        DateTime
    }

    public struct CellLight
    {
        public double data;
        public string text;
        public DateTime dateTime;
        public ECellLightType type;
        public bool hasQuotes;

        public CellLight(double input)
        {
            text = null;
            data = input;
            dateTime = DateTime.MinValue;
            type = ECellLightType.Double;
            hasQuotes = false;
        }

        public CellLight(DateTime input)
        {
            text = null;
            data = double.NaN;
            dateTime = input;
            type = ECellLightType.DateTime;
            hasQuotes = false;
        }

        public CellLight(string input)
        {
            text = input;
            data = double.NaN;
            dateTime = DateTime.MinValue;
            type = ECellLightType.String;
            hasQuotes = false;
        }

        public CellLight(string input, bool hasQuotes2)
        {
            text = input;
            data = double.NaN;
            dateTime = DateTime.MinValue;
            type = ECellLightType.String;
            hasQuotes = hasQuotes2;
        }

        public string ToString()
        {
            string rv = "---null---";
            if (this.type == ECellLightType.DateTime)
            {
                rv = "a date";
            }
            else if (this.type == ECellLightType.Double)
            {
                rv = this.data.ToString();
            }
            else if (this.type == ECellLightType.String)
            {
                rv = this.text;
            }
            return rv;
        }
    }

    public class FrameLightRow
    {
        public List<CellLight> storage = null;

        public FrameLightRow(FrameLight frame)
        {
            this.storage = new List<CellLight>(new CellLight[frame.colnames.Count]); //fills it with "null"-objects  t);            
        }

        public void Set(FrameLight frame, string colname, CellLight cell)
        {
            int i = FindColumn(frame, colname);
            this.storage[i] = cell;
        }

        public CellLight Get(FrameLight frame, string colname)
        {
            int i = FindColumn(frame, colname);
            return this.storage[i];
        }

        public static bool HasColumn(FrameLight frame, string colname)
        {
            for (int i = 0; i < frame.colnames.Count; i++)
            {
                if (G.Equal(frame.colnames[i], colname)) return true;
            }
            return false;
        }

        public static int FindColumn(FrameLight frame, string colname)
        {
            int j = -12345;
            for (int i = 0; i < frame.colnames.Count; i++)
            {
                if (G.Equal(frame.colnames[i], colname)) j = i;
            }
            if (j == -12345)
            {
                new Error("Could not find name '" + G.HandleInternalIdentifyer1(colname) + "'");
            }
            return j;
        }
    }

    public class FrameFilter
    {
        public string name = null;
        public List<string> selected = null;
        public bool active = false;
    }

    public class FrameLight
    {
        public List<FrameLightRow> rows = new List<FrameLightRow>();
        public List<string> colnames = new List<string>(); //must be lowercase

        public void AddColName(string colname)
        {
            if (!this.colnames.Contains(colname, StringComparer.OrdinalIgnoreCase))
            {
                this.colnames.Add(colname);
                for (int i = 0; i < this.rows.Count; i++)
                {
                    this.rows[i].storage.Add(new CellLight());
                }
            }
        }
    }

    public class TableLight
    {
        Dictionary<long, CellLight> storage = new Dictionary<long, CellLight>();
        private int rowMax = int.MinValue;
        private int colMax = int.MinValue;
        public string prnOrientation = null;

        private long GetKey(int row, int col)
        {
            //seems we can safely assume number of rows and cols < 2.147.483.647!
            return (long)row + (long)int.MaxValue * (long)col;
        }

        public int GetRowMaxNumber()
        {
            return rowMax;
        }

        public int GetColMaxNumber()
        {
            return colMax;
        }

        public void Add(int row, int col, CellLight value)
        {
            if (row > rowMax) rowMax = row;
            if (col > colMax) colMax = col;
            long key = GetKey(row, col);
            storage.Add(key, value);
        }

        public CellLight Get(int row, int col)
        {
            long key = GetKey(row, col);
            CellLight cell = new CellLight(); storage.TryGetValue(key, out cell);
            //if it does not exist, the cell will have .type = None.
            return cell;
        }

        public bool ContainsKey(int row, int col)
        {
            long key = GetKey(row, col);
            return storage.ContainsKey(key);
        }

        public TableLight Transpose()
        {
            TableLight ttable = new TableLight();
            foreach (KeyValuePair<long, CellLight> kvp in this.storage)
            {
                int row = (int)(kvp.Key % int.MaxValue);
                int col = (int)(kvp.Key / int.MaxValue);
                ttable.Add(col, row, kvp.Value);
            }
            return ttable;
        }
    }


    public class ModelCommentsHelper
    {
        public string infoText = null;
        public string dateText = null;
        public ESignatureStatus signatureStatus;
        public string signatureFoundInFileHeader = null;
        public int infoCounter = 0;
        public int dateCounter = 0;
        public int signatureCounter = 0;
        public string modelHashTrue = null;
        public string cutout_varlist;
        public string cutout_runbefore;
        public string cutout_runafter;

    }

    public class RunStatusData : INotifyPropertyChanged, IComparable<RunStatusData>
    {
        private string name;
        private string value;
        private string fullName;
        private string calling;
        private string status;
        public event PropertyChangedEventHandler PropertyChanged;

        //public int Compare(RunStatusData x, RunStatusData y)
        //{
        //    return string.Compare(x.Name, y.Name);
        //}

        public int CompareTo(RunStatusData other)
        {
            return string.Compare(this.Name, other.Name);
        }

        public string Name
        {
            get { return this.name; }
            set
            {
                this.name = value;
                OnPropertyChanged("Name");
            }
        }
        public string Value
        {
            get { return this.value; }
            set
            {
                this.value = value;
                OnPropertyChanged("Value");
            }
        }
        public string FullName
        {
            get { return this.fullName; }
            set
            {
                this.fullName = value;
                OnPropertyChanged("FullName");
            }
        }
        public string Calling
        {
            get { return this.calling; }
            set
            {
                this.calling = value;
                OnPropertyChanged("Calling");
            }
        }
        public string Status
        {
            get { return this.status; }
            set
            {
                this.status = value;
                OnPropertyChanged("Status");
            }
        }

        public RunStatusData(string s1, string s2, string s3, string s4, string s5)
        {
            this.Name = s1;
            this.Value = s2;
            this.FullName = s3;
            this.Calling = s4;
            this.Status = s5;
        }

        // Create the OnPropertyChanged method to raise the event
        protected void OnPropertyChanged(string name)
        {
            PropertyChangedEventHandler handler = PropertyChanged;
            if (handler != null)
            {
                handler(this, new PropertyChangedEventArgs(name));
            }
        }
    }

    public class SimOptions
    {
        public string method = "";
        public bool isEigen = false;
        public bool isFix = false;
        public YesNoNull isStatic = YesNoNull.Null;
    }

    /// <summary>
    /// Wrapper for dictionaries used in GAMS scalar model. This issue is that keys are represented
    /// as for instance "x[a,b]", note no blanks. So the wrapper is to absolutely ensure that we avoid blanks-gotchas,
    /// for instance if querying "x[a, b]".
    /// </summary>
    [ProtoContract]
    public class GekkoDictionaryDimensional
    {
        [ProtoMember(1)]
        private GekkoDictionary<string, int> storage = new GekkoDictionary<string, int>(StringComparer.OrdinalIgnoreCase);

        /// <summary>
        /// Add something. Beware: case-insensitive keys. The input string may contain blanks,
        /// which will be removed before add ("x[a, b]" becomes "x[a,b]").
        /// </summary>
        /// <param name="s"></param>
        /// <param name="i"></param>
        public void Add(string s, int i, bool willRemoveBlanks)
        {
            if (willRemoveBlanks) this.storage.Add(G.ReplaceBlanks(s), i);
            else this.storage.Add(s, i);
        }

        /// <summary>
        /// Overload.
        /// </summary>
        /// <param name="s"></param>
        /// <param name="i"></param>
        public void Add(string s, int i)
        {
            Add(s, i, true);
        }

        /// <summary>
        /// Add something, if it is not already present. Beware: case-insensitive keys. The input string may contain blanks,
        /// which will be removed before add ("x[a, b]" becomes "x[a,b]").
        /// </summary>
        /// <param name="s"></param>
        /// <param name="i"></param>
        /// <param name="willRemoveBlanks"></param>
        public void AddIfNotAlreadyThere(string s, int i, bool willRemoveBlanks)
        {
            string s2 = null;
            if (willRemoveBlanks) s2 = G.ReplaceBlanks(s);
            else s2 = s;
            if (!this.storage.ContainsKey(s2))
            {
                this.storage.Add(s2, i);
            }
        }

        public void AddIfNotAlreadyThere(string s, int i)
        {
            AddIfNotAlreadyThere(s, i, true);
        }

        /// <summary>
        /// See if s is in dictionary. Beware: case-insensitive keys. The input string may contain blanks,
        /// which will be removed ("x[a, b]" becomes "x[a,b]").
        /// Note: if key is not found, the method returns -12345.
        /// </summary>
        /// <param name="s"></param>
        /// <returns></returns>
        public int Get(string s, bool willRemoveBlanks)
        {
            string s2 = null;
            if (willRemoveBlanks) s2 = G.ReplaceBlanks(s);
            else s2 = s;
            int i; bool b = this.storage.TryGetValue(s2, out i);  //is set to 0 if not found
            if (!b) i = -12345;
            return i;
        }

        /// <summary>
        /// Overload, removes blanks from input string.
        /// </summary>
        /// <param name="s"></param>
        /// <returns></returns>
        public int Get(string s)
        {
            return Get(s, true);
        }

        public int Count()
        {
            return this.storage.Count;
        }
        
        /// <summary>
        /// Only intended to be used when iterating!
        /// </summary>
        /// <returns></returns>
        public GekkoDictionary<string, int> GetDictionaryForIteration()
        {
            return this.storage;
        }
    }

    public class GekkoDictionary<TKey, TValue> : Dictionary<TKey, TValue>
    {
        public GekkoDictionary()
            : base()
        {
            if (typeof(TKey) == typeof(string))
            {
                //string keys should be called with ignorecase
                new Error("Technical error 437834873");
            }
        }
        //public GekkoDictionary(int capacity) : base(capacity) { }  //not used
        public GekkoDictionary(IEqualityComparer<TKey> comparer)
            : base(comparer)
        {
            if (typeof(TKey) == typeof(string))
            {
                if (comparer != StringComparer.OrdinalIgnoreCase)
                {
                    //string keys should be called with ignorecase
                    new Error("Technical error 437834874");
                }
            }
        }

        //Would be nice to be able override the indexer, but this does not seem possible...
        //Anyway, nice to have a special wrapper for Dictionaries
    }

    public enum EExtrackBankAndRest
    {
        OnlyStrings,
        OnlyStringNoFirstName,
        GetDatabank,
        GetDatabankAndTimeSeries
    }

    public class ExtractBankAndRestHelper
    {
        //public bool simpleNameWithoutAtOrBank = false;
        public string bank;
        public string name;
        public Databank databank;
        public Series ts;
        public bool hasColon = false;
    }

    public class SearchHelper1
    {
        public SearchHelper2 allBanks = new SearchHelper2();
        public SearchHelper2 allFreqs = new SearchHelper2();
        public SearchHelper2 allBanksAndFreqs = new SearchHelper2();
    }

    public class SearchHelper2
    {
        public string name = null;
        public string nameOriginal = null;
        public int count = 0;
    }

    public class GAMSScalarModelSettings
    {
        // --- these can be loaded from ModelInfo.json file
        public bool scalarMemoryModelProducedByGekko = false;
        // ---------- read from file ----------------
        public string zipFilePathAndName = null;  //the file that contains it all
        public FindFileHelper ffh_unrolledModel = null; //GAMS scalar model, with variables x1, x2, x3, ...
        public FindFileHelper ffh_unrolledNames = null; //Translation of x1, x2, x3, ... into "normal" variables
        public FindFileHelper ffh_rawModel = null; //non-unrolled equations        
        public string unrolledModel = null; //raw filename without path
        public string unrolledNames = null; //raw filename without path
        public string rawModel = null; //raw filename without path        
        // ---------- read from memory ----------------
        public List<string> equations = null;
        public List<string> dictionary = null;

    }

    public class Speed
    {
        public static void Run()
        {
            Serializer.PrepareSerializer<Test>();
            var list = new List<byte[]>();
            for (int i = 0; i < 1000000; i++)
            {
                using (var ms = new MemoryStream())
                {
                    Serializer.Serialize<Test>(ms, new Test() { Value = "some text " + i });
                    list.Add(ms.ToArray());
                }
            }

            var watch = new Stopwatch();

            var output = new Test[list.Count];

            G.Writeln();                        
            G.Write("   with Parallel.ForEach (Deserialize): ");
            watch.Restart();
            Parallel.ForEach(list, () => 0, (x, pls, index, s) =>
            {
                //See https://github.com/protobuf-net/protobuf-net/issues/668
                //About double speed on TT pc, compared to no parallel
                output[(int)index] = Deserialize<Test>(x);
                return 0;
            }, _ => { });
            G.Writeln(watch.ElapsedMilliseconds.ToString() + "ms");

            
            G.Write("   with AsParallel (DummyWork): ");
            watch.Restart();
            list.AsParallel().WithExecutionMode(ParallelExecutionMode.ForceParallelism).Select((x, i) =>
            {
                output[i] = DummyWork<Test>(x);
                return true;
            }).All(_ => _);
            G.Writeln(watch.ElapsedMilliseconds.ToString() + "ms");
        }

        private static T Deserialize<T>(ReadOnlyMemory<byte> buffer)
        {            
            //ReadOnlySpan<byte> xx = (ReadOnlySpan<byte>)buffer;  //Span is on the heap (not good), and is not faster when tested
            return Serializer.Deserialize<T>(buffer);
        }

        private static T DummyWork<T>(byte[] buffer)
        {
            using (var ms = new MemoryStream(buffer))
            {
                for (int i = 0; i < 10000; i++) { var x = 100 / 10; }
                return default(T);
            }
        }

        [ProtoContract]
        public sealed class Test
        {
            [ProtoMember(1)]
            public string Value;
        }
    }
}
